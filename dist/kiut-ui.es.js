import { defineComponent as Te, shallowRef as z0, h as Ef, ref as wi, onMounted as V0, onUnmounted as jS, watch as qd, toRaw as Lf, nextTick as $0, version as XS, isProxy as H0, createElementBlock as O, openBlock as L, createVNode as Ze, unref as Z, computed as J, normalizeStyle as Ur, createCommentVNode as ct, createElementVNode as S, toDisplayString as F, Fragment as Nt, renderList as ve, createStaticVNode as zt, onBeforeUnmount as qS, withDirectives as Hp, vShow as Yp, createTextVNode as vu, createBlock as Y0 } from "vue";
function Yo(e) {
  return e + 0.5 | 0;
}
const Bn = (e, t, i) => Math.max(Math.min(e, i), t);
function Us(e) {
  return Bn(Yo(e * 2.55), 0, 255);
}
function Un(e) {
  return Bn(Yo(e * 255), 0, 255);
}
function hn(e) {
  return Bn(Yo(e / 2.55) / 100, 0, 1);
}
function Wp(e) {
  return Bn(Yo(e * 100), 0, 100);
}
const Je = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Of = [..."0123456789ABCDEF"], ZS = (e) => Of[e & 15], KS = (e) => Of[(e & 240) >> 4] + Of[e & 15], Jo = (e) => (e & 240) >> 4 === (e & 15), QS = (e) => Jo(e.r) && Jo(e.g) && Jo(e.b) && Jo(e.a);
function JS(e) {
  var t = e.length, i;
  return e[0] === "#" && (t === 4 || t === 5 ? i = {
    r: 255 & Je[e[1]] * 17,
    g: 255 & Je[e[2]] * 17,
    b: 255 & Je[e[3]] * 17,
    a: t === 5 ? Je[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (i = {
    r: Je[e[1]] << 4 | Je[e[2]],
    g: Je[e[3]] << 4 | Je[e[4]],
    b: Je[e[5]] << 4 | Je[e[6]],
    a: t === 9 ? Je[e[7]] << 4 | Je[e[8]] : 255
  })), i;
}
const t2 = (e, t) => e < 255 ? t(e) : "";
function e2(e) {
  var t = QS(e) ? ZS : KS;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + t2(e.a, t) : void 0;
}
const i2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function W0(e, t, i) {
  const n = t * Math.min(i, 1 - i), r = (a, s = (a + e / 30) % 12) => i - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
  return [r(0), r(8), r(4)];
}
function n2(e, t, i) {
  const n = (r, a = (r + e / 60) % 6) => i - i * t * Math.max(Math.min(a, 4 - a, 1), 0);
  return [n(5), n(3), n(1)];
}
function r2(e, t, i) {
  const n = W0(e, 1, 0.5);
  let r;
  for (t + i > 1 && (r = 1 / (t + i), t *= r, i *= r), r = 0; r < 3; r++)
    n[r] *= 1 - t - i, n[r] += t;
  return n;
}
function a2(e, t, i, n, r) {
  return e === r ? (t - i) / n + (t < i ? 6 : 0) : t === r ? (i - e) / n + 2 : (e - t) / n + 4;
}
function Zd(e) {
  const i = e.r / 255, n = e.g / 255, r = e.b / 255, a = Math.max(i, n, r), s = Math.min(i, n, r), o = (a + s) / 2;
  let l, u, c;
  return a !== s && (c = a - s, u = o > 0.5 ? c / (2 - a - s) : c / (a + s), l = a2(i, n, r, c, a), l = l * 60 + 0.5), [l | 0, u || 0, o];
}
function Kd(e, t, i, n) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, i, n)).map(Un);
}
function Qd(e, t, i) {
  return Kd(W0, e, t, i);
}
function s2(e, t, i) {
  return Kd(r2, e, t, i);
}
function o2(e, t, i) {
  return Kd(n2, e, t, i);
}
function U0(e) {
  return (e % 360 + 360) % 360;
}
function l2(e) {
  const t = i2.exec(e);
  let i = 255, n;
  if (!t)
    return;
  t[5] !== n && (i = t[6] ? Us(+t[5]) : Un(+t[5]));
  const r = U0(+t[2]), a = +t[3] / 100, s = +t[4] / 100;
  return t[1] === "hwb" ? n = s2(r, a, s) : t[1] === "hsv" ? n = o2(r, a, s) : n = Qd(r, a, s), {
    r: n[0],
    g: n[1],
    b: n[2],
    a: i
  };
}
function u2(e, t) {
  var i = Zd(e);
  i[0] = U0(i[0] + t), i = Qd(i), e.r = i[0], e.g = i[1], e.b = i[2];
}
function c2(e) {
  if (!e)
    return;
  const t = Zd(e), i = t[0], n = Wp(t[1]), r = Wp(t[2]);
  return e.a < 255 ? `hsla(${i}, ${n}%, ${r}%, ${hn(e.a)})` : `hsl(${i}, ${n}%, ${r}%)`;
}
const Up = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Gp = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function h2() {
  const e = {}, t = Object.keys(Gp), i = Object.keys(Up);
  let n, r, a, s, o;
  for (n = 0; n < t.length; n++) {
    for (s = o = t[n], r = 0; r < i.length; r++)
      a = i[r], o = o.replace(a, Up[a]);
    a = parseInt(Gp[s], 16), e[o] = [a >> 16 & 255, a >> 8 & 255, a & 255];
  }
  return e;
}
let tl;
function f2(e) {
  tl || (tl = h2(), tl.transparent = [0, 0, 0, 0]);
  const t = tl[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const d2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function v2(e) {
  const t = d2.exec(e);
  let i = 255, n, r, a;
  if (t) {
    if (t[7] !== n) {
      const s = +t[7];
      i = t[8] ? Us(s) : Bn(s * 255, 0, 255);
    }
    return n = +t[1], r = +t[3], a = +t[5], n = 255 & (t[2] ? Us(n) : Bn(n, 0, 255)), r = 255 & (t[4] ? Us(r) : Bn(r, 0, 255)), a = 255 & (t[6] ? Us(a) : Bn(a, 0, 255)), {
      r: n,
      g: r,
      b: a,
      a: i
    };
  }
}
function p2(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${hn(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const qc = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, fa = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function g2(e, t, i) {
  const n = fa(hn(e.r)), r = fa(hn(e.g)), a = fa(hn(e.b));
  return {
    r: Un(qc(n + i * (fa(hn(t.r)) - n))),
    g: Un(qc(r + i * (fa(hn(t.g)) - r))),
    b: Un(qc(a + i * (fa(hn(t.b)) - a))),
    a: e.a + i * (t.a - e.a)
  };
}
function el(e, t, i) {
  if (e) {
    let n = Zd(e);
    n[t] = Math.max(0, Math.min(n[t] + n[t] * i, t === 0 ? 360 : 1)), n = Qd(n), e.r = n[0], e.g = n[1], e.b = n[2];
  }
}
function G0(e, t) {
  return e && Object.assign(t || {}, e);
}
function jp(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Un(e[3]))) : (t = G0(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Un(t.a)), t;
}
function m2(e) {
  return e.charAt(0) === "r" ? v2(e) : l2(e);
}
class yo {
  constructor(t) {
    if (t instanceof yo)
      return t;
    const i = typeof t;
    let n;
    i === "object" ? n = jp(t) : i === "string" && (n = JS(t) || f2(t) || m2(t)), this._rgb = n, this._valid = !!n;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = G0(this._rgb);
    return t && (t.a = hn(t.a)), t;
  }
  set rgb(t) {
    this._rgb = jp(t);
  }
  rgbString() {
    return this._valid ? p2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? e2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? c2(this._rgb) : void 0;
  }
  mix(t, i) {
    if (t) {
      const n = this.rgb, r = t.rgb;
      let a;
      const s = i === a ? 0.5 : i, o = 2 * s - 1, l = n.a - r.a, u = ((o * l === -1 ? o : (o + l) / (1 + o * l)) + 1) / 2;
      a = 1 - u, n.r = 255 & u * n.r + a * r.r + 0.5, n.g = 255 & u * n.g + a * r.g + 0.5, n.b = 255 & u * n.b + a * r.b + 0.5, n.a = s * n.a + (1 - s) * r.a, this.rgb = n;
    }
    return this;
  }
  interpolate(t, i) {
    return t && (this._rgb = g2(this._rgb, t._rgb, i)), this;
  }
  clone() {
    return new yo(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = Un(t), this;
  }
  clearer(t) {
    const i = this._rgb;
    return i.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, i = Yo(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = i, this;
  }
  opaquer(t) {
    const i = this._rgb;
    return i.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return el(this._rgb, 2, t), this;
  }
  darken(t) {
    return el(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return el(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return el(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return u2(this._rgb, t), this;
  }
}
function tn() {
}
const y2 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function Tt(e) {
  return e == null;
}
function ne(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function ft(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function Se(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function Li(e, t) {
  return Se(e) ? e : t;
}
function ot(e, t) {
  return typeof e > "u" ? t : e;
}
const _2 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, j0 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function Rt(e, t, i) {
  if (e && typeof e.call == "function")
    return e.apply(i, t);
}
function Ct(e, t, i, n) {
  let r, a, s;
  if (ne(e))
    for (a = e.length, r = 0; r < a; r++)
      t.call(i, e[r], r);
  else if (ft(e))
    for (s = Object.keys(e), a = s.length, r = 0; r < a; r++)
      t.call(i, e[s[r]], s[r]);
}
function pu(e, t) {
  let i, n, r, a;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (i = 0, n = e.length; i < n; ++i)
    if (r = e[i], a = t[i], r.datasetIndex !== a.datasetIndex || r.index !== a.index)
      return !1;
  return !0;
}
function gu(e) {
  if (ne(e))
    return e.map(gu);
  if (ft(e)) {
    const t = /* @__PURE__ */ Object.create(null), i = Object.keys(e), n = i.length;
    let r = 0;
    for (; r < n; ++r)
      t[i[r]] = gu(e[i[r]]);
    return t;
  }
  return e;
}
function X0(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function b2(e, t, i, n) {
  if (!X0(e))
    return;
  const r = t[e], a = i[e];
  ft(r) && ft(a) ? _o(r, a, n) : t[e] = gu(a);
}
function _o(e, t, i) {
  const n = ne(t) ? t : [
    t
  ], r = n.length;
  if (!ft(e))
    return e;
  i = i || {};
  const a = i.merger || b2;
  let s;
  for (let o = 0; o < r; ++o) {
    if (s = n[o], !ft(s))
      continue;
    const l = Object.keys(s);
    for (let u = 0, c = l.length; u < c; ++u)
      a(l[u], e, s, i);
  }
  return e;
}
function no(e, t) {
  return _o(e, t, {
    merger: x2
  });
}
function x2(e, t, i) {
  if (!X0(e))
    return;
  const n = t[e], r = i[e];
  ft(n) && ft(r) ? no(n, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = gu(r));
}
const Xp = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function w2(e) {
  const t = e.split("."), i = [];
  let n = "";
  for (const r of t)
    n += r, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n), n = "");
  return i;
}
function S2(e) {
  const t = w2(e);
  return (i) => {
    for (const n of t) {
      if (n === "")
        break;
      i = i && i[n];
    }
    return i;
  };
}
function ia(e, t) {
  return (Xp[t] || (Xp[t] = S2(t)))(e);
}
function Jd(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const bo = (e) => typeof e < "u", Kn = (e) => typeof e == "function", qp = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const i of e)
    if (!t.has(i))
      return !1;
  return !0;
};
function M2(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const kt = Math.PI, Ut = 2 * kt, T2 = Ut + kt, mu = Number.POSITIVE_INFINITY, D2 = kt / 180, se = kt / 2, ar = kt / 4, Zp = kt * 2 / 3, q0 = Math.log10, Wi = Math.sign;
function ro(e, t, i) {
  return Math.abs(e - t) < i;
}
function Kp(e) {
  const t = Math.round(e);
  e = ro(e, t, e / 1e3) ? t : e;
  const i = Math.pow(10, Math.floor(q0(e))), n = e / i;
  return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i;
}
function C2(e) {
  const t = [], i = Math.sqrt(e);
  let n;
  for (n = 1; n < i; n++)
    e % n === 0 && (t.push(n), t.push(e / n));
  return i === (i | 0) && t.push(i), t.sort((r, a) => r - a).pop(), t;
}
function k2(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function xo(e) {
  return !k2(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function P2(e, t) {
  const i = Math.round(e);
  return i - t <= e && i + t >= e;
}
function A2(e, t, i) {
  let n, r, a;
  for (n = 0, r = e.length; n < r; n++)
    a = e[n][i], isNaN(a) || (t.min = Math.min(t.min, a), t.max = Math.max(t.max, a));
}
function fn(e) {
  return e * (kt / 180);
}
function E2(e) {
  return e * (180 / kt);
}
function Qp(e) {
  if (!Se(e))
    return;
  let t = 1, i = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, i++;
  return i;
}
function Z0(e, t) {
  const i = t.x - e.x, n = t.y - e.y, r = Math.sqrt(i * i + n * n);
  let a = Math.atan2(n, i);
  return a < -0.5 * kt && (a += Ut), {
    angle: a,
    distance: r
  };
}
function If(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function L2(e, t) {
  return (e - t + T2) % Ut - kt;
}
function Ue(e) {
  return (e % Ut + Ut) % Ut;
}
function wo(e, t, i, n) {
  const r = Ue(e), a = Ue(t), s = Ue(i), o = Ue(a - r), l = Ue(s - r), u = Ue(r - a), c = Ue(r - s);
  return r === a || r === s || n && a === s || o > l && u < c;
}
function ye(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function O2(e) {
  return ye(e, -32768, 32767);
}
function dn(e, t, i, n = 1e-6) {
  return e >= Math.min(t, i) - n && e <= Math.max(t, i) + n;
}
function tv(e, t, i) {
  i = i || ((s) => e[s] < t);
  let n = e.length - 1, r = 0, a;
  for (; n - r > 1; )
    a = r + n >> 1, i(a) ? r = a : n = a;
  return {
    lo: r,
    hi: n
  };
}
const Br = (e, t, i, n) => tv(e, i, n ? (r) => {
  const a = e[r][t];
  return a < i || a === i && e[r + 1][t] === i;
} : (r) => e[r][t] < i), I2 = (e, t, i) => tv(e, i, (n) => e[n][t] >= i);
function R2(e, t, i) {
  let n = 0, r = e.length;
  for (; n < r && e[n] < t; )
    n++;
  for (; r > n && e[r - 1] > i; )
    r--;
  return n > 0 || r < e.length ? e.slice(n, r) : e;
}
const K0 = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function N2(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), K0.forEach((i) => {
    const n = "_onData" + Jd(i), r = e[i];
    Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !1,
      value(...a) {
        const s = r.apply(this, a);
        return e._chartjs.listeners.forEach((o) => {
          typeof o[n] == "function" && o[n](...a);
        }), s;
      }
    });
  });
}
function Jp(e, t) {
  const i = e._chartjs;
  if (!i)
    return;
  const n = i.listeners, r = n.indexOf(t);
  r !== -1 && n.splice(r, 1), !(n.length > 0) && (K0.forEach((a) => {
    delete e[a];
  }), delete e._chartjs);
}
function Q0(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const J0 = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function tb(e, t) {
  let i = [], n = !1;
  return function(...r) {
    i = r, n || (n = !0, J0.call(window, () => {
      n = !1, e.apply(t, i);
    }));
  };
}
function F2(e, t) {
  let i;
  return function(...n) {
    return t ? (clearTimeout(i), i = setTimeout(e, t, n)) : e.apply(this, n), t;
  };
}
const ev = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", ge = (e, t, i) => e === "start" ? t : e === "end" ? i : (t + i) / 2, B2 = (e, t, i, n) => e === (n ? "left" : "right") ? i : e === "center" ? (t + i) / 2 : t;
function z2(e, t, i) {
  const n = t.length;
  let r = 0, a = n;
  if (e._sorted) {
    const { iScale: s, vScale: o, _parsed: l } = e, u = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, c = s.axis, { min: h, max: f, minDefined: d, maxDefined: v } = s.getUserBounds();
    if (d) {
      if (r = Math.min(
        // @ts-expect-error Need to type _parsed
        Br(l, c, h).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? n : Br(t, c, s.getPixelForValue(h)).lo
      ), u) {
        const g = l.slice(0, r + 1).reverse().findIndex((p) => !Tt(p[o.axis]));
        r -= Math.max(0, g);
      }
      r = ye(r, 0, n - 1);
    }
    if (v) {
      let g = Math.max(
        // @ts-expect-error Need to type _parsed
        Br(l, s.axis, f, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? 0 : Br(t, c, s.getPixelForValue(f), !0).hi + 1
      );
      if (u) {
        const p = l.slice(g - 1).findIndex((m) => !Tt(m[o.axis]));
        g += Math.max(0, p);
      }
      a = ye(g, r, n) - r;
    } else
      a = n - r;
  }
  return {
    start: r,
    count: a
  };
}
function V2(e) {
  const { xScale: t, yScale: i, _scaleRanges: n } = e, r = {
    xmin: t.min,
    xmax: t.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!n)
    return e._scaleRanges = r, !0;
  const a = n.xmin !== t.min || n.xmax !== t.max || n.ymin !== i.min || n.ymax !== i.max;
  return Object.assign(n, r), a;
}
const il = (e) => e === 0 || e === 1, tg = (e, t, i) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Ut / i)), eg = (e, t, i) => Math.pow(2, -10 * e) * Math.sin((e - t) * Ut / i) + 1, ao = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * se) + 1,
  easeOutSine: (e) => Math.sin(e * se),
  easeInOutSine: (e) => -0.5 * (Math.cos(kt * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => il(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => il(e) ? e : tg(e, 0.075, 0.3),
  easeOutElastic: (e) => il(e) ? e : eg(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return il(e) ? e : e < 0.5 ? 0.5 * tg(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * eg(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - ao.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? ao.easeInBounce(e * 2) * 0.5 : ao.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function iv(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function ig(e) {
  return iv(e) ? e : new yo(e);
}
function Zc(e) {
  return iv(e) ? e : new yo(e).saturate(0.5).darken(0.1).hexString();
}
const $2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], H2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function Y2(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: H2
    },
    numbers: {
      type: "number",
      properties: $2
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function W2(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const ng = /* @__PURE__ */ new Map();
function U2(e, t) {
  t = t || {};
  const i = e + JSON.stringify(t);
  let n = ng.get(i);
  return n || (n = new Intl.NumberFormat(e, t), ng.set(i, n)), n;
}
function nv(e, t, i) {
  return U2(t, i).format(e);
}
const G2 = {
  values(e) {
    return ne(e) ? e : "" + e;
  },
  numeric(e, t, i) {
    if (e === 0)
      return "0";
    const n = this.chart.options.locale;
    let r, a = e;
    if (i.length > 1) {
      const u = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (u < 1e-4 || u > 1e15) && (r = "scientific"), a = j2(e, i);
    }
    const s = q0(Math.abs(a)), o = isNaN(s) ? 1 : Math.max(Math.min(-1 * Math.floor(s), 20), 0), l = {
      notation: r,
      minimumFractionDigits: o,
      maximumFractionDigits: o
    };
    return Object.assign(l, this.options.ticks.format), nv(e, n, l);
  }
};
function j2(e, t) {
  let i = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(i) >= 1 && e !== Math.floor(e) && (i = e - Math.floor(e)), i;
}
var eb = {
  formatters: G2
};
function X2(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, i) => i.lineWidth,
      tickColor: (t, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: eb.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const na = /* @__PURE__ */ Object.create(null), Rf = /* @__PURE__ */ Object.create(null);
function so(e, t) {
  if (!t)
    return e;
  const i = t.split(".");
  for (let n = 0, r = i.length; n < r; ++n) {
    const a = i[n];
    e = e[a] || (e[a] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function Kc(e, t, i) {
  return typeof t == "string" ? _o(so(e, t), i) : _o(so(e, ""), t);
}
class q2 {
  constructor(t, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (n, r) => Zc(r.backgroundColor), this.hoverBorderColor = (n, r) => Zc(r.borderColor), this.hoverColor = (n, r) => Zc(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(i);
  }
  set(t, i) {
    return Kc(this, t, i);
  }
  get(t) {
    return so(this, t);
  }
  describe(t, i) {
    return Kc(Rf, t, i);
  }
  override(t, i) {
    return Kc(na, t, i);
  }
  route(t, i, n, r) {
    const a = so(this, t), s = so(this, n), o = "_" + i;
    Object.defineProperties(a, {
      [o]: {
        value: a[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const l = this[o], u = s[r];
          return ft(l) ? Object.assign({}, u, l) : ot(l, u);
        },
        set(l) {
          this[o] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((i) => i(this));
  }
}
var ee = /* @__PURE__ */ new q2({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  Y2,
  W2,
  X2
]);
function Z2(e) {
  return !e || Tt(e.size) || Tt(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function rg(e, t, i, n, r) {
  let a = t[r];
  return a || (a = t[r] = e.measureText(r).width, i.push(r)), a > n && (n = a), n;
}
function sr(e, t, i) {
  const n = e.currentDevicePixelRatio, r = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((t - r) * n) / n + r;
}
function ag(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function Nf(e, t, i, n) {
  ib(e, t, i, n, null);
}
function ib(e, t, i, n, r) {
  let a, s, o, l, u, c, h, f;
  const d = t.pointStyle, v = t.rotation, g = t.radius;
  let p = (v || 0) * D2;
  if (d && typeof d == "object" && (a = d.toString(), a === "[object HTMLImageElement]" || a === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(i, n), e.rotate(p), e.drawImage(d, -d.width / 2, -d.height / 2, d.width, d.height), e.restore();
    return;
  }
  if (!(isNaN(g) || g <= 0)) {
    switch (e.beginPath(), d) {
      // Default includes circle
      default:
        r ? e.ellipse(i, n, r / 2, g, 0, 0, Ut) : e.arc(i, n, g, 0, Ut), e.closePath();
        break;
      case "triangle":
        c = r ? r / 2 : g, e.moveTo(i + Math.sin(p) * c, n - Math.cos(p) * g), p += Zp, e.lineTo(i + Math.sin(p) * c, n - Math.cos(p) * g), p += Zp, e.lineTo(i + Math.sin(p) * c, n - Math.cos(p) * g), e.closePath();
        break;
      case "rectRounded":
        u = g * 0.516, l = g - u, s = Math.cos(p + ar) * l, h = Math.cos(p + ar) * (r ? r / 2 - u : l), o = Math.sin(p + ar) * l, f = Math.sin(p + ar) * (r ? r / 2 - u : l), e.arc(i - h, n - o, u, p - kt, p - se), e.arc(i + f, n - s, u, p - se, p), e.arc(i + h, n + o, u, p, p + se), e.arc(i - f, n + s, u, p + se, p + kt), e.closePath();
        break;
      case "rect":
        if (!v) {
          l = Math.SQRT1_2 * g, c = r ? r / 2 : l, e.rect(i - c, n - l, 2 * c, 2 * l);
          break;
        }
        p += ar;
      /* falls through */
      case "rectRot":
        h = Math.cos(p) * (r ? r / 2 : g), s = Math.cos(p) * g, o = Math.sin(p) * g, f = Math.sin(p) * (r ? r / 2 : g), e.moveTo(i - h, n - o), e.lineTo(i + f, n - s), e.lineTo(i + h, n + o), e.lineTo(i - f, n + s), e.closePath();
        break;
      case "crossRot":
        p += ar;
      /* falls through */
      case "cross":
        h = Math.cos(p) * (r ? r / 2 : g), s = Math.cos(p) * g, o = Math.sin(p) * g, f = Math.sin(p) * (r ? r / 2 : g), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + f, n - s), e.lineTo(i - f, n + s);
        break;
      case "star":
        h = Math.cos(p) * (r ? r / 2 : g), s = Math.cos(p) * g, o = Math.sin(p) * g, f = Math.sin(p) * (r ? r / 2 : g), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + f, n - s), e.lineTo(i - f, n + s), p += ar, h = Math.cos(p) * (r ? r / 2 : g), s = Math.cos(p) * g, o = Math.sin(p) * g, f = Math.sin(p) * (r ? r / 2 : g), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + f, n - s), e.lineTo(i - f, n + s);
        break;
      case "line":
        s = r ? r / 2 : Math.cos(p) * g, o = Math.sin(p) * g, e.moveTo(i - s, n - o), e.lineTo(i + s, n + o);
        break;
      case "dash":
        e.moveTo(i, n), e.lineTo(i + Math.cos(p) * (r ? r / 2 : g), n + Math.sin(p) * g);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function So(e, t, i) {
  return i = i || 0.5, !t || e && e.x > t.left - i && e.x < t.right + i && e.y > t.top - i && e.y < t.bottom + i;
}
function hc(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function fc(e) {
  e.restore();
}
function K2(e, t, i, n, r) {
  if (!t)
    return e.lineTo(i.x, i.y);
  if (r === "middle") {
    const a = (t.x + i.x) / 2;
    e.lineTo(a, t.y), e.lineTo(a, i.y);
  } else r === "after" != !!n ? e.lineTo(t.x, i.y) : e.lineTo(i.x, t.y);
  e.lineTo(i.x, i.y);
}
function Q2(e, t, i, n) {
  if (!t)
    return e.lineTo(i.x, i.y);
  e.bezierCurveTo(n ? t.cp1x : t.cp2x, n ? t.cp1y : t.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y);
}
function J2(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), Tt(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function tM(e, t, i, n, r) {
  if (r.strikethrough || r.underline) {
    const a = e.measureText(n), s = t - a.actualBoundingBoxLeft, o = t + a.actualBoundingBoxRight, l = i - a.actualBoundingBoxAscent, u = i + a.actualBoundingBoxDescent, c = r.strikethrough ? (l + u) / 2 : u;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = r.decorationWidth || 2, e.moveTo(s, c), e.lineTo(o, c), e.stroke();
  }
}
function eM(e, t) {
  const i = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = i;
}
function Mo(e, t, i, n, r, a = {}) {
  const s = ne(t) ? t : [
    t
  ], o = a.strokeWidth > 0 && a.strokeColor !== "";
  let l, u;
  for (e.save(), e.font = r.string, J2(e, a), l = 0; l < s.length; ++l)
    u = s[l], a.backdrop && eM(e, a.backdrop), o && (a.strokeColor && (e.strokeStyle = a.strokeColor), Tt(a.strokeWidth) || (e.lineWidth = a.strokeWidth), e.strokeText(u, i, n, a.maxWidth)), e.fillText(u, i, n, a.maxWidth), tM(e, i, n, u, a), n += Number(r.lineHeight);
  e.restore();
}
function yu(e, t) {
  const { x: i, y: n, w: r, h: a, radius: s } = t;
  e.arc(i + s.topLeft, n + s.topLeft, s.topLeft, 1.5 * kt, kt, !0), e.lineTo(i, n + a - s.bottomLeft), e.arc(i + s.bottomLeft, n + a - s.bottomLeft, s.bottomLeft, kt, se, !0), e.lineTo(i + r - s.bottomRight, n + a), e.arc(i + r - s.bottomRight, n + a - s.bottomRight, s.bottomRight, se, 0, !0), e.lineTo(i + r, n + s.topRight), e.arc(i + r - s.topRight, n + s.topRight, s.topRight, 0, -se, !0), e.lineTo(i + s.topLeft, n);
}
const iM = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, nM = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function rM(e, t) {
  const i = ("" + e).match(iM);
  if (!i || i[1] === "normal")
    return t * 1.2;
  switch (e = +i[2], i[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const aM = (e) => +e || 0;
function rv(e, t) {
  const i = {}, n = ft(t), r = n ? Object.keys(t) : t, a = ft(e) ? n ? (s) => ot(e[s], e[t[s]]) : (s) => e[s] : () => e;
  for (const s of r)
    i[s] = aM(a(s));
  return i;
}
function nb(e) {
  return rv(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Ya(e) {
  return rv(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function di(e) {
  const t = nb(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function _e(e, t) {
  e = e || {}, t = t || ee.font;
  let i = ot(e.size, t.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let n = ot(e.style, t.style);
  n && !("" + n).match(nM) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
  const r = {
    family: ot(e.family, t.family),
    lineHeight: rM(ot(e.lineHeight, t.lineHeight), i),
    size: i,
    style: n,
    weight: ot(e.weight, t.weight),
    string: ""
  };
  return r.string = Z2(r), r;
}
function nl(e, t, i, n) {
  let r, a, s;
  for (r = 0, a = e.length; r < a; ++r)
    if (s = e[r], s !== void 0 && s !== void 0)
      return s;
}
function sM(e, t, i) {
  const { min: n, max: r } = e, a = j0(t, (r - n) / 2), s = (o, l) => i && o === 0 ? 0 : o + l;
  return {
    min: s(n, -Math.abs(a)),
    max: s(r, a)
  };
}
function sa(e, t) {
  return Object.assign(Object.create(e), t);
}
function av(e, t = [
  ""
], i, n, r = () => e[0]) {
  const a = i || e;
  typeof n > "u" && (n = ob("_fallback", e));
  const s = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: a,
    _fallback: n,
    _getTarget: r,
    override: (o) => av([
      o,
      ...e
    ], t, a, n)
  };
  return new Proxy(s, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, l) {
      return delete o[l], delete o._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(o, l) {
      return ab(o, l, () => vM(l, t, e, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, l) {
      return Reflect.getOwnPropertyDescriptor(o._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(o, l) {
      return og(o).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(o) {
      return og(o);
    },
    /**
    * A trap for setting property values.
    */
    set(o, l, u) {
      const c = o._storage || (o._storage = r());
      return o[l] = c[l] = u, delete o._keys, !0;
    }
  });
}
function Qa(e, t, i, n) {
  const r = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: rb(e, n),
    setContext: (a) => Qa(e, a, i, n),
    override: (a) => Qa(e.override(a), t, i, n)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, s) {
      return delete a[s], delete e[s], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, s, o) {
      return ab(a, s, () => lM(a, s, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, s) {
      return a._descriptors.allKeys ? Reflect.has(e, s) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, s);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(a, s) {
      return Reflect.has(e, s);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(a, s, o) {
      return e[s] = o, delete a[s], !0;
    }
  });
}
function rb(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = t.scriptable, _indexable: n = t.indexable, _allKeys: r = t.allKeys } = e;
  return {
    allKeys: r,
    scriptable: i,
    indexable: n,
    isScriptable: Kn(i) ? i : () => i,
    isIndexable: Kn(n) ? n : () => n
  };
}
const oM = (e, t) => e ? e + Jd(t) : t, sv = (e, t) => ft(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function ab(e, t, i) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const n = i();
  return e[t] = n, n;
}
function lM(e, t, i) {
  const { _proxy: n, _context: r, _subProxy: a, _descriptors: s } = e;
  let o = n[t];
  return Kn(o) && s.isScriptable(t) && (o = uM(t, o, e, i)), ne(o) && o.length && (o = cM(t, o, e, s.isIndexable)), sv(t, o) && (o = Qa(o, r, a && a[t], s)), o;
}
function uM(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: s, _stack: o } = i;
  if (o.has(e))
    throw new Error("Recursion detected: " + Array.from(o).join("->") + "->" + e);
  o.add(e);
  let l = t(a, s || n);
  return o.delete(e), sv(e, l) && (l = ov(r._scopes, r, e, l)), l;
}
function cM(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: s, _descriptors: o } = i;
  if (typeof a.index < "u" && n(e))
    return t[a.index % t.length];
  if (ft(t[0])) {
    const l = t, u = r._scopes.filter((c) => c !== l);
    t = [];
    for (const c of l) {
      const h = ov(u, r, e, c);
      t.push(Qa(h, a, s && s[e], o));
    }
  }
  return t;
}
function sb(e, t, i) {
  return Kn(e) ? e(t, i) : e;
}
const hM = (e, t) => e === !0 ? t : typeof e == "string" ? ia(t, e) : void 0;
function fM(e, t, i, n, r) {
  for (const a of t) {
    const s = hM(i, a);
    if (s) {
      e.add(s);
      const o = sb(s._fallback, i, r);
      if (typeof o < "u" && o !== i && o !== n)
        return o;
    } else if (s === !1 && typeof n < "u" && i !== n)
      return null;
  }
  return !1;
}
function ov(e, t, i, n) {
  const r = t._rootScopes, a = sb(t._fallback, i, n), s = [
    ...e,
    ...r
  ], o = /* @__PURE__ */ new Set();
  o.add(n);
  let l = sg(o, s, i, a || i, n);
  return l === null || typeof a < "u" && a !== i && (l = sg(o, s, a, l, n), l === null) ? !1 : av(Array.from(o), [
    ""
  ], r, a, () => dM(t, i, n));
}
function sg(e, t, i, n, r) {
  for (; i; )
    i = fM(e, t, i, n, r);
  return i;
}
function dM(e, t, i) {
  const n = e._getTarget();
  t in n || (n[t] = {});
  const r = n[t];
  return ne(r) && ft(i) ? i : r || {};
}
function vM(e, t, i, n) {
  let r;
  for (const a of t)
    if (r = ob(oM(a, e), i), typeof r < "u")
      return sv(e, r) ? ov(i, n, e, r) : r;
}
function ob(e, t) {
  for (const i of t) {
    if (!i)
      continue;
    const n = i[e];
    if (typeof n < "u")
      return n;
  }
}
function og(e) {
  let t = e._keys;
  return t || (t = e._keys = pM(e._scopes)), t;
}
function pM(e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    for (const n of Object.keys(i).filter((r) => !r.startsWith("_")))
      t.add(n);
  return Array.from(t);
}
const gM = Number.EPSILON || 1e-14, Ja = (e, t) => t < e.length && !e[t].skip && e[t], lb = (e) => e === "x" ? "y" : "x";
function mM(e, t, i, n) {
  const r = e.skip ? t : e, a = t, s = i.skip ? t : i, o = If(a, r), l = If(s, a);
  let u = o / (o + l), c = l / (o + l);
  u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c;
  const h = n * u, f = n * c;
  return {
    previous: {
      x: a.x - h * (s.x - r.x),
      y: a.y - h * (s.y - r.y)
    },
    next: {
      x: a.x + f * (s.x - r.x),
      y: a.y + f * (s.y - r.y)
    }
  };
}
function yM(e, t, i) {
  const n = e.length;
  let r, a, s, o, l, u = Ja(e, 0);
  for (let c = 0; c < n - 1; ++c)
    if (l = u, u = Ja(e, c + 1), !(!l || !u)) {
      if (ro(t[c], 0, gM)) {
        i[c] = i[c + 1] = 0;
        continue;
      }
      r = i[c] / t[c], a = i[c + 1] / t[c], o = Math.pow(r, 2) + Math.pow(a, 2), !(o <= 9) && (s = 3 / Math.sqrt(o), i[c] = r * s * t[c], i[c + 1] = a * s * t[c]);
    }
}
function _M(e, t, i = "x") {
  const n = lb(i), r = e.length;
  let a, s, o, l = Ja(e, 0);
  for (let u = 0; u < r; ++u) {
    if (s = o, o = l, l = Ja(e, u + 1), !o)
      continue;
    const c = o[i], h = o[n];
    s && (a = (c - s[i]) / 3, o[`cp1${i}`] = c - a, o[`cp1${n}`] = h - a * t[u]), l && (a = (l[i] - c) / 3, o[`cp2${i}`] = c + a, o[`cp2${n}`] = h + a * t[u]);
  }
}
function bM(e, t = "x") {
  const i = lb(t), n = e.length, r = Array(n).fill(0), a = Array(n);
  let s, o, l, u = Ja(e, 0);
  for (s = 0; s < n; ++s)
    if (o = l, l = u, u = Ja(e, s + 1), !!l) {
      if (u) {
        const c = u[t] - l[t];
        r[s] = c !== 0 ? (u[i] - l[i]) / c : 0;
      }
      a[s] = o ? u ? Wi(r[s - 1]) !== Wi(r[s]) ? 0 : (r[s - 1] + r[s]) / 2 : r[s - 1] : r[s];
    }
  yM(e, r, a), _M(e, a, t);
}
function rl(e, t, i) {
  return Math.max(Math.min(e, i), t);
}
function xM(e, t) {
  let i, n, r, a, s, o = So(e[0], t);
  for (i = 0, n = e.length; i < n; ++i)
    s = a, a = o, o = i < n - 1 && So(e[i + 1], t), a && (r = e[i], s && (r.cp1x = rl(r.cp1x, t.left, t.right), r.cp1y = rl(r.cp1y, t.top, t.bottom)), o && (r.cp2x = rl(r.cp2x, t.left, t.right), r.cp2y = rl(r.cp2y, t.top, t.bottom)));
}
function wM(e, t, i, n, r) {
  let a, s, o, l;
  if (t.spanGaps && (e = e.filter((u) => !u.skip)), t.cubicInterpolationMode === "monotone")
    bM(e, r);
  else {
    let u = n ? e[e.length - 1] : e[0];
    for (a = 0, s = e.length; a < s; ++a)
      o = e[a], l = mM(u, o, e[Math.min(a + 1, s - (n ? 0 : 1)) % s], t.tension), o.cp1x = l.previous.x, o.cp1y = l.previous.y, o.cp2x = l.next.x, o.cp2y = l.next.y, u = o;
  }
  t.capBezierPoints && xM(e, i);
}
function lv() {
  return typeof window < "u" && typeof document < "u";
}
function uv(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function _u(e, t, i) {
  let n;
  return typeof e == "string" ? (n = parseInt(e, 10), e.indexOf("%") !== -1 && (n = n / 100 * t.parentNode[i])) : n = e, n;
}
const dc = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function SM(e, t) {
  return dc(e).getPropertyValue(t);
}
const MM = [
  "top",
  "right",
  "bottom",
  "left"
];
function Gr(e, t, i) {
  const n = {};
  i = i ? "-" + i : "";
  for (let r = 0; r < 4; r++) {
    const a = MM[r];
    n[a] = parseFloat(e[t + "-" + a + i]) || 0;
  }
  return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
}
const TM = (e, t, i) => (e > 0 || t > 0) && (!i || !i.shadowRoot);
function DM(e, t) {
  const i = e.touches, n = i && i.length ? i[0] : e, { offsetX: r, offsetY: a } = n;
  let s = !1, o, l;
  if (TM(r, a, e.target))
    o = r, l = a;
  else {
    const u = t.getBoundingClientRect();
    o = n.clientX - u.left, l = n.clientY - u.top, s = !0;
  }
  return {
    x: o,
    y: l,
    box: s
  };
}
function Or(e, t) {
  if ("native" in e)
    return e;
  const { canvas: i, currentDevicePixelRatio: n } = t, r = dc(i), a = r.boxSizing === "border-box", s = Gr(r, "padding"), o = Gr(r, "border", "width"), { x: l, y: u, box: c } = DM(e, i), h = s.left + (c && o.left), f = s.top + (c && o.top);
  let { width: d, height: v } = t;
  return a && (d -= s.width + o.width, v -= s.height + o.height), {
    x: Math.round((l - h) / d * i.width / n),
    y: Math.round((u - f) / v * i.height / n)
  };
}
function CM(e, t, i) {
  let n, r;
  if (t === void 0 || i === void 0) {
    const a = e && uv(e);
    if (!a)
      t = e.clientWidth, i = e.clientHeight;
    else {
      const s = a.getBoundingClientRect(), o = dc(a), l = Gr(o, "border", "width"), u = Gr(o, "padding");
      t = s.width - u.width - l.width, i = s.height - u.height - l.height, n = _u(o.maxWidth, a, "clientWidth"), r = _u(o.maxHeight, a, "clientHeight");
    }
  }
  return {
    width: t,
    height: i,
    maxWidth: n || mu,
    maxHeight: r || mu
  };
}
const zn = (e) => Math.round(e * 10) / 10;
function kM(e, t, i, n) {
  const r = dc(e), a = Gr(r, "margin"), s = _u(r.maxWidth, e, "clientWidth") || mu, o = _u(r.maxHeight, e, "clientHeight") || mu, l = CM(e, t, i);
  let { width: u, height: c } = l;
  if (r.boxSizing === "content-box") {
    const f = Gr(r, "border", "width"), d = Gr(r, "padding");
    u -= d.width + f.width, c -= d.height + f.height;
  }
  return u = Math.max(0, u - a.width), c = Math.max(0, n ? u / n : c - a.height), u = zn(Math.min(u, s, l.maxWidth)), c = zn(Math.min(c, o, l.maxHeight)), u && !c && (c = zn(u / 2)), (t !== void 0 || i !== void 0) && n && l.height && c > l.height && (c = l.height, u = zn(Math.floor(c * n))), {
    width: u,
    height: c
  };
}
function lg(e, t, i) {
  const n = t || 1, r = zn(e.height * n), a = zn(e.width * n);
  e.height = zn(e.height), e.width = zn(e.width);
  const s = e.canvas;
  return s.style && (i || !s.style.height && !s.style.width) && (s.style.height = `${e.height}px`, s.style.width = `${e.width}px`), e.currentDevicePixelRatio !== n || s.height !== r || s.width !== a ? (e.currentDevicePixelRatio = n, s.height = r, s.width = a, e.ctx.setTransform(n, 0, 0, n, 0, 0), !0) : !1;
}
const PM = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    lv() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function ug(e, t) {
  const i = SM(e, t), n = i && i.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
function Ir(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: e.y + i * (t.y - e.y)
  };
}
function AM(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: n === "middle" ? i < 0.5 ? e.y : t.y : n === "after" ? i < 1 ? e.y : t.y : i > 0 ? t.y : e.y
  };
}
function EM(e, t, i, n) {
  const r = {
    x: e.cp2x,
    y: e.cp2y
  }, a = {
    x: t.cp1x,
    y: t.cp1y
  }, s = Ir(e, r, i), o = Ir(r, a, i), l = Ir(a, t, i), u = Ir(s, o, i), c = Ir(o, l, i);
  return Ir(u, c, i);
}
const LM = function(e, t) {
  return {
    x(i) {
      return e + e + t - i;
    },
    setWidth(i) {
      t = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, n) {
      return i - n;
    },
    leftForLtr(i, n) {
      return i - n;
    }
  };
}, OM = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function Wa(e, t, i) {
  return e ? LM(t, i) : OM();
}
function ub(e, t) {
  let i, n;
  (t === "ltr" || t === "rtl") && (i = e.canvas.style, n = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", t, "important"), e.prevTextDirection = n);
}
function cb(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function hb(e) {
  return e === "angle" ? {
    between: wo,
    compare: L2,
    normalize: Ue
  } : {
    between: dn,
    compare: (t, i) => t - i,
    normalize: (t) => t
  };
}
function cg({ start: e, end: t, count: i, loop: n, style: r }) {
  return {
    start: e % i,
    end: t % i,
    loop: n && (t - e + 1) % i === 0,
    style: r
  };
}
function IM(e, t, i) {
  const { property: n, start: r, end: a } = i, { between: s, normalize: o } = hb(n), l = t.length;
  let { start: u, end: c, loop: h } = e, f, d;
  if (h) {
    for (u += l, c += l, f = 0, d = l; f < d && s(o(t[u % l][n]), r, a); ++f)
      u--, c--;
    u %= l, c %= l;
  }
  return c < u && (c += l), {
    start: u,
    end: c,
    loop: h,
    style: e.style
  };
}
function fb(e, t, i) {
  if (!i)
    return [
      e
    ];
  const { property: n, start: r, end: a } = i, s = t.length, { compare: o, between: l, normalize: u } = hb(n), { start: c, end: h, loop: f, style: d } = IM(e, t, i), v = [];
  let g = !1, p = null, m, y, _;
  const b = () => l(r, _, m) && o(r, _) !== 0, x = () => o(a, m) === 0 || l(a, _, m), w = () => g || b(), M = () => !g || x();
  for (let T = c, D = c; T <= h; ++T)
    y = t[T % s], !y.skip && (m = u(y[n]), m !== _ && (g = l(m, r, a), p === null && w() && (p = o(m, r) === 0 ? T : D), p !== null && M() && (v.push(cg({
      start: p,
      end: T,
      loop: f,
      count: s,
      style: d
    })), p = null), D = T, _ = m));
  return p !== null && v.push(cg({
    start: p,
    end: h,
    loop: f,
    count: s,
    style: d
  })), v;
}
function db(e, t) {
  const i = [], n = e.segments;
  for (let r = 0; r < n.length; r++) {
    const a = fb(n[r], e.points, t);
    a.length && i.push(...a);
  }
  return i;
}
function RM(e, t, i, n) {
  let r = 0, a = t - 1;
  if (i && !n)
    for (; r < t && !e[r].skip; )
      r++;
  for (; r < t && e[r].skip; )
    r++;
  for (r %= t, i && (a += r); a > r && e[a % t].skip; )
    a--;
  return a %= t, {
    start: r,
    end: a
  };
}
function NM(e, t, i, n) {
  const r = e.length, a = [];
  let s = t, o = e[t], l;
  for (l = t + 1; l <= i; ++l) {
    const u = e[l % r];
    u.skip || u.stop ? o.skip || (n = !1, a.push({
      start: t % r,
      end: (l - 1) % r,
      loop: n
    }), t = s = u.stop ? l : null) : (s = l, o.skip && (t = l)), o = u;
  }
  return s !== null && a.push({
    start: t % r,
    end: s % r,
    loop: n
  }), a;
}
function FM(e, t) {
  const i = e.points, n = e.options.spanGaps, r = i.length;
  if (!r)
    return [];
  const a = !!e._loop, { start: s, end: o } = RM(i, r, a, n);
  if (n === !0)
    return hg(e, [
      {
        start: s,
        end: o,
        loop: a
      }
    ], i, t);
  const l = o < s ? o + r : o, u = !!e._fullLoop && s === 0 && o === r - 1;
  return hg(e, NM(i, s, l, u), i, t);
}
function hg(e, t, i, n) {
  return !n || !n.setContext || !i ? t : BM(e, t, i, n);
}
function BM(e, t, i, n) {
  const r = e._chart.getContext(), a = fg(e.options), { _datasetIndex: s, options: { spanGaps: o } } = e, l = i.length, u = [];
  let c = a, h = t[0].start, f = h;
  function d(v, g, p, m) {
    const y = o ? -1 : 1;
    if (v !== g) {
      for (v += l; i[v % l].skip; )
        v -= y;
      for (; i[g % l].skip; )
        g += y;
      v % l !== g % l && (u.push({
        start: v % l,
        end: g % l,
        loop: p,
        style: m
      }), c = m, h = g % l);
    }
  }
  for (const v of t) {
    h = o ? h : v.start;
    let g = i[h % l], p;
    for (f = h + 1; f <= v.end; f++) {
      const m = i[f % l];
      p = fg(n.setContext(sa(r, {
        type: "segment",
        p0: g,
        p1: m,
        p0DataIndex: (f - 1) % l,
        p1DataIndex: f % l,
        datasetIndex: s
      }))), zM(p, c) && d(h, f - 1, v.loop, c), g = m, c = p;
    }
    h < f - 1 && d(h, f - 1, v.loop, c);
  }
  return u;
}
function fg(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function zM(e, t) {
  if (!t)
    return !1;
  const i = [], n = function(r, a) {
    return iv(a) ? (i.includes(a) || i.push(a), i.indexOf(a)) : a;
  };
  return JSON.stringify(e, n) !== JSON.stringify(t, n);
}
function al(e, t, i) {
  return e.options.clip ? e[i] : t[i];
}
function VM(e, t) {
  const { xScale: i, yScale: n } = e;
  return i && n ? {
    left: al(i, t, "left"),
    right: al(i, t, "right"),
    top: al(n, t, "top"),
    bottom: al(n, t, "bottom")
  } : t;
}
function vb(e, t) {
  const i = t._clip;
  if (i.disabled)
    return !1;
  const n = VM(t, e.chartArea);
  return {
    left: i.left === !1 ? 0 : n.left - (i.left === !0 ? 0 : i.left),
    right: i.right === !1 ? e.width : n.right + (i.right === !0 ? 0 : i.right),
    top: i.top === !1 ? 0 : n.top - (i.top === !0 ? 0 : i.top),
    bottom: i.bottom === !1 ? e.height : n.bottom + (i.bottom === !0 ? 0 : i.bottom)
  };
}
let $M = class {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, i, n, r) {
    const a = i.listeners[r], s = i.duration;
    a.forEach((o) => o({
      chart: t,
      initial: i.initial,
      numSteps: s,
      currentStep: Math.min(n - i.start, s)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = J0.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let i = 0;
    this._charts.forEach((n, r) => {
      if (!n.running || !n.items.length)
        return;
      const a = n.items;
      let s = a.length - 1, o = !1, l;
      for (; s >= 0; --s)
        l = a[s], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(t), o = !0) : (a[s] = a[a.length - 1], a.pop());
      o && (r.draw(), this._notify(r, n, t, "progress")), a.length || (n.running = !1, this._notify(r, n, t, "complete"), n.initial = !1), i += a.length;
    }), this._lastDate = t, i === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const i = this._charts;
    let n = i.get(t);
    return n || (n = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(t, n)), n;
  }
  listen(t, i, n) {
    this._getAnims(t).listeners[i].push(n);
  }
  add(t, i) {
    !i || !i.length || this._getAnims(t).items.push(...i);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const i = this._charts.get(t);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((n, r) => Math.max(n, r._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const i = this._charts.get(t);
    return !(!i || !i.running || !i.items.length);
  }
  stop(t) {
    const i = this._charts.get(t);
    if (!i || !i.items.length)
      return;
    const n = i.items;
    let r = n.length - 1;
    for (; r >= 0; --r)
      n[r].cancel();
    i.items = [], this._notify(t, i, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
};
var on = /* @__PURE__ */ new $M();
const dg = "transparent", HM = {
  boolean(e, t, i) {
    return i > 0.5 ? t : e;
  },
  color(e, t, i) {
    const n = ig(e || dg), r = n.valid && ig(t || dg);
    return r && r.valid ? r.mix(n, i).hexString() : t;
  },
  number(e, t, i) {
    return e + (t - e) * i;
  }
};
let YM = class {
  constructor(t, i, n, r) {
    const a = i[n];
    r = nl([
      t.to,
      r,
      a,
      t.from
    ]);
    const s = nl([
      t.from,
      a,
      r
    ]);
    this._active = !0, this._fn = t.fn || HM[t.type || typeof s], this._easing = ao[t.easing] || ao.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = i, this._prop = n, this._from = s, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, i, n) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], a = n - this._start, s = this._duration - a;
      this._start = n, this._duration = Math.floor(Math.max(s, t.duration)), this._total += a, this._loop = !!t.loop, this._to = nl([
        t.to,
        i,
        r,
        t.from
      ]), this._from = nl([
        t.from,
        r,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const i = t - this._start, n = this._duration, r = this._prop, a = this._from, s = this._loop, o = this._to;
    let l;
    if (this._active = a !== o && (s || i < n), !this._active) {
      this._target[r] = o, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[r] = a;
      return;
    }
    l = i / n % 2, l = s && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(a, o, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((i, n) => {
      t.push({
        res: i,
        rej: n
      });
    });
  }
  _notify(t) {
    const i = t ? "res" : "rej", n = this._promises || [];
    for (let r = 0; r < n.length; r++)
      n[r][i]();
  }
};
class pb {
  constructor(t, i) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(t) {
    if (!ft(t))
      return;
    const i = Object.keys(ee.animation), n = this._properties;
    Object.getOwnPropertyNames(t).forEach((r) => {
      const a = t[r];
      if (!ft(a))
        return;
      const s = {};
      for (const o of i)
        s[o] = a[o];
      (ne(a.properties) && a.properties || [
        r
      ]).forEach((o) => {
        (o === r || !n.has(o)) && n.set(o, s);
      });
    });
  }
  _animateOptions(t, i) {
    const n = i.options, r = UM(t, n);
    if (!r)
      return [];
    const a = this._createAnimations(r, n);
    return n.$shared && WM(t.options.$animations, n).then(() => {
      t.options = n;
    }, () => {
    }), a;
  }
  _createAnimations(t, i) {
    const n = this._properties, r = [], a = t.$animations || (t.$animations = {}), s = Object.keys(i), o = Date.now();
    let l;
    for (l = s.length - 1; l >= 0; --l) {
      const u = s[l];
      if (u.charAt(0) === "$")
        continue;
      if (u === "options") {
        r.push(...this._animateOptions(t, i));
        continue;
      }
      const c = i[u];
      let h = a[u];
      const f = n.get(u);
      if (h)
        if (f && h.active()) {
          h.update(f, c, o);
          continue;
        } else
          h.cancel();
      if (!f || !f.duration) {
        t[u] = c;
        continue;
      }
      a[u] = h = new YM(f, t, u, c), r.push(h);
    }
    return r;
  }
  update(t, i) {
    if (this._properties.size === 0) {
      Object.assign(t, i);
      return;
    }
    const n = this._createAnimations(t, i);
    if (n.length)
      return on.add(this._chart, n), !0;
  }
}
function WM(e, t) {
  const i = [], n = Object.keys(t);
  for (let r = 0; r < n.length; r++) {
    const a = e[n[r]];
    a && a.active() && i.push(a.wait());
  }
  return Promise.all(i);
}
function UM(e, t) {
  if (!t)
    return;
  let i = e.options;
  if (!i) {
    e.options = t;
    return;
  }
  return i.$shared && (e.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function vg(e, t) {
  const i = e && e.options || {}, n = i.reverse, r = i.min === void 0 ? t : 0, a = i.max === void 0 ? t : 0;
  return {
    start: n ? a : r,
    end: n ? r : a
  };
}
function GM(e, t, i) {
  if (i === !1)
    return !1;
  const n = vg(e, i), r = vg(t, i);
  return {
    top: r.end,
    right: n.end,
    bottom: r.start,
    left: n.start
  };
}
function jM(e) {
  let t, i, n, r;
  return ft(e) ? (t = e.top, i = e.right, n = e.bottom, r = e.left) : t = i = n = r = e, {
    top: t,
    right: i,
    bottom: n,
    left: r,
    disabled: e === !1
  };
}
function gb(e, t) {
  const i = [], n = e._getSortedDatasetMetas(t);
  let r, a;
  for (r = 0, a = n.length; r < a; ++r)
    i.push(n[r].index);
  return i;
}
function pg(e, t, i, n = {}) {
  const r = e.keys, a = n.mode === "single";
  let s, o, l, u;
  if (t === null)
    return;
  let c = !1;
  for (s = 0, o = r.length; s < o; ++s) {
    if (l = +r[s], l === i) {
      if (c = !0, n.all)
        continue;
      break;
    }
    u = e.values[l], Se(u) && (a || t === 0 || Wi(t) === Wi(u)) && (t += u);
  }
  return !c && !n.all ? 0 : t;
}
function XM(e, t) {
  const { iScale: i, vScale: n } = t, r = i.axis === "x" ? "x" : "y", a = n.axis === "x" ? "x" : "y", s = Object.keys(e), o = new Array(s.length);
  let l, u, c;
  for (l = 0, u = s.length; l < u; ++l)
    c = s[l], o[l] = {
      [r]: c,
      [a]: e[c]
    };
  return o;
}
function Qc(e, t) {
  const i = e && e.options.stacked;
  return i || i === void 0 && t.stack !== void 0;
}
function qM(e, t, i) {
  return `${e.id}.${t.id}.${i.stack || i.type}`;
}
function ZM(e) {
  const { min: t, max: i, minDefined: n, maxDefined: r } = e.getUserBounds();
  return {
    min: n ? t : Number.NEGATIVE_INFINITY,
    max: r ? i : Number.POSITIVE_INFINITY
  };
}
function KM(e, t, i) {
  const n = e[t] || (e[t] = {});
  return n[i] || (n[i] = {});
}
function gg(e, t, i, n) {
  for (const r of t.getMatchingVisibleMetas(n).reverse()) {
    const a = e[r.index];
    if (i && a > 0 || !i && a < 0)
      return r.index;
  }
  return null;
}
function mg(e, t) {
  const { chart: i, _cachedMeta: n } = e, r = i._stacks || (i._stacks = {}), { iScale: a, vScale: s, index: o } = n, l = a.axis, u = s.axis, c = qM(a, s, n), h = t.length;
  let f;
  for (let d = 0; d < h; ++d) {
    const v = t[d], { [l]: g, [u]: p } = v, m = v._stacks || (v._stacks = {});
    f = m[u] = KM(r, c, g), f[o] = p, f._top = gg(f, s, !0, n.type), f._bottom = gg(f, s, !1, n.type);
    const y = f._visualValues || (f._visualValues = {});
    y[o] = p;
  }
}
function Jc(e, t) {
  const i = e.scales;
  return Object.keys(i).filter((n) => i[n].axis === t).shift();
}
function QM(e, t) {
  return sa(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function JM(e, t, i) {
  return sa(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: t,
    mode: "default",
    type: "data"
  });
}
function gs(e, t) {
  const i = e.controller.index, n = e.vScale && e.vScale.axis;
  if (n) {
    t = t || e._parsed;
    for (const r of t) {
      const a = r._stacks;
      if (!a || a[n] === void 0 || a[n][i] === void 0)
        return;
      delete a[n][i], a[n]._visualValues !== void 0 && a[n]._visualValues[i] !== void 0 && delete a[n]._visualValues[i];
    }
  }
}
const th = (e) => e === "reset" || e === "none", yg = (e, t) => t ? e : Object.assign({}, e), tT = (e, t, i) => e && !t.hidden && t._stacked && {
  keys: gb(i, !0),
  values: null
};
class vc {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, i) {
    this.chart = t, this._ctx = t.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Qc(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && gs(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, i = this._cachedMeta, n = this.getDataset(), r = (h, f, d, v) => h === "x" ? f : h === "r" ? v : d, a = i.xAxisID = ot(n.xAxisID, Jc(t, "x")), s = i.yAxisID = ot(n.yAxisID, Jc(t, "y")), o = i.rAxisID = ot(n.rAxisID, Jc(t, "r")), l = i.indexAxis, u = i.iAxisID = r(l, a, s, o), c = i.vAxisID = r(l, s, a, o);
    i.xScale = this.getScaleForId(a), i.yScale = this.getScaleForId(s), i.rScale = this.getScaleForId(o), i.iScale = this.getScaleForId(u), i.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const i = this._cachedMeta;
    return t === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && Jp(this._data, this), t._stacked && gs(t);
  }
  _dataCheck() {
    const t = this.getDataset(), i = t.data || (t.data = []), n = this._data;
    if (ft(i)) {
      const r = this._cachedMeta;
      this._data = XM(i, r);
    } else if (n !== i) {
      if (n) {
        Jp(n, this);
        const r = this._cachedMeta;
        gs(r), r._parsed = [];
      }
      i && Object.isExtensible(i) && N2(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const i = this._cachedMeta, n = this.getDataset();
    let r = !1;
    this._dataCheck();
    const a = i._stacked;
    i._stacked = Qc(i.vScale, i), i.stack !== n.stack && (r = !0, gs(i), i.stack = n.stack), this._resyncElements(t), (r || a !== i._stacked) && (mg(this, i._parsed), i._stacked = Qc(i.vScale, i));
  }
  configure() {
    const t = this.chart.config, i = t.datasetScopeKeys(this._type), n = t.getOptionScopes(this.getDataset(), i, !0);
    this.options = t.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, i) {
    const { _cachedMeta: n, _data: r } = this, { iScale: a, _stacked: s } = n, o = a.axis;
    let l = t === 0 && i === r.length ? !0 : n._sorted, u = t > 0 && n._parsed[t - 1], c, h, f;
    if (this._parsing === !1)
      n._parsed = r, n._sorted = !0, f = r;
    else {
      ne(r[t]) ? f = this.parseArrayData(n, r, t, i) : ft(r[t]) ? f = this.parseObjectData(n, r, t, i) : f = this.parsePrimitiveData(n, r, t, i);
      const d = () => h[o] === null || u && h[o] < u[o];
      for (c = 0; c < i; ++c)
        n._parsed[c + t] = h = f[c], l && (d() && (l = !1), u = h);
      n._sorted = l;
    }
    s && mg(this, f);
  }
  parsePrimitiveData(t, i, n, r) {
    const { iScale: a, vScale: s } = t, o = a.axis, l = s.axis, u = a.getLabels(), c = a === s, h = new Array(r);
    let f, d, v;
    for (f = 0, d = r; f < d; ++f)
      v = f + n, h[f] = {
        [o]: c || a.parse(u[v], v),
        [l]: s.parse(i[v], v)
      };
    return h;
  }
  parseArrayData(t, i, n, r) {
    const { xScale: a, yScale: s } = t, o = new Array(r);
    let l, u, c, h;
    for (l = 0, u = r; l < u; ++l)
      c = l + n, h = i[c], o[l] = {
        x: a.parse(h[0], c),
        y: s.parse(h[1], c)
      };
    return o;
  }
  parseObjectData(t, i, n, r) {
    const { xScale: a, yScale: s } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(r);
    let c, h, f, d;
    for (c = 0, h = r; c < h; ++c)
      f = c + n, d = i[f], u[c] = {
        x: a.parse(ia(d, o), f),
        y: s.parse(ia(d, l), f)
      };
    return u;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, i, n) {
    const r = this.chart, a = this._cachedMeta, s = i[t.axis], o = {
      keys: gb(r, !0),
      values: i._stacks[t.axis]._visualValues
    };
    return pg(o, s, a.index, {
      mode: n
    });
  }
  updateRangeFromParsed(t, i, n, r) {
    const a = n[i.axis];
    let s = a === null ? NaN : a;
    const o = r && n._stacks[i.axis];
    r && o && (r.values = o, s = pg(r, a, this._cachedMeta.index)), t.min = Math.min(t.min, s), t.max = Math.max(t.max, s);
  }
  getMinMax(t, i) {
    const n = this._cachedMeta, r = n._parsed, a = n._sorted && t === n.iScale, s = r.length, o = this._getOtherScale(t), l = tT(i, n, this.chart), u = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: h } = ZM(o);
    let f, d;
    function v() {
      d = r[f];
      const g = d[o.axis];
      return !Se(d[t.axis]) || c > g || h < g;
    }
    for (f = 0; f < s && !(!v() && (this.updateRangeFromParsed(u, t, d, l), a)); ++f)
      ;
    if (a) {
      for (f = s - 1; f >= 0; --f)
        if (!v()) {
          this.updateRangeFromParsed(u, t, d, l);
          break;
        }
    }
    return u;
  }
  getAllParsedValues(t) {
    const i = this._cachedMeta._parsed, n = [];
    let r, a, s;
    for (r = 0, a = i.length; r < a; ++r)
      s = i[r][t.axis], Se(s) && n.push(s);
    return n;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = i.iScale, r = i.vScale, a = this.getParsed(t);
    return {
      label: n ? "" + n.getLabelForValue(a[n.axis]) : "",
      value: r ? "" + r.getLabelForValue(a[r.axis]) : ""
    };
  }
  _update(t) {
    const i = this._cachedMeta;
    this.update(t || "default"), i._clip = jM(ot(this.options.clip, GM(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, i = this.chart, n = this._cachedMeta, r = n.data || [], a = i.chartArea, s = [], o = this._drawStart || 0, l = this._drawCount || r.length - o, u = this.options.drawActiveElementsOnTop;
    let c;
    for (n.dataset && n.dataset.draw(t, a, o, l), c = o; c < o + l; ++c) {
      const h = r[c];
      h.hidden || (h.active && u ? s.push(h) : h.draw(t, a));
    }
    for (c = 0; c < s.length; ++c)
      s[c].draw(t, a);
  }
  getStyle(t, i) {
    const n = i ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(t || 0, n);
  }
  getContext(t, i, n) {
    const r = this.getDataset();
    let a;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const s = this._cachedMeta.data[t];
      a = s.$context || (s.$context = JM(this.getContext(), t, s)), a.parsed = this.getParsed(t), a.raw = r.data[t], a.index = a.dataIndex = t;
    } else
      a = this.$context || (this.$context = QM(this.chart.getContext(), this.index)), a.dataset = r, a.index = a.datasetIndex = this.index;
    return a.active = !!i, a.mode = n, a;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, t);
  }
  _resolveElementOptions(t, i = "default", n) {
    const r = i === "active", a = this._cachedDataOpts, s = t + "-" + i, o = a[s], l = this.enableOptionSharing && bo(n);
    if (o)
      return yg(o, l);
    const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, t), h = r ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], f = u.getOptionScopes(this.getDataset(), c), d = Object.keys(ee.elements[t]), v = () => this.getContext(n, r, i), g = u.resolveNamedOptions(f, d, v, h);
    return g.$shared && (g.$shared = l, a[s] = Object.freeze(yg(g, l))), g;
  }
  _resolveAnimations(t, i, n) {
    const r = this.chart, a = this._cachedDataOpts, s = `animation-${i}`, o = a[s];
    if (o)
      return o;
    let l;
    if (r.options.animation !== !1) {
      const c = this.chart.config, h = c.datasetAnimationScopeKeys(this._type, i), f = c.getOptionScopes(this.getDataset(), h);
      l = c.createResolver(f, this.getContext(t, n, i));
    }
    const u = new pb(r, l && l.animations);
    return l && l._cacheable && (a[s] = Object.freeze(u)), u;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, i) {
    return !i || th(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, i) {
    const n = this.resolveDataElementOptions(t, i), r = this._sharedOptions, a = this.getSharedOptions(n), s = this.includeOptions(i, a) || a !== r;
    return this.updateSharedOptions(a, i, n), {
      sharedOptions: a,
      includeOptions: s
    };
  }
  updateElement(t, i, n, r) {
    th(r) ? Object.assign(t, n) : this._resolveAnimations(i, r).update(t, n);
  }
  updateSharedOptions(t, i, n) {
    t && !th(i) && this._resolveAnimations(void 0, i).update(t, n);
  }
  _setStyle(t, i, n, r) {
    t.active = r;
    const a = this.getStyle(i, r);
    this._resolveAnimations(i, n, r).update(t, {
      options: !r && this.getSharedOptions(a) || a
    });
  }
  removeHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !1);
  }
  setHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const i = this._data, n = this._cachedMeta.data;
    for (const [o, l, u] of this._syncList)
      this[o](l, u);
    this._syncList = [];
    const r = n.length, a = i.length, s = Math.min(a, r);
    s && this.parse(0, s), a > r ? this._insertElements(r, a - r, t) : a < r && this._removeElements(a, r - a);
  }
  _insertElements(t, i, n = !0) {
    const r = this._cachedMeta, a = r.data, s = t + i;
    let o;
    const l = (u) => {
      for (u.length += i, o = u.length - 1; o >= s; o--)
        u[o] = u[o - i];
    };
    for (l(a), o = t; o < s; ++o)
      a[o] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(t, i), n && this.updateElements(a, t, i, "reset");
  }
  updateElements(t, i, n, r) {
  }
  _removeElements(t, i) {
    const n = this._cachedMeta;
    if (this._parsing) {
      const r = n._parsed.splice(t, i);
      n._stacked && gs(n, r);
    }
    n.data.splice(t, i);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [i, n, r] = t;
      this[i](n, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, i) {
    i && this._sync([
      "_removeElements",
      t,
      i
    ]);
    const n = arguments.length - 2;
    n && this._sync([
      "_insertElements",
      t,
      n
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function eT(e, t) {
  if (!e._cache.$bar) {
    const i = e.getMatchingVisibleMetas(t);
    let n = [];
    for (let r = 0, a = i.length; r < a; r++)
      n = n.concat(i[r].controller.getAllParsedValues(e));
    e._cache.$bar = Q0(n.sort((r, a) => r - a));
  }
  return e._cache.$bar;
}
function iT(e) {
  const t = e.iScale, i = eT(t, e.type);
  let n = t._length, r, a, s, o;
  const l = () => {
    s === 32767 || s === -32768 || (bo(o) && (n = Math.min(n, Math.abs(s - o) || n)), o = s);
  };
  for (r = 0, a = i.length; r < a; ++r)
    s = t.getPixelForValue(i[r]), l();
  for (o = void 0, r = 0, a = t.ticks.length; r < a; ++r)
    s = t.getPixelForTick(r), l();
  return n;
}
function nT(e, t, i, n) {
  const r = i.barThickness;
  let a, s;
  return Tt(r) ? (a = t.min * i.categoryPercentage, s = i.barPercentage) : (a = r * n, s = 1), {
    chunk: a / n,
    ratio: s,
    start: t.pixels[e] - a / 2
  };
}
function rT(e, t, i, n) {
  const r = t.pixels, a = r[e];
  let s = e > 0 ? r[e - 1] : null, o = e < r.length - 1 ? r[e + 1] : null;
  const l = i.categoryPercentage;
  s === null && (s = a - (o === null ? t.end - t.start : o - a)), o === null && (o = a + a - s);
  const u = a - (a - Math.min(s, o)) / 2 * l;
  return {
    chunk: Math.abs(o - s) / 2 * l / n,
    ratio: i.barPercentage,
    start: u
  };
}
function aT(e, t, i, n) {
  const r = i.parse(e[0], n), a = i.parse(e[1], n), s = Math.min(r, a), o = Math.max(r, a);
  let l = s, u = o;
  Math.abs(s) > Math.abs(o) && (l = o, u = s), t[i.axis] = u, t._custom = {
    barStart: l,
    barEnd: u,
    start: r,
    end: a,
    min: s,
    max: o
  };
}
function mb(e, t, i, n) {
  return ne(e) ? aT(e, t, i, n) : t[i.axis] = i.parse(e, n), t;
}
function _g(e, t, i, n) {
  const r = e.iScale, a = e.vScale, s = r.getLabels(), o = r === a, l = [];
  let u, c, h, f;
  for (u = i, c = i + n; u < c; ++u)
    f = t[u], h = {}, h[r.axis] = o || r.parse(s[u], u), l.push(mb(f, h, a, u));
  return l;
}
function eh(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function sT(e, t, i) {
  return e !== 0 ? Wi(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= i ? 1 : -1);
}
function oT(e) {
  let t, i, n, r, a;
  return e.horizontal ? (t = e.base > e.x, i = "left", n = "right") : (t = e.base < e.y, i = "bottom", n = "top"), t ? (r = "end", a = "start") : (r = "start", a = "end"), {
    start: i,
    end: n,
    reverse: t,
    top: r,
    bottom: a
  };
}
function lT(e, t, i, n) {
  let r = t.borderSkipped;
  const a = {};
  if (!r) {
    e.borderSkipped = a;
    return;
  }
  if (r === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: s, end: o, reverse: l, top: u, bottom: c } = oT(e);
  r === "middle" && i && (e.enableBorderRadius = !0, (i._top || 0) === n ? r = u : (i._bottom || 0) === n ? r = c : (a[bg(c, s, o, l)] = !0, r = u)), a[bg(r, s, o, l)] = !0, e.borderSkipped = a;
}
function bg(e, t, i, n) {
  return n ? (e = uT(e, t, i), e = xg(e, i, t)) : e = xg(e, t, i), e;
}
function uT(e, t, i) {
  return e === t ? i : e === i ? t : e;
}
function xg(e, t, i) {
  return e === "start" ? t : e === "end" ? i : e;
}
function cT(e, { inflateAmount: t }, i) {
  e.inflateAmount = t === "auto" ? i === 1 ? 0.33 : 0 : t;
}
class hT extends vc {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, i, n, r) {
    return _g(t, i, n, r);
  }
  parseArrayData(t, i, n, r) {
    return _g(t, i, n, r);
  }
  parseObjectData(t, i, n, r) {
    const { iScale: a, vScale: s } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, u = a.axis === "x" ? o : l, c = s.axis === "x" ? o : l, h = [];
    let f, d, v, g;
    for (f = n, d = n + r; f < d; ++f)
      g = i[f], v = {}, v[a.axis] = a.parse(ia(g, u), f), h.push(mb(ia(g, c), v, s, f));
    return h;
  }
  updateRangeFromParsed(t, i, n, r) {
    super.updateRangeFromParsed(t, i, n, r);
    const a = n._custom;
    a && i === this._cachedMeta.vScale && (t.min = Math.min(t.min, a.min), t.max = Math.max(t.max, a.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, { iScale: n, vScale: r } = i, a = this.getParsed(t), s = a._custom, o = eh(s) ? "[" + s.start + ", " + s.end + "]" : "" + r.getLabelForValue(a[r.axis]);
    return {
      label: "" + n.getLabelForValue(a[n.axis]),
      value: o
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const i = this._cachedMeta;
    this.updateElements(i.data, 0, i.data.length, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { index: s, _cachedMeta: { vScale: o } } = this, l = o.getBasePixel(), u = o.isHorizontal(), c = this._getRuler(), { sharedOptions: h, includeOptions: f } = this._getSharedOptions(i, r);
    for (let d = i; d < i + n; d++) {
      const v = this.getParsed(d), g = a || Tt(v[o.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(d), p = this._calculateBarIndexPixels(d, c), m = (v._stacks || {})[o.axis], y = {
        horizontal: u,
        base: g.base,
        enableBorderRadius: !m || eh(v._custom) || s === m._top || s === m._bottom,
        x: u ? g.head : p.center,
        y: u ? p.center : g.head,
        height: u ? p.size : Math.abs(g.size),
        width: u ? Math.abs(g.size) : p.size
      };
      f && (y.options = h || this.resolveDataElementOptions(d, t[d].active ? "active" : r));
      const _ = y.options || t[d].options;
      lT(y, _, m, s), cT(y, _, c.ratio), this.updateElement(t[d], d, y, r);
    }
  }
  _getStacks(t, i) {
    const { iScale: n } = this._cachedMeta, r = n.getMatchingVisibleMetas(this._type).filter((c) => c.controller.options.grouped), a = n.options.stacked, s = [], o = this._cachedMeta.controller.getParsed(i), l = o && o[n.axis], u = (c) => {
      const h = c._parsed.find((d) => d[n.axis] === l), f = h && h[c.vScale.axis];
      if (Tt(f) || isNaN(f))
        return !0;
    };
    for (const c of r)
      if (!(i !== void 0 && u(c)) && ((a === !1 || s.indexOf(c.stack) === -1 || a === void 0 && c.stack === void 0) && s.push(c.stack), c.index === t))
        break;
    return s.length || s.push(void 0), s;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, i = this.chart.options.indexAxis;
    return Object.keys(t).filter((n) => t[n].axis === i).shift();
  }
  _getAxis() {
    const t = {}, i = this.getFirstScaleIdForIndexAxis();
    for (const n of this.chart.data.datasets)
      t[ot(this.chart.options.indexAxis === "x" ? n.xAxisID : n.yAxisID, i)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, i, n) {
    const r = this._getStacks(t, n), a = i !== void 0 ? r.indexOf(i) : -1;
    return a === -1 ? r.length - 1 : a;
  }
  _getRuler() {
    const t = this.options, i = this._cachedMeta, n = i.iScale, r = [];
    let a, s;
    for (a = 0, s = i.data.length; a < s; ++a)
      r.push(n.getPixelForValue(this.getParsed(a)[n.axis], a));
    const o = t.barThickness;
    return {
      min: o || iT(i),
      pixels: r,
      start: n._startPixel,
      end: n._endPixel,
      stackCount: this._getStackCount(),
      scale: n,
      grouped: t.grouped,
      ratio: o ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: i, _stacked: n, index: r }, options: { base: a, minBarLength: s } } = this, o = a || 0, l = this.getParsed(t), u = l._custom, c = eh(u);
    let h = l[i.axis], f = 0, d = n ? this.applyStack(i, l, n) : h, v, g;
    d !== h && (f = d - h, d = h), c && (h = u.barStart, d = u.barEnd - u.barStart, h !== 0 && Wi(h) !== Wi(u.barEnd) && (f = 0), f += h);
    const p = !Tt(a) && !c ? a : f;
    let m = i.getPixelForValue(p);
    if (this.chart.getDataVisibility(t) ? v = i.getPixelForValue(f + d) : v = m, g = v - m, Math.abs(g) < s) {
      g = sT(g, i, o) * s, h === o && (m -= g / 2);
      const y = i.getPixelForDecimal(0), _ = i.getPixelForDecimal(1), b = Math.min(y, _), x = Math.max(y, _);
      m = Math.max(Math.min(m, x), b), v = m + g, n && !c && (l._stacks[i.axis]._visualValues[r] = i.getValueForPixel(v) - i.getValueForPixel(m));
    }
    if (m === i.getPixelForValue(o)) {
      const y = Wi(g) * i.getLineWidthForValue(o) / 2;
      m += y, g -= y;
    }
    return {
      size: g,
      base: m,
      head: v,
      center: v + g / 2
    };
  }
  _calculateBarIndexPixels(t, i) {
    const n = i.scale, r = this.options, a = r.skipNull, s = ot(r.maxBarThickness, 1 / 0);
    let o, l;
    const u = this._getAxisCount();
    if (i.grouped) {
      const c = a ? this._getStackCount(t) : i.stackCount, h = r.barThickness === "flex" ? rT(t, i, r, c * u) : nT(t, i, r, c * u), f = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, d = this._getAxis().indexOf(ot(f, this.getFirstScaleIdForIndexAxis())), v = this._getStackIndex(this.index, this._cachedMeta.stack, a ? t : void 0) + d;
      o = h.start + h.chunk * v + h.chunk / 2, l = Math.min(s, h.chunk * h.ratio);
    } else
      o = n.getPixelForValue(this.getParsed(t)[n.axis], t), l = Math.min(s, i.min * i.ratio);
    return {
      base: o - l / 2,
      head: o + l / 2,
      center: o,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, i = t.vScale, n = t.data, r = n.length;
    let a = 0;
    for (; a < r; ++a)
      this.getParsed(a)[i.axis] !== null && !n[a].hidden && n[a].draw(this._ctx);
  }
}
function fT(e, t, i) {
  let n = 1, r = 1, a = 0, s = 0;
  if (t < Ut) {
    const o = e, l = o + t, u = Math.cos(o), c = Math.sin(o), h = Math.cos(l), f = Math.sin(l), d = (_, b, x) => wo(_, o, l, !0) ? 1 : Math.max(b, b * i, x, x * i), v = (_, b, x) => wo(_, o, l, !0) ? -1 : Math.min(b, b * i, x, x * i), g = d(0, u, h), p = d(se, c, f), m = v(kt, u, h), y = v(kt + se, c, f);
    n = (g - m) / 2, r = (p - y) / 2, a = -(g + m) / 2, s = -(p + y) / 2;
  }
  return {
    ratioX: n,
    ratioY: r,
    offsetX: a,
    offsetY: s
  };
}
class dT extends vc {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const i = t.data, { labels: { pointStyle: n, textAlign: r, color: a, useBorderRadius: s, borderRadius: o } } = t.legend.options;
            return i.labels.length && i.datasets.length ? i.labels.map((l, u) => {
              const h = t.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: l,
                fillStyle: h.backgroundColor,
                fontColor: a,
                hidden: !t.getDataVisibility(u),
                lineDash: h.borderDash,
                lineDashOffset: h.borderDashOffset,
                lineJoin: h.borderJoinStyle,
                lineWidth: h.borderWidth,
                strokeStyle: h.borderColor,
                textAlign: r,
                pointStyle: n,
                borderRadius: s && (o || h.borderRadius),
                index: u
              };
            }) : [];
          }
        },
        onClick(t, i, n) {
          n.chart.toggleDataVisibility(i.index), n.chart.update();
        }
      }
    }
  };
  constructor(t, i) {
    super(t, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, i) {
    const n = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = n;
    else {
      let a = (l) => +n[l];
      if (ft(n[t])) {
        const { key: l = "value" } = this._parsing;
        a = (u) => +ia(n[u], l);
      }
      let s, o;
      for (s = t, o = t + i; s < o; ++s)
        r._parsed[s] = a(s);
    }
  }
  _getRotation() {
    return fn(this.options.rotation - 90);
  }
  _getCircumference() {
    return fn(this.options.circumference);
  }
  _getRotationExtents() {
    let t = Ut, i = -Ut;
    for (let n = 0; n < this.chart.data.datasets.length; ++n)
      if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
        const r = this.chart.getDatasetMeta(n).controller, a = r._getRotation(), s = r._getCircumference();
        t = Math.min(t, a), i = Math.max(i, a + s);
      }
    return {
      rotation: t,
      circumference: i - t
    };
  }
  update(t) {
    const i = this.chart, { chartArea: n } = i, r = this._cachedMeta, a = r.data, s = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing, o = Math.max((Math.min(n.width, n.height) - s) / 2, 0), l = Math.min(_2(this.options.cutout, o), 1), u = this._getRingWeight(this.index), { circumference: c, rotation: h } = this._getRotationExtents(), { ratioX: f, ratioY: d, offsetX: v, offsetY: g } = fT(h, c, l), p = (n.width - s) / f, m = (n.height - s) / d, y = Math.max(Math.min(p, m) / 2, 0), _ = j0(this.options.radius, y), b = Math.max(_ * l, 0), x = (_ - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = v * _, this.offsetY = g * _, r.total = this.calculateTotal(), this.outerRadius = _ - x * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x * u, 0), this.updateElements(a, 0, a.length, t);
  }
  _circumference(t, i) {
    const n = this.options, r = this._cachedMeta, a = this._getCircumference();
    return i && n.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * a / Ut);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", s = this.chart, o = s.chartArea, u = s.options.animation, c = (o.left + o.right) / 2, h = (o.top + o.bottom) / 2, f = a && u.animateScale, d = f ? 0 : this.innerRadius, v = f ? 0 : this.outerRadius, { sharedOptions: g, includeOptions: p } = this._getSharedOptions(i, r);
    let m = this._getRotation(), y;
    for (y = 0; y < i; ++y)
      m += this._circumference(y, a);
    for (y = i; y < i + n; ++y) {
      const _ = this._circumference(y, a), b = t[y], x = {
        x: c + this.offsetX,
        y: h + this.offsetY,
        startAngle: m,
        endAngle: m + _,
        circumference: _,
        outerRadius: v,
        innerRadius: d
      };
      p && (x.options = g || this.resolveDataElementOptions(y, b.active ? "active" : r)), m += _, this.updateElement(b, y, x, r);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, i = t.data;
    let n = 0, r;
    for (r = 0; r < i.length; r++) {
      const a = t._parsed[r];
      a !== null && !isNaN(a) && this.chart.getDataVisibility(r) && !i[r].hidden && (n += Math.abs(a));
    }
    return n;
  }
  calculateCircumference(t) {
    const i = this._cachedMeta.total;
    return i > 0 && !isNaN(t) ? Ut * (Math.abs(t) / i) : 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = this.chart, r = n.data.labels || [], a = nv(i._parsed[t], n.options.locale);
    return {
      label: r[t] || "",
      value: a
    };
  }
  getMaxBorderWidth(t) {
    let i = 0;
    const n = this.chart;
    let r, a, s, o, l;
    if (!t) {
      for (r = 0, a = n.data.datasets.length; r < a; ++r)
        if (n.isDatasetVisible(r)) {
          s = n.getDatasetMeta(r), t = s.data, o = s.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (r = 0, a = t.length; r < a; ++r)
      l = o.resolveDataElementOptions(r), l.borderAlign !== "inner" && (i = Math.max(i, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return i;
  }
  getMaxOffset(t) {
    let i = 0;
    for (let n = 0, r = t.length; n < r; ++n) {
      const a = this.resolveDataElementOptions(n);
      i = Math.max(i, a.offset || 0, a.hoverOffset || 0);
    }
    return i;
  }
  _getRingWeightOffset(t) {
    let i = 0;
    for (let n = 0; n < t; ++n)
      this.chart.isDatasetVisible(n) && (i += this._getRingWeight(n));
    return i;
  }
  _getRingWeight(t) {
    return Math.max(ot(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class vT extends vc {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const i = this._cachedMeta, { dataset: n, data: r = [], _dataset: a } = i, s = this.chart._animationsDisabled;
    let { start: o, count: l } = z2(i, r, s);
    this._drawStart = o, this._drawCount = l, V2(i) && (o = 0, l = r.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!a._decimated, n.points = r;
    const u = this.resolveDatasetElementOptions(t);
    this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(n, void 0, {
      animated: !s,
      options: u
    }, t), this.updateElements(r, o, l, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { iScale: s, vScale: o, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: h } = this._getSharedOptions(i, r), f = s.axis, d = o.axis, { spanGaps: v, segment: g } = this.options, p = xo(v) ? v : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || a || r === "none", y = i + n, _ = t.length;
    let b = i > 0 && this.getParsed(i - 1);
    for (let x = 0; x < _; ++x) {
      const w = t[x], M = m ? w : {};
      if (x < i || x >= y) {
        M.skip = !0;
        continue;
      }
      const T = this.getParsed(x), D = Tt(T[d]), P = M[f] = s.getPixelForValue(T[f], x), C = M[d] = a || D ? o.getBasePixel() : o.getPixelForValue(l ? this.applyStack(o, T, l) : T[d], x);
      M.skip = isNaN(P) || isNaN(C) || D, M.stop = x > 0 && Math.abs(T[f] - b[f]) > p, g && (M.parsed = T, M.raw = u.data[x]), h && (M.options = c || this.resolveDataElementOptions(x, w.active ? "active" : r)), m || this.updateElement(w, x, M, r), b = T;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, i = t.dataset, n = i.options && i.options.borderWidth || 0, r = t.data || [];
    if (!r.length)
      return n;
    const a = r[0].size(this.resolveDataElementOptions(0)), s = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(n, a, s) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
class pT extends dT {
  static id = "pie";
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
}
function or() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class cv {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(cv.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return or();
  }
  parse() {
    return or();
  }
  format() {
    return or();
  }
  add() {
    return or();
  }
  diff() {
    return or();
  }
  startOf() {
    return or();
  }
  endOf() {
    return or();
  }
}
var gT = {
  _date: cv
};
function mT(e, t, i, n) {
  const { controller: r, data: a, _sorted: s } = e, o = r._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (o && t === o.axis && t !== "r" && s && a.length) {
    const u = o._reversePixels ? I2 : Br;
    if (n) {
      if (r._sharedOptions) {
        const c = a[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const f = u(a, t, i - h), d = u(a, t, i + h);
          return {
            lo: f.lo,
            hi: d.hi
          };
        }
      }
    } else {
      const c = u(a, t, i);
      if (l) {
        const { vScale: h } = r._cachedMeta, { _parsed: f } = e, d = f.slice(0, c.lo + 1).reverse().findIndex((g) => !Tt(g[h.axis]));
        c.lo -= Math.max(0, d);
        const v = f.slice(c.hi).findIndex((g) => !Tt(g[h.axis]));
        c.hi += Math.max(0, v);
      }
      return c;
    }
  }
  return {
    lo: 0,
    hi: a.length - 1
  };
}
function pc(e, t, i, n, r) {
  const a = e.getSortedVisibleDatasetMetas(), s = i[t];
  for (let o = 0, l = a.length; o < l; ++o) {
    const { index: u, data: c } = a[o], { lo: h, hi: f } = mT(a[o], t, s, r);
    for (let d = h; d <= f; ++d) {
      const v = c[d];
      v.skip || n(v, u, d);
    }
  }
}
function yT(e) {
  const t = e.indexOf("x") !== -1, i = e.indexOf("y") !== -1;
  return function(n, r) {
    const a = t ? Math.abs(n.x - r.x) : 0, s = i ? Math.abs(n.y - r.y) : 0;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(s, 2));
  };
}
function ih(e, t, i, n, r) {
  const a = [];
  return !r && !e.isPointInArea(t) || pc(e, i, t, function(o, l, u) {
    !r && !So(o, e.chartArea, 0) || o.inRange(t.x, t.y, n) && a.push({
      element: o,
      datasetIndex: l,
      index: u
    });
  }, !0), a;
}
function _T(e, t, i, n) {
  let r = [];
  function a(s, o, l) {
    const { startAngle: u, endAngle: c } = s.getProps([
      "startAngle",
      "endAngle"
    ], n), { angle: h } = Z0(s, {
      x: t.x,
      y: t.y
    });
    wo(h, u, c) && r.push({
      element: s,
      datasetIndex: o,
      index: l
    });
  }
  return pc(e, i, t, a), r;
}
function bT(e, t, i, n, r, a) {
  let s = [];
  const o = yT(i);
  let l = Number.POSITIVE_INFINITY;
  function u(c, h, f) {
    const d = c.inRange(t.x, t.y, r);
    if (n && !d)
      return;
    const v = c.getCenterPoint(r);
    if (!(!!a || e.isPointInArea(v)) && !d)
      return;
    const p = o(t, v);
    p < l ? (s = [
      {
        element: c,
        datasetIndex: h,
        index: f
      }
    ], l = p) : p === l && s.push({
      element: c,
      datasetIndex: h,
      index: f
    });
  }
  return pc(e, i, t, u), s;
}
function nh(e, t, i, n, r, a) {
  return !a && !e.isPointInArea(t) ? [] : i === "r" && !n ? _T(e, t, i, r) : bT(e, t, i, n, r, a);
}
function wg(e, t, i, n, r) {
  const a = [], s = i === "x" ? "inXRange" : "inYRange";
  let o = !1;
  return pc(e, i, t, (l, u, c) => {
    l[s] && l[s](t[i], r) && (a.push({
      element: l,
      datasetIndex: u,
      index: c
    }), o = o || l.inRange(t.x, t.y, r));
  }), n && !o ? [] : a;
}
var xT = {
  modes: {
    index(e, t, i, n) {
      const r = Or(t, e), a = i.axis || "x", s = i.includeInvisible || !1, o = i.intersect ? ih(e, r, a, n, s) : nh(e, r, a, !1, n, s), l = [];
      return o.length ? (e.getSortedVisibleDatasetMetas().forEach((u) => {
        const c = o[0].index, h = u.data[c];
        h && !h.skip && l.push({
          element: h,
          datasetIndex: u.index,
          index: c
        });
      }), l) : [];
    },
    dataset(e, t, i, n) {
      const r = Or(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      let o = i.intersect ? ih(e, r, a, n, s) : nh(e, r, a, !1, n, s);
      if (o.length > 0) {
        const l = o[0].datasetIndex, u = e.getDatasetMeta(l).data;
        o = [];
        for (let c = 0; c < u.length; ++c)
          o.push({
            element: u[c],
            datasetIndex: l,
            index: c
          });
      }
      return o;
    },
    point(e, t, i, n) {
      const r = Or(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      return ih(e, r, a, n, s);
    },
    nearest(e, t, i, n) {
      const r = Or(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      return nh(e, r, a, i.intersect, n, s);
    },
    x(e, t, i, n) {
      const r = Or(t, e);
      return wg(e, r, "x", i.intersect, n);
    },
    y(e, t, i, n) {
      const r = Or(t, e);
      return wg(e, r, "y", i.intersect, n);
    }
  }
};
const yb = [
  "left",
  "top",
  "right",
  "bottom"
];
function ms(e, t) {
  return e.filter((i) => i.pos === t);
}
function Sg(e, t) {
  return e.filter((i) => yb.indexOf(i.pos) === -1 && i.box.axis === t);
}
function ys(e, t) {
  return e.sort((i, n) => {
    const r = t ? n : i, a = t ? i : n;
    return r.weight === a.weight ? r.index - a.index : r.weight - a.weight;
  });
}
function wT(e) {
  const t = [];
  let i, n, r, a, s, o;
  for (i = 0, n = (e || []).length; i < n; ++i)
    r = e[i], { position: a, options: { stack: s, stackWeight: o = 1 } } = r, t.push({
      index: i,
      box: r,
      pos: a,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: s && a + s,
      stackWeight: o
    });
  return t;
}
function ST(e) {
  const t = {};
  for (const i of e) {
    const { stack: n, pos: r, stackWeight: a } = i;
    if (!n || !yb.includes(r))
      continue;
    const s = t[n] || (t[n] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    s.count++, s.weight += a;
  }
  return t;
}
function MT(e, t) {
  const i = ST(e), { vBoxMaxWidth: n, hBoxMaxHeight: r } = t;
  let a, s, o;
  for (a = 0, s = e.length; a < s; ++a) {
    o = e[a];
    const { fullSize: l } = o.box, u = i[o.stack], c = u && o.stackWeight / u.weight;
    o.horizontal ? (o.width = c ? c * n : l && t.availableWidth, o.height = r) : (o.width = n, o.height = c ? c * r : l && t.availableHeight);
  }
  return i;
}
function TT(e) {
  const t = wT(e), i = ys(t.filter((u) => u.box.fullSize), !0), n = ys(ms(t, "left"), !0), r = ys(ms(t, "right")), a = ys(ms(t, "top"), !0), s = ys(ms(t, "bottom")), o = Sg(t, "x"), l = Sg(t, "y");
  return {
    fullSize: i,
    leftAndTop: n.concat(a),
    rightAndBottom: r.concat(l).concat(s).concat(o),
    chartArea: ms(t, "chartArea"),
    vertical: n.concat(r).concat(l),
    horizontal: a.concat(s).concat(o)
  };
}
function Mg(e, t, i, n) {
  return Math.max(e[i], t[i]) + Math.max(e[n], t[n]);
}
function _b(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function DT(e, t, i, n) {
  const { pos: r, box: a } = i, s = e.maxPadding;
  if (!ft(r)) {
    i.size && (e[r] -= i.size);
    const h = n[i.stack] || {
      size: 0,
      count: 1
    };
    h.size = Math.max(h.size, i.horizontal ? a.height : a.width), i.size = h.size / h.count, e[r] += i.size;
  }
  a.getPadding && _b(s, a.getPadding());
  const o = Math.max(0, t.outerWidth - Mg(s, e, "left", "right")), l = Math.max(0, t.outerHeight - Mg(s, e, "top", "bottom")), u = o !== e.w, c = l !== e.h;
  return e.w = o, e.h = l, i.horizontal ? {
    same: u,
    other: c
  } : {
    same: c,
    other: u
  };
}
function CT(e) {
  const t = e.maxPadding;
  function i(n) {
    const r = Math.max(t[n] - e[n], 0);
    return e[n] += r, r;
  }
  e.y += i("top"), e.x += i("left"), i("right"), i("bottom");
}
function kT(e, t) {
  const i = t.maxPadding;
  function n(r) {
    const a = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((s) => {
      a[s] = Math.max(t[s], i[s]);
    }), a;
  }
  return n(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Gs(e, t, i, n) {
  const r = [];
  let a, s, o, l, u, c;
  for (a = 0, s = e.length, u = 0; a < s; ++a) {
    o = e[a], l = o.box, l.update(o.width || t.w, o.height || t.h, kT(o.horizontal, t));
    const { same: h, other: f } = DT(t, i, o, n);
    u |= h && r.length, c = c || f, l.fullSize || r.push(o);
  }
  return u && Gs(r, t, i, n) || c;
}
function sl(e, t, i, n, r) {
  e.top = i, e.left = t, e.right = t + n, e.bottom = i + r, e.width = n, e.height = r;
}
function Tg(e, t, i, n) {
  const r = i.padding;
  let { x: a, y: s } = t;
  for (const o of e) {
    const l = o.box, u = n[o.stack] || {
      placed: 0,
      weight: 1
    }, c = o.stackWeight / u.weight || 1;
    if (o.horizontal) {
      const h = t.w * c, f = u.size || l.height;
      bo(u.start) && (s = u.start), l.fullSize ? sl(l, r.left, s, i.outerWidth - r.right - r.left, f) : sl(l, t.left + u.placed, s, h, f), u.start = s, u.placed += h, s = l.bottom;
    } else {
      const h = t.h * c, f = u.size || l.width;
      bo(u.start) && (a = u.start), l.fullSize ? sl(l, a, r.top, f, i.outerHeight - r.bottom - r.top) : sl(l, a, t.top + u.placed, f, h), u.start = a, u.placed += h, a = l.right;
    }
  }
  t.x = a, t.y = s;
}
var hi = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            t.draw(i);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const i = e.boxes ? e.boxes.indexOf(t) : -1;
    i !== -1 && e.boxes.splice(i, 1);
  },
  configure(e, t, i) {
    t.fullSize = i.fullSize, t.position = i.position, t.weight = i.weight;
  },
  update(e, t, i, n) {
    if (!e)
      return;
    const r = di(e.options.layout.padding), a = Math.max(t - r.width, 0), s = Math.max(i - r.height, 0), o = TT(e.boxes), l = o.vertical, u = o.horizontal;
    Ct(e.boxes, (g) => {
      typeof g.beforeLayout == "function" && g.beforeLayout();
    });
    const c = l.reduce((g, p) => p.box.options && p.box.options.display === !1 ? g : g + 1, 0) || 1, h = Object.freeze({
      outerWidth: t,
      outerHeight: i,
      padding: r,
      availableWidth: a,
      availableHeight: s,
      vBoxMaxWidth: a / 2 / c,
      hBoxMaxHeight: s / 2
    }), f = Object.assign({}, r);
    _b(f, di(n));
    const d = Object.assign({
      maxPadding: f,
      w: a,
      h: s,
      x: r.left,
      y: r.top
    }, r), v = MT(l.concat(u), h);
    Gs(o.fullSize, d, h, v), Gs(l, d, h, v), Gs(u, d, h, v) && Gs(l, d, h, v), CT(d), Tg(o.leftAndTop, d, h, v), d.x += d.w, d.y += d.h, Tg(o.rightAndBottom, d, h, v), e.chartArea = {
      left: d.left,
      top: d.top,
      right: d.left + d.w,
      bottom: d.top + d.h,
      height: d.h,
      width: d.w
    }, Ct(o.chartArea, (g) => {
      const p = g.box;
      Object.assign(p, e.chartArea), p.update(d.w, d.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class bb {
  acquireContext(t, i) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, i, n) {
  }
  removeEventListener(t, i, n) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, i, n, r) {
    return i = Math.max(0, i || t.width), n = n || t.height, {
      width: i,
      height: Math.max(0, r ? Math.floor(i / r) : n)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class PT extends bb {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const Kl = "$chartjs", AT = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Dg = (e) => e === null || e === "";
function ET(e, t) {
  const i = e.style, n = e.getAttribute("height"), r = e.getAttribute("width");
  if (e[Kl] = {
    initial: {
      height: n,
      width: r,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", Dg(r)) {
    const a = ug(e, "width");
    a !== void 0 && (e.width = a);
  }
  if (Dg(n))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const a = ug(e, "height");
      a !== void 0 && (e.height = a);
    }
  return e;
}
const xb = PM ? {
  passive: !0
} : !1;
function LT(e, t, i) {
  e && e.addEventListener(t, i, xb);
}
function OT(e, t, i) {
  e && e.canvas && e.canvas.removeEventListener(t, i, xb);
}
function IT(e, t) {
  const i = AT[e.type] || e.type, { x: n, y: r } = Or(e, t);
  return {
    type: i,
    chart: t,
    native: e,
    x: n !== void 0 ? n : null,
    y: r !== void 0 ? r : null
  };
}
function bu(e, t) {
  for (const i of e)
    if (i === t || i.contains(t))
      return !0;
}
function RT(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let s = !1;
    for (const o of a)
      s = s || bu(o.addedNodes, n), s = s && !bu(o.removedNodes, n);
    s && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function NT(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let s = !1;
    for (const o of a)
      s = s || bu(o.removedNodes, n), s = s && !bu(o.addedNodes, n);
    s && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const To = /* @__PURE__ */ new Map();
let Cg = 0;
function wb() {
  const e = window.devicePixelRatio;
  e !== Cg && (Cg = e, To.forEach((t, i) => {
    i.currentDevicePixelRatio !== e && t();
  }));
}
function FT(e, t) {
  To.size || window.addEventListener("resize", wb), To.set(e, t);
}
function BT(e) {
  To.delete(e), To.size || window.removeEventListener("resize", wb);
}
function zT(e, t, i) {
  const n = e.canvas, r = n && uv(n);
  if (!r)
    return;
  const a = tb((o, l) => {
    const u = r.clientWidth;
    i(o, l), u < r.clientWidth && i();
  }, window), s = new ResizeObserver((o) => {
    const l = o[0], u = l.contentRect.width, c = l.contentRect.height;
    u === 0 && c === 0 || a(u, c);
  });
  return s.observe(r), FT(e, a), s;
}
function rh(e, t, i) {
  i && i.disconnect(), t === "resize" && BT(e);
}
function VT(e, t, i) {
  const n = e.canvas, r = tb((a) => {
    e.ctx !== null && i(IT(a, e));
  }, e);
  return LT(n, t, r), r;
}
class $T extends bb {
  acquireContext(t, i) {
    const n = t && t.getContext && t.getContext("2d");
    return n && n.canvas === t ? (ET(t, i), n) : null;
  }
  releaseContext(t) {
    const i = t.canvas;
    if (!i[Kl])
      return !1;
    const n = i[Kl].initial;
    [
      "height",
      "width"
    ].forEach((a) => {
      const s = n[a];
      Tt(s) ? i.removeAttribute(a) : i.setAttribute(a, s);
    });
    const r = n.style || {};
    return Object.keys(r).forEach((a) => {
      i.style[a] = r[a];
    }), i.width = i.width, delete i[Kl], !0;
  }
  addEventListener(t, i, n) {
    this.removeEventListener(t, i);
    const r = t.$proxies || (t.$proxies = {}), s = {
      attach: RT,
      detach: NT,
      resize: zT
    }[i] || VT;
    r[i] = s(t, i, n);
  }
  removeEventListener(t, i) {
    const n = t.$proxies || (t.$proxies = {}), r = n[i];
    if (!r)
      return;
    ({
      attach: rh,
      detach: rh,
      resize: rh
    }[i] || OT)(t, i, r), n[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, i, n, r) {
    return kM(t, i, n, r);
  }
  isAttached(t) {
    const i = t && uv(t);
    return !!(i && i.isConnected);
  }
}
function HT(e) {
  return !lv() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? PT : $T;
}
let Dn = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  hasValue() {
    return xo(this.x) && xo(this.y);
  }
  getProps(t, i) {
    const n = this.$animations;
    if (!i || !n)
      return this;
    const r = {};
    return t.forEach((a) => {
      r[a] = n[a] && n[a].active() ? n[a]._to : this[a];
    }), r;
  }
};
function YT(e, t) {
  const i = e.options.ticks, n = WT(e), r = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? GT(t) : [], s = a.length, o = a[0], l = a[s - 1], u = [];
  if (s > r)
    return jT(t, u, a, s / r), u;
  const c = UT(a, t, r);
  if (s > 0) {
    let h, f;
    const d = s > 1 ? Math.round((l - o) / (s - 1)) : null;
    for (ol(t, u, c, Tt(d) ? 0 : o - d, o), h = 0, f = s - 1; h < f; h++)
      ol(t, u, c, a[h], a[h + 1]);
    return ol(t, u, c, l, Tt(d) ? t.length : l + d), u;
  }
  return ol(t, u, c), u;
}
function WT(e) {
  const t = e.options.offset, i = e._tickSize(), n = e._length / i + (t ? 0 : 1), r = e._maxLength / i;
  return Math.floor(Math.min(n, r));
}
function UT(e, t, i) {
  const n = XT(e), r = t.length / i;
  if (!n)
    return Math.max(r, 1);
  const a = C2(n);
  for (let s = 0, o = a.length - 1; s < o; s++) {
    const l = a[s];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function GT(e) {
  const t = [];
  let i, n;
  for (i = 0, n = e.length; i < n; i++)
    e[i].major && t.push(i);
  return t;
}
function jT(e, t, i, n) {
  let r = 0, a = i[0], s;
  for (n = Math.ceil(n), s = 0; s < e.length; s++)
    s === a && (t.push(e[s]), r++, a = i[r * n]);
}
function ol(e, t, i, n, r) {
  const a = ot(n, 0), s = Math.min(ot(r, e.length), e.length);
  let o = 0, l, u, c;
  for (i = Math.ceil(i), r && (l = r - n, i = l / Math.floor(l / i)), c = a; c < 0; )
    o++, c = Math.round(a + o * i);
  for (u = Math.max(a, 0); u < s; u++)
    u === c && (t.push(e[u]), o++, c = Math.round(a + o * i));
}
function XT(e) {
  const t = e.length;
  let i, n;
  if (t < 2)
    return !1;
  for (n = e[0], i = 1; i < t; ++i)
    if (e[i] - e[i - 1] !== n)
      return !1;
  return n;
}
const qT = (e) => e === "left" ? "right" : e === "right" ? "left" : e, kg = (e, t, i) => t === "top" || t === "left" ? e[t] + i : e[t] - i, Pg = (e, t) => Math.min(t || e, e);
function Ag(e, t) {
  const i = [], n = e.length / t, r = e.length;
  let a = 0;
  for (; a < r; a += n)
    i.push(e[Math.floor(a)]);
  return i;
}
function ZT(e, t, i) {
  const n = e.ticks.length, r = Math.min(t, n - 1), a = e._startPixel, s = e._endPixel, o = 1e-6;
  let l = e.getPixelForTick(r), u;
  if (!(i && (n === 1 ? u = Math.max(l - a, s - l) : t === 0 ? u = (e.getPixelForTick(1) - l) / 2 : u = (l - e.getPixelForTick(r - 1)) / 2, l += r < t ? u : -u, l < a - o || l > s + o)))
    return l;
}
function KT(e, t) {
  Ct(e, (i) => {
    const n = i.gc, r = n.length / 2;
    let a;
    if (r > t) {
      for (a = 0; a < r; ++a)
        delete i.data[n[a]];
      n.splice(0, r);
    }
  });
}
function _s(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function Eg(e, t) {
  if (!e.display)
    return 0;
  const i = _e(e.font, t), n = di(e.padding);
  return (ne(e.text) ? e.text.length : 1) * i.lineHeight + n.height;
}
function QT(e, t) {
  return sa(e, {
    scale: t,
    type: "scale"
  });
}
function JT(e, t, i) {
  return sa(e, {
    tick: i,
    index: t,
    type: "tick"
  });
}
function tD(e, t, i) {
  let n = ev(e);
  return (i && t !== "right" || !i && t === "right") && (n = qT(n)), n;
}
function eD(e, t, i, n) {
  const { top: r, left: a, bottom: s, right: o, chart: l } = e, { chartArea: u, scales: c } = l;
  let h = 0, f, d, v;
  const g = s - r, p = o - a;
  if (e.isHorizontal()) {
    if (d = ge(n, a, o), ft(i)) {
      const m = Object.keys(i)[0], y = i[m];
      v = c[m].getPixelForValue(y) + g - t;
    } else i === "center" ? v = (u.bottom + u.top) / 2 + g - t : v = kg(e, i, t);
    f = o - a;
  } else {
    if (ft(i)) {
      const m = Object.keys(i)[0], y = i[m];
      d = c[m].getPixelForValue(y) - p + t;
    } else i === "center" ? d = (u.left + u.right) / 2 - p + t : d = kg(e, i, t);
    v = ge(n, s, r), h = i === "left" ? -se : se;
  }
  return {
    titleX: d,
    titleY: v,
    maxWidth: f,
    rotation: h
  };
}
class ss extends Dn {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, i) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: i, _suggestedMin: n, _suggestedMax: r } = this;
    return t = Li(t, Number.POSITIVE_INFINITY), i = Li(i, Number.NEGATIVE_INFINITY), n = Li(n, Number.POSITIVE_INFINITY), r = Li(r, Number.NEGATIVE_INFINITY), {
      min: Li(t, n),
      max: Li(i, r),
      minDefined: Se(t),
      maxDefined: Se(i)
    };
  }
  getMinMax(t) {
    let { min: i, max: n, minDefined: r, maxDefined: a } = this.getUserBounds(), s;
    if (r && a)
      return {
        min: i,
        max: n
      };
    const o = this.getMatchingVisibleMetas();
    for (let l = 0, u = o.length; l < u; ++l)
      s = o[l].controller.getMinMax(this, t), r || (i = Math.min(i, s.min)), a || (n = Math.max(n, s.max));
    return i = a && i > n ? n : i, n = r && i > n ? i : n, {
      min: Li(i, Li(n, i)),
      max: Li(n, Li(i, n))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    Rt(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, i, n) {
    const { beginAtZero: r, grace: a, ticks: s } = this.options, o = s.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = i, this._margins = n = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = sM(this, a, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = o < this.ticks.length;
    this._convertTicksToLabels(l ? Ag(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = YT(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, i, n;
    this.isHorizontal() ? (i = this.left, n = this.right) : (i = this.top, n = this.bottom, t = !t), this._startPixel = i, this._endPixel = n, this._reversePixels = t, this._length = n - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    Rt(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    Rt(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    Rt(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), Rt(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    Rt(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const i = this.options.ticks;
    let n, r, a;
    for (n = 0, r = t.length; n < r; n++)
      a = t[n], a.label = Rt(i.callback, [
        a.value,
        n,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    Rt(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    Rt(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, i = t.ticks, n = Pg(this.ticks.length, t.ticks.maxTicksLimit), r = i.minRotation || 0, a = i.maxRotation;
    let s = r, o, l, u;
    if (!this._isVisible() || !i.display || r >= a || n <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const c = this._getLabelSizes(), h = c.widest.width, f = c.highest.height, d = ye(this.chart.width - h, 0, this.maxWidth);
    o = t.offset ? this.maxWidth / n : d / (n - 1), h + 6 > o && (o = d / (n - (t.offset ? 0.5 : 1)), l = this.maxHeight - _s(t.grid) - i.padding - Eg(t.title, this.chart.options.font), u = Math.sqrt(h * h + f * f), s = E2(Math.min(Math.asin(ye((c.highest.height + 6) / o, -1, 1)), Math.asin(ye(l / u, -1, 1)) - Math.asin(ye(f / u, -1, 1)))), s = Math.max(r, Math.min(a, s))), this.labelRotation = s;
  }
  afterCalculateLabelRotation() {
    Rt(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    Rt(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: n, title: r, grid: a } } = this, s = this._isVisible(), o = this.isHorizontal();
    if (s) {
      const l = Eg(r, i.options.font);
      if (o ? (t.width = this.maxWidth, t.height = _s(a) + l) : (t.height = this.maxHeight, t.width = _s(a) + l), n.display && this.ticks.length) {
        const { first: u, last: c, widest: h, highest: f } = this._getLabelSizes(), d = n.padding * 2, v = fn(this.labelRotation), g = Math.cos(v), p = Math.sin(v);
        if (o) {
          const m = n.mirror ? 0 : p * h.width + g * f.height;
          t.height = Math.min(this.maxHeight, t.height + m + d);
        } else {
          const m = n.mirror ? 0 : g * h.width + p * f.height;
          t.width = Math.min(this.maxWidth, t.width + m + d);
        }
        this._calculatePadding(u, c, p, g);
      }
    }
    this._handleMargins(), o ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, i, n, r) {
    const { ticks: { align: a, padding: s }, position: o } = this.options, l = this.labelRotation !== 0, u = o !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);
      let f = 0, d = 0;
      l ? u ? (f = r * t.width, d = n * i.height) : (f = n * t.height, d = r * i.width) : a === "start" ? d = i.width : a === "end" ? f = t.width : a !== "inner" && (f = t.width / 2, d = i.width / 2), this.paddingLeft = Math.max((f - c + s) * this.width / (this.width - c), 0), this.paddingRight = Math.max((d - h + s) * this.width / (this.width - h), 0);
    } else {
      let c = i.height / 2, h = t.height / 2;
      a === "start" ? (c = 0, h = t.height) : a === "end" && (c = i.height, h = 0), this.paddingTop = c + s, this.paddingBottom = h + s;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    Rt(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: i } = this.options;
    return i === "top" || i === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let i, n;
    for (i = 0, n = t.length; i < n; i++)
      Tt(t[i].label) && (t.splice(i, 1), n--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const i = this.options.ticks.sampleSize;
      let n = this.ticks;
      i < n.length && (n = Ag(n, i)), this._labelSizes = t = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, i, n) {
    const { ctx: r, _longestTextCache: a } = this, s = [], o = [], l = Math.floor(i / Pg(i, n));
    let u = 0, c = 0, h, f, d, v, g, p, m, y, _, b, x;
    for (h = 0; h < i; h += l) {
      if (v = t[h].label, g = this._resolveTickFontOptions(h), r.font = p = g.string, m = a[p] = a[p] || {
        data: {},
        gc: []
      }, y = g.lineHeight, _ = b = 0, !Tt(v) && !ne(v))
        _ = rg(r, m.data, m.gc, _, v), b = y;
      else if (ne(v))
        for (f = 0, d = v.length; f < d; ++f)
          x = v[f], !Tt(x) && !ne(x) && (_ = rg(r, m.data, m.gc, _, x), b += y);
      s.push(_), o.push(b), u = Math.max(_, u), c = Math.max(b, c);
    }
    KT(a, i);
    const w = s.indexOf(u), M = o.indexOf(c), T = (D) => ({
      width: s[D] || 0,
      height: o[D] || 0
    });
    return {
      first: T(0),
      last: T(i - 1),
      widest: T(w),
      highest: T(M),
      widths: s,
      heights: o
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, i) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const i = this._startPixel + t * this._length;
    return O2(this._alignToPixels ? sr(this.chart, i, 0) : i);
  }
  getDecimalForPixel(t) {
    const i = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: i } = this;
    return t < 0 && i < 0 ? i : t > 0 && i > 0 ? t : 0;
  }
  getContext(t) {
    const i = this.ticks || [];
    if (t >= 0 && t < i.length) {
      const n = i[t];
      return n.$context || (n.$context = JT(this.getContext(), t, n));
    }
    return this.$context || (this.$context = QT(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, i = fn(this.labelRotation), n = Math.abs(Math.cos(i)), r = Math.abs(Math.sin(i)), a = this._getLabelSizes(), s = t.autoSkipPadding || 0, o = a ? a.widest.width + s : 0, l = a ? a.highest.height + s : 0;
    return this.isHorizontal() ? l * n > o * r ? o / n : l / r : l * r < o * n ? l / n : o / r;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const i = this.axis, n = this.chart, r = this.options, { grid: a, position: s, border: o } = r, l = a.offset, u = this.isHorizontal(), h = this.ticks.length + (l ? 1 : 0), f = _s(a), d = [], v = o.setContext(this.getContext()), g = v.display ? v.width : 0, p = g / 2, m = function(N) {
      return sr(n, N, g);
    };
    let y, _, b, x, w, M, T, D, P, C, A, E;
    if (s === "top")
      y = m(this.bottom), M = this.bottom - f, D = y - p, C = m(t.top) + p, E = t.bottom;
    else if (s === "bottom")
      y = m(this.top), C = t.top, E = m(t.bottom) - p, M = y + p, D = this.top + f;
    else if (s === "left")
      y = m(this.right), w = this.right - f, T = y - p, P = m(t.left) + p, A = t.right;
    else if (s === "right")
      y = m(this.left), P = t.left, A = m(t.right) - p, w = y + p, T = this.left + f;
    else if (i === "x") {
      if (s === "center")
        y = m((t.top + t.bottom) / 2 + 0.5);
      else if (ft(s)) {
        const N = Object.keys(s)[0], B = s[N];
        y = m(this.chart.scales[N].getPixelForValue(B));
      }
      C = t.top, E = t.bottom, M = y + p, D = M + f;
    } else if (i === "y") {
      if (s === "center")
        y = m((t.left + t.right) / 2);
      else if (ft(s)) {
        const N = Object.keys(s)[0], B = s[N];
        y = m(this.chart.scales[N].getPixelForValue(B));
      }
      w = y - p, T = w - f, P = t.left, A = t.right;
    }
    const R = ot(r.ticks.maxTicksLimit, h), I = Math.max(1, Math.ceil(h / R));
    for (_ = 0; _ < h; _ += I) {
      const N = this.getContext(_), B = a.setContext(N), $ = o.setContext(N), H = B.lineWidth, G = B.color, nt = $.dash || [], K = $.dashOffset, pt = B.tickWidth, gt = B.tickColor, Ht = B.tickBorderDash || [], ht = B.tickBorderDashOffset;
      b = ZT(this, _, l), b !== void 0 && (x = sr(n, b, H), u ? w = T = P = A = x : M = D = C = E = x, d.push({
        tx1: w,
        ty1: M,
        tx2: T,
        ty2: D,
        x1: P,
        y1: C,
        x2: A,
        y2: E,
        width: H,
        color: G,
        borderDash: nt,
        borderDashOffset: K,
        tickWidth: pt,
        tickColor: gt,
        tickBorderDash: Ht,
        tickBorderDashOffset: ht
      }));
    }
    return this._ticksLength = h, this._borderValue = y, d;
  }
  _computeLabelItems(t) {
    const i = this.axis, n = this.options, { position: r, ticks: a } = n, s = this.isHorizontal(), o = this.ticks, { align: l, crossAlign: u, padding: c, mirror: h } = a, f = _s(n.grid), d = f + c, v = h ? -c : d, g = -fn(this.labelRotation), p = [];
    let m, y, _, b, x, w, M, T, D, P, C, A, E = "middle";
    if (r === "top")
      w = this.bottom - v, M = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      w = this.top + v, M = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const I = this._getYAxisLabelAlignment(f);
      M = I.textAlign, x = I.x;
    } else if (r === "right") {
      const I = this._getYAxisLabelAlignment(f);
      M = I.textAlign, x = I.x;
    } else if (i === "x") {
      if (r === "center")
        w = (t.top + t.bottom) / 2 + d;
      else if (ft(r)) {
        const I = Object.keys(r)[0], N = r[I];
        w = this.chart.scales[I].getPixelForValue(N) + d;
      }
      M = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (r === "center")
        x = (t.left + t.right) / 2 - d;
      else if (ft(r)) {
        const I = Object.keys(r)[0], N = r[I];
        x = this.chart.scales[I].getPixelForValue(N);
      }
      M = this._getYAxisLabelAlignment(f).textAlign;
    }
    i === "y" && (l === "start" ? E = "top" : l === "end" && (E = "bottom"));
    const R = this._getLabelSizes();
    for (m = 0, y = o.length; m < y; ++m) {
      _ = o[m], b = _.label;
      const I = a.setContext(this.getContext(m));
      T = this.getPixelForTick(m) + a.labelOffset, D = this._resolveTickFontOptions(m), P = D.lineHeight, C = ne(b) ? b.length : 1;
      const N = C / 2, B = I.color, $ = I.textStrokeColor, H = I.textStrokeWidth;
      let G = M;
      s ? (x = T, M === "inner" && (m === y - 1 ? G = this.options.reverse ? "left" : "right" : m === 0 ? G = this.options.reverse ? "right" : "left" : G = "center"), r === "top" ? u === "near" || g !== 0 ? A = -C * P + P / 2 : u === "center" ? A = -R.highest.height / 2 - N * P + P : A = -R.highest.height + P / 2 : u === "near" || g !== 0 ? A = P / 2 : u === "center" ? A = R.highest.height / 2 - N * P : A = R.highest.height - C * P, h && (A *= -1), g !== 0 && !I.showLabelBackdrop && (x += P / 2 * Math.sin(g))) : (w = T, A = (1 - C) * P / 2);
      let nt;
      if (I.showLabelBackdrop) {
        const K = di(I.backdropPadding), pt = R.heights[m], gt = R.widths[m];
        let Ht = A - K.top, ht = 0 - K.left;
        switch (E) {
          case "middle":
            Ht -= pt / 2;
            break;
          case "bottom":
            Ht -= pt;
            break;
        }
        switch (M) {
          case "center":
            ht -= gt / 2;
            break;
          case "right":
            ht -= gt;
            break;
          case "inner":
            m === y - 1 ? ht -= gt : m > 0 && (ht -= gt / 2);
            break;
        }
        nt = {
          left: ht,
          top: Ht,
          width: gt + K.width,
          height: pt + K.height,
          color: I.backdropColor
        };
      }
      p.push({
        label: b,
        font: D,
        textOffset: A,
        options: {
          rotation: g,
          color: B,
          strokeColor: $,
          strokeWidth: H,
          textAlign: G,
          textBaseline: E,
          translation: [
            x,
            w
          ],
          backdrop: nt
        }
      });
    }
    return p;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: i } = this.options;
    if (-fn(this.labelRotation))
      return t === "top" ? "left" : "right";
    let r = "center";
    return i.align === "start" ? r = "left" : i.align === "end" ? r = "right" : i.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(t) {
    const { position: i, ticks: { crossAlign: n, mirror: r, padding: a } } = this.options, s = this._getLabelSizes(), o = t + a, l = s.widest.width;
    let u, c;
    return i === "left" ? r ? (c = this.right + a, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - o, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : i === "right" ? r ? (c = this.left + a, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + o, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", {
      textAlign: u,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: i }, left: n, top: r, width: a, height: s } = this;
    i && (t.save(), t.fillStyle = i, t.fillRect(n, r, a, s), t.restore());
  }
  getLineWidthForValue(t) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const r = this.ticks.findIndex((a) => a.value === t);
    return r >= 0 ? i.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(t) {
    const i = this.options.grid, n = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let a, s;
    const o = (l, u, c) => {
      !c.width || !c.color || (n.save(), n.lineWidth = c.width, n.strokeStyle = c.color, n.setLineDash(c.borderDash || []), n.lineDashOffset = c.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(u.x, u.y), n.stroke(), n.restore());
    };
    if (i.display)
      for (a = 0, s = r.length; a < s; ++a) {
        const l = r[a];
        i.drawOnChartArea && o({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), i.drawTicks && o({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: i, options: { border: n, grid: r } } = this, a = n.setContext(this.getContext()), s = n.display ? a.width : 0;
    if (!s)
      return;
    const o = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let u, c, h, f;
    this.isHorizontal() ? (u = sr(t, this.left, s) - s / 2, c = sr(t, this.right, o) + o / 2, h = f = l) : (h = sr(t, this.top, s) - s / 2, f = sr(t, this.bottom, o) + o / 2, u = c = l), i.save(), i.lineWidth = a.width, i.strokeStyle = a.color, i.beginPath(), i.moveTo(u, h), i.lineTo(c, f), i.stroke(), i.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const n = this.ctx, r = this._computeLabelArea();
    r && hc(n, r);
    const a = this.getLabelItems(t);
    for (const s of a) {
      const o = s.options, l = s.font, u = s.label, c = s.textOffset;
      Mo(n, u, 0, c, l, o);
    }
    r && fc(n);
  }
  drawTitle() {
    const { ctx: t, options: { position: i, title: n, reverse: r } } = this;
    if (!n.display)
      return;
    const a = _e(n.font), s = di(n.padding), o = n.align;
    let l = a.lineHeight / 2;
    i === "bottom" || i === "center" || ft(i) ? (l += s.bottom, ne(n.text) && (l += a.lineHeight * (n.text.length - 1))) : l += s.top;
    const { titleX: u, titleY: c, maxWidth: h, rotation: f } = eD(this, l, i, o);
    Mo(t, n.text, 0, 0, a, {
      color: n.color,
      maxWidth: h,
      rotation: f,
      textAlign: tD(o, i, r),
      textBaseline: "middle",
      translation: [
        u,
        c
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, i = t.ticks && t.ticks.z || 0, n = ot(t.grid && t.grid.z, -1), r = ot(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== ss.prototype.draw ? [
      {
        z: i,
        draw: (a) => {
          this.draw(a);
        }
      }
    ] : [
      {
        z: n,
        draw: (a) => {
          this.drawBackground(), this.drawGrid(a), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (a) => {
          this.drawLabels(a);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const i = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", r = [];
    let a, s;
    for (a = 0, s = i.length; a < s; ++a) {
      const o = i[a];
      o[n] === this.id && (!t || o.type === t) && r.push(o);
    }
    return r;
  }
  _resolveTickFontOptions(t) {
    const i = this.options.ticks.setContext(this.getContext(t));
    return _e(i.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class ll {
  constructor(t, i, n) {
    this.type = t, this.scope = i, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const i = Object.getPrototypeOf(t);
    let n;
    rD(i) && (n = this.register(i));
    const r = this.items, a = t.id, s = this.scope + "." + a;
    if (!a)
      throw new Error("class does not have id: " + t);
    return a in r || (r[a] = t, iD(t, s, n), this.override && ee.override(t.id, t.overrides)), s;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const i = this.items, n = t.id, r = this.scope;
    n in i && delete i[n], r && n in ee[r] && (delete ee[r][n], this.override && delete na[n]);
  }
}
function iD(e, t, i) {
  const n = _o(/* @__PURE__ */ Object.create(null), [
    i ? ee.get(i) : {},
    ee.get(t),
    e.defaults
  ]);
  ee.set(t, n), e.defaultRoutes && nD(t, e.defaultRoutes), e.descriptors && ee.describe(t, e.descriptors);
}
function nD(e, t) {
  Object.keys(t).forEach((i) => {
    const n = i.split("."), r = n.pop(), a = [
      e
    ].concat(n).join("."), s = t[i].split("."), o = s.pop(), l = s.join(".");
    ee.route(a, r, l, o);
  });
}
function rD(e) {
  return "id" in e && "defaults" in e;
}
class aD {
  constructor() {
    this.controllers = new ll(vc, "datasets", !0), this.elements = new ll(Dn, "elements"), this.plugins = new ll(Object, "plugins"), this.scales = new ll(ss, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, i, n) {
    [
      ...i
    ].forEach((r) => {
      const a = n || this._getRegistryForType(r);
      n || a.isForType(r) || a === this.plugins && r.id ? this._exec(t, a, r) : Ct(r, (s) => {
        const o = n || this._getRegistryForType(s);
        this._exec(t, o, s);
      });
    });
  }
  _exec(t, i, n) {
    const r = Jd(t);
    Rt(n["before" + r], [], n), i[t](n), Rt(n["after" + r], [], n);
  }
  _getRegistryForType(t) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const n = this._typedRegistries[i];
      if (n.isForType(t))
        return n;
    }
    return this.plugins;
  }
  _get(t, i, n) {
    const r = i.get(t);
    if (r === void 0)
      throw new Error('"' + t + '" is not a registered ' + n + ".");
    return r;
  }
}
var zi = /* @__PURE__ */ new aD();
class sD {
  constructor() {
    this._init = void 0;
  }
  notify(t, i, n, r) {
    if (i === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")), this._init === void 0)
      return;
    const a = r ? this._descriptors(t).filter(r) : this._descriptors(t), s = this._notify(a, t, i, n);
    return i === "afterDestroy" && (this._notify(a, t, "stop"), this._notify(this._init, t, "uninstall"), this._init = void 0), s;
  }
  _notify(t, i, n, r) {
    r = r || {};
    for (const a of t) {
      const s = a.plugin, o = s[n], l = [
        i,
        r,
        a.options
      ];
      if (Rt(o, l, s) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    Tt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), i;
  }
  _createDescriptors(t, i) {
    const n = t && t.config, r = ot(n.options && n.options.plugins, {}), a = oD(n);
    return r === !1 && !i ? [] : uD(t, a, r, i);
  }
  _notifyStateChanges(t) {
    const i = this._oldCache || [], n = this._cache, r = (a, s) => a.filter((o) => !s.some((l) => o.plugin.id === l.plugin.id));
    this._notify(r(i, n), t, "stop"), this._notify(r(n, i), t, "start");
  }
}
function oD(e) {
  const t = {}, i = [], n = Object.keys(zi.plugins.items);
  for (let a = 0; a < n.length; a++)
    i.push(zi.getPlugin(n[a]));
  const r = e.plugins || [];
  for (let a = 0; a < r.length; a++) {
    const s = r[a];
    i.indexOf(s) === -1 && (i.push(s), t[s.id] = !0);
  }
  return {
    plugins: i,
    localIds: t
  };
}
function lD(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function uD(e, { plugins: t, localIds: i }, n, r) {
  const a = [], s = e.getContext();
  for (const o of t) {
    const l = o.id, u = lD(n[l], r);
    u !== null && a.push({
      plugin: o,
      options: cD(e.config, {
        plugin: o,
        local: i[l]
      }, u, s)
    });
  }
  return a;
}
function cD(e, { plugin: t, local: i }, n, r) {
  const a = e.pluginScopeKeys(t), s = e.getOptionScopes(n, a);
  return i && t.defaults && s.push(t.defaults), e.createResolver(s, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Ff(e, t) {
  const i = ee.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || i.indexAxis || "x";
}
function hD(e, t) {
  let i = e;
  return e === "_index_" ? i = t : e === "_value_" && (i = t === "x" ? "y" : "x"), i;
}
function fD(e, t) {
  return e === t ? "_index_" : "_value_";
}
function Lg(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function dD(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function Bf(e, ...t) {
  if (Lg(e))
    return e;
  for (const i of t) {
    const n = i.axis || dD(i.position) || e.length > 1 && Lg(e[0].toLowerCase());
    if (n)
      return n;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function Og(e, t, i) {
  if (i[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function vD(e, t) {
  if (t.data && t.data.datasets) {
    const i = t.data.datasets.filter((n) => n.xAxisID === e || n.yAxisID === e);
    if (i.length)
      return Og(e, "x", i[0]) || Og(e, "y", i[0]);
  }
  return {};
}
function pD(e, t) {
  const i = na[e.type] || {
    scales: {}
  }, n = t.scales || {}, r = Ff(e.type, t), a = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach((s) => {
    const o = n[s];
    if (!ft(o))
      return console.error(`Invalid scale configuration for scale: ${s}`);
    if (o._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${s}`);
    const l = Bf(s, o, vD(s, e), ee.scales[o.type]), u = fD(l, r), c = i.scales || {};
    a[s] = no(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      o,
      c[l],
      c[u]
    ]);
  }), e.data.datasets.forEach((s) => {
    const o = s.type || e.type, l = s.indexAxis || Ff(o, t), c = (na[o] || {}).scales || {};
    Object.keys(c).forEach((h) => {
      const f = hD(h, l), d = s[f + "AxisID"] || f;
      a[d] = a[d] || /* @__PURE__ */ Object.create(null), no(a[d], [
        {
          axis: f
        },
        n[d],
        c[h]
      ]);
    });
  }), Object.keys(a).forEach((s) => {
    const o = a[s];
    no(o, [
      ee.scales[o.type],
      ee.scale
    ]);
  }), a;
}
function Sb(e) {
  const t = e.options || (e.options = {});
  t.plugins = ot(t.plugins, {}), t.scales = pD(e, t);
}
function Mb(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function gD(e) {
  return e = e || {}, e.data = Mb(e.data), Sb(e), e;
}
const Ig = /* @__PURE__ */ new Map(), Tb = /* @__PURE__ */ new Set();
function ul(e, t) {
  let i = Ig.get(e);
  return i || (i = t(), Ig.set(e, i), Tb.add(i)), i;
}
const bs = (e, t, i) => {
  const n = ia(t, i);
  n !== void 0 && e.add(n);
};
class mD {
  constructor(t) {
    this._config = gD(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Mb(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Sb(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return ul(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, i) {
    return ul(`${t}.transition.${i}`, () => [
      [
        `datasets.${t}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, i) {
    return ul(`${t}-${i}`, () => [
      [
        `datasets.${t}.elements.${i}`,
        `datasets.${t}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const i = t.id, n = this.type;
    return ul(`${n}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, i) {
    const n = this._scopeCache;
    let r = n.get(t);
    return (!r || i) && (r = /* @__PURE__ */ new Map(), n.set(t, r)), r;
  }
  getOptionScopes(t, i, n) {
    const { options: r, type: a } = this, s = this._cachedScopes(t, n), o = s.get(i);
    if (o)
      return o;
    const l = /* @__PURE__ */ new Set();
    i.forEach((c) => {
      t && (l.add(t), c.forEach((h) => bs(l, t, h))), c.forEach((h) => bs(l, r, h)), c.forEach((h) => bs(l, na[a] || {}, h)), c.forEach((h) => bs(l, ee, h)), c.forEach((h) => bs(l, Rf, h));
    });
    const u = Array.from(l);
    return u.length === 0 && u.push(/* @__PURE__ */ Object.create(null)), Tb.has(i) && s.set(i, u), u;
  }
  chartOptionScopes() {
    const { options: t, type: i } = this;
    return [
      t,
      na[i] || {},
      ee.datasets[i] || {},
      {
        type: i
      },
      ee,
      Rf
    ];
  }
  resolveNamedOptions(t, i, n, r = [
    ""
  ]) {
    const a = {
      $shared: !0
    }, { resolver: s, subPrefixes: o } = Rg(this._resolverCache, t, r);
    let l = s;
    if (_D(s, i)) {
      a.$shared = !1, n = Kn(n) ? n() : n;
      const u = this.createResolver(t, n, o);
      l = Qa(s, n, u);
    }
    for (const u of i)
      a[u] = l[u];
    return a;
  }
  createResolver(t, i, n = [
    ""
  ], r) {
    const { resolver: a } = Rg(this._resolverCache, t, n);
    return ft(i) ? Qa(a, i, void 0, r) : a;
  }
}
function Rg(e, t, i) {
  let n = e.get(t);
  n || (n = /* @__PURE__ */ new Map(), e.set(t, n));
  const r = i.join();
  let a = n.get(r);
  return a || (a = {
    resolver: av(t, i),
    subPrefixes: i.filter((o) => !o.toLowerCase().includes("hover"))
  }, n.set(r, a)), a;
}
const yD = (e) => ft(e) && Object.getOwnPropertyNames(e).some((t) => Kn(e[t]));
function _D(e, t) {
  const { isScriptable: i, isIndexable: n } = rb(e);
  for (const r of t) {
    const a = i(r), s = n(r), o = (s || a) && e[r];
    if (a && (Kn(o) || yD(o)) || s && ne(o))
      return !0;
  }
  return !1;
}
var bD = "4.5.1";
const xD = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Ng(e, t) {
  return e === "top" || e === "bottom" || xD.indexOf(e) === -1 && t === "x";
}
function Fg(e, t) {
  return function(i, n) {
    return i[e] === n[e] ? i[t] - n[t] : i[e] - n[e];
  };
}
function Bg(e) {
  const t = e.chart, i = t.options.animation;
  t.notifyPlugins("afterRender"), Rt(i && i.onComplete, [
    e
  ], t);
}
function wD(e) {
  const t = e.chart, i = t.options.animation;
  Rt(i && i.onProgress, [
    e
  ], t);
}
function Db(e) {
  return lv() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const Ql = {}, zg = (e) => {
  const t = Db(e);
  return Object.values(Ql).filter((i) => i.canvas === t).pop();
};
function SD(e, t, i) {
  const n = Object.keys(e);
  for (const r of n) {
    const a = +r;
    if (a >= t) {
      const s = e[r];
      delete e[r], (i > 0 || a > t) && (e[a + i] = s);
    }
  }
}
function MD(e, t, i, n) {
  return !i || e.type === "mouseout" ? null : n ? t : e;
}
let os = class {
  static defaults = ee;
  static instances = Ql;
  static overrides = na;
  static registry = zi;
  static version = bD;
  static getChart = zg;
  static register(...t) {
    zi.add(...t), Vg();
  }
  static unregister(...t) {
    zi.remove(...t), Vg();
  }
  constructor(t, i) {
    const n = this.config = new mD(i), r = Db(t), a = zg(r);
    if (a)
      throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas with ID '" + a.canvas.id + "' can be reused.");
    const s = n.createResolver(n.chartOptionScopes(), this.getContext());
    this.platform = new (n.platform || HT(r))(), this.platform.updateConfig(n);
    const o = this.platform.acquireContext(r, s.aspectRatio), l = o && o.canvas, u = l && l.height, c = l && l.width;
    if (this.id = y2(), this.ctx = o, this.canvas = l, this.width = c, this.height = u, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new sD(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = F2((h) => this.update(h), s.resizeDelay || 0), this._dataChanges = [], Ql[this.id] = this, !o || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    on.listen(this, "complete", Bg), on.listen(this, "progress", wD), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: i }, width: n, height: r, _aspectRatio: a } = this;
    return Tt(t) ? i && a ? a : r ? n / r : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return zi;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : lg(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return ag(this.canvas, this.ctx), this;
  }
  stop() {
    return on.stop(this), this;
  }
  resize(t, i) {
    on.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: i
    } : this._resize(t, i);
  }
  _resize(t, i) {
    const n = this.options, r = this.canvas, a = n.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(r, t, i, a), o = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, lg(this, o, !0) && (this.notifyPlugins("resize", {
      size: s
    }), Rt(n.onResize, [
      this,
      s
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    Ct(i, (n, r) => {
      n.id = r;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, i = t.scales, n = this.scales, r = Object.keys(n).reduce((s, o) => (s[o] = !1, s), {});
    let a = [];
    i && (a = a.concat(Object.keys(i).map((s) => {
      const o = i[s], l = Bf(s, o), u = l === "r", c = l === "x";
      return {
        options: o,
        dposition: u ? "chartArea" : c ? "bottom" : "left",
        dtype: u ? "radialLinear" : c ? "category" : "linear"
      };
    }))), Ct(a, (s) => {
      const o = s.options, l = o.id, u = Bf(l, o), c = ot(o.type, s.dtype);
      (o.position === void 0 || Ng(o.position, u) !== Ng(s.dposition)) && (o.position = s.dposition), r[l] = !0;
      let h = null;
      if (l in n && n[l].type === c)
        h = n[l];
      else {
        const f = zi.getScale(c);
        h = new f({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), n[h.id] = h;
      }
      h.init(o, t);
    }), Ct(r, (s, o) => {
      s || delete n[o];
    }), Ct(n, (s) => {
      hi.configure(this, s, s.options), hi.addBox(this, s);
    });
  }
  _updateMetasets() {
    const t = this._metasets, i = this.data.datasets.length, n = t.length;
    if (t.sort((r, a) => r.index - a.index), n > i) {
      for (let r = i; r < n; ++r)
        this._destroyDatasetMeta(r);
      t.splice(i, n - i);
    }
    this._sortedMetasets = t.slice(0).sort(Fg("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: i } } = this;
    t.length > i.length && delete this._stacks, t.forEach((n, r) => {
      i.filter((a) => a === n._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const t = [], i = this.data.datasets;
    let n, r;
    for (this._removeUnreferencedMetasets(), n = 0, r = i.length; n < r; n++) {
      const a = i[n];
      let s = this.getDatasetMeta(n);
      const o = a.type || this.config.type;
      if (s.type && s.type !== o && (this._destroyDatasetMeta(n), s = this.getDatasetMeta(n)), s.type = o, s.indexAxis = a.indexAxis || Ff(o, this.options), s.order = a.order || 0, s.index = n, s.label = "" + a.label, s.visible = this.isDatasetVisible(n), s.controller)
        s.controller.updateIndex(n), s.controller.linkScales();
      else {
        const l = zi.getController(o), { datasetElementType: u, dataElementType: c } = ee.datasets[o];
        Object.assign(l, {
          dataElementType: zi.getElement(c),
          datasetElementType: u && zi.getElement(u)
        }), s.controller = new l(this, n), t.push(s.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    Ct(this.data.datasets, (t, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const i = this.config;
    i.update();
    const n = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !n.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const a = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let s = 0;
    for (let u = 0, c = this.data.datasets.length; u < c; u++) {
      const { controller: h } = this.getDatasetMeta(u), f = !r && a.indexOf(h) === -1;
      h.buildOrUpdateElements(f), s = Math.max(+h.getMaxOverflow(), s);
    }
    s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), r || Ct(a, (u) => {
      u.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(Fg("z", "_idx"));
    const { _active: o, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : o.length && this._updateHoverStyles(o, o, !0), this.render();
  }
  _updateScales() {
    Ct(this.scales, (t) => {
      hi.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, i = new Set(Object.keys(this._listeners)), n = new Set(t.events);
    (!qp(i, n) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, i = this._getUniformDataChanges() || [];
    for (const { method: n, start: r, count: a } of i) {
      const s = n === "_removeElements" ? -a : a;
      SD(t, r, s);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, n = (a) => new Set(t.filter((s) => s[0] === a).map((s, o) => o + "," + s.splice(1).join(","))), r = n(0);
    for (let a = 1; a < i; a++)
      if (!qp(r, n(a)))
        return;
    return Array.from(r).map((a) => a.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    hi.update(this, this.width, this.height, t);
    const i = this.chartArea, n = i.width <= 0 || i.height <= 0;
    this._layers = [], Ct(this.boxes, (r) => {
      n && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, a) => {
      r._idx = a;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this._updateDataset(i, Kn(t) ? t({
          datasetIndex: i
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, i) {
    const n = this.getDatasetMeta(t), r = {
      meta: n,
      index: t,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (n.controller._update(i), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (on.has(this) ? this.attached && !on.running(this) && on.start(this) : (this.draw(), Bg({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: n, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(n, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (t = 0; t < i.length && i[t].z <= 0; ++t)
      i[t].draw(this.chartArea);
    for (this._drawDatasets(); t < i.length; ++t)
      i[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const i = this._sortedMetasets, n = [];
    let r, a;
    for (r = 0, a = i.length; r < a; ++r) {
      const s = i[r];
      (!t || s.visible) && n.push(s);
    }
    return n;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let i = t.length - 1; i >= 0; --i)
      this._drawDataset(t[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const i = this.ctx, n = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, r = vb(this, t);
    this.notifyPlugins("beforeDatasetDraw", n) !== !1 && (r && hc(i, r), t.controller.draw(), r && fc(i), n.cancelable = !1, this.notifyPlugins("afterDatasetDraw", n));
  }
  isPointInArea(t) {
    return So(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, i, n, r) {
    const a = xT.modes[i];
    return typeof a == "function" ? a(this, t, n, r) : [];
  }
  getDatasetMeta(t) {
    const i = this.data.datasets[t], n = this._metasets;
    let r = n.filter((a) => a && a._dataset === i).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: t,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, n.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = sa(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const i = this.data.datasets[t];
    if (!i)
      return !1;
    const n = this.getDatasetMeta(t);
    return typeof n.hidden == "boolean" ? !n.hidden : !i.hidden;
  }
  setDatasetVisibility(t, i) {
    const n = this.getDatasetMeta(t);
    n.hidden = !i;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, i, n) {
    const r = n ? "show" : "hide", a = this.getDatasetMeta(t), s = a.controller._resolveAnimations(void 0, r);
    bo(i) ? (a.data[i].hidden = !n, this.update()) : (this.setDatasetVisibility(t, n), s.update(a, {
      visible: n
    }), this.update((o) => o.datasetIndex === t ? r : void 0));
  }
  hide(t, i) {
    this._updateVisibility(t, i, !1);
  }
  show(t, i) {
    this._updateVisibility(t, i, !0);
  }
  _destroyDatasetMeta(t) {
    const i = this._metasets[t];
    i && i.controller && i.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, i;
    for (this.stop(), on.remove(this), t = 0, i = this.data.datasets.length; t < i; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: i } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), ag(t, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete Ql[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, i = this.platform, n = (a, s) => {
      i.addEventListener(this, a, s), t[a] = s;
    }, r = (a, s, o) => {
      a.offsetX = s, a.offsetY = o, this._eventHandler(a);
    };
    Ct(this.options.events, (a) => n(a, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, i = this.platform, n = (l, u) => {
      i.addEventListener(this, l, u), t[l] = u;
    }, r = (l, u) => {
      t[l] && (i.removeEventListener(this, l, u), delete t[l]);
    }, a = (l, u) => {
      this.canvas && this.resize(l, u);
    };
    let s;
    const o = () => {
      r("attach", o), this.attached = !0, this.resize(), n("resize", a), n("detach", s);
    };
    s = () => {
      this.attached = !1, r("resize", a), this._stop(), this._resize(0, 0), n("attach", o);
    }, i.isAttached(this.canvas) ? o() : s();
  }
  unbindEvents() {
    Ct(this._listeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._listeners = {}, Ct(this._responsiveListeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, i, n) {
    const r = n ? "set" : "remove";
    let a, s, o, l;
    for (i === "dataset" && (a = this.getDatasetMeta(t[0].datasetIndex), a.controller["_" + r + "DatasetHoverStyle"]()), o = 0, l = t.length; o < l; ++o) {
      s = t[o];
      const u = s && this.getDatasetMeta(s.datasetIndex).controller;
      u && u[r + "HoverStyle"](s.element, s.datasetIndex, s.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const i = this._active || [], n = t.map(({ datasetIndex: a, index: s }) => {
      const o = this.getDatasetMeta(a);
      if (!o)
        throw new Error("No dataset found at index " + a);
      return {
        datasetIndex: a,
        element: o.data[s],
        index: s
      };
    });
    !pu(n, i) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, i));
  }
  notifyPlugins(t, i, n) {
    return this._plugins.notify(this, t, i, n);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((i) => i.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, i, n) {
    const r = this.options.hover, a = (l, u) => l.filter((c) => !u.some((h) => c.datasetIndex === h.datasetIndex && c.index === h.index)), s = a(i, t), o = n ? t : a(t, i);
    s.length && this.updateHoverStyle(s, r.mode, !1), o.length && r.mode && this.updateHoverStyle(o, r.mode, !0);
  }
  _eventHandler(t, i) {
    const n = {
      event: t,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, r = (s) => (s.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", n, r) === !1)
      return;
    const a = this._handleEvent(t, i, n.inChartArea);
    return n.cancelable = !1, this.notifyPlugins("afterEvent", n, r), (a || n.changed) && this.render(), this;
  }
  _handleEvent(t, i, n) {
    const { _active: r = [], options: a } = this, s = i, o = this._getActiveElements(t, r, n, s), l = M2(t), u = MD(t, this._lastEvent, n, l);
    n && (this._lastEvent = null, Rt(a.onHover, [
      t,
      o,
      this
    ], this), l && Rt(a.onClick, [
      t,
      o,
      this
    ], this));
    const c = !pu(o, r);
    return (c || i) && (this._active = o, this._updateHoverStyles(o, r, i)), this._lastEvent = u, c;
  }
  _getActiveElements(t, i, n, r) {
    if (t.type === "mouseout")
      return [];
    if (!n)
      return i;
    const a = this.options.hover;
    return this.getElementsAtEventForMode(t, a.mode, a, r);
  }
};
function Vg() {
  return Ct(os.instances, (e) => e._plugins.invalidate());
}
function TD(e, t, i) {
  const { startAngle: n, x: r, y: a, outerRadius: s, innerRadius: o, options: l } = t, { borderWidth: u, borderJoinStyle: c } = l, h = Math.min(u / s, Ue(n - i));
  if (e.beginPath(), e.arc(r, a, s - u / 2, n + h / 2, i - h / 2), o > 0) {
    const f = Math.min(u / o, Ue(n - i));
    e.arc(r, a, o + u / 2, i - f / 2, n + f / 2, !0);
  } else {
    const f = Math.min(u / 2, s * Ue(n - i));
    if (c === "round")
      e.arc(r, a, f, i - kt / 2, n + kt / 2, !0);
    else if (c === "bevel") {
      const d = 2 * f * f, v = -d * Math.cos(i + kt / 2) + r, g = -d * Math.sin(i + kt / 2) + a, p = d * Math.cos(n + kt / 2) + r, m = d * Math.sin(n + kt / 2) + a;
      e.lineTo(v, g), e.lineTo(p, m);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function DD(e, t, i) {
  const { startAngle: n, pixelMargin: r, x: a, y: s, outerRadius: o, innerRadius: l } = t;
  let u = r / o;
  e.beginPath(), e.arc(a, s, o, n - u, i + u), l > r ? (u = r / l, e.arc(a, s, l, i + u, n - u, !0)) : e.arc(a, s, r, i + se, n - se), e.closePath(), e.clip();
}
function CD(e) {
  return rv(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function kD(e, t, i, n) {
  const r = CD(e.options.borderRadius), a = (i - t) / 2, s = Math.min(a, n * t / 2), o = (l) => {
    const u = (i - Math.min(a, l)) * n / 2;
    return ye(l, 0, Math.min(a, u));
  };
  return {
    outerStart: o(r.outerStart),
    outerEnd: o(r.outerEnd),
    innerStart: ye(r.innerStart, 0, s),
    innerEnd: ye(r.innerEnd, 0, s)
  };
}
function da(e, t, i, n) {
  return {
    x: i + e * Math.cos(t),
    y: n + e * Math.sin(t)
  };
}
function xu(e, t, i, n, r, a) {
  const { x: s, y: o, startAngle: l, pixelMargin: u, innerRadius: c } = t, h = Math.max(t.outerRadius + n + i - u, 0), f = c > 0 ? c + n + i + u : 0;
  let d = 0;
  const v = r - l;
  if (n) {
    const I = c > 0 ? c - n : 0, N = h > 0 ? h - n : 0, B = (I + N) / 2, $ = B !== 0 ? v * B / (B + n) : v;
    d = (v - $) / 2;
  }
  const g = Math.max(1e-3, v * h - i / kt) / h, p = (v - g) / 2, m = l + p + d, y = r - p - d, { outerStart: _, outerEnd: b, innerStart: x, innerEnd: w } = kD(t, f, h, y - m), M = h - _, T = h - b, D = m + _ / M, P = y - b / T, C = f + x, A = f + w, E = m + x / C, R = y - w / A;
  if (e.beginPath(), a) {
    const I = (D + P) / 2;
    if (e.arc(s, o, h, D, I), e.arc(s, o, h, I, P), b > 0) {
      const H = da(T, P, s, o);
      e.arc(H.x, H.y, b, P, y + se);
    }
    const N = da(A, y, s, o);
    if (e.lineTo(N.x, N.y), w > 0) {
      const H = da(A, R, s, o);
      e.arc(H.x, H.y, w, y + se, R + Math.PI);
    }
    const B = (y - w / f + (m + x / f)) / 2;
    if (e.arc(s, o, f, y - w / f, B, !0), e.arc(s, o, f, B, m + x / f, !0), x > 0) {
      const H = da(C, E, s, o);
      e.arc(H.x, H.y, x, E + Math.PI, m - se);
    }
    const $ = da(M, m, s, o);
    if (e.lineTo($.x, $.y), _ > 0) {
      const H = da(M, D, s, o);
      e.arc(H.x, H.y, _, m - se, D);
    }
  } else {
    e.moveTo(s, o);
    const I = Math.cos(D) * h + s, N = Math.sin(D) * h + o;
    e.lineTo(I, N);
    const B = Math.cos(P) * h + s, $ = Math.sin(P) * h + o;
    e.lineTo(B, $);
  }
  e.closePath();
}
function PD(e, t, i, n, r) {
  const { fullCircles: a, startAngle: s, circumference: o } = t;
  let l = t.endAngle;
  if (a) {
    xu(e, t, i, n, l, r);
    for (let u = 0; u < a; ++u)
      e.fill();
    isNaN(o) || (l = s + (o % Ut || Ut));
  }
  return xu(e, t, i, n, l, r), e.fill(), l;
}
function AD(e, t, i, n, r) {
  const { fullCircles: a, startAngle: s, circumference: o, options: l } = t, { borderWidth: u, borderJoinStyle: c, borderDash: h, borderDashOffset: f, borderRadius: d } = l, v = l.borderAlign === "inner";
  if (!u)
    return;
  e.setLineDash(h || []), e.lineDashOffset = f, v ? (e.lineWidth = u * 2, e.lineJoin = c || "round") : (e.lineWidth = u, e.lineJoin = c || "bevel");
  let g = t.endAngle;
  if (a) {
    xu(e, t, i, n, g, r);
    for (let p = 0; p < a; ++p)
      e.stroke();
    isNaN(o) || (g = s + (o % Ut || Ut));
  }
  v && DD(e, t, g), l.selfJoin && g - s >= kt && d === 0 && c !== "miter" && TD(e, t, g), a || (xu(e, t, i, n, g, r), e.stroke());
}
class ED extends Dn {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.getProps([
      "x",
      "y"
    ], n), { angle: a, distance: s } = Z0(r, {
      x: t,
      y: i
    }), { startAngle: o, endAngle: l, innerRadius: u, outerRadius: c, circumference: h } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], n), f = (this.options.spacing + this.options.borderWidth) / 2, d = ot(h, l - o), v = wo(a, o, l) && o !== l, g = d >= Ut || v, p = dn(s, u + f, c + f);
    return g && p;
  }
  getCenterPoint(t) {
    const { x: i, y: n, startAngle: r, endAngle: a, innerRadius: s, outerRadius: o } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: u } = this.options, c = (r + a) / 2, h = (s + o + u + l) / 2;
    return {
      x: i + Math.cos(c) * h,
      y: n + Math.sin(c) * h
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: i, circumference: n } = this, r = (i.offset || 0) / 4, a = (i.spacing || 0) / 2, s = i.circular;
    if (this.pixelMargin = i.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = n > Ut ? Math.floor(n / Ut) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const o = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(o) * r, Math.sin(o) * r);
    const l = 1 - Math.sin(Math.min(kt, n || 0)), u = r * l;
    t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor, PD(t, this, u, a, s), AD(t, this, u, a, s), t.restore();
  }
}
function Cb(e, t, i = t) {
  e.lineCap = ot(i.borderCapStyle, t.borderCapStyle), e.setLineDash(ot(i.borderDash, t.borderDash)), e.lineDashOffset = ot(i.borderDashOffset, t.borderDashOffset), e.lineJoin = ot(i.borderJoinStyle, t.borderJoinStyle), e.lineWidth = ot(i.borderWidth, t.borderWidth), e.strokeStyle = ot(i.borderColor, t.borderColor);
}
function LD(e, t, i) {
  e.lineTo(i.x, i.y);
}
function OD(e) {
  return e.stepped ? K2 : e.tension || e.cubicInterpolationMode === "monotone" ? Q2 : LD;
}
function kb(e, t, i = {}) {
  const n = e.length, { start: r = 0, end: a = n - 1 } = i, { start: s, end: o } = t, l = Math.max(r, s), u = Math.min(a, o), c = r < s && a < s || r > o && a > o;
  return {
    count: n,
    start: l,
    loop: t.loop,
    ilen: u < l && !c ? n + u - l : u - l
  };
}
function ID(e, t, i, n) {
  const { points: r, options: a } = t, { count: s, start: o, loop: l, ilen: u } = kb(r, i, n), c = OD(a);
  let { move: h = !0, reverse: f } = n || {}, d, v, g;
  for (d = 0; d <= u; ++d)
    v = r[(o + (f ? u - d : d)) % s], !v.skip && (h ? (e.moveTo(v.x, v.y), h = !1) : c(e, g, v, f, a.stepped), g = v);
  return l && (v = r[(o + (f ? u : 0)) % s], c(e, g, v, f, a.stepped)), !!l;
}
function RD(e, t, i, n) {
  const r = t.points, { count: a, start: s, ilen: o } = kb(r, i, n), { move: l = !0, reverse: u } = n || {};
  let c = 0, h = 0, f, d, v, g, p, m;
  const y = (b) => (s + (u ? o - b : b)) % a, _ = () => {
    g !== p && (e.lineTo(c, p), e.lineTo(c, g), e.lineTo(c, m));
  };
  for (l && (d = r[y(0)], e.moveTo(d.x, d.y)), f = 0; f <= o; ++f) {
    if (d = r[y(f)], d.skip)
      continue;
    const b = d.x, x = d.y, w = b | 0;
    w === v ? (x < g ? g = x : x > p && (p = x), c = (h * c + b) / ++h) : (_(), e.lineTo(b, x), v = w, h = 0, g = p = x), m = x;
  }
  _();
}
function zf(e) {
  const t = e.options, i = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !i ? RD : ID;
}
function ND(e) {
  return e.stepped ? AM : e.tension || e.cubicInterpolationMode === "monotone" ? EM : Ir;
}
function FD(e, t, i, n) {
  let r = t._path;
  r || (r = t._path = new Path2D(), t.path(r, i, n) && r.closePath()), Cb(e, t.options), e.stroke(r);
}
function BD(e, t, i, n) {
  const { segments: r, options: a } = t, s = zf(t);
  for (const o of r)
    Cb(e, a, o.style), e.beginPath(), s(e, t, o, {
      start: i,
      end: i + n - 1
    }) && e.closePath(), e.stroke();
}
const zD = typeof Path2D == "function";
function VD(e, t, i, n) {
  zD && !t.options.segment ? FD(e, t, i, n) : BD(e, t, i, n);
}
class gc extends Dn {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, i) {
    const n = this.options;
    if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
      const r = n.spanGaps ? this._loop : this._fullLoop;
      wM(this._points, n, t, r, i), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = FM(this, this.options.segment));
  }
  first() {
    const t = this.segments, i = this.points;
    return t.length && i[t[0].start];
  }
  last() {
    const t = this.segments, i = this.points, n = t.length;
    return n && i[t[n - 1].end];
  }
  interpolate(t, i) {
    const n = this.options, r = t[i], a = this.points, s = db(this, {
      property: i,
      start: r,
      end: r
    });
    if (!s.length)
      return;
    const o = [], l = ND(n);
    let u, c;
    for (u = 0, c = s.length; u < c; ++u) {
      const { start: h, end: f } = s[u], d = a[h], v = a[f];
      if (d === v) {
        o.push(d);
        continue;
      }
      const g = Math.abs((r - d[i]) / (v[i] - d[i])), p = l(d, v, g, n.stepped);
      p[i] = t[i], o.push(p);
    }
    return o.length === 1 ? o[0] : o;
  }
  pathSegment(t, i, n) {
    return zf(this)(t, this, i, n);
  }
  path(t, i, n) {
    const r = this.segments, a = zf(this);
    let s = this._loop;
    i = i || 0, n = n || this.points.length - i;
    for (const o of r)
      s &= a(t, this, o, {
        start: i,
        end: i + n - 1
      });
    return !!s;
  }
  draw(t, i, n, r) {
    const a = this.options || {};
    (this.points || []).length && a.borderWidth && (t.save(), VD(t, this, n, r), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function $g(e, t, i, n) {
  const r = e.options, { [i]: a } = e.getProps([
    i
  ], n);
  return Math.abs(t - a) < r.radius + r.hitRadius;
}
class $D extends Dn {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.options, { x: a, y: s } = this.getProps([
      "x",
      "y"
    ], n);
    return Math.pow(t - a, 2) + Math.pow(i - s, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(t, i) {
    return $g(this, t, "x", i);
  }
  inYRange(t, i) {
    return $g(this, t, "y", i);
  }
  getCenterPoint(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  size(t) {
    t = t || this.options || {};
    let i = t.radius || 0;
    i = Math.max(i, i && t.hoverRadius || 0);
    const n = i && t.borderWidth || 0;
    return (i + n) * 2;
  }
  draw(t, i) {
    const n = this.options;
    this.skip || n.radius < 0.1 || !So(this, i, this.size(n) / 2) || (t.strokeStyle = n.borderColor, t.lineWidth = n.borderWidth, t.fillStyle = n.backgroundColor, Nf(t, n, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function Pb(e, t) {
  const { x: i, y: n, base: r, width: a, height: s } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let o, l, u, c, h;
  return e.horizontal ? (h = s / 2, o = Math.min(i, r), l = Math.max(i, r), u = n - h, c = n + h) : (h = a / 2, o = i - h, l = i + h, u = Math.min(n, r), c = Math.max(n, r)), {
    left: o,
    top: u,
    right: l,
    bottom: c
  };
}
function Vn(e, t, i, n) {
  return e ? 0 : ye(t, i, n);
}
function HD(e, t, i) {
  const n = e.options.borderWidth, r = e.borderSkipped, a = nb(n);
  return {
    t: Vn(r.top, a.top, 0, i),
    r: Vn(r.right, a.right, 0, t),
    b: Vn(r.bottom, a.bottom, 0, i),
    l: Vn(r.left, a.left, 0, t)
  };
}
function YD(e, t, i) {
  const { enableBorderRadius: n } = e.getProps([
    "enableBorderRadius"
  ]), r = e.options.borderRadius, a = Ya(r), s = Math.min(t, i), o = e.borderSkipped, l = n || ft(r);
  return {
    topLeft: Vn(!l || o.top || o.left, a.topLeft, 0, s),
    topRight: Vn(!l || o.top || o.right, a.topRight, 0, s),
    bottomLeft: Vn(!l || o.bottom || o.left, a.bottomLeft, 0, s),
    bottomRight: Vn(!l || o.bottom || o.right, a.bottomRight, 0, s)
  };
}
function WD(e) {
  const t = Pb(e), i = t.right - t.left, n = t.bottom - t.top, r = HD(e, i / 2, n / 2), a = YD(e, i / 2, n / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: i,
      h: n,
      radius: a
    },
    inner: {
      x: t.left + r.l,
      y: t.top + r.t,
      w: i - r.l - r.r,
      h: n - r.t - r.b,
      radius: {
        topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function ah(e, t, i, n) {
  const r = t === null, a = i === null, o = e && !(r && a) && Pb(e, n);
  return o && (r || dn(t, o.left, o.right)) && (a || dn(i, o.top, o.bottom));
}
function UD(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function GD(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function sh(e, t, i = {}) {
  const n = e.x !== i.x ? -t : 0, r = e.y !== i.y ? -t : 0, a = (e.x + e.w !== i.x + i.w ? t : 0) - n, s = (e.y + e.h !== i.y + i.h ? t : 0) - r;
  return {
    x: e.x + n,
    y: e.y + r,
    w: e.w + a,
    h: e.h + s,
    radius: e.radius
  };
}
class jD extends Dn {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: i, options: { borderColor: n, backgroundColor: r } } = this, { inner: a, outer: s } = WD(this), o = UD(s.radius) ? yu : GD;
    t.save(), (s.w !== a.w || s.h !== a.h) && (t.beginPath(), o(t, sh(s, i, a)), t.clip(), o(t, sh(a, -i, s)), t.fillStyle = n, t.fill("evenodd")), t.beginPath(), o(t, sh(a, i)), t.fillStyle = r, t.fill(), t.restore();
  }
  inRange(t, i, n) {
    return ah(this, t, i, n);
  }
  inXRange(t, i) {
    return ah(this, t, null, i);
  }
  inYRange(t, i) {
    return ah(this, null, t, i);
  }
  getCenterPoint(t) {
    const { x: i, y: n, base: r, horizontal: a } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: a ? (i + r) / 2 : i,
      y: a ? n : (n + r) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
function XD(e, t, i) {
  const n = e.segments, r = e.points, a = t.points, s = [];
  for (const o of n) {
    let { start: l, end: u } = o;
    u = mc(l, u, r);
    const c = Vf(i, r[l], r[u], o.loop);
    if (!t.segments) {
      s.push({
        source: o,
        target: c,
        start: r[l],
        end: r[u]
      });
      continue;
    }
    const h = db(t, c);
    for (const f of h) {
      const d = Vf(i, a[f.start], a[f.end], f.loop), v = fb(o, r, d);
      for (const g of v)
        s.push({
          source: g,
          target: f,
          start: {
            [i]: Hg(c, d, "start", Math.max)
          },
          end: {
            [i]: Hg(c, d, "end", Math.min)
          }
        });
    }
  }
  return s;
}
function Vf(e, t, i, n) {
  if (n)
    return;
  let r = t[e], a = i[e];
  return e === "angle" && (r = Ue(r), a = Ue(a)), {
    property: e,
    start: r,
    end: a
  };
}
function qD(e, t) {
  const { x: i = null, y: n = null } = e || {}, r = t.points, a = [];
  return t.segments.forEach(({ start: s, end: o }) => {
    o = mc(s, o, r);
    const l = r[s], u = r[o];
    n !== null ? (a.push({
      x: l.x,
      y: n
    }), a.push({
      x: u.x,
      y: n
    })) : i !== null && (a.push({
      x: i,
      y: l.y
    }), a.push({
      x: i,
      y: u.y
    }));
  }), a;
}
function mc(e, t, i) {
  for (; t > e; t--) {
    const n = i[t];
    if (!isNaN(n.x) && !isNaN(n.y))
      break;
  }
  return t;
}
function Hg(e, t, i, n) {
  return e && t ? n(e[i], t[i]) : e ? e[i] : t ? t[i] : 0;
}
function Ab(e, t) {
  let i = [], n = !1;
  return ne(e) ? (n = !0, i = e) : i = qD(e, t), i.length ? new gc({
    points: i,
    options: {
      tension: 0
    },
    _loop: n,
    _fullLoop: n
  }) : null;
}
function Yg(e) {
  return e && e.fill !== !1;
}
function ZD(e, t, i) {
  let r = e[t].fill;
  const a = [
    t
  ];
  let s;
  if (!i)
    return r;
  for (; r !== !1 && a.indexOf(r) === -1; ) {
    if (!Se(r))
      return r;
    if (s = e[r], !s)
      return !1;
    if (s.visible)
      return r;
    a.push(r), r = s.fill;
  }
  return !1;
}
function KD(e, t, i) {
  const n = eC(e);
  if (ft(n))
    return isNaN(n.value) ? !1 : n;
  let r = parseFloat(n);
  return Se(r) && Math.floor(r) === r ? QD(n[0], t, r, i) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(n) >= 0 && n;
}
function QD(e, t, i, n) {
  return (e === "-" || e === "+") && (i = t + i), i === t || i < 0 || i >= n ? !1 : i;
}
function JD(e, t) {
  let i = null;
  return e === "start" ? i = t.bottom : e === "end" ? i = t.top : ft(e) ? i = t.getPixelForValue(e.value) : t.getBasePixel && (i = t.getBasePixel()), i;
}
function tC(e, t, i) {
  let n;
  return e === "start" ? n = i : e === "end" ? n = t.options.reverse ? t.min : t.max : ft(e) ? n = e.value : n = t.getBaseValue(), n;
}
function eC(e) {
  const t = e.options, i = t.fill;
  let n = ot(i && i.target, i);
  return n === void 0 && (n = !!t.backgroundColor), n === !1 || n === null ? !1 : n === !0 ? "origin" : n;
}
function iC(e) {
  const { scale: t, index: i, line: n } = e, r = [], a = n.segments, s = n.points, o = nC(t, i);
  o.push(Ab({
    x: null,
    y: t.bottom
  }, n));
  for (let l = 0; l < a.length; l++) {
    const u = a[l];
    for (let c = u.start; c <= u.end; c++)
      rC(r, s[c], o);
  }
  return new gc({
    points: r,
    options: {}
  });
}
function nC(e, t) {
  const i = [], n = e.getMatchingVisibleMetas("line");
  for (let r = 0; r < n.length; r++) {
    const a = n[r];
    if (a.index === t)
      break;
    a.hidden || i.unshift(a.dataset);
  }
  return i;
}
function rC(e, t, i) {
  const n = [];
  for (let r = 0; r < i.length; r++) {
    const a = i[r], { first: s, last: o, point: l } = aC(a, t, "x");
    if (!(!l || s && o)) {
      if (s)
        n.unshift(l);
      else if (e.push(l), !o)
        break;
    }
  }
  e.push(...n);
}
function aC(e, t, i) {
  const n = e.interpolate(t, i);
  if (!n)
    return {};
  const r = n[i], a = e.segments, s = e.points;
  let o = !1, l = !1;
  for (let u = 0; u < a.length; u++) {
    const c = a[u], h = s[c.start][i], f = s[c.end][i];
    if (dn(r, h, f)) {
      o = r === h, l = r === f;
      break;
    }
  }
  return {
    first: o,
    last: l,
    point: n
  };
}
class Eb {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, i, n) {
    const { x: r, y: a, radius: s } = this;
    return i = i || {
      start: 0,
      end: Ut
    }, t.arc(r, a, s, i.end, i.start, !0), !n.bounds;
  }
  interpolate(t) {
    const { x: i, y: n, radius: r } = this, a = t.angle;
    return {
      x: i + Math.cos(a) * r,
      y: n + Math.sin(a) * r,
      angle: a
    };
  }
}
function sC(e) {
  const { chart: t, fill: i, line: n } = e;
  if (Se(i))
    return oC(t, i);
  if (i === "stack")
    return iC(e);
  if (i === "shape")
    return !0;
  const r = lC(e);
  return r instanceof Eb ? r : Ab(r, n);
}
function oC(e, t) {
  const i = e.getDatasetMeta(t);
  return i && e.isDatasetVisible(t) ? i.dataset : null;
}
function lC(e) {
  return (e.scale || {}).getPointPositionForValue ? cC(e) : uC(e);
}
function uC(e) {
  const { scale: t = {}, fill: i } = e, n = JD(i, t);
  if (Se(n)) {
    const r = t.isHorizontal();
    return {
      x: r ? n : null,
      y: r ? null : n
    };
  }
  return null;
}
function cC(e) {
  const { scale: t, fill: i } = e, n = t.options, r = t.getLabels().length, a = n.reverse ? t.max : t.min, s = tC(i, t, a), o = [];
  if (n.grid.circular) {
    const l = t.getPointPositionForValue(0, a);
    return new Eb({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(s)
    });
  }
  for (let l = 0; l < r; ++l)
    o.push(t.getPointPositionForValue(l, s));
  return o;
}
function oh(e, t, i) {
  const n = sC(t), { chart: r, index: a, line: s, scale: o, axis: l } = t, u = s.options, c = u.fill, h = u.backgroundColor, { above: f = h, below: d = h } = c || {}, v = r.getDatasetMeta(a), g = vb(r, v);
  n && s.points.length && (hc(e, i), hC(e, {
    line: s,
    target: n,
    above: f,
    below: d,
    area: i,
    scale: o,
    axis: l,
    clip: g
  }), fc(e));
}
function hC(e, t) {
  const { line: i, target: n, above: r, below: a, area: s, scale: o, clip: l } = t, u = i._loop ? "angle" : t.axis;
  e.save();
  let c = a;
  a !== r && (u === "x" ? (Wg(e, n, s.top), lh(e, {
    line: i,
    target: n,
    color: r,
    scale: o,
    property: u,
    clip: l
  }), e.restore(), e.save(), Wg(e, n, s.bottom)) : u === "y" && (Ug(e, n, s.left), lh(e, {
    line: i,
    target: n,
    color: a,
    scale: o,
    property: u,
    clip: l
  }), e.restore(), e.save(), Ug(e, n, s.right), c = r)), lh(e, {
    line: i,
    target: n,
    color: c,
    scale: o,
    property: u,
    clip: l
  }), e.restore();
}
function Wg(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, s = !1;
  e.beginPath();
  for (const o of n) {
    const { start: l, end: u } = o, c = r[l], h = r[mc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(c.x, i), e.lineTo(c.x, c.y)), s = !!t.pathSegment(e, o, {
      move: s
    }), s ? e.closePath() : e.lineTo(h.x, i);
  }
  e.lineTo(t.first().x, i), e.closePath(), e.clip();
}
function Ug(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, s = !1;
  e.beginPath();
  for (const o of n) {
    const { start: l, end: u } = o, c = r[l], h = r[mc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(i, c.y), e.lineTo(c.x, c.y)), s = !!t.pathSegment(e, o, {
      move: s
    }), s ? e.closePath() : e.lineTo(i, h.y);
  }
  e.lineTo(i, t.first().y), e.closePath(), e.clip();
}
function lh(e, t) {
  const { line: i, target: n, property: r, color: a, scale: s, clip: o } = t, l = XD(i, n, r);
  for (const { source: u, target: c, start: h, end: f } of l) {
    const { style: { backgroundColor: d = a } = {} } = u, v = n !== !0;
    e.save(), e.fillStyle = d, fC(e, s, o, v && Vf(r, h, f)), e.beginPath();
    const g = !!i.pathSegment(e, u);
    let p;
    if (v) {
      g ? e.closePath() : Gg(e, n, f, r);
      const m = !!n.pathSegment(e, c, {
        move: g,
        reverse: !0
      });
      p = g && m, p || Gg(e, n, h, r);
    }
    e.closePath(), e.fill(p ? "evenodd" : "nonzero"), e.restore();
  }
}
function fC(e, t, i, n) {
  const r = t.chart.chartArea, { property: a, start: s, end: o } = n || {};
  if (a === "x" || a === "y") {
    let l, u, c, h;
    a === "x" ? (l = s, u = r.top, c = o, h = r.bottom) : (l = r.left, u = s, c = r.right, h = o), e.beginPath(), i && (l = Math.max(l, i.left), c = Math.min(c, i.right), u = Math.max(u, i.top), h = Math.min(h, i.bottom)), e.rect(l, u, c - l, h - u), e.clip();
  }
}
function Gg(e, t, i, n) {
  const r = t.interpolate(i, n);
  r && e.lineTo(r.x, r.y);
}
var dC = {
  id: "filler",
  afterDatasetsUpdate(e, t, i) {
    const n = (e.data.datasets || []).length, r = [];
    let a, s, o, l;
    for (s = 0; s < n; ++s)
      a = e.getDatasetMeta(s), o = a.dataset, l = null, o && o.options && o instanceof gc && (l = {
        visible: e.isDatasetVisible(s),
        index: s,
        fill: KD(o, s, n),
        chart: e,
        axis: a.controller.options.indexAxis,
        scale: a.vScale,
        line: o
      }), a.$filler = l, r.push(l);
    for (s = 0; s < n; ++s)
      l = r[s], !(!l || l.fill === !1) && (l.fill = ZD(r, s, i.propagate));
  },
  beforeDraw(e, t, i) {
    const n = i.drawTime === "beforeDraw", r = e.getSortedVisibleDatasetMetas(), a = e.chartArea;
    for (let s = r.length - 1; s >= 0; --s) {
      const o = r[s].$filler;
      o && (o.line.updateControlPoints(a, o.axis), n && o.fill && oh(e.ctx, o, a));
    }
  },
  beforeDatasetsDraw(e, t, i) {
    if (i.drawTime !== "beforeDatasetsDraw")
      return;
    const n = e.getSortedVisibleDatasetMetas();
    for (let r = n.length - 1; r >= 0; --r) {
      const a = n[r].$filler;
      Yg(a) && oh(e.ctx, a, e.chartArea);
    }
  },
  beforeDatasetDraw(e, t, i) {
    const n = t.meta.$filler;
    !Yg(n) || i.drawTime !== "beforeDatasetDraw" || oh(e.ctx, n, e.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const jg = (e, t) => {
  let { boxHeight: i = t, boxWidth: n = t } = e;
  return e.usePointStyle && (i = Math.min(i, t), n = e.pointStyleWidth || Math.min(n, t)), {
    boxWidth: n,
    boxHeight: i,
    itemHeight: Math.max(t, i)
  };
}, vC = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class Xg extends Dn {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i, n) {
    this.maxWidth = t, this.maxHeight = i, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let i = Rt(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (i = i.filter((n) => t.filter(n, this.chart.data))), t.sort && (i = i.sort((n, r) => t.sort(n, r, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: t, ctx: i } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const n = t.labels, r = _e(n.font), a = r.size, s = this._computeTitleHeight(), { boxWidth: o, itemHeight: l } = jg(n, a);
    let u, c;
    i.font = r.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(s, a, o, l) + 10) : (c = this.maxHeight, u = this._fitCols(s, r, o, l) + 10), this.width = Math.min(u, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, i, n, r) {
    const { ctx: a, maxWidth: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [
      0
    ], c = r + o;
    let h = t;
    a.textAlign = "left", a.textBaseline = "middle";
    let f = -1, d = -c;
    return this.legendItems.forEach((v, g) => {
      const p = n + i / 2 + a.measureText(v.text).width;
      (g === 0 || u[u.length - 1] + p + 2 * o > s) && (h += c, u[u.length - (g > 0 ? 0 : 1)] = 0, d += c, f++), l[g] = {
        left: 0,
        top: d,
        row: f,
        width: p,
        height: r
      }, u[u.length - 1] += p + o;
    }), h;
  }
  _fitCols(t, i, n, r) {
    const { ctx: a, maxHeight: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = s - t;
    let h = o, f = 0, d = 0, v = 0, g = 0;
    return this.legendItems.forEach((p, m) => {
      const { itemWidth: y, itemHeight: _ } = pC(n, i, a, p, r);
      m > 0 && d + _ + 2 * o > c && (h += f + o, u.push({
        width: f,
        height: d
      }), v += f + o, g++, f = d = 0), l[m] = {
        left: v,
        top: d,
        col: g,
        width: y,
        height: _
      }, f = Math.max(f, y), d += _ + o;
    }), h += f, u.push({
      width: f,
      height: d
    }), h;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: n, labels: { padding: r }, rtl: a } } = this, s = Wa(a, this.left, this.width);
    if (this.isHorizontal()) {
      let o = 0, l = ge(n, this.left + r, this.right - this.lineWidths[o]);
      for (const u of i)
        o !== u.row && (o = u.row, l = ge(n, this.left + r, this.right - this.lineWidths[o])), u.top += this.top + t + r, u.left = s.leftForLtr(s.x(l), u.width), l += u.width + r;
    } else {
      let o = 0, l = ge(n, this.top + t + r, this.bottom - this.columnSizes[o].height);
      for (const u of i)
        u.col !== o && (o = u.col, l = ge(n, this.top + t + r, this.bottom - this.columnSizes[o].height)), u.top = l, u.left += this.left + r, u.left = s.leftForLtr(s.x(u.left), u.width), l += u.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      hc(t, this), this._draw(), fc(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: i, lineWidths: n, ctx: r } = this, { align: a, labels: s } = t, o = ee.color, l = Wa(t.rtl, this.left, this.width), u = _e(s.font), { padding: c } = s, h = u.size, f = h / 2;
    let d;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = u.string;
    const { boxWidth: v, boxHeight: g, itemHeight: p } = jg(s, h), m = function(w, M, T) {
      if (isNaN(v) || v <= 0 || isNaN(g) || g < 0)
        return;
      r.save();
      const D = ot(T.lineWidth, 1);
      if (r.fillStyle = ot(T.fillStyle, o), r.lineCap = ot(T.lineCap, "butt"), r.lineDashOffset = ot(T.lineDashOffset, 0), r.lineJoin = ot(T.lineJoin, "miter"), r.lineWidth = D, r.strokeStyle = ot(T.strokeStyle, o), r.setLineDash(ot(T.lineDash, [])), s.usePointStyle) {
        const P = {
          radius: g * Math.SQRT2 / 2,
          pointStyle: T.pointStyle,
          rotation: T.rotation,
          borderWidth: D
        }, C = l.xPlus(w, v / 2), A = M + f;
        ib(r, P, C, A, s.pointStyleWidth && v);
      } else {
        const P = M + Math.max((h - g) / 2, 0), C = l.leftForLtr(w, v), A = Ya(T.borderRadius);
        r.beginPath(), Object.values(A).some((E) => E !== 0) ? yu(r, {
          x: C,
          y: P,
          w: v,
          h: g,
          radius: A
        }) : r.rect(C, P, v, g), r.fill(), D !== 0 && r.stroke();
      }
      r.restore();
    }, y = function(w, M, T) {
      Mo(r, T.text, w, M + p / 2, u, {
        strikethrough: T.hidden,
        textAlign: l.textAlign(T.textAlign)
      });
    }, _ = this.isHorizontal(), b = this._computeTitleHeight();
    _ ? d = {
      x: ge(a, this.left + c, this.right - n[0]),
      y: this.top + c + b,
      line: 0
    } : d = {
      x: this.left + c,
      y: ge(a, this.top + b + c, this.bottom - i[0].height),
      line: 0
    }, ub(this.ctx, t.textDirection);
    const x = p + c;
    this.legendItems.forEach((w, M) => {
      r.strokeStyle = w.fontColor, r.fillStyle = w.fontColor;
      const T = r.measureText(w.text).width, D = l.textAlign(w.textAlign || (w.textAlign = s.textAlign)), P = v + f + T;
      let C = d.x, A = d.y;
      l.setWidth(this.width), _ ? M > 0 && C + P + c > this.right && (A = d.y += x, d.line++, C = d.x = ge(a, this.left + c, this.right - n[d.line])) : M > 0 && A + x > this.bottom && (C = d.x = C + i[d.line].width + c, d.line++, A = d.y = ge(a, this.top + b + c, this.bottom - i[d.line].height));
      const E = l.x(C);
      if (m(E, A, w), C = B2(D, C + v + f, _ ? C + P : this.right, t.rtl), y(l.x(C), A, w), _)
        d.x += P + c;
      else if (typeof w.text != "string") {
        const R = u.lineHeight;
        d.y += Lb(w, R) + c;
      } else
        d.y += x;
    }), cb(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, i = t.title, n = _e(i.font), r = di(i.padding);
    if (!i.display)
      return;
    const a = Wa(t.rtl, this.left, this.width), s = this.ctx, o = i.position, l = n.size / 2, u = r.top + l;
    let c, h = this.left, f = this.width;
    if (this.isHorizontal())
      f = Math.max(...this.lineWidths), c = this.top + u, h = ge(t.align, h, this.right - f);
    else {
      const v = this.columnSizes.reduce((g, p) => Math.max(g, p.height), 0);
      c = u + ge(t.align, this.top, this.bottom - v - t.labels.padding - this._computeTitleHeight());
    }
    const d = ge(o, h, h + f);
    s.textAlign = a.textAlign(ev(o)), s.textBaseline = "middle", s.strokeStyle = i.color, s.fillStyle = i.color, s.font = n.string, Mo(s, i.text, d, c, n);
  }
  _computeTitleHeight() {
    const t = this.options.title, i = _e(t.font), n = di(t.padding);
    return t.display ? i.lineHeight + n.height : 0;
  }
  _getLegendItemAt(t, i) {
    let n, r, a;
    if (dn(t, this.left, this.right) && dn(i, this.top, this.bottom)) {
      for (a = this.legendHitBoxes, n = 0; n < a.length; ++n)
        if (r = a[n], dn(t, r.left, r.left + r.width) && dn(i, r.top, r.top + r.height))
          return this.legendItems[n];
    }
    return null;
  }
  handleEvent(t) {
    const i = this.options;
    if (!yC(t.type, i))
      return;
    const n = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const r = this._hoveredItem, a = vC(r, n);
      r && !a && Rt(i.onLeave, [
        t,
        r,
        this
      ], this), this._hoveredItem = n, n && !a && Rt(i.onHover, [
        t,
        n,
        this
      ], this);
    } else n && Rt(i.onClick, [
      t,
      n,
      this
    ], this);
  }
}
function pC(e, t, i, n, r) {
  const a = gC(n, e, t, i), s = mC(r, n, t.lineHeight);
  return {
    itemWidth: a,
    itemHeight: s
  };
}
function gC(e, t, i, n) {
  let r = e.text;
  return r && typeof r != "string" && (r = r.reduce((a, s) => a.length > s.length ? a : s)), t + i.size / 2 + n.measureText(r).width;
}
function mC(e, t, i) {
  let n = e;
  return typeof t.text != "string" && (n = Lb(t, i)), n;
}
function Lb(e, t) {
  const i = e.text ? e.text.length : 0;
  return t * i;
}
function yC(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var hv = {
  id: "legend",
  _element: Xg,
  start(e, t, i) {
    const n = e.legend = new Xg({
      ctx: e.ctx,
      options: i,
      chart: e
    });
    hi.configure(e, n, i), hi.addBox(e, n);
  },
  stop(e) {
    hi.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, i) {
    const n = e.legend;
    hi.configure(e, n, i), n.options = i;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, i) {
      const n = t.datasetIndex, r = i.chart;
      r.isDatasetVisible(n) ? (r.hide(n), t.hidden = !0) : (r.show(n), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: i, pointStyle: n, textAlign: r, color: a, useBorderRadius: s, borderRadius: o } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const u = l.controller.getStyle(i ? 0 : void 0), c = di(u.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: u.backgroundColor,
            fontColor: a,
            hidden: !l.visible,
            lineCap: u.borderCapStyle,
            lineDash: u.borderDash,
            lineDashOffset: u.borderDashOffset,
            lineJoin: u.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: u.borderColor,
            pointStyle: n || u.pointStyle,
            rotation: u.rotation,
            textAlign: r || u.textAlign,
            borderRadius: s && (o || u.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class Ob extends Dn {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i) {
    const n = this.options;
    if (this.left = 0, this.top = 0, !n.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = i;
    const r = ne(n.text) ? n.text.length : 1;
    this._padding = di(n.padding);
    const a = r * _e(n.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = a : this.width = a;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: i, left: n, bottom: r, right: a, options: s } = this, o = s.align;
    let l = 0, u, c, h;
    return this.isHorizontal() ? (c = ge(o, n, a), h = i + t, u = a - n) : (s.position === "left" ? (c = n + t, h = ge(o, r, i), l = kt * -0.5) : (c = a - t, h = ge(o, i, r), l = kt * 0.5), u = r - i), {
      titleX: c,
      titleY: h,
      maxWidth: u,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, i = this.options;
    if (!i.display)
      return;
    const n = _e(i.font), a = n.lineHeight / 2 + this._padding.top, { titleX: s, titleY: o, maxWidth: l, rotation: u } = this._drawArgs(a);
    Mo(t, i.text, 0, 0, n, {
      color: i.color,
      maxWidth: l,
      rotation: u,
      textAlign: ev(i.align),
      textBaseline: "middle",
      translation: [
        s,
        o
      ]
    });
  }
}
function _C(e, t) {
  const i = new Ob({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  hi.configure(e, i, t), hi.addBox(e, i), e.titleBlock = i;
}
var Ib = {
  id: "title",
  _element: Ob,
  start(e, t, i) {
    _C(e, i);
  },
  stop(e) {
    const t = e.titleBlock;
    hi.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, i) {
    const n = e.titleBlock;
    hi.configure(e, n, i), n.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const js = {
  average(e) {
    if (!e.length)
      return !1;
    let t, i, n = /* @__PURE__ */ new Set(), r = 0, a = 0;
    for (t = 0, i = e.length; t < i; ++t) {
      const o = e[t].element;
      if (o && o.hasValue()) {
        const l = o.tooltipPosition();
        n.add(l.x), r += l.y, ++a;
      }
    }
    return a === 0 || n.size === 0 ? !1 : {
      x: [
        ...n
      ].reduce((o, l) => o + l) / n.size,
      y: r / a
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let i = t.x, n = t.y, r = Number.POSITIVE_INFINITY, a, s, o;
    for (a = 0, s = e.length; a < s; ++a) {
      const l = e[a].element;
      if (l && l.hasValue()) {
        const u = l.getCenterPoint(), c = If(t, u);
        c < r && (r = c, o = l);
      }
    }
    if (o) {
      const l = o.tooltipPosition();
      i = l.x, n = l.y;
    }
    return {
      x: i,
      y: n
    };
  }
};
function Bi(e, t) {
  return t && (ne(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function ln(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function bC(e, t) {
  const { element: i, datasetIndex: n, index: r } = t, a = e.getDatasetMeta(n).controller, { label: s, value: o } = a.getLabelAndValue(r);
  return {
    chart: e,
    label: s,
    parsed: a.getParsed(r),
    raw: e.data.datasets[n].data[r],
    formattedValue: o,
    dataset: a.getDataset(),
    dataIndex: r,
    datasetIndex: n,
    element: i
  };
}
function qg(e, t) {
  const i = e.chart.ctx, { body: n, footer: r, title: a } = e, { boxWidth: s, boxHeight: o } = t, l = _e(t.bodyFont), u = _e(t.titleFont), c = _e(t.footerFont), h = a.length, f = r.length, d = n.length, v = di(t.padding);
  let g = v.height, p = 0, m = n.reduce((b, x) => b + x.before.length + x.lines.length + x.after.length, 0);
  if (m += e.beforeBody.length + e.afterBody.length, h && (g += h * u.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom), m) {
    const b = t.displayColors ? Math.max(o, l.lineHeight) : l.lineHeight;
    g += d * b + (m - d) * l.lineHeight + (m - 1) * t.bodySpacing;
  }
  f && (g += t.footerMarginTop + f * c.lineHeight + (f - 1) * t.footerSpacing);
  let y = 0;
  const _ = function(b) {
    p = Math.max(p, i.measureText(b).width + y);
  };
  return i.save(), i.font = u.string, Ct(e.title, _), i.font = l.string, Ct(e.beforeBody.concat(e.afterBody), _), y = t.displayColors ? s + 2 + t.boxPadding : 0, Ct(n, (b) => {
    Ct(b.before, _), Ct(b.lines, _), Ct(b.after, _);
  }), y = 0, i.font = c.string, Ct(e.footer, _), i.restore(), p += v.width, {
    width: p,
    height: g
  };
}
function xC(e, t) {
  const { y: i, height: n } = t;
  return i < n / 2 ? "top" : i > e.height - n / 2 ? "bottom" : "center";
}
function wC(e, t, i, n) {
  const { x: r, width: a } = n, s = i.caretSize + i.caretPadding;
  if (e === "left" && r + a + s > t.width || e === "right" && r - a - s < 0)
    return !0;
}
function SC(e, t, i, n) {
  const { x: r, width: a } = i, { width: s, chartArea: { left: o, right: l } } = e;
  let u = "center";
  return n === "center" ? u = r <= (o + l) / 2 ? "left" : "right" : r <= a / 2 ? u = "left" : r >= s - a / 2 && (u = "right"), wC(u, e, t, i) && (u = "center"), u;
}
function Zg(e, t, i) {
  const n = i.yAlign || t.yAlign || xC(e, i);
  return {
    xAlign: i.xAlign || t.xAlign || SC(e, t, i, n),
    yAlign: n
  };
}
function MC(e, t) {
  let { x: i, width: n } = e;
  return t === "right" ? i -= n : t === "center" && (i -= n / 2), i;
}
function TC(e, t, i) {
  let { y: n, height: r } = e;
  return t === "top" ? n += i : t === "bottom" ? n -= r + i : n -= r / 2, n;
}
function Kg(e, t, i, n) {
  const { caretSize: r, caretPadding: a, cornerRadius: s } = e, { xAlign: o, yAlign: l } = i, u = r + a, { topLeft: c, topRight: h, bottomLeft: f, bottomRight: d } = Ya(s);
  let v = MC(t, o);
  const g = TC(t, l, u);
  return l === "center" ? o === "left" ? v += u : o === "right" && (v -= u) : o === "left" ? v -= Math.max(c, f) + r : o === "right" && (v += Math.max(h, d) + r), {
    x: ye(v, 0, n.width - t.width),
    y: ye(g, 0, n.height - t.height)
  };
}
function cl(e, t, i) {
  const n = di(i.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - n.right : e.x + n.left;
}
function Qg(e) {
  return Bi([], ln(e));
}
function DC(e, t, i) {
  return sa(e, {
    tooltip: t,
    tooltipItems: i,
    type: "tooltip"
  });
}
function Jg(e, t) {
  const i = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return i ? e.override(i) : e;
}
const Rb = {
  beforeTitle: tn,
  title(e) {
    if (e.length > 0) {
      const t = e[0], i = t.chart.data.labels, n = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (n > 0 && t.dataIndex < n)
        return i[t.dataIndex];
    }
    return "";
  },
  afterTitle: tn,
  beforeBody: tn,
  beforeLabel: tn,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const i = e.formattedValue;
    return Tt(i) || (t += i), t;
  },
  labelColor(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: tn,
  afterBody: tn,
  beforeFooter: tn,
  footer: tn,
  afterFooter: tn
};
function Oe(e, t, i, n) {
  const r = e[t].call(i, n);
  return typeof r > "u" ? Rb[t].call(i, n) : r;
}
class tm extends Dn {
  static positioners = js;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const i = this.chart, n = this.options.setContext(this.getContext()), r = n.enabled && i.options.animation && n.animations, a = new pb(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(a)), a;
  }
  getContext() {
    return this.$context || (this.$context = DC(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, i) {
    const { callbacks: n } = i, r = Oe(n, "beforeTitle", this, t), a = Oe(n, "title", this, t), s = Oe(n, "afterTitle", this, t);
    let o = [];
    return o = Bi(o, ln(r)), o = Bi(o, ln(a)), o = Bi(o, ln(s)), o;
  }
  getBeforeBody(t, i) {
    return Qg(Oe(i.callbacks, "beforeBody", this, t));
  }
  getBody(t, i) {
    const { callbacks: n } = i, r = [];
    return Ct(t, (a) => {
      const s = {
        before: [],
        lines: [],
        after: []
      }, o = Jg(n, a);
      Bi(s.before, ln(Oe(o, "beforeLabel", this, a))), Bi(s.lines, Oe(o, "label", this, a)), Bi(s.after, ln(Oe(o, "afterLabel", this, a))), r.push(s);
    }), r;
  }
  getAfterBody(t, i) {
    return Qg(Oe(i.callbacks, "afterBody", this, t));
  }
  getFooter(t, i) {
    const { callbacks: n } = i, r = Oe(n, "beforeFooter", this, t), a = Oe(n, "footer", this, t), s = Oe(n, "afterFooter", this, t);
    let o = [];
    return o = Bi(o, ln(r)), o = Bi(o, ln(a)), o = Bi(o, ln(s)), o;
  }
  _createItems(t) {
    const i = this._active, n = this.chart.data, r = [], a = [], s = [];
    let o = [], l, u;
    for (l = 0, u = i.length; l < u; ++l)
      o.push(bC(this.chart, i[l]));
    return t.filter && (o = o.filter((c, h, f) => t.filter(c, h, f, n))), t.itemSort && (o = o.sort((c, h) => t.itemSort(c, h, n))), Ct(o, (c) => {
      const h = Jg(t.callbacks, c);
      r.push(Oe(h, "labelColor", this, c)), a.push(Oe(h, "labelPointStyle", this, c)), s.push(Oe(h, "labelTextColor", this, c));
    }), this.labelColors = r, this.labelPointStyles = a, this.labelTextColors = s, this.dataPoints = o, o;
  }
  update(t, i) {
    const n = this.options.setContext(this.getContext()), r = this._active;
    let a, s = [];
    if (!r.length)
      this.opacity !== 0 && (a = {
        opacity: 0
      });
    else {
      const o = js[n.position].call(this, r, this._eventPosition);
      s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
      const l = this._size = qg(this, n), u = Object.assign({}, o, l), c = Zg(this.chart, n, u), h = Kg(n, u, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, a = {
        opacity: 1,
        x: h.x,
        y: h.y,
        width: l.width,
        height: l.height,
        caretX: o.x,
        caretY: o.y
      };
    }
    this._tooltipItems = s, this.$context = void 0, a && this._resolveAnimations().update(this, a), t && n.external && n.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(t, i, n, r) {
    const a = this.getCaretPosition(t, n, r);
    i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3);
  }
  getCaretPosition(t, i, n) {
    const { xAlign: r, yAlign: a } = this, { caretSize: s, cornerRadius: o } = n, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: h } = Ya(o), { x: f, y: d } = t, { width: v, height: g } = i;
    let p, m, y, _, b, x;
    return a === "center" ? (b = d + g / 2, r === "left" ? (p = f, m = p - s, _ = b + s, x = b - s) : (p = f + v, m = p + s, _ = b - s, x = b + s), y = p) : (r === "left" ? m = f + Math.max(l, c) + s : r === "right" ? m = f + v - Math.max(u, h) - s : m = this.caretX, a === "top" ? (_ = d, b = _ - s, p = m - s, y = m + s) : (_ = d + g, b = _ + s, p = m + s, y = m - s), x = _), {
      x1: p,
      x2: m,
      x3: y,
      y1: _,
      y2: b,
      y3: x
    };
  }
  drawTitle(t, i, n) {
    const r = this.title, a = r.length;
    let s, o, l;
    if (a) {
      const u = Wa(n.rtl, this.x, this.width);
      for (t.x = cl(this, n.titleAlign, n), i.textAlign = u.textAlign(n.titleAlign), i.textBaseline = "middle", s = _e(n.titleFont), o = n.titleSpacing, i.fillStyle = n.titleColor, i.font = s.string, l = 0; l < a; ++l)
        i.fillText(r[l], u.x(t.x), t.y + s.lineHeight / 2), t.y += s.lineHeight + o, l + 1 === a && (t.y += n.titleMarginBottom - o);
    }
  }
  _drawColorBox(t, i, n, r, a) {
    const s = this.labelColors[n], o = this.labelPointStyles[n], { boxHeight: l, boxWidth: u } = a, c = _e(a.bodyFont), h = cl(this, "left", a), f = r.x(h), d = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, v = i.y + d;
    if (a.usePointStyle) {
      const g = {
        radius: Math.min(u, l) / 2,
        pointStyle: o.pointStyle,
        rotation: o.rotation,
        borderWidth: 1
      }, p = r.leftForLtr(f, u) + u / 2, m = v + l / 2;
      t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, Nf(t, g, p, m), t.strokeStyle = s.borderColor, t.fillStyle = s.backgroundColor, Nf(t, g, p, m);
    } else {
      t.lineWidth = ft(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, t.strokeStyle = s.borderColor, t.setLineDash(s.borderDash || []), t.lineDashOffset = s.borderDashOffset || 0;
      const g = r.leftForLtr(f, u), p = r.leftForLtr(r.xPlus(f, 1), u - 2), m = Ya(s.borderRadius);
      Object.values(m).some((y) => y !== 0) ? (t.beginPath(), t.fillStyle = a.multiKeyBackground, yu(t, {
        x: g,
        y: v,
        w: u,
        h: l,
        radius: m
      }), t.fill(), t.stroke(), t.fillStyle = s.backgroundColor, t.beginPath(), yu(t, {
        x: p,
        y: v + 1,
        w: u - 2,
        h: l - 2,
        radius: m
      }), t.fill()) : (t.fillStyle = a.multiKeyBackground, t.fillRect(g, v, u, l), t.strokeRect(g, v, u, l), t.fillStyle = s.backgroundColor, t.fillRect(p, v + 1, u - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[n];
  }
  drawBody(t, i, n) {
    const { body: r } = this, { bodySpacing: a, bodyAlign: s, displayColors: o, boxHeight: l, boxWidth: u, boxPadding: c } = n, h = _e(n.bodyFont);
    let f = h.lineHeight, d = 0;
    const v = Wa(n.rtl, this.x, this.width), g = function(T) {
      i.fillText(T, v.x(t.x + d), t.y + f / 2), t.y += f + a;
    }, p = v.textAlign(s);
    let m, y, _, b, x, w, M;
    for (i.textAlign = s, i.textBaseline = "middle", i.font = h.string, t.x = cl(this, p, n), i.fillStyle = n.bodyColor, Ct(this.beforeBody, g), d = o && p !== "right" ? s === "center" ? u / 2 + c : u + 2 + c : 0, b = 0, w = r.length; b < w; ++b) {
      for (m = r[b], y = this.labelTextColors[b], i.fillStyle = y, Ct(m.before, g), _ = m.lines, o && _.length && (this._drawColorBox(i, t, b, v, n), f = Math.max(h.lineHeight, l)), x = 0, M = _.length; x < M; ++x)
        g(_[x]), f = h.lineHeight;
      Ct(m.after, g);
    }
    d = 0, f = h.lineHeight, Ct(this.afterBody, g), t.y -= a;
  }
  drawFooter(t, i, n) {
    const r = this.footer, a = r.length;
    let s, o;
    if (a) {
      const l = Wa(n.rtl, this.x, this.width);
      for (t.x = cl(this, n.footerAlign, n), t.y += n.footerMarginTop, i.textAlign = l.textAlign(n.footerAlign), i.textBaseline = "middle", s = _e(n.footerFont), i.fillStyle = n.footerColor, i.font = s.string, o = 0; o < a; ++o)
        i.fillText(r[o], l.x(t.x), t.y + s.lineHeight / 2), t.y += s.lineHeight + n.footerSpacing;
    }
  }
  drawBackground(t, i, n, r) {
    const { xAlign: a, yAlign: s } = this, { x: o, y: l } = t, { width: u, height: c } = n, { topLeft: h, topRight: f, bottomLeft: d, bottomRight: v } = Ya(r.cornerRadius);
    i.fillStyle = r.backgroundColor, i.strokeStyle = r.borderColor, i.lineWidth = r.borderWidth, i.beginPath(), i.moveTo(o + h, l), s === "top" && this.drawCaret(t, i, n, r), i.lineTo(o + u - f, l), i.quadraticCurveTo(o + u, l, o + u, l + f), s === "center" && a === "right" && this.drawCaret(t, i, n, r), i.lineTo(o + u, l + c - v), i.quadraticCurveTo(o + u, l + c, o + u - v, l + c), s === "bottom" && this.drawCaret(t, i, n, r), i.lineTo(o + d, l + c), i.quadraticCurveTo(o, l + c, o, l + c - d), s === "center" && a === "left" && this.drawCaret(t, i, n, r), i.lineTo(o, l + h), i.quadraticCurveTo(o, l, o + h, l), i.closePath(), i.fill(), r.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(t) {
    const i = this.chart, n = this.$animations, r = n && n.x, a = n && n.y;
    if (r || a) {
      const s = js[t.position].call(this, this._active, this._eventPosition);
      if (!s)
        return;
      const o = this._size = qg(this, t), l = Object.assign({}, s, this._size), u = Zg(i, t, l), c = Kg(t, l, u, i);
      (r._to !== c.x || a._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = o.width, this.height = o.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const i = this.options.setContext(this.getContext());
    let n = this.opacity;
    if (!n)
      return;
    this._updateAnimationTarget(i);
    const r = {
      width: this.width,
      height: this.height
    }, a = {
      x: this.x,
      y: this.y
    };
    n = Math.abs(n) < 1e-3 ? 0 : n;
    const s = di(i.padding), o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && o && (t.save(), t.globalAlpha = n, this.drawBackground(a, t, r, i), ub(t, i.textDirection), a.y += s.top, this.drawTitle(a, t, i), this.drawBody(a, t, i), this.drawFooter(a, t, i), cb(t, i.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, i) {
    const n = this._active, r = t.map(({ datasetIndex: o, index: l }) => {
      const u = this.chart.getDatasetMeta(o);
      if (!u)
        throw new Error("Cannot find a dataset at index " + o);
      return {
        datasetIndex: o,
        element: u.data[l],
        index: l
      };
    }), a = !pu(n, r), s = this._positionChanged(r, i);
    (a || s) && (this._active = r, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, i, n = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, a = this._active || [], s = this._getActiveElements(t, a, i, n), o = this._positionChanged(s, t), l = i || !pu(s, a) || o;
    return l && (this._active = s, (r.enabled || r.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, i))), l;
  }
  _getActiveElements(t, i, n, r) {
    const a = this.options;
    if (t.type === "mouseout")
      return [];
    if (!r)
      return i.filter((o) => this.chart.data.datasets[o.datasetIndex] && this.chart.getDatasetMeta(o.datasetIndex).controller.getParsed(o.index) !== void 0);
    const s = this.chart.getElementsAtEventForMode(t, a.mode, a, n);
    return a.reverse && s.reverse(), s;
  }
  _positionChanged(t, i) {
    const { caretX: n, caretY: r, options: a } = this, s = js[a.position].call(this, t, i);
    return s !== !1 && (n !== s.x || r !== s.y);
  }
}
var fv = {
  id: "tooltip",
  _element: tm,
  positioners: js,
  afterInit(e, t, i) {
    i && (e.tooltip = new tm({
      chart: e,
      options: i
    }));
  },
  beforeUpdate(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  reset(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const i = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const i = t.replay;
      e.tooltip.handleEvent(t.event, i, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Rb
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const CC = (e, t, i, n) => (typeof t == "string" ? (i = e.push(t) - 1, n.unshift({
  index: i,
  label: t
})) : isNaN(t) && (i = null), i);
function kC(e, t, i, n) {
  const r = e.indexOf(t);
  if (r === -1)
    return CC(e, t, i, n);
  const a = e.lastIndexOf(t);
  return r !== a ? i : r;
}
const PC = (e, t) => e === null ? null : ye(Math.round(e), 0, t);
function em(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Nb extends ss {
  static id = "category";
  static defaults = {
    ticks: {
      callback: em
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const i = this._addedLabels;
    if (i.length) {
      const n = this.getLabels();
      for (const { index: r, label: a } of i)
        n[r] === a && n.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, i) {
    if (Tt(t))
      return null;
    const n = this.getLabels();
    return i = isFinite(i) && n[i] === t ? i : kC(n, t, ot(i, t), this._addedLabels), PC(i, n.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: i } = this.getUserBounds();
    let { min: n, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (n = 0), i || (r = this.getLabels().length - 1)), this.min = n, this.max = r;
  }
  buildTicks() {
    const t = this.min, i = this.max, n = this.options.offset, r = [];
    let a = this.getLabels();
    a = t === 0 && i === a.length - 1 ? a : a.slice(t, i + 1), this._valueRange = Math.max(a.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
    for (let s = t; s <= i; s++)
      r.push({
        value: s
      });
    return r;
  }
  getLabelForValue(t) {
    return em.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function AC(e, t) {
  const i = [], { bounds: r, step: a, min: s, max: o, precision: l, count: u, maxTicks: c, maxDigits: h, includeBounds: f } = e, d = a || 1, v = c - 1, { min: g, max: p } = t, m = !Tt(s), y = !Tt(o), _ = !Tt(u), b = (p - g) / (h + 1);
  let x = Kp((p - g) / v / d) * d, w, M, T, D;
  if (x < 1e-14 && !m && !y)
    return [
      {
        value: g
      },
      {
        value: p
      }
    ];
  D = Math.ceil(p / x) - Math.floor(g / x), D > v && (x = Kp(D * x / v / d) * d), Tt(l) || (w = Math.pow(10, l), x = Math.ceil(x * w) / w), r === "ticks" ? (M = Math.floor(g / x) * x, T = Math.ceil(p / x) * x) : (M = g, T = p), m && y && a && P2((o - s) / a, x / 1e3) ? (D = Math.round(Math.min((o - s) / x, c)), x = (o - s) / D, M = s, T = o) : _ ? (M = m ? s : M, T = y ? o : T, D = u - 1, x = (T - M) / D) : (D = (T - M) / x, ro(D, Math.round(D), x / 1e3) ? D = Math.round(D) : D = Math.ceil(D));
  const P = Math.max(Qp(x), Qp(M));
  w = Math.pow(10, Tt(l) ? P : l), M = Math.round(M * w) / w, T = Math.round(T * w) / w;
  let C = 0;
  for (m && (f && M !== s ? (i.push({
    value: s
  }), M < s && C++, ro(Math.round((M + C * x) * w) / w, s, im(s, b, e)) && C++) : M < s && C++); C < D; ++C) {
    const A = Math.round((M + C * x) * w) / w;
    if (y && A > o)
      break;
    i.push({
      value: A
    });
  }
  return y && f && T !== o ? i.length && ro(i[i.length - 1].value, o, im(o, b, e)) ? i[i.length - 1].value = o : i.push({
    value: o
  }) : (!y || T === o) && i.push({
    value: T
  }), i;
}
function im(e, t, { horizontal: i, minRotation: n }) {
  const r = fn(n), a = (i ? Math.sin(r) : Math.cos(r)) || 1e-3, s = 0.75 * t * ("" + e).length;
  return Math.min(t / a, s);
}
class EC extends ss {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, i) {
    return Tt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: i, maxDefined: n } = this.getUserBounds();
    let { min: r, max: a } = this;
    const s = (l) => r = i ? r : l, o = (l) => a = n ? a : l;
    if (t) {
      const l = Wi(r), u = Wi(a);
      l < 0 && u < 0 ? o(0) : l > 0 && u > 0 && s(0);
    }
    if (r === a) {
      let l = a === 0 ? 1 : Math.abs(a * 0.05);
      o(a + l), t || s(r - l);
    }
    this.min = r, this.max = a;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: i, stepSize: n } = t, r;
    return n ? (r = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), i = i || 11), i && (r = Math.min(i, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, i = t.ticks;
    let n = this.getTickLimit();
    n = Math.max(2, n);
    const r = {
      maxTicks: n,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, a = this._range || this, s = AC(r, a);
    return t.bounds === "ticks" && A2(s, this, "value"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
  }
  configure() {
    const t = this.ticks;
    let i = this.min, n = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const r = (n - i) / Math.max(t.length - 1, 1) / 2;
      i -= r, n += r;
    }
    this._startValue = i, this._endValue = n, this._valueRange = n - i;
  }
  getLabelForValue(t) {
    return nv(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Fb extends EC {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: eb.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: i } = this.getMinMax(!0);
    this.min = Se(t) ? t : 0, this.max = Se(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), i = t ? this.width : this.height, n = fn(this.options.ticks.minRotation), r = (t ? Math.sin(n) : Math.cos(n)) || 1e-3, a = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, a.lineHeight / r));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const yc = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, $e = /* @__PURE__ */ Object.keys(yc);
function nm(e, t) {
  return e - t;
}
function rm(e, t) {
  if (Tt(t))
    return null;
  const i = e._adapter, { parser: n, round: r, isoWeekday: a } = e._parseOpts;
  let s = t;
  return typeof n == "function" && (s = n(s)), Se(s) || (s = typeof n == "string" ? i.parse(s, n) : i.parse(s)), s === null ? null : (r && (s = r === "week" && (xo(a) || a === !0) ? i.startOf(s, "isoWeek", a) : i.startOf(s, r)), +s);
}
function am(e, t, i, n) {
  const r = $e.length;
  for (let a = $e.indexOf(e); a < r - 1; ++a) {
    const s = yc[$e[a]], o = s.steps ? s.steps : Number.MAX_SAFE_INTEGER;
    if (s.common && Math.ceil((i - t) / (o * s.size)) <= n)
      return $e[a];
  }
  return $e[r - 1];
}
function LC(e, t, i, n, r) {
  for (let a = $e.length - 1; a >= $e.indexOf(i); a--) {
    const s = $e[a];
    if (yc[s].common && e._adapter.diff(r, n, s) >= t - 1)
      return s;
  }
  return $e[i ? $e.indexOf(i) : 0];
}
function OC(e) {
  for (let t = $e.indexOf(e) + 1, i = $e.length; t < i; ++t)
    if (yc[$e[t]].common)
      return $e[t];
}
function sm(e, t, i) {
  if (!i)
    e[t] = !0;
  else if (i.length) {
    const { lo: n, hi: r } = tv(i, t), a = i[n] >= t ? i[n] : i[r];
    e[a] = !0;
  }
}
function IC(e, t, i, n) {
  const r = e._adapter, a = +r.startOf(t[0].value, n), s = t[t.length - 1].value;
  let o, l;
  for (o = a; o <= s; o = +r.add(o, 1, n))
    l = i[o], l >= 0 && (t[l].major = !0);
  return t;
}
function om(e, t, i) {
  const n = [], r = {}, a = t.length;
  let s, o;
  for (s = 0; s < a; ++s)
    o = t[s], r[o] = s, n.push({
      value: o,
      major: !1
    });
  return a === 0 || !i ? n : IC(e, n, r, i);
}
class lm extends ss {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, i = {}) {
    const n = t.time || (t.time = {}), r = this._adapter = new gT._date(t.adapters.date);
    r.init(i), no(n.displayFormats, r.formats()), this._parseOpts = {
      parser: n.parser,
      round: n.round,
      isoWeekday: n.isoWeekday
    }, super.init(t), this._normalized = i.normalized;
  }
  parse(t, i) {
    return t === void 0 ? null : rm(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, i = this._adapter, n = t.time.unit || "day";
    let { min: r, max: a, minDefined: s, maxDefined: o } = this.getUserBounds();
    function l(u) {
      !s && !isNaN(u.min) && (r = Math.min(r, u.min)), !o && !isNaN(u.max) && (a = Math.max(a, u.max));
    }
    (!s || !o) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), r = Se(r) && !isNaN(r) ? r : +i.startOf(Date.now(), n), a = Se(a) && !isNaN(a) ? a : +i.endOf(Date.now(), n) + 1, this.min = Math.min(r, a - 1), this.max = Math.max(r + 1, a);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
    return t.length && (i = t[0], n = t[t.length - 1]), {
      min: i,
      max: n
    };
  }
  buildTicks() {
    const t = this.options, i = t.time, n = t.ticks, r = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const a = this.min, s = this.max, o = R2(r, a, s);
    return this._unit = i.unit || (n.autoSkip ? am(i.minUnit, this.min, this.max, this._getLabelCapacity(a)) : LC(this, o.length, i.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : OC(this._unit), this.initOffsets(r), t.reverse && o.reverse(), om(this, o, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let i = 0, n = 0, r, a;
    this.options.offset && t.length && (r = this.getDecimalForValue(t[0]), t.length === 1 ? i = 1 - r : i = (this.getDecimalForValue(t[1]) - r) / 2, a = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? n = a : n = (a - this.getDecimalForValue(t[t.length - 2])) / 2);
    const s = t.length < 3 ? 0.5 : 0.25;
    i = ye(i, 0, s), n = ye(n, 0, s), this._offsets = {
      start: i,
      end: n,
      factor: 1 / (i + 1 + n)
    };
  }
  _generate() {
    const t = this._adapter, i = this.min, n = this.max, r = this.options, a = r.time, s = a.unit || am(a.minUnit, i, n, this._getLabelCapacity(i)), o = ot(r.ticks.stepSize, 1), l = s === "week" ? a.isoWeekday : !1, u = xo(l) || l === !0, c = {};
    let h = i, f, d;
    if (u && (h = +t.startOf(h, "isoWeek", l)), h = +t.startOf(h, u ? "day" : s), t.diff(n, i, s) > 1e5 * o)
      throw new Error(i + " and " + n + " are too far apart with stepSize of " + o + " " + s);
    const v = r.ticks.source === "data" && this.getDataTimestamps();
    for (f = h, d = 0; f < n; f = +t.add(f, o, s), d++)
      sm(c, f, v);
    return (f === n || r.bounds === "ticks" || d === 1) && sm(c, f, v), Object.keys(c).sort(nm).map((g) => +g);
  }
  getLabelForValue(t) {
    const i = this._adapter, n = this.options.time;
    return n.tooltipFormat ? i.format(t, n.tooltipFormat) : i.format(t, n.displayFormats.datetime);
  }
  format(t, i) {
    const r = this.options.time.displayFormats, a = this._unit, s = i || r[a];
    return this._adapter.format(t, s);
  }
  _tickFormatFunction(t, i, n, r) {
    const a = this.options, s = a.ticks.callback;
    if (s)
      return Rt(s, [
        t,
        i,
        n
      ], this);
    const o = a.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && o[l], h = u && o[u], f = n[i], d = u && h && f && f.major;
    return this._adapter.format(t, r || (d ? h : c));
  }
  generateTickLabels(t) {
    let i, n, r;
    for (i = 0, n = t.length; i < n; ++i)
      r = t[i], r.label = this._tickFormatFunction(r.value, i, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const i = this._offsets, n = this.getDecimalForValue(t);
    return this.getPixelForDecimal((i.start + n) * i.factor);
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return this.min + n * (this.max - this.min);
  }
  _getLabelSize(t) {
    const i = this.options.ticks, n = this.ctx.measureText(t).width, r = fn(this.isHorizontal() ? i.maxRotation : i.minRotation), a = Math.cos(r), s = Math.sin(r), o = this._resolveTickFontOptions(0).size;
    return {
      w: n * a + o * s,
      h: n * s + o * a
    };
  }
  _getLabelCapacity(t) {
    const i = this.options.time, n = i.displayFormats, r = n[i.unit] || n.millisecond, a = this._tickFormatFunction(t, 0, om(this, [
      t
    ], this._majorUnit), r), s = this._getLabelSize(a), o = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
    return o > 0 ? o : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], i, n;
    if (t.length)
      return t;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (i = 0, n = r.length; i < n; ++i)
      t = t.concat(r[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let i, n;
    if (t.length)
      return t;
    const r = this.getLabels();
    for (i = 0, n = r.length; i < n; ++i)
      t.push(rm(this, r[i]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return Q0(t.sort(nm));
  }
}
function hl(e, t, i) {
  let n = 0, r = e.length - 1, a, s, o, l;
  i ? (t >= e[n].pos && t <= e[r].pos && ({ lo: n, hi: r } = Br(e, "pos", t)), { pos: a, time: o } = e[n], { pos: s, time: l } = e[r]) : (t >= e[n].time && t <= e[r].time && ({ lo: n, hi: r } = Br(e, "time", t)), { time: a, pos: o } = e[n], { time: s, pos: l } = e[r]);
  const u = s - a;
  return u ? o + (l - o) * (t - a) / u : o;
}
class BW extends lm {
  static id = "timeseries";
  static defaults = lm.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(t);
    this._minPos = hl(i, this.min), this._tableRange = hl(i, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: i, max: n } = this, r = [], a = [];
    let s, o, l, u, c;
    for (s = 0, o = t.length; s < o; ++s)
      u = t[s], u >= i && u <= n && r.push(u);
    if (r.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: n,
          pos: 1
        }
      ];
    for (s = 0, o = r.length; s < o; ++s)
      c = r[s + 1], l = r[s - 1], u = r[s], Math.round((c + l) / 2) !== u && a.push({
        time: u,
        pos: s / (o - 1)
      });
    return a;
  }
  _generate() {
    const t = this.min, i = this.max;
    let n = super.getDataTimestamps();
    return (!n.includes(t) || !n.length) && n.splice(0, 0, t), (!n.includes(i) || n.length === 1) && n.push(i), n.sort((r, a) => r - a);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const i = this.getDataTimestamps(), n = this.getLabelTimestamps();
    return i.length && n.length ? t = this.normalize(i.concat(n)) : t = i.length ? i : n, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (hl(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return hl(this._table, n * this._tableRange + this._minPos, !0);
  }
}
const Bb = {
  data: {
    type: Object,
    required: !0
  },
  options: {
    type: Object,
    default: () => ({})
  },
  plugins: {
    type: Array,
    default: () => []
  },
  datasetIdKey: {
    type: String,
    default: "label"
  },
  updateMode: {
    type: String,
    default: void 0
  }
}, RC = {
  ariaLabel: {
    type: String
  },
  ariaDescribedby: {
    type: String
  }
}, NC = {
  type: {
    type: String,
    required: !0
  },
  destroyDelay: {
    type: Number,
    default: 0
    // No delay by default
  },
  ...Bb,
  ...RC
}, FC = XS[0] === "2" ? (e, t) => Object.assign(e, {
  attrs: t
}) : (e, t) => Object.assign(e, t);
function va(e) {
  return H0(e) ? Lf(e) : e;
}
function BC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
  return H0(t) ? new Proxy(e, {}) : e;
}
function zC(e, t) {
  const i = e.options;
  i && t && Object.assign(i, t);
}
function zb(e, t) {
  e.labels = t;
}
function Vb(e, t, i) {
  const n = [];
  e.datasets = t.map((r) => {
    const a = e.datasets.find((s) => s[i] === r[i]);
    return !a || !r.data || n.includes(a) ? {
      ...r
    } : (n.push(a), Object.assign(a, r), a);
  });
}
function VC(e, t) {
  const i = {
    labels: [],
    datasets: []
  };
  return zb(i, e.labels), Vb(i, e.datasets, t), i;
}
const $C = Te({
  props: NC,
  setup(e, t) {
    let { expose: i, slots: n } = t;
    const r = wi(null), a = z0(null);
    i({
      chart: a
    });
    const s = () => {
      if (!r.value) return;
      const { type: u, data: c, options: h, plugins: f, datasetIdKey: d } = e, v = VC(c, d), g = BC(v, c);
      a.value = new os(r.value, {
        type: u,
        data: g,
        options: {
          ...h
        },
        plugins: f
      });
    }, o = () => {
      const u = Lf(a.value);
      u && (e.destroyDelay > 0 ? setTimeout(() => {
        u.destroy(), a.value = null;
      }, e.destroyDelay) : (u.destroy(), a.value = null));
    }, l = (u) => {
      u.update(e.updateMode);
    };
    return V0(s), jS(o), qd([
      () => e.options,
      () => e.data
    ], (u, c) => {
      let [h, f] = u, [d, v] = c;
      const g = Lf(a.value);
      if (!g)
        return;
      let p = !1;
      if (h) {
        const m = va(h), y = va(d);
        m && m !== y && (zC(g, m), p = !0);
      }
      if (f) {
        const m = va(f.labels), y = va(v.labels), _ = va(f.datasets), b = va(v.datasets);
        m !== y && (zb(g.config.data, m), p = !0), _ && _ !== b && (Vb(g.config.data, _, e.datasetIdKey), p = !0);
      }
      p && $0(() => {
        l(g);
      });
    }, {
      deep: !0
    }), () => Ef("canvas", {
      role: "img",
      "aria-label": e.ariaLabel,
      "aria-describedby": e.ariaDescribedby,
      ref: r
    }, [
      Ef("p", {}, [
        n.default ? n.default() : ""
      ])
    ]);
  }
});
function dv(e, t) {
  return os.register(t), Te({
    props: Bb,
    setup(i, n) {
      let { expose: r } = n;
      const a = z0(null), s = (o) => {
        a.value = o?.chart;
      };
      return r({
        chart: a
      }), () => Ef($C, FC({
        ref: s
      }, {
        type: e,
        ...i
      }));
    }
  });
}
const HC = /* @__PURE__ */ dv("bar", hT), YC = /* @__PURE__ */ dv("line", vT), WC = /* @__PURE__ */ dv("pie", pT), UC = { class: "chart-container" }, GC = /* @__PURE__ */ Te({
  __name: "ChartBar",
  props: {
    data: {},
    options: {},
    stacked: { type: Boolean }
  },
  setup(e) {
    const t = e;
    os.register(
      Nb,
      Fb,
      jD,
      Ib,
      fv,
      hv
    );
    const i = t.data, n = (s) => typeof s == "string" ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s, r = {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: "#475569",
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          },
          generateLabels: function(s) {
            return s.data.datasets.map((l, u) => ({
              text: n(l.label || ""),
              fillStyle: Array.isArray(l.backgroundColor) ? l.backgroundColor[0] : l.backgroundColor,
              strokeStyle: Array.isArray(l.borderColor) ? l.borderColor[0] : l.borderColor,
              lineWidth: l.borderWidth,
              hidden: !s.isDatasetVisible(u),
              index: u,
              datasetIndex: u
            }));
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: "rgba(15, 23, 42, 0.95)",
          titleColor: "#f1f5f9",
          bodyColor: "#e2e8f0",
          borderColor: "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(s) {
              return s.length > 0 ? String(n(s[0].label)) : "";
            },
            label: function(s) {
              let o = String(n(s.dataset.label || ""));
              return o && (o += ": "), s.parsed.y !== null && (o += s.parsed.y), o;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          stacked: t.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            color: "rgba(148, 163, 184, 0.12)",
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(s) {
              return n(s);
            }
          }
        },
        x: {
          stacked: t.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(s) {
              const o = this.getLabelForValue(s);
              return n(o);
            }
          }
        }
      },
      elements: {
        bar: {
          borderRadius: 8,
          borderWidth: 0
        }
      }
    }, a = t.options || r;
    return (s, o) => (L(), O("div", UC, [
      Ze(Z(HC), {
        data: Z(i),
        options: Z(a)
      }, null, 8, ["data", "options"])
    ]));
  }
}), fe = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [n, r] of t)
    i[n] = r;
  return i;
}, jC = /* @__PURE__ */ fe(GC, [["__scopeId", "data-v-1469622e"]]), XC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: jC
}, Symbol.toStringTag, { value: "Module" })), qC = { class: "chart-container" }, ZC = /* @__PURE__ */ Te({
  __name: "ChartLine",
  props: {
    data: {},
    options: {}
  },
  setup(e) {
    const t = e;
    os.register(
      Nb,
      Fb,
      $D,
      gc,
      Ib,
      fv,
      hv,
      dC
    );
    const i = t.data, n = (s) => typeof s == "string" ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s, r = {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: "#475569",
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(s) {
              return s.data.datasets.map((l, u) => ({
                text: n(l.label || ""),
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                lineWidth: l.borderWidth,
                hidden: !s.isDatasetVisible(u),
                index: u,
                datasetIndex: u
              }));
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: "rgba(15, 23, 42, 0.95)",
          titleColor: "#f1f5f9",
          bodyColor: "#e2e8f0",
          borderColor: "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(s) {
              return s.length > 0 ? String(n(s[0].label)) : "";
            },
            label: function(s) {
              let o = String(n(s.dataset.label || ""));
              return o && (o += ": "), s.parsed.y !== null && (o += s.parsed.y), o;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: "rgba(148, 163, 184, 0.12)",
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(s) {
              return n(s);
            }
          }
        },
        x: {
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(s) {
              const o = this.getLabelForValue(s);
              return n(o);
            }
          }
        }
      },
      elements: {
        line: {
          tension: 0.4,
          borderWidth: 2.5,
          borderCapStyle: "round"
        },
        point: {
          radius: 4,
          hoverRadius: 6,
          borderWidth: 2,
          backgroundColor: "#ffffff",
          hoverBorderWidth: 3
        }
      }
    }, a = t.options || r;
    return (s, o) => (L(), O("div", qC, [
      Ze(Z(YC), {
        data: Z(i),
        options: Z(a)
      }, null, 8, ["data", "options"])
    ]));
  }
}), vv = /* @__PURE__ */ fe(ZC, [["__scopeId", "data-v-a106a86c"]]), KC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: vv
}, Symbol.toStringTag, { value: "Module" })), QC = { class: "chart-container" }, JC = /* @__PURE__ */ Te({
  __name: "PieChart",
  props: {
    data: {},
    options: {},
    doughnut: { type: Boolean }
  },
  setup(e) {
    const t = e;
    os.register(ED, fv, hv);
    const i = t.data, n = (s) => typeof s == "string" ? s.charAt(0).toUpperCase() + s.slice(1).toLowerCase() : s, r = {
      responsive: !0,
      maintainAspectRatio: !1,
      cutout: t.doughnut ? "60%" : 0,
      plugins: {
        legend: {
          display: !0,
          position: "bottom",
          align: "center",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: "#475569",
            padding: 16,
            boxWidth: 14,
            boxHeight: 14,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(s) {
              const o = s.data;
              return o.labels.length && o.datasets.length ? o.labels.map((l, u) => {
                const c = s.getDatasetMeta(0), h = o.datasets[0], f = h.data[u], d = Array.isArray(h.backgroundColor) ? h.backgroundColor[u] : h.backgroundColor;
                return {
                  text: `${n(l)}: ${f}`,
                  fillStyle: d,
                  hidden: c.data[u]?.hidden || !1,
                  index: u
                };
              }) : [];
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: "rgba(15, 23, 42, 0.95)",
          titleColor: "#f1f5f9",
          bodyColor: "#e2e8f0",
          borderColor: "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(s) {
              return s.length > 0 ? String(n(s[0].label)) : "";
            },
            label: function(s) {
              const o = s.label || "", l = s.parsed || 0, u = s.dataset.data.reduce((h, f) => h + f, 0), c = (l / u * 100).toFixed(1);
              return `${n(o)}: ${l} (${c}%)`;
            }
          }
        }
      },
      elements: {
        arc: {
          borderWidth: 2,
          borderColor: "#ffffff",
          hoverOffset: 8
        }
      },
      animation: {
        animateRotate: !0,
        animateScale: !0
      }
    }, a = t.options || r;
    return (s, o) => (L(), O("div", QC, [
      Ze(Z(WC), {
        data: Z(i),
        options: Z(a)
      }, null, 8, ["data", "options"])
    ]));
  }
}), tk = /* @__PURE__ */ fe(JC, [["__scopeId", "data-v-3a8af968"]]), ek = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tk
}, Symbol.toStringTag, { value: "Module" })), ik = { class: "chart-container" }, nk = ["viewBox"], rk = ["transform"], ak = ["x", "width"], sk = {
  x: "0",
  y: "0",
  "text-anchor": "middle",
  fill: "#f1f5f9",
  "font-size": "12",
  "font-weight": "500",
  "font-family": "'DM Sans', sans-serif",
  "dominant-baseline": "middle"
}, ok = ["x1", "y1", "x2", "y2"], lk = ["points"], uk = ["x1", "y1", "x2", "y2"], ck = ["x", "y"], hk = ["x1", "y1", "x2", "y2"], fk = ["points"], dk = ["transform"], vk = ["y1", "y2"], pk = ["y1", "y2"], gk = ["y1", "y2"], mk = ["y1", "y2"], yk = ["y", "height"], _k = ["y1", "y2"], bk = ["y1", "y2"], xk = ["y1", "y2"], wk = ["y1", "y2"], Sk = ["y", "height"], Mk = ["cy", "onMouseenter"], Tk = ["cy", "onMouseenter"], Dk = ["cy", "onMouseenter"], Ck = ["cy", "onMouseenter"], kk = ["y1", "y2", "onMouseenter"], Pk = ["y1", "y2", "onMouseenter"], Ak = ["x", "y"], Ek = ["x", "y"], Lk = ["transform"], Ok = /* @__PURE__ */ Te({
  __name: "BoxplotChart",
  props: {
    boxplotData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    showLegend: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = e, i = wi({
      visible: !1,
      x: 0,
      y: 0,
      text: ""
    }), n = (u) => typeof u == "string" ? u.charAt(0).toUpperCase() + u.slice(1).toLowerCase() : u, r = (u, c) => {
      const h = u.currentTarget.closest("svg");
      if (!h) return;
      const f = h.getBoundingClientRect(), d = h.createSVGPoint();
      d.x = u.clientX - f.left, d.y = u.clientY - f.top, i.value = {
        visible: !0,
        x: d.x,
        y: d.y - 20,
        text: c
      };
    }, a = (u) => {
      if (i.value.visible) {
        const c = u.currentTarget, h = c.getBoundingClientRect(), f = c.createSVGPoint();
        f.x = u.clientX - h.left, f.y = u.clientY - h.top, i.value.x = f.x, i.value.y = f.y - 20;
      }
    }, s = () => {
      i.value.visible = !1;
    }, o = () => {
      i.value.visible = !1;
    }, l = J(() => {
      const u = [], h = t.chartHeight - t.chartMargin - t.chartBottomMargin;
      for (let f = 1; f <= 10; f++) {
        const d = f, v = (d - 1) / 9, g = t.chartMargin + h - v * h;
        u.push({ value: d, y: g });
      }
      return u;
    });
    return (u, c) => (L(), O("div", ik, [
      (L(), O("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full boxplot-svg",
        style: Ur(`min-height: ${e.chartHeight}px;`),
        onMousemove: a,
        onMouseleave: s
      }, [
        i.value.visible ? (L(), O("g", {
          key: 0,
          transform: `translate(${i.value.x}, ${i.value.y})`
        }, [
          S("rect", {
            x: -(i.value.text.length * 6 + 10),
            y: -16,
            width: i.value.text.length * 12 + 20,
            height: "24",
            fill: "rgba(15, 23, 42, 0.95)",
            rx: "6",
            stroke: "rgba(148, 163, 184, 0.2)",
            "stroke-width": "1"
          }, null, 8, ak),
          S("text", sk, F(i.value.text), 1)
        ], 8, rk)) : ct("", !0),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, ok),
        S("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: "#475569"
        }, null, 8, lk),
        (L(!0), O(Nt, null, ve(l.value, (h, f) => (L(), O(Nt, { key: f }, [
          S("line", {
            x1: e.chartMargin - 6,
            y1: h.y,
            x2: e.chartMargin,
            y2: h.y,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, uk),
          S("text", {
            x: e.chartMargin - 12,
            y: h.y + 4,
            "text-anchor": "end",
            fill: "#64748b",
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, F(h.value), 9, ck)
        ], 64))), 128)),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, hk),
        S("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: "#475569"
        }, null, 8, fk),
        (L(!0), O(Nt, null, ve(e.boxplotData, (h, f) => (L(), O(Nt, { key: f }, [
          S("g", {
            transform: `translate(${h.centerX}, 0)`
          }, [
            h.isTotal ? (L(), O(Nt, { key: 0 }, [
              S("line", {
                x1: 0,
                y1: h.minY,
                x2: 0,
                y2: h.q1Y,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, vk),
              S("line", {
                x1: 0,
                y1: h.q3Y,
                x2: 0,
                y2: h.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, pk),
              S("line", {
                x1: -18,
                y1: h.minY,
                x2: 18,
                y2: h.minY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, gk),
              S("line", {
                x1: -18,
                y1: h.maxY,
                x2: 18,
                y2: h.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, mk),
              S("rect", {
                x: -24,
                y: h.q3Y,
                width: "48",
                height: h.q1Y - h.q3Y,
                fill: "#8b5cf6",
                "fill-opacity": "0.15",
                stroke: "#8b5cf6",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, yk)
            ], 64)) : (L(), O(Nt, { key: 1 }, [
              S("line", {
                x1: 0,
                y1: h.minY,
                x2: 0,
                y2: h.q1Y,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, _k),
              S("line", {
                x1: 0,
                y1: h.q3Y,
                x2: 0,
                y2: h.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, bk),
              S("line", {
                x1: -18,
                y1: h.minY,
                x2: 18,
                y2: h.minY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, xk),
              S("line", {
                x1: -18,
                y1: h.maxY,
                x2: 18,
                y2: h.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, wk),
              S("rect", {
                x: -24,
                y: h.q3Y,
                width: "48",
                height: h.q1Y - h.q3Y,
                fill: "#C67DFF",
                "fill-opacity": "0.15",
                stroke: "#C67DFF",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, Sk)
            ], 64)),
            S("circle", {
              cx: 0,
              cy: h.minY,
              r: "6",
              fill: "#5d4b93",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (d) => r(d, `Min: ${h.min.toFixed(1)}`),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Mk),
            S("circle", {
              cx: 0,
              cy: h.q1Y,
              r: "6",
              fill: "#a855f7",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (d) => r(d, `Q1: ${h.q1.toFixed(1)}`),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Tk),
            S("circle", {
              cx: 0,
              cy: h.q3Y,
              r: "6",
              fill: "#7c3aed",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (d) => r(d, `Q3: ${h.q3.toFixed(1)}`),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Dk),
            S("circle", {
              cx: 0,
              cy: h.maxY,
              r: "6",
              fill: "#C67DFF",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (d) => r(d, `Max: ${h.max.toFixed(1)}`),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Ck),
            S("line", {
              x1: -24,
              y1: h.medianY,
              x2: 24,
              y2: h.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3.5",
              class: "hover-line",
              onMouseenter: (d) => r(d, `Median: ${h.median.toFixed(1)}`),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, kk),
            h.averageY ? (L(), O("line", {
              key: 2,
              x1: -24,
              y1: h.averageY,
              x2: 24,
              y2: h.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (d) => r(d, `Avg: ${h.average.toFixed(1)}`),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Pk)) : ct("", !0)
          ], 8, dk),
          S("text", {
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: "#475569",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, F(n(h.label)), 9, Ak),
          h.responseCount ? (L(), O("text", {
            key: 0,
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: "#64748b",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + F(h.responseCount), 9, Ek)) : ct("", !0)
        ], 64))), 128)),
        e.showLegend ? (L(), O("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [...c[0] || (c[0] = [
          zt('<g transform="translate(-200, 0)" data-v-9ad9865d><circle cx="0" cy="0" r="5" fill="#5d4b93" stroke="#ffffff" stroke-width="1.5" data-v-9ad9865d></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9ad9865d> Min </text></g><g transform="translate(-130, 0)" data-v-9ad9865d><circle cx="0" cy="0" r="5" fill="#a855f7" stroke="#ffffff" stroke-width="1.5" data-v-9ad9865d></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9ad9865d> Q1 </text></g><g transform="translate(-60, 0)" data-v-9ad9865d><circle cx="0" cy="0" r="5" fill="#7c3aed" stroke="#ffffff" stroke-width="1.5" data-v-9ad9865d></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9ad9865d> Q3 </text></g><g transform="translate(10, 0)" data-v-9ad9865d><circle cx="0" cy="0" r="5" fill="#C67DFF" stroke="#ffffff" stroke-width="1.5" data-v-9ad9865d></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9ad9865d> Max </text></g><g transform="translate(80, 0)" data-v-9ad9865d><line x1="0" y1="0" x2="14" y2="0" stroke="#f97316" stroke-width="2.5" stroke-dasharray="6,4" data-v-9ad9865d></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9ad9865d> Avg </text></g><g transform="translate(150, 0)" data-v-9ad9865d><line x1="0" y1="0" x2="14" y2="0" stroke="#8b5cf6" stroke-width="2.5" data-v-9ad9865d></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9ad9865d> Median </text></g>', 6)
        ])], 8, Lk)) : ct("", !0)
      ], 44, nk))
    ]));
  }
}), Ik = /* @__PURE__ */ fe(Ok, [["__scopeId", "data-v-9ad9865d"]]), Rk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Ik
}, Symbol.toStringTag, { value: "Module" })), Nk = { class: "chart-container" }, Fk = ["viewBox"], Bk = ["transform"], zk = ["x", "y", "width", "height"], Vk = ["y"], $k = ["y"], Hk = ["x1", "y1", "x2", "y2"], Yk = ["points"], Wk = ["x1", "y1", "x2", "y2"], Uk = ["x1", "y1", "x2", "y2"], Gk = ["x", "y"], jk = ["x", "y", "transform"], Xk = ["x1", "y1", "x2", "y2"], qk = ["points"], Zk = ["transform"], Kk = ["y1", "y2", "stroke", "onMouseenter"], Qk = ["x", "y", "width", "height", "fill", "stroke", "onMouseenter"], Jk = ["x1", "y1", "x2", "y2", "onMouseenter"], tP = ["x1", "y1", "x2", "y2", "onMouseenter"], eP = ["cy", "onMouseenter"], iP = ["cy", "onMouseenter"], nP = ["x", "y"], rP = ["x", "y"], aP = ["transform"], sP = /* @__PURE__ */ Te({
  __name: "CandlestickChart",
  props: {
    candlestickData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    candleWidth: { default: 35 },
    showLegend: { type: Boolean, default: !0 },
    yAxisLabel: { default: "score" }
  },
  setup(e) {
    const t = e, i = wi({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), n = (u) => typeof u == "string" ? u.charAt(0).toUpperCase() + u.slice(1).toLowerCase() : u, r = (u, c, h) => {
      const f = u.currentTarget.closest("svg");
      if (!f) return;
      const d = f.getBoundingClientRect(), v = f.createSVGPoint();
      v.x = u.clientX - d.left, v.y = u.clientY - d.top;
      let g = n(c.label), p = "";
      switch (h) {
        case "body":
          p = `Q1: ${c.q1.toFixed(1)} | Q3: ${c.q3.toFixed(1)}`;
          break;
        case "wick":
          p = `Min: ${c.low.toFixed(1)} | Max: ${c.high.toFixed(1)}`;
          break;
        case "median":
          p = `Median: ${c.median.toFixed(1)}`;
          break;
        case "average":
          p = `Average: ${c.average?.toFixed(1)}`;
          break;
        case "min":
          p = `Min: ${c.low.toFixed(1)}`;
          break;
        case "max":
          p = `Max: ${c.high.toFixed(1)}`;
          break;
      }
      const m = Math.max(180, p.length * 7 + 40), y = 48;
      i.value = {
        visible: !0,
        x: v.x,
        y: v.y - 20,
        title: g,
        text: p,
        width: m,
        height: y
      };
    }, a = (u) => {
      if (i.value.visible) {
        const c = u.currentTarget, h = c.getBoundingClientRect(), f = c.createSVGPoint();
        f.x = u.clientX - h.left, f.y = u.clientY - h.top, i.value.x = f.x, i.value.y = f.y - 20;
      }
    }, s = () => {
      i.value.visible = !1;
    }, o = () => {
      i.value.visible = !1;
    }, l = J(() => {
      const u = [], h = t.chartHeight - t.chartMargin - t.chartBottomMargin;
      for (let f = 1; f <= 10; f++) {
        const d = f, v = (d - 1) / 9, g = t.chartMargin + h - v * h;
        u.push({ value: d, y: g });
      }
      return u;
    });
    return (u, c) => (L(), O("div", Nk, [
      (L(), O("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full candlestick-svg",
        style: Ur(`min-height: ${e.chartHeight}px;`),
        onMousemove: a,
        onMouseleave: s
      }, [
        i.value.visible ? (L(), O("g", {
          key: 0,
          transform: `translate(${i.value.x}, ${i.value.y})`
        }, [
          S("rect", {
            x: -i.value.width / 2,
            y: -i.value.height - 10,
            width: i.value.width,
            height: i.value.height,
            fill: "rgba(15, 23, 42, 0.95)",
            rx: "8",
            stroke: "rgba(148, 163, 184, 0.2)",
            "stroke-width": "1"
          }, null, 8, zk),
          S("text", {
            x: "0",
            y: -i.value.height + 8,
            "text-anchor": "middle",
            fill: "#f1f5f9",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(i.value.title), 9, Vk),
          S("text", {
            x: "0",
            y: -i.value.height + 26,
            "text-anchor": "middle",
            fill: "#e2e8f0",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(i.value.text), 9, $k)
        ], 8, Bk)) : ct("", !0),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, Hk),
        S("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: "#475569"
        }, null, 8, Yk),
        (L(!0), O(Nt, null, ve(l.value, (h, f) => (L(), O("line", {
          key: `grid-${f}`,
          x1: e.chartMargin,
          y1: h.y,
          x2: e.chartWidth - e.chartMargin,
          y2: h.y,
          stroke: "#e5e7eb",
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, Wk))), 128)),
        (L(!0), O(Nt, null, ve(l.value, (h, f) => (L(), O(Nt, { key: f }, [
          S("line", {
            x1: e.chartMargin - 6,
            y1: h.y,
            x2: e.chartMargin,
            y2: h.y,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, Uk),
          S("text", {
            x: e.chartMargin - 12,
            y: h.y + 4,
            "text-anchor": "end",
            fill: "#64748b",
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, F(h.value), 9, Gk)
        ], 64))), 128)),
        S("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: "#475569",
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, F(n(e.yAxisLabel)), 9, jk),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, Xk),
        S("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: "#475569"
        }, null, 8, qk),
        (L(!0), O(Nt, null, ve(e.candlestickData, (h, f) => (L(), O(Nt, { key: f }, [
          S("g", {
            transform: `translate(${h.centerX}, 0)`
          }, [
            S("line", {
              x1: 0,
              y1: h.highY,
              x2: 0,
              y2: h.lowY,
              stroke: h.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              class: "hover-line",
              onMouseenter: (d) => r(d, h, "wick"),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Kk),
            S("rect", {
              x: -e.candleWidth / 2,
              y: Math.min(h.q1Y, h.q3Y),
              width: e.candleWidth,
              height: Math.abs(h.q3Y - h.q1Y),
              fill: h.isTotal ? "rgba(139, 92, 246, 0.15)" : "rgba(198, 125, 255, 0.15)",
              stroke: h.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              rx: "4",
              class: "hover-rect",
              onMouseenter: (d) => r(d, h, "body"),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Qk),
            h.medianY ? (L(), O("line", {
              key: 0,
              x1: -e.candleWidth / 2,
              y1: h.medianY,
              x2: e.candleWidth / 2,
              y2: h.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3",
              class: "hover-line",
              onMouseenter: (d) => r(d, h, "median"),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, Jk)) : ct("", !0),
            h.averageY ? (L(), O("line", {
              key: 1,
              x1: -e.candleWidth / 2,
              y1: h.averageY,
              x2: e.candleWidth / 2,
              y2: h.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (d) => r(d, h, "average"),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, tP)) : ct("", !0),
            S("circle", {
              cx: 0,
              cy: h.lowY,
              r: "5",
              fill: "#5d4b93",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (d) => r(d, h, "min"),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, eP),
            S("circle", {
              cx: 0,
              cy: h.highY,
              r: "5",
              fill: "#C67DFF",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (d) => r(d, h, "max"),
              onMouseleave: o,
              style: { cursor: "pointer" }
            }, null, 40, iP)
          ], 8, Zk),
          S("text", {
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: "#475569",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, F(n(h.label)), 9, nP),
          h.responseCount ? (L(), O("text", {
            key: 0,
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: "#64748b",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + F(h.responseCount), 9, rP)) : ct("", !0)
        ], 64))), 128)),
        e.showLegend ? (L(), O("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [...c[0] || (c[0] = [
          zt('<g transform="translate(-180, 0)" data-v-f6da4fd7><circle cx="0" cy="0" r="5" fill="#5d4b93" stroke="#ffffff" stroke-width="1.5" data-v-f6da4fd7></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-f6da4fd7> Min </text></g><g transform="translate(-120, 0)" data-v-f6da4fd7><rect x="-6" y="-6" width="12" height="12" fill="rgba(198, 125, 255, 0.15)" stroke="#C67DFF" stroke-width="1.5" rx="2" data-v-f6da4fd7></rect><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-f6da4fd7> Q1 </text></g><g transform="translate(-60, 0)" data-v-f6da4fd7><rect x="-6" y="-6" width="12" height="12" fill="rgba(198, 125, 255, 0.15)" stroke="#C67DFF" stroke-width="1.5" rx="2" data-v-f6da4fd7></rect><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-f6da4fd7> Q3 </text></g><g transform="translate(0, 0)" data-v-f6da4fd7><circle cx="0" cy="0" r="5" fill="#C67DFF" stroke="#ffffff" stroke-width="1.5" data-v-f6da4fd7></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-f6da4fd7> Max </text></g><g transform="translate(60, 0)" data-v-f6da4fd7><line x1="0" y1="0" x2="14" y2="0" stroke="#f97316" stroke-width="2.5" stroke-dasharray="6,4" data-v-f6da4fd7></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-f6da4fd7> Avg </text></g><g transform="translate(130, 0)" data-v-f6da4fd7><line x1="0" y1="0" x2="14" y2="0" stroke="#8b5cf6" stroke-width="2.5" data-v-f6da4fd7></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-f6da4fd7> Median </text></g>', 6)
        ])], 8, aP)) : ct("", !0)
      ], 44, Fk))
    ]));
  }
}), $b = /* @__PURE__ */ fe(sP, [["__scopeId", "data-v-f6da4fd7"]]), oP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $b
}, Symbol.toStringTag, { value: "Module" })), lP = { class: "chart-container" }, uP = ["viewBox"], cP = ["transform"], hP = ["x", "y", "width", "height"], fP = ["y"], dP = ["y"], vP = ["x1", "y1", "x2", "y2"], pP = ["x1", "y1", "x2", "y2"], gP = ["points"], mP = ["x1", "y1", "x2", "y2"], yP = ["x", "y"], _P = ["x", "y", "transform"], bP = ["x1", "y1", "x2", "y2"], xP = ["points"], wP = ["x1", "y1", "x2", "y2"], SP = ["x", "y"], MP = ["x", "y"], TP = ["d"], DP = ["x", "y", "width", "height", "onMouseenter"], CP = ["x1", "y1", "x2", "y2"], kP = ["x", "y"], PP = ["x1", "y1", "x2", "y2"], AP = ["x", "y"], EP = ["x1", "y1", "x2", "y2"], LP = ["x", "y"], OP = ["x1", "y1", "x2", "y2"], IP = ["x", "y"], RP = ["x1", "y1", "x2", "y2"], NP = ["x", "y"], FP = ["x1", "y1", "x2", "y2"], BP = ["x", "y"], zP = ["transform"], VP = /* @__PURE__ */ Te({
  __name: "HistogramChart",
  props: {
    histogram: { default: () => [] },
    minScore: { default: 0 },
    maxScore: { default: 0 },
    q1Score: { default: 0 },
    medianScore: { default: 0 },
    q3Score: { default: 0 },
    averageScore: { default: 0 },
    chartWidth: { default: 800 },
    chartHeight: { default: 450 },
    chartMargin: { default: 60 },
    chartBottomMargin: { default: 80 },
    showLegend: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = e, i = wi({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), n = J(() => t.chartWidth - t.chartMargin * 2), r = J(() => t.chartHeight - t.chartMargin - t.chartBottomMargin), a = J(() => n.value / 10 * 0.6), s = J(() => !t.histogram || t.histogram.length === 0 ? 1 : Math.max(...t.histogram.map((N) => N.count || 0), 1) + 30), o = J(() => {
      if (!t.histogram || t.histogram.length === 0) return 1;
      const I = t.averageScore || 0;
      let N = 0, B = 0;
      if (t.histogram.forEach((H) => {
        const G = H.count || 0;
        N += G;
        const nt = H.score - I;
        B += G * (nt * nt);
      }), N === 0) return 1;
      const $ = B / N;
      return Math.sqrt($) || 1;
    }), l = (I, N, B) => {
      if (B === 0) return 0;
      const $ = 1 / (B * Math.sqrt(2 * Math.PI)), H = -0.5 * Math.pow((I - N) / B, 2);
      return $ * Math.exp(H);
    }, u = J(() => {
      if (!t.histogram || t.histogram.length === 0 || t.averageScore === 0 && o.value === 0) return null;
      const I = t.averageScore, N = o.value, B = [], $ = 100, H = 1, G = 10, nt = t.histogram.reduce((ht, le) => ht + (le.count || 0), 0);
      if (nt === 0) return null;
      let K = 0;
      for (let ht = 0; ht <= $; ht++) {
        const le = H + (G - H) * (ht / $), De = l(le, I, N);
        De > K && (K = De);
      }
      const gt = r.value * 0.75 / K * nt * 6e-3, Ht = t.chartMargin;
      for (let ht = 0; ht <= $; ht++) {
        const le = H + (G - H) * (ht / $), de = l(le, I, N) * gt, Zt = h(le);
        if (Zt !== null) {
          let it = t.chartHeight - t.chartBottomMargin - de;
          it = Math.max(it, Ht), B.push(`${ht === 0 ? "M" : "L"} ${Zt} ${it}`);
        }
      }
      return B.join(" ");
    }), c = J(() => {
      if (!t.histogram || t.histogram.length === 0) return [];
      const I = n.value / 10;
      return t.histogram.map((N, B) => {
        const $ = t.chartMargin + (B + 0.5) * I, H = N.count > 0 ? N.count / s.value * r.value : 0, G = t.chartHeight - t.chartBottomMargin - H;
        return {
          score: N.score,
          count: N.count,
          x: $,
          y: G,
          height: H
        };
      });
    }), h = (I) => {
      if (I < 1 || I > 10) return null;
      const N = n.value / 10;
      return t.chartMargin + (I - 0.5) * N;
    }, f = J(() => h(t.minScore)), d = J(() => h(t.maxScore)), v = J(() => h(t.q1Score)), g = J(() => h(t.medianScore)), p = J(() => h(t.q3Score)), m = J(() => h(t.averageScore)), y = J(() => t.minScore), _ = J(() => t.maxScore), b = J(() => t.q1Score), x = J(() => t.medianScore), w = J(() => t.q3Score), M = J(() => t.averageScore), T = J(() => {
      const I = [], N = t.chartMargin - 8, B = 18;
      v.value !== null && I.push({
        x: v.value,
        y: N,
        value: t.q1Score,
        label: `Q1: ${b.value.toFixed(1)}`,
        color: "#a855f7",
        id: "q1",
        width: 55
      }), g.value !== null && I.push({
        x: g.value,
        y: N - B,
        value: t.medianScore,
        label: `Median: ${x.value.toFixed(1)}`,
        color: "#8b5cf6",
        id: "median",
        width: 90
      }), m.value !== null && I.push({
        x: m.value,
        y: N - B,
        value: t.averageScore,
        label: `Avg: ${M.value.toFixed(1)}`,
        color: "#f97316",
        id: "avg",
        width: 65
      }), p.value !== null && I.push({
        x: p.value,
        y: N,
        value: t.q3Score,
        label: `Q3: ${w.value.toFixed(1)}`,
        color: "#7c3aed",
        id: "q3",
        width: 55
      }), I.sort((G, nt) => (G.x || 0) - (nt.x || 0));
      const $ = [[], [], []];
      I.forEach((G) => {
        if (G.x === null) return;
        let nt = -1;
        for (let K = 0; K < $.length; K++) {
          let pt = !1;
          for (const gt of $[K]) {
            if (gt.x === null) continue;
            const Ht = Math.abs(G.x - gt.x), ht = (G.width + gt.width) / 2 + 10;
            if (Ht < ht) {
              pt = !0;
              break;
            }
          }
          if (!pt) {
            nt = K;
            break;
          }
        }
        nt === -1 && (nt = $.length - 1), G.y = N - nt * B, $[nt].push(G);
      });
      const H = 15;
      return I.forEach((G) => {
        G.y < H && (G.y = H);
      }), I;
    }), D = (I) => T.value.find((B) => B.id === I)?.y || t.chartMargin - 10, P = J(() => {
      const I = [];
      for (let B = 0; B <= 5; B++) {
        const $ = Math.round(s.value / 5 * B), H = t.chartHeight - t.chartBottomMargin - B / 5 * r.value;
        I.push({ value: $, y: H });
      }
      return I;
    }), C = (I, N) => {
      const B = I.currentTarget.closest("svg");
      if (!B) return;
      const $ = B.getBoundingClientRect(), H = B.createSVGPoint();
      H.x = I.clientX - $.left, H.y = I.clientY - $.top;
      const G = `Score: ${N.score}`, nt = `Count: ${N.count}`, K = 120, pt = 48;
      i.value = {
        visible: !0,
        x: H.x,
        y: H.y - 20,
        title: G,
        text: nt,
        width: K,
        height: pt
      };
    }, A = (I) => {
      if (i.value.visible) {
        const N = I.currentTarget, B = N.getBoundingClientRect(), $ = N.createSVGPoint();
        $.x = I.clientX - B.left, $.y = I.clientY - B.top, i.value.x = $.x, i.value.y = $.y - 20;
      }
    }, E = () => {
      i.value.visible = !1;
    }, R = () => {
      i.value.visible = !1;
    };
    return (I, N) => (L(), O("div", lP, [
      (L(), O("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full histogram-svg",
        style: Ur(`min-height: ${e.chartHeight}px;`),
        onMousemove: A,
        onMouseleave: E
      }, [
        i.value.visible ? (L(), O("g", {
          key: 0,
          transform: `translate(${i.value.x}, ${i.value.y})`
        }, [
          S("rect", {
            x: -i.value.width / 2,
            y: -i.value.height - 10,
            width: i.value.width,
            height: i.value.height,
            fill: "rgba(15, 23, 42, 0.95)",
            rx: "8",
            stroke: "rgba(148, 163, 184, 0.2)",
            "stroke-width": "1"
          }, null, 8, hP),
          S("text", {
            x: "0",
            y: -i.value.height + 8,
            "text-anchor": "middle",
            fill: "#f1f5f9",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(i.value.title), 9, fP),
          S("text", {
            x: "0",
            y: -i.value.height + 26,
            "text-anchor": "middle",
            fill: "#e2e8f0",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(i.value.text), 9, dP)
        ], 8, cP)) : ct("", !0),
        (L(!0), O(Nt, null, ve(P.value, (B, $) => (L(), O("line", {
          key: `grid-${$}`,
          x1: e.chartMargin,
          y1: B.y,
          x2: e.chartWidth - e.chartMargin,
          y2: B.y,
          stroke: "#e5e7eb",
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, vP))), 128)),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, pP),
        S("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: "#475569"
        }, null, 8, gP),
        (L(!0), O(Nt, null, ve(P.value, (B, $) => (L(), O(Nt, {
          key: `y-tick-${$}`
        }, [
          S("line", {
            x1: e.chartMargin - 6,
            y1: B.y,
            x2: e.chartMargin,
            y2: B.y,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, mP),
          S("text", {
            x: e.chartMargin - 12,
            y: B.y + 4,
            "text-anchor": "end",
            fill: "#64748b",
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, F(B.value), 9, yP)
        ], 64))), 128)),
        S("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: "#475569",
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, " Count ", 8, _P),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, bP),
        S("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: "#475569"
        }, null, 8, xP),
        (L(!0), O(Nt, null, ve(c.value, (B, $) => (L(), O(Nt, {
          key: `tick-${$}`
        }, [
          S("line", {
            x1: B.x,
            y1: e.chartHeight - e.chartBottomMargin,
            x2: B.x,
            y2: e.chartHeight - e.chartBottomMargin + 5,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, wP),
          S("text", {
            x: B.x,
            y: e.chartHeight - e.chartBottomMargin + 20,
            "text-anchor": "middle",
            fill: "#475569",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, F(B.score), 9, SP)
        ], 64))), 128)),
        S("text", {
          x: e.chartWidth / 2,
          y: e.chartHeight - e.chartBottomMargin + 40,
          "text-anchor": "middle",
          fill: "#475569",
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Score ", 8, MP),
        u.value ? (L(), O("path", {
          key: 1,
          d: u.value,
          fill: "none",
          stroke: "#8b5cf6",
          "stroke-width": "2.5",
          opacity: "0.7",
          class: "gaussian-curve"
        }, null, 8, TP)) : ct("", !0),
        (L(!0), O(Nt, null, ve(c.value, (B, $) => (L(), O("rect", {
          key: `bar-${$}`,
          x: B.x - a.value / 2,
          y: B.y,
          width: a.value,
          height: B.height,
          fill: "rgba(198, 125, 255, 0.6)",
          stroke: "#C67DFF",
          "stroke-width": "2",
          rx: "4",
          class: "histogram-bar",
          onMouseenter: (H) => C(H, B),
          onMouseleave: R,
          style: { cursor: "pointer" }
        }, null, 40, DP))), 128)),
        f.value ? (L(), O("line", {
          key: 2,
          x1: f.value,
          y1: e.chartMargin,
          x2: f.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#5d4b93",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, CP)) : ct("", !0),
        f.value ? (L(), O("text", {
          key: 3,
          x: f.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#5d4b93",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Min: " + F(y.value.toFixed(1)), 9, kP)) : ct("", !0),
        v.value ? (L(), O("line", {
          key: 4,
          x1: v.value,
          y1: e.chartMargin,
          x2: v.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#a855f7",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, PP)) : ct("", !0),
        v.value ? (L(), O("text", {
          key: 5,
          x: v.value,
          y: D("q1"),
          "text-anchor": "middle",
          fill: "#a855f7",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q1: " + F(b.value.toFixed(1)), 9, AP)) : ct("", !0),
        g.value ? (L(), O("line", {
          key: 6,
          x1: g.value,
          y1: e.chartMargin,
          x2: g.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#8b5cf6",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, EP)) : ct("", !0),
        g.value ? (L(), O("text", {
          key: 7,
          x: g.value,
          y: D("median"),
          "text-anchor": "middle",
          fill: "#8b5cf6",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Median: " + F(x.value.toFixed(1)), 9, LP)) : ct("", !0),
        m.value ? (L(), O("line", {
          key: 8,
          x1: m.value,
          y1: e.chartMargin,
          x2: m.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#f97316",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, OP)) : ct("", !0),
        m.value ? (L(), O("text", {
          key: 9,
          x: m.value,
          y: D("avg"),
          "text-anchor": "middle",
          fill: "#f97316",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Avg: " + F(M.value.toFixed(1)), 9, IP)) : ct("", !0),
        p.value ? (L(), O("line", {
          key: 10,
          x1: p.value,
          y1: e.chartMargin,
          x2: p.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#7c3aed",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, RP)) : ct("", !0),
        p.value ? (L(), O("text", {
          key: 11,
          x: p.value,
          y: D("q3"),
          "text-anchor": "middle",
          fill: "#7c3aed",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q3: " + F(w.value.toFixed(1)), 9, NP)) : ct("", !0),
        d.value ? (L(), O("line", {
          key: 12,
          x1: d.value,
          y1: e.chartMargin,
          x2: d.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#C67DFF",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, FP)) : ct("", !0),
        d.value ? (L(), O("text", {
          key: 13,
          x: d.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#C67DFF",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Max: " + F(_.value.toFixed(1)), 9, BP)) : ct("", !0),
        e.showLegend ? (L(), O("g", {
          key: 14,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 50})`
        }, [...N[0] || (N[0] = [
          zt('<g transform="translate(-220, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#8b5cf6" stroke-width="2.5" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Gaussian </text></g><g transform="translate(-140, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#5d4b93" stroke-width="2.5" stroke-dasharray="6,4" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Min </text></g><g transform="translate(-80, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#a855f7" stroke-width="2.5" stroke-dasharray="6,4" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Q1 </text></g><g transform="translate(-20, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#8b5cf6" stroke-width="3" stroke-dasharray="6,4" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Median </text></g><g transform="translate(60, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#f97316" stroke-width="3" stroke-dasharray="6,4" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Avg </text></g><g transform="translate(130, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#7c3aed" stroke-width="2.5" stroke-dasharray="6,4" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Q3 </text></g><g transform="translate(180, 0)" data-v-9a2c13d4><line x1="0" y1="0" x2="20" y2="0" stroke="#C67DFF" stroke-width="2.5" stroke-dasharray="6,4" data-v-9a2c13d4></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-9a2c13d4> Max </text></g>', 7)
        ])], 8, zP)) : ct("", !0)
      ], 44, uP))
    ]));
  }
}), Hb = /* @__PURE__ */ fe(VP, [["__scopeId", "data-v-9a2c13d4"]]), $P = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Hb
}, Symbol.toStringTag, { value: "Module" }));
var $f = function(e, t) {
  return $f = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, $f(e, t);
};
function ae(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  $f(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
var HP = /* @__PURE__ */ (function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
})(), YP = /* @__PURE__ */ (function() {
  function e() {
    this.browser = new HP(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
})(), rt = new YP();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (rt.wxa = !0, rt.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? rt.worker = !0 : !rt.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (rt.node = !0, rt.svgSupported = !0) : WP(navigator.userAgent, rt);
function WP(e, t) {
  var i = t.browser, n = e.match(/Firefox\/([\d.]+)/), r = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), a = e.match(/Edge?\/([\d.]+)/), s = /micromessenger/i.test(e);
  n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1], i.newEdge = +a[1].split(".")[0] > 18), s && (i.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !i.ie && !i.edge, t.pointerEventsSupported = "onpointerdown" in window && (i.edge || i.ie && +i.version >= 11);
  var o = t.domSupported = typeof document < "u";
  if (o) {
    var l = document.documentElement.style;
    t.transform3dSupported = (i.ie && "transition" in l || i.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || i.ie && +i.version >= 9;
  }
}
var pv = 12, UP = "sans-serif", Qn = pv + "px " + UP, GP = 20, jP = 100, XP = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function qP(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var i = 0; i < e.length; i++) {
    var n = String.fromCharCode(i + 32), r = (e.charCodeAt(i) - GP) / jP;
    t[n] = r;
  }
  return t;
}
var ZP = qP(XP), wn = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ (function() {
    var e, t;
    return function(i, n) {
      if (!e) {
        var r = wn.createCanvas();
        e = r && r.getContext("2d");
      }
      if (e)
        return t !== n && (t = e.font = n || Qn), e.measureText(i);
      i = i || "", n = n || Qn;
      var a = /((?:\d+)?\.?\d*)px/.exec(n), s = a && +a[1] || pv, o = 0;
      if (n.indexOf("mono") >= 0)
        o = s * i.length;
      else
        for (var l = 0; l < i.length; l++) {
          var u = ZP[i[l]];
          o += u == null ? s : u * s;
        }
      return { width: o };
    };
  })(),
  loadImage: function(e, t, i) {
    var n = new Image();
    return n.onload = t, n.onerror = i, n.src = e, n;
  }
}, Yb = us([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), Wb = us([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), ls = Object.prototype.toString, _c = Array.prototype, KP = _c.forEach, QP = _c.filter, gv = _c.slice, JP = _c.map, um = (function() {
}).constructor, fl = um ? um.prototype : null, mv = "__proto__", tA = 2311;
function Ub() {
  return tA++;
}
function jr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function dt(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, i = ls.call(e);
  if (i === "[object Array]") {
    if (!oo(e)) {
      t = [];
      for (var n = 0, r = e.length; n < r; n++)
        t[n] = dt(e[n]);
    }
  } else if (Wb[i]) {
    if (!oo(e)) {
      var a = e.constructor;
      if (a.from)
        t = a.from(e);
      else {
        t = new a(e.length);
        for (var n = 0, r = e.length; n < r; n++)
          t[n] = e[n];
      }
    }
  } else if (!Yb[i] && !oo(e) && !ts(e)) {
    t = {};
    for (var s in e)
      e.hasOwnProperty(s) && s !== mv && (t[s] = dt(e[s]));
  }
  return t;
}
function re(e, t, i) {
  if (!q(t) || !q(e))
    return i ? dt(t) : e;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== mv) {
      var r = e[n], a = t[n];
      q(a) && q(r) && !j(a) && !j(r) && !ts(a) && !ts(r) && !cm(a) && !cm(r) && !oo(a) && !oo(r) ? re(r, a, i) : (i || !(n in e)) && (e[n] = dt(t[n]));
    }
  return e;
}
function Y(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var i in t)
      t.hasOwnProperty(i) && i !== mv && (e[i] = t[i]);
  return e;
}
function Qt(e, t, i) {
  for (var n = jt(t), r = 0, a = n.length; r < a; r++) {
    var s = n[r];
    e[s] == null && (e[s] = t[s]);
  }
  return e;
}
function Bt(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var i = 0, n = e.length; i < n; i++)
      if (e[i] === t)
        return i;
  }
  return -1;
}
function eA(e, t) {
  var i = e.prototype;
  function n() {
  }
  n.prototype = t.prototype, e.prototype = new n();
  for (var r in i)
    i.hasOwnProperty(r) && (e.prototype[r] = i[r]);
  e.prototype.constructor = e, e.superClass = t;
}
function Ci(e, t, i) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), r = 0; r < n.length; r++) {
      var a = n[r];
      a !== "constructor" && e[a] == null && (e[a] = t[a]);
    }
  else
    Qt(e, t);
}
function Ye(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function k(e, t, i) {
  if (e && t)
    if (e.forEach && e.forEach === KP)
      e.forEach(t, i);
    else if (e.length === +e.length)
      for (var n = 0, r = e.length; n < r; n++)
        t.call(i, e[n], n, e);
    else
      for (var a in e)
        e.hasOwnProperty(a) && t.call(i, e[a], a, e);
}
function bt(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return yv(e);
  if (e.map && e.map === JP)
    return e.map(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    n.push(t.call(i, e[r], r, e));
  return n;
}
function us(e, t, i, n) {
  if (e && t) {
    for (var r = 0, a = e.length; r < a; r++)
      i = t.call(n, i, e[r], r, e);
    return i;
  }
}
function je(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return yv(e);
  if (e.filter && e.filter === QP)
    return e.filter(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    t.call(i, e[r], r, e) && n.push(e[r]);
  return n;
}
function jt(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var i in e)
    e.hasOwnProperty(i) && t.push(i);
  return t;
}
function iA(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return function() {
    return e.apply(t, i.concat(gv.call(arguments)));
  };
}
var Dt = fl && mt(fl.bind) ? fl.call.bind(fl.bind) : iA;
function Ae(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return function() {
    return e.apply(this, t.concat(gv.call(arguments)));
  };
}
function j(e) {
  return Array.isArray ? Array.isArray(e) : ls.call(e) === "[object Array]";
}
function mt(e) {
  return typeof e == "function";
}
function Q(e) {
  return typeof e == "string";
}
function wu(e) {
  return ls.call(e) === "[object String]";
}
function Xt(e) {
  return typeof e == "number";
}
function q(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function cm(e) {
  return !!Yb[ls.call(e)];
}
function Le(e) {
  return !!Wb[ls.call(e)];
}
function ts(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function bc(e) {
  return e.colorStops != null;
}
function nA(e) {
  return e.image != null;
}
function rA(e) {
  return ls.call(e) === "[object RegExp]";
}
function Gb(e) {
  return e !== e;
}
function Jn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var i = 0, n = e.length; i < n; i++)
    if (e[i] != null)
      return e[i];
}
function et(e, t) {
  return e ?? t;
}
function Xr(e, t, i) {
  return e ?? t ?? i;
}
function yv(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return gv.apply(e, t);
}
function _v(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function tt(e, t) {
  if (!e)
    throw new Error(t);
}
function Hi(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var jb = "__ec_primitive__";
function Hf(e) {
  e[jb] = !0;
}
function oo(e) {
  return e[jb];
}
var aA = (function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var i = this.has(t);
    return i && delete this.data[t], i;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, i) {
    return this.data[t] = i, this;
  }, e.prototype.keys = function() {
    return jt(this.data);
  }, e.prototype.forEach = function(t) {
    var i = this.data;
    for (var n in i)
      i.hasOwnProperty(n) && t(i[n], n);
  }, e;
})(), Xb = typeof Map == "function";
function sA() {
  return Xb ? /* @__PURE__ */ new Map() : new aA();
}
var oA = (function() {
  function e(t) {
    var i = j(t);
    this.data = sA();
    var n = this;
    t instanceof e ? t.each(r) : t && k(t, r);
    function r(a, s) {
      i ? n.set(a, s) : n.set(s, a);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, i) {
    return this.data.set(t, i), i;
  }, e.prototype.each = function(t, i) {
    this.data.forEach(function(n, r) {
      t.call(i, n, r);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return Xb ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
})();
function lt(e) {
  return new oA(e);
}
function lA(e, t) {
  for (var i = new e.constructor(e.length + t.length), n = 0; n < e.length; n++)
    i[n] = e[n];
  for (var r = e.length, n = 0; n < t.length; n++)
    i[n + r] = t[n];
  return i;
}
function xc(e, t) {
  var i;
  if (Object.create)
    i = Object.create(e);
  else {
    var n = function() {
    };
    n.prototype = e, i = new n();
  }
  return t && Y(i, t), i;
}
function qb(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function Ui(e, t) {
  return e.hasOwnProperty(t);
}
function be() {
}
var uA = 180 / Math.PI;
var Yf = function(e, t) {
  return Yf = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, Yf(e, t);
};
function At(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Yf(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
function cs(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function cA(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function hA(e) {
  return [e[0], e[1]];
}
function hm(e, t, i) {
  return e[0] = t[0] + i[0], e[1] = t[1] + i[1], e;
}
function fA(e, t, i) {
  return e[0] = t[0] - i[0], e[1] = t[1] - i[1], e;
}
function dA(e) {
  return Math.sqrt(vA(e));
}
function vA(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function uh(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e;
}
function pA(e, t) {
  var i = dA(t);
  return i === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / i, e[1] = t[1] / i), e;
}
function Wf(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var gA = Wf;
function mA(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var Ua = mA;
function qe(e, t, i) {
  var n = t[0], r = t[1];
  return e[0] = i[0] * n + i[2] * r + i[4], e[1] = i[1] * n + i[3] * r + i[5], e;
}
function Na(e, t, i) {
  return e[0] = Math.min(t[0], i[0]), e[1] = Math.min(t[1], i[1]), e;
}
function Fa(e, t, i) {
  return e[0] = Math.max(t[0], i[0]), e[1] = Math.max(t[1], i[1]), e;
}
var pa = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.target = t, this.topTarget = i && i.topTarget;
  }
  return e;
})(), yA = (function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var i = t.target; i && !i.draggable; )
      i = i.parent || i.__hostTarget;
    i && (this._draggingTarget = i, i.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new pa(i, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var i = this._draggingTarget;
    if (i) {
      var n = t.offsetX, r = t.offsetY, a = n - this._x, s = r - this._y;
      this._x = n, this._y = r, i.drift(a, s, t), this.handler.dispatchToElement(new pa(i, t), "drag", t.event);
      var o = this.handler.findHover(n, r, i).target, l = this._dropTarget;
      this._dropTarget = o, i !== o && (l && o !== l && this.handler.dispatchToElement(new pa(l, t), "dragleave", t.event), o && o !== l && this.handler.dispatchToElement(new pa(o, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var i = this._draggingTarget;
    i && (i.dragging = !1), this.handler.dispatchToElement(new pa(i, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new pa(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
})(), ki = (function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, i, n, r) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof i == "function" && (r = n, n = i, i = null), !n || !t)
      return this;
    var s = this._$eventProcessor;
    i != null && s && s.normalizeQuery && (i = s.normalizeQuery(i)), a[t] || (a[t] = []);
    for (var o = 0; o < a[t].length; o++)
      if (a[t][o].h === n)
        return this;
    var l = {
      h: n,
      query: i,
      ctx: r || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var i = this._$handlers;
    return !i || !i[t] || !i[t].length;
  }, e.prototype.off = function(t, i) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (i) {
      if (n[t]) {
        for (var r = [], a = 0, s = n[t].length; a < s; a++)
          n[t][a].h !== i && r.push(n[t][a]);
        n[t] = r;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var s = i.length, o = r.length, l = 0; l < o; l++) {
        var u = r[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (s) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, i[0]);
              break;
            case 2:
              u.h.call(u.ctx, i[0], i[1]);
              break;
            default:
              u.h.apply(u.ctx, i);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var s = i.length, o = i[s - 1], l = r.length, u = 0; u < l; u++) {
        var c = r[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (s) {
            case 0:
              c.h.call(o);
              break;
            case 1:
              c.h.call(o, i[0]);
              break;
            case 2:
              c.h.call(o, i[0], i[1]);
              break;
            default:
              c.h.apply(o, i.slice(1, s - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e;
})(), _A = Math.log(2);
function Uf(e, t, i, n, r, a) {
  var s = n + "-" + r, o = e.length;
  if (a.hasOwnProperty(s))
    return a[s];
  if (t === 1) {
    var l = Math.round(Math.log((1 << o) - 1 & ~r) / _A);
    return e[i][l];
  }
  for (var u = n | 1 << i, c = i + 1; n & 1 << c; )
    c++;
  for (var h = 0, f = 0, d = 0; f < o; f++) {
    var v = 1 << f;
    v & r || (h += (d % 2 ? -1 : 1) * e[i][f] * Uf(e, t - 1, c, u, r | v, a), d++);
  }
  return a[s] = h, h;
}
function fm(e, t) {
  var i = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], n = {}, r = Uf(i, 8, 0, 0, 0, n);
  if (r !== 0) {
    for (var a = [], s = 0; s < 8; s++)
      for (var o = 0; o < 8; o++)
        a[o] == null && (a[o] = 0), a[o] += ((s + o) % 2 ? -1 : 1) * Uf(i, 7, s === 0 ? 1 : 0, 1 << s, 1 << o, n) / r * t[s];
    return function(l, u, c) {
      var h = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
    };
  }
}
var Su = "___zrEVENTSAVED", ch = [];
function bA(e, t, i, n, r) {
  return Gf(ch, t, n, r, !0) && Gf(e, i, ch[0], ch[1]);
}
function xA(e, t) {
  e && i(e), t && i(t);
  function i(n) {
    var r = n[Su];
    r && (r.clearMarkers && r.clearMarkers(), delete n[Su]);
  }
}
function Gf(e, t, i, n, r) {
  if (t.getBoundingClientRect && rt.domSupported && !Zb(t)) {
    var a = t[Su] || (t[Su] = {}), s = wA(t, a), o = SA(s, a, r);
    if (o)
      return o(e, i, n), !0;
  }
  return !1;
}
function wA(e, t) {
  var i = t.markers;
  if (i)
    return i;
  i = t.markers = [];
  for (var n = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
    var s = document.createElement("div"), o = s.style, l = a % 2, u = (a >> 1) % 2;
    o.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      r[u] + ":0",
      n[1 - l] + ":auto",
      r[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(s), i.push(s);
  }
  return t.clearMarkers = function() {
    k(i, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, i;
}
function SA(e, t, i) {
  for (var n = i ? "invTrans" : "trans", r = t[n], a = t.srcCoords, s = [], o = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), h = 2 * u, f = c.left, d = c.top;
    s.push(f, d), l = l && a && f === a[h] && d === a[h + 1], o.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && r ? r : (t.srcCoords = s, t[n] = i ? fm(o, s) : fm(s, o));
}
function Zb(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var MA = /([&<>"'])/g, TA = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Fe(e) {
  return e == null ? "" : (e + "").replace(MA, function(t, i) {
    return TA[i];
  });
}
var DA = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, hh = [], CA = rt.browser.firefox && +rt.browser.version.split(".")[0] < 39;
function jf(e, t, i, n) {
  return i = i || {}, n ? dm(e, t, i) : CA && t.layerX != null && t.layerX !== t.offsetX ? (i.zrX = t.layerX, i.zrY = t.layerY) : t.offsetX != null ? (i.zrX = t.offsetX, i.zrY = t.offsetY) : dm(e, t, i), i;
}
function dm(e, t, i) {
  if (rt.domSupported && e.getBoundingClientRect) {
    var n = t.clientX, r = t.clientY;
    if (Zb(e)) {
      var a = e.getBoundingClientRect();
      i.zrX = n - a.left, i.zrY = r - a.top;
      return;
    } else if (Gf(hh, e, n, r)) {
      i.zrX = hh[0], i.zrY = hh[1];
      return;
    }
  }
  i.zrX = i.zrY = 0;
}
function bv(e) {
  return e || window.event;
}
function ni(e, t, i) {
  if (t = bv(t), t.zrX != null)
    return t;
  var n = t.type, r = n && n.indexOf("touch") >= 0;
  if (r) {
    var s = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    s && jf(e, s, t, i);
  } else {
    jf(e, t, t, i);
    var a = kA(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var o = t.button;
  return t.which == null && o !== void 0 && DA.test(t.type) && (t.which = o & 1 ? 1 : o & 2 ? 3 : o & 4 ? 2 : 0), t;
}
function kA(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var i = e.deltaX, n = e.deltaY;
  if (i == null || n == null)
    return t;
  var r = Math.abs(n !== 0 ? n : i), a = n > 0 ? -1 : n < 0 ? 1 : i > 0 ? -1 : 1;
  return 3 * r * a;
}
function PA(e, t, i, n) {
  e.addEventListener(t, i, n);
}
function AA(e, t, i, n) {
  e.removeEventListener(t, i, n);
}
var Mu = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function vm(e) {
  return e.which === 2 || e.which === 3;
}
var EA = (function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, i, n) {
    return this._doTrack(t, i, n), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, i, n) {
    var r = t.touches;
    if (r) {
      for (var a = {
        points: [],
        touches: [],
        target: i,
        event: t
      }, s = 0, o = r.length; s < o; s++) {
        var l = r[s], u = jf(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, e.prototype._recognize = function(t) {
    for (var i in fh)
      if (fh.hasOwnProperty(i)) {
        var n = fh[i](this._track, t);
        if (n)
          return n;
      }
  }, e;
})();
function pm(e) {
  var t = e[1][0] - e[0][0], i = e[1][1] - e[0][1];
  return Math.sqrt(t * t + i * i);
}
function LA(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var fh = {
  pinch: function(e, t) {
    var i = e.length;
    if (i) {
      var n = (e[i - 1] || {}).points, r = (e[i - 2] || {}).points || n;
      if (r && r.length > 1 && n && n.length > 1) {
        var a = pm(n) / pm(r);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var s = LA(n);
        return t.pinchX = s[0], t.pinchY = s[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function Gi() {
  return [1, 0, 0, 1, 0, 0];
}
function xv(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function wv(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function lo(e, t, i) {
  var n = t[0] * i[0] + t[2] * i[1], r = t[1] * i[0] + t[3] * i[1], a = t[0] * i[2] + t[2] * i[3], s = t[1] * i[2] + t[3] * i[3], o = t[0] * i[4] + t[2] * i[5] + t[4], l = t[1] * i[4] + t[3] * i[5] + t[5];
  return e[0] = n, e[1] = r, e[2] = a, e[3] = s, e[4] = o, e[5] = l, e;
}
function Xf(e, t, i) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + i[0], e[5] = t[5] + i[1], e;
}
function Sv(e, t, i, n) {
  n === void 0 && (n = [0, 0]);
  var r = t[0], a = t[2], s = t[4], o = t[1], l = t[3], u = t[5], c = Math.sin(i), h = Math.cos(i);
  return e[0] = r * h + o * c, e[1] = -r * c + o * h, e[2] = a * h + l * c, e[3] = -a * c + h * l, e[4] = h * (s - n[0]) + c * (u - n[1]) + n[0], e[5] = h * (u - n[1]) - c * (s - n[0]) + n[1], e;
}
function OA(e, t, i) {
  var n = i[0], r = i[1];
  return e[0] = t[0] * n, e[1] = t[1] * r, e[2] = t[2] * n, e[3] = t[3] * r, e[4] = t[4] * n, e[5] = t[5] * r, e;
}
function Wo(e, t) {
  var i = t[0], n = t[2], r = t[4], a = t[1], s = t[3], o = t[5], l = i * s - a * n;
  return l ? (l = 1 / l, e[0] = s * l, e[1] = -a * l, e[2] = -n * l, e[3] = i * l, e[4] = (n * o - s * r) * l, e[5] = (a * r - i * o) * l, e) : null;
}
var Lt = (function() {
  function e(t, i) {
    this.x = t || 0, this.y = i || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, i) {
    return this.x = t, this.y = i, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, i) {
    this.x += t.x * i, this.y += t.y * i;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(i * i + n * n);
  }, e.prototype.distanceSquare = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return i * i + n * n;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var i = this.x, n = this.y;
      return this.x = t[0] * i + t[2] * n + t[4], this.y = t[1] * i + t[3] * n + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, i, n) {
    t.x = i, t.y = n;
  }, e.copy = function(t, i) {
    t.x = i.x, t.y = i.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, i) {
    return t.x * i.x + t.y * i.y;
  }, e.add = function(t, i, n) {
    t.x = i.x + n.x, t.y = i.y + n.y;
  }, e.sub = function(t, i, n) {
    t.x = i.x - n.x, t.y = i.y - n.y;
  }, e.scale = function(t, i, n) {
    t.x = i.x * n, t.y = i.y * n;
  }, e.scaleAndAdd = function(t, i, n, r) {
    t.x = i.x + n.x * r, t.y = i.y + n.y * r;
  }, e.lerp = function(t, i, n, r) {
    var a = 1 - r;
    t.x = a * i.x + r * n.x, t.y = a * i.y + r * n.y;
  }, e;
})(), zr = Math.min, Ba = Math.max, qf = Math.abs, gm = ["x", "y"], IA = ["width", "height"], lr = new Lt(), ur = new Lt(), cr = new Lt(), hr = new Lt(), Ge = Kb(), Xs = Ge.minTv, Zf = Ge.maxTv, uo = [0, 0], at = (function() {
  function e(t, i, n, r) {
    e.set(this, t, i, n, r);
  }
  return e.set = function(t, i, n, r, a) {
    return r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), t.x = i, t.y = n, t.width = r, t.height = a, t;
  }, e.prototype.union = function(t) {
    var i = zr(t.x, this.x), n = zr(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Ba(t.x + t.width, this.x + this.width) - i : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Ba(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = i, this.y = n;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var i = this, n = t.width / i.width, r = t.height / i.height, a = Gi();
    return Xf(a, a, [-i.x, -i.y]), OA(a, a, [n, r]), Xf(a, a, [t.x, t.y]), a;
  }, e.prototype.intersect = function(t, i, n) {
    return e.intersect(this, t, i, n);
  }, e.intersect = function(t, i, n, r) {
    n && Lt.set(n, 0, 0);
    var a = r && r.outIntersectRect || null, s = r && r.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !i)
      return !1;
    t instanceof e || (t = e.set(RA, t.x, t.y, t.width, t.height)), i instanceof e || (i = e.set(NA, i.x, i.y, i.width, i.height));
    var o = !!n;
    Ge.reset(r, o);
    var l = Ge.touchThreshold, u = t.x + l, c = t.x + t.width - l, h = t.y + l, f = t.y + t.height - l, d = i.x + l, v = i.x + i.width - l, g = i.y + l, p = i.y + i.height - l;
    if (u > c || h > f || d > v || g > p)
      return !1;
    var m = !(c < d || v < u || f < g || p < h);
    return (o || a) && (uo[0] = 1 / 0, uo[1] = 0, mm(u, c, d, v, 0, o, a, s), mm(h, f, g, p, 1, o, a, s), o && Lt.copy(n, m ? Ge.useDir ? Ge.dirMinTv : Xs : Zf)), m;
  }, e.contain = function(t, i, n) {
    return i >= t.x && i <= t.x + t.width && n >= t.y && n <= t.y + t.height;
  }, e.prototype.contain = function(t, i) {
    return e.contain(this, t, i);
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, i) {
    return t.x = i.x, t.y = i.y, t.width = i.width, t.height = i.height, t;
  }, e.applyTransform = function(t, i, n) {
    if (!n) {
      t !== i && e.copy(t, i);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var r = n[0], a = n[3], s = n[4], o = n[5];
      t.x = i.x * r + s, t.y = i.y * a + o, t.width = i.width * r, t.height = i.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    lr.x = cr.x = i.x, lr.y = hr.y = i.y, ur.x = hr.x = i.x + i.width, ur.y = cr.y = i.y + i.height, lr.transform(n), hr.transform(n), ur.transform(n), cr.transform(n), t.x = zr(lr.x, ur.x, cr.x, hr.x), t.y = zr(lr.y, ur.y, cr.y, hr.y);
    var l = Ba(lr.x, ur.x, cr.x, hr.x), u = Ba(lr.y, ur.y, cr.y, hr.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
})(), RA = new at(0, 0, 0, 0), NA = new at(0, 0, 0, 0);
function mm(e, t, i, n, r, a, s, o) {
  var l = qf(t - i), u = qf(n - e), c = zr(l, u), h = gm[r], f = gm[1 - r], d = IA[r];
  t < i || n < e ? l < u ? (a && (Zf[h] = -l), o && (s[h] = t, s[d] = 0)) : (a && (Zf[h] = u), o && (s[h] = e, s[d] = 0)) : (s && (s[h] = Ba(e, i), s[d] = zr(t, n) - s[h]), a && (c < uo[0] || Ge.useDir) && (uo[0] = zr(c, uo[0]), (l < u || !Ge.bidirectional) && (Xs[h] = l, Xs[f] = 0, Ge.useDir && Ge.calcDirMTV()), (l >= u || !Ge.bidirectional) && (Xs[h] = -u, Xs[f] = 0, Ge.useDir && Ge.calcDirMTV())));
}
function Kb() {
  var e = 0, t = new Lt(), i = new Lt(), n = {
    minTv: new Lt(),
    maxTv: new Lt(),
    useDir: !1,
    dirMinTv: new Lt(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, s) {
      n.touchThreshold = 0, a && a.touchThreshold != null && (n.touchThreshold = Ba(0, a.touchThreshold)), n.negativeSize = !1, s && (n.minTv.set(1 / 0, 1 / 0), n.maxTv.set(0, 0), n.useDir = !1, a && a.direction != null && (n.useDir = !0, n.dirMinTv.copy(n.minTv), i.copy(n.minTv), e = a.direction, n.bidirectional = a.bidirectional == null || !!a.bidirectional, n.bidirectional || t.set(Math.cos(e), Math.sin(e))));
    },
    calcDirMTV: function() {
      var a = n.minTv, s = n.dirMinTv, o = a.y * a.y + a.x * a.x, l = Math.sin(e), u = Math.cos(e), c = l * a.y + u * a.x;
      if (r(c)) {
        r(a.x) && r(a.y) && s.set(0, 0);
        return;
      }
      if (i.x = o * u / c, i.y = o * l / c, r(i.x) && r(i.y)) {
        s.set(0, 0);
        return;
      }
      (n.bidirectional || t.dot(i) > 0) && i.len() < s.len() && s.copy(i);
    }
  };
  function r(a) {
    return qf(a) < 1e-10;
  }
  return n;
}
var Qb = "silent";
function FA(e, t, i) {
  return {
    type: e,
    event: i,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: i.zrX,
    offsetY: i.zrY,
    gestureEvent: i.gestureEvent,
    pinchX: i.pinchX,
    pinchY: i.pinchY,
    pinchScale: i.pinchScale,
    wheelDelta: i.zrDelta,
    zrByTouch: i.zrByTouch,
    which: i.which,
    stop: BA
  };
}
function BA() {
  Mu(this.event);
}
var zA = (function(e) {
  At(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.handler = null, i;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
})(ki), xs = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.x = t, this.y = i;
  }
  return e;
})(), VA = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], dh = new at(0, 0, 0, 0), Jb = (function(e) {
  At(t, e);
  function t(i, n, r, a, s) {
    var o = e.call(this) || this;
    return o._hovered = new xs(0, 0), o.storage = i, o.painter = n, o.painterRoot = a, o._pointerSize = s, r = r || new zA(), o.proxy = null, o.setHandlerProxy(r), o._draggingMgr = new yA(o), o;
  }
  return t.prototype.setHandlerProxy = function(i) {
    this.proxy && this.proxy.dispose(), i && (k(VA, function(n) {
      i.on && i.on(n, this[n], this);
    }, this), i.handler = this), this.proxy = i;
  }, t.prototype.mousemove = function(i) {
    var n = i.zrX, r = i.zrY, a = t1(this, n, r), s = this._hovered, o = s.target;
    o && !o.__zr && (s = this.findHover(s.x, s.y), o = s.target);
    var l = this._hovered = a ? new xs(n, r) : this.findHover(n, r), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), o && u !== o && this.dispatchToElement(s, "mouseout", i), this.dispatchToElement(l, "mousemove", i), u && u !== o && this.dispatchToElement(l, "mouseover", i);
  }, t.prototype.mouseout = function(i) {
    var n = i.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", i), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: i });
  }, t.prototype.resize = function() {
    this._hovered = new xs(0, 0);
  }, t.prototype.dispatch = function(i, n) {
    var r = this[i];
    r && r.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(i) {
    var n = this.proxy;
    n.setCursor && n.setCursor(i);
  }, t.prototype.dispatchToElement = function(i, n, r) {
    i = i || {};
    var a = i.target;
    if (!(a && a.silent)) {
      for (var s = "on" + n, o = FA(n, i, r); a && (a[s] && (o.cancelBubble = !!a[s].call(a, o)), a.trigger(n, o), a = a.__hostTarget ? a.__hostTarget : a.parent, !o.cancelBubble); )
        ;
      o.cancelBubble || (this.trigger(n, o), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[s] == "function" && l[s].call(l, o), l.trigger && l.trigger(n, o);
      }));
    }
  }, t.prototype.findHover = function(i, n, r) {
    var a = this.storage.getDisplayList(), s = new xs(i, n);
    if (ym(a, s, i, n, r), this._pointerSize && !s.target) {
      for (var o = [], l = this._pointerSize, u = l / 2, c = new at(i - u, n - u, l, l), h = a.length - 1; h >= 0; h--) {
        var f = a[h];
        f !== r && !f.ignore && !f.ignoreCoarsePointer && (!f.parent || !f.parent.ignoreCoarsePointer) && (dh.copy(f.getBoundingRect()), f.transform && dh.applyTransform(f.transform), dh.intersect(c) && o.push(f));
      }
      if (o.length)
        for (var d = 4, v = Math.PI / 12, g = Math.PI * 2, p = 0; p < u; p += d)
          for (var m = 0; m < g; m += v) {
            var y = i + p * Math.cos(m), _ = n + p * Math.sin(m);
            if (ym(o, s, y, _, r), s.target)
              return s;
          }
    }
    return s;
  }, t.prototype.processGesture = function(i, n) {
    this._gestureMgr || (this._gestureMgr = new EA());
    var r = this._gestureMgr;
    n === "start" && r.clear();
    var a = r.recognize(i, this.findHover(i.zrX, i.zrY, null).target, this.proxy.dom);
    if (n === "end" && r.clear(), a) {
      var s = a.type;
      i.gestureEvent = s;
      var o = new xs();
      o.target = a.target, this.dispatchToElement(o, s, a.event);
    }
  }, t;
})(ki);
k(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  Jb.prototype[e] = function(t) {
    var i = t.zrX, n = t.zrY, r = t1(this, i, n), a, s;
    if ((e !== "mouseup" || !r) && (a = this.findHover(i, n), s = a.target), e === "mousedown")
      this._downEl = s, this._downPoint = [t.zrX, t.zrY], this._upEl = s;
    else if (e === "mouseup")
      this._upEl = s;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || gA(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, e, t);
  };
});
function $A(e, t, i) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, i)) {
    for (var n = e, r = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var s = n.getClipPath();
        if (s && !s.contain(t, i))
          return !1;
      }
      n.silent && (r = !0);
      var o = n.__hostTarget;
      n = o ? n.ignoreHostSilent ? null : o : n.parent;
    }
    return r ? Qb : !0;
  }
  return !1;
}
function ym(e, t, i, n, r) {
  for (var a = e.length - 1; a >= 0; a--) {
    var s = e[a], o = void 0;
    if (s !== r && !s.ignore && (o = $A(s, i, n)) && (!t.topTarget && (t.topTarget = s), o !== Qb)) {
      t.target = s;
      break;
    }
  }
}
function t1(e, t, i) {
  var n = e.painter;
  return t < 0 || t > n.getWidth() || i < 0 || i > n.getHeight();
}
var e1 = 32, ws = 7;
function HA(e) {
  for (var t = 0; e >= e1; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function _m(e, t, i, n) {
  var r = t + 1;
  if (r === i)
    return 1;
  if (n(e[r++], e[t]) < 0) {
    for (; r < i && n(e[r], e[r - 1]) < 0; )
      r++;
    YA(e, t, r);
  } else
    for (; r < i && n(e[r], e[r - 1]) >= 0; )
      r++;
  return r - t;
}
function YA(e, t, i) {
  for (i--; t < i; ) {
    var n = e[t];
    e[t++] = e[i], e[i--] = n;
  }
}
function bm(e, t, i, n, r) {
  for (n === t && n++; n < i; n++) {
    for (var a = e[n], s = t, o = n, l; s < o; )
      l = s + o >>> 1, r(a, e[l]) < 0 ? o = l : s = l + 1;
    var u = n - s;
    switch (u) {
      case 3:
        e[s + 3] = e[s + 2];
      case 2:
        e[s + 2] = e[s + 1];
      case 1:
        e[s + 1] = e[s];
        break;
      default:
        for (; u > 0; )
          e[s + u] = e[s + u - 1], u--;
    }
    e[s] = a;
  }
}
function vh(e, t, i, n, r, a) {
  var s = 0, o = 0, l = 1;
  if (a(e, t[i + r]) > 0) {
    for (o = n - r; l < o && a(e, t[i + r + l]) > 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o), s += r, l += r;
  } else {
    for (o = r + 1; l < o && a(e, t[i + r - l]) <= 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o);
    var u = s;
    s = r - l, l = r - u;
  }
  for (s++; s < l; ) {
    var c = s + (l - s >>> 1);
    a(e, t[i + c]) > 0 ? s = c + 1 : l = c;
  }
  return l;
}
function ph(e, t, i, n, r, a) {
  var s = 0, o = 0, l = 1;
  if (a(e, t[i + r]) < 0) {
    for (o = r + 1; l < o && a(e, t[i + r - l]) < 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o);
    var u = s;
    s = r - l, l = r - u;
  } else {
    for (o = n - r; l < o && a(e, t[i + r + l]) >= 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o), s += r, l += r;
  }
  for (s++; s < l; ) {
    var c = s + (l - s >>> 1);
    a(e, t[i + c]) < 0 ? l = c : s = c + 1;
  }
  return l;
}
function WA(e, t) {
  var i = ws, n, r, a = 0, s = [];
  n = [], r = [];
  function o(d, v) {
    n[a] = d, r[a] = v, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var d = a - 2;
      if (d >= 1 && r[d - 1] <= r[d] + r[d + 1] || d >= 2 && r[d - 2] <= r[d] + r[d - 1])
        r[d - 1] < r[d + 1] && d--;
      else if (r[d] > r[d + 1])
        break;
      c(d);
    }
  }
  function u() {
    for (; a > 1; ) {
      var d = a - 2;
      d > 0 && r[d - 1] < r[d + 1] && d--, c(d);
    }
  }
  function c(d) {
    var v = n[d], g = r[d], p = n[d + 1], m = r[d + 1];
    r[d] = g + m, d === a - 3 && (n[d + 1] = n[d + 2], r[d + 1] = r[d + 2]), a--;
    var y = ph(e[p], e, v, g, 0, t);
    v += y, g -= y, g !== 0 && (m = vh(e[v + g - 1], e, p, m, m - 1, t), m !== 0 && (g <= m ? h(v, g, p, m) : f(v, g, p, m)));
  }
  function h(d, v, g, p) {
    var m = 0;
    for (m = 0; m < v; m++)
      s[m] = e[d + m];
    var y = 0, _ = g, b = d;
    if (e[b++] = e[_++], --p === 0) {
      for (m = 0; m < v; m++)
        e[b + m] = s[y + m];
      return;
    }
    if (v === 1) {
      for (m = 0; m < p; m++)
        e[b + m] = e[_ + m];
      e[b + p] = s[y];
      return;
    }
    for (var x = i, w, M, T; ; ) {
      w = 0, M = 0, T = !1;
      do
        if (t(e[_], s[y]) < 0) {
          if (e[b++] = e[_++], M++, w = 0, --p === 0) {
            T = !0;
            break;
          }
        } else if (e[b++] = s[y++], w++, M = 0, --v === 1) {
          T = !0;
          break;
        }
      while ((w | M) < x);
      if (T)
        break;
      do {
        if (w = ph(e[_], s, y, v, 0, t), w !== 0) {
          for (m = 0; m < w; m++)
            e[b + m] = s[y + m];
          if (b += w, y += w, v -= w, v <= 1) {
            T = !0;
            break;
          }
        }
        if (e[b++] = e[_++], --p === 0) {
          T = !0;
          break;
        }
        if (M = vh(s[y], e, _, p, 0, t), M !== 0) {
          for (m = 0; m < M; m++)
            e[b + m] = e[_ + m];
          if (b += M, _ += M, p -= M, p === 0) {
            T = !0;
            break;
          }
        }
        if (e[b++] = s[y++], --v === 1) {
          T = !0;
          break;
        }
        x--;
      } while (w >= ws || M >= ws);
      if (T)
        break;
      x < 0 && (x = 0), x += 2;
    }
    if (i = x, i < 1 && (i = 1), v === 1) {
      for (m = 0; m < p; m++)
        e[b + m] = e[_ + m];
      e[b + p] = s[y];
    } else {
      if (v === 0)
        throw new Error();
      for (m = 0; m < v; m++)
        e[b + m] = s[y + m];
    }
  }
  function f(d, v, g, p) {
    var m = 0;
    for (m = 0; m < p; m++)
      s[m] = e[g + m];
    var y = d + v - 1, _ = p - 1, b = g + p - 1, x = 0, w = 0;
    if (e[b--] = e[y--], --v === 0) {
      for (x = b - (p - 1), m = 0; m < p; m++)
        e[x + m] = s[m];
      return;
    }
    if (p === 1) {
      for (b -= v, y -= v, w = b + 1, x = y + 1, m = v - 1; m >= 0; m--)
        e[w + m] = e[x + m];
      e[b] = s[_];
      return;
    }
    for (var M = i; ; ) {
      var T = 0, D = 0, P = !1;
      do
        if (t(s[_], e[y]) < 0) {
          if (e[b--] = e[y--], T++, D = 0, --v === 0) {
            P = !0;
            break;
          }
        } else if (e[b--] = s[_--], D++, T = 0, --p === 1) {
          P = !0;
          break;
        }
      while ((T | D) < M);
      if (P)
        break;
      do {
        if (T = v - ph(s[_], e, d, v, v - 1, t), T !== 0) {
          for (b -= T, y -= T, v -= T, w = b + 1, x = y + 1, m = T - 1; m >= 0; m--)
            e[w + m] = e[x + m];
          if (v === 0) {
            P = !0;
            break;
          }
        }
        if (e[b--] = s[_--], --p === 1) {
          P = !0;
          break;
        }
        if (D = p - vh(e[y], s, 0, p, p - 1, t), D !== 0) {
          for (b -= D, _ -= D, p -= D, w = b + 1, x = _ + 1, m = 0; m < D; m++)
            e[w + m] = s[x + m];
          if (p <= 1) {
            P = !0;
            break;
          }
        }
        if (e[b--] = e[y--], --v === 0) {
          P = !0;
          break;
        }
        M--;
      } while (T >= ws || D >= ws);
      if (P)
        break;
      M < 0 && (M = 0), M += 2;
    }
    if (i = M, i < 1 && (i = 1), p === 1) {
      for (b -= v, y -= v, w = b + 1, x = y + 1, m = v - 1; m >= 0; m--)
        e[w + m] = e[x + m];
      e[b] = s[_];
    } else {
      if (p === 0)
        throw new Error();
      for (x = b - (p - 1), m = 0; m < p; m++)
        e[x + m] = s[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: o
  };
}
function Jl(e, t, i, n) {
  i || (i = 0), n || (n = e.length);
  var r = n - i;
  if (!(r < 2)) {
    var a = 0;
    if (r < e1) {
      a = _m(e, i, n, t), bm(e, i, n, i + a, t);
      return;
    }
    var s = WA(e, t), o = HA(r);
    do {
      if (a = _m(e, i, n, t), a < o) {
        var l = r;
        l > o && (l = o), bm(e, i, i + l, i + a, t), a = l;
      }
      s.pushRun(i, a), s.mergeRuns(), r -= a, i += a;
    } while (r !== 0);
    s.forceMergeRuns();
  }
}
var Xe = 1, qs = 2, Ia = 4, xm = !1;
function gh() {
  xm || (xm = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function wm(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var UA = (function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = wm;
  }
  return e.prototype.traverse = function(t, i) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, i);
  }, e.prototype.getDisplayList = function(t, i) {
    i = i || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(i), n;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var i = this._roots, n = this._displayList, r = 0, a = i.length; r < a; r++)
      this._updateAndAddDisplayable(i[r], null, t);
    n.length = this._displayListLen, Jl(n, wm);
  }, e.prototype._updateAndAddDisplayable = function(t, i, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var r = t.getClipPath(), a = i && i.length, s = 0, o = t.__clipPaths;
      if (!t.ignoreClip && (a || r)) {
        if (o || (o = t.__clipPaths = []), a)
          for (var l = 0; l < i.length; l++)
            o[s++] = i[l];
        for (var u = r, c = t; u; )
          u.parent = c, u.updateTransform(), o[s++] = u, c = u, u = u.getClipPath();
      }
      if (o && (o.length = s), t.childrenRef) {
        for (var h = t.childrenRef(), f = 0; f < h.length; f++) {
          var d = h[f];
          t.__dirty && (d.__dirty |= Xe), this._updateAndAddDisplayable(d, o, n);
        }
        t.__dirty = 0;
      } else {
        var v = t;
        isNaN(v.z) && (gh(), v.z = 0), isNaN(v.z2) && (gh(), v.z2 = 0), isNaN(v.zlevel) && (gh(), v.zlevel = 0), this._displayList[this._displayListLen++] = v;
      }
      var g = t.getDecalElement && t.getDecalElement();
      g && this._updateAndAddDisplayable(g, o, n);
      var p = t.getTextGuideLine();
      p && this._updateAndAddDisplayable(p, o, n);
      var m = t.getTextContent();
      m && this._updateAndAddDisplayable(m, o, n);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var i = 0, n = t.length; i < n; i++)
        this.delRoot(t[i]);
      return;
    }
    var r = Bt(this._roots, t);
    r >= 0 && this._roots.splice(r, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
})(), Tu;
Tu = rt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var co = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - co.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? co.bounceIn(e * 2) * 0.5 : co.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, dl = Math.pow, Gn = Math.sqrt, Du = 1e-8, i1 = 1e-4, Sm = Gn(3), vl = 1 / 3, Vi = cs(), si = cs(), Ga = cs();
function $n(e) {
  return e > -Du && e < Du;
}
function n1(e) {
  return e > Du || e < -Du;
}
function Pe(e, t, i, n, r) {
  var a = 1 - r;
  return a * a * (a * e + 3 * r * t) + r * r * (r * n + 3 * a * i);
}
function Mm(e, t, i, n, r) {
  var a = 1 - r;
  return 3 * (((t - e) * a + 2 * (i - t) * r) * a + (n - i) * r * r);
}
function r1(e, t, i, n, r, a) {
  var s = n + 3 * (t - i) - e, o = 3 * (i - t * 2 + e), l = 3 * (t - e), u = e - r, c = o * o - 3 * s * l, h = o * l - 9 * s * u, f = l * l - 3 * o * u, d = 0;
  if ($n(c) && $n(h))
    if ($n(o))
      a[0] = 0;
    else {
      var v = -l / o;
      v >= 0 && v <= 1 && (a[d++] = v);
    }
  else {
    var g = h * h - 4 * c * f;
    if ($n(g)) {
      var p = h / c, v = -o / s + p, m = -p / 2;
      v >= 0 && v <= 1 && (a[d++] = v), m >= 0 && m <= 1 && (a[d++] = m);
    } else if (g > 0) {
      var y = Gn(g), _ = c * o + 1.5 * s * (-h + y), b = c * o + 1.5 * s * (-h - y);
      _ < 0 ? _ = -dl(-_, vl) : _ = dl(_, vl), b < 0 ? b = -dl(-b, vl) : b = dl(b, vl);
      var v = (-o - (_ + b)) / (3 * s);
      v >= 0 && v <= 1 && (a[d++] = v);
    } else {
      var x = (2 * c * o - 3 * s * h) / (2 * Gn(c * c * c)), w = Math.acos(x) / 3, M = Gn(c), T = Math.cos(w), v = (-o - 2 * M * T) / (3 * s), m = (-o + M * (T + Sm * Math.sin(w))) / (3 * s), D = (-o + M * (T - Sm * Math.sin(w))) / (3 * s);
      v >= 0 && v <= 1 && (a[d++] = v), m >= 0 && m <= 1 && (a[d++] = m), D >= 0 && D <= 1 && (a[d++] = D);
    }
  }
  return d;
}
function a1(e, t, i, n, r) {
  var a = 6 * i - 12 * t + 6 * e, s = 9 * t + 3 * n - 3 * e - 9 * i, o = 3 * t - 3 * e, l = 0;
  if ($n(s)) {
    if (n1(a)) {
      var u = -o / a;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = a * a - 4 * s * o;
    if ($n(c))
      r[0] = -a / (2 * s);
    else if (c > 0) {
      var h = Gn(c), u = (-a + h) / (2 * s), f = (-a - h) / (2 * s);
      u >= 0 && u <= 1 && (r[l++] = u), f >= 0 && f <= 1 && (r[l++] = f);
    }
  }
  return l;
}
function Cu(e, t, i, n, r, a) {
  var s = (t - e) * r + e, o = (i - t) * r + t, l = (n - i) * r + i, u = (o - s) * r + s, c = (l - o) * r + o, h = (c - u) * r + u;
  a[0] = e, a[1] = s, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n;
}
function GA(e, t, i, n, r, a, s, o, l, u, c) {
  var h, f = 5e-3, d = 1 / 0, v, g, p, m;
  Vi[0] = l, Vi[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    si[0] = Pe(e, i, r, s, y), si[1] = Pe(t, n, a, o, y), p = Ua(Vi, si), p < d && (h = y, d = p);
  d = 1 / 0;
  for (var _ = 0; _ < 32 && !(f < i1); _++)
    v = h - f, g = h + f, si[0] = Pe(e, i, r, s, v), si[1] = Pe(t, n, a, o, v), p = Ua(si, Vi), v >= 0 && p < d ? (h = v, d = p) : (Ga[0] = Pe(e, i, r, s, g), Ga[1] = Pe(t, n, a, o, g), m = Ua(Ga, Vi), g <= 1 && m < d ? (h = g, d = m) : f *= 0.5);
  return Gn(d);
}
function jA(e, t, i, n, r, a, s, o, l) {
  for (var u = e, c = t, h = 0, f = 1 / l, d = 1; d <= l; d++) {
    var v = d * f, g = Pe(e, i, r, s, v), p = Pe(t, n, a, o, v), m = g - u, y = p - c;
    h += Math.sqrt(m * m + y * y), u = g, c = p;
  }
  return h;
}
function Be(e, t, i, n) {
  var r = 1 - n;
  return r * (r * e + 2 * n * t) + n * n * i;
}
function Tm(e, t, i, n) {
  return 2 * ((1 - n) * (t - e) + n * (i - t));
}
function XA(e, t, i, n, r) {
  var a = e - 2 * t + i, s = 2 * (t - e), o = e - n, l = 0;
  if ($n(a)) {
    if (n1(s)) {
      var u = -o / s;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = s * s - 4 * a * o;
    if ($n(c)) {
      var u = -s / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u);
    } else if (c > 0) {
      var h = Gn(c), u = (-s + h) / (2 * a), f = (-s - h) / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u), f >= 0 && f <= 1 && (r[l++] = f);
    }
  }
  return l;
}
function s1(e, t, i) {
  var n = e + i - 2 * t;
  return n === 0 ? 0.5 : (e - t) / n;
}
function ku(e, t, i, n, r) {
  var a = (t - e) * n + e, s = (i - t) * n + t, o = (s - a) * n + a;
  r[0] = e, r[1] = a, r[2] = o, r[3] = o, r[4] = s, r[5] = i;
}
function qA(e, t, i, n, r, a, s, o, l) {
  var u, c = 5e-3, h = 1 / 0;
  Vi[0] = s, Vi[1] = o;
  for (var f = 0; f < 1; f += 0.05) {
    si[0] = Be(e, i, r, f), si[1] = Be(t, n, a, f);
    var d = Ua(Vi, si);
    d < h && (u = f, h = d);
  }
  h = 1 / 0;
  for (var v = 0; v < 32 && !(c < i1); v++) {
    var g = u - c, p = u + c;
    si[0] = Be(e, i, r, g), si[1] = Be(t, n, a, g);
    var d = Ua(si, Vi);
    if (g >= 0 && d < h)
      u = g, h = d;
    else {
      Ga[0] = Be(e, i, r, p), Ga[1] = Be(t, n, a, p);
      var m = Ua(Ga, Vi);
      p <= 1 && m < h ? (u = p, h = m) : c *= 0.5;
    }
  }
  return Gn(h);
}
function ZA(e, t, i, n, r, a, s) {
  for (var o = e, l = t, u = 0, c = 1 / s, h = 1; h <= s; h++) {
    var f = h * c, d = Be(e, i, r, f), v = Be(t, n, a, f), g = d - o, p = v - l;
    u += Math.sqrt(g * g + p * p), o = d, l = v;
  }
  return u;
}
var KA = /cubic-bezier\(([0-9,\.e ]+)\)/;
function o1(e) {
  var t = e && KA.exec(e);
  if (t) {
    var i = t[1].split(","), n = +Hi(i[0]), r = +Hi(i[1]), a = +Hi(i[2]), s = +Hi(i[3]);
    if (isNaN(n + r + a + s))
      return;
    var o = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : r1(0, n, a, 1, l, o) && Pe(0, r, s, 1, o[0]);
    };
  }
}
var QA = (function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || be, this.ondestroy = t.ondestroy || be, this.onrestart = t.onrestart || be, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, i) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += i;
      return;
    }
    var n = this._life, r = t - this._startTime - this._pausedTime, a = r / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var s = this.easingFunc, o = s ? s(a) : a;
    if (this.onframe(o), a === 1)
      if (this.loop) {
        var l = r % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = mt(t) ? t : co[t] || o1(t);
  }, e;
})(), l1 = /* @__PURE__ */ (function() {
  function e(t) {
    this.value = t;
  }
  return e;
})(), JA = (function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var i = new l1(t);
    return this.insertEntry(i), i;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var i = t.prev, n = t.next;
    i ? i.next = n : this.head = n, n ? n.prev = i : this.tail = i, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
})(), es = (function() {
  function e(t) {
    this._list = new JA(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, i) {
    var n = this._list, r = this._map, a = null;
    if (r[t] == null) {
      var s = n.len(), o = this._lastRemovedEntry;
      if (s >= this._maxSize && s > 0) {
        var l = n.head;
        n.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      o ? o.value = i : o = new l1(i), o.key = t, n.insertEntry(o), r[t] = o;
    }
    return a;
  }, e.prototype.get = function(t) {
    var i = this._map[t], n = this._list;
    if (i != null)
      return i !== n.tail && (n.remove(i), n.insertEntry(i)), i.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
})(), Dm = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function jn(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function tE(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function Pu(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function mh(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? jn(parseFloat(t) / 100 * 255) : jn(parseInt(t, 10));
}
function qr(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Pu(parseFloat(t) / 100) : Pu(parseFloat(t));
}
function yh(e, t, i) {
  return i < 0 ? i += 1 : i > 1 && (i -= 1), i * 6 < 1 ? e + (t - e) * i * 6 : i * 2 < 1 ? t : i * 3 < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e;
}
function pl(e, t, i) {
  return e + (t - e) * i;
}
function ii(e, t, i, n, r) {
  return e[0] = t, e[1] = i, e[2] = n, e[3] = r, e;
}
function Kf(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var u1 = new es(20), gl = null;
function ga(e, t) {
  gl && Kf(gl, t), gl = u1.put(e, gl || t.slice());
}
function yn(e, t) {
  if (e) {
    t = t || [];
    var i = u1.get(e);
    if (i)
      return Kf(t, i);
    e = e + "";
    var n = e.replace(/ /g, "").toLowerCase();
    if (n in Dm)
      return Kf(t, Dm[n]), ga(e, t), t;
    var r = n.length;
    if (n.charAt(0) === "#") {
      if (r === 4 || r === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          ii(t, 0, 0, 0, 1);
          return;
        }
        return ii(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(n.slice(4), 16) / 15 : 1), ga(e, t), t;
      } else if (r === 7 || r === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          ii(t, 0, 0, 0, 1);
          return;
        }
        return ii(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(n.slice(7), 16) / 255 : 1), ga(e, t), t;
      }
      return;
    }
    var s = n.indexOf("("), o = n.indexOf(")");
    if (s !== -1 && o + 1 === r) {
      var l = n.substr(0, s), u = n.substr(s + 1, o - (s + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? ii(t, +u[0], +u[1], +u[2], 1) : ii(t, 0, 0, 0, 1);
          c = qr(u.pop());
        case "rgb":
          if (u.length >= 3)
            return ii(t, mh(u[0]), mh(u[1]), mh(u[2]), u.length === 3 ? c : qr(u[3])), ga(e, t), t;
          ii(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            ii(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = qr(u[3]), Qf(u, t), ga(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            ii(t, 0, 0, 0, 1);
            return;
          }
          return Qf(u, t), ga(e, t), t;
        default:
          return;
      }
    }
    ii(t, 0, 0, 0, 1);
  }
}
function Qf(e, t) {
  var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = qr(e[1]), r = qr(e[2]), a = r <= 0.5 ? r * (n + 1) : r + n - r * n, s = r * 2 - a;
  return t = t || [], ii(t, jn(yh(s, a, i + 1 / 3) * 255), jn(yh(s, a, i) * 255), jn(yh(s, a, i - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function eE(e) {
  if (e) {
    var t = e[0] / 255, i = e[1] / 255, n = e[2] / 255, r = Math.min(t, i, n), a = Math.max(t, i, n), s = a - r, o = (a + r) / 2, l, u;
    if (s === 0)
      l = 0, u = 0;
    else {
      o < 0.5 ? u = s / (a + r) : u = s / (2 - a - r);
      var c = ((a - t) / 6 + s / 2) / s, h = ((a - i) / 6 + s / 2) / s, f = ((a - n) / 6 + s / 2) / s;
      t === a ? l = f - h : i === a ? l = 1 / 3 + c - f : n === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var d = [l * 360, u, o];
    return e[3] != null && d.push(e[3]), d;
  }
}
function Cm(e, t) {
  var i = yn(e);
  if (i) {
    for (var n = 0; n < 3; n++)
      i[n] = i[n] * (1 - t) | 0, i[n] > 255 ? i[n] = 255 : i[n] < 0 && (i[n] = 0);
    return Zr(i, i.length === 4 ? "rgba" : "rgb");
  }
}
function _h(e, t, i) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    i = i || [];
    var n = e * (t.length - 1), r = Math.floor(n), a = Math.ceil(n), s = t[r], o = t[a], l = n - r;
    return i[0] = jn(pl(s[0], o[0], l)), i[1] = jn(pl(s[1], o[1], l)), i[2] = jn(pl(s[2], o[2], l)), i[3] = Pu(pl(s[3], o[3], l)), i;
  }
}
function ja(e, t, i, n) {
  var r = yn(e);
  if (e)
    return r = eE(r), t != null && (r[0] = tE(mt(t) ? t(r[0]) : t)), i != null && (r[1] = qr(mt(i) ? i(r[1]) : i)), n != null && (r[2] = qr(mt(n) ? n(r[2]) : n)), Zr(Qf(r), "rgba");
}
function iE(e, t) {
  var i = yn(e);
  if (i && t != null)
    return i[3] = Pu(t), Zr(i, "rgba");
}
function Zr(e, t) {
  if (!(!e || !e.length)) {
    var i = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (i += "," + e[3]), t + "(" + i + ")";
  }
}
function Au(e, t) {
  var i = yn(e);
  return i ? (0.299 * i[0] + 0.587 * i[1] + 0.114 * i[2]) * i[3] / 255 + (1 - i[3]) * t : 0;
}
var km = new es(100);
function Pm(e) {
  if (Q(e)) {
    var t = km.get(e);
    return t || (t = Cm(e, -0.1), km.put(e, t)), t;
  } else if (bc(e)) {
    var i = Y({}, e);
    return i.colorStops = bt(e.colorStops, function(n) {
      return {
        offset: n.offset,
        color: Cm(n.color, -0.1)
      };
    }), i;
  }
  return e;
}
function nE(e) {
  return e.type === "linear";
}
function rE(e) {
  return e.type === "radial";
}
(function() {
  return rt.hasGlobalWindow && mt(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && jr("Base64 isn't natively supported in the current environment."), null;
  };
})();
var Jf = Array.prototype.slice;
function un(e, t, i) {
  return (t - e) * i + e;
}
function bh(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = un(t[a], i[a], n);
  return e;
}
function aE(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, s = 0; s < r; s++) {
    e[s] || (e[s] = []);
    for (var o = 0; o < a; o++)
      e[s][o] = un(t[s][o], i[s][o], n);
  }
  return e;
}
function ml(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = t[a] + i[a] * n;
  return e;
}
function Am(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, s = 0; s < r; s++) {
    e[s] || (e[s] = []);
    for (var o = 0; o < a; o++)
      e[s][o] = t[s][o] + i[s][o] * n;
  }
  return e;
}
function sE(e, t) {
  for (var i = e.length, n = t.length, r = i > n ? t : e, a = Math.min(i, n), s = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, o = a; o < Math.max(i, n); o++)
    r.push({
      offset: s.offset,
      color: s.color.slice()
    });
}
function oE(e, t, i) {
  var n = e, r = t;
  if (!(!n.push || !r.push)) {
    var a = n.length, s = r.length;
    if (a !== s) {
      var o = a > s;
      if (o)
        n.length = s;
      else
        for (var l = a; l < s; l++)
          n.push(i === 1 ? r[l] : Jf.call(r[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (i === 1)
        isNaN(n[l]) && (n[l] = r[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = r[l][c]);
  }
}
function tu(e) {
  if (Ye(e)) {
    var t = e.length;
    if (Ye(e[0])) {
      for (var i = [], n = 0; n < t; n++)
        i.push(Jf.call(e[n]));
      return i;
    }
    return Jf.call(e);
  }
  return e;
}
function eu(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function lE(e) {
  return Ye(e && e[0]) ? 2 : 1;
}
var yl = 0, iu = 1, c1 = 2, Zs = 3, td = 4, ed = 5, Em = 6;
function Lm(e) {
  return e === td || e === ed;
}
function _l(e) {
  return e === iu || e === c1;
}
var Ss = [0, 0, 0, 0], uE = (function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, i, n) {
    this._needsSort = !0;
    var r = this.keyframes, a = r.length, s = !1, o = Em, l = i;
    if (Ye(i)) {
      var u = lE(i);
      o = u, (u === 1 && !Xt(i[0]) || u === 2 && !Xt(i[0][0])) && (s = !0);
    } else if (Xt(i) && !Gb(i))
      o = yl;
    else if (Q(i))
      if (!isNaN(+i))
        o = yl;
      else {
        var c = yn(i);
        c && (l = c, o = Zs);
      }
    else if (bc(i)) {
      var h = Y({}, l);
      h.colorStops = bt(i.colorStops, function(d) {
        return {
          offset: d.offset,
          color: yn(d.color)
        };
      }), nE(i) ? o = td : rE(i) && (o = ed), l = h;
    }
    a === 0 ? this.valType = o : (o !== this.valType || o === Em) && (s = !0), this.discrete = this.discrete || s;
    var f = {
      time: t,
      value: l,
      rawValue: i,
      percent: 0
    };
    return n && (f.easing = n, f.easingFunc = mt(n) ? n : co[n] || o1(n)), r.push(f), f;
  }, e.prototype.prepare = function(t, i) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(g, p) {
      return g.time - p.time;
    });
    for (var r = this.valType, a = n.length, s = n[a - 1], o = this.discrete, l = _l(r), u = Lm(r), c = 0; c < a; c++) {
      var h = n[c], f = h.value, d = s.value;
      h.percent = h.time / t, o || (l && c !== a - 1 ? oE(f, d, r) : u && sE(f.colorStops, d.colorStops));
    }
    if (!o && r !== ed && i && this.needsAnimate() && i.needsAnimate() && r === i.valType && !i._finished) {
      this._additiveTrack = i;
      for (var v = n[0].value, c = 0; c < a; c++)
        r === yl ? n[c].additiveValue = n[c].value - v : r === Zs ? n[c].additiveValue = ml([], n[c].value, v, -1) : _l(r) && (n[c].additiveValue = r === iu ? ml([], n[c].value, v, -1) : Am([], n[c].value, v, -1));
    }
  }, e.prototype.step = function(t, i) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, r = n ? "additiveValue" : "value", a = this.valType, s = this.keyframes, o = s.length, l = this.propName, u = a === Zs, c, h = this._lastFr, f = Math.min, d, v;
      if (o === 1)
        d = v = s[0];
      else {
        if (i < 0)
          c = 0;
        else if (i < this._lastFrP) {
          var g = f(h + 1, o - 1);
          for (c = g; c >= 0 && !(s[c].percent <= i); c--)
            ;
          c = f(c, o - 2);
        } else {
          for (c = h; c < o && !(s[c].percent > i); c++)
            ;
          c = f(c - 1, o - 2);
        }
        v = s[c + 1], d = s[c];
      }
      if (d && v) {
        this._lastFr = c, this._lastFrP = i;
        var p = v.percent - d.percent, m = p === 0 ? 1 : f((i - d.percent) / p, 1);
        v.easingFunc && (m = v.easingFunc(m));
        var y = n ? this._additiveValue : u ? Ss : t[l];
        if ((_l(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = m < 1 ? d.rawValue : v.rawValue;
        else if (_l(a))
          a === iu ? bh(y, d[r], v[r], m) : aE(y, d[r], v[r], m);
        else if (Lm(a)) {
          var _ = d[r], b = v[r], x = a === td;
          t[l] = {
            type: x ? "linear" : "radial",
            x: un(_.x, b.x, m),
            y: un(_.y, b.y, m),
            colorStops: bt(_.colorStops, function(M, T) {
              var D = b.colorStops[T];
              return {
                offset: un(M.offset, D.offset, m),
                color: eu(bh([], M.color, D.color, m))
              };
            }),
            global: b.global
          }, x ? (t[l].x2 = un(_.x2, b.x2, m), t[l].y2 = un(_.y2, b.y2, m)) : t[l].r = un(_.r, b.r, m);
        } else if (u)
          bh(y, d[r], v[r], m), n || (t[l] = eu(y));
        else {
          var w = un(d[r], v[r], m);
          n ? this._additiveValue = w : t[l] = w;
        }
        n && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var i = this.valType, n = this.propName, r = this._additiveValue;
    i === yl ? t[n] = t[n] + r : i === Zs ? (yn(t[n], Ss), ml(Ss, Ss, r, 1), t[n] = eu(Ss)) : i === iu ? ml(t[n], t[n], r, 1) : i === c1 && Am(t[n], t[n], r, 1);
  }, e;
})(), Mv = (function() {
  function e(t, i, n, r) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = i, i && r) {
      jr("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = r, this._allowDiscrete = n;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, i, n) {
    return this.whenWithKeys(t, i, jt(i), n);
  }, e.prototype.whenWithKeys = function(t, i, n, r) {
    for (var a = this._tracks, s = 0; s < n.length; s++) {
      var o = n[s], l = a[o];
      if (!l) {
        l = a[o] = new uE(o);
        var u = void 0, c = this._getAdditiveTrack(o);
        if (c) {
          var h = c.keyframes, f = h[h.length - 1];
          u = f && f.value, c.valType === Zs && u && (u = eu(u));
        } else
          u = this._target[o];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, tu(u), r), this._trackKeys.push(o);
      }
      l.addKeyframe(t, tu(i[o]), r);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var i = t.length, n = 0; n < i; n++)
        t[n].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, i = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, i)
      for (var n = 0; n < i.length; n++)
        i[n].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, i = this._trackKeys, n = 0; n < i.length; n++)
      t[i[n]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var i, n = this._additiveAnimators;
    if (n)
      for (var r = 0; r < n.length; r++) {
        var a = n[r].getTrack(t);
        a && (i = a);
      }
    return i;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var i = this, n = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var s = this._trackKeys[a], o = this._tracks[s], l = this._getAdditiveTrack(s), u = o.keyframes, c = u.length;
        if (o.prepare(r, l), o.needsAnimate())
          if (!this._allowDiscrete && o.discrete) {
            var h = u[c - 1];
            h && (i._target[o.propName] = h.rawValue), o.setFinished();
          } else
            n.push(o);
      }
      if (n.length || this._force) {
        var f = new QA({
          life: r,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(d) {
            i._started = 2;
            var v = i._additiveAnimators;
            if (v) {
              for (var g = !1, p = 0; p < v.length; p++)
                if (v[p]._clip) {
                  g = !0;
                  break;
                }
              g || (i._additiveAnimators = null);
            }
            for (var p = 0; p < n.length; p++)
              n[p].step(i._target, d);
            var m = i._onframeCbs;
            if (m)
              for (var p = 0; p < m.length; p++)
                m[p](i._target, d);
          },
          ondestroy: function() {
            i._doneCallback();
          }
        });
        this._clip = f, this.animation && this.animation.addClip(f), t && f.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var i = this._clip;
      t && i.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return bt(this._trackKeys, function(i) {
      return t._tracks[i];
    });
  }, e.prototype.stopTracks = function(t, i) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
      var s = n[t[a]];
      s && !s.isFinished() && (i ? s.step(this._target, 1) : this._started === 1 && s.step(this._target, 0), s.setFinished());
    }
    for (var o = !0, a = 0; a < r.length; a++)
      if (!n[r[a]].isFinished()) {
        o = !1;
        break;
      }
    return o && this._abortedCallback(), o;
  }, e.prototype.saveTo = function(t, i, n) {
    if (t) {
      i = i || this._trackKeys;
      for (var r = 0; r < i.length; r++) {
        var a = i[r], s = this._tracks[a];
        if (!(!s || s.isFinished())) {
          var o = s.keyframes, l = o[n ? 0 : o.length - 1];
          l && (t[a] = tu(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, i) {
    i = i || jt(t);
    for (var n = 0; n < i.length; n++) {
      var r = i[n], a = this._tracks[r];
      if (a) {
        var s = a.keyframes;
        if (s.length > 1) {
          var o = s.pop();
          a.addKeyframe(o.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, e;
})();
function za() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var cE = (function(e) {
  At(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, i = i || {}, n.stage = i.stage || {}, n;
  }
  return t.prototype.addClip = function(i) {
    i.animation && this.removeClip(i), this._head ? (this._tail.next = i, i.prev = this._tail, i.next = null, this._tail = i) : this._head = this._tail = i, i.animation = this;
  }, t.prototype.addAnimator = function(i) {
    i.animation = this;
    var n = i.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(i) {
    if (i.animation) {
      var n = i.prev, r = i.next;
      n ? n.next = r : this._head = r, r ? r.prev = n : this._tail = n, i.next = i.prev = i.animation = null;
    }
  }, t.prototype.removeAnimator = function(i) {
    var n = i.getClip();
    n && this.removeClip(n), i.animation = null;
  }, t.prototype.update = function(i) {
    for (var n = za() - this._pausedTime, r = n - this._time, a = this._head; a; ) {
      var s = a.next, o = a.step(n, r);
      o && (a.ondestroy(), this.removeClip(a)), a = s;
    }
    this._time = n, i || (this.trigger("frame", r), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var i = this;
    this._running = !0;
    function n() {
      i._running && (Tu(n), !i._paused && i.update());
    }
    Tu(n);
  }, t.prototype.start = function() {
    this._running || (this._time = za(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = za(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += za() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var i = this._head; i; ) {
      var n = i.next;
      i.prev = i.next = i.animation = null, i = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(i, n) {
    n = n || {}, this.start();
    var r = new Mv(i, n.loop);
    return this.addAnimator(r), r;
  }, t;
})(ki), hE = 300, xh = rt.domSupported, wh = (function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], i = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = bt(e, function(r) {
    var a = r.replace("mouse", "pointer");
    return i.hasOwnProperty(a) ? a : r;
  });
  return {
    mouse: e,
    touch: t,
    pointer: n
  };
})(), Om = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, Im = !1;
function id(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function fE(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function Sh(e) {
  e && (e.zrByTouch = !0);
}
function dE(e, t) {
  return ni(e.dom, new vE(e, t), !0);
}
function h1(e, t) {
  for (var i = t, n = !1; i && i.nodeType !== 9 && !(n = i.domBelongToZr || i !== t && i === e.painterRoot); )
    i = i.parentNode;
  return n;
}
var vE = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.stopPropagation = be, this.stopImmediatePropagation = be, this.preventDefault = be, this.type = i.type, this.target = this.currentTarget = t.dom, this.pointerType = i.pointerType, this.clientX = i.clientX, this.clientY = i.clientY;
  }
  return e;
})(), yi = {
  mousedown: function(e) {
    e = ni(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = ni(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = ni(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = ni(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    h1(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    Im = !0, e = ni(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    Im || (e = ni(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = ni(this.dom, e), Sh(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), yi.mousemove.call(this, e), yi.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = ni(this.dom, e), Sh(e), this.handler.processGesture(e, "change"), yi.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = ni(this.dom, e), Sh(e), this.handler.processGesture(e, "end"), yi.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < hE && yi.click.call(this, e);
  },
  pointerdown: function(e) {
    yi.mousedown.call(this, e);
  },
  pointermove: function(e) {
    id(e) || yi.mousemove.call(this, e);
  },
  pointerup: function(e) {
    yi.mouseup.call(this, e);
  },
  pointerout: function(e) {
    id(e) || yi.mouseout.call(this, e);
  }
};
k(["click", "dblclick", "contextmenu"], function(e) {
  yi[e] = function(t) {
    t = ni(this.dom, t), this.trigger(e, t);
  };
});
var nd = {
  pointermove: function(e) {
    id(e) || nd.mousemove.call(this, e);
  },
  pointerup: function(e) {
    nd.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function pE(e, t) {
  var i = t.domHandlers;
  rt.pointerEventsSupported ? k(wh.pointer, function(n) {
    nu(t, n, function(r) {
      i[n].call(e, r);
    });
  }) : (rt.touchEventsSupported && k(wh.touch, function(n) {
    nu(t, n, function(r) {
      i[n].call(e, r), fE(t);
    });
  }), k(wh.mouse, function(n) {
    nu(t, n, function(r) {
      r = bv(r), t.touching || i[n].call(e, r);
    });
  }));
}
function gE(e, t) {
  rt.pointerEventsSupported ? k(Om.pointer, i) : rt.touchEventsSupported || k(Om.mouse, i);
  function i(n) {
    function r(a) {
      a = bv(a), h1(e, a.target) || (a = dE(e, a), t.domHandlers[n].call(e, a));
    }
    nu(t, n, r, { capture: !0 });
  }
}
function nu(e, t, i, n) {
  e.mounted[t] = i, e.listenerOpts[t] = n, PA(e.domTarget, t, i, n);
}
function Mh(e) {
  var t = e.mounted;
  for (var i in t)
    t.hasOwnProperty(i) && AA(e.domTarget, i, t[i], e.listenerOpts[i]);
  e.mounted = {};
}
var Rm = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = i;
  }
  return e;
})(), mE = (function(e) {
  At(t, e);
  function t(i, n) {
    var r = e.call(this) || this;
    return r.__pointerCapturing = !1, r.dom = i, r.painterRoot = n, r._localHandlerScope = new Rm(i, yi), xh && (r._globalHandlerScope = new Rm(document, nd)), pE(r, r._localHandlerScope), r;
  }
  return t.prototype.dispose = function() {
    Mh(this._localHandlerScope), xh && Mh(this._globalHandlerScope);
  }, t.prototype.setCursor = function(i) {
    this.dom.style && (this.dom.style.cursor = i || "default");
  }, t.prototype.__togglePointerCapture = function(i) {
    if (this.__mayPointerCapture = null, xh && +this.__pointerCapturing ^ +i) {
      this.__pointerCapturing = i;
      var n = this._globalHandlerScope;
      i ? gE(this, n) : Mh(n);
    }
  }, t;
})(ki), f1 = 1;
rt.hasGlobalWindow && (f1 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Eu = f1, rd = 0.4, ad = "#333", sd = "#ccc", yE = "#eee", Nm = xv, Fm = 5e-5;
function fr(e) {
  return e > Fm || e < -Fm;
}
var dr = [], ma = [], Th = Gi(), Dh = Math.abs, Vr = (function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return fr(this.rotation) || fr(this.x) || fr(this.y) || fr(this.scaleX - 1) || fr(this.scaleY - 1) || fr(this.skewX) || fr(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, i = this.needLocalTransform(), n = this.transform;
    if (!(i || t)) {
      n && (Nm(n), this.invTransform = null);
      return;
    }
    n = n || Gi(), i ? this.getLocalTransform(n) : Nm(n), t && (i ? lo(n, t, n) : wv(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var i = this.globalScaleRatio;
    if (i != null && i !== 1) {
      this.getGlobalScale(dr);
      var n = dr[0] < 0 ? -1 : 1, r = dr[1] < 0 ? -1 : 1, a = ((dr[0] - n) * i + n) / dr[0] || 0, s = ((dr[1] - r) * i + r) / dr[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= s, t[3] *= s;
    }
    this.invTransform = this.invTransform || Gi(), Wo(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, i = []; t; )
      i.push(t), t = t.parent;
    for (; t = i.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var i = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(a), i = Math.sqrt(i), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = i, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, i = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || Gi(), lo(ma, t.invTransform, i), i = ma);
      var n = this.originX, r = this.originY;
      (n || r) && (Th[4] = n, Th[5] = r, lo(ma, i, Th), ma[4] -= n, ma[5] -= r, i = ma), this.setLocalTransform(i);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var i = this.transform;
    return t = t || [], i ? (t[0] = Math.sqrt(i[0] * i[0] + i[1] * i[1]), t[1] = Math.sqrt(i[2] * i[2] + i[3] * i[3]), i[0] < 0 && (t[0] = -t[0]), i[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, i) {
    var n = [t, i], r = this.invTransform;
    return r && qe(n, n, r), n;
  }, e.prototype.transformCoordToGlobal = function(t, i) {
    var n = [t, i], r = this.transform;
    return r && qe(n, n, r), n;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Dh(t[0] - 1) > 1e-10 && Dh(t[3] - 1) > 1e-10 ? Math.sqrt(Dh(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    od(this, t);
  }, e.getLocalTransform = function(t, i) {
    i = i || [];
    var n = t.originX || 0, r = t.originY || 0, a = t.scaleX, s = t.scaleY, o = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, h = t.y, f = t.skewX ? Math.tan(t.skewX) : 0, d = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || r || o || l) {
      var v = n + o, g = r + l;
      i[4] = -v * a - f * g * s, i[5] = -g * s - d * v * a;
    } else
      i[4] = i[5] = 0;
    return i[0] = a, i[3] = s, i[1] = d * a, i[2] = f * s, u && Sv(i, i, u), i[4] += n + c, i[5] += r + h, i;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  })(), e;
})(), Do = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function od(e, t) {
  for (var i = 0; i < Do.length; i++) {
    var n = Do[i];
    e[n] = t[n];
  }
}
function ji(e) {
  bl || (bl = new es(100)), e = e || Qn;
  var t = bl.get(e);
  return t || (t = {
    font: e,
    strWidthCache: new es(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: wn.measureText("", e).width,
    asciiCharWidth: wn.measureText("a", e).width
  }, bl.put(e, t)), t;
}
var bl;
function _E(e) {
  if (!(Ch >= Bm)) {
    e = e || Qn;
    for (var t = [], i = +/* @__PURE__ */ new Date(), n = 0; n <= 127; n++)
      t[n] = wn.measureText(String.fromCharCode(n), e).width;
    var r = +/* @__PURE__ */ new Date() - i;
    return r > 16 ? Ch = Bm : r > 2 && Ch++, t;
  }
}
var Ch = 0, Bm = 5;
function d1(e, t) {
  return e.asciiWidthMapTried || (e.asciiWidthMap = _E(e.font), e.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? e.asciiWidthMap != null ? e.asciiWidthMap[t] : e.asciiCharWidth : e.stWideCharWidth;
}
function Xi(e, t) {
  var i = e.strWidthCache, n = i.get(t);
  return n == null && (n = wn.measureText(t, e.font).width, i.put(t, n)), n;
}
function zm(e, t, i, n) {
  var r = Xi(ji(t), e), a = wc(t), s = is(0, r, i), o = Kr(0, a, n), l = new at(s, o, r, a);
  return l;
}
function bE(e, t, i, n) {
  var r = ((e || "") + "").split(`
`), a = r.length;
  if (a === 1)
    return zm(r[0], t, i, n);
  for (var s = new at(0, 0, 0, 0), o = 0; o < r.length; o++) {
    var l = zm(r[o], t, i, n);
    o === 0 ? s.copy(l) : s.union(l);
  }
  return s;
}
function is(e, t, i, n) {
  return i === "right" ? n ? e += t : e -= t : i === "center" && (n ? e += t / 2 : e -= t / 2), e;
}
function Kr(e, t, i, n) {
  return i === "middle" ? n ? e += t / 2 : e -= t / 2 : i === "bottom" && (n ? e += t : e -= t), e;
}
function wc(e) {
  return ji(e).stWideCharWidth;
}
function Co(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function v1(e, t, i) {
  var n = t.position || "inside", r = t.distance != null ? t.distance : 5, a = i.height, s = i.width, o = a / 2, l = i.x, u = i.y, c = "left", h = "top";
  if (n instanceof Array)
    l += Co(n[0], i.width), u += Co(n[1], i.height), c = null, h = null;
  else
    switch (n) {
      case "left":
        l -= r, u += o, c = "right", h = "middle";
        break;
      case "right":
        l += r + s, u += o, h = "middle";
        break;
      case "top":
        l += s / 2, u -= r, c = "center", h = "bottom";
        break;
      case "bottom":
        l += s / 2, u += a + r, c = "center";
        break;
      case "inside":
        l += s / 2, u += o, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += r, u += o, h = "middle";
        break;
      case "insideRight":
        l += s - r, u += o, c = "right", h = "middle";
        break;
      case "insideTop":
        l += s / 2, u += r, c = "center";
        break;
      case "insideBottom":
        l += s / 2, u += a - r, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += r, u += r;
        break;
      case "insideTopRight":
        l += s - r, u += r, c = "right";
        break;
      case "insideBottomLeft":
        l += r, u += a - r, h = "bottom";
        break;
      case "insideBottomRight":
        l += s - r, u += a - r, c = "right", h = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = h, e;
}
var kh = "__zr_normal__", Ph = Do.concat(["ignore"]), xE = us(Do, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), ya = {}, wE = new at(0, 0, 0, 0), xl = [], Sc = (function() {
  function e(t) {
    this.id = Ub(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, i, n) {
    switch (this.draggable) {
      case "horizontal":
        i = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var r = this.transform;
    r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += i, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var i = this._textContent;
    if (i && (!i.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, r = n.local, a = i.innerTransformable, s = void 0, o = void 0, l = !1;
      a.parent = r ? this : null;
      var u = !1;
      a.copyTransform(i);
      var c = n.position != null, h = n.autoOverflowArea, f = void 0;
      if ((h || c) && (f = wE, n.layoutRect ? f.copy(n.layoutRect) : f.copy(this.getBoundingRect()), r || f.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(ya, n, f) : v1(ya, n, f), a.x = ya.x, a.y = ya.y, s = ya.align, o = ya.verticalAlign;
        var d = n.origin;
        if (d && n.rotation != null) {
          var v = void 0, g = void 0;
          d === "center" ? (v = f.width * 0.5, g = f.height * 0.5) : (v = Co(d[0], f.width), g = Co(d[1], f.height)), u = !0, a.originX = -a.x + v + (r ? 0 : f.x), a.originY = -a.y + g + (r ? 0 : f.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var p = n.offset;
      p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
      var m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (h) {
        var y = m.overflowRect = m.overflowRect || new at(0, 0, 0, 0);
        a.getLocalTransform(xl), Wo(xl, xl), at.copy(y, f), y.applyTransform(xl);
      } else
        m.overflowRect = null;
      var _ = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, b = void 0, x = void 0, w = void 0;
      _ && this.canBeInsideText() ? (b = n.insideFill, x = n.insideStroke, (b == null || b === "auto") && (b = this.getInsideTextFill()), (x == null || x === "auto") && (x = this.getInsideTextStroke(b), w = !0)) : (b = n.outsideFill, x = n.outsideStroke, (b == null || b === "auto") && (b = this.getOutsideFill()), (x == null || x === "auto") && (x = this.getOutsideStroke(b), w = !0)), b = b || "#000", (b !== m.fill || x !== m.stroke || w !== m.autoStroke || s !== m.align || o !== m.verticalAlign) && (l = !0, m.fill = b, m.stroke = x, m.autoStroke = w, m.align = s, m.verticalAlign = o, i.setDefaultTextStyle(m)), i.__dirty |= Xe, l && i.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? sd : ad;
  }, e.prototype.getOutsideStroke = function(t) {
    var i = this.__zr && this.__zr.getBackgroundColor(), n = typeof i == "string" && yn(i);
    n || (n = [255, 255, 255, 1]);
    for (var r = n[3], a = this.__zr.isDarkMode(), s = 0; s < 3; s++)
      n[s] = n[s] * r + (a ? 0 : 255) * (1 - r);
    return n[3] = 1, Zr(n, "rgba");
  }, e.prototype.traverse = function(t, i) {
  }, e.prototype.attrKV = function(t, i) {
    t === "textConfig" ? this.setTextConfig(i) : t === "textContent" ? this.setTextContent(i) : t === "clipPath" ? this.setClipPath(i) : t === "extra" ? (this.extra = this.extra || {}, Y(this.extra, i)) : this[t] = i;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, i) {
    if (typeof t == "string")
      this.attrKV(t, i);
    else if (q(t))
      for (var n = t, r = jt(n), a = 0; a < r.length; a++) {
        var s = r[a];
        this.attrKV(s, t[s]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var i = this._normalState, n = 0; n < this.animators.length; n++) {
      var r = this.animators[n], a = r.__fromStateTransition;
      if (!(r.getLoop() || a && a !== kh)) {
        var s = r.targetName, o = s ? i[s] : i;
        r.saveTo(o);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var i = this._normalState;
    i || (i = this._normalState = {}), t.textConfig && !i.textConfig && (i.textConfig = this.textConfig), this._savePrimaryToNormal(t, i, Ph);
  }, e.prototype._savePrimaryToNormal = function(t, i, n) {
    for (var r = 0; r < n.length; r++) {
      var a = n[r];
      t[a] != null && !(a in i) && (i[a] = this[a]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var i = this.states;
    return i[t] || (i[t] = {}), i[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(kh, !1, t);
  }, e.prototype.useState = function(t, i, n, r) {
    var a = t === kh, s = this.hasState();
    if (!(!s && a)) {
      var o = this.currentStates, l = this.stateTransition;
      if (!(Bt(o, t) >= 0 && (i || o.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          jr("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || r);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, i, !n && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, f = this._textGuide;
        return h && h.useState(t, i, n, c), f && f.useState(t, i, n, c), a ? (this.currentStates = [], this._normalState = {}) : i ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Xe), u;
      }
    }
  }, e.prototype.useStates = function(t, i, n) {
    if (!t.length)
      this.clearStates();
    else {
      var r = [], a = this.currentStates, s = t.length, o = s === a.length;
      if (o) {
        for (var l = 0; l < s; l++)
          if (t[l] !== a[l]) {
            o = !1;
            break;
          }
      }
      if (o)
        return;
      for (var l = 0; l < s; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && r.push(c);
      }
      var h = r[s - 1], f = !!(h && h.hoverLayer || n);
      f && this._toggleHoverLayerFlag(!0);
      var d = this._mergeStates(r), v = this.stateTransition;
      this.saveCurrentToNormalState(d), this._applyStateObj(t.join(","), d, this._normalState, !1, !i && !this.__inHover && v && v.duration > 0, v);
      var g = this._textContent, p = this._textGuide;
      g && g.useStates(t, i, f), p && p.useStates(t, i, f), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !f && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Xe);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var i = t.__hostTarget;
      t = i ? t.ignoreHostSilent ? null : i : t.parent;
    }
    return !1;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var i = this.animators[t];
      i.targetName && i.changeTarget(this[i.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var i = Bt(this.currentStates, t);
    if (i >= 0) {
      var n = this.currentStates.slice();
      n.splice(i, 1), this.useStates(n);
    }
  }, e.prototype.replaceState = function(t, i, n) {
    var r = this.currentStates.slice(), a = Bt(r, t), s = Bt(r, i) >= 0;
    a >= 0 ? s ? r.splice(a, 1) : r[a] = i : n && !s && r.push(i), this.useStates(r);
  }, e.prototype.toggleState = function(t, i) {
    i ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var i = {}, n, r = 0; r < t.length; r++) {
      var a = t[r];
      Y(i, a), a.textConfig && (n = n || {}, Y(n, a.textConfig));
    }
    return n && (i.textConfig = n), i;
  }, e.prototype._applyStateObj = function(t, i, n, r, a, s) {
    var o = !(i && r);
    i && i.textConfig ? (this.textConfig = Y({}, r ? this.textConfig : n.textConfig), Y(this.textConfig, i.textConfig)) : o && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < Ph.length; c++) {
      var h = Ph[c], f = a && xE[h];
      i && i[h] != null ? f ? (u = !0, l[h] = i[h]) : this[h] = i[h] : o && n[h] != null && (f ? (u = !0, l[h] = n[h]) : this[h] = n[h]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var d = this.animators[c], v = d.targetName;
        d.getLoop() || d.__changeFinalValue(v ? (i || n)[v] : i || n);
      }
    u && this._transitionState(t, l, s);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var i = this.__zr;
    i && t.addSelfToZr(i), t.__zr = i, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var i = this._textContent;
    if (i !== t) {
      if (i && i !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new Vr(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), Y(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= Xe;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var i = this._textContent, n = this._textGuide;
    i && (i.__inHover = t), n && (n.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.addAnimator(i[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.removeAnimator(i[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, i, n) {
    var r = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !r) {
      jr('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new Mv(r, i, n);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, e.prototype.addAnimator = function(t, i) {
    var n = this.__zr, r = this;
    t.during(function() {
      r.updateDuringAnimation(i);
    }).done(function() {
      var a = r.animators, s = Bt(a, t);
      s >= 0 && a.splice(s, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, i) {
    for (var n = this.animators, r = n.length, a = [], s = 0; s < r; s++) {
      var o = n[s];
      !t || t === o.scope ? o.stop(i) : a.push(o);
    }
    return this.animators = a, this;
  }, e.prototype.animateTo = function(t, i, n) {
    Ah(this, t, i, n);
  }, e.prototype.animateFrom = function(t, i, n) {
    Ah(this, t, i, n, !0);
  }, e.prototype._transitionState = function(t, i, n, r) {
    for (var a = Ah(this, i, n, r), s = 0; s < a.length; s++)
      a[s].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = Xe;
    var i = {};
    function n(a, s, o) {
      i[a + s + o] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + s + "', '" + o + "' instead"), i[a + s + o] = !0);
    }
    function r(a, s, o, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(a, o, l), !this[s]) {
            var c = this[s] = [];
            u(this, c);
          }
          return this[s];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(a, o, l), this[o] = c[0], this[l] = c[1], this[s] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[o];
          },
          set: function(f) {
            c[o] = f;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(f) {
            c[l] = f;
          }
        });
      }
    }
    Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
  })(), e;
})();
Ci(Sc, ki);
Ci(Sc, Vr);
function Ah(e, t, i, n, r) {
  i = i || {};
  var a = [];
  p1(e, "", e, t, i, n, a, r);
  var s = a.length, o = !1, l = i.done, u = i.aborted, c = function() {
    o = !0, s--, s <= 0 && (o ? l && l() : u && u());
  }, h = function() {
    s--, s <= 0 && (o ? l && l() : u && u());
  };
  s || l && l(), a.length > 0 && i.during && a[0].during(function(v, g) {
    i.during(g);
  });
  for (var f = 0; f < a.length; f++) {
    var d = a[f];
    c && d.done(c), h && d.aborted(h), i.force && d.duration(i.duration), d.start(i.easing);
  }
  return a;
}
function Eh(e, t, i) {
  for (var n = 0; n < i; n++)
    e[n] = t[n];
}
function SE(e) {
  return Ye(e[0]);
}
function ME(e, t, i) {
  if (Ye(t[i]))
    if (Ye(e[i]) || (e[i] = []), Le(t[i])) {
      var n = t[i].length;
      e[i].length !== n && (e[i] = new t[i].constructor(n), Eh(e[i], t[i], n));
    } else {
      var r = t[i], a = e[i], s = r.length;
      if (SE(r))
        for (var o = r[0].length, l = 0; l < s; l++)
          a[l] ? Eh(a[l], r[l], o) : a[l] = Array.prototype.slice.call(r[l]);
      else
        Eh(a, r, s);
      a.length = r.length;
    }
  else
    e[i] = t[i];
}
function TE(e, t) {
  return e === t || Ye(e) && Ye(t) && DE(e, t);
}
function DE(e, t) {
  var i = e.length;
  if (i !== t.length)
    return !1;
  for (var n = 0; n < i; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function p1(e, t, i, n, r, a, s, o) {
  for (var l = jt(n), u = r.duration, c = r.delay, h = r.additive, f = r.setToFinal, d = !q(a), v = e.animators, g = [], p = 0; p < l.length; p++) {
    var m = l[p], y = n[m];
    if (y != null && i[m] != null && (d || a[m]))
      if (q(y) && !Ye(y) && !bc(y)) {
        if (t) {
          o || (i[m] = y, e.updateDuringAnimation(t));
          continue;
        }
        p1(e, m, i[m], y, r, a && a[m], s, o);
      } else
        g.push(m);
    else o || (i[m] = y, e.updateDuringAnimation(t), g.push(m));
  }
  var _ = g.length;
  if (!h && _)
    for (var b = 0; b < v.length; b++) {
      var x = v[b];
      if (x.targetName === t) {
        var w = x.stopTracks(g);
        if (w) {
          var M = Bt(v, x);
          v.splice(M, 1);
        }
      }
    }
  if (r.force || (g = je(g, function(C) {
    return !TE(n[C], i[C]);
  }), _ = g.length), _ > 0 || r.force && !s.length) {
    var T = void 0, D = void 0, P = void 0;
    if (o) {
      D = {}, f && (T = {});
      for (var b = 0; b < _; b++) {
        var m = g[b];
        D[m] = i[m], f ? T[m] = n[m] : i[m] = n[m];
      }
    } else if (f) {
      P = {};
      for (var b = 0; b < _; b++) {
        var m = g[b];
        P[m] = tu(i[m]), ME(i, n, m);
      }
    }
    var x = new Mv(i, !1, !1, h ? je(v, function(A) {
      return A.targetName === t;
    }) : null);
    x.targetName = t, r.scope && (x.scope = r.scope), f && T && x.whenWithKeys(0, T, g), P && x.whenWithKeys(0, P, g), x.whenWithKeys(u ?? 500, o ? D : n, g).delay(c || 0), e.addAnimator(x, t), s.push(x);
  }
}
var Mi = (function(e) {
  At(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(i) {
    return this._children[i];
  }, t.prototype.childOfName = function(i) {
    for (var n = this._children, r = 0; r < n.length; r++)
      if (n[r].name === i)
        return n[r];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(i) {
    if (i && (i !== this && i.parent !== this && (this._children.push(i), this._doAdd(i)), process.env.NODE_ENV !== "production" && i.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(i, n) {
    if (i && i !== this && i.parent !== this && n && n.parent === this) {
      var r = this._children, a = r.indexOf(n);
      a >= 0 && (r.splice(a, 0, i), this._doAdd(i));
    }
    return this;
  }, t.prototype.replace = function(i, n) {
    var r = Bt(this._children, i);
    return r >= 0 && this.replaceAt(n, r), this;
  }, t.prototype.replaceAt = function(i, n) {
    var r = this._children, a = r[n];
    if (i && i !== this && i.parent !== this && i !== a) {
      r[n] = i, a.parent = null;
      var s = this.__zr;
      s && a.removeSelfFromZr(s), this._doAdd(i);
    }
    return this;
  }, t.prototype._doAdd = function(i) {
    i.parent && i.parent.remove(i), i.parent = this;
    var n = this.__zr;
    n && n !== i.__zr && i.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(i) {
    var n = this.__zr, r = this._children, a = Bt(r, i);
    return a < 0 ? this : (r.splice(a, 1), i.parent = null, n && i.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var i = this._children, n = this.__zr, r = 0; r < i.length; r++) {
      var a = i[r];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return i.length = 0, this;
  }, t.prototype.eachChild = function(i, n) {
    for (var r = this._children, a = 0; a < r.length; a++) {
      var s = r[a];
      i.call(n, s, a);
    }
    return this;
  }, t.prototype.traverse = function(i, n) {
    for (var r = 0; r < this._children.length; r++) {
      var a = this._children[r], s = i.call(n, a);
      a.isGroup && !s && a.traverse(i, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.addSelfToZr(i);
    }
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.removeSelfFromZr(i);
    }
  }, t.prototype.getBoundingRect = function(i) {
    for (var n = new at(0, 0, 0, 0), r = i || this._children, a = [], s = null, o = 0; o < r.length; o++) {
      var l = r[o];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (at.applyTransform(n, u, c), s = s || n.clone(), s.union(n)) : (s = s || u.clone(), s.union(u));
      }
    }
    return s || n;
  }, t;
})(Sc);
Mi.prototype.type = "group";
var Ks = {}, g1 = {};
function CE(e) {
  delete g1[e];
}
function kE(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return Au(e, 1) < rd;
  if (e.colorStops) {
    for (var t = e.colorStops, i = 0, n = t.length, r = 0; r < n; r++)
      i += Au(t[r].color, 1);
    return i /= n, i < rd;
  }
  return !1;
}
var PE = (function() {
  function e(t, i, n) {
    var r = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = i, this.id = t;
    var a = new UA(), s = n.renderer || "canvas";
    if (Ks[s] || (s = jt(Ks)[0]), process.env.NODE_ENV !== "production" && !Ks[s])
      throw new Error("Renderer '" + s + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var o = new Ks[s](i, a, n, t), l = n.ssr || o.ssrOnly;
    this.storage = a, this.painter = o;
    var u = !rt.node && !rt.worker && !l ? new mE(o.getViewportRoot(), o.root) : null, c = n.useCoarsePointer, h = c == null || c === "auto" ? rt.touchEventsSupported : !!c, f = 44, d;
    h && (d = et(n.pointerSize, f)), this.handler = new Jb(a, o, u, o.root, d), this.animation = new cE({
      stage: {
        update: l ? null : function() {
          return r._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, i) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, i), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = kE(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var i, n = za();
    this._needsRefresh && (i = !0, this.refreshImmediately(t)), this._needsRefreshHover && (i = !0, this.refreshHoverImmediately());
    var r = za();
    i ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: r - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, i) {
    if (!this._disposed)
      return this.handler.findHover(t, i);
  }, e.prototype.on = function(t, i, n) {
    return this._disposed || this.handler.on(t, i, n), this;
  }, e.prototype.off = function(t, i) {
    this._disposed || this.handler.off(t, i);
  }, e.prototype.trigger = function(t, i) {
    this._disposed || this.handler.trigger(t, i);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), i = 0; i < t.length; i++)
        t[i] instanceof Mi && t[i].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, CE(this.id));
  }, e;
})();
function Vm(e, t) {
  var i = new PE(Ub(), e, t);
  return g1[i.id] = i, i;
}
function AE(e, t) {
  Ks[e] = t;
}
var $m = 1e-4, m1 = 20;
function EE(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
var ko = Math.min, bi = Math.max, vn = Math.abs;
function Po(e, t, i, n) {
  var r = t[0], a = t[1], s = i[0], o = i[1], l = a - r, u = o - s;
  if (l === 0)
    return u === 0 ? s : (s + o) / 2;
  if (l > 0) {
    if (e <= r)
      return s;
    if (e >= a)
      return o;
  } else {
    if (e >= r)
      return s;
    if (e <= a)
      return o;
  }
  return (e - r) / l * u + s;
}
var ze = LE;
function LE(e, t, i) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return OE(e, t, i);
}
function OE(e, t, i) {
  return Q(e) ? EE(e).match(/%$/) ? parseFloat(e) / 100 * t + (i || 0) : parseFloat(e) : e == null ? NaN : +e;
}
function IE(e, t, i) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), m1), e = (+e).toFixed(t), i ? e : +e;
}
function Hm(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, i = 0; i < 15; i++, t *= 10)
      if (Math.round(e * t) / t === e)
        return i;
  }
  return RE(e);
}
function RE(e) {
  var t = e.toString().toLowerCase(), i = t.indexOf("e"), n = i > 0 ? +t.slice(i + 1) : 0, r = i > 0 ? i : t.length, a = t.indexOf("."), s = a < 0 ? 0 : r - 1 - a;
  return Math.max(0, s - n);
}
function NE(e, t) {
  var i = Math.max(Hm(e), Hm(t)), n = e + t;
  return i > m1 ? n : IE(n, i);
}
function y1(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function Lu(e) {
  return e > -$m && e < $m;
}
var FE = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Mc(e) {
  if (e instanceof Date)
    return e;
  if (Q(e)) {
    var t = FE.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var i = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (i -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, i, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function Ou(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !Q(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function _1(e) {
  return !isNaN(Ou(e));
}
function b1() {
  return Math.round(Math.random() * 9);
}
function x1(e, t) {
  return t === 0 ? e : x1(t, e % t);
}
function Ym(e, t) {
  return e == null ? t : t == null ? e : e * t / x1(e, t);
}
var BE = "[ECharts] ", Wm = {}, zE = typeof console < "u" && console.warn && console.log;
function Tc(e, t, i) {
  if (zE) {
    if (i) {
      if (Wm[t])
        return;
      Wm[t] = !0;
    }
    console[e](BE + t);
  }
}
function VE(e, t) {
  Tc("log", e, t);
}
function oi(e, t) {
  Tc("warn", e, t);
}
function qt(e, t) {
  Tc("error", e, t);
}
function Sn(e) {
  process.env.NODE_ENV !== "production" && Tc("warn", "DEPRECATED: " + e, !0);
}
function he(e, t, i) {
  process.env.NODE_ENV !== "production" && Sn((i ? "[" + i + "]" : "") + (e + " is deprecated; use " + t + " instead."));
}
function Iu() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var i = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(r) {
      return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : Gb(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : mt(r) ? "function () { ... }" : rA(r) ? r + "" : null;
    };
    i = bt(e, function(r) {
      if (Q(r))
        return r;
      var a = n(r);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(r, function(s, o) {
            var l = n(o);
            return l ?? o;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return i;
}
function Ve(e) {
  throw new Error(e);
}
var w1 = "series\0", $E = "\0_ec_\0";
function Ee(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function Um(e, t, i) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var n = 0, r = i.length; n < r; n++) {
      var a = i[n];
      !e.emphasis[t].hasOwnProperty(a) && e[t].hasOwnProperty(a) && (e.emphasis[t][a] = e[t][a]);
    }
  }
}
var Gm = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function Uo(e) {
  return q(e) && !j(e) && !(e instanceof Date) ? e.value : e;
}
function HE(e) {
  return q(e) && !(e instanceof Array);
}
function YE(e, t, i) {
  var n = i === "normalMerge", r = i === "replaceMerge", a = i === "replaceAll";
  e = e || [], t = (t || []).slice();
  var s = lt();
  k(t, function(l, u) {
    if (!q(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !Xm(l.id) && jm(l.id), l.name != null && !Xm(l.name) && jm(l.name));
  });
  var o = WE(e, s, i);
  return (n || r) && UE(o, e, s, t), n && GE(o, t), n || r ? jE(o, t, r) : a && XE(o, t), qE(o), o;
}
function WE(e, t, i) {
  var n = [];
  if (i === "replaceAll")
    return n;
  for (var r = 0; r < e.length; r++) {
    var a = e[r];
    a && a.id != null && t.set(a.id, r), n.push({
      existing: i === "replaceMerge" || ns(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function UE(e, t, i, n) {
  k(n, function(r, a) {
    if (!(!r || r.id == null)) {
      var s = ho(r.id), o = i.get(s);
      if (o != null) {
        var l = e[o];
        tt(!l.newOption, 'Duplicated option on id "' + s + '".'), l.newOption = r, l.existing = t[o], n[a] = null;
      }
    }
  });
}
function GE(e, t) {
  k(t, function(i, n) {
    if (!(!i || i.name == null))
      for (var r = 0; r < e.length; r++) {
        var a = e[r].existing;
        if (!e[r].newOption && a && (a.id == null || i.id == null) && !ns(i) && !ns(a) && S1("name", a, i)) {
          e[r].newOption = i, t[n] = null;
          return;
        }
      }
  });
}
function jE(e, t, i) {
  k(t, function(n) {
    if (n) {
      for (
        var r, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (r = e[a]) && (r.newOption || ns(r.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        r.existing && n.id != null && !S1("id", n, r.existing));
      )
        a++;
      r ? (r.newOption = n, r.brandNew = i) : e.push({
        newOption: n,
        brandNew: i,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function XE(e, t) {
  k(t, function(i) {
    e.push({
      newOption: i,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function qE(e) {
  var t = lt();
  k(e, function(i) {
    var n = i.existing;
    n && t.set(n.id, i);
  }), k(e, function(i) {
    var n = i.newOption;
    tt(!n || n.id == null || !t.get(n.id) || t.get(n.id) === i, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, i), !i.keyInfo && (i.keyInfo = {});
  }), k(e, function(i, n) {
    var r = i.existing, a = i.newOption, s = i.keyInfo;
    if (q(a)) {
      if (s.name = a.name != null ? ho(a.name) : r ? r.name : w1 + n, r)
        s.id = ho(r.id);
      else if (a.id != null)
        s.id = ho(a.id);
      else {
        var o = 0;
        do
          s.id = "\0" + s.name + "\0" + o++;
        while (t.get(s.id));
      }
      t.set(s.id, i);
    }
  });
}
function S1(e, t, i) {
  var n = Si(t[e], null), r = Si(i[e], null);
  return n != null && r != null && n === r;
}
function ho(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return Si(e, "");
}
function Si(e, t) {
  return e == null ? t : Q(e) ? e : Xt(e) || wu(e) ? e + "" : t;
}
function jm(e) {
  process.env.NODE_ENV !== "production" && oi("`" + e + "` is invalid id or name. Must be a string or number.");
}
function Xm(e) {
  return wu(e) || _1(e);
}
function M1(e) {
  var t = e.name;
  return !!(t && t.indexOf(w1));
}
function ns(e) {
  return e && e.id != null && ho(e.id).indexOf($E) === 0;
}
function ZE(e, t, i) {
  k(e, function(n) {
    var r = n.newOption;
    q(r) && (n.keyInfo.mainType = t, n.keyInfo.subType = KE(t, r, n.existing, i));
  });
}
function KE(e, t, i, n) {
  var r = t.type ? t.type : i ? i.subType : n.determineSubType(e, t);
  return r;
}
function Go(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return j(t.dataIndex) ? bt(t.dataIndex, function(i) {
      return e.indexOfRawIndex(i);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return j(t.name) ? bt(t.name, function(i) {
      return e.indexOfName(i);
    }) : e.indexOfName(t.name);
}
function Wt() {
  var e = "__ec_inner_" + QE++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var QE = b1();
function Lh(e, t, i) {
  var n = Tv(t, i), r = n.mainTypeSpecified, a = n.queryOptionMap, s = n.others, o = s, l = i ? i.defaultMainType : null;
  return !r && l && a.set(l, {}), a.each(function(u, c) {
    var h = jo(e, c, u, {
      useDefault: l === c,
      enableAll: i && i.enableAll != null ? i.enableAll : !0,
      enableNone: i && i.enableNone != null ? i.enableNone : !0
    });
    o[c + "Models"] = h.models, o[c + "Model"] = h.models[0];
  }), o;
}
function Tv(e, t) {
  var i;
  if (Q(e)) {
    var n = {};
    n[e + "Index"] = 0, i = n;
  } else
    i = e;
  var r = lt(), a = {}, s = !1;
  return k(i, function(o, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = o;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || t && t.includeMainTypes && Bt(t.includeMainTypes, c) < 0)) {
      s = s || !!c;
      var f = r.get(c) || r.set(c, {});
      f[h] = o;
    }
  }), {
    mainTypeSpecified: s,
    queryOptionMap: r,
    others: a
  };
}
var Fn = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
};
function jo(e, t, i, n) {
  n = n || Fn;
  var r = i.index, a = i.id, s = i.name, o = {
    models: null,
    specified: r != null || a != null || s != null
  };
  if (!o.specified) {
    var l = void 0;
    return o.models = n.useDefault && (l = e.getComponent(t)) ? [l] : [], o;
  }
  if (r === "none" || r === !1) {
    if (n.enableNone)
      return o.models = [], o;
    process.env.NODE_ENV !== "production" && qt('`"none"` or `false` is not a valid value on index option.'), r = -1;
  }
  return r === "all" && (n.enableAll ? r = a = s = null : (process.env.NODE_ENV !== "production" && qt('`"all"` is not a valid value on index option.'), r = -1)), o.models = e.queryComponents({
    mainType: t,
    index: r,
    id: a,
    name: s
  }), o;
}
function T1(e, t, i) {
  e.setAttribute ? e.setAttribute(t, i) : e[t] = i;
}
function JE(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function tL(e) {
  return e === "auto" ? rt.domSupported ? "html" : "richText" : e || "html";
}
function eL(e, t) {
  var i = lt(), n = [];
  return k(e, function(r) {
    var a = t(r);
    (i.get(a) || (n.push(a), i.set(a, []))).push(r);
  }), {
    keys: n,
    buckets: i
  };
}
var iL = ".", vr = "___EC__COMPONENT__CONTAINER___", D1 = "___EC__EXTENDED_CLASS___";
function Yi(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var i = e.split(iL);
    t.main = i[0] || "", t.sub = i[1] || "";
  }
  return t;
}
function nL(e) {
  tt(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function rL(e) {
  return !!(e && e[D1]);
}
function Dv(e, t) {
  e.$constructor = e, e.extend = function(i) {
    process.env.NODE_ENV !== "production" && k(t, function(a) {
      i[a] || console.warn("Method `" + a + "` should be implemented" + (i.type ? " in " + i.type : "") + ".");
    });
    var n = this, r;
    return aL(n) ? r = /** @class */
    (function(a) {
      ae(s, a);
      function s() {
        return a.apply(this, arguments) || this;
      }
      return s;
    })(n) : (r = function() {
      (i.$constructor || n).apply(this, arguments);
    }, eA(r, this)), Y(r.prototype, i), r[D1] = !0, r.extend = this.extend, r.superCall = lL, r.superApply = uL, r.superClass = n, r;
  };
}
function aL(e) {
  return mt(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function C1(e, t) {
  e.extend = t.extend;
}
var sL = Math.round(Math.random() * 10);
function oL(e) {
  var t = ["__\0is_clz", sL++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && tt(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(i) {
    return !!(i && i[t]);
  };
}
function lL(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(e, i);
}
function uL(e, t, i) {
  return this.superClass.prototype[t].apply(e, i);
}
function Cv(e) {
  var t = {};
  e.registerClass = function(n) {
    var r = n.type || n.prototype.type;
    if (r) {
      nL(r), n.prototype.type = r;
      var a = Yi(r);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = n;
      else if (a.sub !== vr) {
        var s = i(a);
        s[a.sub] = n;
      }
    }
    return n;
  }, e.getClass = function(n, r, a) {
    var s = t[n];
    if (s && s[vr] && (s = r ? s[r] : null), a && !s)
      throw new Error(r ? "Component " + n + "." + (r || "") + " is used but not imported." : n + ".type should be specified.");
    return s;
  }, e.getClassesByMainType = function(n) {
    var r = Yi(n), a = [], s = t[r.main];
    return s && s[vr] ? k(s, function(o, l) {
      l !== vr && a.push(o);
    }) : a.push(s), a;
  }, e.hasClass = function(n) {
    var r = Yi(n);
    return !!t[r.main];
  }, e.getAllClassMainTypes = function() {
    var n = [];
    return k(t, function(r, a) {
      n.push(a);
    }), n;
  }, e.hasSubTypes = function(n) {
    var r = Yi(n), a = t[r.main];
    return a && a[vr];
  };
  function i(n) {
    var r = t[n.main];
    return (!r || !r[vr]) && (r = t[n.main] = {}, r[vr] = !0), r;
  }
}
function Ao(e, t) {
  for (var i = 0; i < e.length; i++)
    e[i][1] || (e[i][1] = e[i][0]);
  return t = t || !1, function(n, r, a) {
    for (var s = {}, o = 0; o < e.length; o++) {
      var l = e[o][1];
      if (!(r && Bt(r, l) >= 0 || a && Bt(a, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (s[e[o][0]] = u);
      }
    }
    return s;
  };
}
var cL = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], hL = Ao(cL), fL = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, i) {
      return hL(this, t, i);
    }, e;
  })()
), ld = new es(50);
function dL(e) {
  if (typeof e == "string") {
    var t = ld.get(e);
    return t && t.image;
  } else
    return e;
}
function k1(e, t, i, n, r) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !i)
        return t;
      var a = ld.get(e), s = { hostEl: i, cb: n, cbPayload: r };
      return a ? (t = a.image, !Dc(t) && a.pending.push(s)) : (t = wn.loadImage(e, qm, qm), t.__zrImageSrc = e, ld.put(e, t.__cachedImgObj = {
        image: t,
        pending: [s]
      })), t;
    } else
      return e;
  else return t;
}
function qm() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var i = e.pending[t], n = i.cb;
    n && n(this, i.cbPayload), i.hostEl.dirty();
  }
  e.pending.length = 0;
}
function Dc(e) {
  return e && e.width && e.height;
}
var Oh = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function vL(e, t, i, n, r, a) {
  if (!i) {
    e.text = "", e.isTruncated = !1;
    return;
  }
  var s = (t + "").split(`
`);
  a = P1(i, n, r, a);
  for (var o = !1, l = {}, u = 0, c = s.length; u < c; u++)
    A1(l, s[u], a), s[u] = l.textLine, o = o || l.isTruncated;
  e.text = s.join(`
`), e.isTruncated = o;
}
function P1(e, t, i, n) {
  n = n || {};
  var r = Y({}, n);
  i = et(i, "..."), r.maxIterations = et(n.maxIterations, 2);
  var a = r.minChar = et(n.minChar, 0), s = r.fontMeasureInfo = ji(t), o = s.asciiCharWidth;
  r.placeholder = et(n.placeholder, "");
  for (var l = e = Math.max(0, e - 1), u = 0; u < a && l >= o; u++)
    l -= o;
  var c = Xi(s, i);
  return c > l && (i = "", c = 0), l = e - c, r.ellipsis = i, r.ellipsisWidth = c, r.contentWidth = l, r.containerWidth = e, r;
}
function A1(e, t, i) {
  var n = i.containerWidth, r = i.contentWidth, a = i.fontMeasureInfo;
  if (!n) {
    e.textLine = "", e.isTruncated = !1;
    return;
  }
  var s = Xi(a, t);
  if (s <= n) {
    e.textLine = t, e.isTruncated = !1;
    return;
  }
  for (var o = 0; ; o++) {
    if (s <= r || o >= i.maxIterations) {
      t += i.ellipsis;
      break;
    }
    var l = o === 0 ? pL(t, r, a) : s > 0 ? Math.floor(t.length * r / s) : 0;
    t = t.substr(0, l), s = Xi(a, t);
  }
  t === "" && (t = i.placeholder), e.textLine = t, e.isTruncated = !0;
}
function pL(e, t, i) {
  for (var n = 0, r = 0, a = e.length; r < a && n < t; r++)
    n += d1(i, e.charCodeAt(r));
  return r;
}
function gL(e, t, i, n) {
  var r = kv(e), a = t.overflow, s = t.padding, o = s ? s[1] + s[3] : 0, l = s ? s[0] + s[2] : 0, u = t.font, c = a === "truncate", h = wc(u), f = et(t.lineHeight, h), d = t.lineOverflow === "truncate", v = !1, g = t.width;
  g == null && i != null && (g = i - o);
  var p = t.height;
  p == null && n != null && (p = n - l);
  var m;
  g != null && (a === "break" || a === "breakAll") ? m = r ? E1(r, t.font, g, a === "breakAll", 0).lines : [] : m = r ? r.split(`
`) : [];
  var y = m.length * f;
  if (p == null && (p = y), y > p && d) {
    var _ = Math.floor(p / f);
    v = v || m.length > _, m = m.slice(0, _), y = m.length * f;
  }
  if (r && c && g != null)
    for (var b = P1(g, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), x = {}, w = 0; w < m.length; w++)
      A1(x, m[w], b), m[w] = x.textLine, v = v || x.isTruncated;
  for (var M = p, T = 0, D = ji(u), w = 0; w < m.length; w++)
    T = Math.max(Xi(D, m[w]), T);
  g == null && (g = T);
  var P = g;
  return M += l, P += o, {
    lines: m,
    height: p,
    outerWidth: P,
    outerHeight: M,
    lineHeight: f,
    calculatedLineHeight: h,
    contentWidth: T,
    contentHeight: y,
    width: g,
    isTruncated: v
  };
}
var mL = /* @__PURE__ */ (function() {
  function e() {
  }
  return e;
})(), Zm = /* @__PURE__ */ (function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
})(), yL = /* @__PURE__ */ (function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return e;
})();
function _L(e, t, i, n, r) {
  var a = new yL(), s = kv(e);
  if (!s)
    return a;
  var o = t.padding, l = o ? o[1] + o[3] : 0, u = o ? o[0] + o[2] : 0, c = t.width;
  c == null && i != null && (c = i - l);
  var h = t.height;
  h == null && n != null && (h = n - u);
  for (var f = t.overflow, d = (f === "break" || f === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: f === "breakAll" } : null, v = Oh.lastIndex = 0, g; (g = Oh.exec(s)) != null; ) {
    var p = g.index;
    p > v && Ih(a, s.substring(v, p), t, d), Ih(a, g[2], t, d, g[1]), v = Oh.lastIndex;
  }
  v < s.length && Ih(a, s.substring(v, s.length), t, d);
  var m = [], y = 0, _ = 0, b = f === "truncate", x = t.lineOverflow === "truncate", w = {};
  function M(ht, le, De) {
    ht.width = le, ht.lineHeight = De, y += De, _ = Math.max(_, le);
  }
  t: for (var T = 0; T < a.lines.length; T++) {
    for (var D = a.lines[T], P = 0, C = 0, A = 0; A < D.tokens.length; A++) {
      var E = D.tokens[A], R = E.styleName && t.rich[E.styleName] || {}, I = E.textPadding = R.padding, N = I ? I[1] + I[3] : 0, B = E.font = R.font || t.font;
      E.contentHeight = wc(B);
      var $ = et(R.height, E.contentHeight);
      if (E.innerHeight = $, I && ($ += I[0] + I[2]), E.height = $, E.lineHeight = Xr(R.lineHeight, t.lineHeight, $), E.align = R && R.align || r, E.verticalAlign = R && R.verticalAlign || "middle", x && h != null && y + E.lineHeight > h) {
        var H = a.lines.length;
        A > 0 ? (D.tokens = D.tokens.slice(0, A), M(D, C, P), a.lines = a.lines.slice(0, T + 1)) : a.lines = a.lines.slice(0, T), a.isTruncated = a.isTruncated || a.lines.length < H;
        break t;
      }
      var G = R.width, nt = G == null || G === "auto";
      if (typeof G == "string" && G.charAt(G.length - 1) === "%")
        E.percentWidth = G, m.push(E), E.contentWidth = Xi(ji(B), E.text);
      else {
        if (nt) {
          var K = R.backgroundColor, pt = K && K.image;
          pt && (pt = dL(pt), Dc(pt) && (E.width = Math.max(E.width, pt.width * $ / pt.height)));
        }
        var gt = b && c != null ? c - C : null;
        gt != null && gt < E.width ? !nt || gt < N ? (E.text = "", E.width = E.contentWidth = 0) : (vL(w, E.text, gt - N, B, t.ellipsis, { minChar: t.truncateMinChar }), E.text = w.text, a.isTruncated = a.isTruncated || w.isTruncated, E.width = E.contentWidth = Xi(ji(B), E.text)) : E.contentWidth = Xi(ji(B), E.text);
      }
      E.width += N, C += E.width, R && (P = Math.max(P, E.lineHeight));
    }
    M(D, C, P);
  }
  a.outerWidth = a.width = et(c, _), a.outerHeight = a.height = et(h, y), a.contentHeight = y, a.contentWidth = _, a.outerWidth += l, a.outerHeight += u;
  for (var T = 0; T < m.length; T++) {
    var E = m[T], Ht = E.percentWidth;
    E.width = parseInt(Ht, 10) / 100 * a.width;
  }
  return a;
}
function Ih(e, t, i, n, r) {
  var a = t === "", s = r && i.rich[r] || {}, o = e.lines, l = s.font || i.font, u = !1, c, h;
  if (n) {
    var f = s.padding, d = f ? f[1] + f[3] : 0;
    if (s.width != null && s.width !== "auto") {
      var v = Co(s.width, n.width) + d;
      o.length > 0 && v + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = v;
    } else {
      var g = E1(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = g.accumWidth + d, h = g.linesWidths, c = g.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var p = ji(l), m = 0; m < c.length; m++) {
    var y = c[m], _ = new mL();
    if (_.styleName = r, _.text = y, _.isLineHolder = !y && !a, typeof s.width == "number" ? _.width = s.width : _.width = h ? h[m] : Xi(p, y), !m && !u) {
      var b = (o[o.length - 1] || (o[0] = new Zm())).tokens, x = b.length;
      x === 1 && b[0].isLineHolder ? b[0] = _ : (y || !x || a) && b.push(_);
    } else
      o.push(new Zm([_]));
  }
}
function bL(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var xL = us(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function wL(e) {
  return bL(e) ? !!xL[e] : !0;
}
function E1(e, t, i, n, r) {
  for (var a = [], s = [], o = "", l = "", u = 0, c = 0, h = ji(t), f = 0; f < e.length; f++) {
    var d = e.charAt(f);
    if (d === `
`) {
      l && (o += l, c += u), a.push(o), s.push(c), o = "", l = "", u = 0, c = 0;
      continue;
    }
    var v = d1(h, d.charCodeAt(0)), g = n ? !1 : !wL(d);
    if (a.length ? c + v > i : r + c + v > i) {
      c ? (o || l) && (g ? (o || (o = l, l = "", u = 0, c = u), a.push(o), s.push(c - u), l += d, u += v, o = "", c = u) : (l && (o += l, l = "", u = 0), a.push(o), s.push(c), o = d, c = v)) : g ? (a.push(l), s.push(u), l = d, u = v) : (a.push(d), s.push(v));
      continue;
    }
    c += v, g ? (l += d, u += v) : (l && (o += l, l = "", u = 0), o += d);
  }
  return l && (o += l), o && (a.push(o), s.push(c)), a.length === 1 && (c += r), {
    accumWidth: c,
    lines: a,
    linesWidths: s
  };
}
function Km(e, t, i, n, r, a) {
  if (e.baseX = i, e.baseY = n, e.outerWidth = e.outerHeight = null, !!t) {
    var s = t.width * 2, o = t.height * 2;
    at.set(Qm, is(i, s, r), Kr(n, o, a), s, o), at.intersect(t, Qm, null, Jm);
    var l = Jm.outIntersectRect;
    e.outerWidth = l.width, e.outerHeight = l.height, e.baseX = is(l.x, l.width, r, !0), e.baseY = Kr(l.y, l.height, a, !0);
  }
}
var Qm = new at(0, 0, 0, 0), Jm = { outIntersectRect: {}, clamp: !0 };
function kv(e) {
  return e != null ? e += "" : e = "";
}
function SL(e) {
  var t = kv(e.text), i = e.font, n = Xi(ji(i), t), r = wc(i);
  return ud(e, n, r, null);
}
function ud(e, t, i, n) {
  var r = new at(is(e.x || 0, t, e.textAlign), Kr(e.y || 0, i, e.textBaseline), t, i), a = n ?? (L1(e) ? e.lineWidth : 0);
  return a > 0 && (r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a), r;
}
function L1(e) {
  var t = e.stroke;
  return t != null && t !== "none" && e.lineWidth > 0;
}
var cd = "__zr_style_" + Math.round(Math.random() * 10), Qr = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, Cc = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
Qr[cd] = !0;
var ty = ["z", "z2", "invisible"], ML = ["invisible"], Xo = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype._init = function(i) {
    for (var n = jt(i), r = 0; r < n.length; r++) {
      var a = n[r];
      a === "style" ? this.useStyle(i[a]) : e.prototype.attrKV.call(this, a, i[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(i, n, r, a) {
    var s = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && TL(this, i, n) || s && !s[0] && !s[3])
      return !1;
    if (r && this.__clipPaths && this.__clipPaths.length) {
      for (var o = 0; o < this.__clipPaths.length; ++o)
        if (this.__clipPaths[o].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(i, n) {
    return this.rectContain(i, n);
  }, t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.rectContain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    return a.contain(r[0], r[1]);
  }, t.prototype.getPaintRect = function() {
    var i = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, r = this.getBoundingRect(), a = this.style, s = a.shadowBlur || 0, o = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      i = this._paintRect || (this._paintRect = new at(0, 0, 0, 0)), n ? at.applyTransform(i, r, n) : i.copy(r), (s || o || l) && (i.width += s * 2 + Math.abs(o), i.height += s * 2 + Math.abs(l), i.x = Math.min(i.x, i.x + o - s), i.y = Math.min(i.y, i.y + l - s));
      var u = this.dirtyRectTolerance;
      i.isZero() || (i.x = Math.floor(i.x - u), i.y = Math.floor(i.y - u), i.width = Math.ceil(i.width + 1 + u * 2), i.height = Math.ceil(i.height + 1 + u * 2));
    }
    return i;
  }, t.prototype.setPrevPaintRect = function(i) {
    i ? (this._prevPaintRect = this._prevPaintRect || new at(0, 0, 0, 0), this._prevPaintRect.copy(i)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(i) {
    return this.animate("style", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i !== "style" ? e.prototype.attrKV.call(this, i, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(i, n) {
    return typeof i == "string" ? this.style[i] = n : Y(this.style, i), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(i) {
    i || this.markRedraw(), this.__dirty |= qs, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & qs);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~qs;
  }, t.prototype.createStyle = function(i) {
    return xc(Qr, i);
  }, t.prototype.useStyle = function(i) {
    i[cd] || (i = this.createStyle(i)), this.__inHover ? this.__hoverStyle = i : this.style = i, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(i) {
    return i[cd];
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(i, n, ty);
  }, t.prototype._applyStateObj = function(i, n, r, a, s, o) {
    e.prototype._applyStateObj.call(this, i, n, r, a, s, o);
    var l = !(n && a), u;
    if (n && n.style ? s ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, n.style)) : l && (u = r.style), u)
      if (s) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = jt(c), f = 0; f < h.length; f++) {
            var d = h[f];
            d in u && (u[d] = u[d], this.style[d] = c[d]);
          }
        for (var v = jt(u), f = 0; f < v.length; f++) {
          var d = v[f];
          this.style[d] = this.style[d];
        }
        this._transitionState(i, {
          style: u
        }, o, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? ML : ty, f = 0; f < g.length; f++) {
      var d = g[f];
      n && n[d] != null ? this[d] = n[d] : l && r[d] != null && (this[d] = r[d]);
    }
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var s = i[a];
      s.style && (r = r || {}, this._mergeStyle(r, s.style));
    }
    return r && (n.style = r), n;
  }, t.prototype._mergeStyle = function(i, n) {
    return Y(i, n), i;
  }, t.prototype.getAnimationStyleProps = function() {
    return Cc;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "displayable", i.invisible = !1, i.z = 0, i.z2 = 0, i.zlevel = 0, i.culling = !1, i.cursor = "pointer", i.rectHover = !1, i.incremental = !1, i._rect = null, i.dirtyRectTolerance = 0, i.__dirty = Xe | qs;
  })(), t;
})(Sc), Rh = new at(0, 0, 0, 0), Nh = new at(0, 0, 0, 0);
function TL(e, t, i) {
  return Rh.copy(e.getBoundingRect()), e.transform && Rh.applyTransform(e.transform), Nh.width = t, Nh.height = i, !Rh.intersect(Nh);
}
var li = Math.min, ui = Math.max, Fh = Math.sin, Bh = Math.cos, pr = Math.PI * 2, wl = cs(), Sl = cs(), Ml = cs();
function ey(e, t, i, n, r, a) {
  r[0] = li(e, i), r[1] = li(t, n), a[0] = ui(e, i), a[1] = ui(t, n);
}
var iy = [], ny = [];
function DL(e, t, i, n, r, a, s, o, l, u) {
  var c = a1, h = Pe, f = c(e, i, r, s, iy);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var d = 0; d < f; d++) {
    var v = h(e, i, r, s, iy[d]);
    l[0] = li(v, l[0]), u[0] = ui(v, u[0]);
  }
  f = c(t, n, a, o, ny);
  for (var d = 0; d < f; d++) {
    var g = h(t, n, a, o, ny[d]);
    l[1] = li(g, l[1]), u[1] = ui(g, u[1]);
  }
  l[0] = li(e, l[0]), u[0] = ui(e, u[0]), l[0] = li(s, l[0]), u[0] = ui(s, u[0]), l[1] = li(t, l[1]), u[1] = ui(t, u[1]), l[1] = li(o, l[1]), u[1] = ui(o, u[1]);
}
function CL(e, t, i, n, r, a, s, o) {
  var l = s1, u = Be, c = ui(li(l(e, i, r), 1), 0), h = ui(li(l(t, n, a), 1), 0), f = u(e, i, r, c), d = u(t, n, a, h);
  s[0] = li(e, r, f), s[1] = li(t, a, d), o[0] = ui(e, r, f), o[1] = ui(t, a, d);
}
function kL(e, t, i, n, r, a, s, o, l) {
  var u = Na, c = Fa, h = Math.abs(r - a);
  if (h % pr < 1e-4 && h > 1e-4) {
    o[0] = e - i, o[1] = t - n, l[0] = e + i, l[1] = t + n;
    return;
  }
  if (wl[0] = Bh(r) * i + e, wl[1] = Fh(r) * n + t, Sl[0] = Bh(a) * i + e, Sl[1] = Fh(a) * n + t, u(o, wl, Sl), c(l, wl, Sl), r = r % pr, r < 0 && (r = r + pr), a = a % pr, a < 0 && (a = a + pr), r > a && !s ? a += pr : r < a && s && (r += pr), s) {
    var f = a;
    a = r, r = f;
  }
  for (var d = 0; d < a; d += Math.PI / 2)
    d > r && (Ml[0] = Bh(d) * i + e, Ml[1] = Fh(d) * n + t, u(o, Ml, o), c(l, Ml, l));
}
var Mt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, gr = [], mr = [], Oi = [], An = [], Ii = [], Ri = [], zh = Math.min, Vh = Math.max, yr = Math.cos, _r = Math.sin, en = Math.abs, hd = Math.PI, Rn = hd * 2, $h = typeof Float32Array < "u", Ms = [];
function Hh(e) {
  var t = Math.round(e / hd * 1e8) / 1e8;
  return t % 2 * hd;
}
function PL(e, t) {
  var i = Hh(e[0]);
  i < 0 && (i += Rn);
  var n = i - e[0], r = e[1];
  r += n, !t && r - i >= Rn ? r = i + Rn : t && i - r >= Rn ? r = i - Rn : !t && i > r ? r = i + (Rn - Hh(i - r)) : t && i < r && (r = i - (Rn - Hh(r - i))), e[0] = i, e[1] = r;
}
var rs = (function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, i, n) {
    n = n || 0, n > 0 && (this._ux = en(n / Eu / t) || 0, this._uy = en(n / Eu / i) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, i) {
    return this._drawPendingPt(), this.addData(Mt.M, t, i), this._ctx && this._ctx.moveTo(t, i), this._x0 = t, this._y0 = i, this._xi = t, this._yi = i, this;
  }, e.prototype.lineTo = function(t, i) {
    var n = en(t - this._xi), r = en(i - this._yi), a = n > this._ux || r > this._uy;
    if (this.addData(Mt.L, t, i), this._ctx && a && this._ctx.lineTo(t, i), a)
      this._xi = t, this._yi = i, this._pendingPtDist = 0;
    else {
      var s = n * n + r * r;
      s > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = i, this._pendingPtDist = s);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, i, n, r, a, s) {
    return this._drawPendingPt(), this.addData(Mt.C, t, i, n, r, a, s), this._ctx && this._ctx.bezierCurveTo(t, i, n, r, a, s), this._xi = a, this._yi = s, this;
  }, e.prototype.quadraticCurveTo = function(t, i, n, r) {
    return this._drawPendingPt(), this.addData(Mt.Q, t, i, n, r), this._ctx && this._ctx.quadraticCurveTo(t, i, n, r), this._xi = n, this._yi = r, this;
  }, e.prototype.arc = function(t, i, n, r, a, s) {
    this._drawPendingPt(), Ms[0] = r, Ms[1] = a, PL(Ms, s), r = Ms[0], a = Ms[1];
    var o = a - r;
    return this.addData(Mt.A, t, i, n, n, r, o, 0, s ? 0 : 1), this._ctx && this._ctx.arc(t, i, n, r, a, s), this._xi = yr(a) * n + t, this._yi = _r(a) * n + i, this;
  }, e.prototype.arcTo = function(t, i, n, r, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, i, n, r, a), this;
  }, e.prototype.rect = function(t, i, n, r) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, i, n, r), this.addData(Mt.R, t, i, n, r), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Mt.Z);
    var t = this._ctx, i = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = i, this._yi = n, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    if (this._saveData) {
      var i = t.length;
      !(this.data && this.data.length === i) && $h && (this.data = new Float32Array(i));
      for (var n = 0; n < i; n++)
        this.data[n] = t[n];
      this._len = i;
    }
  }, e.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var i = t.length, n = 0, r = this._len, a = 0; a < i; a++)
        n += t[a].len();
      var s = this.data;
      if ($h && (s instanceof Float32Array || !s) && (this.data = new Float32Array(r + n), r > 0 && s))
        for (var o = 0; o < r; o++)
          this.data[o] = s[o];
      for (var a = 0; a < i; a++)
        for (var l = t[a].data, o = 0; o < l.length; o++)
          this.data[r++] = l[o];
      this._len = r;
    }
  }, e.prototype.addData = function(t, i, n, r, a, s, o, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], i = 0; i < this._len; i++)
        t[i] = this.data[i];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, $h && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    Oi[0] = Oi[1] = Ii[0] = Ii[1] = Number.MAX_VALUE, An[0] = An[1] = Ri[0] = Ri[1] = -Number.MAX_VALUE;
    var t = this.data, i = 0, n = 0, r = 0, a = 0, s;
    for (s = 0; s < this._len; ) {
      var o = t[s++], l = s === 1;
      switch (l && (i = t[s], n = t[s + 1], r = i, a = n), o) {
        case Mt.M:
          i = r = t[s++], n = a = t[s++], Ii[0] = r, Ii[1] = a, Ri[0] = r, Ri[1] = a;
          break;
        case Mt.L:
          ey(i, n, t[s], t[s + 1], Ii, Ri), i = t[s++], n = t[s++];
          break;
        case Mt.C:
          DL(i, n, t[s++], t[s++], t[s++], t[s++], t[s], t[s + 1], Ii, Ri), i = t[s++], n = t[s++];
          break;
        case Mt.Q:
          CL(i, n, t[s++], t[s++], t[s], t[s + 1], Ii, Ri), i = t[s++], n = t[s++];
          break;
        case Mt.A:
          var u = t[s++], c = t[s++], h = t[s++], f = t[s++], d = t[s++], v = t[s++] + d;
          s += 1;
          var g = !t[s++];
          l && (r = yr(d) * h + u, a = _r(d) * f + c), kL(u, c, h, f, d, v, g, Ii, Ri), i = yr(v) * h + u, n = _r(v) * f + c;
          break;
        case Mt.R:
          r = i = t[s++], a = n = t[s++];
          var p = t[s++], m = t[s++];
          ey(r, a, r + p, a + m, Ii, Ri);
          break;
        case Mt.Z:
          i = r, n = a;
          break;
      }
      Na(Oi, Oi, Ii), Fa(An, An, Ri);
    }
    return s === 0 && (Oi[0] = Oi[1] = An[0] = An[1] = 0), new at(Oi[0], Oi[1], An[0] - Oi[0], An[1] - Oi[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, i = this._len, n = this._ux, r = this._uy, a = 0, s = 0, o = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, f = 0; f < i; ) {
      var d = t[f++], v = f === 1;
      v && (a = t[f], s = t[f + 1], o = a, l = s);
      var g = -1;
      switch (d) {
        case Mt.M:
          a = o = t[f++], s = l = t[f++];
          break;
        case Mt.L: {
          var p = t[f++], m = t[f++], y = p - a, _ = m - s;
          (en(y) > n || en(_) > r || f === i - 1) && (g = Math.sqrt(y * y + _ * _), a = p, s = m);
          break;
        }
        case Mt.C: {
          var b = t[f++], x = t[f++], p = t[f++], m = t[f++], w = t[f++], M = t[f++];
          g = jA(a, s, b, x, p, m, w, M, 10), a = w, s = M;
          break;
        }
        case Mt.Q: {
          var b = t[f++], x = t[f++], p = t[f++], m = t[f++];
          g = ZA(a, s, b, x, p, m, 10), a = p, s = m;
          break;
        }
        case Mt.A:
          var T = t[f++], D = t[f++], P = t[f++], C = t[f++], A = t[f++], E = t[f++], R = E + A;
          f += 1, v && (o = yr(A) * P + T, l = _r(A) * C + D), g = Vh(P, C) * zh(Rn, Math.abs(E)), a = yr(R) * P + T, s = _r(R) * C + D;
          break;
        case Mt.R: {
          o = a = t[f++], l = s = t[f++];
          var I = t[f++], N = t[f++];
          g = I * 2 + N * 2;
          break;
        }
        case Mt.Z: {
          var y = o - a, _ = l - s;
          g = Math.sqrt(y * y + _ * _), a = o, s = l;
          break;
        }
      }
      g >= 0 && (u[h++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, i) {
    var n = this.data, r = this._ux, a = this._uy, s = this._len, o, l, u, c, h, f, d = i < 1, v, g, p = 0, m = 0, y, _ = 0, b, x;
    if (!(d && (this._pathSegLen || this._calculateLength(), v = this._pathSegLen, g = this._pathLen, y = i * g, !y)))
      t: for (var w = 0; w < s; ) {
        var M = n[w++], T = w === 1;
        switch (T && (u = n[w], c = n[w + 1], o = u, l = c), M !== Mt.L && _ > 0 && (t.lineTo(b, x), _ = 0), M) {
          case Mt.M:
            o = u = n[w++], l = c = n[w++], t.moveTo(u, c);
            break;
          case Mt.L: {
            h = n[w++], f = n[w++];
            var D = en(h - u), P = en(f - c);
            if (D > r || P > a) {
              if (d) {
                var C = v[m++];
                if (p + C > y) {
                  var A = (y - p) / C;
                  t.lineTo(u * (1 - A) + h * A, c * (1 - A) + f * A);
                  break t;
                }
                p += C;
              }
              t.lineTo(h, f), u = h, c = f, _ = 0;
            } else {
              var E = D * D + P * P;
              E > _ && (b = h, x = f, _ = E);
            }
            break;
          }
          case Mt.C: {
            var R = n[w++], I = n[w++], N = n[w++], B = n[w++], $ = n[w++], H = n[w++];
            if (d) {
              var C = v[m++];
              if (p + C > y) {
                var A = (y - p) / C;
                Cu(u, R, N, $, A, gr), Cu(c, I, B, H, A, mr), t.bezierCurveTo(gr[1], mr[1], gr[2], mr[2], gr[3], mr[3]);
                break t;
              }
              p += C;
            }
            t.bezierCurveTo(R, I, N, B, $, H), u = $, c = H;
            break;
          }
          case Mt.Q: {
            var R = n[w++], I = n[w++], N = n[w++], B = n[w++];
            if (d) {
              var C = v[m++];
              if (p + C > y) {
                var A = (y - p) / C;
                ku(u, R, N, A, gr), ku(c, I, B, A, mr), t.quadraticCurveTo(gr[1], mr[1], gr[2], mr[2]);
                break t;
              }
              p += C;
            }
            t.quadraticCurveTo(R, I, N, B), u = N, c = B;
            break;
          }
          case Mt.A:
            var G = n[w++], nt = n[w++], K = n[w++], pt = n[w++], gt = n[w++], Ht = n[w++], ht = n[w++], le = !n[w++], De = K > pt ? K : pt, de = en(K - pt) > 1e-3, Zt = gt + Ht, it = !1;
            if (d) {
              var C = v[m++];
              p + C > y && (Zt = gt + Ht * (y - p) / C, it = !0), p += C;
            }
            if (de && t.ellipse ? t.ellipse(G, nt, K, pt, ht, gt, Zt, le) : t.arc(G, nt, De, gt, Zt, le), it)
              break t;
            T && (o = yr(gt) * K + G, l = _r(gt) * pt + nt), u = yr(Zt) * K + G, c = _r(Zt) * pt + nt;
            break;
          case Mt.R:
            o = u = n[w], l = c = n[w + 1], h = n[w++], f = n[w++];
            var yt = n[w++], rr = n[w++];
            if (d) {
              var C = v[m++];
              if (p + C > y) {
                var Ce = y - p;
                t.moveTo(h, f), t.lineTo(h + zh(Ce, yt), f), Ce -= yt, Ce > 0 && t.lineTo(h + yt, f + zh(Ce, rr)), Ce -= rr, Ce > 0 && t.lineTo(h + Vh(yt - Ce, 0), f + rr), Ce -= yt, Ce > 0 && t.lineTo(h, f + Vh(rr - Ce, 0));
                break t;
              }
              p += C;
            }
            t.rect(h, f, yt, rr);
            break;
          case Mt.Z:
            if (d) {
              var C = v[m++];
              if (p + C > y) {
                var A = (y - p) / C;
                t.lineTo(u * (1 - A) + o * A, c * (1 - A) + l * A);
                break t;
              }
              p += C;
            }
            t.closePath(), u = o, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), i = this.data;
    return t.data = i.slice ? i.slice() : Array.prototype.slice.call(i), t._len = this._len, t;
  }, e.prototype.canSave = function() {
    return !!this._saveData;
  }, e.CMD = Mt, e.initDefaultProps = (function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  })(), e;
})();
function _a(e, t, i, n, r, a, s) {
  if (r === 0)
    return !1;
  var o = r, l = 0, u = e;
  if (s > t + o && s > n + o || s < t - o && s < n - o || a > e + o && a > i + o || a < e - o && a < i - o)
    return !1;
  if (e !== i)
    l = (t - n) / (e - i), u = (e * n - i * t) / (e - i);
  else
    return Math.abs(a - e) <= o / 2;
  var c = l * a - s + u, h = c * c / (l * l + 1);
  return h <= o / 2 * o / 2;
}
function AL(e, t, i, n, r, a, s, o, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > t + h && c > n + h && c > a + h && c > o + h || c < t - h && c < n - h && c < a - h && c < o - h || u > e + h && u > i + h && u > r + h && u > s + h || u < e - h && u < i - h && u < r - h && u < s - h)
    return !1;
  var f = GA(e, t, i, n, r, a, s, o, u, c);
  return f <= h / 2;
}
function EL(e, t, i, n, r, a, s, o, l) {
  if (s === 0)
    return !1;
  var u = s;
  if (l > t + u && l > n + u && l > a + u || l < t - u && l < n - u && l < a - u || o > e + u && o > i + u && o > r + u || o < e - u && o < i - u && o < r - u)
    return !1;
  var c = qA(e, t, i, n, r, a, o, l);
  return c <= u / 2;
}
var ry = Math.PI * 2;
function Tl(e) {
  return e %= ry, e < 0 && (e += ry), e;
}
var Ts = Math.PI * 2;
function LL(e, t, i, n, r, a, s, o, l) {
  if (s === 0)
    return !1;
  var u = s;
  o -= e, l -= t;
  var c = Math.sqrt(o * o + l * l);
  if (c - u > i || c + u < i)
    return !1;
  if (Math.abs(n - r) % Ts < 1e-4)
    return !0;
  if (a) {
    var h = n;
    n = Tl(r), r = Tl(h);
  } else
    n = Tl(n), r = Tl(r);
  n > r && (r += Ts);
  var f = Math.atan2(l, o);
  return f < 0 && (f += Ts), f >= n && f <= r || f + Ts >= n && f + Ts <= r;
}
function br(e, t, i, n, r, a) {
  if (a > t && a > n || a < t && a < n || n === t)
    return 0;
  var s = (a - t) / (n - t), o = n < t ? 1 : -1;
  (s === 1 || s === 0) && (o = n < t ? 0.5 : -0.5);
  var l = s * (i - e) + e;
  return l === r ? 1 / 0 : l > r ? o : 0;
}
var En = rs.CMD, xr = Math.PI * 2, OL = 1e-4;
function IL(e, t) {
  return Math.abs(e - t) < OL;
}
var ke = [-1, -1, -1], ai = [-1, -1];
function RL() {
  var e = ai[0];
  ai[0] = ai[1], ai[1] = e;
}
function NL(e, t, i, n, r, a, s, o, l, u) {
  if (u > t && u > n && u > a && u > o || u < t && u < n && u < a && u < o)
    return 0;
  var c = r1(t, n, a, o, u, ke);
  if (c === 0)
    return 0;
  for (var h = 0, f = -1, d = void 0, v = void 0, g = 0; g < c; g++) {
    var p = ke[g], m = p === 0 || p === 1 ? 0.5 : 1, y = Pe(e, i, r, s, p);
    y < l || (f < 0 && (f = a1(t, n, a, o, ai), ai[1] < ai[0] && f > 1 && RL(), d = Pe(t, n, a, o, ai[0]), f > 1 && (v = Pe(t, n, a, o, ai[1]))), f === 2 ? p < ai[0] ? h += d < t ? m : -m : p < ai[1] ? h += v < d ? m : -m : h += o < v ? m : -m : p < ai[0] ? h += d < t ? m : -m : h += o < d ? m : -m);
  }
  return h;
}
function FL(e, t, i, n, r, a, s, o) {
  if (o > t && o > n && o > a || o < t && o < n && o < a)
    return 0;
  var l = XA(t, n, a, o, ke);
  if (l === 0)
    return 0;
  var u = s1(t, n, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = Be(t, n, a, u), f = 0; f < l; f++) {
      var d = ke[f] === 0 || ke[f] === 1 ? 0.5 : 1, v = Be(e, i, r, ke[f]);
      v < s || (ke[f] < u ? c += h < t ? d : -d : c += a < h ? d : -d);
    }
    return c;
  } else {
    var d = ke[0] === 0 || ke[0] === 1 ? 0.5 : 1, v = Be(e, i, r, ke[0]);
    return v < s ? 0 : a < t ? d : -d;
  }
}
function BL(e, t, i, n, r, a, s, o) {
  if (o -= t, o > i || o < -i)
    return 0;
  var l = Math.sqrt(i * i - o * o);
  ke[0] = -l, ke[1] = l;
  var u = Math.abs(n - r);
  if (u < 1e-4)
    return 0;
  if (u >= xr - 1e-4) {
    n = 0, r = xr;
    var c = a ? 1 : -1;
    return s >= ke[0] + e && s <= ke[1] + e ? c : 0;
  }
  if (n > r) {
    var h = n;
    n = r, r = h;
  }
  n < 0 && (n += xr, r += xr);
  for (var f = 0, d = 0; d < 2; d++) {
    var v = ke[d];
    if (v + e > s) {
      var g = Math.atan2(o, v), c = a ? 1 : -1;
      g < 0 && (g = xr + g), (g >= n && g <= r || g + xr >= n && g + xr <= r) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), f += c);
    }
  }
  return f;
}
function O1(e, t, i, n, r) {
  for (var a = e.data, s = e.len(), o = 0, l = 0, u = 0, c = 0, h = 0, f, d, v = 0; v < s; ) {
    var g = a[v++], p = v === 1;
    switch (g === En.M && v > 1 && (i || (o += br(l, u, c, h, n, r))), p && (l = a[v], u = a[v + 1], c = l, h = u), g) {
      case En.M:
        c = a[v++], h = a[v++], l = c, u = h;
        break;
      case En.L:
        if (i) {
          if (_a(l, u, a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += br(l, u, a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case En.C:
        if (i) {
          if (AL(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += NL(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case En.Q:
        if (i) {
          if (EL(l, u, a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += FL(l, u, a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case En.A:
        var m = a[v++], y = a[v++], _ = a[v++], b = a[v++], x = a[v++], w = a[v++];
        v += 1;
        var M = !!(1 - a[v++]);
        f = Math.cos(x) * _ + m, d = Math.sin(x) * b + y, p ? (c = f, h = d) : o += br(l, u, f, d, n, r);
        var T = (n - m) * b / _ + m;
        if (i) {
          if (LL(m, y, b, x, x + w, M, t, T, r))
            return !0;
        } else
          o += BL(m, y, b, x, x + w, M, T, r);
        l = Math.cos(x + w) * _ + m, u = Math.sin(x + w) * b + y;
        break;
      case En.R:
        c = l = a[v++], h = u = a[v++];
        var D = a[v++], P = a[v++];
        if (f = c + D, d = h + P, i) {
          if (_a(c, h, f, h, t, n, r) || _a(f, h, f, d, t, n, r) || _a(f, d, c, d, t, n, r) || _a(c, d, c, h, t, n, r))
            return !0;
        } else
          o += br(f, h, f, d, n, r), o += br(c, d, c, h, n, r);
        break;
      case En.Z:
        if (i) {
          if (_a(l, u, c, h, t, n, r))
            return !0;
        } else
          o += br(l, u, c, h, n, r);
        l = c, u = h;
        break;
    }
  }
  return !i && !IL(u, h) && (o += br(l, u, c, h, n, r) || 0), o !== 0;
}
function zL(e, t, i) {
  return O1(e, 0, !1, t, i);
}
function VL(e, t, i, n) {
  return O1(e, t, !0, i, n);
}
var I1 = Qt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, Qr), $L = {
  style: Qt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, Cc.style)
}, Yh = Do.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), It = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.update = function() {
    var i = this;
    e.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var r = this._decalEl = this._decalEl || new t();
      r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
        i.buildPath(l, i.shape);
      }), r.silent = !0;
      var a = r.style;
      for (var s in n)
        a[s] !== n[s] && (a[s] = n[s]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var o = 0; o < Yh.length; ++o)
        r[Yh[o]] = this[Yh[o]];
      r.__dirty |= Xe;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(i) {
    var n = jt(i);
    this.shape = this.getDefaultShape();
    var r = this.getDefaultStyle();
    r && this.useStyle(r);
    for (var a = 0; a < n.length; a++) {
      var s = n[a], o = i[s];
      s === "style" ? this.style ? Y(this.style, o) : this.useStyle(o) : s === "shape" ? Y(this.shape, o) : e.prototype.attrKV.call(this, s, o);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var i = this.style.fill;
    if (i !== "none") {
      if (Q(i)) {
        var n = Au(i, 0);
        return n > 0.5 ? ad : n > 0.2 ? yE : sd;
      } else if (i)
        return sd;
    }
    return ad;
  }, t.prototype.getInsideTextStroke = function(i) {
    var n = this.style.fill;
    if (Q(n)) {
      var r = this.__zr, a = !!(r && r.isDarkMode()), s = Au(i, 0) < rd;
      if (a === s)
        return n;
    }
  }, t.prototype.buildPath = function(i, n, r) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~Ia;
  }, t.prototype.getUpdatedPathProxy = function(i) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, i), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new rs(!1);
  }, t.prototype.hasStroke = function() {
    var i = this.style, n = i.stroke;
    return !(n == null || n === "none" || !(i.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var i = this._rect, n = this.style, r = !i;
    if (r) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var s = this.path;
      (a || this.__dirty & Ia) && (s.beginPath(), this.buildPath(s, this.shape, !1), this.pathUpdated()), i = s.getBoundingRect();
    }
    if (this._rect = i, this.hasStroke() && this.path && this.path.len() > 0) {
      var o = this._rectStroke || (this._rectStroke = i.clone());
      if (this.__dirty || r) {
        o.copy(i);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (o.width += u / l, o.height += u / l, o.x -= u / l / 2, o.y -= u / l / 2);
      }
      return o;
    }
    return i;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect(), s = this.style;
    if (i = r[0], n = r[1], a.contain(i, n)) {
      var o = this.path;
      if (this.hasStroke()) {
        var l = s.lineWidth, u = s.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), VL(o, l / u, i, n)))
          return !0;
      }
      if (this.hasFill())
        return zL(o, i, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= Ia, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(i) {
    return this.animate("shape", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : i === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i === "shape" ? this.setShape(n) : e.prototype.attrKV.call(this, i, n);
  }, t.prototype.setShape = function(i, n) {
    var r = this.shape;
    return r || (r = this.shape = {}), typeof i == "string" ? r[i] = n : Y(r, i), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & Ia);
  }, t.prototype.createStyle = function(i) {
    return xc(I1, i);
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.shape && !n.shape && (n.shape = Y({}, this.shape));
  }, t.prototype._applyStateObj = function(i, n, r, a, s, o) {
    e.prototype._applyStateObj.call(this, i, n, r, a, s, o);
    var l = !(n && a), u;
    if (n && n.shape ? s ? a ? u = n.shape : (u = Y({}, r.shape), Y(u, n.shape)) : (u = Y({}, a ? this.shape : r.shape), Y(u, n.shape)) : l && (u = r.shape), u)
      if (s) {
        this.shape = Y({}, this.shape);
        for (var c = {}, h = jt(u), f = 0; f < h.length; f++) {
          var d = h[f];
          typeof u[d] == "object" ? this.shape[d] = u[d] : c[d] = u[d];
        }
        this._transitionState(i, {
          shape: c
        }, o);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var s = i[a];
      s.shape && (r = r || {}, this._mergeStyle(r, s.shape));
    }
    return r && (n.shape = r), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return $L;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(i) {
    var n = (function(a) {
      At(s, a);
      function s(o) {
        var l = a.call(this, o) || this;
        return i.init && i.init.call(l, o), l;
      }
      return s.prototype.getDefaultStyle = function() {
        return dt(i.style);
      }, s.prototype.getDefaultShape = function() {
        return dt(i.shape);
      }, s;
    })(t);
    for (var r in i)
      typeof i[r] == "function" && (n.prototype[r] = i[r]);
    return n;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "path", i.strokeContainThreshold = 5, i.segmentIgnoreThreshold = 0, i.subPixelOptimize = !1, i.autoBatch = !1, i.__dirty = Xe | qs | Ia;
  })(), t;
})(Xo), HL = Qt({
  strokeFirst: !0,
  font: Qn,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, I1), Ru = (function(e) {
  At(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return L1(this.style);
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(i) {
    return xc(HL, i);
  }, t.prototype.setBoundingRect = function(i) {
    this._rect = i;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = SL(this.style)), this._rect;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.dirtyRectTolerance = 10;
  })(), t;
})(Xo);
Ru.prototype.type = "tspan";
var YL = Qt({
  x: 0,
  y: 0
}, Qr), WL = {
  style: Qt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, Cc.style)
};
function UL(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var oa = (function(e) {
  At(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(i) {
    return xc(YL, i);
  }, t.prototype._getSize = function(i) {
    var n = this.style, r = n[i];
    if (r != null)
      return r;
    var a = UL(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var s = i === "width" ? "height" : "width", o = n[s];
    return o == null ? a[i] : a[i] / a[s] * o;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return WL;
  }, t.prototype.getBoundingRect = function() {
    var i = this.style;
    return this._rect || (this._rect = new at(i.x || 0, i.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
})(Xo);
oa.prototype.type = "image";
function GL(e, t) {
  var i = t.x, n = t.y, r = t.width, a = t.height, s = t.r, o, l, u, c;
  r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), typeof s == "number" ? o = l = u = c = s : s instanceof Array ? s.length === 1 ? o = l = u = c = s[0] : s.length === 2 ? (o = u = s[0], l = c = s[1]) : s.length === 3 ? (o = s[0], l = c = s[1], u = s[2]) : (o = s[0], l = s[1], u = s[2], c = s[3]) : o = l = u = c = 0;
  var h;
  o + l > r && (h = o + l, o *= r / h, l *= r / h), u + c > r && (h = u + c, u *= r / h, c *= r / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), o + c > a && (h = o + c, o *= a / h, c *= a / h), e.moveTo(i + o, n), e.lineTo(i + r - l, n), l !== 0 && e.arc(i + r - l, n + l, l, -Math.PI / 2, 0), e.lineTo(i + r, n + a - u), u !== 0 && e.arc(i + r - u, n + a - u, u, 0, Math.PI / 2), e.lineTo(i + c, n + a), c !== 0 && e.arc(i + c, n + a - c, c, Math.PI / 2, Math.PI), e.lineTo(i, n + o), o !== 0 && e.arc(i + o, n + o, o, Math.PI, Math.PI * 1.5);
}
var Va = Math.round;
function R1(e, t, i) {
  if (t) {
    var n = t.x1, r = t.x2, a = t.y1, s = t.y2;
    e.x1 = n, e.x2 = r, e.y1 = a, e.y2 = s;
    var o = i && i.lineWidth;
    return o && (Va(n * 2) === Va(r * 2) && (e.x1 = e.x2 = $r(n, o, !0)), Va(a * 2) === Va(s * 2) && (e.y1 = e.y2 = $r(a, o, !0))), e;
  }
}
function N1(e, t, i) {
  if (t) {
    var n = t.x, r = t.y, a = t.width, s = t.height;
    e.x = n, e.y = r, e.width = a, e.height = s;
    var o = i && i.lineWidth;
    return o && (e.x = $r(n, o, !0), e.y = $r(r, o, !0), e.width = Math.max($r(n + a, o, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max($r(r + s, o, !1) - e.y, s === 0 ? 0 : 1)), e;
  }
}
function $r(e, t, i) {
  if (!t)
    return e;
  var n = Va(e * 2);
  return (n + Va(t)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
}
var jL = /* @__PURE__ */ (function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
})(), XL = {}, xe = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new jL();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, s, o;
    if (this.subPixelOptimize) {
      var l = N1(XL, n, this.style);
      r = l.x, a = l.y, s = l.width, o = l.height, l.r = n.r, n = l;
    } else
      r = n.x, a = n.y, s = n.width, o = n.height;
    n.r ? GL(i, n) : i.rect(r, a, s, o);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
})(It);
xe.prototype.type = "rect";
var ay = {
  fill: "#000"
}, sy = 2, Ni = {}, qL = {
  style: Qt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, Cc.style)
}, vi = (function(e) {
  At(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = ay, n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var i = this.innerTransformable;
    i ? (i.updateTransform(), i.transform && (this.transform = i.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(i) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(i) : e.prototype.getLocalTransform.call(this, i);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, tO(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = i;
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var i = new at(0, 0, 0, 0), n = this._children, r = [], a = null, s = 0; s < n.length; s++) {
        var o = n[s], l = o.getBoundingRect(), u = o.getLocalTransform(r);
        u ? (i.copy(l), i.applyTransform(u), a = a || i.clone(), a.union(i)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || i;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(i) {
    this._defaultStyle = i || ay;
  }, t.prototype.setTextContent = function(i) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(i, n) {
    if (!n)
      return i;
    var r = n.rich, a = i.rich || r && {};
    return Y(i, n), r && a ? (this._mergeRich(a, r), i.rich = a) : a && (i.rich = a), i;
  }, t.prototype._mergeRich = function(i, n) {
    for (var r = jt(n), a = 0; a < r.length; a++) {
      var s = r[a];
      i[s] = i[s] || {}, Y(i[s], n[s]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return qL;
  }, t.prototype._getOrCreateChild = function(i) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof i)) && (n = new i()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var i = this.style, n = i.font || Qn, r = i.padding, a = this._defaultStyle, s = i.x || 0, o = i.y || 0, l = i.align || a.align || "left", u = i.verticalAlign || a.verticalAlign || "top";
    Km(Ni, a.overflowRect, s, o, l, u), s = Ni.baseX, o = Ni.baseY;
    var c = dy(i), h = gL(c, i, Ni.outerWidth, Ni.outerHeight), f = Wh(i), d = !!i.backgroundColor, v = h.outerHeight, g = h.outerWidth, p = h.lines, m = h.lineHeight;
    this.isTruncated = !!h.isTruncated;
    var y = s, _ = Kr(o, h.contentHeight, u);
    if (f || r) {
      var b = is(s, g, l), x = Kr(o, v, u);
      f && this._renderBackground(i, i, b, x, g, v);
    }
    _ += m / 2, r && (y = fy(s, l, r), u === "top" ? _ += r[0] : u === "bottom" && (_ -= r[2]));
    for (var w = 0, M = !1, T = !1, D = hy("fill" in i ? i.fill : (T = !0, a.fill)), P = cy("stroke" in i ? i.stroke : !d && (!a.autoStroke || T) ? (w = sy, M = !0, a.stroke) : null), C = i.textShadowBlur > 0, A = 0; A < p.length; A++) {
      var E = this._getOrCreateChild(Ru), R = E.createStyle();
      E.useStyle(R), R.text = p[A], R.x = y, R.y = _, R.textAlign = l, R.textBaseline = "middle", R.opacity = i.opacity, R.strokeFirst = !0, C && (R.shadowBlur = i.textShadowBlur || 0, R.shadowColor = i.textShadowColor || "transparent", R.shadowOffsetX = i.textShadowOffsetX || 0, R.shadowOffsetY = i.textShadowOffsetY || 0), R.stroke = P, R.fill = D, P && (R.lineWidth = i.lineWidth || w, R.lineDash = i.lineDash, R.lineDashOffset = i.lineDashOffset || 0), R.font = n, ly(R, i), _ += m, E.setBoundingRect(ud(R, h.contentWidth, h.calculatedLineHeight, M ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var i = this.style, n = this._defaultStyle, r = i.align || n.align, a = i.verticalAlign || n.verticalAlign, s = i.x || 0, o = i.y || 0;
    Km(Ni, n.overflowRect, s, o, r, a), s = Ni.baseX, o = Ni.baseY;
    var l = dy(i), u = _L(l, i, Ni.outerWidth, Ni.outerHeight, r), c = u.width, h = u.outerWidth, f = u.outerHeight, d = i.padding;
    this.isTruncated = !!u.isTruncated;
    var v = is(s, h, r), g = Kr(o, f, a), p = v, m = g;
    d && (p += d[3], m += d[0]);
    var y = p + c;
    Wh(i) && this._renderBackground(i, i, v, g, h, f);
    for (var _ = !!i.backgroundColor, b = 0; b < u.lines.length; b++) {
      for (var x = u.lines[b], w = x.tokens, M = w.length, T = x.lineHeight, D = x.width, P = 0, C = p, A = y, E = M - 1, R = void 0; P < M && (R = w[P], !R.align || R.align === "left"); )
        this._placeToken(R, i, T, m, C, "left", _), D -= R.width, C += R.width, P++;
      for (; E >= 0 && (R = w[E], R.align === "right"); )
        this._placeToken(R, i, T, m, A, "right", _), D -= R.width, A -= R.width, E--;
      for (C += (c - (C - p) - (y - A) - D) / 2; P <= E; )
        R = w[P], this._placeToken(R, i, T, m, C + R.width / 2, "center", _), C += R.width, P++;
      m += T;
    }
  }, t.prototype._placeToken = function(i, n, r, a, s, o, l) {
    var u = n.rich[i.styleName] || {};
    u.text = i.text;
    var c = i.verticalAlign, h = a + r / 2;
    c === "top" ? h = a + i.height / 2 : c === "bottom" && (h = a + r - i.height / 2);
    var f = !i.isLineHolder && Wh(u);
    f && this._renderBackground(u, n, o === "right" ? s - i.width : o === "center" ? s - i.width / 2 : s, h - i.height / 2, i.width, i.height);
    var d = !!u.backgroundColor, v = i.textPadding;
    v && (s = fy(s, o, v), h -= i.height / 2 - v[0] - i.innerHeight / 2);
    var g = this._getOrCreateChild(Ru), p = g.createStyle();
    g.useStyle(p);
    var m = this._defaultStyle, y = !1, _ = 0, b = !1, x = hy("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, m.fill)), w = cy("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !d && !l && (!m.autoStroke || y) ? (_ = sy, b = !0, m.stroke) : null), M = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    p.text = i.text, p.x = s, p.y = h, M && (p.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, p.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), p.textAlign = o, p.textBaseline = "middle", p.font = i.font || Qn, p.opacity = Xr(u.opacity, n.opacity, 1), ly(p, u), w && (p.lineWidth = Xr(u.lineWidth, n.lineWidth, _), p.lineDash = et(u.lineDash, n.lineDash), p.lineDashOffset = n.lineDashOffset || 0, p.stroke = w), x && (p.fill = x), g.setBoundingRect(ud(p, i.contentWidth, i.contentHeight, b ? 0 : null));
  }, t.prototype._renderBackground = function(i, n, r, a, s, o) {
    var l = i.backgroundColor, u = i.borderWidth, c = i.borderColor, h = l && l.image, f = l && !h, d = i.borderRadius, v = this, g, p;
    if (f || i.lineHeight || u && c) {
      g = this._getOrCreateChild(xe), g.useStyle(g.createStyle()), g.style.fill = null;
      var m = g.shape;
      m.x = r, m.y = a, m.width = s, m.height = o, m.r = d, g.dirtyShape();
    }
    if (f) {
      var y = g.style;
      y.fill = l || null, y.fillOpacity = et(i.fillOpacity, 1);
    } else if (h) {
      p = this._getOrCreateChild(oa), p.onload = function() {
        v.dirtyStyle();
      };
      var _ = p.style;
      _.image = l.image, _.x = r, _.y = a, _.width = s, _.height = o;
    }
    if (u && c) {
      var y = g.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = et(i.strokeOpacity, 1), y.lineDash = i.borderDash, y.lineDashOffset = i.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var b = (g || p).style;
    b.shadowBlur = i.shadowBlur || 0, b.shadowColor = i.shadowColor || "transparent", b.shadowOffsetX = i.shadowOffsetX || 0, b.shadowOffsetY = i.shadowOffsetY || 0, b.opacity = Xr(i.opacity, n.opacity, 1);
  }, t.makeFont = function(i) {
    var n = "";
    return JL(i) && (n = [
      i.fontStyle,
      i.fontWeight,
      QL(i.fontSize),
      i.fontFamily || "sans-serif"
    ].join(" ")), n && Hi(n) || i.textFont || i.font;
  }, t;
})(Xo), ZL = { left: !0, right: 1, center: 1 }, KL = { top: 1, bottom: 1, middle: 1 }, oy = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function QL(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? pv + "px" : e + "px";
}
function ly(e, t) {
  for (var i = 0; i < oy.length; i++) {
    var n = oy[i], r = t[n];
    r != null && (e[n] = r);
  }
}
function JL(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function tO(e) {
  return uy(e), k(e.rich, uy), e;
}
function uy(e) {
  if (e) {
    e.font = vi.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || ZL[t] ? t : "left";
    var i = e.verticalAlign;
    i === "center" && (i = "middle"), e.verticalAlign = i == null || KL[i] ? i : "top";
    var n = e.padding;
    n && (e.padding = _v(e.padding));
  }
}
function cy(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function hy(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function fy(e, t, i) {
  return t === "right" ? e - i[1] : t === "center" ? e + i[3] / 2 - i[1] / 2 : e + i[3];
}
function dy(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function Wh(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
var Ft = Wt(), eO = function(e, t, i, n) {
  if (n) {
    var r = Ft(n);
    r.dataIndex = i, r.dataType = t, r.seriesIndex = e, r.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var s = Ft(a);
      s.seriesIndex = e, s.dataIndex = i, s.dataType = t, s.ssrType = "chart";
    });
  }
}, vy = 1, py = {}, F1 = Wt(), Pv = Wt(), B1 = 0, Av = 1, Ev = 2, tr = ["emphasis", "blur", "select"], gy = ["normal", "emphasis", "blur", "select"], iO = 10, nO = 9, Jr = "highlight", ru = "downplay", Nu = "select", fd = "unselect", Fu = "toggleSelect", Lv = "selectchanged";
function ba(e) {
  return e != null && e !== "none";
}
function kc(e, t, i) {
  e.onHoverStateChange && (e.hoverState || 0) !== i && e.onHoverStateChange(t), e.hoverState = i;
}
function z1(e) {
  kc(e, "emphasis", Ev);
}
function V1(e) {
  e.hoverState === Ev && kc(e, "normal", B1);
}
function Ov(e) {
  kc(e, "blur", Av);
}
function $1(e) {
  e.hoverState === Av && kc(e, "normal", B1);
}
function rO(e) {
  e.selected = !0;
}
function aO(e) {
  e.selected = !1;
}
function my(e, t, i) {
  t(e, i);
}
function Cn(e, t, i) {
  my(e, t, i), e.isGroup && e.traverse(function(n) {
    my(n, t, i);
  });
}
function sO(e, t, i, n) {
  for (var r = e.style, a = {}, s = 0; s < t.length; s++) {
    var o = t[s], l = r[o];
    a[o] = l ?? (n && n[o]);
  }
  for (var s = 0; s < e.animators.length; s++) {
    var u = e.animators[s];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(i) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function oO(e, t, i, n) {
  var r = i && Bt(i, "select") >= 0, a = !1;
  if (e instanceof It) {
    var s = F1(e), o = r && s.selectFill || s.normalFill, l = r && s.selectStroke || s.normalStroke;
    if (ba(o) || ba(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = Y({}, n), u = Y({}, u), u.fill = o) : !ba(u.fill) && ba(o) ? (a = !0, n = Y({}, n), u = Y({}, u), u.fill = Pm(o)) : !ba(u.stroke) && ba(l) && (a || (n = Y({}, n), u = Y({}, u)), u.stroke = Pm(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = Y({}, n));
    var c = e.z2EmphasisLift;
    n.z2 = e.z2 + (c ?? iO);
  }
  return n;
}
function lO(e, t, i) {
  if (i && i.z2 == null) {
    i = Y({}, i);
    var n = e.z2SelectLift;
    i.z2 = e.z2 + (n ?? nO);
  }
  return i;
}
function uO(e, t, i) {
  var n = Bt(e.currentStates, t) >= 0, r = e.style.opacity, a = n ? null : sO(e, ["opacity"], t, {
    opacity: 1
  });
  i = i || {};
  var s = i.style || {};
  return s.opacity == null && (i = Y({}, i), s = Y({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? r : a.opacity * 0.1
  }, s), i.style = s), i;
}
function Uh(e, t) {
  var i = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return oO(this, e, t, i);
    if (e === "blur")
      return uO(this, e, i);
    if (e === "select")
      return lO(this, e, i);
  }
  return i;
}
function cO(e) {
  e.stateProxy = Uh;
  var t = e.getTextContent(), i = e.getTextGuideLine();
  t && (t.stateProxy = Uh), i && (i.stateProxy = Uh);
}
function yy(e, t) {
  !U1(e, t) && !e.__highByOuter && Cn(e, z1);
}
function _y(e, t) {
  !U1(e, t) && !e.__highByOuter && Cn(e, V1);
}
function Bu(e, t) {
  e.__highByOuter |= 1 << (t || 0), Cn(e, z1);
}
function zu(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && Cn(e, V1);
}
function hO(e) {
  Cn(e, Ov);
}
function H1(e) {
  Cn(e, $1);
}
function Y1(e) {
  Cn(e, rO);
}
function W1(e) {
  Cn(e, aO);
}
function U1(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function G1(e) {
  var t = e.getModel(), i = [], n = [];
  t.eachComponent(function(r, a) {
    var s = Pv(a), o = r === "series", l = o ? e.getViewOfSeriesModel(a) : e.getViewOfComponentModel(a);
    !o && n.push(l), s.isBlured && (l.group.traverse(function(u) {
      $1(u);
    }), o && i.push(a)), s.isBlured = !1;
  }), k(n, function(r) {
    r && r.toggleBlurSeries && r.toggleBlurSeries(i, !1, t);
  });
}
function dd(e, t, i, n) {
  var r = n.getModel();
  i = i || "coordinateSystem";
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var f = u.getItemGraphicEl(c[h]);
      f && H1(f);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var s = r.getSeriesByIndex(e), o = s.coordinateSystem;
    o && o.master && (o = o.master);
    var l = [];
    r.eachSeries(function(u) {
      var c = s === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var f = h && o ? h === o : c;
      if (!// Not blur other series if blurScope series
      (i === "series" && !c || i === "coordinateSystem" && !f || t === "series" && c)) {
        var d = n.getViewOfSeriesModel(u);
        if (d.group.traverse(function(p) {
          p.__highByOuter && c && t === "self" || Ov(p);
        }), Ye(t))
          a(u.getData(), t);
        else if (q(t))
          for (var v = jt(t), g = 0; g < v.length; g++)
            a(u.getData(v[g]), t[v[g]]);
        l.push(u), Pv(u).isBlured = !0;
      }
    }), r.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = n.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, r);
      }
    });
  }
}
function vd(e, t, i) {
  if (!(e == null || t == null)) {
    var n = i.getModel().getComponent(e, t);
    if (n) {
      Pv(n).isBlured = !0;
      var r = i.getViewOfComponentModel(n);
      !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
        Ov(a);
      });
    }
  }
}
function fO(e, t, i) {
  var n = e.seriesIndex, r = e.getData(t.dataType);
  if (!r) {
    process.env.NODE_ENV !== "production" && qt("Unknown dataType " + t.dataType);
    return;
  }
  var a = Go(r, t);
  a = (j(a) ? a[0] : a) || 0;
  var s = r.getItemGraphicEl(a);
  if (!s)
    for (var o = r.count(), l = 0; !s && l < o; )
      s = r.getItemGraphicEl(l++);
  if (s) {
    var u = Ft(s);
    dd(n, u.focus, u.blurScope, i);
  } else {
    var c = e.get(["emphasis", "focus"]), h = e.get(["emphasis", "blurScope"]);
    c != null && dd(n, c, h, i);
  }
}
function Iv(e, t, i, n) {
  var r = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || i == null)
    return r;
  var a = n.getModel().getComponent(e, t);
  if (!a)
    return r;
  var s = n.getViewOfComponentModel(a);
  if (!s || !s.findHighDownDispatchers)
    return r;
  for (var o = s.findHighDownDispatchers(i), l, u = 0; u < o.length; u++)
    if (process.env.NODE_ENV !== "production" && !as(o[u]) && qt("param should be highDownDispatcher"), Ft(o[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: o
  };
}
function dO(e, t, i) {
  process.env.NODE_ENV !== "production" && !as(e) && qt("param should be highDownDispatcher");
  var n = Ft(e), r = Iv(n.componentMainType, n.componentIndex, n.componentHighDownName, i), a = r.dispatchers, s = r.focusSelf;
  a ? (s && vd(n.componentMainType, n.componentIndex, i), k(a, function(o) {
    return yy(o, t);
  })) : (dd(n.seriesIndex, n.focus, n.blurScope, i), n.focus === "self" && vd(n.componentMainType, n.componentIndex, i), yy(e, t));
}
function vO(e, t, i) {
  process.env.NODE_ENV !== "production" && !as(e) && qt("param should be highDownDispatcher"), G1(i);
  var n = Ft(e), r = Iv(n.componentMainType, n.componentIndex, n.componentHighDownName, i).dispatchers;
  r ? k(r, function(a) {
    return _y(a, t);
  }) : _y(e, t);
}
function pO(e, t, i) {
  if (pd(t)) {
    var n = t.dataType, r = e.getData(n), a = Go(r, t);
    j(a) || (a = [a]), e[t.type === Fu ? "toggleSelect" : t.type === Nu ? "select" : "unselect"](a, n);
  }
}
function by(e) {
  var t = e.getAllData();
  k(t, function(i) {
    var n = i.data, r = i.type;
    n.eachItemGraphicEl(function(a, s) {
      e.isSelected(s, r) ? Y1(a) : W1(a);
    });
  });
}
function gO(e) {
  var t = [];
  return e.eachSeries(function(i) {
    var n = i.getAllData();
    k(n, function(r) {
      r.data;
      var a = r.type, s = i.getSelectedDataIndices();
      if (s.length > 0) {
        var o = {
          dataIndex: s,
          seriesIndex: i.seriesIndex
        };
        a != null && (o.dataType = a), t.push(o);
      }
    });
  }), t;
}
function mO(e, t, i) {
  j1(e, !0), Cn(e, cO), _O(e, t, i);
}
function yO(e) {
  j1(e, !1);
}
function xy(e, t, i, n) {
  n ? yO(e) : mO(e, t, i);
}
function _O(e, t, i) {
  var n = Ft(e);
  t != null ? (n.focus = t, n.blurScope = i) : n.focus && (n.focus = null);
}
var wy = ["emphasis", "blur", "select"], bO = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function Sy(e, t, i, n) {
  i = i || "itemStyle";
  for (var r = 0; r < wy.length; r++) {
    var a = wy[r], s = t.getModel([a, i]), o = e.ensureState(a);
    o.style = n ? n(s) : s[bO[i]]();
  }
}
function j1(e, t) {
  var i = t === !1, n = e;
  e.highDownSilentOnTouch && (n.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!i || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !i);
}
function as(e) {
  return !!(e && e.__highDownDispatcher);
}
function xO(e) {
  var t = py[e];
  return t == null && vy <= 32 && (t = py[e] = vy++), t;
}
function pd(e) {
  var t = e.type;
  return t === Nu || t === fd || t === Fu;
}
function My(e) {
  var t = e.type;
  return t === Jr || t === ru;
}
function wO(e) {
  var t = F1(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var i = e.states.select || {};
  t.selectFill = i.style && i.style.fill || null, t.selectStroke = i.style && i.style.stroke || null;
}
var xa = rs.CMD, SO = [[], [], []], Ty = Math.sqrt, MO = Math.atan2;
function TO(e, t) {
  if (t) {
    var i = e.data, n = e.len(), r, a, s, o, l, u, c = xa.M, h = xa.C, f = xa.L, d = xa.R, v = xa.A, g = xa.Q;
    for (s = 0, o = 0; s < n; ) {
      switch (r = i[s++], o = s, a = 0, r) {
        case c:
          a = 1;
          break;
        case f:
          a = 1;
          break;
        case h:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case v:
          var p = t[4], m = t[5], y = Ty(t[0] * t[0] + t[1] * t[1]), _ = Ty(t[2] * t[2] + t[3] * t[3]), b = MO(-t[1] / _, t[0] / y);
          i[s] *= y, i[s++] += p, i[s] *= _, i[s++] += m, i[s++] *= y, i[s++] *= _, i[s++] += b, i[s++] += b, s += 2, o = s;
          break;
        case d:
          u[0] = i[s++], u[1] = i[s++], qe(u, u, t), i[o++] = u[0], i[o++] = u[1], u[0] += i[s++], u[1] += i[s++], qe(u, u, t), i[o++] = u[0], i[o++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var x = SO[l];
        x[0] = i[s++], x[1] = i[s++], qe(x, x, t), i[o++] = x[0], i[o++] = x[1];
      }
    }
    e.increaseVersion();
  }
}
var Gh = Math.sqrt, Dl = Math.sin, Cl = Math.cos, Ds = Math.PI;
function Dy(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function gd(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (Dy(e) * Dy(t));
}
function Cy(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos(gd(e, t));
}
function ky(e, t, i, n, r, a, s, o, l, u, c) {
  var h = l * (Ds / 180), f = Cl(h) * (e - i) / 2 + Dl(h) * (t - n) / 2, d = -1 * Dl(h) * (e - i) / 2 + Cl(h) * (t - n) / 2, v = f * f / (s * s) + d * d / (o * o);
  v > 1 && (s *= Gh(v), o *= Gh(v));
  var g = (r === a ? -1 : 1) * Gh((s * s * (o * o) - s * s * (d * d) - o * o * (f * f)) / (s * s * (d * d) + o * o * (f * f))) || 0, p = g * s * d / o, m = g * -o * f / s, y = (e + i) / 2 + Cl(h) * p - Dl(h) * m, _ = (t + n) / 2 + Dl(h) * p + Cl(h) * m, b = Cy([1, 0], [(f - p) / s, (d - m) / o]), x = [(f - p) / s, (d - m) / o], w = [(-1 * f - p) / s, (-1 * d - m) / o], M = Cy(x, w);
  if (gd(x, w) <= -1 && (M = Ds), gd(x, w) >= 1 && (M = 0), M < 0) {
    var T = Math.round(M / Ds * 1e6) / 1e6;
    M = Ds * 2 + T % 2 * Ds;
  }
  c.addData(u, y, _, s, o, b, M, h, a);
}
var DO = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, CO = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function kO(e) {
  var t = new rs();
  if (!e)
    return t;
  var i = 0, n = 0, r = i, a = n, s, o = rs.CMD, l = e.match(DO);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), f = void 0, d = c.match(CO) || [], v = d.length, g = 0; g < v; g++)
      d[g] = parseFloat(d[g]);
    for (var p = 0; p < v; ) {
      var m = void 0, y = void 0, _ = void 0, b = void 0, x = void 0, w = void 0, M = void 0, T = i, D = n, P = void 0, C = void 0;
      switch (h) {
        case "l":
          i += d[p++], n += d[p++], f = o.L, t.addData(f, i, n);
          break;
        case "L":
          i = d[p++], n = d[p++], f = o.L, t.addData(f, i, n);
          break;
        case "m":
          i += d[p++], n += d[p++], f = o.M, t.addData(f, i, n), r = i, a = n, h = "l";
          break;
        case "M":
          i = d[p++], n = d[p++], f = o.M, t.addData(f, i, n), r = i, a = n, h = "L";
          break;
        case "h":
          i += d[p++], f = o.L, t.addData(f, i, n);
          break;
        case "H":
          i = d[p++], f = o.L, t.addData(f, i, n);
          break;
        case "v":
          n += d[p++], f = o.L, t.addData(f, i, n);
          break;
        case "V":
          n = d[p++], f = o.L, t.addData(f, i, n);
          break;
        case "C":
          f = o.C, t.addData(f, d[p++], d[p++], d[p++], d[p++], d[p++], d[p++]), i = d[p - 2], n = d[p - 1];
          break;
        case "c":
          f = o.C, t.addData(f, d[p++] + i, d[p++] + n, d[p++] + i, d[p++] + n, d[p++] + i, d[p++] + n), i += d[p - 2], n += d[p - 1];
          break;
        case "S":
          m = i, y = n, P = t.len(), C = t.data, s === o.C && (m += i - C[P - 4], y += n - C[P - 3]), f = o.C, T = d[p++], D = d[p++], i = d[p++], n = d[p++], t.addData(f, m, y, T, D, i, n);
          break;
        case "s":
          m = i, y = n, P = t.len(), C = t.data, s === o.C && (m += i - C[P - 4], y += n - C[P - 3]), f = o.C, T = i + d[p++], D = n + d[p++], i += d[p++], n += d[p++], t.addData(f, m, y, T, D, i, n);
          break;
        case "Q":
          T = d[p++], D = d[p++], i = d[p++], n = d[p++], f = o.Q, t.addData(f, T, D, i, n);
          break;
        case "q":
          T = d[p++] + i, D = d[p++] + n, i += d[p++], n += d[p++], f = o.Q, t.addData(f, T, D, i, n);
          break;
        case "T":
          m = i, y = n, P = t.len(), C = t.data, s === o.Q && (m += i - C[P - 4], y += n - C[P - 3]), i = d[p++], n = d[p++], f = o.Q, t.addData(f, m, y, i, n);
          break;
        case "t":
          m = i, y = n, P = t.len(), C = t.data, s === o.Q && (m += i - C[P - 4], y += n - C[P - 3]), i += d[p++], n += d[p++], f = o.Q, t.addData(f, m, y, i, n);
          break;
        case "A":
          _ = d[p++], b = d[p++], x = d[p++], w = d[p++], M = d[p++], T = i, D = n, i = d[p++], n = d[p++], f = o.A, ky(T, D, i, n, w, M, _, b, x, f, t);
          break;
        case "a":
          _ = d[p++], b = d[p++], x = d[p++], w = d[p++], M = d[p++], T = i, D = n, i += d[p++], n += d[p++], f = o.A, ky(T, D, i, n, w, M, _, b, x, f, t);
          break;
      }
    }
    (h === "z" || h === "Z") && (f = o.Z, t.addData(f), i = r, n = a), s = f;
  }
  return t.toStatic(), t;
}
var X1 = (function(e) {
  At(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(i) {
  }, t;
})(It);
function q1(e) {
  return e.setData != null;
}
function Z1(e, t) {
  var i = kO(e), n = Y({}, t);
  return n.buildPath = function(r) {
    var a = q1(r);
    if (a && r.canSave()) {
      r.appendPath(i);
      var s = r.getContext();
      s && r.rebuildPath(s, 1);
    } else {
      var s = a ? r.getContext() : r;
      s && i.rebuildPath(s, 1);
    }
  }, n.applyTransform = function(r) {
    TO(i, r), this.dirtyShape();
  }, n;
}
function PO(e, t) {
  return new X1(Z1(e, t));
}
function AO(e, t) {
  var i = Z1(e, t), n = (function(r) {
    At(a, r);
    function a(s) {
      var o = r.call(this, s) || this;
      return o.applyTransform = i.applyTransform, o.buildPath = i.buildPath, o;
    }
    return a;
  })(X1);
  return n;
}
function EO(e, t) {
  for (var i = [], n = e.length, r = 0; r < n; r++) {
    var a = e[r];
    i.push(a.getUpdatedPathProxy(!0));
  }
  var s = new It(t);
  return s.createPathProxy(), s.buildPath = function(o) {
    if (q1(o)) {
      o.appendPath(i);
      var l = o.getContext();
      l && o.rebuildPath(l, 1);
    }
  }, s;
}
var LO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
})(), Pc = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new LO();
  }, t.prototype.buildPath = function(i, n) {
    i.moveTo(n.cx + n.r, n.cy), i.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
})(It);
Pc.prototype.type = "circle";
var OO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
})(), Rv = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new OO();
  }, t.prototype.buildPath = function(i, n) {
    var r = 0.5522848, a = n.cx, s = n.cy, o = n.rx, l = n.ry, u = o * r, c = l * r;
    i.moveTo(a - o, s), i.bezierCurveTo(a - o, s - c, a - u, s - l, a, s - l), i.bezierCurveTo(a + u, s - l, a + o, s - c, a + o, s), i.bezierCurveTo(a + o, s + c, a + u, s + l, a, s + l), i.bezierCurveTo(a - u, s + l, a - o, s + c, a - o, s), i.closePath();
  }, t;
})(It);
Rv.prototype.type = "ellipse";
var K1 = Math.PI, jh = K1 * 2, wr = Math.sin, wa = Math.cos, IO = Math.acos, pe = Math.atan2, Py = Math.abs, fo = Math.sqrt, Qs = Math.max, Fi = Math.min, mi = 1e-4;
function RO(e, t, i, n, r, a, s, o) {
  var l = i - e, u = n - t, c = s - r, h = o - a, f = h * l - c * u;
  if (!(f * f < mi))
    return f = (c * (t - a) - h * (e - r)) / f, [e + f * l, t + f * u];
}
function kl(e, t, i, n, r, a, s) {
  var o = e - i, l = t - n, u = (s ? a : -a) / fo(o * o + l * l), c = u * l, h = -u * o, f = e + c, d = t + h, v = i + c, g = n + h, p = (f + v) / 2, m = (d + g) / 2, y = v - f, _ = g - d, b = y * y + _ * _, x = r - a, w = f * g - v * d, M = (_ < 0 ? -1 : 1) * fo(Qs(0, x * x * b - w * w)), T = (w * _ - y * M) / b, D = (-w * y - _ * M) / b, P = (w * _ + y * M) / b, C = (-w * y + _ * M) / b, A = T - p, E = D - m, R = P - p, I = C - m;
  return A * A + E * E > R * R + I * I && (T = P, D = C), {
    cx: T,
    cy: D,
    x0: -c,
    y0: -h,
    x1: T * (r / x - 1),
    y1: D * (r / x - 1)
  };
}
function NO(e) {
  var t;
  if (j(e)) {
    var i = e.length;
    if (!i)
      return e;
    i === 1 ? t = [e[0], e[0], 0, 0] : i === 2 ? t = [e[0], e[0], e[1], e[1]] : i === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function FO(e, t) {
  var i, n = Qs(t.r, 0), r = Qs(t.r0 || 0, 0), a = n > 0, s = r > 0;
  if (!(!a && !s)) {
    if (a || (n = r, r = 0), r > n) {
      var o = n;
      n = r, r = o;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, h = t.cy, f = !!t.clockwise, d = Py(u - l), v = d > jh && d % jh;
      if (v > mi && (d = v), !(n > mi))
        e.moveTo(c, h);
      else if (d > jh - mi)
        e.moveTo(c + n * wa(l), h + n * wr(l)), e.arc(c, h, n, l, u, !f), r > mi && (e.moveTo(c + r * wa(u), h + r * wr(u)), e.arc(c, h, r, u, l, f));
      else {
        var g = void 0, p = void 0, m = void 0, y = void 0, _ = void 0, b = void 0, x = void 0, w = void 0, M = void 0, T = void 0, D = void 0, P = void 0, C = void 0, A = void 0, E = void 0, R = void 0, I = n * wa(l), N = n * wr(l), B = r * wa(u), $ = r * wr(u), H = d > mi;
        if (H) {
          var G = t.cornerRadius;
          G && (i = NO(G), g = i[0], p = i[1], m = i[2], y = i[3]);
          var nt = Py(n - r) / 2;
          if (_ = Fi(nt, m), b = Fi(nt, y), x = Fi(nt, g), w = Fi(nt, p), D = M = Qs(_, b), P = T = Qs(x, w), (M > mi || T > mi) && (C = n * wa(u), A = n * wr(u), E = r * wa(l), R = r * wr(l), d < K1)) {
            var K = RO(I, N, E, R, C, A, B, $);
            if (K) {
              var pt = I - K[0], gt = N - K[1], Ht = C - K[0], ht = A - K[1], le = 1 / wr(IO((pt * Ht + gt * ht) / (fo(pt * pt + gt * gt) * fo(Ht * Ht + ht * ht))) / 2), De = fo(K[0] * K[0] + K[1] * K[1]);
              D = Fi(M, (n - De) / (le + 1)), P = Fi(T, (r - De) / (le - 1));
            }
          }
        }
        if (!H)
          e.moveTo(c + I, h + N);
        else if (D > mi) {
          var de = Fi(m, D), Zt = Fi(y, D), it = kl(E, R, I, N, n, de, f), yt = kl(C, A, B, $, n, Zt, f);
          e.moveTo(c + it.cx + it.x0, h + it.cy + it.y0), D < M && de === Zt ? e.arc(c + it.cx, h + it.cy, D, pe(it.y0, it.x0), pe(yt.y0, yt.x0), !f) : (de > 0 && e.arc(c + it.cx, h + it.cy, de, pe(it.y0, it.x0), pe(it.y1, it.x1), !f), e.arc(c, h, n, pe(it.cy + it.y1, it.cx + it.x1), pe(yt.cy + yt.y1, yt.cx + yt.x1), !f), Zt > 0 && e.arc(c + yt.cx, h + yt.cy, Zt, pe(yt.y1, yt.x1), pe(yt.y0, yt.x0), !f));
        } else
          e.moveTo(c + I, h + N), e.arc(c, h, n, l, u, !f);
        if (!(r > mi) || !H)
          e.lineTo(c + B, h + $);
        else if (P > mi) {
          var de = Fi(g, P), Zt = Fi(p, P), it = kl(B, $, C, A, r, -Zt, f), yt = kl(I, N, E, R, r, -de, f);
          e.lineTo(c + it.cx + it.x0, h + it.cy + it.y0), P < T && de === Zt ? e.arc(c + it.cx, h + it.cy, P, pe(it.y0, it.x0), pe(yt.y0, yt.x0), !f) : (Zt > 0 && e.arc(c + it.cx, h + it.cy, Zt, pe(it.y0, it.x0), pe(it.y1, it.x1), !f), e.arc(c, h, r, pe(it.cy + it.y1, it.cx + it.x1), pe(yt.cy + yt.y1, yt.cx + yt.x1), f), de > 0 && e.arc(c + yt.cx, h + yt.cy, de, pe(yt.y1, yt.x1), pe(yt.y0, yt.x0), !f));
        } else
          e.lineTo(c + B, h + $), e.arc(c, h, r, u, l, f);
      }
      e.closePath();
    }
  }
}
var BO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
})(), Nv = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new BO();
  }, t.prototype.buildPath = function(i, n) {
    FO(i, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
})(It);
Nv.prototype.type = "sector";
var zO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
})(), Fv = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new zO();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, s = Math.PI * 2;
    i.moveTo(r + n.r, a), i.arc(r, a, n.r, 0, s, !1), i.moveTo(r + n.r0, a), i.arc(r, a, n.r0, 0, s, !0);
  }, t;
})(It);
Fv.prototype.type = "ring";
function VO(e, t, i, n) {
  var r = [], a = [], s = [], o = [], l, u, c, h;
  if (n) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var f = 0, d = e.length; f < d; f++)
      Na(c, c, e[f]), Fa(h, h, e[f]);
    Na(c, c, n[0]), Fa(h, h, n[1]);
  }
  for (var f = 0, d = e.length; f < d; f++) {
    var v = e[f];
    if (i)
      l = e[f ? f - 1 : d - 1], u = e[(f + 1) % d];
    else if (f === 0 || f === d - 1) {
      r.push(hA(e[f]));
      continue;
    } else
      l = e[f - 1], u = e[f + 1];
    fA(a, u, l), uh(a, a, t);
    var g = Wf(v, l), p = Wf(v, u), m = g + p;
    m !== 0 && (g /= m, p /= m), uh(s, a, -g), uh(o, a, p);
    var y = hm([], v, s), _ = hm([], v, o);
    n && (Fa(y, y, c), Na(y, y, h), Fa(_, _, c), Na(_, _, h)), r.push(y), r.push(_);
  }
  return i && r.push(r.shift()), r;
}
function Q1(e, t, i) {
  var n = t.smooth, r = t.points;
  if (r && r.length >= 2) {
    if (n) {
      var a = VO(r, n, i, t.smoothConstraint);
      e.moveTo(r[0][0], r[0][1]);
      for (var s = r.length, o = 0; o < (i ? s : s - 1); o++) {
        var l = a[o * 2], u = a[o * 2 + 1], c = r[(o + 1) % s];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(r[0][0], r[0][1]);
      for (var o = 1, h = r.length; o < h; o++)
        e.lineTo(r[o][0], r[o][1]);
    }
    i && e.closePath();
  }
}
var $O = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), Bv = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new $O();
  }, t.prototype.buildPath = function(i, n) {
    Q1(i, n, !0);
  }, t;
})(It);
Bv.prototype.type = "polygon";
var HO = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), zv = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new HO();
  }, t.prototype.buildPath = function(i, n) {
    Q1(i, n, !1);
  }, t;
})(It);
zv.prototype.type = "polyline";
var YO = {}, WO = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
})(), hs = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new WO();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, s, o;
    if (this.subPixelOptimize) {
      var l = R1(YO, n, this.style);
      r = l.x1, a = l.y1, s = l.x2, o = l.y2;
    } else
      r = n.x1, a = n.y1, s = n.x2, o = n.y2;
    var u = n.percent;
    u !== 0 && (i.moveTo(r, a), u < 1 && (s = r * (1 - u) + s * u, o = a * (1 - u) + o * u), i.lineTo(s, o));
  }, t.prototype.pointAt = function(i) {
    var n = this.shape;
    return [
      n.x1 * (1 - i) + n.x2 * i,
      n.y1 * (1 - i) + n.y2 * i
    ];
  }, t;
})(It);
hs.prototype.type = "line";
var Ie = [], UO = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
})();
function Ay(e, t, i) {
  var n = e.cpx2, r = e.cpy2;
  return n != null || r != null ? [
    (i ? Mm : Pe)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (i ? Mm : Pe)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (i ? Tm : Be)(e.x1, e.cpx1, e.x2, t),
    (i ? Tm : Be)(e.y1, e.cpy1, e.y2, t)
  ];
}
var Vv = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new UO();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.x1, a = n.y1, s = n.x2, o = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, h = n.cpy2, f = n.percent;
    f !== 0 && (i.moveTo(r, a), c == null || h == null ? (f < 1 && (ku(r, l, s, f, Ie), l = Ie[1], s = Ie[2], ku(a, u, o, f, Ie), u = Ie[1], o = Ie[2]), i.quadraticCurveTo(l, u, s, o)) : (f < 1 && (Cu(r, l, c, s, f, Ie), l = Ie[1], c = Ie[2], s = Ie[3], Cu(a, u, h, o, f, Ie), u = Ie[1], h = Ie[2], o = Ie[3]), i.bezierCurveTo(l, u, c, h, s, o)));
  }, t.prototype.pointAt = function(i) {
    return Ay(this.shape, i, !1);
  }, t.prototype.tangentAt = function(i) {
    var n = Ay(this.shape, i, !0);
    return pA(n, n);
  }, t;
})(It);
Vv.prototype.type = "bezier-curve";
var GO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
})(), Ac = (function(e) {
  At(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new GO();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, s = Math.max(n.r, 0), o = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(o), h = Math.sin(o);
    i.moveTo(c * s + r, h * s + a), i.arc(r, a, s, o, l, !u);
  }, t;
})(It);
Ac.prototype.type = "arc";
var jO = (function(e) {
  At(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.type = "compound", i;
  }
  return t.prototype._updatePathDirty = function() {
    for (var i = this.shape.paths, n = this.shapeChanged(), r = 0; r < i.length; r++)
      n = n || i[r].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var i = this.shape.paths || [], n = this.getGlobalScale(), r = 0; r < i.length; r++)
      i[r].path || i[r].createPathProxy(), i[r].path.setScale(n[0], n[1], i[r].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(i, n) {
    for (var r = n.paths || [], a = 0; a < r.length; a++)
      r[a].buildPath(i, r[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var i = this.shape.paths || [], n = 0; n < i.length; n++)
      i[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), It.prototype.getBoundingRect.call(this);
  }, t;
})(It), J1 = (function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, i) {
    this.colorStops.push({
      offset: t,
      color: i
    });
  }, e;
})(), tx = (function(e) {
  At(t, e);
  function t(i, n, r, a, s, o) {
    var l = e.call(this, s) || this;
    return l.x = i ?? 0, l.y = n ?? 0, l.x2 = r ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = o || !1, l;
  }
  return t;
})(J1), XO = (function(e) {
  At(t, e);
  function t(i, n, r, a, s) {
    var o = e.call(this, a) || this;
    return o.x = i ?? 0.5, o.y = n ?? 0.5, o.r = r ?? 0.5, o.type = "radial", o.global = s || !1, o;
  }
  return t;
})(J1), Xh = Math.min, qO = Math.max, Pl = Math.abs, Sr = [0, 0], Mr = [0, 0], ce = Kb(), Al = ce.minTv, El = ce.maxTv, ex = (function() {
  function e(t, i) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new Lt();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new Lt();
    t && this.fromBoundingRect(t, i);
  }
  return e.prototype.fromBoundingRect = function(t, i) {
    var n = this._corners, r = this._axes, a = t.x, s = t.y, o = a + t.width, l = s + t.height;
    if (n[0].set(a, s), n[1].set(o, s), n[2].set(o, l), n[3].set(a, l), i)
      for (var u = 0; u < 4; u++)
        n[u].transform(i);
    Lt.sub(r[0], n[1], n[0]), Lt.sub(r[1], n[3], n[0]), r[0].normalize(), r[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = r[u].dot(n[0]);
  }, e.prototype.intersect = function(t, i, n) {
    var r = !0, a = !i;
    return i && Lt.set(i, 0, 0), ce.reset(n, !a), !this._intersectCheckOneSide(this, t, a, 1) && (r = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (r = !1, a) || !a && !ce.negativeSize && Lt.copy(i, r ? ce.useDir ? ce.dirMinTv : Al : El), r;
  }, e.prototype._intersectCheckOneSide = function(t, i, n, r) {
    for (var a = !0, s = 0; s < 2; s++) {
      var o = t._axes[s];
      if (t._getProjMinMaxOnAxis(s, t._corners, Sr), t._getProjMinMaxOnAxis(s, i._corners, Mr), ce.negativeSize || Sr[1] < Mr[0] || Sr[0] > Mr[1]) {
        if (a = !1, ce.negativeSize || n)
          return a;
        var l = Pl(Mr[0] - Sr[1]), u = Pl(Sr[0] - Mr[1]);
        Xh(l, u) > El.len() && (l < u ? Lt.scale(El, o, -l * r) : Lt.scale(El, o, u * r));
      } else if (!n) {
        var l = Pl(Mr[0] - Sr[1]), u = Pl(Sr[0] - Mr[1]);
        (ce.useDir || Xh(l, u) < Al.len()) && ((l < u || !ce.bidirectional) && (Lt.scale(Al, o, l * r), ce.useDir && ce.calcDirMTV()), (l >= u || !ce.bidirectional) && (Lt.scale(Al, o, -u * r), ce.useDir && ce.calcDirMTV()));
      }
    }
    return a;
  }, e.prototype._getProjMinMaxOnAxis = function(t, i, n) {
    for (var r = this._axes[t], a = this._origin, s = i[0].dot(r) + a[t], o = s, l = s, u = 1; u < i.length; u++) {
      var c = i[u].dot(r) + a[t];
      o = Xh(c, o), l = qO(c, l);
    }
    n[0] = o + ce.touchThreshold, n[1] = l - ce.touchThreshold, ce.negativeSize = n[1] < n[0];
  }, e;
})(), ZO = [], KO = (function(e) {
  At(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.notClear = !0, i.incremental = !0, i._displayables = [], i._temporaryDisplayables = [], i._cursor = 0, i;
  }
  return t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(i, n) {
    n ? this._temporaryDisplayables.push(i) : this._displayables.push(i), this.markRedraw();
  }, t.prototype.addDisplayables = function(i, n) {
    n = n || !1;
    for (var r = 0; r < i.length; r++)
      this.addDisplayable(i[r], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(i) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      i && i(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      i && i(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var n = this._displayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var n = this._temporaryDisplayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var i = new at(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var r = this._displayables[n], a = r.getBoundingRect().clone();
        r.needLocalTransform() && a.applyTransform(r.getLocalTransform(ZO)), i.union(a);
      }
      this._rect = i;
    }
    return this._rect;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    if (a.contain(r[0], r[1]))
      for (var s = 0; s < this._displayables.length; s++) {
        var o = this._displayables[s];
        if (o.contain(i, n))
          return !0;
      }
    return !1;
  }, t;
})(Xo);
Wt();
function QO(e, t, i, n, r) {
  var a;
  if (t && t.ecModel) {
    var s = t.ecModel.getUpdatePayload();
    a = s && s.animation;
  }
  var o = t && t.isAnimationEnabled(), l = e === "update";
  if (o) {
    var u = void 0, c = void 0, h = void 0;
    n ? (u = et(n.duration, 200), c = et(n.easing, "cubicOut"), h = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), mt(h) && (h = h(i, r)), mt(u) && (u = u(i));
    var f = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return f;
  } else
    return null;
}
function $v(e, t, i, n, r, a, s) {
  var o = !1, l;
  mt(r) ? (s = a, a = r, r = null) : q(r) && (a = r.cb, s = r.during, o = r.isFrom, l = r.removeOpt, r = r.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = QO(e, n, r, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, r) : null);
  if (c && c.duration > 0) {
    var h = c.duration, f = c.delay, d = c.easing, v = {
      duration: h,
      delay: f || 0,
      easing: d,
      done: a,
      force: !!a || !!s,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: s
    };
    o ? t.animateFrom(i, v) : t.animateTo(i, v);
  } else
    t.stopAnimation(), !o && t.attr(i), s && s(1), a && a();
}
function Hv(e, t, i, n, r, a) {
  $v("update", e, t, i, n, r, a);
}
function ix(e, t, i, n, r, a) {
  $v("enter", e, t, i, n, r, a);
}
function vo(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var i = e.animators[t];
    if (i.scope === "leave")
      return !0;
  }
  return !1;
}
function nx(e, t, i, n, r, a) {
  vo(e) || $v("leave", e, t, i, n, r, a);
}
function Ey(e, t, i, n) {
  e.removeTextContent(), e.removeTextGuideLine(), nx(e, {
    style: {
      opacity: 0
    }
  }, t, i, n);
}
function JO(e, t, i) {
  function n() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(r) {
    r.isGroup || Ey(r, t, i, n);
  }) : Ey(e, t, i, n);
}
var md = {}, tI = ["x", "y"], eI = ["width", "height"];
function iI(e) {
  return It.extend(e);
}
var nI = AO;
function rI(e, t) {
  return nI(e, t);
}
function Pi(e, t) {
  md[e] = t;
}
function aI(e) {
  if (md.hasOwnProperty(e))
    return md[e];
}
function Yv(e, t, i, n) {
  var r = PO(e, t);
  return i && (n === "center" && (i = ax(i, r.getBoundingRect())), sx(r, i)), r;
}
function rx(e, t, i) {
  var n = new oa({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(r) {
      if (i === "center") {
        var a = {
          width: r.width,
          height: r.height
        };
        n.setStyle(ax(t, a));
      }
    }
  });
  return n;
}
function ax(e, t) {
  var i = t.width / t.height, n = e.height * i, r;
  n <= e.width ? r = e.height : (n = e.width, r = n / i);
  var a = e.x + e.width / 2, s = e.y + e.height / 2;
  return {
    x: a - n / 2,
    y: s - r / 2,
    width: n,
    height: r
  };
}
var sI = EO;
function sx(e, t) {
  if (e.applyTransform) {
    var i = e.getBoundingRect(), n = i.calculateTransform(t);
    e.applyTransform(n);
  }
}
function Wv(e, t) {
  return R1(e, e, {
    lineWidth: t
  }), e;
}
function oI(e, t) {
  return N1(e, e, t), e;
}
var lI = $r;
function uI(e, t) {
  for (var i = xv([]); e && e !== t; )
    lo(i, e.getLocalTransform(), i), e = e.parent;
  return i;
}
function Uv(e, t, i) {
  return t && !Ye(t) && (t = Vr.getLocalTransform(t)), i && (t = Wo([], t)), qe([], e, t);
}
function cI(e, t, i) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : vn(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : vn(2 * t[4] / t[2]), a = [e === "left" ? -n : e === "right" ? n : 0, e === "top" ? -r : e === "bottom" ? r : 0];
  return a = Uv(a, t, i), vn(a[0]) > vn(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function Ly(e) {
  return !e.isGroup;
}
function hI(e) {
  return e.shape != null;
}
function fI(e, t, i) {
  if (!e || !t)
    return;
  function n(s) {
    var o = {};
    return s.traverse(function(l) {
      Ly(l) && l.anid && (o[l.anid] = l);
    }), o;
  }
  function r(s) {
    var o = {
      x: s.x,
      y: s.y,
      rotation: s.rotation
    };
    return hI(s) && (o.shape = dt(s.shape)), o;
  }
  var a = n(e);
  t.traverse(function(s) {
    if (Ly(s) && s.anid) {
      var o = a[s.anid];
      if (o) {
        var l = r(s);
        s.attr(r(o)), Hv(s, l, i, Ft(s).dataIndex);
      }
    }
  });
}
function dI(e, t) {
  return bt(e, function(i) {
    var n = i[0];
    n = bi(n, t.x), n = ko(n, t.x + t.width);
    var r = i[1];
    return r = bi(r, t.y), r = ko(r, t.y + t.height), [n, r];
  });
}
function vI(e, t) {
  var i = bi(e.x, t.x), n = ko(e.x + e.width, t.x + t.width), r = bi(e.y, t.y), a = ko(e.y + e.height, t.y + t.height);
  if (n >= i && a >= r)
    return {
      x: i,
      y: r,
      width: n - i,
      height: a - r
    };
}
function ox(e, t, i) {
  var n = Y({
    rectHover: !0
  }, t), r = n.style = {
    strokeNoScale: !0
  };
  if (i = i || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (r.image = e.slice(8), Qt(r, i), new oa(n)) : Yv(e.replace("path://", ""), n, i, "center");
}
function pI(e, t, i, n, r) {
  for (var a = 0, s = r[r.length - 1]; a < r.length; a++) {
    var o = r[a];
    if (lx(e, t, i, n, o[0], o[1], s[0], s[1]))
      return !0;
    s = o;
  }
}
function lx(e, t, i, n, r, a, s, o) {
  var l = i - e, u = n - t, c = s - r, h = o - a, f = qh(c, h, l, u);
  if (gI(f))
    return !1;
  var d = e - r, v = t - a, g = qh(d, v, l, u) / f;
  if (g < 0 || g > 1)
    return !1;
  var p = qh(d, v, c, h) / f;
  return !(p < 0 || p > 1);
}
function qh(e, t, i, n) {
  return e * n - i * t;
}
function gI(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function yd(e, t, i, n, r) {
  return t == null || (Xt(t) ? Ot[0] = Ot[1] = Ot[2] = Ot[3] = t : (process.env.NODE_ENV !== "production" && tt(t.length === 4), Ot[0] = t[0], Ot[1] = t[1], Ot[2] = t[2], Ot[3] = t[3]), n && (Ot[0] = bi(0, Ot[0]), Ot[1] = bi(0, Ot[1]), Ot[2] = bi(0, Ot[2]), Ot[3] = bi(0, Ot[3])), i && (Ot[0] = -Ot[0], Ot[1] = -Ot[1], Ot[2] = -Ot[2], Ot[3] = -Ot[3]), Oy(e, Ot, "x", "width", 3, 1, r && r[0] || 0), Oy(e, Ot, "y", "height", 0, 2, r && r[1] || 0)), e;
}
var Ot = [0, 0, 0, 0];
function Oy(e, t, i, n, r, a, s) {
  var o = t[a] + t[r], l = e[n];
  e[n] += o, s = bi(0, ko(s, l)), e[n] < s ? (e[n] = s, e[i] += t[r] >= 0 ? -t[r] : t[a] >= 0 ? l + t[a] : vn(o) > 1e-8 ? (l - s) * t[r] / o : 0) : e[i] -= t[r];
}
function Gv(e) {
  var t = e.itemTooltipOption, i = e.componentModel, n = e.itemName, r = Q(t) ? {
    formatter: t
  } : t, a = i.mainType, s = i.componentIndex, o = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  o[a + "Index"] = s;
  var l = e.formatterParamsExtra;
  l && k(jt(l), function(c) {
    Ui(o, c) || (o[c] = l[c], o.$vars.push(c));
  });
  var u = Ft(e.el);
  u.componentMainType = a, u.componentIndex = s, u.tooltipConfig = {
    name: n,
    option: Qt({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: o
    }, r)
  };
}
function _d(e, t) {
  var i;
  e.isGroup && (i = t(e)), i || e.traverse(t);
}
function ux(e, t) {
  if (e)
    if (j(e))
      for (var i = 0; i < e.length; i++)
        _d(e[i], t);
    else
      _d(e, t);
}
function jv(e) {
  return !e || vn(e[1]) < Ll && vn(e[2]) < Ll || vn(e[0]) < Ll && vn(e[3]) < Ll;
}
var Ll = 1e-5;
function Eo(e, t) {
  return e ? at.copy(e, t) : t.clone();
}
function Xv(e, t) {
  return t ? wv(e || Gi(), t) : void 0;
}
function Lo(e) {
  return {
    z: e.get("z") || 0,
    zlevel: e.get("zlevel") || 0
  };
}
function mI(e) {
  var t = -1 / 0, i = 1 / 0;
  _d(e, function(a) {
    n(a), n(a.getTextContent()), n(a.getTextGuideLine());
  });
  function n(a) {
    if (!(!a || a.isGroup)) {
      var s = a.currentStates;
      if (s.length)
        for (var o = 0; o < s.length; o++)
          r(a.states[s[o]]);
      r(a);
    }
  }
  function r(a) {
    if (a) {
      var s = a.z2;
      s > t && (t = s), s < i && (i = s);
    }
  }
  return i > t && (i = t = 0), {
    min: i,
    max: t
  };
}
function cx(e, t, i) {
  hx(e, t, i, -1 / 0);
}
function hx(e, t, i, n) {
  if (e.ignoreModelZ)
    return n;
  var r = e.getTextContent(), a = e.getTextGuideLine(), s = e.isGroup;
  if (s)
    for (var o = e.childrenRef(), l = 0; l < o.length; l++)
      n = bi(hx(o[l], t, i, n), n);
  else
    e.z = t, e.zlevel = i, n = bi(e.z2 || 0, n);
  if (r && (r.z = t, r.zlevel = i, isFinite(n) && (r.z2 = n + 2)), a) {
    var u = e.textGuideLineConfig;
    a.z = t, a.zlevel = i, isFinite(n) && (a.z2 = n + (u && u.showAbove ? 1 : -1));
  }
  return n;
}
Pi("circle", Pc);
Pi("ellipse", Rv);
Pi("sector", Nv);
Pi("ring", Fv);
Pi("polygon", Bv);
Pi("polyline", zv);
Pi("rect", xe);
Pi("line", hs);
Pi("bezierCurve", Vv);
Pi("arc", Ac);
const yI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Ac,
  BezierCurve: Vv,
  BoundingRect: at,
  Circle: Pc,
  CompoundPath: jO,
  Ellipse: Rv,
  Group: Mi,
  Image: oa,
  IncrementalDisplayable: KO,
  Line: hs,
  LinearGradient: tx,
  OrientedBoundingRect: ex,
  Path: It,
  Point: Lt,
  Polygon: Bv,
  Polyline: zv,
  RadialGradient: XO,
  Rect: xe,
  Ring: Fv,
  Sector: Nv,
  Text: vi,
  WH: eI,
  XY: tI,
  applyTransform: Uv,
  calcZ2Range: mI,
  clipPointsByRect: dI,
  clipRectByRect: vI,
  createIcon: ox,
  ensureCopyRect: Eo,
  ensureCopyTransform: Xv,
  expandOrShrinkRect: yd,
  extendPath: rI,
  extendShape: iI,
  getShapeClass: aI,
  getTransform: uI,
  groupTransition: fI,
  initProps: ix,
  isBoundingRectAxisAligned: jv,
  isElementRemoved: vo,
  lineLineIntersect: lx,
  linePolygonIntersect: pI,
  makeImage: rx,
  makePath: Yv,
  mergePath: sI,
  registerShape: Pi,
  removeElement: nx,
  removeElementWithFadeOut: JO,
  resizePath: sx,
  retrieveZInfo: Lo,
  setTooltipConfig: Gv,
  subPixelOptimize: lI,
  subPixelOptimizeLine: Wv,
  subPixelOptimizeRect: oI,
  transformDirection: cI,
  traverseElements: ux,
  traverseUpdateZ: cx,
  updateProps: Hv
}, Symbol.toStringTag, { value: "Module" }));
var Ec = {};
function _I(e, t) {
  for (var i = 0; i < tr.length; i++) {
    var n = tr[i], r = t[n], a = e.ensureState(n);
    a.style = a.style || {}, a.style.text = r;
  }
  var s = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(s, !0);
}
function Iy(e, t, i) {
  var n = e.labelFetcher, r = e.labelDataIndex, a = e.labelDimIndex, s = t.normal, o;
  n && (o = n.getFormattedLabel(r, "normal", null, a, s && s.get("formatter"), i != null ? {
    interpolatedValue: i
  } : null)), o == null && (o = mt(e.defaultText) ? e.defaultText(r, e, i) : e.defaultText);
  for (var l = {
    normal: o
  }, u = 0; u < tr.length; u++) {
    var c = tr[u], h = t[c];
    l[c] = et(n ? n.getFormattedLabel(r, c, null, a, h && h.get("formatter")) : null, o);
  }
  return l;
}
function Ry(e, t, i, n) {
  i = i || Ec;
  for (var r = e instanceof vi, a = !1, s = 0; s < gy.length; s++) {
    var o = t[gy[s]];
    if (o && o.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = r ? e : e.getTextContent();
  if (a) {
    r || (l || (l = new vi(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = Iy(i, t), c = t.normal, h = !!c.getShallow("show"), f = ra(c, n, i, !1, !r);
    f.text = u.normal, r || e.setTextConfig(Fy(c, i, !1));
    for (var s = 0; s < tr.length; s++) {
      var d = tr[s], o = t[d];
      if (o) {
        var v = l.ensureState(d), g = !!et(o.getShallow("show"), h);
        if (g !== h && (v.ignore = !g), v.style = ra(o, n, i, !0, !r), v.style.text = u[d], !r) {
          var p = e.ensureState(d);
          p.textConfig = Fy(o, i, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (f.x = l.style.x), l.style.y != null && (f.y = l.style.y), l.ignore = !h, l.useStyle(f), l.dirty(), i.enableTextSetter && (SI(l).setLabelText = function(m) {
      var y = Iy(i, t, m);
      _I(l, y);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function Ny(e, t) {
  t = t || "label";
  for (var i = {
    normal: e.getModel(t)
  }, n = 0; n < tr.length; n++) {
    var r = tr[n];
    i[r] = e.getModel([r, t]);
  }
  return i;
}
function ra(e, t, i, n, r) {
  var a = {};
  return bI(a, e, i, n, r), t && Y(a, t), a;
}
function Fy(e, t, i) {
  t = t || {};
  var n = {}, r, a = e.getShallow("rotate"), s = et(e.getShallow("distance"), i ? null : 5), o = e.getShallow("offset");
  return r = e.getShallow("position") || (i ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (n.position = r), o != null && (n.offset = o), a != null && (a *= Math.PI / 180, n.rotation = a), s != null && (n.distance = s), n.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (n.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (n.layoutRect = t.layoutRect), n;
}
function bI(e, t, i, n, r) {
  i = i || Ec;
  var a = t.ecModel, s = a && a.option.textStyle, o = xI(t), l;
  if (o) {
    l = {};
    var u = "richInheritPlainLabel", c = et(t.get(u), a ? a.get(u) : void 0);
    for (var h in o)
      if (o.hasOwnProperty(h)) {
        var f = t.getModel(["rich", h]);
        $y(l[h] = {}, f, s, t, c, i, n, r, !1, !0);
      }
  }
  l && (e.rich = l);
  var d = t.get("overflow");
  d && (e.overflow = d);
  var v = t.get("lineOverflow");
  v && (e.lineOverflow = v);
  var g = e, p = t.get("minMargin");
  if (p != null)
    p = Xt(p) ? p / 2 : 0, g.margin = [p, p, p, p], g.__marginType = $a.minMargin;
  else {
    var m = t.get("textMargin");
    m != null && (g.margin = _v(m), g.__marginType = $a.textMargin);
  }
  $y(e, t, s, null, null, i, n, r, !0, !1);
}
function xI(e) {
  for (var t; e && e !== e.ecModel; ) {
    var i = (e.option || Ec).rich;
    if (i) {
      t = t || {};
      for (var n = jt(i), r = 0; r < n.length; r++) {
        var a = n[r];
        t[a] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var By = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], zy = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], Vy = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function $y(e, t, i, n, r, a, s, o, l, u) {
  i = !s && i || Ec;
  var c = a && a.inheritColor, h = t.getShallow("color"), f = t.getShallow("textBorderColor"), d = et(t.getShallow("opacity"), i.opacity);
  (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && he("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), (f === "inherit" || f === "auto") && (process.env.NODE_ENV !== "production" && f === "auto" && he("color: 'auto'", "color: 'inherit'"), c ? f = c : f = null), o || (h = h || i.color, f = f || i.textBorderColor), h != null && (e.fill = h), f != null && (e.stroke = f);
  var v = et(t.getShallow("textBorderWidth"), i.textBorderWidth);
  v != null && (e.lineWidth = v);
  var g = et(t.getShallow("textBorderType"), i.textBorderType);
  g != null && (e.lineDash = g);
  var p = et(t.getShallow("textBorderDashOffset"), i.textBorderDashOffset);
  p != null && (e.lineDashOffset = p), !s && d == null && !u && (d = a && a.defaultOpacity), d != null && (e.opacity = d), !s && !o && e.fill == null && a.inheritColor && (e.fill = a.inheritColor);
  for (var m = 0; m < By.length; m++) {
    var y = By[m], _ = r !== !1 && n ? Xr(t.getShallow(y), n.getShallow(y), i[y]) : et(t.getShallow(y), i[y]);
    _ != null && (e[y] = _);
  }
  for (var m = 0; m < zy.length; m++) {
    var y = zy[m], _ = t.getShallow(y);
    _ != null && (e[y] = _);
  }
  if (e.verticalAlign == null) {
    var b = t.getShallow("baseline");
    b != null && (e.verticalAlign = b);
  }
  if (!l || !a.disableBox) {
    for (var m = 0; m < Vy.length; m++) {
      var y = Vy[m], _ = t.getShallow(y);
      _ != null && (e[y] = _);
    }
    var x = t.getShallow("borderType");
    x != null && (e.borderDash = x), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && he("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = c), (e.borderColor === "auto" || e.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && he("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = c);
  }
}
function wI(e, t) {
  var i = t && t.getModel("textStyle");
  return Hi([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || i && i.getShallow("fontStyle") || "",
    e.fontWeight || i && i.getShallow("fontWeight") || "",
    (e.fontSize || i && i.getShallow("fontSize") || 12) + "px",
    e.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var SI = Wt(), $a = {
  minMargin: 1,
  textMargin: 2
}, MI = ["textStyle", "color"], Zh = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Kh = new vi(), TI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var i = this.ecModel;
      return this.getShallow("color") || (!t && i ? i.get(MI) : null);
    }, e.prototype.getFont = function() {
      return wI({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var i = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Zh.length; n++)
        i[Zh[n]] = this.getShallow(Zh[n]);
      return Kh.useStyle(i), Kh.update(), Kh.getBoundingRect();
    }, e;
  })()
), fx = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], DI = Ao(fx), CI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return DI(this, t);
    }, e;
  })()
), dx = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], kI = Ao(dx), PI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, i) {
      return kI(this, t, i);
    }, e;
  })()
), Gt = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.parentModel = i, this.ecModel = n, this.option = t;
    }
    return e.prototype.init = function(t, i, n) {
    }, e.prototype.mergeOption = function(t, i) {
      re(this.option, t, !0);
    }, e.prototype.get = function(t, i) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !i && this.parentModel);
    }, e.prototype.getShallow = function(t, i) {
      var n = this.option, r = n == null ? n : n[t];
      if (r == null && !i) {
        var a = this.parentModel;
        a && (r = a.getShallow(t));
      }
      return r;
    }, e.prototype.getModel = function(t, i) {
      var n = t != null, r = n ? this.parsePath(t) : null, a = n ? this._doGet(r) : this.option;
      return i = i || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new e(a, i, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(dt(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!rt.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, i) {
      var n = this.option;
      if (!t)
        return n;
      for (var r = 0; r < t.length && !(t[r] && (n = n && typeof n == "object" ? n[t[r]] : null, n == null)); r++)
        ;
      return n == null && i && (n = i._doGet(this.resolveParentPath(t), i.parentModel)), n;
    }, e;
  })()
);
Dv(Gt);
oL(Gt);
Ci(Gt, CI);
Ci(Gt, PI);
Ci(Gt, fL);
Ci(Gt, TI);
var AI = Math.round(Math.random() * 10);
function Lc(e) {
  return [e || "", AI++].join("_");
}
function EI(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(i, n) {
    var r = Yi(i);
    t[r.main] = n;
  }, e.determineSubType = function(i, n) {
    var r = n.type;
    if (!r) {
      var a = Yi(i).main;
      e.hasSubTypes(i) && t[a] && (r = t[a](n));
    }
    return r;
  };
}
function LI(e, t) {
  e.topologicalTravel = function(a, s, o, l) {
    if (!a.length)
      return;
    var u = i(s), c = u.graph, h = u.noEntryList, f = {};
    for (k(a, function(y) {
      f[y] = !0;
    }); h.length; ) {
      var d = h.pop(), v = c[d], g = !!f[d];
      g && (o.call(l, d, v.originalDeps.slice()), delete f[d]), k(v.successor, g ? m : p);
    }
    k(f, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = Iu("Circular dependency may exists: ", f, a, s)), new Error(y);
    });
    function p(y) {
      c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
    }
    function m(y) {
      f[y] = !0, p(y);
    }
  };
  function i(a) {
    var s = {}, o = [];
    return k(a, function(l) {
      var u = n(s, l), c = u.originalDeps = t(l), h = r(c, a);
      u.entryCount = h.length, u.entryCount === 0 && o.push(l), k(h, function(f) {
        Bt(u.predecessor, f) < 0 && u.predecessor.push(f);
        var d = n(s, f);
        Bt(d.successor, f) < 0 && d.successor.push(l);
      });
    }), {
      graph: s,
      noEntryList: o
    };
  }
  function n(a, s) {
    return a[s] || (a[s] = {
      predecessor: [],
      successor: []
    }), a[s];
  }
  function r(a, s) {
    var o = [];
    return k(a, function(l) {
      Bt(s, l) >= 0 && o.push(l);
    }), o;
  }
}
const OI = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, II = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var Vu = "ZH", qv = "EN", Xa = qv, au = {}, Zv = {}, vx = rt.domSupported ? (function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Xa).toUpperCase()
  );
  return e.indexOf(Vu) > -1 ? Vu : Xa;
})() : Xa;
function px(e, t) {
  e = e.toUpperCase(), Zv[e] = new Gt(t), au[e] = t;
}
function RI(e) {
  if (Q(e)) {
    var t = au[e.toUpperCase()] || {};
    return e === Vu || e === qv ? dt(t) : re(dt(t), dt(au[Xa]), !1);
  } else
    return re(dt(e), dt(au[Xa]), !1);
}
function NI(e) {
  return Zv[e];
}
function FI() {
  return Zv[Xa];
}
px(qv, OI);
px(Vu, II);
function Ln(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function gx(e, t, i, n) {
  var r = Mc(e), a = r[BI(i)](), s = r[zI(i)]() + 1, o = Math.floor((s - 1) / 3) + 1, l = r[VI(i)](), u = r["get" + (i ? "UTC" : "") + "Day"](), c = r[$I(i)](), h = (c - 1) % 12 + 1, f = r[HI(i)](), d = r[YI(i)](), v = r[WI(i)](), g = c >= 12 ? "pm" : "am", p = g.toUpperCase(), m = n instanceof Gt ? n : NI(vx) || FI(), y = m.getModel("time"), _ = y.get("month"), b = y.get("monthAbbr"), x = y.get("dayOfWeek"), w = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, p + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, Ln(a % 100 + "", 2)).replace(/{Q}/g, o + "").replace(/{MMMM}/g, _[s - 1]).replace(/{MMM}/g, b[s - 1]).replace(/{MM}/g, Ln(s, 2)).replace(/{M}/g, s + "").replace(/{dd}/g, Ln(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, x[u]).replace(/{ee}/g, w[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Ln(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Ln(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Ln(f, 2)).replace(/{m}/g, f + "").replace(/{ss}/g, Ln(d, 2)).replace(/{s}/g, d + "").replace(/{SSS}/g, Ln(v, 3)).replace(/{S}/g, v + "");
}
function BI(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function zI(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function VI(e) {
  return e ? "getUTCDate" : "getDate";
}
function $I(e) {
  return e ? "getUTCHours" : "getHours";
}
function HI(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function YI(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function WI(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function UI(e) {
  if (!_1(e))
    return Q(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function mx(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(i, n) {
    return n.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var Kv = _v;
function bd(e, t, i) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function r(c) {
    return c && Hi(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var s = t === "time", o = e instanceof Date;
  if (s || o) {
    var l = s ? Mc(e) : e;
    if (isNaN(+l)) {
      if (o)
        return "-";
    } else return gx(l, n, i);
  }
  if (t === "ordinal")
    return wu(e) ? r(e) : Xt(e) && a(e) ? e + "" : "-";
  var u = Ou(e);
  return a(u) ? UI(u) : wu(e) ? r(e) : typeof e == "boolean" ? e + "" : "-";
}
var Hy = ["a", "b", "c", "d", "e", "f", "g"], Qh = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function yx(e, t, i) {
  j(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
    var s = Hy[a];
    e = e.replace(Qh(s), Qh(s, 0));
  }
  for (var o = 0; o < n; o++)
    for (var l = 0; l < r.length; l++) {
      var u = t[o][r[l]];
      e = e.replace(Qh(Hy[l], o), i ? Fe(u) : u);
    }
  return e;
}
function GI(e, t) {
  var i = Q(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, n = i.color, r = i.type;
  t = i.extraCssText;
  var a = i.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Fe(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Fe(n) + ";" + (t || "") + '"></span>';
  var s = i.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + s + "|}  ",
    style: r === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function Oo(e, t) {
  return t = t || "transparent", Q(e) ? e : q(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function Yy(e, t) {
  if (t === "_blank" || t === "blank") {
    var i = window.open();
    i.opener = null, i.location.href = e;
  } else
    window.open(e, t);
}
var Jh = {}, tf = {}, Oc = (
  /** @class */
  (function() {
    function e() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return e.prototype.create = function(t, i) {
      this._nonSeriesBoxMasterList = n(Jh, !0), this._normalMasterList = n(tf, !1);
      function n(r, a) {
        var s = [];
        return k(r, function(o, l) {
          var u = o.create(t, i);
          s = s.concat(u || []), process.env.NODE_ENV !== "production" && a && k(u, function(c) {
            return tt(!c.update);
          });
        }), s;
      }
    }, e.prototype.update = function(t, i) {
      k(this._normalMasterList, function(n) {
        n.update && n.update(t, i);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, e.register = function(t, i) {
      if (t === "matrix" || t === "calendar") {
        Jh[t] = i;
        return;
      }
      tf[t] = i;
    }, e.get = function(t) {
      return tf[t] || Jh[t];
    }, e;
  })()
), Wy = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
}, jI = lt();
function XI(e) {
  var t = e.getShallow("coord", !0), i = Wy.coord;
  if (t == null) {
    var n = jI.get(e.type);
    n && n.getCoord2 && (i = Wy.coord2, t = n.getCoord2(e));
  }
  return {
    coord: t,
    from: i
  };
}
var su = k, qI = ["left", "right", "top", "bottom", "width", "height"], Ol = [["width", "left", "right"], ["height", "top", "bottom"]];
function _x(e, t, i, n, r) {
  var a = 0, s = 0;
  n == null && (n = 1 / 0), r == null && (r = 1 / 0);
  var o = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = t.childAt(u + 1), f = h && h.getBoundingRect(), d, v;
    if (e === "horizontal") {
      var g = c.width + (f ? -f.x + c.x : 0);
      d = a + g, d > n || l.newline ? (a = 0, d = g, s += o + i, o = c.height) : o = Math.max(o, c.height);
    } else {
      var p = c.height + (f ? -f.y + c.y : 0);
      v = s + p, v > r || l.newline ? (a += o + i, s = 0, v = p, o = c.width) : o = Math.max(o, c.width);
    }
    l.newline || (l.x = a, l.y = s, l.markRedraw(), e === "horizontal" ? a = d + i : s = v + i);
  });
}
Ae(_x, "vertical");
Ae(_x, "horizontal");
function ZI(e, t) {
  return {
    left: e.getShallow("left", t),
    top: e.getShallow("top", t),
    right: e.getShallow("right", t),
    bottom: e.getShallow("bottom", t),
    width: e.getShallow("width", t),
    height: e.getShallow("height", t)
  };
}
function Qv(e, t, i) {
  i = Kv(i || 0);
  var n = t.width, r = t.height, a = ze(e.left, n), s = ze(e.top, r), o = ze(e.right, n), l = ze(e.bottom, r), u = ze(e.width, n), c = ze(e.height, r), h = i[2] + i[0], f = i[1] + i[3], d = e.aspect;
  switch (isNaN(u) && (u = n - o - f - a), isNaN(c) && (c = r - l - h - s), d != null && (isNaN(u) && isNaN(c) && (d > n / r ? u = n * 0.8 : c = r * 0.8), isNaN(u) && (u = d * c), isNaN(c) && (c = u / d)), isNaN(a) && (a = n - o - u - f), isNaN(s) && (s = r - l - c - h), e.left || e.right) {
    case "center":
      a = n / 2 - u / 2 - i[3];
      break;
    case "right":
      a = n - u - f;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      s = r / 2 - c / 2 - i[0];
      break;
    case "bottom":
      s = r - c - h;
      break;
  }
  a = a || 0, s = s || 0, isNaN(u) && (u = n - f - a - (o || 0)), isNaN(c) && (c = r - h - s - (l || 0));
  var v = new at((t.x || 0) + a + i[3], (t.y || 0) + s + i[0], u, c);
  return v.margin = i, v;
}
var ef = {
  rect: 1
};
function bx(e, t, i) {
  var n, r, a, s = e.boxCoordinateSystem, o;
  if (s) {
    var l = XI(e), u = l.coord, c = l.from;
    if (s.dataToLayout) {
      a = ef.rect, o = c;
      var h = s.dataToLayout(u);
      n = h.contentRect || h.rect;
    } else
      process.env.NODE_ENV !== "production" && qt(e.type + "[" + e.componentIndex + "]" + (" layout based on " + s.type + " is not supported."));
  }
  return a == null && (a = ef.rect), a === ef.rect && (n || (n = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), r = [n.x + n.width / 2, n.y + n.height / 2]), {
    type: a,
    refContainer: n,
    refPoint: r,
    boxCoordFrom: o
  };
}
function $u(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return q(t) ? t : t ? {
    type: t
  } : null;
}
function Hu(e, t, i) {
  var n = i && i.ignoreSize;
  !j(n) && (n = [n, n]);
  var r = s(Ol[0], 0), a = s(Ol[1], 1);
  l(Ol[0], e, r), l(Ol[1], e, a);
  function s(u, c) {
    var h = {}, f = 0, d = {}, v = 0, g = 2;
    if (su(u, function(y) {
      d[y] = e[y];
    }), su(u, function(y) {
      Ui(t, y) && (h[y] = d[y] = t[y]), o(h, y) && f++, o(d, y) && v++;
    }), n[c])
      return o(t, u[1]) ? d[u[2]] = null : o(t, u[2]) && (d[u[1]] = null), d;
    if (v === g || !f)
      return d;
    if (f >= g)
      return h;
    for (var p = 0; p < u.length; p++) {
      var m = u[p];
      if (!Ui(h, m) && Ui(e, m)) {
        h[m] = e[m];
        break;
      }
    }
    return h;
  }
  function o(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, h) {
    su(u, function(f) {
      c[f] = h[f];
    });
  }
}
function xx(e) {
  return KI({}, e);
}
function KI(e, t) {
  return t && e && su(qI, function(i) {
    Ui(t, i) && (e[i] = t[i]);
  }), e;
}
var QI = Wt(), Pt = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(i, n, r) {
      var a = e.call(this, i, n, r) || this;
      return a.uid = Lc("ec_cpt_model"), a;
    }
    return t.prototype.init = function(i, n, r) {
      this.mergeDefaultAndTheme(i, r);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = $u(this), a = r ? xx(i) : {}, s = n.getTheme();
      re(i, s.get(this.mainType)), re(i, this.getDefaultOption()), r && Hu(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      re(this.option, i, !0);
      var r = $u(this);
      r && Hu(this.option, i, r);
    }, t.prototype.optionUpdated = function(i, n) {
    }, t.prototype.getDefaultOption = function() {
      var i = this.constructor;
      if (!rL(i))
        return i.defaultOption;
      var n = QI(this);
      if (!n.defaultOption) {
        for (var r = [], a = i; a; ) {
          var s = a.prototype.defaultOption;
          s && r.push(s), a = a.superClass;
        }
        for (var o = {}, l = r.length - 1; l >= 0; l--)
          o = re(o, r[l], !0);
        n.defaultOption = o;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(i, n) {
      var r = i + "Index", a = i + "Id";
      return jo(this.ecModel, i, {
        index: this.get(r, !0),
        id: this.get(a, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      return ZI(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(i) {
      this.option.zlevel = i;
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "component", i.id = "", i.name = "", i.mainType = "", i.subType = "", i.componentIndex = 0;
    })(), t;
  })(Gt)
);
C1(Pt, Gt);
Cv(Pt);
EI(Pt);
LI(Pt, JI);
function JI(e) {
  var t = [];
  return k(Pt.getClassesByMainType(e), function(i) {
    t = t.concat(i.dependencies || i.prototype.dependencies || []);
  }), t = bt(t, function(i) {
    return Yi(i).main;
  }), e !== "dataset" && Bt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var St = {
  color: {},
  darkColor: {},
  size: {}
}, Kt = St.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
Y(Kt, {
  primary: Kt.neutral80,
  secondary: Kt.neutral70,
  tertiary: Kt.neutral60,
  quaternary: Kt.neutral50,
  disabled: Kt.neutral20,
  border: Kt.neutral30,
  borderTint: Kt.neutral20,
  borderShade: Kt.neutral40,
  background: Kt.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: Kt.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: Kt.neutral70,
  axisLineTint: Kt.neutral40,
  axisTick: Kt.neutral70,
  axisTickMinor: Kt.neutral60,
  axisLabel: Kt.neutral70,
  axisSplitLine: Kt.neutral15,
  axisMinorSplitLine: Kt.neutral05
});
for (var Tr in Kt)
  if (Kt.hasOwnProperty(Tr)) {
    var Uy = Kt[Tr];
    Tr === "theme" ? St.darkColor.theme = Kt.theme.slice() : Tr === "highlight" ? St.darkColor.highlight = "rgba(255,231,130,0.4)" : Tr.indexOf("accent") === 0 ? St.darkColor[Tr] = ja(Uy, null, function(e) {
      return e * 0.5;
    }, function(e) {
      return Math.min(1, 1.3 - e);
    }) : St.darkColor[Tr] = ja(Uy, null, function(e) {
      return e * 0.9;
    }, function(e) {
      return 1 - Math.pow(e, 1.5);
    });
  }
St.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var Sx = "";
typeof navigator < "u" && (Sx = navigator.platform || "");
var Sa = "rgba(0, 0, 0, 0.2)", Mx = St.color.theme[0], tR = ja(Mx, null, null, 0.9);
const eR = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: St.color.theme,
  gradientColor: [tR, Mx],
  aria: {
    decal: {
      decals: [{
        color: Sa,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Sa,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Sa,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Sa,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Sa,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Sa,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: Sx.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var xd = lt(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Ke = "original", Me = "arrayRows", Ai = "objectRows", Ki = "keyedColumns", _n = "typedArray", Tx = "unknown", qi = "column", la = "row", We = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, Dx = Wt();
function iR(e) {
  Dx(e).datasetMap = lt();
}
function nR(e, t, i) {
  var n = {}, r = Cx(t);
  if (!r || !e)
    return n;
  var a = [], s = [], o = t.ecModel, l = Dx(o).datasetMap, u = r.uid + "_" + i.seriesLayoutBy, c, h;
  e = e.slice(), k(e, function(g, p) {
    var m = q(g) ? g : e[p] = {
      name: g
    };
    m.type === "ordinal" && c == null && (c = p, h = v(m)), n[m.name] = [];
  });
  var f = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  k(e, function(g, p) {
    var m = g.name, y = v(g);
    if (c == null) {
      var _ = f.valueWayDim;
      d(n[m], _, y), d(s, _, y), f.valueWayDim += y;
    } else if (c === p)
      d(n[m], 0, y), d(a, 0, y);
    else {
      var _ = f.categoryWayDim;
      d(n[m], _, y), d(s, _, y), f.categoryWayDim += y;
    }
  });
  function d(g, p, m) {
    for (var y = 0; y < m; y++)
      g.push(p + y);
  }
  function v(g) {
    var p = g.dimsDef;
    return p ? p.length : 1;
  }
  return a.length && (n.itemName = a), s.length && (n.seriesName = s), n;
}
function Cx(e) {
  var t = e.get("data", !0);
  if (!t)
    return jo(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, Fn).models[0];
}
function rR(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : jo(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, Fn).models;
}
function kx(e, t) {
  return aR(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function aR(e, t, i, n, r, a) {
  var s, o = 5;
  if (Le(e))
    return We.Not;
  var l, u;
  if (n) {
    var c = n[a];
    q(c) ? (l = c.name, u = c.type) : Q(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? We.Must : We.Not;
  if (t === Me) {
    var h = e;
    if (i === la) {
      for (var f = h[a], d = 0; d < (f || []).length && d < o; d++)
        if ((s = b(f[r + d])) != null)
          return s;
    } else
      for (var d = 0; d < h.length && d < o; d++) {
        var v = h[r + d];
        if (v && (s = b(v[a])) != null)
          return s;
      }
  } else if (t === Ai) {
    var g = e;
    if (!l)
      return We.Not;
    for (var d = 0; d < g.length && d < o; d++) {
      var p = g[d];
      if (p && (s = b(p[l])) != null)
        return s;
    }
  } else if (t === Ki) {
    var m = e;
    if (!l)
      return We.Not;
    var f = m[l];
    if (!f || Le(f))
      return We.Not;
    for (var d = 0; d < f.length && d < o; d++)
      if ((s = b(f[d])) != null)
        return s;
  } else if (t === Ke)
    for (var y = e, d = 0; d < y.length && d < o; d++) {
      var p = y[d], _ = Uo(p);
      if (!j(_))
        return We.Not;
      if ((s = b(_[a])) != null)
        return s;
    }
  function b(x) {
    var w = Q(x);
    if (x != null && Number.isFinite(Number(x)) && x !== "")
      return w ? We.Might : We.Not;
    if (w && x !== "-")
      return We.Must;
  }
  return We.Not;
}
var sR = lt();
function oR(e, t, i) {
  var n = sR.get(t);
  if (!n)
    return i;
  var r = n(e);
  if (!r)
    return i;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < r.length; a++)
      tt(ns(r[a]));
  return i.concat(r);
}
var Gy = Wt();
Wt();
var Jv = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, i, n) {
      var r = Ee(this.get("color", !0)), a = this.get("colorLayer", !0);
      return uR(this, Gy, r, a, t, i, n);
    }, e.prototype.clearColorPalette = function() {
      cR(this, Gy);
    }, e;
  })()
);
function lR(e, t) {
  for (var i = e.length, n = 0; n < i; n++)
    if (e[n].length > t)
      return e[n];
  return e[i - 1];
}
function uR(e, t, i, n, r, a, s) {
  a = a || e;
  var o = t(a), l = o.paletteIdx || 0, u = o.paletteNameMap = o.paletteNameMap || {};
  if (u.hasOwnProperty(r))
    return u[r];
  var c = s == null || !n ? i : lR(n, s);
  if (c = c || i, !(!c || !c.length)) {
    var h = c[l];
    return r && (u[r] = h), o.paletteIdx = (l + 1) % c.length, h;
  }
}
function cR(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var Il, Cs, jy, nf = "\0_ec_inner", Xy = 1, hR = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, fR = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Yu = {};
function dR(e) {
  k(e, function(t, i) {
    if (!Pt.hasClass(i)) {
      var n = hR[i];
      n && !Yu[n] && (qt("Component " + i + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), Yu[n] = !0);
    }
  });
}
var tp = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(i, n, r, a, s, o) {
      a = a || {}, this.option = null, this._theme = new Gt(a), this._locale = new Gt(s), this._optionManager = o;
    }, t.prototype.setOption = function(i, n, r) {
      process.env.NODE_ENV !== "production" && (tt(i != null, "option is null/undefined"), tt(i[nf] !== Xy, "please use chart.getOption()"));
      var a = Ky(n);
      this._optionManager.setOption(i, r, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(i, n) {
      return this._resetOption(i, Ky(n));
    }, t.prototype._resetOption = function(i, n) {
      var r = !1, a = this._optionManager;
      if (!i || i === "recreate") {
        var s = a.mountOption(i === "recreate");
        process.env.NODE_ENV !== "production" && dR(s), !this.option || i === "recreate" ? jy(this, s) : (this.restoreData(), this._mergeOption(s, n)), r = !0;
      }
      if ((i === "timeline" || i === "media") && this.restoreData(), !i || i === "recreate" || i === "timeline") {
        var o = a.getTimelineOption(this);
        o && (r = !0, this._mergeOption(o, n));
      }
      if (!i || i === "recreate" || i === "media") {
        var l = a.getMediaOption(this);
        l.length && k(l, function(u) {
          r = !0, this._mergeOption(u, n);
        }, this);
      }
      return r;
    }, t.prototype.mergeOption = function(i) {
      this._mergeOption(i, null);
    }, t.prototype._mergeOption = function(i, n) {
      var r = this.option, a = this._componentsMap, s = this._componentsCount, o = [], l = lt(), u = n && n.replaceMergeMainTypeMap;
      iR(this), k(i, function(h, f) {
        h != null && (Pt.hasClass(f) ? f && (o.push(f), l.set(f, !0)) : r[f] = r[f] == null ? dt(h) : re(r[f], h, !0));
      }), u && u.each(function(h, f) {
        Pt.hasClass(f) && !l.get(f) && (o.push(f), l.set(f, !0));
      }), Pt.topologicalTravel(o, Pt.getAllClassMainTypes(), c, this);
      function c(h) {
        var f = oR(this, h, Ee(i[h])), d = a.get(h), v = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          d ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = YE(d, f, v);
        ZE(g, h, Pt), r[h] = null, a.set(h, null), s.set(h, 0);
        var p = [], m = [], y = 0, _, b;
        k(g, function(x, w) {
          var M = x.existing, T = x.newOption;
          if (!T)
            M && (M.mergeOption({}, this), M.optionUpdated({}, !1));
          else {
            var D = h === "series", P = Pt.getClass(
              h,
              x.keyInfo.subType,
              !D
              // Give a more detailed warn later if series don't exists
            );
            if (!P) {
              if (process.env.NODE_ENV !== "production") {
                var C = x.keyInfo.subType, A = fR[C];
                Yu[C] || (Yu[C] = !0, qt(A ? "Series " + C + ` is used but not imported.
import { ` + A + ` } from 'echarts/charts';
echarts.use([` + A + "]);" : "Unknown series " + C));
              }
              return;
            }
            if (h === "tooltip") {
              if (_) {
                process.env.NODE_ENV !== "production" && (b || (oi("Currently only one tooltip component is allowed."), b = !0));
                return;
              }
              _ = !0;
            }
            if (M && M.constructor === P)
              M.name = x.keyInfo.name, M.mergeOption(T, this), M.optionUpdated(T, !1);
            else {
              var E = Y({
                componentIndex: w
              }, x.keyInfo);
              M = new P(T, this, this, E), Y(M, E), x.brandNew && (M.__requireNewView = !0), M.init(T, this, this), M.optionUpdated(null, !0);
            }
          }
          M ? (p.push(M.option), m.push(M), y++) : (p.push(void 0), m.push(void 0));
        }, this), r[h] = p, a.set(h, m), s.set(h, y), h === "series" && Il(this);
      }
      this._seriesIndices || Il(this);
    }, t.prototype.getOption = function() {
      var i = dt(this.option);
      return k(i, function(n, r) {
        if (Pt.hasClass(r)) {
          for (var a = Ee(n), s = a.length, o = !1, l = s - 1; l >= 0; l--)
            a[l] && !ns(a[l]) ? o = !0 : (a[l] = null, !o && s--);
          a.length = s, i[r] = a;
        }
      }), delete i[nf], i;
    }, t.prototype.setTheme = function(i) {
      this._theme = new Gt(i), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(i) {
      this._payload = i;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(i, n) {
      var r = this._componentsMap.get(i);
      if (r) {
        var a = r[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var s = 0; s < r.length; s++)
            if (r[s])
              return r[s];
        }
      }
    }, t.prototype.queryComponents = function(i) {
      var n = i.mainType;
      if (!n)
        return [];
      var r = i.index, a = i.id, s = i.name, o = this._componentsMap.get(n);
      if (!o || !o.length)
        return [];
      var l;
      return r != null ? (l = [], k(Ee(r), function(u) {
        o[u] && l.push(o[u]);
      })) : a != null ? l = qy("id", a, o) : s != null ? l = qy("name", s, o) : l = je(o, function(u) {
        return !!u;
      }), Zy(l, i);
    }, t.prototype.findComponents = function(i) {
      var n = i.query, r = i.mainType, a = o(n), s = a ? this.queryComponents(a) : je(this._componentsMap.get(r), function(u) {
        return !!u;
      });
      return l(Zy(s, i));
      function o(u) {
        var c = r + "Index", h = r + "Id", f = r + "Name";
        return u && (u[c] != null || u[h] != null || u[f] != null) ? {
          mainType: r,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[f]
        } : null;
      }
      function l(u) {
        return i.filter ? je(u, i.filter) : u;
      }
    }, t.prototype.eachComponent = function(i, n, r) {
      var a = this._componentsMap;
      if (mt(i)) {
        var s = n, o = i;
        a.each(function(h, f) {
          for (var d = 0; h && d < h.length; d++) {
            var v = h[d];
            v && o.call(s, f, v, v.componentIndex);
          }
        });
      } else
        for (var l = Q(i) ? a.get(i) : q(i) ? this.findComponents(i) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(r, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(i) {
      var n = Si(i, null);
      return je(this._componentsMap.get("series"), function(r) {
        return !!r && n != null && r.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(i) {
      return this._componentsMap.get("series")[i];
    }, t.prototype.getSeriesByType = function(i) {
      return je(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === i;
      });
    }, t.prototype.getSeries = function() {
      return je(this._componentsMap.get("series"), function(i) {
        return !!i;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(i, n) {
      Cs(this), k(this._seriesIndices, function(r) {
        var a = this._componentsMap.get("series")[r];
        i.call(n, a, r);
      }, this);
    }, t.prototype.eachRawSeries = function(i, n) {
      k(this._componentsMap.get("series"), function(r) {
        r && i.call(n, r, r.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(i, n, r) {
      Cs(this), k(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        s.subType === i && n.call(r, s, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(i, n, r) {
      return k(this.getSeriesByType(i), n, r);
    }, t.prototype.isSeriesFiltered = function(i) {
      return Cs(this), this._seriesIndicesMap.get(i.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(i, n) {
      Cs(this);
      var r = [];
      k(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        i.call(n, s, a) && r.push(a);
      }, this), this._seriesIndices = r, this._seriesIndicesMap = lt(r);
    }, t.prototype.restoreData = function(i) {
      Il(this);
      var n = this._componentsMap, r = [];
      n.each(function(a, s) {
        Pt.hasClass(s) && r.push(s);
      }), Pt.topologicalTravel(r, Pt.getAllClassMainTypes(), function(a) {
        k(n.get(a), function(s) {
          s && (a !== "series" || !vR(s, i)) && s.restoreData();
        });
      });
    }, t.internalField = (function() {
      Il = function(i) {
        var n = i._seriesIndices = [];
        k(i._componentsMap.get("series"), function(r) {
          r && n.push(r.componentIndex);
        }), i._seriesIndicesMap = lt(n);
      }, Cs = function(i) {
        if (process.env.NODE_ENV !== "production" && !i._seriesIndices)
          throw new Error("Option should contains series.");
      }, jy = function(i, n) {
        i.option = {}, i.option[nf] = Xy, i._componentsMap = lt({
          series: []
        }), i._componentsCount = lt();
        var r = n.aria;
        q(r) && r.enabled == null && (r.enabled = !0), pR(n, i._theme.option), re(n, eR, !1), i._mergeOption(n, null);
      };
    })(), t;
  })(Gt)
);
function vR(e, t) {
  if (t) {
    var i = t.seriesIndex, n = t.seriesId, r = t.seriesName;
    return i != null && e.componentIndex !== i || n != null && e.id !== n || r != null && e.name !== r;
  }
}
function pR(e, t) {
  var i = e.color && !e.colorLayer;
  k(t, function(n, r) {
    r === "colorLayer" && i || r === "color" && e.color || Pt.hasClass(r) || (typeof n == "object" ? e[r] = e[r] ? re(e[r], n, !1) : dt(n) : e[r] == null && (e[r] = n));
  });
}
function qy(e, t, i) {
  if (j(t)) {
    var n = lt();
    return k(t, function(a) {
      if (a != null) {
        var s = Si(a, null);
        s != null && n.set(a, !0);
      }
    }), je(i, function(a) {
      return a && n.get(a[e]);
    });
  } else {
    var r = Si(t, null);
    return je(i, function(a) {
      return a && r != null && a[e] === r;
    });
  }
}
function Zy(e, t) {
  return t.hasOwnProperty("subType") ? je(e, function(i) {
    return i && i.subType === t.subType;
  }) : e;
}
function Ky(e) {
  var t = lt();
  return e && k(Ee(e.replaceMerge), function(i) {
    process.env.NODE_ENV !== "production" && tt(Pt.hasClass(i), '"' + i + '" is not valid component main type in "replaceMerge"'), t.set(i, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
Ci(tp, Jv);
var gR = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], Px = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      k(gR, function(i) {
        this[i] = Dt(t[i], t);
      }, this);
    }
    return e;
  })()
), mR = /^(min|max)?(.+)$/, yR = (
  /** @class */
  (function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, i, n) {
      t && (k(Ee(t.series), function(s) {
        s && s.data && Le(s.data) && Hf(s.data);
      }), k(Ee(t.dataset), function(s) {
        s && s.source && Le(s.source) && Hf(s.source);
      })), t = dt(t);
      var r = this._optionBackup, a = _R(t, i, !r);
      this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, e.prototype.mountOption = function(t) {
      var i = this._optionBackup;
      return this._timelineOptions = i.timelineOptions, this._mediaList = i.mediaList, this._mediaDefault = i.mediaDefault, this._currentMediaIndices = [], dt(t ? i.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var i, n = this._timelineOptions;
      if (n.length) {
        var r = t.getComponent("timeline");
        r && (i = dt(
          // FIXME:TS as TimelineModel or quivlant interface
          n[r.getCurrentIndex()]
        ));
      }
      return i;
    }, e.prototype.getMediaOption = function(t) {
      var i = this._api.getWidth(), n = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, s = [], o = [];
      if (!r.length && !a)
        return o;
      for (var l = 0, u = r.length; l < u; l++)
        bR(r[l].query, i, n) && s.push(l);
      return !s.length && a && (s = [-1]), s.length && !wR(s, this._currentMediaIndices) && (o = bt(s, function(c) {
        return dt(c === -1 ? a.option : r[c].option);
      })), this._currentMediaIndices = s, o;
    }, e;
  })()
);
function _R(e, t, i) {
  var n = [], r, a, s = e.baseOption, o = e.timeline, l = e.options, u = e.media, c = !!e.media, h = !!(l || o || s && s.timeline);
  s ? (a = s, a.timeline || (a.timeline = o)) : ((h || c) && (e.options = e.media = null), a = e), c && (j(u) ? k(u, function(d) {
    process.env.NODE_ENV !== "production" && d && !d.option && q(d.query) && q(d.query.option) && qt("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), d && d.option && (d.query ? n.push(d) : r || (r = d));
  }) : process.env.NODE_ENV !== "production" && qt("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), f(a), k(l, function(d) {
    return f(d);
  }), k(n, function(d) {
    return f(d.option);
  });
  function f(d) {
    k(t, function(v) {
      v(d, i);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: r,
    mediaList: n
  };
}
function bR(e, t, i) {
  var n = {
    width: t,
    height: i,
    aspectratio: t / i
    // lower case for convenience.
  }, r = !0;
  return k(e, function(a, s) {
    var o = s.match(mR);
    if (!(!o || !o[1] || !o[2])) {
      var l = o[1], u = o[2].toLowerCase();
      xR(n[u], a, l) || (r = !1);
    }
  }), r;
}
function xR(e, t, i) {
  return i === "min" ? e >= t : i === "max" ? e <= t : e === t;
}
function wR(e, t) {
  return e.join(",") === t.join(",");
}
var ti = k, Io = q, Qy = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function rf(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0, n = Qy.length; i < n; i++) {
      var r = Qy[i], a = t.normal, s = t.emphasis;
      a && a[r] && (process.env.NODE_ENV !== "production" && he("itemStyle.normal." + r, r), e[r] = e[r] || {}, e[r].normal ? re(e[r].normal, a[r]) : e[r].normal = a[r], a[r] = null), s && s[r] && (process.env.NODE_ENV !== "production" && he("itemStyle.emphasis." + r, "emphasis." + r), e[r] = e[r] || {}, e[r].emphasis ? re(e[r].emphasis, s[r]) : e[r].emphasis = s[r], s[r] = null);
    }
}
function me(e, t, i) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var n = e[t].normal, r = e[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && Sn("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), i ? (e[t].normal = e[t].emphasis = null, Qt(e[t], n)) : e[t] = n), r && (process.env.NODE_ENV !== "production" && Sn(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = r, r.focus && (e.emphasis.focus = r.focus), r.blurScope && (e.emphasis.blurScope = r.blurScope));
  }
}
function Js(e) {
  me(e, "itemStyle"), me(e, "lineStyle"), me(e, "areaStyle"), me(e, "label"), me(e, "labelLine"), me(e, "upperLabel"), me(e, "edgeLabel");
}
function te(e, t) {
  var i = Io(e) && e[t], n = Io(i) && i.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && Sn("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var r = 0, a = Gm.length; r < a; r++) {
      var s = Gm[r];
      n.hasOwnProperty(s) && (i[s] = n[s]);
    }
  }
}
function ri(e) {
  e && (Js(e), te(e, "label"), e.emphasis && te(e.emphasis, "label"));
}
function SR(e) {
  if (Io(e)) {
    rf(e), Js(e), te(e, "label"), te(e, "upperLabel"), te(e, "edgeLabel"), e.emphasis && (te(e.emphasis, "label"), te(e.emphasis, "upperLabel"), te(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (rf(t), ri(t));
    var i = e.markLine;
    i && (rf(i), ri(i));
    var n = e.markArea;
    n && ri(n);
    var r = e.data;
    if (e.type === "graph") {
      r = r || e.nodes;
      var a = e.links || e.edges;
      if (a && !Le(a))
        for (var s = 0; s < a.length; s++)
          ri(a[s]);
      k(e.categories, function(u) {
        Js(u);
      });
    }
    if (r && !Le(r))
      for (var s = 0; s < r.length; s++)
        ri(r[s]);
    if (t = e.markPoint, t && t.data)
      for (var o = t.data, s = 0; s < o.length; s++)
        ri(o[s]);
    if (i = e.markLine, i && i.data)
      for (var l = i.data, s = 0; s < l.length; s++)
        j(l[s]) ? (ri(l[s][0]), ri(l[s][1])) : ri(l[s]);
    e.type === "gauge" ? (te(e, "axisLabel"), te(e, "title"), te(e, "detail")) : e.type === "treemap" ? (me(e.breadcrumb, "itemStyle"), k(e.levels, function(u) {
      Js(u);
    })) : e.type === "tree" && Js(e.leaves);
  }
}
function nn(e) {
  return j(e) ? e : e ? [e] : [];
}
function Jy(e) {
  return (j(e) ? e[0] : e) || {};
}
function MR(e, t) {
  ti(nn(e.series), function(n) {
    Io(n) && SR(n);
  });
  var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), ti(i, function(n) {
    ti(nn(e[n]), function(r) {
      r && (te(r, "axisLabel"), te(r.axisPointer, "label"));
    });
  }), ti(nn(e.parallel), function(n) {
    var r = n && n.parallelAxisDefault;
    te(r, "axisLabel"), te(r && r.axisPointer, "label");
  }), ti(nn(e.calendar), function(n) {
    me(n, "itemStyle"), te(n, "dayLabel"), te(n, "monthLabel"), te(n, "yearLabel");
  }), ti(nn(e.radar), function(n) {
    te(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && Sn("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && Sn("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && ti(n.indicator, function(r) {
      r.text && he("text", "name", "radar.indicator");
    });
  }), ti(nn(e.geo), function(n) {
    Io(n) && (ri(n), ti(nn(n.regions), function(r) {
      ri(r);
    }));
  }), ti(nn(e.timeline), function(n) {
    ri(n), me(n, "label"), me(n, "itemStyle"), me(n, "controlStyle", !0);
    var r = n.data;
    j(r) && k(r, function(a) {
      q(a) && (me(a, "label"), me(a, "itemStyle"));
    });
  }), ti(nn(e.toolbox), function(n) {
    me(n, "iconStyle"), ti(n.feature, function(r) {
      me(r, "iconStyle");
    });
  }), te(Jy(e.axisPointer), "label"), te(Jy(e.tooltip).axisPointer, "label");
}
function TR(e, t) {
  for (var i = t.split(","), n = e, r = 0; r < i.length && (n = n && n[i[r]], n != null); r++)
    ;
  return n;
}
function DR(e, t, i, n) {
  for (var r = t.split(","), a = e, s, o = 0; o < r.length - 1; o++)
    s = r[o], a[s] == null && (a[s] = {}), a = a[s];
  a[r[o]] == null && (a[r[o]] = i);
}
function t_(e) {
  e && k(CR, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var CR = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], kR = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], af = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function ks(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0; i < af.length; i++) {
      var n = af[i][1], r = af[i][0];
      t[n] != null && (t[r] = t[n], process.env.NODE_ENV !== "production" && he(n, r));
    }
}
function e_(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && he("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function i_(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && he("downplay", "blur", "sunburst"));
}
function PR(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && he("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function Ax(e, t) {
  if (e)
    for (var i = 0; i < e.length; i++)
      t(e[i]), e[i] && Ax(e[i].children, t);
}
function Ex(e, t) {
  MR(e, t), e.series = Ee(e.series), k(e.series, function(i) {
    if (q(i)) {
      var n = i.type;
      if (n === "line")
        i.clipOverflow != null && (i.clip = i.clipOverflow, process.env.NODE_ENV !== "production" && he("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        i.clockWise != null && (i.clockwise = i.clockWise, process.env.NODE_ENV !== "production" && he("clockWise", "clockwise")), e_(i.label);
        var r = i.data;
        if (r && !Le(r))
          for (var a = 0; a < r.length; a++)
            e_(r[a]);
        i.hoverOffset != null && (i.emphasis = i.emphasis || {}, (i.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && he("hoverOffset", "emphasis.scaleSize"), i.emphasis.scaleSize = i.hoverOffset));
      } else if (n === "gauge") {
        var s = TR(i, "pointer.color");
        s != null && DR(i, "itemStyle.color", s);
      } else if (n === "bar") {
        ks(i), ks(i.backgroundStyle), ks(i.emphasis);
        var r = i.data;
        if (r && !Le(r))
          for (var a = 0; a < r.length; a++)
            typeof r[a] == "object" && (ks(r[a]), ks(r[a] && r[a].emphasis));
      } else if (n === "sunburst") {
        var o = i.highlightPolicy;
        o && (i.emphasis = i.emphasis || {}, i.emphasis.focus || (i.emphasis.focus = o, process.env.NODE_ENV !== "production" && he("highlightPolicy", "emphasis.focus", "sunburst"))), i_(i), Ax(i.data, i_);
      } else n === "graph" || n === "sankey" ? PR(i) : n === "map" && (i.mapType && !i.map && (process.env.NODE_ENV !== "production" && he("mapType", "map", "map"), i.map = i.mapType), i.mapLocation && (process.env.NODE_ENV !== "production" && Sn("`mapLocation` is not used anymore."), Qt(i, i.mapLocation)));
      i.hoverAnimation != null && (i.emphasis = i.emphasis || {}, i.emphasis && i.emphasis.scale == null && (process.env.NODE_ENV !== "production" && he("hoverAnimation", "emphasis.scale"), i.emphasis.scale = i.hoverAnimation)), t_(i);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), k(kR, function(i) {
    var n = e[i];
    n && (j(n) || (n = [n]), k(n, function(r) {
      t_(r);
    }));
  });
}
function AR(e) {
  var t = lt();
  e.eachSeries(function(i) {
    var n = i.get("stack");
    if (n) {
      var r = t.get(n) || t.set(n, []), a = i.getData(), s = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: i
      };
      if (!s.stackedDimension || !(s.isStackedByIndex || s.stackedByDimension))
        return;
      r.push(s);
    }
  }), t.each(function(i) {
    if (i.length !== 0) {
      var n = i[0].seriesModel, r = n.get("stackOrder") || "seriesAsc";
      r === "seriesDesc" && i.reverse(), k(i, function(a, s) {
        a.data.setCalculationInfo("stackedOnSeries", s > 0 ? i[s - 1].seriesModel : null);
      }), ER(i);
    }
  });
}
function ER(e) {
  k(e, function(t, i) {
    var n = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], s = t.data, o = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    s.modify(a, function(u, c, h) {
      var f = s.get(t.stackedDimension, h);
      if (isNaN(f))
        return r;
      var d, v;
      o ? v = s.getRawIndex(h) : d = s.get(t.stackedByDimension, h);
      for (var g = NaN, p = i - 1; p >= 0; p--) {
        var m = e[p];
        if (o || (v = m.data.rawIndexOf(m.stackedByDimension, d)), v >= 0) {
          var y = m.data.getByRawIndex(m.stackResultDimension, v);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && f >= 0 && y > 0 || l === "samesign" && f <= 0 && y < 0) {
            f = NE(f, y), g = y;
            break;
          }
        }
      }
      return n[0] = f, n[1] = g, n;
    });
  });
}
var Ic = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === Ki ? {} : []), this.sourceFormat = t.sourceFormat || Tx, this.seriesLayoutBy = t.seriesLayoutBy || qi, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var i = this.dimensionsDefine = t.dimensionsDefine;
      if (i)
        for (var n = 0; n < i.length; n++) {
          var r = i[n];
          r.type == null && kx(this, n) === We.Must && (r.type = "ordinal");
        }
    }
    return e;
  })()
);
function ep(e) {
  return e instanceof Ic;
}
function wd(e, t, i) {
  i = i || Lx(e);
  var n = t.seriesLayoutBy, r = OR(e, i, n, t.sourceHeader, t.dimensions), a = new Ic({
    data: e,
    sourceFormat: i,
    seriesLayoutBy: n,
    dimensionsDefine: r.dimensionsDefine,
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount,
    metaRawOption: dt(t)
  });
  return a;
}
function ip(e) {
  return new Ic({
    data: e,
    sourceFormat: Le(e) ? _n : Ke
  });
}
function LR(e) {
  return new Ic({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: dt(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function Lx(e) {
  var t = Tx;
  if (Le(e))
    t = _n;
  else if (j(e)) {
    e.length === 0 && (t = Me);
    for (var i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      if (r != null) {
        if (j(r) || Le(r)) {
          t = Me;
          break;
        } else if (q(r)) {
          t = Ai;
          break;
        }
      }
    }
  } else if (q(e)) {
    for (var a in e)
      if (Ui(e, a) && Ye(e[a])) {
        t = Ki;
        break;
      }
  }
  return t;
}
function OR(e, t, i, n, r) {
  var a, s;
  if (!e)
    return {
      dimensionsDefine: n_(r),
      startIndex: s,
      dimensionsDetectedCount: a
    };
  if (t === Me) {
    var o = e;
    n === "auto" || n == null ? r_(function(u) {
      u != null && u !== "-" && (Q(u) ? s == null && (s = 1) : s = 0);
    }, i, o, 10) : s = Xt(n) ? n : n ? 1 : 0, !r && s === 1 && (r = [], r_(function(u, c) {
      r[c] = u != null ? u + "" : "";
    }, i, o, 1 / 0)), a = r ? r.length : i === la ? o.length : o[0] ? o[0].length : null;
  } else if (t === Ai)
    r || (r = IR(e));
  else if (t === Ki)
    r || (r = [], k(e, function(u, c) {
      r.push(c);
    }));
  else if (t === Ke) {
    var l = Uo(e[0]);
    a = j(l) && l.length || 1;
  } else t === _n && process.env.NODE_ENV !== "production" && tt(!!r, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: s,
    dimensionsDefine: n_(r),
    dimensionsDetectedCount: a
  };
}
function IR(e) {
  for (var t = 0, i; t < e.length && !(i = e[t++]); )
    ;
  if (i)
    return jt(i);
}
function n_(e) {
  if (e) {
    var t = lt();
    return bt(e, function(i, n) {
      i = q(i) ? i : {
        name: i
      };
      var r = {
        name: i.name,
        displayName: i.displayName,
        type: i.type
      };
      if (r.name == null)
        return r;
      r.name += "", r.displayName == null && (r.displayName = r.name);
      var a = t.get(r.name);
      return a ? r.name += "-" + a.count++ : t.set(r.name, {
        count: 1
      }), r;
    });
  }
}
function r_(e, t, i, n) {
  if (t === la)
    for (var r = 0; r < i.length && r < n; r++)
      e(i[r] ? i[r][0] : null, r);
  else
    for (var a = i[0] || [], r = 0; r < a.length && r < n; r++)
      e(a[r], r);
}
function Ox(e) {
  var t = e.sourceFormat;
  return t === Ai || t === Ki;
}
var Dr, Cr, kr, Pr, a_, s_, Ix = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = ep(t) ? t : ip(t);
      this._source = n;
      var r = this._data = n.data, a = n.sourceFormat, s = n.seriesLayoutBy;
      if (a === _n) {
        if (process.env.NODE_ENV !== "production" && i == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = i, this._data = r;
      }
      if (process.env.NODE_ENV !== "production") {
        var o = RR[Wu(a, s)];
        o && o(r, n.dimensionsDefine);
      }
      s_(this, r, n);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, i) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    })(), e.internalField = (function() {
      var t;
      s_ = function(s, o, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, f = l.dimensionsDefine, d = a_[Wu(u, c)];
        if (process.env.NODE_ENV !== "production" && tt(d, "Invalide sourceFormat: " + u), Y(s, d), u === _n)
          s.getItem = i, s.count = r, s.fillStorage = n;
        else {
          var v = Rx(u, c);
          s.getItem = Dt(v, null, o, h, f);
          var g = Nx(u, c);
          s.count = Dt(g, null, o, h, f);
        }
      };
      var i = function(s, o) {
        s = s - this._offset, o = o || [];
        for (var l = this._data, u = this._dimSize, c = u * s, h = 0; h < u; h++)
          o[h] = l[c + h];
        return o;
      }, n = function(s, o, l, u) {
        for (var c = this._data, h = this._dimSize, f = 0; f < h; f++) {
          for (var d = u[f], v = d[0] == null ? 1 / 0 : d[0], g = d[1] == null ? -1 / 0 : d[1], p = o - s, m = l[f], y = 0; y < p; y++) {
            var _ = c[y * h + f];
            m[s + y] = _, _ < v && (v = _), _ > g && (g = _);
          }
          d[0] = v, d[1] = g;
        }
      }, r = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      a_ = (t = {}, t[Me + "_" + qi] = {
        pure: !0,
        appendData: a
      }, t[Me + "_" + la] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[Ai] = {
        pure: !0,
        appendData: a
      }, t[Ki] = {
        pure: !0,
        appendData: function(s) {
          var o = this._data;
          k(s, function(l, u) {
            for (var c = o[u] || (o[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, t[Ke] = {
        appendData: a
      }, t[_n] = {
        persistent: !1,
        pure: !0,
        appendData: function(s) {
          process.env.NODE_ENV !== "production" && tt(Le(s), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = s;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(s) {
        for (var o = 0; o < s.length; o++)
          this._data.push(s[o]);
      }
    })(), e;
  })()
), Rl = function(e) {
  j(e) || qt("series.data or dataset.source must be an array.");
}, RR = (Dr = {}, Dr[Me + "_" + qi] = Rl, Dr[Me + "_" + la] = Rl, Dr[Ai] = Rl, Dr[Ki] = function(e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i].name;
    n == null && qt("dimension name must not be null/undefined.");
  }
}, Dr[Ke] = Rl, Dr), o_ = function(e, t, i, n) {
  return e[n];
}, NR = (Cr = {}, Cr[Me + "_" + qi] = function(e, t, i, n) {
  return e[n + t];
}, Cr[Me + "_" + la] = function(e, t, i, n, r) {
  n += t;
  for (var a = r || [], s = e, o = 0; o < s.length; o++) {
    var l = s[o];
    a[o] = l ? l[n] : null;
  }
  return a;
}, Cr[Ai] = o_, Cr[Ki] = function(e, t, i, n, r) {
  for (var a = r || [], s = 0; s < i.length; s++) {
    var o = i[s].name, l = o != null ? e[o] : null;
    a[s] = l ? l[n] : null;
  }
  return a;
}, Cr[Ke] = o_, Cr);
function Rx(e, t) {
  var i = NR[Wu(e, t)];
  return process.env.NODE_ENV !== "production" && tt(i, 'Do not support get item on "' + e + '", "' + t + '".'), i;
}
var l_ = function(e, t, i) {
  return e.length;
}, FR = (kr = {}, kr[Me + "_" + qi] = function(e, t, i) {
  return Math.max(0, e.length - t);
}, kr[Me + "_" + la] = function(e, t, i) {
  var n = e[0];
  return n ? Math.max(0, n.length - t) : 0;
}, kr[Ai] = l_, kr[Ki] = function(e, t, i) {
  var n = i[0].name, r = n != null ? e[n] : null;
  return r ? r.length : 0;
}, kr[Ke] = l_, kr);
function Nx(e, t) {
  var i = FR[Wu(e, t)];
  return process.env.NODE_ENV !== "production" && tt(i, 'Do not support count on "' + e + '", "' + t + '".'), i;
}
var sf = function(e, t, i) {
  return e[t];
}, BR = (Pr = {}, Pr[Me] = sf, Pr[Ai] = function(e, t, i) {
  return e[i];
}, Pr[Ki] = sf, Pr[Ke] = function(e, t, i) {
  var n = Uo(e);
  return n instanceof Array ? n[t] : n;
}, Pr[_n] = sf, Pr);
function Fx(e) {
  var t = BR[e];
  return process.env.NODE_ENV !== "production" && tt(t, 'Do not support get value on "' + e + '".'), t;
}
function Wu(e, t) {
  return e === Me ? e + "_" + t : e;
}
function Uu(e, t, i) {
  if (e) {
    var n = e.getRawDataItem(t);
    if (n != null) {
      var r = e.getStore(), a = r.getSource().sourceFormat;
      if (i != null) {
        var s = e.getDimensionIndex(i), o = r.getDimensionProperty(s);
        return Fx(a)(n, s, o);
      } else {
        var l = n;
        return a === Ke && (l = Uo(n)), l;
      }
    }
  }
}
var zR = /\{@(.+?)\}/g, VR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, i) {
      var n = this.getData(i), r = this.getRawValue(t, i), a = n.getRawIndex(t), s = n.getName(t), o = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, f = h === "series", d = n.userOutput && n.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: f ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: f ? this.id : null,
        seriesName: f ? this.name : null,
        name: s,
        dataIndex: a,
        data: o,
        dataType: i,
        value: r,
        color: u,
        borderColor: c,
        dimensionNames: d ? d.fullDimensions : null,
        encode: d ? d.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, i, n, r, a, s) {
      i = i || "normal";
      var o = this.getData(n), l = this.getDataParams(t, n);
      if (s && (l.value = s.interpolatedValue), r != null && j(l.value) && (l.value = l.value[r]), !a) {
        var u = o.getItemModel(t);
        a = u.get(i === "normal" ? ["label", "formatter"] : [i, "label", "formatter"]);
      }
      if (mt(a))
        return l.status = i, l.dimensionIndex = r, a(l);
      if (Q(a)) {
        var c = yx(a, l);
        return c.replace(zR, function(h, f) {
          var d = f.length, v = f;
          v.charAt(0) === "[" && v.charAt(d - 1) === "]" && (v = +v.slice(1, d - 1), process.env.NODE_ENV !== "production" && isNaN(v) && qt("Invalide label formatter: @" + f + ", only support @[0], @[1], @[2], ..."));
          var g = Uu(o, t, v);
          if (s && j(s.interpolatedValue)) {
            var p = o.getDimensionIndex(v);
            p >= 0 && (g = s.interpolatedValue[p]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, i) {
      return Uu(this.getData(i), t);
    }, e.prototype.formatTooltip = function(t, i, n) {
    }, e;
  })()
);
function u_(e) {
  var t, i;
  return q(e) ? e.type ? i = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + Iu(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: i
  };
}
function po(e) {
  return new $R(e);
}
var $R = (
  /** @class */
  (function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var i = this._upstream, n = t && t.skip;
      if (this._dirty && i) {
        var r = this.context;
        r.data = r.outputData = i.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var s = c(this._modBy), o = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (s !== l || o !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = !1, h = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var f = t && t.step;
      if (i ? (process.env.NODE_ENV !== "production" && tt(i._outputDueEnd != null), this._dueEnd = i._outputDueEnd) : (process.env.NODE_ENV !== "production" && tt(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var d = this._dueIndex, v = Math.min(f != null ? this._dueIndex + f : 1 / 0, this._dueEnd);
        if (!n && (h || d < v)) {
          var g = this._progress;
          if (j(g))
            for (var p = 0; p < g.length; p++)
              this._doProgress(g[p], d, v, l, u);
          else
            this._doProgress(g, d, v, l, u);
        }
        this._dueIndex = v;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : v;
        process.env.NODE_ENV !== "production" && tt(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, i, n, r, a) {
      c_.reset(i, n, r, a), this._callingProgress = t, this._callingProgress({
        start: i,
        end: n,
        count: n - i,
        next: c_.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var i, n;
      !t && this._reset && (i = this._reset(this.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), j(i) && !i.length && (i = null)), this._progress = i, this._modBy = this._modDataCount = null;
      var r = this._downstream;
      return r && r.dirty(), n;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && tt(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  })()
), c_ = /* @__PURE__ */ (function() {
  var e, t, i, n, r, a = {
    reset: function(l, u, c, h) {
      t = l, e = u, i = c, n = h, r = Math.ceil(n / i), a.next = i > 1 && n > 0 ? o : s;
    }
  };
  return a;
  function s() {
    return t < e ? t++ : null;
  }
  function o() {
    var l = t % r * i + Math.ceil(t / r), u = t >= e ? null : l < n ? l : t;
    return t++, u;
  }
})();
function ou(e, t) {
  var i = t && t.type;
  return i === "ordinal" ? e : (i === "time" && !Xt(e) && e != null && e !== "-" && (e = +Mc(e)), e == null || e === "" ? NaN : Number(e));
}
lt({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +Mc(e);
  },
  trim: function(e) {
    return Q(e) ? Hi(e) : e;
  }
});
var HR = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, i == null && (i = n ? "min" : "max"), this._incomparable = i === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, i) {
      var n = Xt(t) ? t : Ou(t), r = Xt(i) ? i : Ou(i), a = isNaN(n), s = isNaN(r);
      if (a && (n = this._incomparable), s && (r = this._incomparable), a && s) {
        var o = Q(t), l = Q(i);
        o && (n = l ? t : 0), l && (r = o ? i : 0);
      }
      return n < r ? this._resultLT : n > r ? -this._resultLT : 0;
    }, e;
  })()
), YR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, i) {
    }, e.prototype.retrieveValueFromItem = function(t, i) {
    }, e.prototype.convertValue = function(t, i) {
      return ou(t, i);
    }, e;
  })()
);
function WR(e, t) {
  var i = new YR(), n = e.data, r = i.sourceFormat = e.sourceFormat, a = e.startIndex, s = "";
  e.seriesLayoutBy !== qi && (process.env.NODE_ENV !== "production" && (s = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), Ve(s));
  var o = [], l = {}, u = e.dimensionsDefine;
  if (u)
    k(u, function(g, p) {
      var m = g.name, y = {
        index: p,
        name: m,
        displayName: g.displayName
      };
      if (o.push(y), m != null) {
        var _ = "";
        Ui(l, m) && (process.env.NODE_ENV !== "production" && (_ = 'dimension name "' + m + '" duplicated.'), Ve(_)), l[m] = y;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      o.push({
        index: c
      });
  var h = Rx(r, qi);
  t.__isBuiltIn && (i.getRawDataItem = function(g) {
    return h(n, a, o, g);
  }, i.getRawData = Dt(UR, null, e)), i.cloneRawData = Dt(GR, null, e);
  var f = Nx(r, qi);
  i.count = Dt(f, null, n, a, o);
  var d = Fx(r);
  i.retrieveValue = function(g, p) {
    var m = h(n, a, o, g);
    return v(m, p);
  };
  var v = i.retrieveValueFromItem = function(g, p) {
    if (g != null) {
      var m = o[p];
      if (m)
        return d(g, p, m.name);
    }
  };
  return i.getDimensionInfo = Dt(jR, null, o, l), i.cloneAllDimensionInfo = Dt(XR, null, o), i;
}
function UR(e) {
  var t = e.sourceFormat;
  if (!np(t)) {
    var i = "";
    process.env.NODE_ENV !== "production" && (i = "`getRawData` is not supported in source format " + t), Ve(i);
  }
  return e.data;
}
function GR(e) {
  var t = e.sourceFormat, i = e.data;
  if (!np(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), Ve(n);
  }
  if (t === Me) {
    for (var r = [], a = 0, s = i.length; a < s; a++)
      r.push(i[a].slice());
    return r;
  } else if (t === Ai) {
    for (var r = [], a = 0, s = i.length; a < s; a++)
      r.push(Y({}, i[a]));
    return r;
  }
}
function jR(e, t, i) {
  if (i != null) {
    if (Xt(i) || !isNaN(i) && !Ui(t, i))
      return e[i];
    if (Ui(t, i))
      return t[i];
  }
}
function XR(e) {
  return dt(e);
}
var Bx = lt();
function qR(e) {
  e = dt(e);
  var t = e.type, i = "";
  t || (process.env.NODE_ENV !== "production" && (i = "Must have a `type` when `registerTransform`."), Ve(i));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (i = 'Name must include namespace like "ns:regression".'), Ve(i));
  var r = !1;
  n[0] === "echarts" && (t = n[1], r = !0), e.__isBuiltIn = r, Bx.set(t, e);
}
function ZR(e, t, i) {
  var n = Ee(e), r = n.length, a = "";
  r || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), Ve(a));
  for (var s = 0, o = r; s < o; s++) {
    var l = n[s];
    t = KR(l, t, i, r === 1 ? null : s), s !== o - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function KR(e, t, i, n) {
  var r = "";
  t.length || (process.env.NODE_ENV !== "production" && (r = "Must have at least one upstream dataset."), Ve(r)), q(e) || (process.env.NODE_ENV !== "production" && (r = "transform declaration must be an object rather than " + typeof e + "."), Ve(r));
  var a = e.type, s = Bx.get(a);
  s || (process.env.NODE_ENV !== "production" && (r = 'Can not find transform on type "' + a + '".'), Ve(r));
  var o = bt(t, function(c) {
    return WR(c, s);
  }), l = Ee(s.transform({
    upstream: o[0],
    upstreamList: o,
    config: dt(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = bt(l, function(c) {
      var h = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + i.datasetIndex + h + " ===", "- transform result data:", Iu(c.data), "- transform result dimensions:", Iu(c.dimensions)].join(`
`);
    }).join(`
`);
    VE(u);
  }
  return bt(l, function(c, h) {
    var f = "";
    q(c) || (process.env.NODE_ENV !== "production" && (f = "A transform should not return some empty results."), Ve(f)), c.data || (process.env.NODE_ENV !== "production" && (f = "Transform result data should be not be null or undefined"), Ve(f));
    var d = Lx(c.data);
    np(d) || (process.env.NODE_ENV !== "production" && (f = "Transform result data should be array rows or object rows."), Ve(f));
    var v, g = t[0];
    if (g && h === 0 && !c.dimensions) {
      var p = g.startIndex;
      p && (c.data = g.data.slice(0, p).concat(c.data)), v = {
        seriesLayoutBy: qi,
        sourceHeader: p,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      v = {
        seriesLayoutBy: qi,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return wd(c.data, v, null);
  });
}
function np(e) {
  return e === Me || e === Ai;
}
var Rc = "undefined", QR = typeof Uint32Array === Rc ? Array : Uint32Array, JR = typeof Uint16Array === Rc ? Array : Uint16Array, zx = typeof Int32Array === Rc ? Array : Int32Array, h_ = typeof Float64Array === Rc ? Array : Float64Array, Vx = {
  float: h_,
  int: zx,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: h_
}, of;
function Ma(e) {
  return e > 65535 ? QR : JR;
}
function Ta() {
  return [1 / 0, -1 / 0];
}
function t5(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function f_(e, t, i, n, r) {
  var a = Vx[i || "float"];
  if (r) {
    var s = e[t], o = s && s.length;
    if (o !== n) {
      for (var l = new a(n), u = 0; u < o; u++)
        l[u] = s[u];
      e[t] = l;
    }
  } else
    e[t] = new a(n);
}
var Sd = (
  /** @class */
  (function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = lt();
    }
    return e.prototype.initData = function(t, i, n) {
      process.env.NODE_ENV !== "production" && tt(mt(t.getItem) && mt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var r = t.getSource(), a = this.defaultDimValueGetter = of[r.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var s = Ox(r);
      this._dimensions = bt(i, function(o) {
        return process.env.NODE_ENV !== "production" && s && tt(o.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: o.type,
          property: o.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, i) {
      var n = this._calcDimNameToIdx, r = this._dimensions, a = n.get(t);
      if (a != null) {
        if (r[a].type === i)
          return a;
      } else
        a = r.length;
      return r[a] = {
        type: i
      }, n.set(t, a), this._chunks[a] = new Vx[i || "float"](this._rawCount), this._rawExtent[a] = Ta(), a;
    }, e.prototype.collectOrdinalMeta = function(t, i) {
      var n = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, s = r.ordinalOffset || 0, o = n.length;
      s === 0 && (a[t] = Ta());
      for (var l = a[t], u = s; u < o; u++) {
        var c = n[u] = i.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      r.ordinalMeta = i, r.ordinalOffset = o, r.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var i = this._dimensions[t], n = i.ordinalMeta;
      return n;
    }, e.prototype.getDimensionProperty = function(t) {
      var i = this._dimensions[t];
      return i && i.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && tt(!this._indices, "appendData can only be called on raw data.");
      var i = this._provider, n = this.count();
      i.appendData(t);
      var r = i.count();
      return i.persistent || (r += n), n < r && this._initDataFromProvider(n, r, !0), [n, r];
    }, e.prototype.appendValues = function(t, i) {
      for (var n = this._chunks, r = this._dimensions, a = r.length, s = this._rawExtent, o = this.count(), l = o + Math.max(t.length, i || 0), u = 0; u < a; u++) {
        var c = r[u];
        f_(n, u, c.type, l, !0);
      }
      for (var h = [], f = o; f < l; f++)
        for (var d = f - o, v = 0; v < a; v++) {
          var c = r[v], g = of.arrayRows.call(this, t[d] || h, c.property, d, v);
          n[v][f] = g;
          var p = s[v];
          g < p[0] && (p[0] = g), g > p[1] && (p[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: o,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, i, n) {
      for (var r = this._provider, a = this._chunks, s = this._dimensions, o = s.length, l = this._rawExtent, u = bt(s, function(y) {
        return y.property;
      }), c = 0; c < o; c++) {
        var h = s[c];
        l[c] || (l[c] = Ta()), f_(a, c, h.type, i, n);
      }
      if (r.fillStorage)
        r.fillStorage(t, i, a, l);
      else
        for (var f = [], d = t; d < i; d++) {
          f = r.getItem(d, f);
          for (var v = 0; v < o; v++) {
            var g = a[v], p = this._dimValueGetter(f, u[v], d, v);
            g[d] = p;
            var m = l[v];
            p < m[0] && (m[0] = p), p > m[1] && (m[1] = p);
          }
        }
      !r.persistent && r.clean && r.clean(), this._rawCount = this._count = i, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, i) {
      if (!(i >= 0 && i < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(i)] : NaN;
    }, e.prototype.getValues = function(t, i) {
      var n = [], r = [];
      if (i == null) {
        i = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          r.push(a);
      } else
        r = t;
      for (var a = 0, s = r.length; a < s; a++)
        n.push(this.get(r[a], i));
      return n;
    }, e.prototype.getByRawIndex = function(t, i) {
      if (!(i >= 0 && i < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[i] : NaN;
    }, e.prototype.getSum = function(t) {
      var i = this._chunks[t], n = 0;
      if (i)
        for (var r = 0, a = this.count(); r < a; r++) {
          var s = this.get(t, r);
          isNaN(s) || (n += s);
        }
      return n;
    }, e.prototype.getMedian = function(t) {
      var i = [];
      this.each([t], function(a) {
        isNaN(a) || i.push(a);
      });
      var n = i.sort(function(a, s) {
        return a - s;
      }), r = this.count();
      return r === 0 ? 0 : r % 2 === 1 ? n[(r - 1) / 2] : (n[r / 2] + n[r / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var i = this._indices, n = i[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var r = 0, a = this._count - 1; r <= a; ) {
        var s = (r + a) / 2 | 0;
        if (i[s] < t)
          r = s + 1;
        else if (i[s] > t)
          a = s - 1;
        else
          return s;
      }
      return -1;
    }, e.prototype.getIndices = function() {
      var t, i = this._indices;
      if (i) {
        var n = i.constructor, r = this._count;
        if (n === Array) {
          t = new n(r);
          for (var a = 0; a < r; a++)
            t[a] = i[a];
        } else
          t = new n(i.buffer, 0, r);
      } else {
        var n = Ma(this._rawCount);
        t = new n(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, e.prototype.filter = function(t, i) {
      if (!this._count)
        return this;
      for (var n = this.clone(), r = n.count(), a = Ma(n._rawCount), s = new a(r), o = [], l = t.length, u = 0, c = t[0], h = n._chunks, f = 0; f < r; f++) {
        var d = void 0, v = n.getRawIndex(f);
        if (l === 0)
          d = i(f);
        else if (l === 1) {
          var g = h[c][v];
          d = i(g, f);
        } else {
          for (var p = 0; p < l; p++)
            o[p] = h[t[p]][v];
          o[p] = f, d = i.apply(null, o);
        }
        d && (s[u++] = v);
      }
      return u < r && (n._indices = s), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.selectRange = function(t) {
      var i = this.clone(), n = i._count;
      if (!n)
        return this;
      var r = jt(t), a = r.length;
      if (!a)
        return this;
      var s = i.count(), o = Ma(i._rawCount), l = new o(s), u = 0, c = r[0], h = t[c][0], f = t[c][1], d = i._chunks, v = !1;
      if (!i._indices) {
        var g = 0;
        if (a === 1) {
          for (var p = d[r[0]], m = 0; m < n; m++) {
            var y = p[m];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = g), g++;
          }
          v = !0;
        } else if (a === 2) {
          for (var p = d[r[0]], _ = d[r[1]], b = t[r[1]][0], x = t[r[1]][1], m = 0; m < n; m++) {
            var y = p[m], w = _[m];
            (y >= h && y <= f || isNaN(y)) && (w >= b && w <= x || isNaN(w)) && (l[u++] = g), g++;
          }
          v = !0;
        }
      }
      if (!v)
        if (a === 1)
          for (var m = 0; m < s; m++) {
            var M = i.getRawIndex(m), y = d[r[0]][M];
            (y >= h && y <= f || isNaN(y)) && (l[u++] = M);
          }
        else
          for (var m = 0; m < s; m++) {
            for (var T = !0, M = i.getRawIndex(m), D = 0; D < a; D++) {
              var P = r[D], y = d[P][M];
              (y < t[P][0] || y > t[P][1]) && (T = !1);
            }
            T && (l[u++] = i.getRawIndex(m));
          }
      return u < s && (i._indices = l), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, e.prototype.map = function(t, i) {
      var n = this.clone(t);
      return this._updateDims(n, t, i), n;
    }, e.prototype.modify = function(t, i) {
      this._updateDims(this, t, i);
    }, e.prototype._updateDims = function(t, i, n) {
      for (var r = t._chunks, a = [], s = i.length, o = t.count(), l = [], u = t._rawExtent, c = 0; c < i.length; c++)
        u[i[c]] = Ta();
      for (var h = 0; h < o; h++) {
        for (var f = t.getRawIndex(h), d = 0; d < s; d++)
          l[d] = r[i[d]][f];
        l[s] = h;
        var v = n && n.apply(null, l);
        if (v != null) {
          typeof v != "object" && (a[0] = v, v = a);
          for (var c = 0; c < v.length; c++) {
            var g = i[c], p = v[c], m = u[g], y = r[g];
            y && (y[f] = p), p < m[0] && (m[0] = p), p > m[1] && (m[1] = p);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = this.clone([t], !0), r = n._chunks, a = r[t], s = this.count(), o = 0, l = Math.floor(1 / i), u = this.getRawIndex(0), c, h, f, d = new (Ma(this._rawCount))(Math.min((Math.ceil(s / l) + 2) * 2, s));
      d[o++] = u;
      for (var v = 1; v < s - 1; v += l) {
        for (var g = Math.min(v + l, s - 1), p = Math.min(v + l * 2, s), m = (p + g) / 2, y = 0, _ = g; _ < p; _++) {
          var b = this.getRawIndex(_), x = a[b];
          isNaN(x) || (y += x);
        }
        y /= p - g;
        var w = v, M = Math.min(v + l, s), T = v - 1, D = a[u];
        c = -1, f = w;
        for (var P = -1, C = 0, _ = w; _ < M; _++) {
          var b = this.getRawIndex(_), x = a[b];
          if (isNaN(x)) {
            C++, P < 0 && (P = b);
            continue;
          }
          h = Math.abs((T - m) * (x - D) - (T - _) * (y - D)), h > c && (c = h, f = b);
        }
        C > 0 && C < M - w && (d[o++] = Math.min(P, f), f = Math.max(P, f)), d[o++] = f, u = f;
      }
      return d[o++] = this.getRawIndex(s - 1), n._count = o, n._indices = d, n.getRawIndex = this._getRawIdx, n;
    }, e.prototype.minmaxDownSample = function(t, i) {
      for (var n = this.clone([t], !0), r = n._chunks, a = Math.floor(1 / i), s = r[t], o = this.count(), l = new (Ma(this._rawCount))(Math.ceil(o / a) * 2), u = 0, c = 0; c < o; c += a) {
        var h = c, f = s[this.getRawIndex(h)], d = c, v = s[this.getRawIndex(d)], g = a;
        c + a > o && (g = o - c);
        for (var p = 0; p < g; p++) {
          var m = this.getRawIndex(c + p), y = s[m];
          y < f && (f = y, h = c + p), y > v && (v = y, d = c + p);
        }
        var _ = this.getRawIndex(h), b = this.getRawIndex(d);
        h < d ? (l[u++] = _, l[u++] = b) : (l[u++] = b, l[u++] = _);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, e.prototype.downSample = function(t, i, n, r) {
      for (var a = this.clone([t], !0), s = a._chunks, o = [], l = Math.floor(1 / i), u = s[t], c = this.count(), h = a._rawExtent[t] = Ta(), f = new (Ma(this._rawCount))(Math.ceil(c / l)), d = 0, v = 0; v < c; v += l) {
        l > c - v && (l = c - v, o.length = l);
        for (var g = 0; g < l; g++) {
          var p = this.getRawIndex(v + g);
          o[g] = u[p];
        }
        var m = n(o), y = this.getRawIndex(Math.min(v + r(o, m) || 0, c - 1));
        u[y] = m, m < h[0] && (h[0] = m), m > h[1] && (h[1] = m), f[d++] = y;
      }
      return a._count = d, a._indices = f, a._updateGetRawIdx(), a;
    }, e.prototype.each = function(t, i) {
      if (this._count)
        for (var n = t.length, r = this._chunks, a = 0, s = this.count(); a < s; a++) {
          var o = this.getRawIndex(a);
          switch (n) {
            case 0:
              i(a);
              break;
            case 1:
              i(r[t[0]][o], a);
              break;
            case 2:
              i(r[t[0]][o], r[t[1]][o], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = r[t[l]][o];
              u[l] = a, i.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var i = this._chunks[t], n = Ta();
      if (!i)
        return n;
      var r = this.count(), a = !this._indices, s;
      if (a)
        return this._rawExtent[t].slice();
      if (s = this._extent[t], s)
        return s.slice();
      s = n;
      for (var o = s[0], l = s[1], u = 0; u < r; u++) {
        var c = this.getRawIndex(u), h = i[c];
        h < o && (o = h), h > l && (l = h);
      }
      return s = [o, l], this._extent[t] = s, s;
    }, e.prototype.getRawDataItem = function(t) {
      var i = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(i);
      for (var n = [], r = this._chunks, a = 0; a < r.length; a++)
        n.push(r[a][i]);
      return n;
    }, e.prototype.clone = function(t, i) {
      var n = new e(), r = this._chunks, a = t && us(t, function(o, l) {
        return o[l] = !0, o;
      }, {});
      if (a)
        for (var s = 0; s < r.length; s++)
          n._chunks[s] = a[s] ? t5(r[s]) : r[s];
      else
        n._chunks = r;
      return this._copyCommonProps(n), i || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = dt(this._extent), t._rawExtent = dt(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, i = void 0;
        if (t === Array) {
          var n = this._indices.length;
          i = new t(n);
          for (var r = 0; r < n; r++)
            i[r] = this._indices[r];
        } else
          i = new t(this._indices);
        return i;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = (function() {
      function t(i, n, r, a) {
        return ou(i[a], this._dimensions[a]);
      }
      of = {
        arrayRows: t,
        objectRows: function(i, n, r, a) {
          return ou(i[n], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(i, n, r, a) {
          var s = i && (i.value == null ? i : i.value);
          return ou(s instanceof Array ? s[a] : s, this._dimensions[a]);
        },
        typedArray: function(i, n, r, a) {
          return i[a];
        }
      };
    })(), e;
  })()
), e5 = (
  /** @class */
  (function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, i) {
      this._sourceList = t, this._upstreamSignList = i, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, i = this._getUpstreamSourceManagers(), n = !!i.length, r, a;
      if (Ps(t)) {
        var s = t, o = void 0, l = void 0, u = void 0;
        if (n) {
          var c = i[0];
          c.prepareSource(), u = c.getSource(), o = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          o = s.get("data", !0), l = Le(o) ? _n : Ke, a = [];
        var h = this._getSourceMetaRawOption() || {}, f = u && u.metaRawOption || {}, d = et(h.seriesLayoutBy, f.seriesLayoutBy) || null, v = et(h.sourceHeader, f.sourceHeader), g = et(h.dimensions, f.dimensions), p = d !== f.seriesLayoutBy || !!v != !!f.sourceHeader || g;
        r = p ? [wd(o, {
          seriesLayoutBy: d,
          sourceHeader: v,
          dimensions: g
        }, l)] : [];
      } else {
        var m = t;
        if (n) {
          var y = this._applyTransform(i);
          r = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = m.get("source", !0);
          r = [wd(_, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && tt(r && a), this._setLocalSource(r, a);
    }, e.prototype._applyTransform = function(t) {
      var i = this._sourceHost, n = i.get("transform", !0), r = i.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && tt(r != null || n != null), r != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), d_(a));
      }
      var s, o = [], l = [];
      return k(t, function(u) {
        u.prepareSource();
        var c = u.getSource(r || 0), h = "";
        r != null && !c && (process.env.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + r), d_(h)), o.push(c), l.push(u._getVersionSign());
      }), n ? s = ZR(n, o, {
        datasetIndex: i.componentIndex
      }) : r != null && (s = [LR(o[0])]), {
        sourceList: s,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), i = 0; i < t.length; i++) {
        var n = t[i];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[i] !== n._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var i = this._sourceList[t];
      if (!i) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return i;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && tt(Ps(this._sourceHost), "Can only call getDataStore on series source manager.");
      var i = t.makeStoreSchema();
      return this._innerGetDataStore(i.dimensions, t.source, i.hash);
    }, e.prototype._innerGetDataStore = function(t, i, n) {
      var r = 0, a = this._storeList, s = a[r];
      s || (s = a[r] = {});
      var o = s[n];
      if (!o) {
        var l = this._getUpstreamSourceManagers()[0];
        Ps(this._sourceHost) && l ? o = l._innerGetDataStore(t, i, n) : (o = new Sd(), o.initData(new Ix(i, t.length), t)), s[n] = o;
      }
      return o;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (Ps(t)) {
        var i = Cx(t);
        return i ? [i.getSourceManager()] : [];
      } else
        return bt(rR(t), function(n) {
          return n.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, i, n, r;
      if (Ps(t))
        i = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), r = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        i = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), r = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: i,
        sourceHeader: n,
        dimensions: r
      };
    }, e;
  })()
);
function Ps(e) {
  return e.mainType === "series";
}
function d_(e) {
  throw new Error(e);
}
var i5 = "line-height:1";
function $x(e) {
  var t = e.lineHeight;
  return t == null ? i5 : "line-height:" + Fe(t + "") + "px";
}
function Hx(e, t) {
  var i = e.color || St.color.tertiary, n = e.fontSize || 12, r = e.fontWeight || "400", a = e.color || St.color.secondary, s = e.fontSize || 14, o = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Fe(n + "") + "px;color:" + Fe(i) + ";font-weight:" + Fe(r + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Fe(s + "") + "px;color:" + Fe(a) + ";font-weight:" + Fe(o + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: i,
      fontWeight: r
    },
    valueStyle: {
      fontSize: s,
      fill: a,
      fontWeight: o
    }
  };
}
var n5 = [0, 10, 20, 30], r5 = ["", `
`, `

`, `


`];
function aa(e, t) {
  return t.type = e, t;
}
function Md(e) {
  return e.type === "section";
}
function Yx(e) {
  return Md(e) ? a5 : s5;
}
function Wx(e) {
  if (Md(e)) {
    var t = 0, i = e.blocks.length, n = i > 1 || i > 0 && !e.noHeader;
    return k(e.blocks, function(r) {
      var a = Wx(r);
      a >= t && (t = a + +(n && // 0 always can not be readable gap level.
      (!a || Md(r) && !r.noHeader)));
    }), t;
  }
  return 0;
}
function a5(e, t, i, n) {
  var r = t.noHeader, a = o5(Wx(t)), s = [], o = t.blocks || [];
  tt(!o || j(o)), o = o || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    o = o.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Ui(u, l)) {
      var c = new HR(u[l], null);
      o.sort(function(g, p) {
        return c.evaluate(g.sortParam, p.sortParam);
      });
    } else l === "seriesDesc" && o.reverse();
  }
  k(o, function(g, p) {
    var m = t.valueFormatter, y = Yx(g)(
      // Inherit valueFormatter
      m ? Y(Y({}, e), {
        valueFormatter: m
      }) : e,
      g,
      p > 0 ? a.html : 0,
      n
    );
    y != null && s.push(y);
  });
  var h = e.renderMode === "richText" ? s.join(a.richText) : Td(n, s.join(""), r ? i : a.html);
  if (r)
    return h;
  var f = bd(t.header, "ordinal", e.useUTC), d = Hx(n, e.renderMode).nameStyle, v = $x(n);
  return e.renderMode === "richText" ? Ux(e, f, d) + a.richText + h : Td(n, '<div style="' + d + ";" + v + ';">' + Fe(f) + "</div>" + h, i);
}
function s5(e, t, i, n) {
  var r = e.renderMode, a = t.noName, s = t.noValue, o = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(b) {
    return b = j(b) ? b : [b], bt(b, function(x, w) {
      return bd(x, j(d) ? d[w] : d, u);
    });
  };
  if (!(a && s)) {
    var h = o ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || St.color.secondary, r), f = a ? "" : bd(l, "ordinal", u), d = t.valueType, v = s ? [] : c(t.value, t.dataIndex), g = !o || !a, p = !o && a, m = Hx(n, r), y = m.nameStyle, _ = m.valueStyle;
    return r === "richText" ? (o ? "" : h) + (a ? "" : Ux(e, f, y)) + (s ? "" : c5(e, v, g, p, _)) : Td(n, (o ? "" : h) + (a ? "" : l5(f, !o, y)) + (s ? "" : u5(v, g, p, _)), i);
  }
}
function v_(e, t, i, n, r, a) {
  if (e) {
    var s = Yx(e), o = {
      useUTC: r,
      renderMode: i,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return s(o, e, 0, a);
  }
}
function o5(e) {
  return {
    html: n5[e],
    richText: r5[e]
  };
}
function Td(e, t, i) {
  var n = '<div style="clear:both"></div>', r = "margin: " + i + "px 0 0", a = $x(e);
  return '<div style="' + r + ";" + a + ';">' + t + n + "</div>";
}
function l5(e, t, i) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + i + ";" + n + '">' + Fe(e) + "</span>";
}
function u5(e, t, i, n) {
  var r = i ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
  return e = j(e) ? e : [e], '<span style="' + a + ";" + n + '">' + bt(e, function(s) {
    return Fe(s);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function Ux(e, t, i) {
  return e.markupStyleCreator.wrapRichTextStyle(t, i);
}
function c5(e, t, i, n, r) {
  var a = [r], s = n ? 10 : 20;
  return i && a.push({
    padding: [0, 0, 0, s],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(j(t) ? t.join("  ") : t, a);
}
function h5(e, t) {
  var i = e.getData().getItemVisual(t, "style"), n = i[e.visualDrawType];
  return Oo(n);
}
function Gx(e, t) {
  var i = e.get("padding");
  return i ?? (t === "richText" ? [8, 10] : 10);
}
var lf = (
  /** @class */
  (function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = b1();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, i, n) {
      var r = n === "richText" ? this._generateStyleName() : null, a = GI({
        color: i,
        type: t,
        renderMode: n,
        markerId: r
      });
      return Q(a) ? a : (process.env.NODE_ENV !== "production" && tt(r), this.richTextStyles[r] = a.style, a.content);
    }, e.prototype.wrapRichTextStyle = function(t, i) {
      var n = {};
      j(i) ? k(i, function(a) {
        return Y(n, a);
      }) : Y(n, i);
      var r = this._generateStyleName();
      return this.richTextStyles[r] = n, "{" + r + "|" + t + "}";
    }, e;
  })()
);
function f5(e) {
  var t = e.series, i = e.dataIndex, n = e.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), s = a.length, o = t.getRawValue(i), l = j(o), u = h5(t, i), c, h, f, d;
  if (s > 1 || l && !s) {
    var v = d5(o, t, i, a, u);
    c = v.inlineValues, h = v.inlineValueTypes, f = v.blocks, d = v.inlineValues[0];
  } else if (s) {
    var g = r.getDimensionInfo(a[0]);
    d = c = Uu(r, i, a[0]), h = g.type;
  } else
    d = c = l ? o[0] : o;
  var p = M1(t), m = p && t.name || "", y = r.getName(i), _ = n ? m : y;
  return aa("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !p,
    sortParam: d,
    blocks: [aa("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: _,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !Hi(_),
      value: c,
      valueType: h,
      dataIndex: i
    })].concat(f || [])
  });
}
function d5(e, t, i, n, r) {
  var a = t.getData(), s = us(e, function(h, f, d) {
    var v = a.getDimensionInfo(d);
    return h = h || v && v.tooltip !== !1 && v.displayName != null;
  }, !1), o = [], l = [], u = [];
  n.length ? k(n, function(h) {
    c(Uu(a, i, h), h);
  }) : k(e, c);
  function c(h, f) {
    var d = a.getDimensionInfo(f);
    !d || d.otherDims.tooltip === !1 || (s ? u.push(aa("nameValue", {
      markerType: "subItem",
      markerColor: r,
      name: d.displayName,
      value: h,
      valueType: d.type
    })) : (o.push(h), l.push(d.type)));
  }
  return {
    inlineValues: o,
    inlineValueTypes: l,
    blocks: u
  };
}
var On = Wt();
function Nl(e, t) {
  return e.getName(t) || e.getId(t);
}
var v5 = "__universalTransitionEnabled", er = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i._selectedDataIndicesMap = {}, i;
    }
    return t.prototype.init = function(i, n, r) {
      this.seriesIndex = this.componentIndex, this.dataTask = po({
        count: g5,
        reset: m5
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(i, r);
      var a = On(this).sourceManager = new e5(this);
      a.prepareSource();
      var s = this.getInitialData(i, r);
      g_(s, this), this.dataTask.context.data = s, process.env.NODE_ENV !== "production" && tt(s, "getInitialData returned invalid data."), On(this).dataBeforeProcessed = s, p_(this), this._initSelectedMapFromData(s);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = $u(this), a = r ? xx(i) : {}, s = this.subType;
      Pt.hasClass(s) && (s += "Series"), re(i, n.getTheme().get(this.subType)), re(i, this.getDefaultOption()), Um(i, "label", ["show"]), this.fillDataTextStyle(i.data), r && Hu(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      i = re(this.option, i, !0), this.fillDataTextStyle(i.data);
      var r = $u(this);
      r && Hu(this.option, i, r);
      var a = On(this).sourceManager;
      a.dirty(), a.prepareSource();
      var s = this.getInitialData(i, n);
      g_(s, this), this.dataTask.dirty(), this.dataTask.context.data = s, On(this).dataBeforeProcessed = s, p_(this), this._initSelectedMapFromData(s);
    }, t.prototype.fillDataTextStyle = function(i) {
      if (i && !Le(i))
        for (var n = ["show"], r = 0; r < i.length; r++)
          i[r] && i[r].label && Um(i[r], "label", n);
    }, t.prototype.getInitialData = function(i, n) {
    }, t.prototype.appendData = function(i) {
      var n = this.getRawData();
      n.appendData(i.data);
    }, t.prototype.getData = function(i) {
      var n = Dd(this);
      if (n) {
        var r = n.context.data;
        return i == null || !r.getLinkedData ? r : r.getLinkedData(i);
      } else
        return On(this).data;
    }, t.prototype.getAllData = function() {
      var i = this.getData();
      return i && i.getLinkedDataAll ? i.getLinkedDataAll() : [{
        data: i
      }];
    }, t.prototype.setData = function(i) {
      var n = Dd(this);
      if (n) {
        var r = n.context;
        r.outputData = i, n !== this.dataTask && (r.data = i);
      }
      On(this).data = i;
    }, t.prototype.getEncode = function() {
      var i = this.get("encode", !0);
      if (i)
        return lt(i);
    }, t.prototype.getSourceManager = function() {
      return On(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return On(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var i = this.get("colorBy");
      return i || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var i = this.coordinateSystem;
      return i && i.getBaseAxis && i.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(i, n, r, a) {
      var s = this.getData(), o = this.coordinateSystem, l = o && o.getAxis(i);
      if (!o || !l)
        return [];
      var u = l.dataToCoord(r);
      a == null && (a = 1 / 0);
      var c = [], h = 1 / 0, f = -1, d = 0;
      return s.each(n, function(v, g) {
        var p = l.dataToCoord(v), m = u - p, y = Math.abs(m);
        y <= a && ((y < h || y === h && m >= 0 && f < 0) && (h = y, f = m, d = 0), m === f && (c[d++] = g));
      }), c.length = d, c;
    }, t.prototype.formatTooltip = function(i, n, r) {
      return f5({
        series: this,
        dataIndex: i,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var i = this.ecModel;
      if (rt.node && !(i && i.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(i, n, r) {
      var a = this.ecModel, s = Jv.prototype.getColorFromPalette.call(this, i, n, r);
      return s || (s = a.getColorFromPalette(i, n, r)), s;
    }, t.prototype.coordDimToDataDim = function(i) {
      return this.getRawData().mapDimensionsAll(i);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(i, n) {
      this._innerSelect(this.getData(n), i);
    }, t.prototype.unselect = function(i, n) {
      var r = this.option.selectedMap;
      if (r) {
        var a = this.option.selectedMode, s = this.getData(n);
        if (a === "series" || r === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var o = 0; o < i.length; o++) {
          var l = i[o], u = Nl(s, l);
          r[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(i, n) {
      for (var r = [], a = 0; a < i.length; a++)
        r[0] = i[a], this.isSelected(i[a], n) ? this.unselect(r, n) : this.select(r, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var i = this._selectedDataIndicesMap, n = jt(i), r = [], a = 0; a < n.length; a++) {
        var s = i[n[a]];
        s >= 0 && r.push(s);
      }
      return r;
    }, t.prototype.isSelected = function(i, n) {
      var r = this.option.selectedMap;
      if (!r)
        return !1;
      var a = this.getData(n);
      return (r === "all" || r[Nl(a, i)]) && !a.getItemModel(i).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[v5])
        return !0;
      var i = this.option.universalTransition;
      return i ? i === !0 ? !0 : i && i.enabled : !1;
    }, t.prototype._innerSelect = function(i, n) {
      var r, a, s = this.option, o = s.selectedMode, l = n.length;
      if (!(!o || !l)) {
        if (o === "series")
          s.selectedMap = "all";
        else if (o === "multiple") {
          q(s.selectedMap) || (s.selectedMap = {});
          for (var u = s.selectedMap, c = 0; c < l; c++) {
            var h = n[c], f = Nl(i, h);
            u[f] = !0, this._selectedDataIndicesMap[f] = i.getRawIndex(h);
          }
        } else if (o === "single" || o === !0) {
          var d = n[l - 1], f = Nl(i, d);
          s.selectedMap = (r = {}, r[f] = !0, r), this._selectedDataIndicesMap = (a = {}, a[f] = i.getRawIndex(d), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(i) {
      if (!this.option.selectedMap) {
        var n = [];
        i.hasItemOption && i.each(function(r) {
          var a = i.getRawDataItem(r);
          a && a.selected && n.push(r);
        }), n.length > 0 && this._innerSelect(i, n);
      }
    }, t.registerClass = function(i) {
      return Pt.registerClass(i);
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "series.__base__", i.seriesIndex = 0, i.ignoreStyleOnData = !1, i.hasSymbolVisual = !1, i.defaultSymbol = "circle", i.visualStyleAccessPath = "itemStyle", i.visualDrawType = "fill";
    })(), t;
  })(Pt)
);
Ci(er, VR);
Ci(er, Jv);
C1(er, Pt);
function p_(e) {
  var t = e.name;
  M1(e) || (e.name = p5(e) || t);
}
function p5(e) {
  var t = e.getRawData(), i = t.mapDimensionsAll("seriesName"), n = [];
  return k(i, function(r) {
    var a = t.getDimensionInfo(r);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function g5(e) {
  return e.model.getRawData().count();
}
function m5(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), y5;
}
function y5(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function g_(e, t) {
  k(lA(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(i) {
    e.wrapMethod(i, Ae(_5, t));
  });
}
function _5(e, t) {
  var i = Dd(e);
  return i && i.setOutputEnd((t || this).count()), t;
}
function Dd(e) {
  var t = (e.ecModel || {}).scheduler, i = t && t.getPipeline(e.uid);
  if (i) {
    var n = i.currentTask;
    if (n) {
      var r = n.agentStubMap;
      r && (n = r.get(e.uid));
    }
    return n;
  }
}
var Mn = (
  /** @class */
  (function() {
    function e() {
      this.group = new Mi(), this.uid = Lc("viewComponent");
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
    }, e.prototype.updateLayout = function(t, i, n, r) {
    }, e.prototype.updateVisual = function(t, i, n, r) {
    }, e.prototype.toggleBlurSeries = function(t, i, n) {
    }, e.prototype.eachRendered = function(t) {
      var i = this.group;
      i && i.traverse(t);
    }, e;
  })()
);
Dv(Mn);
Cv(Mn);
function b5() {
  var e = Wt();
  return function(t) {
    var i = e(t), n = t.pipelineContext, r = !!i.large, a = !!i.progressiveRender, s = i.large = !!(n && n.large), o = i.progressiveRender = !!(n && n.progressiveRender);
    return (r !== s || a !== o) && "reset";
  };
}
var jx = Wt(), x5 = b5(), Xn = (
  /** @class */
  (function() {
    function e() {
      this.group = new Mi(), this.uid = Lc("viewChart"), this.renderTask = po({
        plan: w5,
        reset: S5
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && qt("Unknown dataType " + r.dataType);
        return;
      }
      y_(a, r, "emphasis");
    }, e.prototype.downplay = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && qt("Unknown dataType " + r.dataType);
        return;
      }
      y_(a, r, "normal");
    }, e.prototype.remove = function(t, i) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateLayout = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateVisual = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.eachRendered = function(t) {
      ux(this.group, t);
    }, e.markUpdateMethod = function(t, i) {
      jx(t).updateMethod = i;
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.type = "chart";
    })(), e;
  })()
);
function m_(e, t, i) {
  e && as(e) && (t === "emphasis" ? Bu : zu)(e, i);
}
function y_(e, t, i) {
  var n = Go(e, t), r = t && t.highlightKey != null ? xO(t.highlightKey) : null;
  n != null ? k(Ee(n), function(a) {
    m_(e.getItemGraphicEl(a), i, r);
  }) : e.eachItemGraphicEl(function(a) {
    m_(a, i, r);
  });
}
Dv(Xn, ["dispose"]);
Cv(Xn);
function w5(e) {
  return x5(e.model);
}
function S5(e) {
  var t = e.model, i = e.ecModel, n = e.api, r = e.payload, a = t.pipelineContext.progressiveRender, s = e.view, o = r && jx(r).updateMethod, l = a ? "incrementalPrepareRender" : o && s[o] ? o : "render";
  return l !== "render" && s[l](t, i, n, r), M5[l];
}
var M5 = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, Gu = "\0__throttleOriginMethod", __ = "\0__throttleRate", b_ = "\0__throttleType";
function Xx(e, t, i) {
  var n, r = 0, a = 0, s = null, o, l, u, c;
  t = t || 0;
  function h() {
    a = (/* @__PURE__ */ new Date()).getTime(), s = null, e.apply(l, u || []);
  }
  var f = function() {
    for (var d = [], v = 0; v < arguments.length; v++)
      d[v] = arguments[v];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = d;
    var g = c || t, p = c || i;
    c = null, o = n - (p ? r : a) - g, clearTimeout(s), p ? s = setTimeout(h, g) : o >= 0 ? h() : s = setTimeout(h, -o), r = n;
  };
  return f.clear = function() {
    s && (clearTimeout(s), s = null);
  }, f.debounceNextCall = function(d) {
    c = d;
  }, f;
}
function qx(e, t, i, n) {
  var r = e[t];
  if (r) {
    var a = r[Gu] || r, s = r[b_], o = r[__];
    if (o !== i || s !== n) {
      if (i == null || !n)
        return e[t] = a;
      r = e[t] = Xx(a, i, n === "debounce"), r[Gu] = a, r[b_] = n, r[__] = i;
    }
    return r;
  }
}
function Cd(e, t) {
  var i = e[t];
  i && i[Gu] && (i.clear && i.clear(), e[t] = i[Gu]);
}
var x_ = Wt(), w_ = {
  itemStyle: Ao(dx, !0),
  lineStyle: Ao(fx, !0)
}, T5 = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function Zx(e, t) {
  var i = e.visualStyleMapper || w_[t];
  return i || (console.warn("Unknown style type '" + t + "'."), w_.itemStyle);
}
function Kx(e, t) {
  var i = e.visualDrawType || T5[t];
  return i || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var D5 = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = e.getModel(n), a = Zx(e, n), s = a(r), o = r.getShallow("decal");
    o && (i.setVisual("decal", o), o.dirty = !0);
    var l = Kx(e, n), u = s[l], c = mt(u) ? u : null, h = s.fill === "auto" || s.stroke === "auto";
    if (!s[l] || c || h) {
      var f = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      s[l] || (s[l] = f, i.setVisual("colorFromPalette", !0)), s.fill = s.fill === "auto" || mt(s.fill) ? f : s.fill, s.stroke = s.stroke === "auto" || mt(s.stroke) ? f : s.stroke;
    }
    if (i.setVisual("style", s), i.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return i.setVisual("colorFromPalette", !1), {
        dataEach: function(d, v) {
          var g = e.getDataParams(v), p = Y({}, s);
          p[l] = c(g), d.setItemVisual(v, "style", p);
        }
      };
  }
}, As = new Gt(), C5 = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = Zx(e, n), a = i.getVisual("drawType");
      return {
        dataEach: i.hasItemOption ? function(s, o) {
          var l = s.getRawDataItem(o);
          if (l && l[n]) {
            As.option = l[n];
            var u = r(As), c = s.ensureUniqueItemVisual(o, "style");
            Y(c, u), As.option.decal && (s.setItemVisual(o, "decal", As.option.decal), As.option.decal.dirty = !0), a in u && s.setItemVisual(o, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, k5 = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = lt();
    e.eachSeries(function(i) {
      var n = i.getColorBy();
      if (!i.isColorBySeries()) {
        var r = i.type + "-" + n, a = t.get(r);
        a || (a = {}, t.set(r, a)), x_(i).scope = a;
      }
    }), e.eachSeries(function(i) {
      if (!(i.isColorBySeries() || e.isSeriesFiltered(i))) {
        var n = i.getRawData(), r = {}, a = i.getData(), s = x_(i).scope, o = i.visualStyleAccessPath || "itemStyle", l = Kx(i, o);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          r[c] = u;
        }), n.each(function(u) {
          var c = r[u], h = a.getItemVisual(c, "colorFromPalette");
          if (h) {
            var f = a.ensureUniqueItemVisual(c, "style"), d = n.getName(u) || u + "", v = n.count();
            f[l] = i.getColorFromPalette(d, s, v);
          }
        });
      }
    });
  }
}, Fl = Math.PI;
function P5(e, t) {
  t = t || {}, Qt(t, {
    text: "loading",
    textColor: St.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: St.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var i = new Mi(), n = new xe({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  i.add(n);
  var r = new vi({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new xe({
    style: {
      fill: "none"
    },
    textContent: r,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  i.add(a);
  var s;
  return t.showSpinner && (s = new Ac({
    shape: {
      startAngle: -Fl / 2,
      endAngle: -Fl / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), s.animateShape(!0).when(1e3, {
    endAngle: Fl * 3 / 2
  }).start("circularInOut"), s.animateShape(!0).when(1e3, {
    startAngle: Fl * 3 / 2
  }).delay(300).start("circularInOut"), i.add(s)), i.resize = function() {
    var o = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && o ? 10 : 0) - o) / 2 - (t.showSpinner && o ? 0 : 5 + o / 2) + (t.showSpinner ? 0 : o / 2) + (o ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && s.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, i.resize(), i;
}
var Qx = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this._stageTaskMap = lt(), this.ecInstance = t, this.api = i, n = this._dataProcessorHandlers = n.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = n.concat(r);
    }
    return e.prototype.restoreData = function(t, i) {
      t.restoreData(i), this._stageTaskMap.each(function(n) {
        var r = n.overallTask;
        r && r.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, i) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), r = n.context, a = !i && n.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > n.blockIndex, s = a ? n.step : null, o = r && r.modDataCount, l = o != null ? Math.ceil(o / s) : null;
        return {
          step: s,
          modBy: l,
          modDataCount: o
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, i) {
      var n = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), s = n.progressiveEnabled && i.incrementalPrepareRender && a >= n.threshold, o = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = n.context = {
        progressiveRender: s,
        modDataCount: l,
        large: o
      };
    }, e.prototype.restorePipelines = function(t) {
      var i = this, n = i._pipelineMap = lt();
      t.eachSeries(function(r) {
        var a = r.getProgressive(), s = r.uid;
        n.set(s, {
          id: s,
          head: null,
          tail: null,
          threshold: r.getProgressiveThreshold(),
          progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), i._pipe(r, r.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, i = this.api.getModel(), n = this.api;
      k(this._allHandlers, function(r) {
        var a = t.get(r.uid) || t.set(r.uid, {}), s = "";
        process.env.NODE_ENV !== "production" && (s = '"reset" and "overallReset" must not be both specified.'), tt(!(r.reset && r.overallReset), s), r.reset && this._createSeriesStageTask(r, a, i, n), r.overallReset && this._createOverallStageTask(r, a, i, n);
      }, this);
    }, e.prototype.prepareView = function(t, i, n, r) {
      var a = t.renderTask, s = a.context;
      s.model = i, s.ecModel = n, s.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(i, a);
    }, e.prototype.performDataProcessorTasks = function(t, i) {
      this._performStageTasks(this._dataProcessorHandlers, t, i, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, i, n) {
      this._performStageTasks(this._visualHandlers, t, i, n);
    }, e.prototype._performStageTasks = function(t, i, n, r) {
      r = r || {};
      var a = !1, s = this;
      k(t, function(l, u) {
        if (!(r.visualType && r.visualType !== l.visualType)) {
          var c = s._stageTaskMap.get(l.uid), h = c.seriesTaskMap, f = c.overallTask;
          if (f) {
            var d, v = f.agentStubMap;
            v.each(function(p) {
              o(r, p) && (p.dirty(), d = !0);
            }), d && f.dirty(), s.updatePayload(f, n);
            var g = s.getPerformArgs(f, r.block);
            v.each(function(p) {
              p.perform(g);
            }), f.perform(g) && (a = !0);
          } else h && h.each(function(p, m) {
            o(r, p) && p.dirty();
            var y = s.getPerformArgs(p, r.block);
            y.skip = !l.performRawSeries && i.isSeriesFiltered(p.context.model), s.updatePayload(p, n), p.perform(y) && (a = !0);
          });
        }
      });
      function o(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var i;
      t.eachSeries(function(n) {
        i = n.dataTask.perform() || i;
      }), this.unfinished = i || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var i = t.tail;
        do {
          if (i.__block) {
            t.blockIndex = i.__idxInPipeline;
            break;
          }
          i = i.getUpstream();
        } while (i);
      });
    }, e.prototype.updatePayload = function(t, i) {
      i !== "remain" && (t.context.payload = i);
    }, e.prototype._createSeriesStageTask = function(t, i, n, r) {
      var a = this, s = i.seriesTaskMap, o = i.seriesTaskMap = lt(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, r).each(c);
      function c(h) {
        var f = h.uid, d = o.set(f, s && s.get(f) || po({
          plan: I5,
          reset: R5,
          count: F5
        }));
        d.context = {
          model: h,
          ecModel: n,
          api: r,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(h, d);
      }
    }, e.prototype._createOverallStageTask = function(t, i, n, r) {
      var a = this, s = i.overallTask = i.overallTask || po({
        reset: A5
      });
      s.context = {
        ecModel: n,
        api: r,
        overallReset: t.overallReset,
        scheduler: a
      };
      var o = s.agentStubMap, l = s.agentStubMap = lt(), u = t.seriesType, c = t.getTargetSeries, h = !0, f = !1, d = "";
      process.env.NODE_ENV !== "production" && (d = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), tt(!t.createOnAllSeries, d), u ? n.eachRawSeriesByType(u, v) : c ? c(n, r).each(v) : (h = !1, k(n.getSeries(), v));
      function v(g) {
        var p = g.uid, m = l.set(p, o && o.get(p) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (f = !0, po({
          reset: E5,
          onDirty: O5
        })));
        m.context = {
          model: g,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = s, m.__block = h, a._pipe(g, m);
      }
      f && s.dirty();
    }, e.prototype._pipe = function(t, i) {
      var n = t.uid, r = this._pipelineMap.get(n);
      !r.head && (r.head = i), r.tail && r.tail.pipe(i), r.tail = i, i.__idxInPipeline = r.count++, i.__pipeline = r;
    }, e.wrapStageHandler = function(t, i) {
      return mt(t) && (t = {
        overallReset: t,
        seriesType: B5(t)
      }), t.uid = Lc("stageHandler"), i && (t.visualType = i), t;
    }, e;
  })()
);
function A5(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function E5(e) {
  return e.overallProgress && L5;
}
function L5() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function O5() {
  this.agent && this.agent.dirty();
}
function I5(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function R5(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = Ee(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? bt(t, function(i, n) {
    return Jx(n);
  }) : N5;
}
var N5 = Jx(0);
function Jx(e) {
  return function(t, i) {
    var n = i.data, r = i.resetDefines[e];
    if (r && r.dataEach)
      for (var a = t.start; a < t.end; a++)
        r.dataEach(n, a);
    else r && r.progress && r.progress(t, n);
  };
}
function F5(e) {
  return e.data.count();
}
function B5(e) {
  ju = null;
  try {
    e(Ro, tw);
  } catch {
  }
  return ju;
}
var Ro = {}, tw = {}, ju;
ew(Ro, tp);
ew(tw, Px);
Ro.eachSeriesByType = Ro.eachRawSeriesByType = function(e) {
  ju = e;
};
Ro.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (ju = e.subType);
};
function ew(e, t) {
  for (var i in t.prototype)
    e[i] = be;
}
var W = St.darkColor, z5 = W.background, Es = function() {
  return {
    axisLine: {
      lineStyle: {
        color: W.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: W.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [W.backgroundTint, W.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: W.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: W.axisLabel
    },
    axisName: {}
  };
}, S_ = {
  label: {
    color: W.secondary
  },
  itemStyle: {
    borderColor: W.borderTint
  },
  dividerLineStyle: {
    color: W.border
  }
}, iw = {
  darkMode: !0,
  color: W.theme,
  backgroundColor: z5,
  axisPointer: {
    lineStyle: {
      color: W.border
    },
    crossStyle: {
      color: W.borderShade
    },
    label: {
      color: W.tertiary
    }
  },
  legend: {
    textStyle: {
      color: W.secondary
    },
    pageTextStyle: {
      color: W.tertiary
    }
  },
  textStyle: {
    color: W.secondary
  },
  title: {
    textStyle: {
      color: W.primary
    },
    subtextStyle: {
      color: W.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: W.accent50
    }
  },
  tooltip: {
    backgroundColor: W.neutral20,
    defaultBorderColor: W.border,
    textStyle: {
      color: W.tertiary
    }
  },
  dataZoom: {
    borderColor: W.accent10,
    textStyle: {
      color: W.tertiary
    },
    brushStyle: {
      color: W.backgroundTint
    },
    handleStyle: {
      color: W.neutral00,
      borderColor: W.accent20
    },
    moveHandleStyle: {
      color: W.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: W.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: W.accent30
      },
      areaStyle: {
        color: W.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: W.accent50
      },
      areaStyle: {
        color: W.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: W.secondary
    },
    handleStyle: {
      borderColor: W.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: W.accent10
    },
    label: {
      color: W.tertiary
    },
    controlStyle: {
      color: W.accent30,
      borderColor: W.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: W.neutral00,
      borderColor: W.neutral20
    },
    dayLabel: {
      color: W.tertiary
    },
    monthLabel: {
      color: W.secondary
    },
    yearLabel: {
      color: W.secondary
    }
  },
  matrix: {
    x: S_,
    y: S_,
    backgroundColor: {
      borderColor: W.axisLine
    },
    body: {
      itemStyle: {
        borderColor: W.borderTint
      }
    }
  },
  timeAxis: Es(),
  logAxis: Es(),
  valueAxis: Es(),
  categoryAxis: Es(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: W.theme
  },
  gauge: {
    title: {
      color: W.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, W.neutral05]]
      }
    },
    axisLabel: {
      color: W.axisLabel
    },
    detail: {
      color: W.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: W.background
    }
  },
  radar: (function() {
    var e = Es();
    return e.axisName = {
      color: W.axisLabel
    }, e.axisLine.lineStyle.color = W.neutral20, e;
  })(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: W.neutral20,
        textStyle: {
          color: W.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: W.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: W.background
    }
  },
  map: {
    itemStyle: {
      borderColor: W.border,
      areaColor: W.neutral10
    },
    label: {
      color: W.tertiary
    },
    emphasis: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    },
    select: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: W.border,
      areaColor: W.neutral10
    },
    emphasis: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    },
    select: {
      label: {
        color: W.primary
      },
      itemStyle: {
        color: W.highlight
      }
    }
  }
};
iw.categoryAxis.splitLine.show = !1;
var V5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var i = {}, n = {}, r = {};
      if (Q(t)) {
        var a = Yi(t);
        i.mainType = a.main || null, i.subType = a.sub || null;
      } else {
        var s = ["Index", "Name", "Id"], o = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        k(t, function(l, u) {
          for (var c = !1, h = 0; h < s.length; h++) {
            var f = s[h], d = u.lastIndexOf(f);
            if (d > 0 && d === u.length - f.length) {
              var v = u.slice(0, d);
              v !== "data" && (i.mainType = v, i[f.toLowerCase()] = l, c = !0);
            }
          }
          o.hasOwnProperty(u) && (n[u] = l, c = !0), c || (r[u] = l);
        });
      }
      return {
        cptQuery: i,
        dataQuery: n,
        otherQuery: r
      };
    }, e.prototype.filter = function(t, i) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var r = n.targetEl, a = n.packedEvent, s = n.model, o = n.view;
      if (!s || !o)
        return !0;
      var l = i.cptQuery, u = i.dataQuery;
      return c(l, s, "mainType") && c(l, s, "subType") && c(l, s, "index", "componentIndex") && c(l, s, "name") && c(l, s, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!o.filterForExposedEvent || o.filterForExposedEvent(t, i.otherQuery, r, a));
      function c(h, f, d, v) {
        return h[d] == null || f[v || d] === h[d];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  })()
), kd = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], M_ = kd.concat(["symbolKeepAspect"]), $5 = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData();
    if (e.legendIcon && i.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var n = {}, r = {}, a = !1, s = 0; s < kd.length; s++) {
      var o = kd[s], l = e.get(o);
      mt(l) ? (a = !0, r[o] = l) : n[o] = l;
    }
    if (n.symbol = n.symbol || e.defaultSymbol, i.setVisual(Y({
      legendIcon: e.legendIcon || n.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(e))
      return;
    var u = jt(r);
    function c(h, f) {
      for (var d = e.getRawValue(f), v = e.getDataParams(f), g = 0; g < u.length; g++) {
        var p = u[g];
        h.setItemVisual(f, p, r[p](d, v));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, H5 = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var i = e.getData();
    function n(r, a) {
      for (var s = r.getItemModel(a), o = 0; o < M_.length; o++) {
        var l = M_[o], u = s.getShallow(l, !0);
        u != null && r.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: i.hasItemOption ? n : null
    };
  }
};
function Y5(e, t, i) {
  switch (i) {
    case "color":
      var n = e.getItemVisual(t, "style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, i);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + i);
  }
}
function W5(e, t) {
  switch (t) {
    case "color":
      var i = e.getVisual("style");
      return i[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Da(e, t, i, n, r) {
  var a = e + t;
  i.isSilent(a) || (process.env.NODE_ENV !== "production" && Sn("event " + a + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(s) {
    for (var o = s.seriesIndex, l = s.option.selectedMap, u = r.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === o) {
        var h = s.getData(), f = Go(h, r.fromActionPayload);
        i.trigger(a, {
          type: a,
          seriesId: s.id,
          name: j(f) ? h.getName(f[0]) : h.getName(f),
          selected: Q(l) ? l : Y({}, l)
        });
      }
  }));
}
function U5(e, t, i) {
  e.on("selectchanged", function(n) {
    var r = i.getModel();
    n.isFromClick ? (Da("map", "selectchanged", t, r, n), Da("pie", "selectchanged", t, r, n)) : n.fromAction === "select" ? (Da("map", "selected", t, r, n), Da("pie", "selected", t, r, n)) : n.fromAction === "unselect" && (Da("map", "unselected", t, r, n), Da("pie", "unselected", t, r, n));
  });
}
function to(e, t, i) {
  for (var n; e && !(t(e) && (n = e, i)); )
    e = e.__hostTarget || e.parent;
  return n;
}
var G5 = Math.round(Math.random() * 9), j5 = typeof Object.defineProperty == "function", X5 = (function() {
  function e() {
    this._id = "__ec_inner_" + G5++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, i) {
    var n = this._guard(t);
    return j5 ? Object.defineProperty(n, this._id, {
      value: i,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = i, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
})(), q5 = It.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n + a), e.lineTo(i - r, n + a), e.closePath();
  }
}), Z5 = It.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n), e.lineTo(i, n + a), e.lineTo(i - r, n), e.closePath();
  }
}), K5 = It.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.x, n = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), s = r / 2, o = s * s / (a - s), l = n - a + s + o, u = Math.asin(o / s), c = Math.cos(u) * s, h = Math.sin(u), f = Math.cos(u), d = s * 0.6, v = s * 0.7;
    e.moveTo(i - c, l + o), e.arc(i, l, s, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(i + c - h * d, l + o + f * d, i, n - v, i, n), e.bezierCurveTo(i, n - v, i - c + h * d, l + o + f * d, i - c, l + o), e.closePath();
  }
}), Q5 = It.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.height, n = t.width, r = t.x, a = t.y, s = n / 3 * 2;
    e.moveTo(r, a), e.lineTo(r + s, a + i), e.lineTo(r, a + i / 4 * 3), e.lineTo(r - s, a + i), e.lineTo(r, a), e.closePath();
  }
}), J5 = {
  line: hs,
  rect: xe,
  roundRect: xe,
  square: xe,
  circle: Pc,
  diamond: Z5,
  pin: K5,
  arrow: Q5,
  triangle: q5
}, tN = {
  line: function(e, t, i, n, r) {
    r.x1 = e, r.y1 = t + n / 2, r.x2 = e + i, r.y2 = t + n / 2;
  },
  rect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n;
  },
  roundRect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n, r.r = Math.min(i, n) / 4;
  },
  square: function(e, t, i, n, r) {
    var a = Math.min(i, n);
    r.x = e, r.y = t, r.width = a, r.height = a;
  },
  circle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.r = Math.min(i, n) / 2;
  },
  diamond: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  },
  pin: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  arrow: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  triangle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  }
}, Pd = {};
k(J5, function(e, t) {
  Pd[t] = new e();
});
var eN = It.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, i) {
    var n = v1(e, t, i), r = this.shape;
    return r && r.symbolType === "pin" && t.position === "inside" && (n.y = i.y + i.height * 0.4), n;
  },
  buildPath: function(e, t, i) {
    var n = t.symbolType;
    if (n !== "none") {
      var r = Pd[n];
      r || (n = "rect", r = Pd[n]), tN[n](t.x, t.y, t.width, t.height, r.shape), r.buildPath(e, r.shape, i);
    }
  }
});
function iN(e, t) {
  if (this.type !== "image") {
    var i = this.style;
    this.__isEmptyBrush ? (i.stroke = e, i.fill = t || St.color.neutral00, i.lineWidth = 2) : this.shape.symbolType === "line" ? i.stroke = e : i.fill = e, this.markRedraw();
  }
}
function nw(e, t, i, n, r, a, s) {
  var o = e.indexOf("empty") === 0;
  o && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = rx(e.slice(8), new at(t, i, n, r), s ? "center" : "cover") : e.indexOf("path://") === 0 ? l = Yv(e.slice(7), {}, new at(t, i, n, r), s ? "center" : "cover") : l = new eN({
    shape: {
      symbolType: e,
      x: t,
      y: i,
      width: n,
      height: r
    }
  }), l.__isEmptyBrush = o, l.setColor = iN, a && l.setColor(a), l;
}
function nN(e, t) {
  if (e != null)
    return j(e) || (e = [e, e]), [ze(e[0], t[0]) || 0, ze(et(e[1], e[0]), t[1]) || 0];
}
function Hr(e) {
  return isFinite(e);
}
function rN(e, t, i) {
  var n = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, s = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, s = s * i.height + i.y), n = Hr(n) ? n : 0, r = Hr(r) ? r : 1, a = Hr(a) ? a : 0, s = Hr(s) ? s : 0;
  var o = e.createLinearGradient(n, a, r, s);
  return o;
}
function aN(e, t, i) {
  var n = i.width, r = i.height, a = Math.min(n, r), s = t.x == null ? 0.5 : t.x, o = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (s = s * n + i.x, o = o * r + i.y, l = l * a), s = Hr(s) ? s : 0.5, o = Hr(o) ? o : 0.5, l = l >= 0 && Hr(l) ? l : 0.5;
  var u = e.createRadialGradient(s, o, 0, s, o, l);
  return u;
}
function Ad(e, t, i) {
  for (var n = t.type === "radial" ? aN(e, t, i) : rN(e, t, i), r = t.colorStops, a = 0; a < r.length; a++)
    n.addColorStop(r[a].offset, r[a].color);
  return n;
}
function sN(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var i = 0; i < e.length; i++)
    if (e[i] !== t[i])
      return !0;
  return !1;
}
function Bl(e) {
  return parseInt(e, 10);
}
function zl(e, t, i) {
  var n = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], s = ["paddingRight", "paddingBottom"][t];
  if (i[n] != null && i[n] !== "auto")
    return parseFloat(i[n]);
  var o = document.defaultView.getComputedStyle(e);
  return (e[r] || Bl(o[n]) || Bl(e.style[n])) - (Bl(o[a]) || 0) - (Bl(o[s]) || 0) | 0;
}
function oN(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : Xt(e) ? [e] : j(e) ? e : null;
}
function rw(e) {
  var t = e.style, i = t.lineDash && t.lineWidth > 0 && oN(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (i) {
    var r = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    r && r !== 1 && (i = bt(i, function(a) {
      return a / r;
    }), n /= r);
  }
  return [i, n];
}
var lN = new rs(!0);
function Xu(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function T_(e) {
  return typeof e == "string" && e !== "none";
}
function qu(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function D_(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = i;
  } else
    e.fill();
}
function C_(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = i;
  } else
    e.stroke();
}
function Ed(e, t, i) {
  var n = k1(t.image, t.__image, i);
  if (Dc(n)) {
    var r = e.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && r && r.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * uA), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
    }
    return r;
  }
}
function uN(e, t, i, n) {
  var r, a = Xu(i), s = qu(i), o = i.strokePercent, l = o < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || lN, h = t.__dirty;
  if (!n) {
    var f = i.fill, d = i.stroke, v = s && !!f.colorStops, g = a && !!d.colorStops, p = s && !!f.image, m = a && !!d.image, y = void 0, _ = void 0, b = void 0, x = void 0, w = void 0;
    (v || g) && (w = t.getBoundingRect()), v && (y = h ? Ad(e, f, w) : t.__canvasFillGradient, t.__canvasFillGradient = y), g && (_ = h ? Ad(e, d, w) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = _), p && (b = h || !t.__canvasFillPattern ? Ed(e, f, t) : t.__canvasFillPattern, t.__canvasFillPattern = b), m && (x = h || !t.__canvasStrokePattern ? Ed(e, d, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = x), v ? e.fillStyle = y : p && (b ? e.fillStyle = b : s = !1), g ? e.strokeStyle = _ : m && (x ? e.strokeStyle = x : a = !1);
  }
  var M = t.getGlobalScale();
  c.setScale(M[0], M[1], t.segmentIgnoreThreshold);
  var T, D;
  e.setLineDash && i.lineDash && (r = rw(t), T = r[0], D = r[1]);
  var P = !0;
  (u || h & Ia) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), P = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), P && c.rebuildPath(e, l ? o : 1), T && (e.setLineDash(T), e.lineDashOffset = D), n || (i.strokeFirst ? (a && C_(e, i), s && D_(e, i)) : (s && D_(e, i), a && C_(e, i))), T && e.setLineDash([]);
}
function cN(e, t, i) {
  var n = t.__image = k1(i.image, t.__image, t, t.onload);
  if (!(!n || !Dc(n))) {
    var r = i.x || 0, a = i.y || 0, s = t.getWidth(), o = t.getHeight(), l = n.width / n.height;
    if (s == null && o != null ? s = o * l : o == null && s != null ? o = s / l : s == null && o == null && (s = n.width, o = n.height), i.sWidth && i.sHeight) {
      var u = i.sx || 0, c = i.sy || 0;
      e.drawImage(n, u, c, i.sWidth, i.sHeight, r, a, s, o);
    } else if (i.sx && i.sy) {
      var u = i.sx, c = i.sy, h = s - u, f = o - c;
      e.drawImage(n, u, c, h, f, r, a, s, o);
    } else
      e.drawImage(n, r, a, s, o);
  }
}
function hN(e, t, i) {
  var n, r = i.text;
  if (r != null && (r += ""), r) {
    e.font = i.font || Qn, e.textAlign = i.textAlign, e.textBaseline = i.textBaseline;
    var a = void 0, s = void 0;
    e.setLineDash && i.lineDash && (n = rw(t), a = n[0], s = n[1]), a && (e.setLineDash(a), e.lineDashOffset = s), i.strokeFirst ? (Xu(i) && e.strokeText(r, i.x, i.y), qu(i) && e.fillText(r, i.x, i.y)) : (qu(i) && e.fillText(r, i.x, i.y), Xu(i) && e.strokeText(r, i.x, i.y)), a && e.setLineDash([]);
  }
}
var k_ = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], P_ = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function aw(e, t, i, n, r) {
  var a = !1;
  if (!n && (i = i || {}, t === i))
    return !1;
  if (n || t.opacity !== i.opacity) {
    He(e, r), a = !0;
    var s = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(s) ? Qr.opacity : s;
  }
  (n || t.blend !== i.blend) && (a || (He(e, r), a = !0), e.globalCompositeOperation = t.blend || Qr.blend);
  for (var o = 0; o < k_.length; o++) {
    var l = k_[o];
    (n || t[l] !== i[l]) && (a || (He(e, r), a = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== i.shadowColor) && (a || (He(e, r), a = !0), e.shadowColor = t.shadowColor || Qr.shadowColor), a;
}
function A_(e, t, i, n, r) {
  var a = No(t, r.inHover), s = n ? null : i && No(i, r.inHover) || {};
  if (a === s)
    return !1;
  var o = aw(e, a, s, n, r);
  if ((n || a.fill !== s.fill) && (o || (He(e, r), o = !0), T_(a.fill) && (e.fillStyle = a.fill)), (n || a.stroke !== s.stroke) && (o || (He(e, r), o = !0), T_(a.stroke) && (e.strokeStyle = a.stroke)), (n || a.opacity !== s.opacity) && (o || (He(e, r), o = !0), e.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (o || (He(e, r), o = !0), e.lineWidth = u);
  }
  for (var c = 0; c < P_.length; c++) {
    var h = P_[c], f = h[0];
    (n || a[f] !== s[f]) && (o || (He(e, r), o = !0), e[f] = a[f] || h[1]);
  }
  return o;
}
function fN(e, t, i, n, r) {
  return aw(e, No(t, r.inHover), i && No(i, r.inHover), n, r);
}
function sw(e, t) {
  var i = t.transform, n = e.dpr || 1;
  i ? e.setTransform(n * i[0], n * i[1], n * i[2], n * i[3], n * i[4], n * i[5]) : e.setTransform(n, 0, 0, n, 0, 0);
}
function dN(e, t, i) {
  for (var n = !1, r = 0; r < e.length; r++) {
    var a = e[r];
    n = n || a.isZeroArea(), sw(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  i.allClipped = n;
}
function vN(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var E_ = 1, L_ = 2, O_ = 3, I_ = 4;
function pN(e) {
  var t = qu(e), i = Xu(e);
  return !(e.lineDash || !(+t ^ +i) || t && typeof e.fill != "string" || i && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function He(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function No(e, t) {
  return t && e.__hoverStyle || e.style;
}
function ow(e, t) {
  Yr(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Yr(e, t, i, n) {
  var r = t.transform;
  if (!t.shouldBePainted(i.viewWidth, i.viewHeight, !1, !1)) {
    t.__dirty &= ~Xe, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, s = i.prevElClipPaths, o = !1, l = !1;
  if ((!s || sN(a, s)) && (s && s.length && (He(e, i), e.restore(), l = o = !0, i.prevElClipPaths = null, i.allClipped = !1, i.prevEl = null), a && a.length && (He(e, i), e.save(), dN(a, e, i), o = !0), i.prevElClipPaths = a), i.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = i.prevEl;
  u || (l = o = !0);
  var c = t instanceof It && t.autoBatch && pN(t.style);
  o || vN(r, u.transform) ? (He(e, i), sw(e, t)) : c || He(e, i);
  var h = No(t, i.inHover);
  t instanceof It ? (i.lastDrawType !== E_ && (l = !0, i.lastDrawType = E_), A_(e, t, u, l, i), (!c || !i.batchFill && !i.batchStroke) && e.beginPath(), uN(e, t, h, c), c && (i.batchFill = h.fill || "", i.batchStroke = h.stroke || "")) : t instanceof Ru ? (i.lastDrawType !== O_ && (l = !0, i.lastDrawType = O_), A_(e, t, u, l, i), hN(e, t, h)) : t instanceof oa ? (i.lastDrawType !== L_ && (l = !0, i.lastDrawType = L_), fN(e, t, u, l, i), cN(e, t, h)) : t.getTemporalDisplayables && (i.lastDrawType !== I_ && (l = !0, i.lastDrawType = I_), gN(e, t, i)), c && n && He(e, i), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), i.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function gN(e, t, i) {
  var n = t.getDisplayables(), r = t.getTemporalDisplayables();
  e.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: i.viewWidth,
    viewHeight: i.viewHeight,
    inHover: i.inHover
  }, s, o;
  for (s = t.getCursor(), o = n.length; s < o; s++) {
    var l = n[s];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Yr(e, l, a, s === o - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = r.length; u < c; u++) {
    var l = r[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Yr(e, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var uf = new X5(), R_ = new es(100), N_ = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function F_(e, t) {
  if (e === "none")
    return null;
  var i = t.getDevicePixelRatio(), n = t.getZr(), r = n.painter.type === "svg";
  e.dirty && uf.delete(e);
  var a = uf.get(e);
  if (a)
    return a;
  var s = Qt(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  s.backgroundColor === "none" && (s.backgroundColor = null);
  var o = {
    repeat: "repeat"
  };
  return l(o), o.rotation = s.rotation, o.scaleX = o.scaleY = r ? 1 : 1 / i, uf.set(e, o), e.dirty = !1, o;
  function l(u) {
    for (var c = [i], h = !0, f = 0; f < N_.length; ++f) {
      var d = s[N_[f]];
      if (d != null && !j(d) && !Q(d) && !Xt(d) && typeof d != "boolean") {
        h = !1;
        break;
      }
      c.push(d);
    }
    var v;
    if (h) {
      v = c.join(",") + (r ? "-svg" : "");
      var g = R_.get(v);
      g && (r ? u.svgElement = g : u.image = g);
    }
    var p = uw(s.dashArrayX), m = mN(s.dashArrayY), y = lw(s.symbol), _ = yN(p), b = cw(m), x = !r && wn.createCanvas(), w = r && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, M = D(), T;
    x && (x.width = M.width * i, x.height = M.height * i, T = x.getContext("2d")), P(), h && R_.put(v, x || w), u.image = x, u.svgElement = w, u.svgWidth = M.width, u.svgHeight = M.height;
    function D() {
      for (var C = 1, A = 0, E = _.length; A < E; ++A)
        C = Ym(C, _[A]);
      for (var R = 1, A = 0, E = y.length; A < E; ++A)
        R = Ym(R, y[A].length);
      C *= R;
      var I = b * _.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var N = function(B) {
          console.warn("Calculated decal size is greater than " + B + " due to decal option settings so " + B + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + B + " to be larger to avoid incontinuity.");
        };
        C > s.maxTileWidth && N("maxTileWidth"), I > s.maxTileHeight && N("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(C, s.maxTileWidth)),
        height: Math.max(1, Math.min(I, s.maxTileHeight))
      };
    }
    function P() {
      T && (T.clearRect(0, 0, x.width, x.height), s.backgroundColor && (T.fillStyle = s.backgroundColor, T.fillRect(0, 0, x.width, x.height)));
      for (var C = 0, A = 0; A < m.length; ++A)
        C += m[A];
      if (C <= 0)
        return;
      for (var E = -b, R = 0, I = 0, N = 0; E < M.height; ) {
        if (R % 2 === 0) {
          for (var B = I / 2 % y.length, $ = 0, H = 0, G = 0; $ < M.width * 2; ) {
            for (var nt = 0, A = 0; A < p[N].length; ++A)
              nt += p[N][A];
            if (nt <= 0)
              break;
            if (H % 2 === 0) {
              var K = (1 - s.symbolSize) * 0.5, pt = $ + p[N][H] * K, gt = E + m[R] * K, Ht = p[N][H] * s.symbolSize, ht = m[R] * s.symbolSize, le = G / 2 % y[B].length;
              De(pt, gt, Ht, ht, y[B][le]);
            }
            $ += p[N][H], ++G, ++H, H === p[N].length && (H = 0);
          }
          ++N, N === p.length && (N = 0);
        }
        E += m[R], ++I, ++R, R === m.length && (R = 0);
      }
      function De(de, Zt, it, yt, rr) {
        var Ce = r ? 1 : i, Vp = nw(rr, de * Ce, Zt * Ce, it * Ce, yt * Ce, s.color, s.symbolKeepAspect);
        if (r) {
          var $p = n.painter.renderOneToVNode(Vp);
          $p && w.children.push($p);
        } else
          ow(T, Vp);
      }
    }
  }
}
function lw(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (Q(e))
    return [[e]];
  for (var t = !0, i = 0; i < e.length; ++i)
    if (!Q(e[i])) {
      t = !1;
      break;
    }
  if (t)
    return lw([e]);
  for (var n = [], i = 0; i < e.length; ++i)
    Q(e[i]) ? n.push([e[i]]) : n.push(e[i]);
  return n;
}
function uw(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if (Xt(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var i = !0, n = 0; n < e.length; ++n)
    if (!Xt(e[n])) {
      i = !1;
      break;
    }
  if (i)
    return uw([e]);
  for (var r = [], n = 0; n < e.length; ++n)
    if (Xt(e[n])) {
      var t = Math.ceil(e[n]);
      r.push([t, t]);
    } else {
      var t = bt(e[n], function(o) {
        return Math.ceil(o);
      });
      t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
    }
  return r;
}
function mN(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if (Xt(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var i = bt(e, function(n) {
    return Math.ceil(n);
  });
  return e.length % 2 ? i.concat(i) : i;
}
function yN(e) {
  return bt(e, function(t) {
    return cw(t);
  });
}
function cw(e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += e[i];
  return e.length % 2 === 1 ? t * 2 : t;
}
function _N(e, t) {
  e.eachRawSeries(function(i) {
    if (!e.isSeriesFiltered(i)) {
      var n = i.getData();
      n.hasItemVisual() && n.each(function(s) {
        var o = n.getItemVisual(s, "decal");
        if (o) {
          var l = n.ensureUniqueItemVisual(s, "style");
          l.decal = F_(o, t);
        }
      });
      var r = n.getVisual("decal");
      if (r) {
        var a = n.getVisual("style");
        a.decal = F_(r, t);
      }
    }
  });
}
var _i = new ki(), Zu = {};
function bN(e, t) {
  process.env.NODE_ENV !== "production" && Zu[e] && qt("Already has an implementation of " + e + "."), Zu[e] = t;
}
function xN(e) {
  return process.env.NODE_ENV !== "production" && (Zu[e] || qt("Implementation of " + e + " doesn't exists.")), Zu[e];
}
var wN = 1, SN = 800, MN = 900, TN = 1e3, DN = 2e3, CN = 5e3, hw = 1e3, kN = 1100, rp = 2e3, fw = 3e3, PN = 4e3, Nc = 4500, AN = 4600, EN = 5e3, LN = 6e3, dw = 7e3, ON = {
  PROCESSOR: {
    FILTER: TN,
    SERIES_FILTER: SN,
    STATISTIC: CN
  },
  VISUAL: {
    LAYOUT: hw,
    PROGRESSIVE_LAYOUT: kN,
    GLOBAL: rp,
    CHART: fw,
    POST_CHART_LAYOUT: AN,
    COMPONENT: PN,
    BRUSH: EN,
    CHART_ITEM: Nc,
    ARIA: LN,
    DECAL: dw
  }
}, ie = "__flagInMainProcess", Vl = "__mainProcessVersion", ue = "__pendingUpdate", cf = "__needsUpdateStatus", B_ = /^[a-zA-Z0-9_]+$/, hf = "__connectUpdateStatus", z_ = 0, IN = 1, RN = 2;
function vw(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    if (this.isDisposed()) {
      Re(this.id);
      return;
    }
    return gw(this, e, t);
  };
}
function pw(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    return gw(this, e, t);
  };
}
function gw(e, t, i) {
  return i[0] = i[0] && i[0].toLowerCase(), ki.prototype[t].apply(e, i);
}
var mw = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  })(ki)
), yw = mw.prototype;
yw.on = pw("on");
yw.off = pw("off");
var Ar, ff, $l, rn, Hl, df, vf, Ca, ka, V_, $_, pf, H_, Yl, Y_, _w, ei, W_, Pa, bw = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(i, n, r) {
      var a = e.call(this, new V5()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, a._dom = i;
      var s = "canvas", o = "auto", l = !1;
      if (a[Vl] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          rt.hasGlobalWindow ? window : global
        );
        u && (s = et(u.__ECHARTS__DEFAULT__RENDERER__, s), o = et(u.__ECHARTS__DEFAULT__COARSE_POINTER, o), l = et(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      r.ssr;
      var c = a._zr = Vm(i, {
        renderer: r.renderer || s,
        devicePixelRatio: r.devicePixelRatio,
        width: r.width,
        height: r.height,
        ssr: r.ssr,
        useDirtyRect: et(r.useDirtyRect, l),
        useCoarsePointer: et(r.useCoarsePointer, o),
        pointerSize: r.pointerSize
      });
      a._ssr = r.ssr, a._throttledZrFlush = Xx(Dt(c.flush, c), 17), a._updateTheme(n), a._locale = RI(r.locale || vx), a._coordSysMgr = new Oc();
      var h = a._api = Y_(a);
      function f(d, v) {
        return d.__prio - v.__prio;
      }
      return Jl(Ju, f), Jl(Od, f), a._scheduler = new Qx(a, h, Od, Ju), a._messageCenter = new mw(), a._initEvents(), a.resize = Dt(a.resize, a), c.animation.on("frame", a._onframe, a), V_(c, a), $_(c, a), Hf(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        W_(this);
        var i = this._scheduler;
        if (this[ue]) {
          var n = this[ue].silent;
          this[ie] = !0, Pa(this);
          try {
            Ar(this), rn.update.call(this, null, this[ue].updateParams);
          } catch (l) {
            throw this[ie] = !1, this[ue] = null, l;
          }
          this._zr.flush(), this[ie] = !1, this[ue] = null, Ca.call(this, n), ka.call(this, n);
        } else if (i.unfinished) {
          var r = wN, a = this._model, s = this._api;
          i.unfinished = !1;
          do {
            var o = +/* @__PURE__ */ new Date();
            i.performSeriesTasks(a), i.performDataProcessorTasks(a), df(this, a), i.performVisualTasks(a), Yl(this, this._model, s, "remain", {}), r -= +/* @__PURE__ */ new Date() - o;
          } while (r > 0 && i.unfinished);
          i.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(i, n, r) {
      if (this[ie]) {
        process.env.NODE_ENV !== "production" && qt("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Re(this.id);
        return;
      }
      var a, s, o;
      if (q(n) && (r = n.lazyUpdate, a = n.silent, s = n.replaceMerge, o = n.transition, n = n.notMerge), this[ie] = !0, Pa(this), !this._model || n) {
        var l = new yR(this._api), u = this._theme, c = this._model = new tp();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(i, {
        replaceMerge: s
      }, Id);
      var h = {
        seriesTransition: o,
        optionChanged: !0
      };
      if (r)
        this[ue] = {
          silent: a,
          updateParams: h
        }, this[ie] = !1, this.getZr().wakeUp();
      else {
        try {
          Ar(this), rn.update.call(this, null, h);
        } catch (f) {
          throw this[ue] = null, this[ie] = !1, f;
        }
        this._ssr || this._zr.flush(), this[ue] = null, this[ie] = !1, Ca.call(this, a), ka.call(this, a);
      }
    }, t.prototype.setTheme = function(i, n) {
      if (this[ie]) {
        process.env.NODE_ENV !== "production" && qt("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Re(this.id);
        return;
      }
      var r = this._model;
      if (r) {
        var a = n && n.silent, s = null;
        this[ue] && (a == null && (a = this[ue].silent), s = this[ue].updateParams, this[ue] = null), this[ie] = !0, Pa(this);
        try {
          this._updateTheme(i), r.setTheme(this._theme), Ar(this), rn.update.call(this, {
            type: "setTheme"
          }, s);
        } catch (o) {
          throw this[ie] = !1, o;
        }
        this[ie] = !1, Ca.call(this, a), ka.call(this, a);
      }
    }, t.prototype._updateTheme = function(i) {
      Q(i) && (i = xw[i]), i && (i = dt(i), i && Ex(i, !0), this._theme = i);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || rt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(i) {
      return process.env.NODE_ENV !== "production" && he("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(i);
    }, t.prototype.renderToCanvas = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: i.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: i.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: i.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var i = this._zr, n = i.storage.getDisplayList();
      return k(n, function(r) {
        r.stopAnimation(null, !0);
      }), i.painter.toDataURL();
    }, t.prototype.getDataURL = function(i) {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      i = i || {};
      var n = i.excludeComponents, r = this._model, a = [], s = this;
      k(n, function(l) {
        r.eachComponent({
          mainType: l
        }, function(u) {
          var c = s._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var o = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(i).toDataURL("image/" + (i && i.type || "png"));
      return k(a, function(l) {
        l.group.ignore = !1;
      }), o;
    }, t.prototype.getConnectedDataURL = function(i) {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      var n = i.type === "svg", r = this.group, a = Math.min, s = Math.max, o = 1 / 0;
      if (U_[r]) {
        var l = o, u = o, c = -o, h = -o, f = [], d = i && i.pixelRatio || this.getDevicePixelRatio();
        k(go, function(_, b) {
          if (_.group === r) {
            var x = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(dt(i)), w = _.getDom().getBoundingClientRect();
            l = a(w.left, l), u = a(w.top, u), c = s(w.right, c), h = s(w.bottom, h), f.push({
              dom: x,
              left: w.left,
              top: w.top
            });
          }
        }), l *= d, u *= d, c *= d, h *= d;
        var v = c - l, g = h - u, p = wn.createCanvas(), m = Vm(p, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: v,
          height: g
        }), n) {
          var y = "";
          return k(f, function(_) {
            var b = _.left - l, x = _.top - u;
            y += '<g transform="translate(' + b + "," + x + ')">' + _.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = y, i.connectedBackgroundColor && m.painter.setBackgroundColor(i.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return i.connectedBackgroundColor && m.add(new xe({
            shape: {
              x: 0,
              y: 0,
              width: v,
              height: g
            },
            style: {
              fill: i.connectedBackgroundColor
            }
          })), k(f, function(_) {
            var b = new oa({
              style: {
                x: _.left * d - l,
                y: _.top * d - u,
                image: _.dom
              }
            });
            m.add(b);
          }), m.refreshImmediately(), p.toDataURL("image/" + (i && i.type || "png"));
      } else
        return this.getDataURL(i);
    }, t.prototype.convertToPixel = function(i, n, r) {
      return Hl(this, "convertToPixel", i, n, r);
    }, t.prototype.convertToLayout = function(i, n, r) {
      return Hl(this, "convertToLayout", i, n, r);
    }, t.prototype.convertFromPixel = function(i, n, r) {
      return Hl(this, "convertFromPixel", i, n, r);
    }, t.prototype.containPixel = function(i, n) {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      var r = this._model, a, s = Lh(r, i);
      return k(s, function(o, l) {
        l.indexOf("Models") >= 0 && k(o, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? a = a || h.containPoint(n, u) : process.env.NODE_ENV !== "production" && oi(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && oi(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(i, n) {
      var r = this._model, a = Lh(r, i, {
        defaultMainType: "series"
      }), s = a.seriesModel;
      process.env.NODE_ENV !== "production" && (s || oi("There is no specified series model"));
      var o = s.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? o.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? Y5(o, l, n) : W5(o, n);
    }, t.prototype.getViewOfComponentModel = function(i) {
      return this._componentsMap[i.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(i) {
      return this._chartsMap[i.__viewId];
    }, t.prototype._initEvents = function() {
      var i = this;
      k(NN, function(r) {
        var a = function(s) {
          var o = i.getModel(), l = s.target, u, c = r === "globalout";
          if (c ? u = {} : l && to(l, function(g) {
            var p = Ft(g);
            if (p && p.dataIndex != null) {
              var m = p.dataModel || o.getSeriesByIndex(p.seriesIndex);
              return u = m && m.getDataParams(p.dataIndex, p.dataType, l) || {}, !0;
            } else if (p.eventData)
              return u = Y({}, p.eventData), !0;
          }, !0), u) {
            var h = u.componentType, f = u.componentIndex;
            (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", f = u.seriesIndex);
            var d = h && f != null && o.getComponent(h, f), v = d && i[d.mainType === "series" ? "_chartsMap" : "_componentsMap"][d.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(d && v) && oi("model or view can not be found by params"), u.event = s, u.type = r, i._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: d,
              view: v
            }, i.trigger(r, u);
          }
        };
        a.zrEventfulCallAtLast = !0, i._zr.on(r, a, i);
      });
      var n = this._messageCenter;
      k(Ld, function(r, a) {
        n.on(a, function(s) {
          i.trigger(a, s);
        });
      }), U5(n, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      this._disposed = !0;
      var i = this.getDom();
      i && T1(this.getDom(), sp, "");
      var n = this, r = n._api, a = n._model;
      k(n._componentsViews, function(s) {
        s.dispose(a, r);
      }), k(n._chartsViews, function(s) {
        s.dispose(a, r);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete go[n.id];
    }, t.prototype.resize = function(i) {
      if (this[ie]) {
        process.env.NODE_ENV !== "production" && qt("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Re(this.id);
        return;
      }
      this._zr.resize(i);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var r = n.resetOption("media"), a = i && i.silent;
        this[ue] && (a == null && (a = this[ue].silent), r = !0, this[ue] = null), this[ie] = !0, Pa(this);
        try {
          r && Ar(this), rn.update.call(this, {
            type: "resize",
            animation: Y({
              // Disable animation
              duration: 0
            }, i && i.animation)
          });
        } catch (s) {
          throw this[ie] = !1, s;
        }
        this[ie] = !1, Ca.call(this, a), ka.call(this, a);
      }
    }, t.prototype.showLoading = function(i, n) {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      if (q(i) && (n = i, i = ""), i = i || "default", this.hideLoading(), !Rd[i]) {
        process.env.NODE_ENV !== "production" && oi("Loading effects " + i + " not exists.");
        return;
      }
      var r = Rd[i](this._api, n), a = this._zr;
      this._loadingFX = r, a.add(r);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(i) {
      var n = Y({}, i);
      return n.type = Qu[i.type], n;
    }, t.prototype.dispatchAction = function(i, n) {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      if (q(n) || (n = {
        silent: !!n
      }), !!Ku[i.type] && this._model) {
        if (this[ie]) {
          this._pendingActions.push(i);
          return;
        }
        var r = n.silent;
        vf.call(this, i, r);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && rt.browser.weChat && this._throttledZrFlush(), Ca.call(this, r), ka.call(this, r);
      }
    }, t.prototype.updateLabelLayout = function() {
      _i.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(i) {
      if (this._disposed) {
        Re(this.id);
        return;
      }
      var n = i.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && tt(i.data && a), a.appendData(i), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = (function() {
      Ar = function(h) {
        var f = h._scheduler;
        f.restorePipelines(h._model), f.prepareStageTasks(), ff(h, !0), ff(h, !1), f.plan();
      }, ff = function(h, f) {
        for (var d = h._model, v = h._scheduler, g = f ? h._componentsViews : h._chartsViews, p = f ? h._componentsMap : h._chartsMap, m = h._zr, y = h._api, _ = 0; _ < g.length; _++)
          g[_].__alive = !1;
        f ? d.eachComponent(function(w, M) {
          w !== "series" && b(M);
        }) : d.eachSeries(b);
        function b(w) {
          var M = w.__requireNewView;
          w.__requireNewView = !1;
          var T = "_ec_" + w.id + "_" + w.type, D = !M && p[T];
          if (!D) {
            var P = Yi(w.type), C = f ? Mn.getClass(P.main, P.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Xn.getClass(P.sub)
            );
            process.env.NODE_ENV !== "production" && tt(C, P.sub + " does not exist."), D = new C(), D.init(d, y), p[T] = D, g.push(D), m.add(D.group);
          }
          w.__viewId = D.__id = T, D.__alive = !0, D.__model = w, D.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !f && v.prepareView(D, w, d, y);
        }
        for (var _ = 0; _ < g.length; ) {
          var x = g[_];
          x.__alive ? _++ : (!f && x.renderTask.dispose(), m.remove(x.group), x.dispose(d, y), g.splice(_, 1), p[x.__id] === x && delete p[x.__id], x.__id = x.group.__ecComponentInfo = null);
        }
      }, $l = function(h, f, d, v, g) {
        var p = h._model;
        if (p.setUpdatePayload(d), !v) {
          k([].concat(h._componentsViews).concat(h._chartsViews), x);
          return;
        }
        var m = {};
        m[v + "Id"] = d[v + "Id"], m[v + "Index"] = d[v + "Index"], m[v + "Name"] = d[v + "Name"];
        var y = {
          mainType: v,
          query: m
        };
        g && (y.subType = g);
        var _ = d.excludeSeriesId, b;
        _ != null && (b = lt(), k(Ee(_), function(w) {
          var M = Si(w, null);
          M != null && b.set(M, !0);
        })), p && p.eachComponent(y, function(w) {
          var M = b && b.get(w.id) != null;
          if (!M)
            if (My(d))
              if (w instanceof er)
                d.type === Jr && !d.notBlur && !w.get(["emphasis", "disabled"]) && fO(w, d, h._api);
              else {
                var T = Iv(w.mainType, w.componentIndex, d.name, h._api), D = T.focusSelf, P = T.dispatchers;
                d.type === Jr && D && !d.notBlur && vd(w.mainType, w.componentIndex, h._api), P && k(P, function(C) {
                  d.type === Jr ? Bu(C) : zu(C);
                });
              }
            else pd(d) && w instanceof er && (pO(w, d, h._api), by(w), ei(h));
        }, h), p && p.eachComponent(y, function(w) {
          var M = b && b.get(w.id) != null;
          M || x(h[v === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, h);
        function x(w) {
          w && w.__alive && w[f] && w[f](w.__model, p, h._api, d);
        }
      }, rn = {
        prepareAndUpdate: function(h) {
          Ar(this), rn.update.call(this, h, h && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, f) {
          var d = this._model, v = this._api, g = this._zr, p = this._coordSysMgr, m = this._scheduler;
          if (d) {
            d.setUpdatePayload(h), m.restoreData(d, h), m.performSeriesTasks(d), p.create(d, v), m.performDataProcessorTasks(d, h), df(this, d), p.update(d, v), n(d), m.performVisualTasks(d, h);
            var y = d.get("backgroundColor") || "transparent";
            g.setBackgroundColor(y);
            var _ = d.get("darkMode");
            _ != null && _ !== "auto" && g.setDarkMode(_), pf(this, d, v, h, f), _i.trigger("afterupdate", d, v);
          }
        },
        updateTransform: function(h) {
          var f = this, d = this._model, v = this._api;
          if (d) {
            d.setUpdatePayload(h);
            var g = [];
            d.eachComponent(function(m, y) {
              if (m !== "series") {
                var _ = f.getViewOfComponentModel(y);
                if (_ && _.__alive)
                  if (_.updateTransform) {
                    var b = _.updateTransform(y, d, v, h);
                    b && b.update && g.push(_);
                  } else
                    g.push(_);
              }
            });
            var p = lt();
            d.eachSeries(function(m) {
              var y = f._chartsMap[m.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(m, d, v, h);
                _ && _.update && p.set(m.uid, 1);
              } else
                p.set(m.uid, 1);
            }), n(d), this._scheduler.performVisualTasks(d, h, {
              setDirty: !0,
              dirtyMap: p
            }), Yl(this, d, v, h, {}, p), _i.trigger("afterupdate", d, v);
          }
        },
        updateView: function(h) {
          var f = this._model;
          f && (f.setUpdatePayload(h), Xn.markUpdateMethod(h, "updateView"), n(f), this._scheduler.performVisualTasks(f, h, {
            setDirty: !0
          }), pf(this, f, this._api, h, {}), _i.trigger("afterupdate", f, this._api));
        },
        updateVisual: function(h) {
          var f = this, d = this._model;
          d && (d.setUpdatePayload(h), d.eachSeries(function(v) {
            v.getData().clearAllVisual();
          }), Xn.markUpdateMethod(h, "updateVisual"), n(d), this._scheduler.performVisualTasks(d, h, {
            visualType: "visual",
            setDirty: !0
          }), d.eachComponent(function(v, g) {
            if (v !== "series") {
              var p = f.getViewOfComponentModel(g);
              p && p.__alive && p.updateVisual(g, d, f._api, h);
            }
          }), d.eachSeries(function(v) {
            var g = f._chartsMap[v.__viewId];
            g.updateVisual(v, d, f._api, h);
          }), _i.trigger("afterupdate", d, this._api));
        },
        updateLayout: function(h) {
          rn.update.call(this, h);
        }
      };
      function i(h, f, d, v, g) {
        if (h._disposed) {
          Re(h.id);
          return;
        }
        for (var p = h._model, m = h._coordSysMgr.getCoordinateSystems(), y, _ = Lh(p, d), b = 0; b < m.length; b++) {
          var x = m[b];
          if (x[f] && (y = x[f](p, _, v, g)) != null)
            return y;
        }
        process.env.NODE_ENV !== "production" && oi("No coordinate system that supports " + f + " found by the given finder.");
      }
      Hl = i, df = function(h, f) {
        var d = h._chartsMap, v = h._scheduler;
        f.eachSeries(function(g) {
          v.updateStreamModes(g, d[g.__viewId]);
        });
      }, vf = function(h, f) {
        var d = this, v = this.getModel(), g = h.type, p = h.escapeConnect, m = Ku[g], y = (m.update || "update").split(":"), _ = y.pop(), b = y[0] != null && Yi(y[0]);
        this[ie] = !0, Pa(this);
        var x = [h], w = !1;
        h.batch && (w = !0, x = bt(h.batch, function(N) {
          return N = Qt(Y({}, N), h), N.batch = null, N;
        }));
        var M = [], T, D = [], P = m.nonRefinedEventType, C = pd(h), A = My(h);
        if (A && G1(this._api), k(x, function(N) {
          var B = m.action(N, v, d._api);
          if (m.refineEvent ? D.push(B) : T = B, T = T || Y({}, N), T.type = P, M.push(T), A) {
            var $ = Tv(h), H = $.queryOptionMap, G = $.mainTypeSpecified, nt = G ? H.keys()[0] : "series";
            $l(d, _, N, nt), ei(d);
          } else C ? ($l(d, _, N, "series"), ei(d)) : b && $l(d, _, N, b.main, b.sub);
        }), _ !== "none" && !A && !C && !b)
          try {
            this[ue] ? (Ar(this), rn.update.call(this, h), this[ue] = null) : rn[_].call(this, h);
          } catch (N) {
            throw this[ie] = !1, N;
          }
        if (w ? T = {
          type: P,
          escapeConnect: p,
          batch: M
        } : T = M[0], this[ie] = !1, !f) {
          var E = void 0;
          if (m.refineEvent) {
            var R = m.refineEvent(D, h, v, this._api).eventContent;
            tt(q(R)), E = Qt({
              type: m.refinedEventType
            }, R), E.fromAction = h.type, E.fromActionPayload = h, E.escapeConnect = !0;
          }
          var I = this._messageCenter;
          I.trigger(T.type, T), E && I.trigger(E.type, E);
        }
      }, Ca = function(h) {
        for (var f = this._pendingActions; f.length; ) {
          var d = f.shift();
          vf.call(this, d, h);
        }
      }, ka = function(h) {
        !h && this.trigger("updated");
      }, V_ = function(h, f) {
        h.on("rendered", function(d) {
          f.trigger("rendered", d), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !f[ue] && !f._scheduler.unfinished && !f._pendingActions.length && f.trigger("finished");
        });
      }, $_ = function(h, f) {
        h.on("mouseover", function(d) {
          var v = d.target, g = to(v, as);
          g && (dO(g, d, f._api), ei(f));
        }).on("mouseout", function(d) {
          var v = d.target, g = to(v, as);
          g && (vO(g, d, f._api), ei(f));
        }).on("click", function(d) {
          var v = d.target, g = to(v, function(y) {
            return Ft(y).dataIndex != null;
          }, !0);
          if (g) {
            var p = g.selected ? "unselect" : "select", m = Ft(g);
            f._api.dispatchAction({
              type: p,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function n(h) {
        h.clearColorPalette(), h.eachSeries(function(f) {
          f.clearColorPalette();
        });
      }
      function r(h) {
        var f = [], d = [], v = !1;
        if (h.eachComponent(function(y, _) {
          var b = _.get("zlevel") || 0, x = _.get("z") || 0, w = _.getZLevelKey();
          v = v || !!w, (y === "series" ? d : f).push({
            zlevel: b,
            z: x,
            idx: _.componentIndex,
            type: y,
            key: w
          });
        }), v) {
          var g = f.concat(d), p, m;
          Jl(g, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), k(g, function(y) {
            var _ = h.getComponent(y.type, y.idx), b = y.zlevel, x = y.key;
            p != null && (b = Math.max(p, b)), x ? (b === p && x !== m && b++, m = x) : m && (b === p && b++, m = ""), p = b, _.setZLevel(b);
          });
        }
      }
      pf = function(h, f, d, v, g) {
        r(f), H_(h, f, d, v, g), k(h._chartsViews, function(p) {
          p.__alive = !1;
        }), Yl(h, f, d, v, g), k(h._chartsViews, function(p) {
          p.__alive || p.remove(f, d);
        });
      }, H_ = function(h, f, d, v, g, p) {
        k(p || h._componentsViews, function(m) {
          var y = m.__model;
          u(y, m), m.render(y, f, d, v), l(y, m), c(y, m);
        });
      }, Yl = function(h, f, d, v, g, p) {
        var m = h._scheduler;
        g = Y(g || {}, {
          updatedSeries: f.getSeries()
        }), _i.trigger("series:beforeupdate", f, d, g);
        var y = !1;
        f.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          b.__alive = !0;
          var x = b.renderTask;
          m.updatePayload(x, v), u(_, b), p && p.get(_.uid) && x.dirty(), x.perform(m.getPerformArgs(x)) && (y = !0), b.group.silent = !!_.get("silent"), o(_, b), by(_);
        }), m.unfinished = y || m.unfinished, _i.trigger("series:layoutlabels", f, d, g), _i.trigger("series:transition", f, d, g), f.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          l(_, b), c(_, b);
        }), s(h, f), _i.trigger("series:afterupdate", f, d, g);
      }, ei = function(h) {
        h[cf] = !0, h.getZr().wakeUp();
      }, Pa = function(h) {
        h[Vl] = (h[Vl] + 1) % 1e3;
      }, W_ = function(h) {
        h[cf] && (h.getZr().storage.traverse(function(f) {
          vo(f) || a(f);
        }), h[cf] = !1);
      };
      function a(h) {
        for (var f = [], d = h.currentStates, v = 0; v < d.length; v++) {
          var g = d[v];
          g === "emphasis" || g === "blur" || g === "select" || f.push(g);
        }
        h.selected && h.states.select && f.push("select"), h.hoverState === Ev && h.states.emphasis ? f.push("emphasis") : h.hoverState === Av && h.states.blur && f.push("blur"), h.useStates(f);
      }
      function s(h, f) {
        var d = h._zr, v = d.storage, g = 0;
        v.traverse(function(p) {
          p.isGroup || g++;
        }), g > f.get("hoverLayerThreshold") && !rt.node && !rt.worker && f.eachSeries(function(p) {
          if (!p.preventUsingHoverLayer) {
            var m = h._chartsMap[p.__viewId];
            m.__alive && m.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(h, f) {
        var d = h.get("blendMode") || null;
        f.eachRendered(function(v) {
          v.isGroup || (v.style.blend = d);
        });
      }
      function l(h, f) {
        if (!h.preventAutoZ) {
          var d = Lo(h);
          f.eachRendered(function(v) {
            return cx(v, d.z, d.zlevel), !0;
          });
        }
      }
      function u(h, f) {
        f.eachRendered(function(d) {
          if (!vo(d)) {
            var v = d.getTextContent(), g = d.getTextGuideLine();
            d.stateTransition && (d.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), d.hasState() ? (d.prevStates = d.currentStates, d.clearStates()) : d.prevStates && (d.prevStates = null);
          }
        });
      }
      function c(h, f) {
        var d = h.getModel("stateAnimation"), v = h.isAnimationEnabled(), g = d.get("duration"), p = g > 0 ? {
          duration: g,
          delay: d.get("delay"),
          easing: d.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        f.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (vo(m))
              return;
            if (m instanceof It && wO(m), m.__dirty) {
              var y = m.prevStates;
              y && m.useStates(y);
            }
            if (v) {
              m.stateTransition = p;
              var _ = m.getTextContent(), b = m.getTextGuideLine();
              _ && (_.stateTransition = p), b && (b.stateTransition = p);
            }
            m.__dirty && a(m);
          }
        });
      }
      Y_ = function(h) {
        return new /** @class */
        ((function(f) {
          ae(d, f);
          function d() {
            return f !== null && f.apply(this, arguments) || this;
          }
          return d.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, d.prototype.getComponentByElement = function(v) {
            for (; v; ) {
              var g = v.__ecComponentInfo;
              if (g != null)
                return h._model.getComponent(g.mainType, g.index);
              v = v.parent;
            }
          }, d.prototype.enterEmphasis = function(v, g) {
            Bu(v, g), ei(h);
          }, d.prototype.leaveEmphasis = function(v, g) {
            zu(v, g), ei(h);
          }, d.prototype.enterBlur = function(v) {
            hO(v), ei(h);
          }, d.prototype.leaveBlur = function(v) {
            H1(v), ei(h);
          }, d.prototype.enterSelect = function(v) {
            Y1(v), ei(h);
          }, d.prototype.leaveSelect = function(v) {
            W1(v), ei(h);
          }, d.prototype.getModel = function() {
            return h.getModel();
          }, d.prototype.getViewOfComponentModel = function(v) {
            return h.getViewOfComponentModel(v);
          }, d.prototype.getViewOfSeriesModel = function(v) {
            return h.getViewOfSeriesModel(v);
          }, d.prototype.getMainProcessVersion = function() {
            return h[Vl];
          }, d;
        })(Px))(h);
      }, _w = function(h) {
        function f(d, v) {
          for (var g = 0; g < d.length; g++) {
            var p = d[g];
            p[hf] = v;
          }
        }
        k(Qu, function(d, v) {
          h._messageCenter.on(v, function(g) {
            if (U_[h.group] && h[hf] !== z_) {
              if (g && g.escapeConnect)
                return;
              var p = h.makeActionFromEvent(g), m = [];
              k(go, function(y) {
                y !== h && y.group === h.group && m.push(y);
              }), f(m, z_), k(m, function(y) {
                y[hf] !== IN && y.dispatchAction(p);
              }), f(m, RN);
            }
          });
        });
      };
    })(), t;
  })(ki)
), ap = bw.prototype;
ap.on = vw("on");
ap.off = vw("off");
ap.one = function(e, t, i) {
  var n = this;
  Sn("ECharts#one is deprecated.");
  function r() {
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    t && t.apply && t.apply(this, a), n.off(e, r);
  }
  this.on.call(this, e, r, i);
};
var NN = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function Re(e) {
  process.env.NODE_ENV !== "production" && oi("Instance " + e + " has been disposed");
}
var Ku = {}, Qu = {}, Ld = {}, Od = [], Id = [], Ju = [], xw = {}, Rd = {}, go = {}, U_ = {}, FN = +/* @__PURE__ */ new Date() - 0, sp = "_echarts_instance_";
function BN(e, t, i) {
  {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var n = zN(e);
    if (n)
      return process.env.NODE_ENV !== "production" && oi("There is a chart instance already initialized on the dom."), n;
    process.env.NODE_ENV !== "production" && ts(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && !i || !e.clientHeight && !i) && oi("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var r = new bw(e, t, i);
  return r.id = "ec_" + FN++, go[r.id] = r, T1(e, sp, r.id), _w(r), _i.trigger("afterinit", r), r;
}
function zN(e) {
  return go[JE(e, sp)];
}
function ww(e, t) {
  xw[e] = t;
}
function Sw(e) {
  Bt(Id, e) < 0 && Id.push(e);
}
function Mw(e, t) {
  lp(Od, e, t, DN);
}
function VN(e) {
  op("afterinit", e);
}
function $N(e) {
  op("afterupdate", e);
}
function op(e, t) {
  _i.on(e, t);
}
function ua(e, t, i) {
  var n, r, a, s, o;
  mt(t) && (i = t, t = ""), q(e) ? (n = e.type, r = e.event, s = e.update, o = e.publishNonRefinedEvent, i || (i = e.action), a = e.refineEvent) : (n = e, r = t);
  function l(c) {
    return c.toLowerCase();
  }
  r = l(r || n);
  var u = a ? l(n) : r;
  Ku[n] || (tt(B_.test(n) && B_.test(r)), a && tt(r !== n), Ku[n] = {
    actionType: n,
    refinedEventType: r,
    nonRefinedEventType: u,
    update: s,
    action: i,
    refineEvent: a
  }, Ld[r] = 1, a && o && (Ld[u] = 1), process.env.NODE_ENV !== "production" && Qu[u] && qt(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), Qu[u] = n);
}
function HN(e, t) {
  Oc.register(e, t);
}
function YN(e, t) {
  lp(Ju, e, t, hw, "layout");
}
function ca(e, t) {
  lp(Ju, e, t, fw, "visual");
}
var G_ = [];
function lp(e, t, i, n, r) {
  if ((mt(t) || q(t)) && (i = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    k(e, function(s) {
      tt(s.__raw !== i);
    });
  }
  if (!(Bt(G_, i) >= 0)) {
    G_.push(i);
    var a = Qx.wrapStageHandler(i, r);
    a.__prio = t, a.__raw = i, e.push(a);
  }
}
function Tw(e, t) {
  Rd[e] = t;
}
function WN(e, t, i) {
  var n = xN("registerMap");
  n && n(e, t, i);
}
var UN = qR;
ca(rp, D5);
ca(Nc, C5);
ca(Nc, k5);
ca(rp, $5);
ca(Nc, H5);
ca(dw, _N);
Sw(Ex);
Mw(MN, AR);
Tw("default", P5);
ua({
  type: Jr,
  event: Jr,
  update: Jr
}, be);
ua({
  type: ru,
  event: ru,
  update: ru
}, be);
ua({
  type: Nu,
  event: Lv,
  update: Nu,
  action: be,
  refineEvent: up,
  publishNonRefinedEvent: !0
});
ua({
  type: fd,
  event: Lv,
  update: fd,
  action: be,
  refineEvent: up,
  publishNonRefinedEvent: !0
});
ua({
  type: Fu,
  event: Lv,
  update: Fu,
  action: be,
  refineEvent: up,
  publishNonRefinedEvent: !0
});
function up(e, t, i, n) {
  return {
    eventContent: {
      selected: gO(i),
      isFromClick: t.isFromClick || !1
    }
  };
}
ww("default", {});
ww("dark", iw);
function Ls(e) {
  return e == null ? 0 : e.length || 1;
}
function j_(e) {
  return e;
}
var GN = (
  /** @class */
  (function() {
    function e(t, i, n, r, a, s) {
      this._old = t, this._new = i, this._oldKeyGetter = n || j_, this._newKeyGetter = r || j_, this.context = a, this._diffModeMultiple = s === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, i = this._new, n = {}, r = new Array(t.length), a = new Array(i.length);
      this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(i, n, a, "_newKeyGetter");
      for (var s = 0; s < t.length; s++) {
        var o = r[s], l = n[o], u = Ls(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[o] = l[0]), this._update && this._update(c, s);
        } else u === 1 ? (n[o] = null, this._update && this._update(l, s)) : this._remove && this._remove(s);
      }
      this._performRestAdd(a, n);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, i = this._new, n = {}, r = {}, a = [], s = [];
      this._initIndexMap(t, n, a, "_oldKeyGetter"), this._initIndexMap(i, r, s, "_newKeyGetter");
      for (var o = 0; o < a.length; o++) {
        var l = a[o], u = n[l], c = r[l], h = Ls(u), f = Ls(c);
        if (h > 1 && f === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), r[l] = null;
        else if (h === 1 && f > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), r[l] = null;
        else if (h === 1 && f === 1)
          this._update && this._update(c, u), r[l] = null;
        else if (h > 1 && f > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), r[l] = null;
        else if (h > 1)
          for (var d = 0; d < h; d++)
            this._remove && this._remove(u[d]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(s, r);
    }, e.prototype._performRestAdd = function(t, i) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n], a = i[r], s = Ls(a);
        if (s > 1)
          for (var o = 0; o < s; o++)
            this._add && this._add(a[o]);
        else s === 1 && this._add && this._add(a);
        i[r] = null;
      }
    }, e.prototype._initIndexMap = function(t, i, n, r) {
      for (var a = this._diffModeMultiple, s = 0; s < t.length; s++) {
        var o = "_ec_" + this[r](t[s], s);
        if (a || (n[s] = o), !!i) {
          var l = i[o], u = Ls(l);
          u === 0 ? (i[o] = s, a && n.push(o)) : u === 1 ? i[o] = [l, s] : l.push(s);
        }
      }
    }, e;
  })()
), jN = (
  /** @class */
  (function() {
    function e(t, i) {
      this._encode = t, this._schema = i;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  })()
);
function XN(e, t) {
  var i = {}, n = i.encode = {}, r = lt(), a = [], s = [], o = {};
  k(e.dimensions, function(f) {
    var d = e.getDimensionInfo(f), v = d.coordDim;
    if (v) {
      process.env.NODE_ENV !== "production" && tt(xd.get(v) == null);
      var g = d.coordDimIndex;
      gf(n, v)[g] = f, d.isExtraCoord || (r.set(v, 1), ZN(d.type) && (a[0] = f), gf(o, v)[g] = e.getDimensionIndex(d.name)), d.defaultTooltip && s.push(f);
    }
    xd.each(function(p, m) {
      var y = gf(n, m), _ = d.otherDims[m];
      _ != null && _ !== !1 && (y[_] = d.name);
    });
  });
  var l = [], u = {};
  r.each(function(f, d) {
    var v = n[d];
    u[d] = v[0], l = l.concat(v);
  }), i.dataDimsOnCoord = l, i.dataDimIndicesOnCoord = bt(l, function(f) {
    return e.getDimensionInfo(f).storeDimIndex;
  }), i.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (a = c.slice());
  var h = n.tooltip;
  return h && h.length ? s = h.slice() : s.length || (s = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = s, i.userOutput = new jN(o, t), i;
}
function gf(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function qN(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function ZN(e) {
  return !(e === "ordinal" || e === "time");
}
var lu = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.otherDims = {}, t != null && Y(this, t);
    }
    return e;
  })()
), KN = Wt(), QN = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, Dw = (
  /** @class */
  (function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = Pw(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return et(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var i = this.source.dimensionsDefine;
      if (i)
        return i[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, i = Ox(this.source), n = !Aw(t), r = "", a = [], s = 0, o = 0; s < t; s++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[o];
        if (h && h.storeDimIndex === s)
          l = i ? h.name : null, u = h.type, c = h.ordinalMeta, o++;
        else {
          var f = this.getSourceDimension(s);
          f && (l = i ? f.name : null, u = f.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), i && l != null && (!h || !h.isCalculationCoord) && (r += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += QN[u] || "f", c && (r += c.uid), r += "$";
      }
      var d = this.source, v = [d.seriesLayoutBy, d.startIndex, r].join("$$");
      return {
        dimensions: a,
        hash: v
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], i = 0, n = 0; i < this._fullDimCount; i++) {
        var r = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === i)
          a.isCalculationCoord || (r = a.name), n++;
        else {
          var s = this.getSourceDimension(i);
          s && (r = s.name);
        }
        t.push(r);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  })()
);
function Cw(e) {
  return e instanceof Dw;
}
function kw(e) {
  for (var t = lt(), i = 0; i < (e || []).length; i++) {
    var n = e[i], r = q(n) ? n.name : n;
    r != null && t.get(r) == null && t.set(r, i);
  }
  return t;
}
function Pw(e) {
  var t = KN(e);
  return t.dimNameMap || (t.dimNameMap = kw(e.dimensionsDefine));
}
function Aw(e) {
  return e > 30;
}
var Os = q, In = bt, JN = typeof Int32Array > "u" ? Array : Int32Array, tF = "e\0\0", X_ = -1, eF = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], iF = ["_approximateExtent"], q_, Wl, Is, Aa, mf, Rs, yf, Nd = (
  /** @class */
  (function() {
    function e(t, i) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var n, r = !1;
      Cw(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = !0, n = t), n = n || ["x", "y"];
      for (var a = {}, s = [], o = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var h = n[c], f = Q(h) ? new lu({
          name: h
        }) : h instanceof lu ? h : new lu(h), d = f.name;
        f.type = f.type || "float", f.coordDim || (f.coordDim = d, f.coordDimIndex = 0);
        var v = f.otherDims = f.otherDims || {};
        s.push(d), a[d] = f, u[d] != null && (l = !0), f.createInvertedIndices && (o[d] = []);
        var g = c;
        Xt(f.storeDimIndex) && (g = f.storeDimIndex), v.itemName === 0 && (this._nameDimIdx = g), v.itemId === 0 && (this._idDimIdx = g), process.env.NODE_ENV !== "production" && tt(r || f.storeDimIndex >= 0), r && (f.storeDimIndex = c);
      }
      if (this.dimensions = s, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = i, this._invertedIndicesMap = o, this._dimOmitted) {
        var p = this._dimIdxToName = lt();
        k(s, function(m) {
          p.set(a[m].storeDimIndex, m);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i == null)
        return t;
      if (i = t, !this._dimOmitted)
        return this.dimensions[i];
      var n = this._dimIdxToName.get(i);
      if (n != null)
        return n;
      var r = this._schema.getSourceDimension(i);
      if (r)
        return r.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i != null)
        return i;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if (Xt(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var i = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && i == null)
        throw new Error("Unknown dimension " + t);
      return i;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var i = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return i.hasOwnProperty(n) ? i[n] : void 0;
      } : function(n) {
        return i[n];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, i) {
      var n = this._dimSummary;
      if (i == null)
        return n.encodeFirstDimNotExtra[t];
      var r = n.encode[t];
      return r ? r[i] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var i = this._dimSummary, n = i.encode[t];
      return (n || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, i, n) {
      var r = this, a;
      if (t instanceof Sd && (a = t), !a) {
        var s = this.dimensions, o = ep(t) || Ye(t) ? new Ix(t, s.length) : t;
        a = new Sd();
        var l = In(s, function(u) {
          return {
            type: r._dimInfos[u].type,
            property: u
          };
        });
        a.initData(o, l, n);
      }
      this._store = a, this._nameList = (i || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = XN(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var i = this._store.appendData(t);
      this._doInit(i[0], i[1]);
    }, e.prototype.appendValues = function(t, i) {
      var n = this._store.appendValues(t, i && i.length), r = n.start, a = n.end, s = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), i)
        for (var o = r; o < a; o++) {
          var l = o - r;
          this._nameList[o] = i[l], s && yf(this, o);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, i = this.dimensions, n = 0; n < i.length; n++) {
        var r = this._dimInfos[i[n]];
        r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== _n && !t.fillStorage;
    }, e.prototype._doInit = function(t, i) {
      if (!(t >= i)) {
        var n = this._store, r = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, s = this._idList, o = r.getSource().sourceFormat, l = o === Ke;
        if (l && !r.pure)
          for (var u = [], c = t; c < i; c++) {
            var h = r.getItem(c, u);
            if (!this.hasItemOption && HE(h) && (this.hasItemOption = !0), h) {
              var f = h.name;
              a[c] == null && f != null && (a[c] = Si(f, null));
              var d = h.id;
              s[c] == null && d != null && (s[c] = Si(d, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < i; c++)
            yf(this, c);
        q_(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, i) {
      i = this.getDimension(i), this._approximateExtent[i] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, i) {
      Os(t) ? Y(this._calculationInfo, t) : this._calculationInfo[t] = i;
    }, e.prototype.getName = function(t) {
      var i = this.getRawIndex(t), n = this._nameList[i];
      return n == null && this._nameDimIdx != null && (n = Is(this, this._nameDimIdx, i)), n == null && (n = ""), n;
    }, e.prototype._getCategory = function(t, i) {
      var n = this._store.get(t, i), r = this._store.getOrdinalMeta(t);
      return r ? r.categories[n] : n;
    }, e.prototype.getId = function(t) {
      return Wl(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.get(r.storeDimIndex, i);
    }, e.prototype.getByRawIndex = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.getByRawIndex(r.storeDimIndex, i);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, i) {
      var n = this, r = this._store;
      return j(t) ? r.getValues(In(t, function(a) {
        return n._getStoreDimIndex(a);
      }), i) : r.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var i = this._dimSummary.dataDimIndicesOnCoord, n = 0, r = i.length; n < r; n++)
        if (isNaN(this._store.get(i[n], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var i = 0, n = this._store.count(); i < n; i++)
        if (this.getName(i) === t)
          return i;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, i) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var r = n && n[i];
      return r == null || isNaN(r) ? X_ : r;
    }, e.prototype.each = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []);
      var r = n || this, a = In(Aa(t), this._getStoreDimIndex, this);
      this._store.each(a, r ? Dt(i, r) : i);
    }, e.prototype.filterSelf = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []);
      var r = n || this, a = In(Aa(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, r ? Dt(i, r) : i), this;
    }, e.prototype.selectRange = function(t) {
      var i = this, n = {}, r = jt(t);
      return k(r, function(a) {
        var s = i._getStoreDimIndex(a);
        n[s] = t[a];
      }), this._store = this._store.selectRange(n), this;
    }, e.prototype.mapArray = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []), n = n || this;
      var r = [];
      return this.each(t, function() {
        r.push(i && i.apply(this, arguments));
      }, n), r;
    }, e.prototype.map = function(t, i, n, r) {
      var a = n || r || this, s = In(Aa(t), this._getStoreDimIndex, this), o = Rs(this);
      return o._store = this._store.map(s, a ? Dt(i, a) : i), o;
    }, e.prototype.modify = function(t, i, n, r) {
      var a = this, s = n || r || this;
      process.env.NODE_ENV !== "production" && k(Aa(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var o = In(Aa(t), this._getStoreDimIndex, this);
      this._store.modify(o, s ? Dt(i, s) : i);
    }, e.prototype.downSample = function(t, i, n, r) {
      var a = Rs(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), i, n, r), a;
    }, e.prototype.minmaxDownSample = function(t, i) {
      var n = Rs(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = Rs(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var i = this.hostModel, n = this.getRawDataItem(t);
      return new Gt(n, i, i && i.ecModel);
    }, e.prototype.diff = function(t) {
      var i = this;
      return new GN(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return Wl(t, n);
      }, function(n) {
        return Wl(i, n);
      });
    }, e.prototype.getVisual = function(t) {
      var i = this._visual;
      return i && i[t];
    }, e.prototype.setVisual = function(t, i) {
      this._visual = this._visual || {}, Os(t) ? Y(this._visual, t) : this._visual[t] = i;
    }, e.prototype.getItemVisual = function(t, i) {
      var n = this._itemVisuals[t], r = n && n[i];
      return r ?? this.getVisual(i);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, i) {
      var n = this._itemVisuals, r = n[t];
      r || (r = n[t] = {});
      var a = r[i];
      return a == null && (a = this.getVisual(i), j(a) ? a = a.slice() : Os(a) && (a = Y({}, a)), r[i] = a), a;
    }, e.prototype.setItemVisual = function(t, i, n) {
      var r = this._itemVisuals[t] || {};
      this._itemVisuals[t] = r, Os(i) ? Y(r, i) : r[i] = n;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, i) {
      Os(t) ? Y(this._layout, t) : this._layout[t] = i;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, i, n) {
      this._itemLayouts[t] = n ? Y(this._itemLayouts[t] || {}, i) : i;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, i) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      eO(n, this.dataType, t, i), this._graphicEls[t] = i;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, i) {
      k(this._graphicEls, function(n, r) {
        n && t && t.call(i, n, r);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : In(this.dimensions, this._getDimInfo, this), this.hostModel)), mf(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, i) {
      var n = this[t];
      mt(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var r = n.apply(this, arguments);
        return i.apply(this, [r].concat(yv(arguments)));
      });
    }, e.internalField = (function() {
      q_ = function(t) {
        var i = t._invertedIndicesMap;
        k(i, function(n, r) {
          var a = t._dimInfos[r], s = a.ordinalMeta, o = t._store;
          if (s) {
            n = i[r] = new JN(s.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = X_;
            for (var l = 0; l < o.count(); l++)
              n[o.get(a.storeDimIndex, l)] = l;
          }
        });
      }, Is = function(t, i, n) {
        return Si(t._getCategory(i, n), null);
      }, Wl = function(t, i) {
        var n = t._idList[i];
        return n == null && t._idDimIdx != null && (n = Is(t, t._idDimIdx, i)), n == null && (n = tF + i), n;
      }, Aa = function(t) {
        return j(t) || (t = t != null ? [t] : []), t;
      }, Rs = function(t) {
        var i = new e(t._schema ? t._schema : In(t.dimensions, t._getDimInfo, t), t.hostModel);
        return mf(i, t), i;
      }, mf = function(t, i) {
        k(eF.concat(i.__wrappedMethods || []), function(n) {
          i.hasOwnProperty(n) && (t[n] = i[n]);
        }), t.__wrappedMethods = i.__wrappedMethods, k(iF, function(n) {
          t[n] = dt(i[n]);
        }), t._calculationInfo = Y({}, i._calculationInfo);
      }, yf = function(t, i) {
        var n = t._nameList, r = t._idList, a = t._nameDimIdx, s = t._idDimIdx, o = n[i], l = r[i];
        if (o == null && a != null && (n[i] = o = Is(t, a, i)), l == null && s != null && (r[i] = l = Is(t, s, i)), l == null && o != null) {
          var u = t._nameRepeatCount, c = u[o] = (u[o] || 0) + 1;
          l = o, c > 1 && (l += "__ec__" + c), r[i] = l;
        }
      };
    })(), e;
  })()
);
function Ew(e, t) {
  ep(e) || (e = ip(e)), t = t || {};
  var i = t.coordDimensions || [], n = t.dimensionsDefine || e.dimensionsDefine || [], r = lt(), a = [], s = rF(e, i, n, t.dimensionsCount), o = t.canOmitUnusedDimensions && Aw(s), l = n === e.dimensionsDefine, u = l ? Pw(e) : kw(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, s));
  for (var h = lt(c), f = new zx(s), d = 0; d < f.length; d++)
    f[d] = -1;
  function v(D) {
    var P = f[D];
    if (P < 0) {
      var C = n[D], A = q(C) ? C : {
        name: C
      }, E = new lu(), R = A.name;
      R != null && u.get(R) != null && (E.name = E.displayName = R), A.type != null && (E.type = A.type), A.displayName != null && (E.displayName = A.displayName);
      var I = a.length;
      return f[D] = I, E.storeDimIndex = D, a.push(E), E;
    }
    return a[P];
  }
  if (!o)
    for (var d = 0; d < s; d++)
      v(d);
  h.each(function(D, P) {
    var C = Ee(D).slice();
    if (C.length === 1 && !Q(C[0]) && C[0] < 0) {
      h.set(P, !1);
      return;
    }
    var A = h.set(P, []);
    k(C, function(E, R) {
      var I = Q(E) ? u.get(E) : E;
      I != null && I < s && (A[R] = I, p(v(I), P, R));
    });
  });
  var g = 0;
  k(i, function(D) {
    var P, C, A, E;
    if (Q(D))
      P = D, E = {};
    else {
      E = D, P = E.name;
      var R = E.ordinalMeta;
      E.ordinalMeta = null, E = Y({}, E), E.ordinalMeta = R, C = E.dimsDef, A = E.otherDims, E.name = E.coordDim = E.coordDimIndex = E.dimsDef = E.otherDims = null;
    }
    var I = h.get(P);
    if (I !== !1) {
      if (I = Ee(I), !I.length)
        for (var N = 0; N < (C && C.length || 1); N++) {
          for (; g < s && v(g).coordDim != null; )
            g++;
          g < s && I.push(g++);
        }
      k(I, function(B, $) {
        var H = v(B);
        if (l && E.type != null && (H.type = E.type), p(Qt(H, E), P, $), H.name == null && C) {
          var G = C[$];
          !q(G) && (G = {
            name: G
          }), H.name = H.displayName = G.name, H.defaultTooltip = G.defaultTooltip;
        }
        A && Qt(H.otherDims, A);
      });
    }
  });
  function p(D, P, C) {
    xd.get(P) != null ? D.otherDims[P] = C : (D.coordDim = P, D.coordDimIndex = C, r.set(P, !0));
  }
  var m = t.generateCoord, y = t.generateCoordCount, _ = y != null;
  y = m ? y || 1 : 0;
  var b = m || "value";
  function x(D) {
    D.name == null && (D.name = D.coordDim);
  }
  if (o)
    k(a, function(D) {
      x(D);
    }), a.sort(function(D, P) {
      return D.storeDimIndex - P.storeDimIndex;
    });
  else
    for (var w = 0; w < s; w++) {
      var M = v(w), T = M.coordDim;
      T == null && (M.coordDim = aF(b, r, _), M.coordDimIndex = 0, (!m || y <= 0) && (M.isExtraCoord = !0), y--), x(M), M.type == null && (kx(e, w) === We.Must || M.isExtraCoord && (M.otherDims.itemName != null || M.otherDims.seriesName != null)) && (M.type = "ordinal");
    }
  return nF(a), new Dw({
    source: e,
    dimensions: a,
    fullDimensionCount: s,
    dimensionOmitted: o
  });
}
function nF(e) {
  for (var t = lt(), i = 0; i < e.length; i++) {
    var n = e[i], r = n.name, a = t.get(r) || 0;
    a > 0 && (n.name = r + (a - 1)), a++, t.set(r, a);
  }
}
function rF(e, t, i, n) {
  var r = Math.max(e.dimensionsDetectedCount || 1, t.length, i.length, n || 0);
  return k(t, function(a) {
    var s;
    q(a) && (s = a.dimsDef) && (r = Math.max(r, s.length));
  }), r;
}
function aF(e, t, i) {
  if (i || t.hasKey(e)) {
    for (var n = 0; t.hasKey(e + n); )
      n++;
    e += n;
  }
  return t.set(e, !0), e;
}
var sF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = lt(), this.categoryAxisMap = lt(), this.coordSysName = t;
    }
    return e;
  })()
);
function oF(e) {
  var t = e.get("coordinateSystem"), i = new sF(t), n = lF[t];
  if (n)
    return n(e, i, i.axisMap, i.categoryAxisMap), i;
}
var lF = {
  cartesian2d: function(e, t, i, n) {
    var r = e.getReferringComponents("xAxis", Fn).models[0], a = e.getReferringComponents("yAxis", Fn).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error('xAxis "' + Jn(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + Jn(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], i.set("x", r), i.set("y", a), Ea(r) && (n.set("x", r), t.firstCategoryDimIndex = 0), Ea(a) && (n.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, i, n) {
    var r = e.getReferringComponents("singleAxis", Fn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], i.set("single", r), Ea(r) && (n.set("single", r), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, i, n) {
    var r = e.getReferringComponents("polar", Fn).models[0], a = r.findAxisModel("radiusAxis"), s = r.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!s)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", s), Ea(a) && (n.set("radius", a), t.firstCategoryDimIndex = 0), Ea(s) && (n.set("angle", s), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, i, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, i, n) {
    var r = e.ecModel, a = r.getComponent("parallel", e.get("parallelIndex")), s = t.coordSysDims = a.dimensions.slice();
    k(a.parallelAxisIndex, function(o, l) {
      var u = r.getComponent("parallelAxis", o), c = s[l];
      i.set(c, u), Ea(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(e, t, i, n) {
    var r = e.getReferringComponents("matrix", Fn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = r.getDimensionModel("x"), s = r.getDimensionModel("y");
    i.set("x", a), i.set("y", s), n.set("x", a), n.set("y", s);
  }
};
function Ea(e) {
  return e.get("type") === "category";
}
function uF(e, t, i) {
  i = i || {};
  var n = i.byIndex, r = i.stackedCoordDimension, a, s, o;
  cF(t) ? a = t : (s = t.schema, a = s.dimensions, o = t.store);
  var l = !!(e && e.get("stack")), u, c, h, f;
  if (k(a, function(y, _) {
    Q(y) && (a[_] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!r || r === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    h = "__\0ecstackresult_" + e.id, f = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var d = c.coordDim, v = c.type, g = 0;
    k(a, function(y) {
      y.coordDim === d && g++;
    });
    var p = {
      name: h,
      coordDim: d,
      coordDimIndex: g,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, m = {
      name: f,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: f,
      coordDimIndex: g + 1,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    s ? (o && (p.storeDimIndex = o.ensureCalculationDimension(f, v), m.storeDimIndex = o.ensureCalculationDimension(h, v)), s.appendCalculationDimension(p), s.appendCalculationDimension(m)) : (a.push(p), a.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: f,
    stackResultDimension: h
  };
}
function cF(e) {
  return !Cw(e.schema);
}
function hF(e, t) {
  var i = e.get("coordinateSystem"), n = Oc.get(i), r;
  return t && t.coordSysDims && (r = bt(t.coordSysDims, function(a) {
    var s = {
      name: a
    }, o = t.axisMap.get(a);
    if (o) {
      var l = o.get("type");
      s.type = qN(l);
    }
    return s;
  })), r || (r = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), r;
}
function fF(e, t, i) {
  var n, r;
  return i && k(e, function(a, s) {
    var o = a.coordDim, l = i.categoryAxisMap.get(o);
    l && (n == null && (n = s), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (r = !0);
  }), !r && n != null && (e[n].otherDims.itemName = 0), n;
}
function dF(e, t, i) {
  i = i || {};
  var n = t.getSourceManager(), r, a = !1;
  e ? (a = !0, r = ip(e)) : (r = n.getSource(), a = r.sourceFormat === Ke);
  var s = oF(t), o = hF(t, s), l = i.useEncodeDefaulter, u = mt(l) ? l : l ? Ae(nR, o, t) : null, c = {
    coordDimensions: o,
    generateCoord: i.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, h = Ew(r, c), f = fF(h.dimensions, i.createInvertedIndices, s), d = a ? null : n.getSharedDataStore(h), v = uF(t, {
    schema: h,
    store: d
  }), g = new Nd(h, t);
  g.setCalculationInfo(v);
  var p = f != null && vF(r) ? function(m, y, _, b) {
    return b === f ? _ : this.defaultDimValueGetter(m, y, _, b);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? r : d,
    null,
    p
  ), g;
}
function vF(e) {
  if (e.sourceFormat === Ke) {
    var t = pF(e.data || []);
    return !j(Uo(t));
  }
}
function pF(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
function Lw(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function gF(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function mF(e) {
  return e.type === "category" && gF(e.getLabelModel()) === 0;
}
function tc(e) {
  return e === "middle" || e === "center";
}
var Z_ = [], yF = {
  registerPreprocessor: Sw,
  registerProcessor: Mw,
  registerPostInit: VN,
  registerPostUpdate: $N,
  registerUpdateLifecycle: op,
  registerAction: ua,
  registerCoordinateSystem: HN,
  registerLayout: YN,
  registerVisual: ca,
  registerTransform: UN,
  registerLoading: Tw,
  registerMap: WN,
  registerImpl: bN,
  PRIORITY: ON,
  ComponentModel: Pt,
  ComponentView: Mn,
  SeriesModel: er,
  ChartView: Xn,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    Pt.registerClass(e);
  },
  registerComponentView: function(e) {
    Mn.registerClass(e);
  },
  registerSeriesModel: function(e) {
    er.registerClass(e);
  },
  registerChartView: function(e) {
    Xn.registerClass(e);
  },
  registerCustomSeries: function(e, t) {
  },
  registerSubTypeDefaulter: function(e, t) {
    Pt.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    AE(e, t);
  }
};
function cp(e) {
  if (j(e)) {
    k(e, function(t) {
      cp(t);
    });
    return;
  }
  Bt(Z_, e) >= 0 || (Z_.push(e), mt(e) && (e = {
    install: e
  }), e.install(yF));
}
Wt();
Wt();
var K_ = {
  estimate: 1,
  determine: 2
};
function _F(e) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: e
  };
}
var Q_ = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], bF = 1, ec = 2, Ow = bF | ec;
function ic(e, t, i) {
  i = i || Ow, t ? e.dirty |= i : e.dirty &= ~i;
}
function Iw(e, t) {
  return t = t || Ow, e.dirty == null || !!(e.dirty & t);
}
function ir(e) {
  if (e)
    return Iw(e) && xF(e, e.label, e), e;
}
function xF(e, t, i) {
  var n = t.getComputedTransform();
  e.transform = Xv(e.transform, n);
  var r = e.localRect = Eo(e.localRect, t.getBoundingRect()), a = t.style, s = a.margin, o = i && i.marginForce, l = i && i.minMarginForce, u = i && i.marginDefault, c = a.__marginType;
  c == null && u && (s = u, c = $a.textMargin);
  for (var h = 0; h < 4; h++)
    _f[h] = c === $a.minMargin && l && l[h] != null ? l[h] : o && o[h] != null ? o[h] : s ? s[h] : 0;
  c === $a.textMargin && yd(r, _f, !1, !1);
  var f = e.rect = Eo(e.rect, r);
  return n && f.applyTransform(n), c === $a.minMargin && yd(f, _f, !1, !1), e.axisAligned = jv(n), (e.label = e.label || {}).ignore = t.ignore, ic(e, !1), ic(e, !0, ec), e;
}
var _f = [0, 0, 0, 0];
function wF(e, t, i) {
  return e.transform = Xv(e.transform, i), e.localRect = Eo(e.localRect, t), e.rect = Eo(e.rect, t), i && e.rect.applyTransform(i), e.axisAligned = jv(i), e.obb = void 0, (e.label = e.label || {}).ignore = !1, e;
}
function SF(e, t) {
  if (e) {
    e.label.x += t.x, e.label.y += t.y, e.label.markRedraw();
    var i = e.transform;
    i && (i[4] += t.x, i[5] += t.y);
    var n = e.rect;
    n && (n.x += t.x, n.y += t.y);
    var r = e.obb;
    r && r.fromBoundingRect(e.localRect, i);
  }
}
function J_(e, t) {
  for (var i = 0; i < Q_.length; i++) {
    var n = Q_[i];
    e[n] == null && (e[n] = t[n]);
  }
  return ir(e);
}
function t0(e) {
  var t = e.obb;
  return (!t || Iw(e, ec)) && (e.obb = t = t || new ex(), t.fromBoundingRect(e.localRect, e.transform), ic(e, !1, ec)), t;
}
function MF(e) {
  var t = [];
  e.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function i(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var n = 0; n < e.length; n++) {
    var r = ir(e[n]);
    if (!r.label.ignore) {
      for (var a = r.label, s = r.labelLine, o = !1, l = 0; l < t.length; l++)
        if (hp(r, t[l], null, {
          touchThreshold: 0.05
        })) {
          o = !0;
          break;
        }
      o ? (i(a), s && i(s)) : t.push(r);
    }
  }
}
function hp(e, t, i, n) {
  return !e || !t || e.label && e.label.ignore || t.label && t.label.ignore || !e.rect.intersect(t.rect, i, n) ? !1 : e.axisAligned && t.axisAligned ? !0 : t0(e).intersect(t0(t), i, n);
}
var TF = null;
function DF() {
  return TF;
}
var CF = "expandAxisBreak", Hn = Math.PI, kF = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], PF = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], nc = Wt(), Rw = Wt(), AF = (
  /** @class */
  (function() {
    function e(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return e.prototype.ensureRecord = function(t) {
      var i = t.axis.dim, n = t.componentIndex, r = this.recordMap, a = r[i] || (r[i] = []);
      return a[n] || (a[n] = {
        ready: {}
      });
    }, e;
  })()
);
function EF(e, t, i, n) {
  var r = i.axis, a = t.ensureRecord(i), s = [], o, l = fp(e.axisName) && tc(e.nameLocation);
  k(n, function(v) {
    var g = ir(v);
    if (!(!g || g.label.ignore)) {
      s.push(g);
      var p = a.transGroup;
      l && (p.transform ? Wo(Ns, p.transform) : xv(Ns), g.transform && lo(Ns, Ns, g.transform), at.copy(Ul, g.localRect), Ul.applyTransform(Ns), o ? o.union(Ul) : at.copy(o = new at(0, 0, 0, 0), Ul));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (s.sort(function(v, g) {
    return Math.abs(v.label[u] - c) - Math.abs(g.label[u] - c);
  }), l && o) {
    var h = r.getExtent(), f = Math.min(h[0], h[1]), d = Math.max(h[0], h[1]) - f;
    o.union(new at(f, 0, d, 1));
  }
  a.stOccupiedRect = o, a.labelInfoList = s;
}
var Ns = Gi(), Ul = new at(0, 0, 0, 0), LF = function(e, t, i, n, r, a) {
  if (tc(e.nameLocation)) {
    var s = a.stOccupiedRect;
    s && Nw(wF({}, s, a.transGroup.transform), n, r);
  } else
    OF(a.labelInfoList, a.dirVec, n, r);
};
function Nw(e, t, i) {
  var n = new Lt();
  hp(e, t, n, {
    direction: Math.atan2(i.y, i.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && SF(t, n);
}
function OF(e, t, i, n) {
  for (var r = Lt.dot(n, t) >= 0, a = 0, s = e.length; a < s; a++) {
    var o = e[r ? a : s - 1 - a];
    o.label.ignore || Nw(o, i, n);
  }
}
var ta = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this.group = new Mi(), this._axisModel = t, this._api = i, this._local = {}, this._shared = r || new AF(LF), this._resetCfgDetermined(n);
    }
    return e.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var i = this._shared.ensureRecord(this._axisModel).ready;
        tt(!i.axisLine && !i.axisTickLabelDetermine), i.axisName = i.axisTickLabelEstimate = !1;
      }
      var n = this._cfg.raw;
      n.position = t.position, n.labelOffset = t.labelOffset, this._resetCfgDetermined(n);
    }, e.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, e.prototype._resetCfgDetermined = function(t) {
      var i = this._axisModel, n = i.getDefaultOption ? i.getDefaultOption() : {}, r = et(t.axisName, i.get("name")), a = i.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = et(t.defaultNameMoveOverlap, !0));
      var s = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: et(t.nameDirection, 1),
        tickDirection: et(t.tickDirection, 1),
        labelDirection: et(t.labelDirection, 1),
        labelOffset: et(t.labelOffset, 0),
        silent: et(t.silent, !0),
        axisName: r,
        nameLocation: Xr(i.get("nameLocation"), n.nameLocation, "end"),
        shouldNameMoveOverlap: fp(r) && a,
        optionHideOverlap: i.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: i.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (tt(s.position != null), tt(s.rotation != null)), this._cfg = s;
      var o = new Mi({
        x: s.position[0],
        y: s.position[1],
        rotation: s.rotation
      });
      o.updateTransform(), this._transformGroup = o;
      var l = this._shared.ensureRecord(i);
      l.transGroup = this._transformGroup, l.dirVec = new Lt(Math.cos(-s.rotation), Math.sin(-s.rotation));
    }, e.prototype.build = function(t, i) {
      var n = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), k(IF, function(r) {
        t[r] && RF[r](n._cfg, n._local, n._shared, n._axisModel, n.group, n._transformGroup, n._api, i || {});
      }), this;
    }, e.innerTextLayout = function(t, i, n) {
      var r = y1(i - t), a, s;
      return Lu(r) ? (s = n > 0 ? "top" : "bottom", a = "center") : Lu(r - Hn) ? (s = n > 0 ? "bottom" : "top", a = "center") : (s = "middle", r > 0 && r < Hn ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: r,
        textAlign: a,
        textVerticalAlign: s
      };
    }, e.makeAxisEventDataBase = function(t) {
      var i = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return i[t.mainType + "Index"] = t.componentIndex, i;
    }, e.isLabelSilent = function(t) {
      var i = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || i && i.show);
    }, e;
  })()
), IF = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], RF = {
  axisLine: function(e, t, i, n, r, a, s) {
    if (process.env.NODE_ENV !== "production") {
      var o = i.ensureRecord(n).ready;
      tt(!o.axisLine), o.axisLine = !0;
    }
    var l = n.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, e.raw.axisLineAutoShow != null && (l = !!e.raw.axisLineAutoShow)), !!l) {
      var u = n.axis.getExtent(), c = a.transform, h = [u[0], 0], f = [u[1], 0], d = h[0] > f[0];
      c && (qe(h, h, c), qe(f, f, c));
      var v = Y({
        lineCap: "round"
      }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), g = {
        strokeContainThreshold: e.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: v
      };
      if (n.get(["axisLine", "breakLine"]) && n.axis.scale.hasBreaks())
        DF().buildAxisBreakLine(n, r, a, g);
      else {
        var p = new hs(Y({
          shape: {
            x1: h[0],
            y1: h[1],
            x2: f[0],
            y2: f[1]
          }
        }, g));
        Wv(p.shape, p.style.lineWidth), p.anid = "line", r.add(p);
      }
      var m = n.get(["axisLine", "symbol"]);
      if (m != null) {
        var y = n.get(["axisLine", "symbolSize"]);
        Q(m) && (m = [m, m]), (Q(y) || Xt(y)) && (y = [y, y]);
        var _ = nN(n.get(["axisLine", "symbolOffset"]) || 0, y), b = y[0], x = y[1];
        k([{
          rotate: e.rotation + Math.PI / 2,
          offset: _[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: _[1],
          r: Math.sqrt((h[0] - f[0]) * (h[0] - f[0]) + (h[1] - f[1]) * (h[1] - f[1]))
        }], function(w, M) {
          if (m[M] !== "none" && m[M] != null) {
            var T = nw(m[M], -b / 2, -x / 2, b, x, v.stroke, !0), D = w.r + w.offset, P = d ? f : h;
            T.attr({
              rotation: w.rotate,
              x: P[0] + D * Math.cos(e.rotation),
              y: P[1] - D * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(T);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(e, t, i, n, r, a, s, o) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      tt(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = i0(t, r, o);
    u && e0(e, t, i, n, r, a, s, K_.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(e, t, i, n, r, a, s, o) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = i0(t, r, o);
    u && e0(e, t, i, n, r, a, s, K_.determine);
    var c = zF(e, r, a, n);
    BF(e, t.labelLayoutList, c), VF(e, r, a, n, e.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(e, t, i, n, r, a, s, o) {
    var l = i.ensureRecord(n);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      tt(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (r.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = e.axisName;
    if (fp(c)) {
      var h = e.nameLocation, f = e.nameDirection, d = n.getModel("nameTextStyle"), v = n.get("nameGap") || 0, g = n.axis.getExtent(), p = n.axis.inverse ? -1 : 1, m = new Lt(0, 0), y = new Lt(0, 0);
      h === "start" ? (m.x = g[0] - p * v, y.x = -p) : h === "end" ? (m.x = g[1] + p * v, y.x = p) : (m.x = (g[0] + g[1]) / 2, m.y = e.labelOffset + f * v, y.y = f);
      var _ = Gi();
      y.transform(Sv(_, _, e.rotation));
      var b = n.get("nameRotate");
      b != null && (b = b * Hn / 180);
      var x, w;
      tc(h) ? x = ta.innerTextLayout(
        e.rotation,
        b ?? e.rotation,
        // Adapt to axis.
        f
      ) : (x = NF(e.rotation, h, b || 0, g), w = e.raw.axisNameAvailableWidth, w != null && (w = Math.abs(w / Math.sin(x.rotation)), !isFinite(w) && (w = null)));
      var M = d.getFont(), T = n.get("nameTruncate", !0) || {}, D = T.ellipsis, P = Jn(e.raw.nameTruncateMaxWidth, T.maxWidth, w), C = o.nameMarginLevel || 0, A = new vi({
        x: m.x,
        y: m.y,
        rotation: x.rotation,
        silent: ta.isLabelSilent(n),
        style: ra(d, {
          text: c,
          font: M,
          overflow: "truncate",
          width: P,
          ellipsis: D,
          fill: d.getTextColor() || n.get(["axisLine", "lineStyle", "color"]),
          align: d.get("align") || x.textAlign,
          verticalAlign: d.get("verticalAlign") || x.textVerticalAlign
        }),
        z2: 1
      });
      if (Gv({
        el: A,
        componentModel: n,
        itemName: c
      }), A.__fullText = c, A.anid = "name", n.get("triggerEvent")) {
        var E = ta.makeAxisEventDataBase(n);
        E.targetType = "axisName", E.name = c, Ft(A).eventData = E;
      }
      a.add(A), A.updateTransform(), t.nameEl = A;
      var R = l.nameLayout = ir({
        label: A,
        priority: A.z2,
        defaultAttr: {
          ignore: A.ignore
        },
        marginDefault: tc(h) ? kF[C] : PF[C]
      });
      if (l.nameLocation = h, r.add(A), A.decomposeTransform(), e.shouldNameMoveOverlap && R) {
        var I = i.ensureRecord(n);
        process.env.NODE_ENV !== "production" && tt(I.labelInfoList), i.resolveAxisNameOverlap(e, i, n, R, y, I);
      }
    }
  }
};
function e0(e, t, i, n, r, a, s, o) {
  Bw(t) || $F(e, t, r, o, n, s);
  var l = t.labelLayoutList;
  HF(e, n, l, a), e.rotation;
  var u = e.optionHideOverlap;
  FF(n, l, u), u && MF(
    // Filter the already ignored labels by the previous overlap resolving methods.
    je(l, function(c) {
      return c && !c.label.ignore;
    })
  ), EF(e, i, n, l);
}
function NF(e, t, i, n) {
  var r = y1(i - e), a, s, o = n[0] > n[1], l = t === "start" && !o || t !== "start" && o;
  return Lu(r - Hn / 2) ? (s = l ? "bottom" : "top", a = "center") : Lu(r - Hn * 1.5) ? (s = l ? "top" : "bottom", a = "center") : (s = "middle", r < Hn * 1.5 && r > Hn / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: r,
    textAlign: a,
    textVerticalAlign: s
  };
}
function FF(e, t, i) {
  if (mF(e.axis))
    return;
  function n(o, l, u) {
    var c = ir(t[l]), h = ir(t[u]);
    if (!(!c || !h)) {
      if (o === !1 || c.suggestIgnore) {
        eo(c.label);
        return;
      }
      if (h.suggestIgnore) {
        eo(h.label);
        return;
      }
      var f = 0.1;
      if (!i) {
        var d = [0, 0, 0, 0];
        c = J_({
          marginForce: d
        }, c), h = J_({
          marginForce: d
        }, h);
      }
      hp(c, h, null, {
        touchThreshold: f
      }) && eo(o ? h.label : c.label);
    }
  }
  var r = e.get(["axisLabel", "showMinLabel"]), a = e.get(["axisLabel", "showMaxLabel"]), s = t.length;
  n(r, 0, 1), n(a, s - 1, s - 2);
}
function BF(e, t, i) {
  e.showMinorTicks || k(t, function(n) {
    if (n && n.label.ignore)
      for (var r = 0; r < i.length; r++) {
        var a = i[r], s = Rw(a), o = nc(n.label);
        if (s.tickValue != null && !s.onBand && s.tickValue === o.tickValue) {
          eo(a);
          return;
        }
      }
  });
}
function eo(e) {
  e && (e.ignore = !0);
}
function Fw(e, t, i, n, r) {
  for (var a = [], s = [], o = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    s[0] = u, s[1] = 0, o[0] = u, o[1] = i, t && (qe(s, s, t), qe(o, o, t));
    var c = new hs({
      shape: {
        x1: s[0],
        y1: s[1],
        x2: o[0],
        y2: o[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Wv(c.shape, c.style.lineWidth), c.anid = r + "_" + e[l].tickValue, a.push(c);
    var h = Rw(c);
    h.onBand = !!e[l].onBand, h.tickValue = e[l].tickValue;
  }
  return a;
}
function zF(e, t, i, n) {
  var r = n.axis, a = n.getModel("axisTick"), s = a.get("show");
  if (s === "auto" && (s = !0, e.raw.axisTickAutoShow != null && (s = !!e.raw.axisTickAutoShow)), !s || r.scale.isBlank())
    return [];
  for (var o = a.getModel("lineStyle"), l = e.tickDirection * a.get("length"), u = r.getTicksCoords(), c = Fw(u, i.transform, l, Qt(o.getLineStyle(), {
    stroke: n.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), h = 0; h < c.length; h++)
    t.add(c[h]);
  return c;
}
function VF(e, t, i, n, r) {
  var a = n.axis, s = n.getModel("minorTick");
  if (!(!e.showMinorTicks || a.scale.isBlank())) {
    var o = a.getMinorTicksCoords();
    if (o.length)
      for (var l = s.getModel("lineStyle"), u = r * s.get("length"), c = Qt(l.getLineStyle(), Qt(n.getModel("axisTick").getLineStyle(), {
        stroke: n.get(["axisLine", "lineStyle", "color"])
      })), h = 0; h < o.length; h++)
        for (var f = Fw(o[h], i.transform, u, c, "minorticks_" + h), d = 0; d < f.length; d++)
          t.add(f[d]);
  }
}
function i0(e, t, i) {
  if (Bw(e)) {
    var n = e.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && tt(e.labelGroup && n);
    var r = n.out.noPxChangeTryDetermine;
    if (i.noPxChange) {
      for (var a = !0, s = 0; s < r.length; s++)
        a = a && r[s]();
      if (a)
        return !1;
    }
    r.length && (t.remove(e.labelGroup), Fd(e, null, null, null));
  }
  return !0;
}
function $F(e, t, i, n, r, a) {
  var s = r.axis, o = Jn(e.raw.axisLabelShow, r.get(["axisLabel", "show"])), l = new Mi();
  i.add(l);
  var u = _F(n);
  if (!o || s.scale.isBlank()) {
    Fd(t, [], l, u);
    return;
  }
  var c = r.getModel("axisLabel"), h = s.getViewLabels(u), f = (Jn(e.raw.labelRotate, c.get("rotate")) || 0) * Hn / 180, d = ta.innerTextLayout(e.rotation, f, e.labelDirection), v = r.getCategories && r.getCategories(!0), g = [], p = r.get("triggerEvent"), m = 1 / 0, y = -1 / 0;
  k(h, function(b, x) {
    var w, M = s.scale.type === "ordinal" ? s.scale.getRawOrdinalNumber(b.tickValue) : b.tickValue, T = b.formattedLabel, D = b.rawLabel, P = c;
    if (v && v[M]) {
      var C = v[M];
      q(C) && C.textStyle && (P = new Gt(C.textStyle, c, r.ecModel));
    }
    var A = P.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), E = P.getShallow("align", !0) || d.textAlign, R = et(P.getShallow("alignMinLabel", !0), E), I = et(P.getShallow("alignMaxLabel", !0), E), N = P.getShallow("verticalAlign", !0) || P.getShallow("baseline", !0) || d.textVerticalAlign, B = et(P.getShallow("verticalAlignMinLabel", !0), N), $ = et(P.getShallow("verticalAlignMaxLabel", !0), N), H = 10 + (((w = b.time) === null || w === void 0 ? void 0 : w.level) || 0);
    m = Math.min(m, H), y = Math.max(y, H);
    var G = new vi({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: ta.isLabelSilent(r),
      z2: H,
      style: ra(P, {
        text: T,
        align: x === 0 ? R : x === h.length - 1 ? I : E,
        verticalAlign: x === 0 ? B : x === h.length - 1 ? $ : N,
        fill: mt(A) ? A(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          s.type === "category" ? D : s.type === "value" ? M + "" : M,
          x
        ) : A
      })
    });
    G.anid = "label_" + M;
    var nt = nc(G);
    if (nt.break = b.break, nt.tickValue = M, nt.layoutRotation = d.rotation, Gv({
      el: G,
      componentModel: r,
      itemName: T,
      formatterParamsExtra: {
        isTruncated: function() {
          return G.isTruncated;
        },
        value: D,
        tickIndex: x
      }
    }), p) {
      var K = ta.makeAxisEventDataBase(r);
      K.targetType = "axisLabel", K.value = D, K.tickIndex = x, b.break && (K.break = {
        // type: labelItem.break.type,
        start: b.break.parsedBreak.vmin,
        end: b.break.parsedBreak.vmax
      }), s.type === "category" && (K.dataIndex = M), Ft(G).eventData = K, b.break && WF(r, a, G, b.break);
    }
    g.push(G), l.add(G);
  });
  var _ = bt(g, function(b) {
    return {
      label: b,
      priority: nc(b).break ? b.z2 + (y - m + 1) : b.z2,
      defaultAttr: {
        ignore: b.ignore
      }
    };
  });
  Fd(t, _, l, u);
}
function Bw(e) {
  return !!e.labelLayoutList;
}
function Fd(e, t, i, n) {
  e.labelLayoutList = t, e.labelGroup = i, e.axisLabelsCreationContext = n;
}
function HF(e, t, i, n) {
  var r = t.get(["axisLabel", "margin"]);
  k(i, function(a, s) {
    var o = ir(a);
    if (o) {
      var l = o.label, u = nc(l);
      o.suggestIgnore = l.ignore, l.ignore = !1, od(an, YF), an.x = t.axis.dataToCoord(u.tickValue), an.y = e.labelOffset + e.labelDirection * r, an.rotation = u.layoutRotation, n.add(an), an.updateTransform(), n.remove(an), an.decomposeTransform(), od(l, an), l.markRedraw(), ic(o, !0), ir(o);
    }
  });
}
var an = new xe(), YF = new xe();
function fp(e) {
  return !!e;
}
function WF(e, t, i, n) {
  i.on("click", function(r) {
    var a = {
      type: CF,
      breaks: [{
        start: n.parsedBreak.breakOption.start,
        end: n.parsedBreak.breakOption.end
      }]
    };
    a[e.axis.dim + "AxisIndex"] = e.componentIndex, t.dispatchAction(a);
  });
}
function n0(e, t, i) {
  i = i || {};
  var n = t.axis, r = {}, a = n.getAxesOnZeroOf()[0], s = n.position, o = a ? "onZero" : s, l = n.dim, u = [e.x, e.x + e.width, e.y, e.y + e.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, h = t.get("offset") || 0, f = l === "x" ? [u[2] - h, u[3] + h] : [u[0] - h, u[1] + h];
  if (a) {
    var d = a.toGlobalCoord(a.dataToCoord(0));
    f[c.onZero] = Math.max(Math.min(d, f[1]), f[0]);
  }
  r.position = [l === "y" ? f[c[o]] : u[0], l === "x" ? f[c[o]] : u[3]], r.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  r.labelDirection = r.tickDirection = r.nameDirection = v[s], r.labelOffset = a ? f[c[s]] - f[c.onZero] : 0, t.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), Jn(i.labelInside, t.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
  var g = t.get(["axisLabel", "rotate"]);
  return r.labelRotate = o === "top" ? -g : g, r.z2 = 1, r;
}
function UF(e, t) {
  var i = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return GF(i, e, t), i.seriesInvolved && XF(i, e), i;
}
function GF(e, t, i) {
  var n = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", !0) || [], s = [];
  k(i.getCoordinateSystems(), function(o) {
    if (!o.axisPointerEnabled)
      return;
    var l = Fo(o.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = o;
    var c = o.model, h = c.getModel("tooltip", n);
    if (k(o.getAxes(), Ae(g, !1, null)), o.getTooltipAxes && n && h.get("show")) {
      var f = h.get("trigger") === "axis", d = h.get(["axisPointer", "type"]) === "cross", v = o.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (f || d) && k(v.baseAxes, Ae(g, d ? "cross" : !0, f)), d && k(v.otherAxes, Ae(g, "cross", !1));
    }
    function g(p, m, y) {
      var _ = y.model.getModel("axisPointer", r), b = _.get("show");
      if (!(!b || b === "auto" && !p && !Bd(_))) {
        m == null && (m = _.get("triggerTooltip")), _ = p ? jF(y, h, r, t, p, m) : _;
        var x = _.get("snap"), w = _.get("triggerEmphasis"), M = Fo(y.model), T = m || x || y.type === "category", D = e.axesInfo[M] = {
          key: M,
          axis: y,
          coordSys: o,
          axisPointerModel: _,
          triggerTooltip: m,
          triggerEmphasis: w,
          involveSeries: T,
          snap: x,
          useHandle: Bd(_),
          seriesModels: [],
          linkGroup: null
        };
        u[M] = D, e.seriesInvolved = e.seriesInvolved || T;
        var P = qF(a, y);
        if (P != null) {
          var C = s[P] || (s[P] = {
            axesInfo: {}
          });
          C.axesInfo[M] = D, C.mapper = a[P].mapper, D.linkGroup = C;
        }
      }
    }
  });
}
function jF(e, t, i, n, r, a) {
  var s = t.getModel("axisPointer"), o = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  k(o, function(f) {
    l[f] = dt(s.get(f));
  }), l.snap = e.type !== "category" && !!a, s.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), r === "cross") {
    var c = s.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var h = l.lineStyle = s.get("crossStyle");
      h && Qt(u, h.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new Gt(l, i, n));
}
function XF(e, t) {
  t.eachSeries(function(i) {
    var n = i.coordinateSystem, r = i.get(["tooltip", "trigger"], !0), a = i.get(["tooltip", "show"], !0);
    !n || !n.model || r === "none" || r === !1 || r === "item" || a === !1 || i.get(["axisPointer", "show"], !0) === !1 || k(e.coordSysAxesInfo[Fo(n.model)], function(s) {
      var o = s.axis;
      n.getAxis(o.dim) === o && (s.seriesModels.push(i), s.seriesDataCount == null && (s.seriesDataCount = 0), s.seriesDataCount += i.getData().count());
    });
  });
}
function qF(e, t) {
  for (var i = t.model, n = t.dim, r = 0; r < e.length; r++) {
    var a = e[r] || {};
    if (bf(a[n + "AxisId"], i.id) || bf(a[n + "AxisIndex"], i.componentIndex) || bf(a[n + "AxisName"], i.name))
      return r;
  }
}
function bf(e, t) {
  return e === "all" || j(e) && Bt(e, t) >= 0 || e === t;
}
function ZF(e) {
  var t = dp(e);
  if (t) {
    var i = t.axisPointerModel, n = t.axis.scale, r = i.option, a = i.get("status"), s = i.get("value");
    s != null && (s = n.parse(s));
    var o = Bd(i);
    a == null && (r.status = o ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (s == null || s > l[1]) && (s = l[1]), s < l[0] && (s = l[0]), r.value = s, o && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function dp(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[Fo(e)];
}
function KF(e) {
  var t = dp(e);
  return t && t.axisPointerModel;
}
function Bd(e) {
  return !!e.get(["handle", "show"]);
}
function Fo(e) {
  return e.type + "||" + e.id;
}
var xf = {}, QF = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r, a) {
      this.axisPointerClass && ZF(i), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(i, r, !0);
    }, t.prototype.updateAxisPointer = function(i, n, r, a) {
      this._doUpdateAxisPointerClass(i, r, !1);
    }, t.prototype.remove = function(i, n) {
      var r = this._axisPointer;
      r && r.remove(n);
    }, t.prototype.dispose = function(i, n) {
      this._disposeAxisPointer(n), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(i, n, r) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var s = KF(i);
        s ? (this._axisPointer || (this._axisPointer = new a())).render(i, s, n, r) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(i) {
      this._axisPointer && this._axisPointer.dispose(i), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(i, n) {
      if (process.env.NODE_ENV !== "production" && xf[i])
        throw new Error("axisPointer " + i + " exists");
      xf[i] = n;
    }, t.getAxisPointerClass = function(i) {
      return i && xf[i];
    }, t.type = "axis", t;
  })(Mn)
), Fr = Wt(), r0 = dt, wf = Dt, JF = (
  /** @class */
  (function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, i, n, r) {
      var a = i.get("value"), s = i.get("status");
      if (this._axisModel = t, this._axisPointerModel = i, this._api = n, !(!r && this._lastValue === a && this._lastStatus === s)) {
        this._lastValue = a, this._lastStatus = s;
        var o = this._group, l = this._handle;
        if (!s || s === "hide") {
          o && o.hide(), l && l.hide();
          return;
        }
        o && o.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, i, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(t, i);
        if (!o)
          o = this._group = new Mi(), this.createPointerEl(o, u, t, i), this.createLabelEl(o, u, t, i), n.getZr().add(o);
        else {
          var f = Ae(a0, i, h);
          this.updatePointerEl(o, u, f), this.updateLabelEl(o, u, f, i);
        }
        o0(o, i, !0), this._renderHandle(a);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, i) {
      var n = i.get("animation"), r = t.axis, a = r.type === "category", s = i.get("snap");
      if (!s && !a)
        return !1;
      if (n === "auto" || n == null) {
        var o = this.animationThreshold;
        if (a && r.getBandWidth() > o)
          return !0;
        if (s) {
          var l = dp(t).seriesDataCount, u = r.getExtent();
          return Math.abs(u[0] - u[1]) / l > o;
        }
        return !1;
      }
      return n === !0;
    }, e.prototype.makeElOption = function(t, i, n, r, a) {
    }, e.prototype.createPointerEl = function(t, i, n, r) {
      var a = i.pointer;
      if (a) {
        var s = Fr(t).pointerEl = new yI[a.type](r0(i.pointer));
        t.add(s);
      }
    }, e.prototype.createLabelEl = function(t, i, n, r) {
      if (i.label) {
        var a = Fr(t).labelEl = new vi(r0(i.label));
        t.add(a), s0(a, r);
      }
    }, e.prototype.updatePointerEl = function(t, i, n) {
      var r = Fr(t).pointerEl;
      r && i.pointer && (r.setStyle(i.pointer.style), n(r, {
        shape: i.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, i, n, r) {
      var a = Fr(t).labelEl;
      a && (a.setStyle(i.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: i.label.x,
        y: i.label.y
      }), s0(a, r));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var i = this._axisPointerModel, n = this._api.getZr(), r = this._handle, a = i.getModel("handle"), s = i.get("status");
        if (!a.get("show") || !s || s === "hide") {
          r && n.remove(r), this._handle = null;
          return;
        }
        var o;
        this._handle || (o = !0, r = this._handle = ox(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Mu(u.event);
          },
          onmousedown: wf(this._onHandleDragMove, this, 0, 0),
          drift: wf(this._onHandleDragMove, this),
          ondragend: wf(this._onHandleDragEnd, this)
        }), n.add(r)), o0(r, i, !1), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        j(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, qx(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o);
      }
    }, e.prototype._moveHandleToValue = function(t, i) {
      a0(this._axisPointerModel, !i && this._moveAnimation, this._handle, Sf(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, i) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var r = this.updateHandleTransform(Sf(n), [t, i], this._axisModel, this._axisPointerModel);
        this._payloadInfo = r, n.stopAnimation(), n.attr(Sf(r)), Fr(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var i = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: i.cursorPoint[0],
          y: i.cursorPoint[1],
          tooltipOption: i.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var i = this._axisPointerModel.get("value");
        this._moveHandleToValue(i), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var i = t.getZr(), n = this._group, r = this._handle;
      i && n && (this._lastGraphicKey = null, n && i.remove(n), r && i.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), Cd(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, i, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: i[n],
        height: i[1 - n]
      };
    }, e;
  })()
);
function a0(e, t, i, n) {
  zw(Fr(i).lastProp, n) || (Fr(i).lastProp = n, t ? Hv(i, n, e) : (i.stopAnimation(), i.attr(n)));
}
function zw(e, t) {
  if (q(e) && q(t)) {
    var i = !0;
    return k(t, function(n, r) {
      i = i && zw(e[r], n);
    }), !!i;
  } else
    return e === t;
}
function s0(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function Sf(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function o0(e, t, i) {
  var n = t.get("z"), r = t.get("zlevel");
  e && e.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), r != null && (a.zlevel = r), a.silent = i);
  });
}
function tB(e) {
  var t = e.get("type"), i = e.getModel(t + "Style"), n;
  return t === "line" ? (n = i.getLineStyle(), n.fill = null) : t === "shadow" && (n = i.getAreaStyle(), n.stroke = null), n;
}
function eB(e, t, i, n, r) {
  var a = i.get("value"), s = Vw(a, t.axis, t.ecModel, i.get("seriesDataIndices"), {
    precision: i.get(["label", "precision"]),
    formatter: i.get(["label", "formatter"])
  }), o = i.getModel("label"), l = Kv(o.get("padding") || 0), u = o.getFont(), c = bE(s, u), h = r.position, f = c.width + l[1] + l[3], d = c.height + l[0] + l[2], v = r.align;
  v === "right" && (h[0] -= f), v === "center" && (h[0] -= f / 2);
  var g = r.verticalAlign;
  g === "bottom" && (h[1] -= d), g === "middle" && (h[1] -= d / 2), iB(h, f, d, n);
  var p = o.get("backgroundColor");
  (!p || p === "auto") && (p = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: ra(o, {
      text: s,
      font: u,
      fill: o.getTextColor(),
      padding: l,
      backgroundColor: p
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function iB(e, t, i, n) {
  var r = n.getWidth(), a = n.getHeight();
  e[0] = Math.min(e[0] + t, r) - t, e[1] = Math.min(e[1] + i, a) - i, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function Vw(e, t, i, n, r) {
  e = t.scale.parse(e);
  var a = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: r.precision
  }), s = r.formatter;
  if (s) {
    var o = {
      value: Lw(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    k(n, function(l) {
      var u = i.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && o.seriesData.push(h);
    }), Q(s) ? a = s.replace("{value}", a) : mt(s) && (a = s(o));
  }
  return a;
}
function $w(e, t, i) {
  var n = Gi();
  return Sv(n, n, i.rotation), Xf(n, n, i.position), Uv([e.dataToCoord(t), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
}
function nB(e, t, i, n, r, a) {
  var s = ta.innerTextLayout(i.rotation, 0, i.labelDirection);
  i.labelMargin = r.get(["label", "margin"]), eB(t, n, r, a, {
    position: $w(n.axis, e, i),
    align: s.textAlign,
    verticalAlign: s.textVerticalAlign
  });
}
function rB(e, t, i) {
  return i = i || 0, {
    x1: e[i],
    y1: e[1 - i],
    x2: t[i],
    y2: t[1 - i]
  };
}
function aB(e, t, i) {
  return i = i || 0, {
    x: e[i],
    y: e[1 - i],
    width: t[i],
    height: t[1 - i]
  };
}
var sB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(i, n, r, a, s) {
      var o = r.axis, l = o.grid, u = a.get("type"), c = l0(l, o).getOtherAxis(o).getGlobalExtent(), h = o.toGlobalCoord(o.dataToCoord(n, !0));
      if (u && u !== "none") {
        var f = tB(a), d = oB[u](o, h, c);
        d.style = f, i.graphicKey = d.type, i.pointer = d;
      }
      var v = n0(l.getRect(), r);
      nB(n, i, v, r, a, s);
    }, t.prototype.getHandleTransform = function(i, n, r) {
      var a = n0(n.axis.grid.getRect(), n, {
        labelInside: !1
      });
      a.labelMargin = r.get(["handle", "margin"]);
      var s = $w(n.axis, i, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(i, n, r, a) {
      var s = r.axis, o = s.grid, l = s.getGlobalExtent(!0), u = l0(o, s).getOtherAxis(s).getGlobalExtent(), c = s.dim === "x" ? 0 : 1, h = [i.x, i.y];
      h[c] += n[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var f = (u[1] + u[0]) / 2, d = [f, f];
      d[c] = h[c];
      var v = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: i.rotation,
        cursorPoint: d,
        tooltipOption: v[c]
      };
    }, t;
  })(JF)
);
function l0(e, t) {
  var i = {};
  return i[t.dim + "AxisIndex"] = t.index, e.getCartesian(i);
}
var oB = {
  line: function(e, t, i) {
    var n = rB([t, i[0]], [t, i[1]], u0(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, i) {
    var n = Math.max(1, e.getBandWidth()), r = i[1] - i[0];
    return {
      type: "Rect",
      shape: aB([t - n / 2, i[0]], [n, r], u0(e))
    };
  }
};
function u0(e) {
  return e.dim === "x" ? 0 : 1;
}
var lB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: St.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: St.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: St.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: St.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: St.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  })(Pt)
), pn = Wt(), uB = k;
function Hw(e, t, i) {
  if (!rt.node) {
    var n = t.getZr();
    pn(n).records || (pn(n).records = {}), cB(n, t);
    var r = pn(n).records[e] || (pn(n).records[e] = {});
    r.handler = i;
  }
}
function cB(e, t) {
  if (pn(e).initialized)
    return;
  pn(e).initialized = !0, i("click", Ae(c0, "click")), i("mousemove", Ae(c0, "mousemove")), i("globalout", fB);
  function i(n, r) {
    e.on(n, function(a) {
      var s = dB(t);
      uB(pn(e).records, function(o) {
        o && r(o, a, s.dispatchAction);
      }), hB(s.pendings, t);
    });
  }
}
function hB(e, t) {
  var i = e.showTip.length, n = e.hideTip.length, r;
  i ? r = e.showTip[i - 1] : n && (r = e.hideTip[n - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
}
function fB(e, t, i) {
  e.handler("leave", null, i);
}
function c0(e, t, i, n) {
  t.handler(e, i, n);
}
function dB(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, i = function(n) {
    var r = t[n.type];
    r ? r.push(n) : (n.dispatchAction = i, e.dispatchAction(n));
  };
  return {
    dispatchAction: i,
    pendings: t
  };
}
function zd(e, t) {
  if (!rt.node) {
    var i = t.getZr(), n = (pn(i).records || {})[e];
    n && (pn(i).records[e] = null);
  }
}
var vB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      var a = n.getComponent("tooltip"), s = i.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      Hw("axisPointer", r, function(o, l, u) {
        s !== "none" && (o === "leave" || s.indexOf(o) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: o,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(i, n) {
      zd("axisPointer", n);
    }, t.prototype.dispose = function(i, n) {
      zd("axisPointer", n);
    }, t.type = "axisPointer", t;
  })(Mn)
);
function Yw(e, t) {
  var i = [], n = e.seriesIndex, r;
  if (n == null || !(r = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = r.getData(), s = Go(a, e);
  if (s == null || s < 0 || j(s))
    return {
      point: []
    };
  var o = a.getItemGraphicEl(s), l = r.coordinateSystem;
  if (r.getTooltipPosition)
    i = r.getTooltipPosition(s) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, f = u.dim, d = h === "x" || h === "radius" ? 1 : 0, v = a.mapDimension(f), g = [];
      g[d] = a.get(v, s), g[1 - d] = a.get(a.getCalculationInfo("stackResultDimension"), s), i = l.dataToPoint(g) || [];
    } else
      i = l.dataToPoint(a.getValues(bt(l.dimensions, function(m) {
        return a.mapDimension(m);
      }), s)) || [];
  else if (o) {
    var p = o.getBoundingRect().clone();
    p.applyTransform(o.transform), i = [p.x + p.width / 2, p.y + p.height / 2];
  }
  return {
    point: i,
    el: o
  };
}
var h0 = Wt();
function pB(e, t, i) {
  var n = e.currTrigger, r = [e.x, e.y], a = e, s = e.dispatchAction || Dt(i.dispatchAction, i), o = t.getComponent("axisPointer").coordSysAxesInfo;
  if (o) {
    uu(r) && (r = Yw({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = uu(r), u = a.axesInfo, c = o.axesInfo, h = n === "leave" || uu(r), f = {}, d = {}, v = {
      list: [],
      map: {}
    }, g = {
      showPointer: Ae(mB, d),
      showTooltip: Ae(yB, v)
    };
    k(o.coordSysMap, function(m, y) {
      var _ = l || m.containPoint(r);
      k(o.coordSysAxesInfo[y], function(b, x) {
        var w = b.axis, M = wB(u, b);
        if (!h && _ && (!u || M)) {
          var T = M && M.value;
          T == null && !l && (T = w.pointToData(r)), T != null && f0(b, T, g, !1, f);
        }
      });
    });
    var p = {};
    return k(c, function(m, y) {
      var _ = m.linkGroup;
      _ && !d[y] && k(_.axesInfo, function(b, x) {
        var w = d[x];
        if (b !== m && w) {
          var M = w.value;
          _.mapper && (M = m.axis.scale.parse(_.mapper(M, d0(b), d0(m)))), p[m.key] = M;
        }
      });
    }), k(p, function(m, y) {
      f0(c[y], m, g, !0, f);
    }), _B(d, c, f), bB(v, r, e, s), xB(c, s, i), f;
  }
}
function f0(e, t, i, n, r) {
  var a = e.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!e.involveSeries) {
      i.showPointer(e, t);
      return;
    }
    var s = gB(t, e), o = s.payloadBatch, l = s.snapToValue;
    o[0] && r.seriesIndex == null && Y(r, o[0]), !n && e.snap && a.containData(l) && l != null && (t = l), i.showPointer(e, t, o), i.showTooltip(e, s, l);
  }
}
function gB(e, t) {
  var i = t.axis, n = i.dim, r = e, a = [], s = Number.MAX_VALUE, o = -1;
  return k(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), h, f;
    if (l.getAxisTooltipData) {
      var d = l.getAxisTooltipData(c, e, i);
      f = d.dataIndices, h = d.nestestValue;
    } else {
      if (f = l.indicesOfNearest(
        n,
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        i.type === "category" ? 0.5 : null
      ), !f.length)
        return;
      h = l.getData().get(c[0], f[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var v = e - h, g = Math.abs(v);
      g <= s && ((g < s || v >= 0 && o < 0) && (s = g, o = v, r = h, a.length = 0), k(f, function(p) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: p,
          dataIndex: l.getData().getRawIndex(p)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: r
  };
}
function mB(e, t, i, n) {
  e[t.key] = {
    value: i,
    payloadBatch: n
  };
}
function yB(e, t, i, n) {
  var r = i.payloadBatch, a = t.axis, s = a.model, o = t.axisPointerModel;
  if (!(!t.triggerTooltip || !r.length)) {
    var l = t.coordSys.model, u = Fo(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: s.componentIndex,
      axisType: s.type,
      axisId: s.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: o.get(["label", "precision"]),
        formatter: o.get(["label", "formatter"])
      },
      seriesDataIndices: r.slice()
    });
  }
}
function _B(e, t, i) {
  var n = i.axesInfo = [];
  k(t, function(r, a) {
    var s = r.axisPointerModel.option, o = e[a];
    o ? (!r.useHandle && (s.status = "show"), s.value = o.value, s.seriesDataIndices = (o.payloadBatch || []).slice()) : !r.useHandle && (s.status = "hide"), s.status === "show" && n.push({
      axisDim: r.axis.dim,
      axisIndex: r.axis.model.componentIndex,
      value: s.value
    });
  });
}
function bB(e, t, i, n) {
  if (uu(t) || !e.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var r = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: i.tooltipOption,
    position: i.position,
    dataIndexInside: r.dataIndexInside,
    dataIndex: r.dataIndex,
    seriesIndex: r.seriesIndex,
    dataByCoordSys: e.list
  });
}
function xB(e, t, i) {
  var n = i.getZr(), r = "axisPointerLastHighlights", a = h0(n)[r] || {}, s = h0(n)[r] = {};
  k(e, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && k(h.seriesDataIndices, function(f) {
      var d = f.seriesIndex + " | " + f.dataIndex;
      s[d] = f;
    });
  });
  var o = [], l = [];
  k(a, function(u, c) {
    !s[c] && l.push(u);
  }), k(s, function(u, c) {
    !a[c] && o.push(u);
  }), l.length && i.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), o.length && i.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: o
  });
}
function wB(e, t) {
  for (var i = 0; i < (e || []).length; i++) {
    var n = e[i];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function d0(e) {
  var t = e.axis.model, i = {}, n = i.axisDim = e.axis.dim;
  return i.axisIndex = i[n + "AxisIndex"] = t.componentIndex, i.axisName = i[n + "AxisName"] = t.name, i.axisId = i[n + "AxisId"] = t.id, i;
}
function uu(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function SB(e) {
  QF.registerAxisPointerClass("CartesianAxisPointer", sB), e.registerComponentModel(lB), e.registerComponentView(vB), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var i = t.axisPointer.link;
      i && !j(i) && (t.axisPointer.link = [i]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, i) {
    t.getComponent("axisPointer").coordSysAxesInfo = UF(t, i);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, pB);
}
function MB(e, t, i) {
  var n = e.target;
  n.x += t, n.y += i, n.dirty();
}
function TB(e, t, i, n) {
  var r = e.target, a = e.zoomLimit, s = e.zoom = e.zoom || 1;
  s *= t, s = vp(s, a);
  var o = s / e.zoom;
  e.zoom = s, Ww(r, i, n, o), r.dirty();
}
function DB(e, t, i, n, r, a) {
  var s = new at(0, 0, 0, 0);
  n.enable(e.get("roam"), {
    api: t,
    zInfo: {
      component: e
    },
    triggerInfo: {
      roamTrigger: e.get("roamTrigger"),
      isInSelf: function(u, c, h) {
        return s.copy(i.getBoundingRect()), s.applyTransform(i.getComputedTransform()), s.contain(c, h);
      },
      isInClip: function(u, c, h) {
        return !0;
      }
    }
  }), r.zoomLimit = e.get("scaleLimit");
  var o = e.coordinateSystem;
  r.zoom = o ? o.getZoom() : 1;
  var l = e.subType + "Roam";
  n.off("pan").off("zoom").on("pan", function(u) {
    MB(r, u.dx, u.dy), t.dispatchAction({
      seriesId: e.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    TB(r, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: e.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function v0(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function CB(e, t, i) {
  var n = e.getZoom(), r = e.getCenter(), a = t.zoom, s = e.projectedToPoint ? e.projectedToPoint(r) : e.dataToPoint(r);
  return t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, e.setCenter(v0(e, s))), a != null && (a = vp(n * a, i) / n, Ww(e, t.originX, t.originY, a), e.updateTransform(), e.setCenter(v0(e, s)), e.setZoom(a * n)), {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
function Ww(e, t, i, n) {
  e.x -= (t - e.x) * (n - 1), e.y -= (i - e.y) * (n - 1), e.scaleX *= n, e.scaleY *= n;
}
function vp(e, t) {
  if (t) {
    var i = t.min || 0, n = t.max || 1 / 0;
    e = Math.max(Math.min(n, e), i);
  }
  return e;
}
var p0 = qe, kB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(i, n) {
      var r = e.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Vr(), r._rawTransformable = new Vr(), r.name = i, r._opt = n, r;
    }
    return t.prototype.setBoundingRect = function(i, n, r, a) {
      return this._rect = new at(i, n, r, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(i, n, r, a) {
      this._transformTo(i, n, r, a), this._viewRect = new at(i, n, r, a);
    }, t.prototype._transformTo = function(i, n, r, a) {
      var s = this.getBoundingRect(), o = this._rawTransformable;
      o.transform = s.calculateTransform(new at(i, n, r, a));
      var l = o.parent;
      o.parent = null, o.decomposeTransform(), o.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(i) {
      var n = this._opt;
      n && n.api && n.ecModel && n.ecModel.getShallow("legacyViewCoordSysCenterBase") && i && (i = [ze(i[0], n.api.getWidth()), ze(i[1], n.api.getWidth())]), this._centerOption = dt(i), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(i) {
      this._zoom = vp(i || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var i = this.getBoundingRect(), n = i.x + i.width / 2, r = i.y + i.height / 2;
      return [n, r];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var i = this._centerOption, n = this._rect;
      i && n && (this._center = [ze(i[0], n.width, n.x), ze(i[1], n.height, n.y)]);
      var r = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, s = this.getDefaultCenter(), o = this.getCenter(), l = this.getZoom();
      o = qe([], o, r), s = qe([], s, r), a.originX = o[0], a.originY = o[1], a.x = s[0] - o[0], a.y = s[1] - o[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var i = this._roamTransformable, n = this._rawTransformable;
      n.parent = i, i.updateTransform(), n.updateTransform(), wv(this.transform || (this.transform = []), n.transform || Gi()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Wo(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var i = this._rawTransformable, n = this._roamTransformable, r = new Vr();
      return r.transform = n.transform, r.decomposeTransform(), {
        roam: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        },
        raw: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var i = this.getBoundingRect().clone();
      return i.applyTransform(this.transform), i;
    }, t.prototype.dataToPoint = function(i, n, r) {
      var a = n ? this._rawTransform : this.transform;
      return r = r || [], a ? p0(r, i, a) : cA(r, i);
    }, t.prototype.pointToData = function(i, n, r) {
      r = r || [];
      var a = this.invTransform;
      return a ? p0(r, i, a) : (r[0] = i[0], r[1] = i[1], r);
    }, t.prototype.convertToPixel = function(i, n, r) {
      var a = g0(n);
      return a === this ? a.dataToPoint(r) : null;
    }, t.prototype.convertFromPixel = function(i, n, r) {
      var a = g0(n);
      return a === this ? a.pointToData(r) : null;
    }, t.prototype.containPoint = function(i) {
      return this.getViewRectAfterRoam().contain(i[0], i[1]);
    }, t.dimensions = ["x", "y"], t;
  })(Vr)
);
function g0(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var PB = Wt();
function m0(e, t) {
  return !!PB(e)[t];
}
ua({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, be);
var AB = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function EB(e, t, i) {
  var n = t.getComponentByElement(e.topTarget);
  if (!n || n === i || AB.hasOwnProperty(n.mainType))
    return !1;
  var r = n.coordinateSystem;
  if (!r || r.model === i)
    return !1;
  var a = Lo(n), s = Lo(i);
  return !((a.zlevel - s.zlevel || a.z - s.z) <= 0);
}
var LB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(i) {
      var n = e.call(this) || this;
      n._zr = i;
      var r = Dt(n._mousedownHandler, n), a = Dt(n._mousemoveHandler, n), s = Dt(n._mouseupHandler, n), o = Dt(n._mousewheelHandler, n), l = Dt(n._pinchHandler, n);
      return n.enable = function(u, c) {
        var h = c.zInfo, f = Lo(h.component), d = f.z, v = f.zlevel, g = {
          component: h.component,
          z: d,
          zlevel: v,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: et(h.z2, -1 / 0)
        }, p = Y({}, c.triggerInfo);
        this._opt = Qt(Y({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: g,
          triggerInfo: p
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && (Bs(i, "mousedown", r, g), Bs(i, "mousemove", a, g), Bs(i, "mouseup", s, g)), (u === !0 || u === "scale" || u === "zoom") && (Bs(i, "mousewheel", o, g), Bs(i, "pinch", l, g)));
      }, n.disable = function() {
        this._enabled = !1, zs(i, "mousedown", r), zs(i, "mousemove", a), zs(i, "mouseup", s), zs(i, "mousewheel", o), zs(i, "pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(i, n, r) {
      var a = this._opt, s = a.zInfoParsed;
      if (EB(i, a.api, s.component))
        return !1;
      var o = a.triggerInfo, l = o.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = o.isInSelf(i, n, r)), u && o.isInClip && !o.isInClip(i, n, r) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(i, n, r, a) {
      var s = i.target;
      if (!s && this._checkPointer(i, n, r))
        return "grab";
      if (a)
        return s && s.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(i) {
      if (!(vm(i) || Fs(i))) {
        for (var n = i.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var r = i.offsetX, a = i.offsetY;
        this._checkPointer(i, r, a) && (this._x = r, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(i) {
      var n = this._zr;
      if (!(i.gestureEvent === "pinch" || m0(n, "globalPan") || Fs(i))) {
        var r = i.offsetX, a = i.offsetY;
        if (!this._dragging || !cu("moveOnMouseMove", i, this._opt)) {
          var s = this._decideCursorStyle(i, r, a, !1);
          s && n.setCursorStyle(s);
          return;
        }
        n.setCursorStyle("grabbing");
        var o = this._x, l = this._y, u = r - o, c = a - l;
        this._x = r, this._y = a, this._opt.preventDefaultMouseMove && Mu(i.event), i.__ecRoamConsumed = !0, y0(this, "pan", "moveOnMouseMove", i, {
          dx: u,
          dy: c,
          oldX: o,
          oldY: l,
          newX: r,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(i) {
      if (!Fs(i)) {
        var n = this._zr;
        if (!vm(i)) {
          this._dragging = !1;
          var r = this._decideCursorStyle(i, i.offsetX, i.offsetY, !0);
          r && n.setCursorStyle(r);
        }
      }
    }, t.prototype._mousewheelHandler = function(i) {
      if (!Fs(i)) {
        var n = cu("zoomOnMouseWheel", i, this._opt), r = cu("moveOnMouseWheel", i, this._opt), a = i.wheelDelta, s = Math.abs(a), o = i.offsetX, l = i.offsetY;
        if (!(a === 0 || !n && !r)) {
          if (n) {
            var u = s > 3 ? 1.4 : s > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", i, {
              scale: c,
              originX: o,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (r) {
            var h = Math.abs(a), f = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", i, {
              scrollDelta: f,
              originX: o,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(i) {
      if (!(m0(this._zr, "globalPan") || Fs(i))) {
        var n = i.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, i, {
          scale: n,
          originX: i.pinchX,
          originY: i.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(i, n, r, a, s) {
      i._checkPointer(a, s.originX, s.originY) && (Mu(a.event), a.__ecRoamConsumed = !0, y0(i, n, r, a, s));
    }, t;
  })(ki)
);
function Fs(e) {
  return e.__ecRoamConsumed;
}
var OB = Wt();
function Fc(e) {
  var t = OB(e);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function Bs(e, t, i, n) {
  for (var r = Fc(e), a = r.roam, s = a[t] = a[t] || [], o = 0; o < s.length; o++) {
    var l = s[o].zInfoParsed;
    if ((l.zlevel - n.zlevel || l.z - n.z || l.z2 - n.z2) <= 0)
      break;
  }
  s.splice(o, 0, {
    listener: i,
    zInfoParsed: n
  }), IB(e, t);
}
function zs(e, t, i) {
  for (var n = Fc(e), r = n.roam[t] || [], a = 0; a < r.length; a++)
    if (r[a].listener === i) {
      r.splice(a, 1), r.length || RB(e, t);
      return;
    }
}
function IB(e, t) {
  var i = Fc(e);
  i.uniform[t] || e.on(t, i.uniform[t] = function(n) {
    var r = i.roam[t];
    if (r)
      for (var a = 0; a < r.length; a++)
        r[a].listener(n);
  });
}
function RB(e, t) {
  var i = Fc(e), n = i.uniform;
  n[t] && (e.off(t, n[t]), n[t] = null);
}
function y0(e, t, i, n, r) {
  r.isAvailableBehavior = Dt(cu, null, i, n), e.trigger(t, r);
}
function cu(e, t, i) {
  var n = i[e];
  return !e || n && (!Q(n) || t.event[n + "Key"]);
}
var NB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: St.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: St.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: St.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: St.color.tertiary,
        fontSize: 14
      }
    }, t;
  })(Pt)
);
function Uw(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function Gw(e) {
  if (rt.domSupported) {
    for (var t = document.documentElement.style, i = 0, n = e.length; i < n; i++)
      if (e[i] in t)
        return e[i];
  }
}
var jw = Gw(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), FB = Gw(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function Xw(e, t) {
  if (!e)
    return t;
  t = mx(t, !0);
  var i = e.indexOf(t);
  return e = i === -1 ? t : "-" + e.slice(0, i) + "-" + t, e.toLowerCase();
}
function BB(e, t) {
  var i = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return i ? i[t] : null;
}
var zB = Xw(FB, "transition"), pp = Xw(jw, "transform"), VB = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (rt.transform3dSupported ? "will-change:transform;" : "");
function $B(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function HB(e, t, i) {
  if (!Q(i) || i === "inside")
    return "";
  var n = e.get("backgroundColor"), r = e.get("borderWidth");
  t = Oo(t);
  var a = $B(i), s = Math.max(Math.round(r) * 1.5, 6), o = "", l = pp + ":", u;
  Bt(["left", "right"], a) > -1 ? (o += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (o += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = s + r, f = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), d = Math.round(((f - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (f - h) / 2) * 100) / 100;
  o += ";" + a + ":-" + d + "px";
  var v = t + " solid " + r + "px;", g = ["position:absolute;width:" + s + "px;height:" + s + "px;z-index:-1;", o + ";" + l + ";", "border-bottom:" + v, "border-right:" + v, "background-color:" + n + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function YB(e, t, i) {
  var n = "cubic-bezier(0.23,1,0.32,1)", r = "", a = "";
  return i && (r = " " + e / 2 + "s " + n, a = "opacity" + r + ",visibility" + r), t || (r = " " + e + "s " + n, a += (a.length ? "," : "") + (rt.transformSupported ? "" + pp + r : ",left" + r + ",top" + r)), zB + ":" + a;
}
function _0(e, t, i) {
  var n = e.toFixed(0) + "px", r = t.toFixed(0) + "px";
  if (!rt.transformSupported)
    return i ? "top:" + r + ";left:" + n + ";" : [["top", r], ["left", n]];
  var a = rt.transform3dSupported, s = "translate" + (a ? "3d" : "") + "(" + n + "," + r + (a ? ",0" : "") + ")";
  return i ? "top:0;left:0;" + pp + ":" + s + ";" : [["top", 0], ["left", 0], [jw, s]];
}
function WB(e) {
  var t = [], i = e.get("fontSize"), n = e.getTextColor();
  n && t.push("color:" + n), t.push("font:" + e.getFont());
  var r = et(e.get("lineHeight"), Math.round(i * 3 / 2));
  i && t.push("line-height:" + r + "px");
  var a = e.get("textShadowColor"), s = e.get("textShadowBlur") || 0, o = e.get("textShadowOffsetX") || 0, l = e.get("textShadowOffsetY") || 0;
  return a && s && t.push("text-shadow:" + o + "px " + l + "px " + s + "px " + a), k(["decoration", "align"], function(u) {
    var c = e.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function UB(e, t, i, n) {
  var r = [], a = e.get("transitionDuration"), s = e.get("backgroundColor"), o = e.get("shadowBlur"), l = e.get("shadowColor"), u = e.get("shadowOffsetX"), c = e.get("shadowOffsetY"), h = e.getModel("textStyle"), f = Gx(e, "html"), d = u + "px " + c + "px " + o + "px " + l;
  return r.push("box-shadow:" + d), t && a > 0 && r.push(YB(a, i, n)), s && r.push("background-color:" + s), k(["width", "color", "radius"], function(v) {
    var g = "border-" + v, p = mx(g), m = e.get(p);
    m != null && r.push(g + ":" + m + (v === "color" ? "" : "px"));
  }), r.push(WB(h)), f != null && r.push("padding:" + Kv(f).join("px ") + "px"), r.join(";") + ";";
}
function b0(e, t, i, n, r) {
  var a = t && t.painter;
  if (i) {
    var s = a && a.getViewportRoot();
    s && bA(e, s, i, n, r);
  } else {
    e[0] = n, e[1] = r;
    var o = a && a.getViewportRootOffset();
    o && (e[0] += o.offsetLeft, e[1] += o.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var GB = (
  /** @class */
  (function() {
    function e(t, i) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, rt.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var r = this._zr = t.getZr(), a = i.appendTo, s = a && (Q(a) ? document.querySelector(a) : ts(a) ? a : mt(a) && a(t.getDom()));
      b0(this._styleCoord, r, s, t.getWidth() / 2, t.getHeight() / 2), (s || t.getDom()).appendChild(n), this._api = t, this._container = s;
      var o = this;
      n.onmouseenter = function() {
        o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !o._enterable) {
          var u = r.handler, c = r.painter.getViewportRoot();
          ni(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        o._inContent = !1, o._enterable && o._show && o.hideLater(o._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var i = this._api.getDom(), n = BB(i, "position"), r = i.style;
        r.position !== "absolute" && n !== "absolute" && (r.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, i) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, r = n.style, a = this._styleCoord;
      n.innerHTML ? r.cssText = VB + UB(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + _0(a[0], a[1], !0) + ("border-color:" + Oo(i) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var s = this.el;
      if (t == null) {
        s.innerHTML = "";
        return;
      }
      var o = "";
      if (Q(a) && n.get("trigger") === "item" && !Uw(n) && (o = HB(n, r, a)), Q(t))
        s.innerHTML = t + o;
      else if (t) {
        s.innerHTML = "", j(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          ts(t[l]) && t[l].parentNode !== s && s.appendChild(t[l]);
        if (o && s.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = o, s.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, e.prototype.moveTo = function(t, i) {
      if (this.el) {
        var n = this._styleCoord;
        if (b0(n, this._zr, this._container, t, i), n[0] != null && n[1] != null) {
          var r = this.el.style, a = _0(n[0], n[1]);
          k(a, function(s) {
            r[s[0]] = s[1];
          });
        }
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, i = this.el.style;
      this._enableDisplayTransition ? (i.visibility = "hidden", i.opacity = "0") : i.display = "none", rt.transform3dSupported && (i.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Dt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      xA(t && t.painter && t.painter.getViewportRoot(), this._container);
      var i = this.el;
      if (i) {
        i.onmouseenter = i.onmousemove = i.onmouseleave = null;
        var n = i.parentNode;
        n && n.removeChild(i);
      }
      this.el = this._container = null;
    }, e;
  })()
), jB = (
  /** @class */
  (function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), w0(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var i = t.get("alwaysShowContent");
      i && this._moveIfResized(), this._alwaysShowContent = i;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var s = this;
      q(t) && Ve(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var o = n.getModel("textStyle");
      this.el = new vi({
        style: {
          rich: i.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: r,
          textShadowColor: o.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: Gx(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), k(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        s.el.style[u] = n.get(u);
      }), k(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        s.el.style[u] = o.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, i = this.el.getBoundingRect(), n = x0(t.style);
      return [i.width + n.left + n.right, i.height + n.top + n.bottom];
    }, e.prototype.moveTo = function(t, i) {
      var n = this.el;
      if (n) {
        var r = this._styleCoord;
        w0(r, this._zr, t, i), t = r[0], i = r[1];
        var a = n.style, s = Nn(a.borderWidth || 0), o = x0(a);
        n.x = t + s + o.left, n.y = i + s + o.top, n.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Dt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  })()
);
function Nn(e) {
  return Math.max(0, e);
}
function x0(e) {
  var t = Nn(e.shadowBlur || 0), i = Nn(e.shadowOffsetX || 0), n = Nn(e.shadowOffsetY || 0);
  return {
    left: Nn(t - i),
    right: Nn(t + i),
    top: Nn(t - n),
    bottom: Nn(t + n)
  };
}
function w0(e, t, i, n) {
  e[0] = i, e[1] = n, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var XB = new xe({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), qB = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.init = function(i, n) {
      if (!(rt.node || !n.getDom())) {
        var r = i.getComponent("tooltip"), a = this._renderMode = tL(r.get("renderMode"));
        this._tooltipContent = a === "richText" ? new jB(n) : new GB(n, {
          appendTo: r.get("appendToBody", !0) ? "body" : r.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(i, n, r) {
      if (!(rt.node || !r.getDom())) {
        this.group.removeAll(), this._tooltipModel = i, this._ecModel = n, this._api = r;
        var a = this._tooltipContent;
        a.update(i), a.setEnterable(i.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && i.get("transitionDuration") ? qx(this, "_updatePosition", 50, "fixRate") : Cd(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var i = this._tooltipModel, n = i.get("triggerOn");
      Hw("itemTooltip", this._api, Dt(function(r, a, s) {
        n !== "none" && (n.indexOf(r) >= 0 ? this._tryShow(a, s) : r === "leave" && this._hide(s));
      }, this));
    }, t.prototype._keepShow = function() {
      var i = this._tooltipModel, n = this._ecModel, r = this._api, a = i.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var s = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !r.isDisposed() && s.manuallyShowTip(i, n, r, {
            x: s._lastX,
            y: s._lastY,
            dataByCoordSys: s._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(i, n, r, a) {
      if (!(a.from === this.uid || rt.node || !r.getDom())) {
        var s = S0(a, r);
        this._ticket = "";
        var o = a.dataByCoordSys, l = JB(a, n, r);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, s);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = XB;
          c.x = a.x, c.y = a.y, c.update(), Ft(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, s);
        } else if (o)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: o,
            tooltipOption: a.tooltipOption
          }, s);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(i, n, r, a))
            return;
          var h = Yw(a, n), f = h.point[0], d = h.point[1];
          f != null && d != null && this._tryShow({
            offsetX: f,
            offsetY: d,
            target: h.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, s);
        } else a.x != null && a.y != null && (r.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: r.getZr().findHover(a.x, a.y).target
        }, s));
      }
    }, t.prototype.manuallyHideTip = function(i, n, r, a) {
      var s = this._tooltipContent;
      this._tooltipModel && s.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(S0(a, r));
    }, t.prototype._manuallyAxisShowTip = function(i, n, r, a) {
      var s = a.seriesIndex, o = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(s == null || o == null || l == null)) {
        var u = n.getSeriesByIndex(s);
        if (u) {
          var c = u.getData(), h = Vs([c.getItemModel(o), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return r.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: s,
              dataIndex: o,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(i, n) {
      var r = i.target, a = this._tooltipModel;
      if (a) {
        this._lastX = i.offsetX, this._lastY = i.offsetY;
        var s = i.dataByCoordSys;
        if (s && s.length)
          this._showAxisTooltip(s, i);
        else if (r) {
          var o = Ft(r);
          if (o.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          to(r, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (Ft(c).dataIndex != null ? l = c : Ft(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(i, l, n) : u ? this._showComponentItemTooltip(i, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(i, n) {
      var r = i.get("showDelay");
      n = Dt(n, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(n, r) : n();
    }, t.prototype._showAxisTooltip = function(i, n) {
      var r = this._ecModel, a = this._tooltipModel, s = [n.offsetX, n.offsetY], o = Vs([n.tooltipOption], a), l = this._renderMode, u = [], c = aa("section", {
        blocks: [],
        noHeader: !0
      }), h = [], f = new lf();
      k(i, function(y) {
        k(y.dataByAxis, function(_) {
          var b = r.getComponent(_.axisDim + "Axis", _.axisIndex), x = _.value;
          if (!(!b || x == null)) {
            var w = Vw(x, b.axis, r, _.seriesDataIndices, _.valueLabelOpt), M = aa("section", {
              header: w,
              noHeader: !Hi(w),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(M), k(_.seriesDataIndices, function(T) {
              var D = r.getSeriesByIndex(T.seriesIndex), P = T.dataIndexInside, C = D.getDataParams(P);
              if (!(C.dataIndex < 0)) {
                C.axisDim = _.axisDim, C.axisIndex = _.axisIndex, C.axisType = _.axisType, C.axisId = _.axisId, C.axisValue = Lw(b.axis, {
                  value: x
                }), C.axisValueLabel = w, C.marker = f.makeTooltipMarker("item", Oo(C.color), l);
                var A = u_(D.formatTooltip(P, !0, null)), E = A.frag;
                if (E) {
                  var R = Vs([D], a).get("valueFormatter");
                  M.blocks.push(R ? Y({
                    valueFormatter: R
                  }, E) : E);
                }
                A.text && h.push(A.text), u.push(C);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var d = n.position, v = o.get("order"), g = v_(c, f, l, v, r.get("useUTC"), o.get("textStyle"));
      g && h.unshift(g);
      var p = l === "richText" ? `

` : "<br/>", m = h.join(p);
      this._showOrMove(o, function() {
        this._updateContentNotChangedOnAxis(i, u) ? this._updatePosition(o, d, s[0], s[1], this._tooltipContent, u) : this._showTooltipContent(o, m, u, Math.random() + "", s[0], s[1], d, null, f);
      });
    }, t.prototype._showSeriesItemTooltip = function(i, n, r) {
      var a = this._ecModel, s = Ft(n), o = s.seriesIndex, l = a.getSeriesByIndex(o), u = s.dataModel || l, c = s.dataIndex, h = s.dataType, f = u.getData(h), d = this._renderMode, v = i.positionDefault, g = Vs([f.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, v ? {
        position: v
      } : null), p = g.get("trigger");
      if (!(p != null && p !== "item")) {
        var m = u.getDataParams(c, h), y = new lf();
        m.marker = y.makeTooltipMarker("item", Oo(m.color), d);
        var _ = u_(u.formatTooltip(c, !1, h)), b = g.get("order"), x = g.get("valueFormatter"), w = _.frag, M = w ? v_(x ? Y({
          valueFormatter: x
        }, w) : w, y, d, b, a.get("useUTC"), g.get("textStyle")) : _.text, T = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, M, m, T, i.offsetX, i.offsetY, i.position, i.target, y);
        }), r({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: f.getRawIndex(c),
          seriesIndex: o,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(i, n, r) {
      var a = this._renderMode === "html", s = Ft(n), o = s.tooltipConfig, l = o.option || {}, u = l.encodeHTMLContent;
      if (Q(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = dt(l), l.content = Fe(l.content));
      var h = [l], f = this._ecModel.getComponent(s.componentMainType, s.componentIndex);
      f && h.push(f), h.push({
        formatter: l.content
      });
      var d = i.positionDefault, v = Vs(h, this._tooltipModel, d ? {
        position: d
      } : null), g = v.get("content"), p = Math.random() + "", m = new lf();
      this._showOrMove(v, function() {
        var y = dt(v.get("formatterParams") || {});
        this._showTooltipContent(v, g, y, p, i.offsetX, i.offsetY, i.position, n, m);
      }), r({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(i, n, r, a, s, o, l, u, c) {
      if (this._ticket = "", !(!i.get("showContent") || !i.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(i.get("enterable"));
        var f = i.get("formatter");
        l = l || i.get("position");
        var d = n, v = this._getNearestPoint([s, o], r, i.get("trigger"), i.get("borderColor"), i.get("defaultBorderColor", !0)), g = v.color;
        if (f)
          if (Q(f)) {
            var p = i.ecModel.get("useUTC"), m = j(r) ? r[0] : r, y = m && m.axisType && m.axisType.indexOf("time") >= 0;
            d = f, y && (d = gx(m.axisValue, d, p)), d = yx(d, r, !0);
          } else if (mt(f)) {
            var _ = Dt(function(b, x) {
              b === this._ticket && (h.setContent(x, c, i, g, l), this._updatePosition(i, l, s, o, h, r, u));
            }, this);
            this._ticket = a, d = f(r, a, _);
          } else
            d = f;
        h.setContent(d, c, i, g, l), h.show(i, g), this._updatePosition(i, l, s, o, h, r, u);
      }
    }, t.prototype._getNearestPoint = function(i, n, r, a, s) {
      if (r === "axis" || j(n))
        return {
          color: a || s
        };
      if (!j(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(i, n, r, a, s, o, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || i.get("position");
      var h = s.getSize(), f = i.get("align"), d = i.get("verticalAlign"), v = l && l.getBoundingRect().clone();
      if (l && v.applyTransform(l.transform), mt(n) && (n = n([r, a], o, s.el, v, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), j(n))
        r = ze(n[0], u), a = ze(n[1], c);
      else if (q(n)) {
        var g = n;
        g.width = h[0], g.height = h[1];
        var p = Qv(g, {
          width: u,
          height: c
        });
        r = p.x, a = p.y, f = null, d = null;
      } else if (Q(n) && l) {
        var m = QB(n, v, h, i.get("borderWidth"));
        r = m[0], a = m[1];
      } else {
        var m = ZB(r, a, s, u, c, f ? null : 20, d ? null : 20);
        r = m[0], a = m[1];
      }
      if (f && (r -= M0(f) ? h[0] / 2 : f === "right" ? h[0] : 0), d && (a -= M0(d) ? h[1] / 2 : d === "bottom" ? h[1] : 0), Uw(i)) {
        var m = KB(r, a, s, u, c);
        r = m[0], a = m[1];
      }
      s.moveTo(r, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(i, n) {
      var r = this._lastDataByCoordSys, a = this._cbParamsList, s = !!r && r.length === i.length;
      return s && k(r, function(o, l) {
        var u = o.dataByAxis || [], c = i[l] || {}, h = c.dataByAxis || [];
        s = s && u.length === h.length, s && k(u, function(f, d) {
          var v = h[d] || {}, g = f.seriesDataIndices || [], p = v.seriesDataIndices || [];
          s = s && f.value === v.value && f.axisType === v.axisType && f.axisId === v.axisId && g.length === p.length, s && k(g, function(m, y) {
            var _ = p[y];
            s = s && m.seriesIndex === _.seriesIndex && m.dataIndex === _.dataIndex;
          }), a && k(f.seriesDataIndices, function(m) {
            var y = m.seriesIndex, _ = n[y], b = a[y];
            _ && b && b.data !== _.data && (s = !1);
          });
        });
      }), this._lastDataByCoordSys = i, this._cbParamsList = n, !!s;
    }, t.prototype._hide = function(i) {
      this._lastDataByCoordSys = null, i({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(i, n) {
      rt.node || !n.getDom() || (Cd(this, "_updatePosition"), this._tooltipContent.dispose(), zd("itemTooltip", n));
    }, t.type = "tooltip", t;
  })(Mn)
);
function Vs(e, t, i) {
  var n = t.ecModel, r;
  i ? (r = new Gt(i, n, n), r = new Gt(t.option, r, n)) : r = t;
  for (var a = e.length - 1; a >= 0; a--) {
    var s = e[a];
    s && (s instanceof Gt && (s = s.get("tooltip", !0)), Q(s) && (s = {
      formatter: s
    }), s && (r = new Gt(s, r, n)));
  }
  return r;
}
function S0(e, t) {
  return e.dispatchAction || Dt(t.dispatchAction, t);
}
function ZB(e, t, i, n, r, a, s) {
  var o = i.getSize(), l = o[0], u = o[1];
  return a != null && (e + l + a + 2 > n ? e -= l + a : e += a), s != null && (t + u + s > r ? t -= u + s : t += s), [e, t];
}
function KB(e, t, i, n, r) {
  var a = i.getSize(), s = a[0], o = a[1];
  return e = Math.min(e + s, n) - s, t = Math.min(t + o, r) - o, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function QB(e, t, i, n) {
  var r = i[0], a = i[1], s = Math.ceil(Math.SQRT2 * n) + 8, o = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      o = t.x + u / 2 - r / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      o = t.x + u / 2 - r / 2, l = t.y - a - s;
      break;
    case "bottom":
      o = t.x + u / 2 - r / 2, l = t.y + c + s;
      break;
    case "left":
      o = t.x - r - s, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      o = t.x + u + s, l = t.y + c / 2 - a / 2;
  }
  return [o, l];
}
function M0(e) {
  return e === "center" || e === "middle";
}
function JB(e, t, i) {
  var n = Tv(e).queryOptionMap, r = n.keys()[0];
  if (!(!r || r === "series")) {
    var a = jo(t, r, n.get(r), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), s = a.models[0];
    if (s) {
      var o = i.getViewOfComponentModel(s), l;
      if (o.group.traverse(function(u) {
        var c = Ft(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: r,
          componentIndex: s.componentIndex,
          el: l
        };
    }
  }
}
function t3(e) {
  cp(SB), e.registerComponentModel(NB), e.registerComponentView(qB), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, be), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, be);
}
var Bo = k, e3 = q, rc = -1, gp = (
  /** @class */
  (function() {
    function e(t) {
      var i = t.mappingMethod, n = t.type, r = this.option = dt(t);
      this.type = n, this.mappingMethod = i, this._normalizeData = r3[i];
      var a = e.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[i], i === "piecewise" ? (Mf(r), i3(r)) : i === "category" ? r.categories ? n3(r) : Mf(r, !0) : (tt(i !== "linear" || r.dataExtent), Mf(r));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var i = this._normalizeData(t);
      return this._normalizedToVisual(i, t);
    }, e.prototype.getNormalizer = function() {
      return Dt(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return jt(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, i, n) {
      q(t) ? k(t, i, n) : i.call(n, t);
    }, e.mapVisual = function(t, i, n) {
      var r, a = j(t) ? [] : q(t) ? {} : (r = !0, null);
      return e.eachVisual(t, function(s, o) {
        var l = i.call(n, s, o);
        r ? a = l : a[o] = l;
      }), a;
    }, e.retrieveVisuals = function(t) {
      var i = {}, n;
      return t && Bo(e.visualHandlers, function(r, a) {
        t.hasOwnProperty(a) && (i[a] = t[a], n = !0);
      }), n ? i : null;
    }, e.prepareVisualTypes = function(t) {
      if (j(t))
        t = t.slice();
      else if (e3(t)) {
        var i = [];
        Bo(t, function(n, r) {
          i.push(r);
        }), t = i;
      } else
        return [];
      return t.sort(function(n, r) {
        return r === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, i) {
      return i === "color" ? !!(t && t.indexOf(i) === 0) : t === i;
    }, e.findPieceIndex = function(t, i, n) {
      for (var r, a = 1 / 0, s = 0, o = i.length; s < o; s++) {
        var l = i[s].value;
        if (l != null) {
          if (l === t || Q(l) && l === t + "")
            return s;
          n && f(l, s);
        }
      }
      for (var s = 0, o = i.length; s < o; s++) {
        var u = i[s], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (jl(h[1], t, c[1]))
              return s;
          } else if (c[1] === 1 / 0) {
            if (jl(h[0], c[0], t))
              return s;
          } else if (jl(h[0], c[0], t) && jl(h[1], t, c[1]))
            return s;
          n && f(c[0], s), n && f(c[1], s);
        }
      }
      if (n)
        return t === 1 / 0 ? i.length - 1 : t === -1 / 0 ? 0 : r;
      function f(d, v) {
        var g = Math.abs(d - t);
        g < a && (a = g, r = v);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: $s("color"),
        getColorMapper: function() {
          var t = this.option;
          return Dt(t.mappingMethod === "category" ? function(i, n) {
            return !n && (i = this._normalizeData(i)), io.call(this, i);
          } : function(i, n, r) {
            var a = !!r;
            return !n && (i = this._normalizeData(i)), r = _h(i, t.parsedVisual, r), a ? r : Zr(r, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return Zr(_h(t, this.option.parsedVisual), "rgba");
          },
          category: io,
          piecewise: function(t, i) {
            var n = $d.call(this, i);
            return n == null && (n = Zr(_h(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: Rr
        }
      },
      colorHue: Gl(function(t, i) {
        return ja(t, i);
      }),
      colorSaturation: Gl(function(t, i) {
        return ja(t, null, i);
      }),
      colorLightness: Gl(function(t, i) {
        return ja(t, null, null, i);
      }),
      colorAlpha: Gl(function(t, i) {
        return iE(t, i);
      }),
      decal: {
        applyVisual: $s("decal"),
        _normalizedToVisual: {
          linear: null,
          category: io,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: $s("opacity"),
        _normalizedToVisual: Vd([0, 1])
      },
      liftZ: {
        applyVisual: $s("liftZ"),
        _normalizedToVisual: {
          linear: Rr,
          category: Rr,
          piecewise: Rr,
          fixed: Rr
        }
      },
      symbol: {
        applyVisual: function(t, i, n) {
          var r = this.mapValueToVisual(t);
          n("symbol", r);
        },
        _normalizedToVisual: {
          linear: T0,
          category: io,
          piecewise: function(t, i) {
            var n = $d.call(this, i);
            return n == null && (n = T0.call(this, t)), n;
          },
          fixed: Rr
        }
      },
      symbolSize: {
        applyVisual: $s("symbolSize"),
        _normalizedToVisual: Vd([0, 1])
      }
    }, e;
  })()
);
function i3(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, k(t, function(i, n) {
    i.originIndex = n, i.visual != null && (e.hasSpecialVisual = !0);
  });
}
function n3(e) {
  var t = e.categories, i = e.categoryMap = {}, n = e.visual;
  if (Bo(t, function(s, o) {
    i[s] = o;
  }), !j(n)) {
    var r = [];
    q(n) ? Bo(n, function(s, o) {
      var l = i[o];
      r[l ?? rc] = s;
    }) : r[rc] = n, n = qw(e, r);
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete i[t[a]], t.pop());
}
function Mf(e, t) {
  var i = e.visual, n = [];
  q(i) ? Bo(i, function(a) {
    n.push(a);
  }) : i != null && n.push(i);
  var r = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !r.hasOwnProperty(e.type) && (n[1] = n[0]), qw(e, n);
}
function Gl(e) {
  return {
    applyVisual: function(t, i, n) {
      var r = this.mapValueToVisual(t);
      n("color", e(i("color"), r));
    },
    _normalizedToVisual: Vd([0, 1])
  };
}
function T0(e) {
  var t = this.option.visual;
  return t[Math.round(Po(e, [0, 1], [0, t.length - 1]))] || {};
}
function $s(e) {
  return function(t, i, n) {
    n(e, this.mapValueToVisual(t));
  };
}
function io(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== rc ? e % t.length : e];
}
function Rr() {
  return this.option.visual[0];
}
function Vd(e) {
  return {
    linear: function(t) {
      return Po(t, e, this.option.visual);
    },
    category: io,
    piecewise: function(t, i) {
      var n = $d.call(this, i);
      return n == null && (n = Po(t, e, this.option.visual)), n;
    },
    fixed: Rr
  };
}
function $d(e) {
  var t = this.option, i = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = gp.findPieceIndex(e, i), r = i[n];
    if (r && r.visual)
      return r.visual[this.type];
  }
}
function qw(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = bt(t, function(i) {
    var n = yn(i);
    return !n && process.env.NODE_ENV !== "production" && oi("'" + i + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var r3 = {
  linear: function(e) {
    return Po(e, this.option.dataExtent, [0, 1]);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, i = gp.findPieceIndex(e, t, !0);
    if (i != null)
      return Po(i, [0, t.length - 1], [0, 1]);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? rc;
  },
  fixed: be
};
function jl(e, t, i) {
  return e ? t <= i : t < i;
}
var a3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, i;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: St.size.m,
      backgroundColor: St.color.transparent,
      borderColor: St.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: St.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: St.color.quaternary
      }
    }, t;
  })(Pt)
), s3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      if (this.group.removeAll(), !!i.get("show")) {
        var a = this.group, s = i.getModel("textStyle"), o = i.getModel("subtextStyle"), l = i.get("textAlign"), u = et(i.get("textBaseline"), i.get("textVerticalAlign")), c = new vi({
          style: ra(s, {
            text: i.get("text"),
            fill: s.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), f = i.get("subtext"), d = new vi({
          style: ra(o, {
            text: f,
            fill: o.getTextColor(),
            y: h.height + i.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), v = i.get("link"), g = i.get("sublink"), p = i.get("triggerEvent", !0);
        c.silent = !v && !p, d.silent = !g && !p, v && c.on("click", function() {
          Yy(v, "_" + i.get("target"));
        }), g && d.on("click", function() {
          Yy(g, "_" + i.get("subtarget"));
        }), Ft(c).eventData = Ft(d).eventData = p ? {
          componentType: "title",
          componentIndex: i.componentIndex
        } : null, a.add(c), f && a.add(d);
        var m = a.getBoundingRect(), y = i.getBoxLayoutParams();
        y.width = m.width, y.height = m.height;
        var _ = bx(i, r), b = Qv(y, _.refContainer, i.get("padding"));
        l || (l = i.get("left") || i.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = i.get("top") || i.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), a.x = b.x, a.y = b.y, a.markRedraw();
        var x = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(x), d.setStyle(x), m = a.getBoundingRect();
        var w = b.margin, M = i.getItemStyle(["color", "opacity"]);
        M.fill = i.get("backgroundColor");
        var T = new xe({
          shape: {
            x: m.x - w[3],
            y: m.y - w[0],
            width: m.width + w[1] + w[3],
            height: m.height + w[0] + w[2],
            r: i.get("borderRadius")
          },
          style: M,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(T);
      }
    }, t.type = "title", t;
  })(Mn)
);
function o3(e) {
  e.registerComponentModel(a3), e.registerComponentView(s3);
}
var fi = Wt();
function l3(e) {
  var t = e.mainData, i = e.datas;
  i || (i = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, Zw(t, i, e), k(i, function(n) {
    k(t.TRANSFERABLE_METHODS, function(r) {
      n.wrapMethod(r, Ae(u3, e));
    });
  }), t.wrapMethod("cloneShallow", Ae(h3, e)), k(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, Ae(c3, e));
  }), tt(i[t.dataType] === t);
}
function u3(e, t) {
  if (v3(this)) {
    var i = Y({}, fi(this).datas);
    i[this.dataType] = t, Zw(t, i, e);
  } else
    mp(t, this.dataType, fi(this).mainData, e);
  return t;
}
function c3(e, t) {
  return e.struct && e.struct.update(), t;
}
function h3(e, t) {
  return k(fi(t).datas, function(i, n) {
    i !== t && mp(i.cloneShallow(), n, t, e);
  }), t;
}
function f3(e) {
  var t = fi(this).mainData;
  return e == null || t == null ? t : fi(t).datas[e];
}
function d3() {
  var e = fi(this).mainData;
  return e == null ? [{
    data: e
  }] : bt(jt(fi(e).datas), function(t) {
    return {
      type: t,
      data: fi(e).datas[t]
    };
  });
}
function v3(e) {
  return fi(e).mainData === e;
}
function Zw(e, t, i) {
  fi(e).datas = {}, k(t, function(n, r) {
    mp(n, r, e, i);
  });
}
function mp(e, t, i, n) {
  fi(i).datas[t] = e, fi(e).mainData = i, e.dataType = t, n.struct && (e[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = e), e.getLinkedData = f3, e.getLinkedDataAll = d3;
}
function La(e) {
  return "_EC_" + e;
}
var p3 = (
  /** @class */
  (function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, i) {
      t = t == null ? "" + i : "" + t;
      var n = this._nodesMap;
      if (n[La(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var r = new Nr(t, i);
      return r.hostGraph = this, this.nodes.push(r), n[La(t)] = r, r;
    }, e.prototype.getNodeByIndex = function(t) {
      var i = this.data.getRawIndex(t);
      return this.nodes[i];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[La(t)];
    }, e.prototype.addEdge = function(t, i, n) {
      var r = this._nodesMap, a = this._edgesMap;
      if (Xt(t) && (t = this.nodes[t]), Xt(i) && (i = this.nodes[i]), t instanceof Nr || (t = r[La(t)]), i instanceof Nr || (i = r[La(i)]), !(!t || !i)) {
        var s = t.id + "-" + i.id, o = new Kw(t, i, n);
        return o.hostGraph = this, this._directed && (t.outEdges.push(o), i.inEdges.push(o)), t.edges.push(o), t !== i && i.edges.push(o), this.edges.push(o), a[s] = o, o;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var i = this.edgeData.getRawIndex(t);
      return this.edges[i];
    }, e.prototype.getEdge = function(t, i) {
      t instanceof Nr && (t = t.id), i instanceof Nr && (i = i.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + i] : n[t + "-" + i] || n[i + "-" + t];
    }, e.prototype.eachNode = function(t, i) {
      for (var n = this.nodes, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.eachEdge = function(t, i) {
      for (var n = this.edges, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.breadthFirstTraverse = function(t, i, n, r) {
      if (i instanceof Nr || (i = this._nodesMap[La(i)]), !!i) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++)
          this.nodes[s].__visited = !1;
        if (!t.call(r, i, null))
          for (var o = [i]; o.length; )
            for (var l = o.shift(), u = l[a], s = 0; s < u.length; s++) {
              var c = u[s], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (t.call(r, h, l))
                  return;
                o.push(h), h.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, i = this.edgeData, n = this.nodes, r = this.edges, a = 0, s = n.length; a < s; a++)
        n[a].dataIndex = -1;
      for (var a = 0, s = t.count(); a < s; a++)
        n[t.getRawIndex(a)].dataIndex = a;
      i.filterSelf(function(o) {
        var l = r[i.getRawIndex(o)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, s = r.length; a < s; a++)
        r[a].dataIndex = -1;
      for (var a = 0, s = i.count(); a < s; a++)
        r[i.getRawIndex(a)].dataIndex = a;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), i = this.nodes, n = this.edges, r = 0; r < i.length; r++)
        t.addNode(i[r].id, i[r].dataIndex);
      for (var r = 0; r < n.length; r++) {
        var a = n[r];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, e;
  })()
), Nr = (
  /** @class */
  (function() {
    function e(t, i) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = i ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, i = 0; i < this.edges.length; i++) {
        var n = this.edges[i];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = lt(), i = lt(), n = 0, r = this.edges.length; n < r; n++) {
        var a = this.edges[n];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var s = [a.node1], o = [a.node2], l = 0; l < s.length; ) {
            var u = s[l];
            l++, i.set(u.dataIndex, !0);
            for (var c = u.inEdges, h = 0, f = c.length, d = void 0, v = void 0; h < f; h++)
              d = c[h], v = d.dataIndex, v >= 0 && !t.hasKey(v) && (t.set(v, !0), s.push(d.node1));
          }
          for (l = 0; l < o.length; ) {
            var g = o[l];
            l++, i.set(g.dataIndex, !0);
            for (var p = g.outEdges, h = 0, m = p.length, y = void 0, _ = void 0; h < m; h++)
              y = p[h], _ = y.dataIndex, _ >= 0 && !t.hasKey(_) && (t.set(_, !0), o.push(y.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
), Kw = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = i, this.dataIndex = n ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = lt(), i = lt();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], r = [this.node2], a = 0; a < n.length; ) {
        var s = n[a];
        a++, i.set(s.dataIndex, !0);
        for (var o = s.inEdges, l = 0, u = o.length, c = void 0, h = void 0; l < u; l++)
          c = s.inEdges[l], h = c.dataIndex, h >= 0 && !t.hasKey(h) && (t.set(h, !0), n.push(c.node1));
      }
      for (a = 0; a < r.length; ) {
        var f = r[a];
        a++, i.set(f.dataIndex, !0);
        for (var d = f.outEdges, l = 0, u = d.length, v = void 0, g = void 0; l < u; l++)
          v = f.outEdges[l], g = v.dataIndex, g >= 0 && !t.hasKey(g) && (t.set(g, !0), r.push(v.node2));
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
);
function Qw(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(i) {
      var n = this[e][t];
      return n.getStore().get(n.getDimensionIndex(i || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, i, n);
    },
    getVisual: function(i) {
      return this[e][t].getItemVisual(this.dataIndex, i);
    },
    setLayout: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, i, n);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
Ci(Nr, Qw("hostGraph", "data"));
Ci(Kw, Qw("hostGraph", "edgeData"));
function g3(e, t, i, n, r) {
  for (var a = new p3(n), s = 0; s < e.length; s++)
    a.addNode(Jn(
      // Id, name, dataIndex
      e[s].id,
      e[s].name,
      s
    ), s);
  for (var o = [], l = [], u = 0, s = 0; s < t.length; s++) {
    var c = t[s], h = c.source, f = c.target;
    a.addEdge(h, f, u) && (l.push(c), o.push(Jn(Si(c.id, null), h + " > " + f)), u++);
  }
  var d = i.get("coordinateSystem"), v;
  if (d === "cartesian2d" || d === "polar" || d === "matrix")
    v = dF(e, i);
  else {
    var g = Oc.get(d), p = g ? g.dimensions || [] : [];
    Bt(p, "value") < 0 && p.concat(["value"]);
    var m = Ew(e, {
      coordDimensions: p,
      encodeDefine: i.getEncode()
    }).dimensions;
    v = new Nd(m, i), v.initData(e);
  }
  var y = new Nd(["value"], i);
  return y.initData(l, o), r && r(v, y), l3({
    mainData: v,
    struct: a,
    structAttr: "graph",
    datas: {
      node: v,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var m3 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  })()
), y3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(i) {
      return e.call(this, i) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new m3();
    }, t.prototype.buildPath = function(i, n) {
      var r = n.extent;
      i.moveTo(n.x1, n.y1), i.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (i.lineTo(n.x2 + r, n.y2), i.bezierCurveTo(n.cpx2 + r, n.cpy2, n.cpx1 + r, n.cpy1, n.x1 + r, n.y1)) : (i.lineTo(n.x2, n.y2 + r), i.bezierCurveTo(n.cpx2, n.cpy2 + r, n.cpx1, n.cpy1 + r, n.x1, n.y1 + r)), i.closePath();
    }, t.prototype.highlight = function() {
      Bu(this);
    }, t.prototype.downplay = function() {
      zu(this);
    }, t;
  })(It)
), _3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i._mainGroup = new Mi(), i._focusAdjacencyDisabled = !1, i;
    }
    return t.prototype.init = function(i, n) {
      this._controller = new LB(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(i, n, r) {
      var a = this, s = i.getGraph(), o = this._mainGroup, l = i.layoutInfo, u = l.width, c = l.height, h = i.getData(), f = i.getData("edge"), d = i.get("orient");
      this._model = i, o.removeAll(), o.x = l.x, o.y = l.y, this._updateViewCoordSys(i, r), DB(i, r, o, this._controller, this._controllerHost), s.eachEdge(function(v) {
        var g = new y3(), p = Ft(g);
        p.dataIndex = v.dataIndex, p.seriesIndex = i.seriesIndex, p.dataType = "edge";
        var m = v.getModel(), y = m.getModel("lineStyle"), _ = y.get("curveness"), b = v.node1.getLayout(), x = v.node1.getModel(), w = x.get("localX"), M = x.get("localY"), T = v.node2.getLayout(), D = v.node2.getModel(), P = D.get("localX"), C = D.get("localY"), A = v.getLayout(), E, R, I, N, B, $, H, G;
        g.shape.extent = Math.max(1, A.dy), g.shape.orient = d, d === "vertical" ? (E = (w != null ? w * u : b.x) + A.sy, R = (M != null ? M * c : b.y) + b.dy, I = (P != null ? P * u : T.x) + A.ty, N = C != null ? C * c : T.y, B = E, $ = R * (1 - _) + N * _, H = I, G = R * _ + N * (1 - _)) : (E = (w != null ? w * u : b.x) + b.dx, R = (M != null ? M * c : b.y) + A.sy, I = P != null ? P * u : T.x, N = (C != null ? C * c : T.y) + A.ty, B = E * (1 - _) + I * _, $ = R, H = E * _ + I * (1 - _), G = N), g.setShape({
          x1: E,
          y1: R,
          x2: I,
          y2: N,
          cpx1: B,
          cpy1: $,
          cpx2: H,
          cpy2: G
        }), g.useStyle(y.getItemStyle()), D0(g.style, d, v);
        var nt = "" + m.get("value"), K = Ny(m, "edgeLabel");
        Ry(g, K, {
          labelFetcher: {
            getFormattedLabel: function(Ht, ht, le, De, de, Zt) {
              return i.getFormattedLabel(
                Ht,
                ht,
                "edge",
                De,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Xr(de, K.normal && K.normal.get("formatter"), nt),
                Zt
              );
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: nt
        }), g.setTextConfig({
          position: "inside"
        });
        var pt = m.getModel("emphasis");
        Sy(g, m, "lineStyle", function(Ht) {
          var ht = Ht.getItemStyle();
          return D0(ht, d, v), ht;
        }), o.add(g), f.setItemGraphicEl(v.dataIndex, g);
        var gt = pt.get("focus");
        xy(g, gt === "adjacency" ? v.getAdjacentDataIndices() : gt === "trajectory" ? v.getTrajectoryDataIndices() : gt, pt.get("blurScope"), pt.get("disabled"));
      }), s.eachNode(function(v) {
        var g = v.getLayout(), p = v.getModel(), m = p.get("localX"), y = p.get("localY"), _ = p.getModel("emphasis"), b = p.get(["itemStyle", "borderRadius"]) || 0, x = new xe({
          shape: {
            x: m != null ? m * u : g.x,
            y: y != null ? y * c : g.y,
            width: g.dx,
            height: g.dy,
            r: b
          },
          style: p.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Ry(x, Ny(p), {
          labelFetcher: {
            getFormattedLabel: function(M, T) {
              return i.getFormattedLabel(M, T, "node");
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: v.id
        }), x.disableLabelAnimation = !0, x.setStyle("fill", v.getVisual("color")), x.setStyle("decal", v.getVisual("style").decal), Sy(x, p), o.add(x), h.setItemGraphicEl(v.dataIndex, x), Ft(x).dataType = "node";
        var w = _.get("focus");
        xy(x, w === "adjacency" ? v.getAdjacentDataIndices() : w === "trajectory" ? v.getTrajectoryDataIndices() : w, _.get("blurScope"), _.get("disabled"));
      }), h.eachItemGraphicEl(function(v, g) {
        var p = h.getItemModel(g);
        p.get("draggable") && (v.drift = function(m, y) {
          a._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += y, this.dirty(), r.dispatchAction({
            type: "dragNode",
            seriesId: i.id,
            dataIndex: h.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, v.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, v.draggable = !0, v.cursor = "move");
      }), !this._data && i.isAnimationEnabled() && o.setClipPath(b3(o.getBoundingRect(), i, function() {
        o.removeClipPath();
      })), this._data = i.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(i, n) {
      var r = i.layoutInfo, a = r.width, s = r.height, o = i.coordinateSystem = new kB(null, {
        api: n,
        ecModel: i.ecModel
      });
      o.zoomLimit = i.get("scaleLimit"), o.setBoundingRect(0, 0, a, s), o.setCenter(i.get("center")), o.setZoom(i.get("zoom")), this._controllerHost.target.attr({
        x: o.x,
        y: o.y,
        scaleX: o.scaleX,
        scaleY: o.scaleY
      });
    }, t.type = "sankey", t;
  })(Xn)
);
function D0(e, t, i) {
  switch (e.fill) {
    case "source":
      e.fill = i.node1.getVisual("color"), e.decal = i.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = i.node2.getVisual("color"), e.decal = i.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = i.node1.getVisual("color"), r = i.node2.getVisual("color");
      Q(n) && Q(r) && (e.fill = new tx(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: r,
        offset: 1
      }]));
  }
}
function b3(e, t, i) {
  var n = new xe({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return ix(n, {
    shape: {
      width: e.width + 20
    }
  }, t, i), n;
}
var x3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.getInitialData = function(i, n) {
      var r = i.edges || i.links || [], a = i.data || i.nodes || [], s = i.levels || [];
      this.levelModels = [];
      for (var o = this.levelModels, l = 0; l < s.length; l++)
        if (s[l].depth != null && s[l].depth >= 0)
          o[s[l].depth] = new Gt(s[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = g3(a, r, this, !0, c);
      return u.data;
      function c(h, f) {
        h.wrapMethod("getItemModel", function(d, v) {
          var g = d.parentModel, p = g.getData().getItemLayout(v);
          if (p) {
            var m = p.depth, y = g.levelModels[m];
            y && (d.parentModel = y);
          }
          return d;
        }), f.wrapMethod("getItemModel", function(d, v) {
          var g = d.parentModel, p = g.getGraph().getEdgeByIndex(v), m = p.node1.getLayout();
          if (m) {
            var y = m.depth, _ = g.levelModels[y];
            _ && (d.parentModel = _);
          }
          return d;
        });
      }
    }, t.prototype.setNodePosition = function(i, n) {
      var r = this.option.data || this.option.nodes, a = r[i];
      a.localX = n[0], a.localY = n[1];
    }, t.prototype.setCenter = function(i) {
      this.option.center = i;
    }, t.prototype.setZoom = function(i) {
      this.option.zoom = i;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(i, n, r) {
      function a(d) {
        return isNaN(d) || d == null;
      }
      if (r === "edge") {
        var s = this.getDataParams(i, r), o = s.data, l = s.value, u = o.source + " -- " + o.target;
        return aa("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(i), h = c.getLayout().value, f = this.getDataParams(i, r).data.name;
        return aa("nameValue", {
          name: f != null ? f + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(i, n) {
      var r = e.prototype.getDataParams.call(this, i, n);
      if (r.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(i), s = a.getLayout().value;
        r.value = s;
      }
      return r;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: St.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: St.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  })(er)
);
function w3(e, t) {
  e.eachSeriesByType("sankey", function(i) {
    var n = i.get("nodeWidth"), r = i.get("nodeGap"), a = bx(i, t).refContainer, s = Qv(i.getBoxLayoutParams(), a);
    i.layoutInfo = s;
    var o = s.width, l = s.height, u = i.getGraph(), c = u.nodes, h = u.edges;
    M3(c);
    var f = je(c, function(p) {
      return p.getLayout().value === 0;
    }), d = f.length !== 0 ? 0 : i.get("layoutIterations"), v = i.get("orient"), g = i.get("nodeAlign");
    S3(c, h, n, r, o, l, d, v, g);
  });
}
function S3(e, t, i, n, r, a, s, o, l) {
  T3(e, t, i, r, a, o, l), P3(e, t, a, r, n, s, o), B3(e, o);
}
function M3(e) {
  k(e, function(t) {
    var i = qn(t.outEdges, ac), n = qn(t.inEdges, ac), r = t.getValue() || 0, a = Math.max(i, n, r);
    t.setLayout({
      value: a
    }, !0);
  });
}
function T3(e, t, i, n, r, a, s) {
  for (var o = [], l = [], u = [], c = [], h = 0, f = 0; f < t.length; f++)
    o[f] = 1;
  for (var f = 0; f < e.length; f++)
    l[f] = e[f].inEdges.length, l[f] === 0 && u.push(e[f]);
  for (var d = -1; u.length; ) {
    for (var v = 0; v < u.length; v++) {
      var g = u[v], p = g.hostGraph.data.getRawDataItem(g.dataIndex), m = p.depth != null && p.depth >= 0;
      m && p.depth > d && (d = p.depth), g.setLayout({
        depth: m ? p.depth : h
      }, !0), a === "vertical" ? g.setLayout({
        dy: i
      }, !0) : g.setLayout({
        dx: i
      }, !0);
      for (var y = 0; y < g.outEdges.length; y++) {
        var _ = g.outEdges[y], b = t.indexOf(_);
        o[b] = 0;
        var x = _.node2, w = e.indexOf(x);
        --l[w] === 0 && c.indexOf(x) < 0 && c.push(x);
      }
    }
    ++h, u = c, c = [];
  }
  for (var f = 0; f < o.length; f++)
    if (o[f] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var M = d > h - 1 ? d : h - 1;
  s && s !== "left" && D3(e, s, a, M);
  var T = a === "vertical" ? (r - i) / M : (n - i) / M;
  k3(e, T, a);
}
function Jw(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function D3(e, t, i, n) {
  if (t === "right") {
    for (var r = [], a = e, s = 0; a.length; ) {
      for (var o = 0; o < a.length; o++) {
        var l = a[o];
        l.setLayout({
          skNodeHeight: s
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          r.indexOf(c.node1) < 0 && r.push(c.node1);
        }
      }
      a = r, r = [], ++s;
    }
    k(e, function(h) {
      Jw(h) || h.setLayout({
        depth: Math.max(0, n - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && C3(e, n);
}
function C3(e, t) {
  k(e, function(i) {
    !Jw(i) && !i.outEdges.length && i.setLayout({
      depth: t
    }, !0);
  });
}
function k3(e, t, i) {
  k(e, function(n) {
    var r = n.getLayout().depth * t;
    i === "vertical" ? n.setLayout({
      y: r
    }, !0) : n.setLayout({
      x: r
    }, !0);
  });
}
function P3(e, t, i, n, r, a, s) {
  var o = A3(e, s);
  E3(o, t, i, n, r, s), Tf(o, r, i, n, s);
  for (var l = 1; a > 0; a--)
    l *= 0.99, L3(o, l, s), Tf(o, r, i, n, s), F3(o, l, s), Tf(o, r, i, n, s);
}
function A3(e, t) {
  var i = [], n = t === "vertical" ? "y" : "x", r = eL(e, function(a) {
    return a.getLayout()[n];
  });
  return r.keys.sort(function(a, s) {
    return a - s;
  }), k(r.keys, function(a) {
    i.push(r.buckets.get(a));
  }), i;
}
function E3(e, t, i, n, r, a) {
  var s = 1 / 0;
  k(e, function(o) {
    var l = o.length, u = 0;
    k(o, function(h) {
      u += h.getLayout().value;
    });
    var c = a === "vertical" ? (n - (l - 1) * r) / u : (i - (l - 1) * r) / u;
    c < s && (s = c);
  }), k(e, function(o) {
    k(o, function(l, u) {
      var c = l.getLayout().value * s;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), k(t, function(o) {
    var l = +o.getValue() * s;
    o.setLayout({
      dy: l
    }, !0);
  });
}
function Tf(e, t, i, n, r) {
  var a = r === "vertical" ? "x" : "y";
  k(e, function(s) {
    s.sort(function(g, p) {
      return g.getLayout()[a] - p.getLayout()[a];
    });
    for (var o, l, u, c = 0, h = s.length, f = r === "vertical" ? "dx" : "dy", d = 0; d < h; d++)
      l = s[d], u = c - l.getLayout()[a], u > 0 && (o = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({
        x: o
      }, !0) : l.setLayout({
        y: o
      }, !0)), c = l.getLayout()[a] + l.getLayout()[f] + t;
    var v = r === "vertical" ? n : i;
    if (u = c - t - v, u > 0) {
      o = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
        x: o
      }, !0) : l.setLayout({
        y: o
      }, !0), c = o;
      for (var d = h - 2; d >= 0; --d)
        l = s[d], u = l.getLayout()[a] + l.getLayout()[f] + t - c, u > 0 && (o = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
          x: o
        }, !0) : l.setLayout({
          y: o
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function L3(e, t, i) {
  k(e.slice().reverse(), function(n) {
    k(n, function(r) {
      if (r.outEdges.length) {
        var a = qn(r.outEdges, O3, i) / qn(r.outEdges, ac);
        if (isNaN(a)) {
          var s = r.outEdges.length;
          a = s ? qn(r.outEdges, I3, i) / s : 0;
        }
        if (i === "vertical") {
          var o = r.getLayout().x + (a - nr(r, i)) * t;
          r.setLayout({
            x: o
          }, !0);
        } else {
          var l = r.getLayout().y + (a - nr(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function O3(e, t) {
  return nr(e.node2, t) * e.getValue();
}
function I3(e, t) {
  return nr(e.node2, t);
}
function R3(e, t) {
  return nr(e.node1, t) * e.getValue();
}
function N3(e, t) {
  return nr(e.node1, t);
}
function nr(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function ac(e) {
  return e.getValue();
}
function qn(e, t, i) {
  for (var n = 0, r = e.length, a = -1; ++a < r; ) {
    var s = +t(e[a], i);
    isNaN(s) || (n += s);
  }
  return n;
}
function F3(e, t, i) {
  k(e, function(n) {
    k(n, function(r) {
      if (r.inEdges.length) {
        var a = qn(r.inEdges, R3, i) / qn(r.inEdges, ac);
        if (isNaN(a)) {
          var s = r.inEdges.length;
          a = s ? qn(r.inEdges, N3, i) / s : 0;
        }
        if (i === "vertical") {
          var o = r.getLayout().x + (a - nr(r, i)) * t;
          r.setLayout({
            x: o
          }, !0);
        } else {
          var l = r.getLayout().y + (a - nr(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function B3(e, t) {
  var i = t === "vertical" ? "x" : "y";
  k(e, function(n) {
    n.outEdges.sort(function(r, a) {
      return r.node2.getLayout()[i] - a.node2.getLayout()[i];
    }), n.inEdges.sort(function(r, a) {
      return r.node1.getLayout()[i] - a.node1.getLayout()[i];
    });
  }), k(e, function(n) {
    var r = 0, a = 0;
    k(n.outEdges, function(s) {
      s.setLayout({
        sy: r
      }, !0), r += s.getLayout().dy;
    }), k(n.inEdges, function(s) {
      s.setLayout({
        ty: a
      }, !0), a += s.getLayout().dy;
    });
  });
}
function z3(e) {
  e.eachSeriesByType("sankey", function(t) {
    var i = t.getGraph(), n = i.nodes, r = i.edges;
    if (n.length) {
      var a = 1 / 0, s = -1 / 0;
      k(n, function(o) {
        var l = o.getLayout().value;
        l < a && (a = l), l > s && (s = l);
      }), k(n, function(o) {
        var l = new gp({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, s],
          visual: t.get("color")
        }), u = l.mapValueToVisual(o.getLayout().value), c = o.getModel().get(["itemStyle", "color"]);
        c != null ? (o.setVisual("color", c), o.setVisual("style", {
          fill: c
        })) : (o.setVisual("color", u), o.setVisual("style", {
          fill: u
        }));
      });
    }
    r.length && k(r, function(o) {
      var l = o.getModel().get("lineStyle");
      o.setVisual("style", l);
    });
  });
}
function V3(e) {
  e.registerChartView(_3), e.registerSeriesModel(x3), e.registerLayout(w3), e.registerVisual(z3), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, i) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), e.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, i, n) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(r) {
      var a = r.coordinateSystem, s = CB(a, t, r.get("scaleLimit"));
      r.setCenter(s.center), r.setZoom(s.zoom);
    });
  });
}
function C0(e, t, i) {
  var n = wn.createCanvas(), r = t.getWidth(), a = t.getHeight(), s = n.style;
  return s && (s.position = "absolute", s.left = "0", s.top = "0", s.width = r + "px", s.height = a + "px", n.setAttribute("data-zr-dom-id", e)), n.width = r * i, n.height = a * i, n;
}
var Df = (function(e) {
  At(t, e);
  function t(i, n, r) {
    var a = e.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var s;
    r = r || Eu, typeof i == "string" ? s = C0(i, n, r) : q(i) && (s = i, i = s.id), a.id = i, a.dom = s;
    var o = s.style;
    return o && (qb(s), s.onselectstart = function() {
      return !1;
    }, o.padding = "0", o.margin = "0", o.borderWidth = "0"), a.painter = n, a.dpr = r, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var i = this.dpr;
    this.domBack = C0("back-" + this.id, this.painter, i), this.ctxBack = this.domBack.getContext("2d"), i !== 1 && this.ctxBack.scale(i, i);
  }, t.prototype.createRepaintRects = function(i, n, r, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var s = [], o = this.maxRepaintRectCount, l = !1, u = new at(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (s.length === 0) {
          var _ = new at(0, 0, 0, 0);
          _.copy(y), s.push(_);
        } else {
          for (var b = !1, x = 1 / 0, w = 0, M = 0; M < s.length; ++M) {
            var T = s[M];
            if (T.intersect(y)) {
              var D = new at(0, 0, 0, 0);
              D.copy(T), D.union(y), s[M] = D, b = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(T);
              var P = y.width * y.height, C = T.width * T.height, A = u.width * u.height, E = A - P - C;
              E < x && (x = E, w = M);
            }
          }
          if (l && (s[w].union(y), b = !0), !b) {
            var _ = new at(0, 0, 0, 0);
            _.copy(y), s.push(_);
          }
          l || (l = s.length >= o);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var f = i[h];
      if (f) {
        var d = f.shouldBePainted(r, a, !0, !0), v = f.__isRendered && (f.__dirty & Xe || !d) ? f.getPrevPaintRect() : null;
        v && c(v);
        var g = d && (f.__dirty & Xe || !f.__isRendered) ? f.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var f = n[h], d = f && f.shouldBePainted(r, a, !0, !0);
      if (f && (!d || !f.__zr) && f.__isRendered) {
        var v = f.getPrevPaintRect();
        v && c(v);
      }
    }
    var p;
    do {
      p = !1;
      for (var h = 0; h < s.length; ) {
        if (s[h].isZero()) {
          s.splice(h, 1);
          continue;
        }
        for (var m = h + 1; m < s.length; )
          s[h].intersect(s[m]) ? (p = !0, s[h].union(s[m]), s.splice(m, 1)) : m++;
        h++;
      }
    } while (p);
    return this._paintRects = s, s;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(i, n) {
    var r = this.dpr, a = this.dom, s = a.style, o = this.domBack;
    s && (s.width = i + "px", s.height = n + "px"), a.width = i * r, a.height = n * r, o && (o.width = i * r, o.height = n * r, r !== 1 && this.ctxBack.scale(r, r));
  }, t.prototype.clear = function(i, n, r) {
    var a = this.dom, s = this.ctx, o = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !i, c = this.lastFrameAlpha, h = this.dpr, f = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, o / h, l / h));
    var d = this.domBack;
    function v(g, p, m, y) {
      if (s.clearRect(g, p, m, y), n && n !== "transparent") {
        var _ = void 0;
        if (bc(n)) {
          var b = n.global || n.__width === m && n.__height === y;
          _ = b && n.__canvasGradient || Ad(s, n, {
            x: 0,
            y: 0,
            width: m,
            height: y
          }), n.__canvasGradient = _, n.__width = m, n.__height = y;
        } else nA(n) && (n.scaleX = n.scaleX || h, n.scaleY = n.scaleY || h, _ = Ed(s, n, {
          dirty: function() {
            f.setUnpainted(), f.painter.refresh();
          }
        }));
        s.save(), s.fillStyle = _ || n, s.fillRect(g, p, m, y), s.restore();
      }
      u && (s.save(), s.globalAlpha = c, s.drawImage(d, g, p, m, y), s.restore());
    }
    !r || u ? v(0, 0, o, l) : r.length && k(r, function(g) {
      v(g.x * h, g.y * h, g.width * h, g.height * h);
    });
  }, t;
})(ki), k0 = 1e5, Er = 314159, Xl = 0.01, $3 = 1e-3;
function H3(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function Y3(e, t) {
  var i = document.createElement("div");
  return i.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", i;
}
var W3 = (function() {
  function e(t, i, n, r) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = Y({}, n || {}), this.dpr = n.devicePixelRatio || Eu, this._singleCanvas = a, this.root = t;
    var s = t.style;
    s && (qb(t), t.innerHTML = ""), this.storage = i;
    var o = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, h = c.width, f = c.height;
      n.width != null && (h = n.width), n.height != null && (f = n.height), this.dpr = n.devicePixelRatio || 1, c.width = h * this.dpr, c.height = f * this.dpr, this._width = h, this._height = f;
      var d = new Df(c, this, this.dpr);
      d.__builtin__ = !0, d.initContext(), l[Er] = d, d.zlevel = Er, o.push(Er), this._domRoot = t;
    } else {
      this._width = zl(t, 0, n), this._height = zl(t, 1, n);
      var u = this._domRoot = Y3(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var i = this.storage.getDisplayList(!0), n = this._prevDisplayList, r = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(i, n, t, this._redrawId);
    for (var a = 0; a < r.length; a++) {
      var s = r[a], o = this._layers[s];
      if (!o.__builtin__ && o.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        o.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = i.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var i = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!i) {
      for (var r = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, s = 0; s < i; s++) {
        var o = t[s];
        o.__inHover && (n || (n = this._hoverlayer = this.getLayer(k0)), a || (a = n.ctx, a.save()), Yr(a, o, r, s === i - 1));
      }
      a && a.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(k0);
  }, e.prototype.paintOne = function(t, i) {
    ow(t, i);
  }, e.prototype._paintList = function(t, i, n, r) {
    if (this._redrawId === r) {
      n = n || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, i, n), s = a.finished, o = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), o && this._paintHoverList(t), s)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        Tu(function() {
          l._paintList(t, i, n, r);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(Er).ctx, i = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, i, n), this.eachBuiltinLayer(function(r) {
      r.virtual && t.drawImage(r.dom, 0, 0, i, n);
    });
  }, e.prototype._doPaintList = function(t, i, n) {
    for (var r = this, a = [], s = this._opts.useDirtyRect, o = 0; o < this._zlevelList.length; o++) {
      var l = this._zlevelList[o], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var c = !0, h = !1, f = function(g) {
      var p = a[g], m = p.ctx, y = s && p.createRepaintRects(t, i, d._width, d._height), _ = n ? p.__startIndex : p.__drawIndex, b = !n && p.incremental && Date.now, x = b && Date.now(), w = p.zlevel === d._zlevelList[0] ? d._backgroundColor : null;
      if (p.__startIndex === p.__endIndex)
        p.clear(!1, w, y);
      else if (_ === p.__startIndex) {
        var M = t[_];
        (!M.incremental || !M.notClear || n) && p.clear(!1, w, y);
      }
      _ === -1 && (console.error("For some unknown reason. drawIndex is -1"), _ = p.__startIndex);
      var T, D = function(E) {
        var R = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: r._width,
          viewHeight: r._height
        };
        for (T = _; T < p.__endIndex; T++) {
          var I = t[T];
          if (I.__inHover && (h = !0), r._doPaintEl(I, p, s, E, R, T === p.__endIndex - 1), b) {
            var N = Date.now() - x;
            if (N > 15)
              break;
          }
        }
        R.prevElClipPaths && m.restore();
      };
      if (y)
        if (y.length === 0)
          T = p.__endIndex;
        else
          for (var P = d.dpr, C = 0; C < y.length; ++C) {
            var A = y[C];
            m.save(), m.beginPath(), m.rect(A.x * P, A.y * P, A.width * P, A.height * P), m.clip(), D(A), m.restore();
          }
      else
        m.save(), D(), m.restore();
      p.__drawIndex = T, p.__drawIndex < p.__endIndex && (c = !1);
    }, d = this, v = 0; v < a.length; v++)
      f(v);
    return rt.wxa && k(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, e.prototype._doPaintEl = function(t, i, n, r, a, s) {
    var o = i.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!r || l && l.intersect(r)) && (Yr(o, t, a, s), t.setPrevPaintRect(l));
    } else
      Yr(o, t, a, s);
  }, e.prototype.getLayer = function(t, i) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Er);
    var n = this._layers[t];
    return n || (n = new Df("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? re(n, this._layerConfig[t], !0) : this._layerConfig[t - Xl] && re(n, this._layerConfig[t - Xl], !0), i && (n.virtual = i), this.insertLayer(t, n), n.initContext()), n;
  }, e.prototype.insertLayer = function(t, i) {
    var n = this._layers, r = this._zlevelList, a = r.length, s = this._domRoot, o = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && jr("ZLevel " + t + " has been used already");
      return;
    }
    if (!H3(i)) {
      process.env.NODE_ENV !== "production" && jr("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > r[0]) {
      for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++)
        ;
      o = n[r[l]];
    }
    if (r.splice(l + 1, 0, t), n[t] = i, !i.virtual)
      if (o) {
        var u = o.dom;
        u.nextSibling ? s.insertBefore(i.dom, u.nextSibling) : s.appendChild(i.dom);
      } else
        s.firstChild ? s.insertBefore(i.dom, s.firstChild) : s.appendChild(i.dom);
    i.painter || (i.painter = this);
  }, e.prototype.eachLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r];
      t.call(i, this._layers[a], a);
    }
  }, e.prototype.eachBuiltinLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], s = this._layers[a];
      s.__builtin__ && t.call(i, s, a);
    }
  }, e.prototype.eachOtherLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], s = this._layers[a];
      s.__builtin__ || t.call(i, s, a);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(h, f) {
      h.__dirty = h.__used = !1;
    });
    function i(h) {
      a && (a.__endIndex !== h && (a.__dirty = !0), a.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var r = t[n];
        if (r.zlevel !== t[n - 1].zlevel || r.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, s = 0, o, l;
    for (l = 0; l < t.length; l++) {
      var r = t[l], u = r.zlevel, c = void 0;
      o !== u && (o = u, s = 0), r.incremental ? (c = this.getLayer(u + $3, this._needsManuallyCompositing), c.incremental = !0, s = 1) : c = this.getLayer(u + (s > 0 ? Xl : 0), this._needsManuallyCompositing), c.__builtin__ || jr("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, i(l), a = c), r.__dirty & Xe && !r.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    i(l), this.eachBuiltinLayer(function(h, f) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, k(this._layers, function(i) {
      i.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, i) {
    if (i) {
      var n = this._layerConfig;
      n[t] ? re(n[t], i, !0) : n[t] = i;
      for (var r = 0; r < this._zlevelList.length; r++) {
        var a = this._zlevelList[r];
        if (a === t || a === t + Xl) {
          var s = this._layers[a];
          re(s, n[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var i = this._layers, n = this._zlevelList, r = i[t];
    r && (r.dom.parentNode.removeChild(r.dom), delete i[t], n.splice(Bt(n, t), 1));
  }, e.prototype.resize = function(t, i) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var r = this._opts, a = this.root;
      if (t != null && (r.width = t), i != null && (r.height = i), t = zl(a, 0, r), i = zl(a, 1, r), n.style.display = "", this._width !== t || i !== this._height) {
        n.style.width = t + "px", n.style.height = i + "px";
        for (var s in this._layers)
          this._layers.hasOwnProperty(s) && this._layers[s].resize(t, i);
        this.refresh(!0);
      }
      this._width = t, this._height = i;
    } else {
      if (t == null || i == null)
        return;
      this._width = t, this._height = i, this.getLayer(Er).resize(t, i);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var i = this._layers[t];
    i && i.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Er].dom;
    var i = new Df("image", this, t.pixelRatio || this.dpr);
    i.initContext(), i.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = i.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var r = i.dom.width, a = i.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? n.drawImage(h.dom, 0, 0, r, a) : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
      });
    } else
      for (var s = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, o = this.storage.getDisplayList(!0), l = 0, u = o.length; l < u; l++) {
        var c = o[l];
        Yr(n, c, s, l === u - 1);
      }
    return i.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
})();
function U3(e) {
  e.registerPainter("canvas", W3);
}
const G3 = { class: "chart-container" }, j3 = {
  key: 1,
  class: "chart-wrapper"
}, X3 = /* @__PURE__ */ Te({
  __name: "SankeyChart",
  props: {
    data: { default: () => ({ nodes: [], links: [] }) },
    title: { default: "" },
    height: { default: "500px" },
    nodeColors: { default: () => ({}) },
    useGradient: { type: Boolean, default: !0 },
    nodeGap: { default: 20 }
  },
  setup(e) {
    cp([t3, o3, V3, U3]);
    const t = e, i = wi(null), n = wi(!0), r = wi(!1);
    let a = null;
    const s = {
      animation: { duration: 1e3, easing: "cubicOut" },
      margins: { left: "2%", right: "2%", top: "2%", bottom: "2%" },
      node: { width: 70, gap: 20, align: "left", iterations: 64 },
      style: {
        shadowBlur: 4,
        shadowColor: "rgba(139, 92, 246, 0.15)"
      }
    }, o = [
      "#C67DFF",
      // Primary light
      "#8b5cf6",
      // Primary medium
      "#a855f7",
      // Bright purple
      "#7c3aed",
      // Vibrant purple
      "#5d4b93",
      // Primary dark
      "#9333ea"
      // Deep purple
    ], l = () => {
      const p = t.data.links.filter(
        (b) => b.source && b.target && typeof b.value == "number"
      ), m = Math.max(...p.map((b) => b.value), 1), y = Math.max(1, m * 0.01), _ = p.map((b) => ({
        ...b,
        originalValue: b.value,
        value: b.value < m * 0.01 ? y : b.value
      }));
      return {
        nodes: t.data.nodes.filter((b) => b.name),
        links: _
      };
    }, u = (p) => p.map((m, y) => ({
      ...m,
      itemStyle: {
        color: t.nodeColors[m.name] || o[y % o.length],
        borderRadius: 8
      }
    })), c = (p) => (m) => {
      if (m.dataType === "node") {
        const M = p.filter((P) => P.target === m.name), T = p.filter((P) => P.source === m.name), D = M.length > 0 ? M.reduce((P, C) => P + (C.originalValue || C.value), 0) : T.reduce((P, C) => P + (C.originalValue || C.value), 0);
        return `<div style="font-weight: 600; margin-bottom: 4px; color: #f1f5f9;">${m.name}</div><div style="color: #e2e8f0; font-size: 12px;">Count: ${D.toLocaleString()}</div>`;
      }
      const _ = m.data?.source || m.source || "Unknown", b = m.data?.target || m.target || "Unknown", x = m.data?.originalValue || m.data?.value || m.value || 0, w = m.data?.label || `${x.toLocaleString()}`;
      return `<div style="font-weight: 600; margin-bottom: 4px; color: #f1f5f9;">${_}  ${b}</div><div style="color: #e2e8f0; font-size: 12px;">Flow: ${w}</div>`;
    }, h = () => {
      if (!(!a || !t.data.nodes?.length || !t.data.links?.length))
        try {
          const { nodes: p, links: m } = l(), y = u(p), _ = {
            tooltip: {
              trigger: "item",
              triggerOn: "mousemove",
              formatter: c(m),
              backgroundColor: "rgba(15, 23, 42, 0.95)",
              borderColor: "rgba(148, 163, 184, 0.2)",
              borderWidth: 1,
              borderRadius: 8,
              padding: [10, 14],
              textStyle: {
                color: "#f1f5f9",
                fontSize: 13,
                fontFamily: "'DM Sans', sans-serif",
                fontWeight: 500
              },
              shadowBlur: 10,
              shadowColor: "rgba(0, 0, 0, 0.3)"
            },
            series: [
              {
                type: "sankey",
                data: y,
                links: m,
                emphasis: { focus: "adjacency" },
                levels: [
                  {
                    depth: 0,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  },
                  {
                    depth: 1,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  }
                ],
                lineStyle: {
                  color: t.useGradient ? "gradient" : "source",
                  curveness: 0.5,
                  opacity: 0.6
                },
                itemStyle: s.style,
                label: {
                  show: !0,
                  position: "inside",
                  color: "#ffffff",
                  fontWeight: 600,
                  fontSize: 12,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (b) => {
                    const x = b.name || "";
                    return x.length > 15 ? `${x.substring(0, 15)}...` : x;
                  }
                },
                edgeLabel: {
                  show: !0,
                  fontSize: 11,
                  color: "#475569",
                  fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (b) => {
                    const x = b.data?.originalValue || b.value || 0;
                    return b.data?.label || `${x.toLocaleString()}`;
                  }
                },
                nodeAlign: s.node.align,
                nodeGap: t.nodeGap,
                nodeWidth: s.node.width,
                layoutIterations: s.node.iterations,
                orient: "horizontal",
                draggable: !1,
                ...s.margins
              }
            ],
            backgroundColor: "transparent",
            animation: !0,
            animationDuration: s.animation.duration,
            animationEasing: s.animation.easing
          };
          a.setOption(_);
        } catch (p) {
          console.error("Error setting Sankey chart options:", p), r.value = !0;
        }
    }, f = async () => {
      if (i.value)
        try {
          a = BN(i.value), h(), window.addEventListener("resize", v);
        } catch (p) {
          console.error("Error initializing Sankey chart:", p), r.value = !0;
        } finally {
          n.value = !1;
        }
    }, d = async (p = 40) => {
      await $0();
      for (let m = 0; m < p; m++) {
        if (i.value?.clientWidth && i.value.clientWidth > 0 && i.value?.clientHeight && i.value.clientHeight > 0)
          return await f();
        await new Promise((y) => setTimeout(y, 50));
      }
      await f(), setTimeout(v, 50);
    }, v = () => a?.resize(), g = () => {
      window.removeEventListener("resize", v), a && (a.dispose(), a = null);
    };
    return V0(() => i.value && d()), qS(g), qd(() => t.data, h, { deep: !0 }), (p, m) => (L(), O("div", G3, [
      r.value ? (L(), O("div", {
        key: 0,
        class: "error-state",
        style: Ur({ height: e.height })
      }, [...m[0] || (m[0] = [
        zt('<div class="error-content" data-v-6c6d201e><svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-6c6d201e><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-6c6d201e></path></svg><p class="error-title" data-v-6c6d201e>Chart could not be loaded</p><p class="error-description" data-v-6c6d201e>Please check the data format.</p></div>', 1)
      ])], 4)) : (L(), O("div", j3, [
        Hp(S("div", {
          ref_key: "chartEl",
          ref: i,
          class: "chart-content",
          style: Ur({ height: e.height })
        }, null, 4), [
          [Yp, !n.value]
        ]),
        Hp(S("div", {
          class: "loading-state",
          style: Ur({ height: e.height })
        }, [...m[1] || (m[1] = [
          zt('<div class="loading-container" data-v-6c6d201e><div class="sankey-loader" data-v-6c6d201e><div class="flow flow-1" data-v-6c6d201e></div><div class="flow flow-2" data-v-6c6d201e></div><div class="flow flow-3" data-v-6c6d201e></div><div class="flow flow-4" data-v-6c6d201e></div></div><p class="loading-text" data-v-6c6d201e>Loading Sankey diagram...</p></div>', 1)
        ])], 4), [
          [Yp, n.value]
        ])
      ]))
    ]));
  }
}), fs = /* @__PURE__ */ fe(X3, [["__scopeId", "data-v-6c6d201e"]]), q3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: fs
}, Symbol.toStringTag, { value: "Module" }));
var tS;
function V() {
  return tS.apply(null, arguments);
}
function Z3(e) {
  tS = e;
}
function Ti(e) {
  return e instanceof Array || Object.prototype.toString.call(e) === "[object Array]";
}
function ea(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Object]";
}
function xt(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function yp(e) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(e).length === 0;
  var t;
  for (t in e)
    if (xt(e, t))
      return !1;
  return !0;
}
function Ne(e) {
  return e === void 0;
}
function Tn(e) {
  return typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]";
}
function qo(e) {
  return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
}
function eS(e, t) {
  var i = [], n, r = e.length;
  for (n = 0; n < r; ++n)
    i.push(t(e[n], n));
  return i;
}
function Yn(e, t) {
  for (var i in t)
    xt(t, i) && (e[i] = t[i]);
  return xt(t, "toString") && (e.toString = t.toString), xt(t, "valueOf") && (e.valueOf = t.valueOf), e;
}
function Qi(e, t, i, n) {
  return MS(e, t, i, n, !0).utc();
}
function K3() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function st(e) {
  return e._pf == null && (e._pf = K3()), e._pf;
}
var Hd;
Array.prototype.some ? Hd = Array.prototype.some : Hd = function(e) {
  var t = Object(this), i = t.length >>> 0, n;
  for (n = 0; n < i; n++)
    if (n in t && e.call(this, t[n], n, t))
      return !0;
  return !1;
};
function _p(e) {
  var t = null, i = !1, n = e._d && !isNaN(e._d.getTime());
  if (n && (t = st(e), i = Hd.call(t.parsedDateParts, function(r) {
    return r != null;
  }), n = t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && i), e._strict && (n = n && t.charsLeftOver === 0 && t.unusedTokens.length === 0 && t.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(e))
    e._isValid = n;
  else
    return n;
  return e._isValid;
}
function Bc(e) {
  var t = Qi(NaN);
  return e != null ? Yn(st(t), e) : st(t).userInvalidated = !0, t;
}
var P0 = V.momentProperties = [], Cf = !1;
function bp(e, t) {
  var i, n, r, a = P0.length;
  if (Ne(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), Ne(t._i) || (e._i = t._i), Ne(t._f) || (e._f = t._f), Ne(t._l) || (e._l = t._l), Ne(t._strict) || (e._strict = t._strict), Ne(t._tzm) || (e._tzm = t._tzm), Ne(t._isUTC) || (e._isUTC = t._isUTC), Ne(t._offset) || (e._offset = t._offset), Ne(t._pf) || (e._pf = st(t)), Ne(t._locale) || (e._locale = t._locale), a > 0)
    for (i = 0; i < a; i++)
      n = P0[i], r = t[n], Ne(r) || (e[n] = r);
  return e;
}
function Zo(e) {
  bp(this, e), this._d = new Date(e._d != null ? e._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Cf === !1 && (Cf = !0, V.updateOffset(this), Cf = !1);
}
function Di(e) {
  return e instanceof Zo || e != null && e._isAMomentObject != null;
}
function iS(e) {
  V.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + e);
}
function pi(e, t) {
  var i = !0;
  return Yn(function() {
    if (V.deprecationHandler != null && V.deprecationHandler(null, e), i) {
      var n = [], r, a, s, o = arguments.length;
      for (a = 0; a < o; a++) {
        if (r = "", typeof arguments[a] == "object") {
          r += `
[` + a + "] ";
          for (s in arguments[0])
            xt(arguments[0], s) && (r += s + ": " + arguments[0][s] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[a];
        n.push(r);
      }
      iS(
        e + `
Arguments: ` + Array.prototype.slice.call(n).join("") + `
` + new Error().stack
      ), i = !1;
    }
    return t.apply(this, arguments);
  }, t);
}
var A0 = {};
function nS(e, t) {
  V.deprecationHandler != null && V.deprecationHandler(e, t), A0[e] || (iS(t), A0[e] = !0);
}
V.suppressDeprecationWarnings = !1;
V.deprecationHandler = null;
function Ji(e) {
  return typeof Function < "u" && e instanceof Function || Object.prototype.toString.call(e) === "[object Function]";
}
function Q3(e) {
  var t, i;
  for (i in e)
    xt(e, i) && (t = e[i], Ji(t) ? this[i] = t : this["_" + i] = t);
  this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function Yd(e, t) {
  var i = Yn({}, e), n;
  for (n in t)
    xt(t, n) && (ea(e[n]) && ea(t[n]) ? (i[n] = {}, Yn(i[n], e[n]), Yn(i[n], t[n])) : t[n] != null ? i[n] = t[n] : delete i[n]);
  for (n in e)
    xt(e, n) && !xt(t, n) && ea(e[n]) && (i[n] = Yn({}, i[n]));
  return i;
}
function xp(e) {
  e != null && this.set(e);
}
var Wd;
Object.keys ? Wd = Object.keys : Wd = function(e) {
  var t, i = [];
  for (t in e)
    xt(e, t) && i.push(t);
  return i;
};
var J3 = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function t4(e, t, i) {
  var n = this._calendar[e] || this._calendar.sameElse;
  return Ji(n) ? n.call(t, i) : n;
}
function Zi(e, t, i) {
  var n = "" + Math.abs(e), r = t - n.length, a = e >= 0;
  return (a ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + n;
}
var wp = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, ql = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, kf = {}, qa = {};
function X(e, t, i, n) {
  var r = n;
  typeof n == "string" && (r = function() {
    return this[n]();
  }), e && (qa[e] = r), t && (qa[t[0]] = function() {
    return Zi(r.apply(this, arguments), t[1], t[2]);
  }), i && (qa[i] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      e
    );
  });
}
function e4(e) {
  return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "");
}
function i4(e) {
  var t = e.match(wp), i, n;
  for (i = 0, n = t.length; i < n; i++)
    qa[t[i]] ? t[i] = qa[t[i]] : t[i] = e4(t[i]);
  return function(r) {
    var a = "", s;
    for (s = 0; s < n; s++)
      a += Ji(t[s]) ? t[s].call(r, e) : t[s];
    return a;
  };
}
function hu(e, t) {
  return e.isValid() ? (t = rS(t, e.localeData()), kf[t] = kf[t] || i4(t), kf[t](e)) : e.localeData().invalidDate();
}
function rS(e, t) {
  var i = 5;
  function n(r) {
    return t.longDateFormat(r) || r;
  }
  for (ql.lastIndex = 0; i >= 0 && ql.test(e); )
    e = e.replace(
      ql,
      n
    ), ql.lastIndex = 0, i -= 1;
  return e;
}
var n4 = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function r4(e) {
  var t = this._longDateFormat[e], i = this._longDateFormat[e.toUpperCase()];
  return t || !i ? t : (this._longDateFormat[e] = i.match(wp).map(function(n) {
    return n === "MMMM" || n === "MM" || n === "DD" || n === "dddd" ? n.slice(1) : n;
  }).join(""), this._longDateFormat[e]);
}
var a4 = "Invalid date";
function s4() {
  return this._invalidDate;
}
var o4 = "%d", l4 = /\d{1,2}/;
function u4(e) {
  return this._ordinal.replace("%d", e);
}
var c4 = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function h4(e, t, i, n) {
  var r = this._relativeTime[i];
  return Ji(r) ? r(e, t, i, n) : r.replace(/%d/i, e);
}
function f4(e, t) {
  var i = this._relativeTime[e > 0 ? "future" : "past"];
  return Ji(i) ? i(t) : i.replace(/%s/i, t);
}
var E0 = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function gi(e) {
  return typeof e == "string" ? E0[e] || E0[e.toLowerCase()] : void 0;
}
function Sp(e) {
  var t = {}, i, n;
  for (n in e)
    xt(e, n) && (i = gi(n), i && (t[i] = e[n]));
  return t;
}
var d4 = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function v4(e) {
  var t = [], i;
  for (i in e)
    xt(e, i) && t.push({ unit: i, priority: d4[i] });
  return t.sort(function(n, r) {
    return n.priority - r.priority;
  }), t;
}
var aS = /\d/, Qe = /\d\d/, sS = /\d{3}/, Mp = /\d{4}/, zc = /[+-]?\d{6}/, $t = /\d\d?/, oS = /\d\d\d\d?/, lS = /\d\d\d\d\d\d?/, Vc = /\d{1,3}/, Tp = /\d{1,4}/, $c = /[+-]?\d{1,6}/, ds = /\d+/, Hc = /[+-]?\d+/, p4 = /Z|[+-]\d\d:?\d\d/gi, Yc = /Z|[+-]\d\d(?::?\d\d)?/gi, g4 = /[+-]?\d+(\.\d{1,3})?/, Ko = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, vs = /^[1-9]\d?/, Dp = /^([1-9]\d|\d)/, sc;
sc = {};
function U(e, t, i) {
  sc[e] = Ji(t) ? t : function(n, r) {
    return n && i ? i : t;
  };
}
function m4(e, t) {
  return xt(sc, e) ? sc[e](t._strict, t._locale) : new RegExp(y4(e));
}
function y4(e) {
  return bn(
    e.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(t, i, n, r, a) {
        return i || n || r || a;
      }
    )
  );
}
function bn(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function ci(e) {
  return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
}
function vt(e) {
  var t = +e, i = 0;
  return t !== 0 && isFinite(t) && (i = ci(t)), i;
}
var Ud = {};
function Et(e, t) {
  var i, n = t, r;
  for (typeof e == "string" && (e = [e]), Tn(t) && (n = function(a, s) {
    s[t] = vt(a);
  }), r = e.length, i = 0; i < r; i++)
    Ud[e[i]] = n;
}
function Qo(e, t) {
  Et(e, function(i, n, r, a) {
    r._w = r._w || {}, t(i, r._w, r, a);
  });
}
function _4(e, t, i) {
  t != null && xt(Ud, e) && Ud[e](t, i._a, i, e);
}
function Wc(e) {
  return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
}
var we = 0, gn = 1, $i = 2, oe = 3, xi = 4, mn = 5, Wr = 6, b4 = 7, x4 = 8;
X("Y", 0, 0, function() {
  var e = this.year();
  return e <= 9999 ? Zi(e, 4) : "+" + e;
});
X(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
X(0, ["YYYY", 4], 0, "year");
X(0, ["YYYYY", 5], 0, "year");
X(0, ["YYYYYY", 6, !0], 0, "year");
U("Y", Hc);
U("YY", $t, Qe);
U("YYYY", Tp, Mp);
U("YYYYY", $c, zc);
U("YYYYYY", $c, zc);
Et(["YYYYY", "YYYYYY"], we);
Et("YYYY", function(e, t) {
  t[we] = e.length === 2 ? V.parseTwoDigitYear(e) : vt(e);
});
Et("YY", function(e, t) {
  t[we] = V.parseTwoDigitYear(e);
});
Et("Y", function(e, t) {
  t[we] = parseInt(e, 10);
});
function mo(e) {
  return Wc(e) ? 366 : 365;
}
V.parseTwoDigitYear = function(e) {
  return vt(e) + (vt(e) > 68 ? 1900 : 2e3);
};
var uS = ps("FullYear", !0);
function w4() {
  return Wc(this.year());
}
function ps(e, t) {
  return function(i) {
    return i != null ? (cS(this, e, i), V.updateOffset(this, t), this) : zo(this, e);
  };
}
function zo(e, t) {
  if (!e.isValid())
    return NaN;
  var i = e._d, n = e._isUTC;
  switch (t) {
    case "Milliseconds":
      return n ? i.getUTCMilliseconds() : i.getMilliseconds();
    case "Seconds":
      return n ? i.getUTCSeconds() : i.getSeconds();
    case "Minutes":
      return n ? i.getUTCMinutes() : i.getMinutes();
    case "Hours":
      return n ? i.getUTCHours() : i.getHours();
    case "Date":
      return n ? i.getUTCDate() : i.getDate();
    case "Day":
      return n ? i.getUTCDay() : i.getDay();
    case "Month":
      return n ? i.getUTCMonth() : i.getMonth();
    case "FullYear":
      return n ? i.getUTCFullYear() : i.getFullYear();
    default:
      return NaN;
  }
}
function cS(e, t, i) {
  var n, r, a, s, o;
  if (!(!e.isValid() || isNaN(i))) {
    switch (n = e._d, r = e._isUTC, t) {
      case "Milliseconds":
        return void (r ? n.setUTCMilliseconds(i) : n.setMilliseconds(i));
      case "Seconds":
        return void (r ? n.setUTCSeconds(i) : n.setSeconds(i));
      case "Minutes":
        return void (r ? n.setUTCMinutes(i) : n.setMinutes(i));
      case "Hours":
        return void (r ? n.setUTCHours(i) : n.setHours(i));
      case "Date":
        return void (r ? n.setUTCDate(i) : n.setDate(i));
      // case 'Day': // Not real
      //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
      // case 'Month': // Not used because we need to pass two variables
      //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
      case "FullYear":
        break;
      // See below ...
      default:
        return;
    }
    a = i, s = e.month(), o = e.date(), o = o === 29 && s === 1 && !Wc(a) ? 28 : o, r ? n.setUTCFullYear(a, s, o) : n.setFullYear(a, s, o);
  }
}
function S4(e) {
  return e = gi(e), Ji(this[e]) ? this[e]() : this;
}
function M4(e, t) {
  if (typeof e == "object") {
    e = Sp(e);
    var i = v4(e), n, r = i.length;
    for (n = 0; n < r; n++)
      this[i[n].unit](e[i[n].unit]);
  } else if (e = gi(e), Ji(this[e]))
    return this[e](t);
  return this;
}
function T4(e, t) {
  return (e % t + t) % t;
}
var Jt;
Array.prototype.indexOf ? Jt = Array.prototype.indexOf : Jt = function(e) {
  var t;
  for (t = 0; t < this.length; ++t)
    if (this[t] === e)
      return t;
  return -1;
};
function Cp(e, t) {
  if (isNaN(e) || isNaN(t))
    return NaN;
  var i = T4(t, 12);
  return e += (t - i) / 12, i === 1 ? Wc(e) ? 29 : 28 : 31 - i % 7 % 2;
}
X("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
X("MMM", 0, 0, function(e) {
  return this.localeData().monthsShort(this, e);
});
X("MMMM", 0, 0, function(e) {
  return this.localeData().months(this, e);
});
U("M", $t, vs);
U("MM", $t, Qe);
U("MMM", function(e, t) {
  return t.monthsShortRegex(e);
});
U("MMMM", function(e, t) {
  return t.monthsRegex(e);
});
Et(["M", "MM"], function(e, t) {
  t[gn] = vt(e) - 1;
});
Et(["MMM", "MMMM"], function(e, t, i, n) {
  var r = i._locale.monthsParse(e, n, i._strict);
  r != null ? t[gn] = r : st(i).invalidMonth = e;
});
var D4 = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), hS = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), fS = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, C4 = Ko, k4 = Ko;
function P4(e, t) {
  return e ? Ti(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || fS).test(t) ? "format" : "standalone"][e.month()] : Ti(this._months) ? this._months : this._months.standalone;
}
function A4(e, t) {
  return e ? Ti(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[fS.test(t) ? "format" : "standalone"][e.month()] : Ti(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function E4(e, t, i) {
  var n, r, a, s = e.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n)
      a = Qi([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(
        a,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[n] = this.months(a, "").toLocaleLowerCase();
  return i ? t === "MMM" ? (r = Jt.call(this._shortMonthsParse, s), r !== -1 ? r : null) : (r = Jt.call(this._longMonthsParse, s), r !== -1 ? r : null) : t === "MMM" ? (r = Jt.call(this._shortMonthsParse, s), r !== -1 ? r : (r = Jt.call(this._longMonthsParse, s), r !== -1 ? r : null)) : (r = Jt.call(this._longMonthsParse, s), r !== -1 ? r : (r = Jt.call(this._shortMonthsParse, s), r !== -1 ? r : null));
}
function L4(e, t, i) {
  var n, r, a;
  if (this._monthsParseExact)
    return E4.call(this, e, t, i);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
    if (r = Qi([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[n] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !i && !this._monthsParse[n] && (a = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[n] = new RegExp(a.replace(".", ""), "i")), i && t === "MMMM" && this._longMonthsParse[n].test(e))
      return n;
    if (i && t === "MMM" && this._shortMonthsParse[n].test(e))
      return n;
    if (!i && this._monthsParse[n].test(e))
      return n;
  }
}
function dS(e, t) {
  if (!e.isValid())
    return e;
  if (typeof t == "string") {
    if (/^\d+$/.test(t))
      t = vt(t);
    else if (t = e.localeData().monthsParse(t), !Tn(t))
      return e;
  }
  var i = t, n = e.date();
  return n = n < 29 ? n : Math.min(n, Cp(e.year(), i)), e._isUTC ? e._d.setUTCMonth(i, n) : e._d.setMonth(i, n), e;
}
function vS(e) {
  return e != null ? (dS(this, e), V.updateOffset(this, !0), this) : zo(this, "Month");
}
function O4() {
  return Cp(this.year(), this.month());
}
function I4(e) {
  return this._monthsParseExact ? (xt(this, "_monthsRegex") || pS.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (xt(this, "_monthsShortRegex") || (this._monthsShortRegex = C4), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function R4(e) {
  return this._monthsParseExact ? (xt(this, "_monthsRegex") || pS.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (xt(this, "_monthsRegex") || (this._monthsRegex = k4), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex);
}
function pS() {
  function e(l, u) {
    return u.length - l.length;
  }
  var t = [], i = [], n = [], r, a, s, o;
  for (r = 0; r < 12; r++)
    a = Qi([2e3, r]), s = bn(this.monthsShort(a, "")), o = bn(this.months(a, "")), t.push(s), i.push(o), n.push(o), n.push(s);
  t.sort(e), i.sort(e), n.sort(e), this._monthsRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function N4(e, t, i, n, r, a, s) {
  var o;
  return e < 100 && e >= 0 ? (o = new Date(e + 400, t, i, n, r, a, s), isFinite(o.getFullYear()) && o.setFullYear(e)) : o = new Date(e, t, i, n, r, a, s), o;
}
function Vo(e) {
  var t, i;
  return e < 100 && e >= 0 ? (i = Array.prototype.slice.call(arguments), i[0] = e + 400, t = new Date(Date.UTC.apply(null, i)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t;
}
function oc(e, t, i) {
  var n = 7 + t - i, r = (7 + Vo(e, 0, n).getUTCDay() - t) % 7;
  return -r + n - 1;
}
function gS(e, t, i, n, r) {
  var a = (7 + i - n) % 7, s = oc(e, n, r), o = 1 + 7 * (t - 1) + a + s, l, u;
  return o <= 0 ? (l = e - 1, u = mo(l) + o) : o > mo(e) ? (l = e + 1, u = o - mo(e)) : (l = e, u = o), {
    year: l,
    dayOfYear: u
  };
}
function $o(e, t, i) {
  var n = oc(e.year(), t, i), r = Math.floor((e.dayOfYear() - n - 1) / 7) + 1, a, s;
  return r < 1 ? (s = e.year() - 1, a = r + xn(s, t, i)) : r > xn(e.year(), t, i) ? (a = r - xn(e.year(), t, i), s = e.year() + 1) : (s = e.year(), a = r), {
    week: a,
    year: s
  };
}
function xn(e, t, i) {
  var n = oc(e, t, i), r = oc(e + 1, t, i);
  return (mo(e) - n + r) / 7;
}
X("w", ["ww", 2], "wo", "week");
X("W", ["WW", 2], "Wo", "isoWeek");
U("w", $t, vs);
U("ww", $t, Qe);
U("W", $t, vs);
U("WW", $t, Qe);
Qo(
  ["w", "ww", "W", "WW"],
  function(e, t, i, n) {
    t[n.substr(0, 1)] = vt(e);
  }
);
function F4(e) {
  return $o(e, this._week.dow, this._week.doy).week;
}
var B4 = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function z4() {
  return this._week.dow;
}
function V4() {
  return this._week.doy;
}
function $4(e) {
  var t = this.localeData().week(this);
  return e == null ? t : this.add((e - t) * 7, "d");
}
function H4(e) {
  var t = $o(this, 1, 4).week;
  return e == null ? t : this.add((e - t) * 7, "d");
}
X("d", 0, "do", "day");
X("dd", 0, 0, function(e) {
  return this.localeData().weekdaysMin(this, e);
});
X("ddd", 0, 0, function(e) {
  return this.localeData().weekdaysShort(this, e);
});
X("dddd", 0, 0, function(e) {
  return this.localeData().weekdays(this, e);
});
X("e", 0, 0, "weekday");
X("E", 0, 0, "isoWeekday");
U("d", $t);
U("e", $t);
U("E", $t);
U("dd", function(e, t) {
  return t.weekdaysMinRegex(e);
});
U("ddd", function(e, t) {
  return t.weekdaysShortRegex(e);
});
U("dddd", function(e, t) {
  return t.weekdaysRegex(e);
});
Qo(["dd", "ddd", "dddd"], function(e, t, i, n) {
  var r = i._locale.weekdaysParse(e, n, i._strict);
  r != null ? t.d = r : st(i).invalidWeekday = e;
});
Qo(["d", "e", "E"], function(e, t, i, n) {
  t[n] = vt(e);
});
function Y4(e, t) {
  return typeof e != "string" ? e : isNaN(e) ? (e = t.weekdaysParse(e), typeof e == "number" ? e : null) : parseInt(e, 10);
}
function W4(e, t) {
  return typeof e == "string" ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e;
}
function kp(e, t) {
  return e.slice(t, 7).concat(e.slice(0, t));
}
var U4 = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), mS = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), G4 = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), j4 = Ko, X4 = Ko, q4 = Ko;
function Z4(e, t) {
  var i = Ti(this._weekdays) ? this._weekdays : this._weekdays[e && e !== !0 && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
  return e === !0 ? kp(i, this._week.dow) : e ? i[e.day()] : i;
}
function K4(e) {
  return e === !0 ? kp(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort;
}
function Q4(e) {
  return e === !0 ? kp(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin;
}
function J4(e, t, i) {
  var n, r, a, s = e.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n)
      a = Qi([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(
        a,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(
        a,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(a, "").toLocaleLowerCase();
  return i ? t === "dddd" ? (r = Jt.call(this._weekdaysParse, s), r !== -1 ? r : null) : t === "ddd" ? (r = Jt.call(this._shortWeekdaysParse, s), r !== -1 ? r : null) : (r = Jt.call(this._minWeekdaysParse, s), r !== -1 ? r : null) : t === "dddd" ? (r = Jt.call(this._weekdaysParse, s), r !== -1 || (r = Jt.call(this._shortWeekdaysParse, s), r !== -1) ? r : (r = Jt.call(this._minWeekdaysParse, s), r !== -1 ? r : null)) : t === "ddd" ? (r = Jt.call(this._shortWeekdaysParse, s), r !== -1 || (r = Jt.call(this._weekdaysParse, s), r !== -1) ? r : (r = Jt.call(this._minWeekdaysParse, s), r !== -1 ? r : null)) : (r = Jt.call(this._minWeekdaysParse, s), r !== -1 || (r = Jt.call(this._weekdaysParse, s), r !== -1) ? r : (r = Jt.call(this._shortWeekdaysParse, s), r !== -1 ? r : null));
}
function tz(e, t, i) {
  var n, r, a;
  if (this._weekdaysParseExact)
    return J4.call(this, e, t, i);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
    if (r = Qi([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[n] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[n] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[n] || (a = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[n] = new RegExp(a.replace(".", ""), "i")), i && t === "dddd" && this._fullWeekdaysParse[n].test(e))
      return n;
    if (i && t === "ddd" && this._shortWeekdaysParse[n].test(e))
      return n;
    if (i && t === "dd" && this._minWeekdaysParse[n].test(e))
      return n;
    if (!i && this._weekdaysParse[n].test(e))
      return n;
  }
}
function ez(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = zo(this, "Day");
  return e != null ? (e = Y4(e, this.localeData()), this.add(e - t, "d")) : t;
}
function iz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return e == null ? t : this.add(e - t, "d");
}
function nz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    var t = W4(e, this.localeData());
    return this.day(this.day() % 7 ? t : t - 7);
  } else
    return this.day() || 7;
}
function rz(e) {
  return this._weekdaysParseExact ? (xt(this, "_weekdaysRegex") || Pp.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (xt(this, "_weekdaysRegex") || (this._weekdaysRegex = j4), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function az(e) {
  return this._weekdaysParseExact ? (xt(this, "_weekdaysRegex") || Pp.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (xt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = X4), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function sz(e) {
  return this._weekdaysParseExact ? (xt(this, "_weekdaysRegex") || Pp.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (xt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = q4), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Pp() {
  function e(c, h) {
    return h.length - c.length;
  }
  var t = [], i = [], n = [], r = [], a, s, o, l, u;
  for (a = 0; a < 7; a++)
    s = Qi([2e3, 1]).day(a), o = bn(this.weekdaysMin(s, "")), l = bn(this.weekdaysShort(s, "")), u = bn(this.weekdays(s, "")), t.push(o), i.push(l), n.push(u), r.push(o), r.push(l), r.push(u);
  t.sort(e), i.sort(e), n.sort(e), r.sort(e), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + n.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function Ap() {
  return this.hours() % 12 || 12;
}
function oz() {
  return this.hours() || 24;
}
X("H", ["HH", 2], 0, "hour");
X("h", ["hh", 2], 0, Ap);
X("k", ["kk", 2], 0, oz);
X("hmm", 0, 0, function() {
  return "" + Ap.apply(this) + Zi(this.minutes(), 2);
});
X("hmmss", 0, 0, function() {
  return "" + Ap.apply(this) + Zi(this.minutes(), 2) + Zi(this.seconds(), 2);
});
X("Hmm", 0, 0, function() {
  return "" + this.hours() + Zi(this.minutes(), 2);
});
X("Hmmss", 0, 0, function() {
  return "" + this.hours() + Zi(this.minutes(), 2) + Zi(this.seconds(), 2);
});
function yS(e, t) {
  X(e, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      t
    );
  });
}
yS("a", !0);
yS("A", !1);
function _S(e, t) {
  return t._meridiemParse;
}
U("a", _S);
U("A", _S);
U("H", $t, Dp);
U("h", $t, vs);
U("k", $t, vs);
U("HH", $t, Qe);
U("hh", $t, Qe);
U("kk", $t, Qe);
U("hmm", oS);
U("hmmss", lS);
U("Hmm", oS);
U("Hmmss", lS);
Et(["H", "HH"], oe);
Et(["k", "kk"], function(e, t, i) {
  var n = vt(e);
  t[oe] = n === 24 ? 0 : n;
});
Et(["a", "A"], function(e, t, i) {
  i._isPm = i._locale.isPM(e), i._meridiem = e;
});
Et(["h", "hh"], function(e, t, i) {
  t[oe] = vt(e), st(i).bigHour = !0;
});
Et("hmm", function(e, t, i) {
  var n = e.length - 2;
  t[oe] = vt(e.substr(0, n)), t[xi] = vt(e.substr(n)), st(i).bigHour = !0;
});
Et("hmmss", function(e, t, i) {
  var n = e.length - 4, r = e.length - 2;
  t[oe] = vt(e.substr(0, n)), t[xi] = vt(e.substr(n, 2)), t[mn] = vt(e.substr(r)), st(i).bigHour = !0;
});
Et("Hmm", function(e, t, i) {
  var n = e.length - 2;
  t[oe] = vt(e.substr(0, n)), t[xi] = vt(e.substr(n));
});
Et("Hmmss", function(e, t, i) {
  var n = e.length - 4, r = e.length - 2;
  t[oe] = vt(e.substr(0, n)), t[xi] = vt(e.substr(n, 2)), t[mn] = vt(e.substr(r));
});
function lz(e) {
  return (e + "").toLowerCase().charAt(0) === "p";
}
var uz = /[ap]\.?m?\.?/i, cz = ps("Hours", !0);
function hz(e, t, i) {
  return e > 11 ? i ? "pm" : "PM" : i ? "am" : "AM";
}
var bS = {
  calendar: J3,
  longDateFormat: n4,
  invalidDate: a4,
  ordinal: o4,
  dayOfMonthOrdinalParse: l4,
  relativeTime: c4,
  months: D4,
  monthsShort: hS,
  week: B4,
  weekdays: U4,
  weekdaysMin: G4,
  weekdaysShort: mS,
  meridiemParse: uz
}, Yt = {}, Hs = {}, Ho;
function fz(e, t) {
  var i, n = Math.min(e.length, t.length);
  for (i = 0; i < n; i += 1)
    if (e[i] !== t[i])
      return i;
  return n;
}
function L0(e) {
  return e && e.toLowerCase().replace("_", "-");
}
function dz(e) {
  for (var t = 0, i, n, r, a; t < e.length; ) {
    for (a = L0(e[t]).split("-"), i = a.length, n = L0(e[t + 1]), n = n ? n.split("-") : null; i > 0; ) {
      if (r = Uc(a.slice(0, i).join("-")), r)
        return r;
      if (n && n.length >= i && fz(a, n) >= i - 1)
        break;
      i--;
    }
    t++;
  }
  return Ho;
}
function vz(e) {
  return !!(e && e.match("^[^/\\\\]*$"));
}
function Uc(e) {
  var t = null, i;
  if (Yt[e] === void 0 && typeof module < "u" && module && module.exports && vz(e))
    try {
      t = Ho._abbr, i = require, i("./locale/" + e), Zn(t);
    } catch {
      Yt[e] = null;
    }
  return Yt[e];
}
function Zn(e, t) {
  var i;
  return e && (Ne(t) ? i = kn(e) : i = Ep(e, t), i ? Ho = i : typeof console < "u" && console.warn && console.warn(
    "Locale " + e + " not found. Did you forget to load it?"
  )), Ho._abbr;
}
function Ep(e, t) {
  if (t !== null) {
    var i, n = bS;
    if (t.abbr = e, Yt[e] != null)
      nS(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), n = Yt[e]._config;
    else if (t.parentLocale != null)
      if (Yt[t.parentLocale] != null)
        n = Yt[t.parentLocale]._config;
      else if (i = Uc(t.parentLocale), i != null)
        n = i._config;
      else
        return Hs[t.parentLocale] || (Hs[t.parentLocale] = []), Hs[t.parentLocale].push({
          name: e,
          config: t
        }), null;
    return Yt[e] = new xp(Yd(n, t)), Hs[e] && Hs[e].forEach(function(r) {
      Ep(r.name, r.config);
    }), Zn(e), Yt[e];
  } else
    return delete Yt[e], null;
}
function pz(e, t) {
  if (t != null) {
    var i, n, r = bS;
    Yt[e] != null && Yt[e].parentLocale != null ? Yt[e].set(Yd(Yt[e]._config, t)) : (n = Uc(e), n != null && (r = n._config), t = Yd(r, t), n == null && (t.abbr = e), i = new xp(t), i.parentLocale = Yt[e], Yt[e] = i), Zn(e);
  } else
    Yt[e] != null && (Yt[e].parentLocale != null ? (Yt[e] = Yt[e].parentLocale, e === Zn() && Zn(e)) : Yt[e] != null && delete Yt[e]);
  return Yt[e];
}
function kn(e) {
  var t;
  if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e)
    return Ho;
  if (!Ti(e)) {
    if (t = Uc(e), t)
      return t;
    e = [e];
  }
  return dz(e);
}
function gz() {
  return Wd(Yt);
}
function Lp(e) {
  var t, i = e._a;
  return i && st(e).overflow === -2 && (t = i[gn] < 0 || i[gn] > 11 ? gn : i[$i] < 1 || i[$i] > Cp(i[we], i[gn]) ? $i : i[oe] < 0 || i[oe] > 24 || i[oe] === 24 && (i[xi] !== 0 || i[mn] !== 0 || i[Wr] !== 0) ? oe : i[xi] < 0 || i[xi] > 59 ? xi : i[mn] < 0 || i[mn] > 59 ? mn : i[Wr] < 0 || i[Wr] > 999 ? Wr : -1, st(e)._overflowDayOfYear && (t < we || t > $i) && (t = $i), st(e)._overflowWeeks && t === -1 && (t = b4), st(e)._overflowWeekday && t === -1 && (t = x4), st(e).overflow = t), e;
}
var mz = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, yz = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, _z = /Z|[+-]\d\d(?::?\d\d)?/, Zl = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Pf = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], bz = /^\/?Date\((-?\d+)/i, xz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, wz = {
  UT: 0,
  GMT: 0,
  EDT: -240,
  EST: -300,
  CDT: -300,
  CST: -360,
  MDT: -360,
  MST: -420,
  PDT: -420,
  PST: -480
};
function xS(e) {
  var t, i, n = e._i, r = mz.exec(n) || yz.exec(n), a, s, o, l, u = Zl.length, c = Pf.length;
  if (r) {
    for (st(e).iso = !0, t = 0, i = u; t < i; t++)
      if (Zl[t][1].exec(r[1])) {
        s = Zl[t][0], a = Zl[t][2] !== !1;
        break;
      }
    if (s == null) {
      e._isValid = !1;
      return;
    }
    if (r[3]) {
      for (t = 0, i = c; t < i; t++)
        if (Pf[t][1].exec(r[3])) {
          o = (r[2] || " ") + Pf[t][0];
          break;
        }
      if (o == null) {
        e._isValid = !1;
        return;
      }
    }
    if (!a && o != null) {
      e._isValid = !1;
      return;
    }
    if (r[4])
      if (_z.exec(r[4]))
        l = "Z";
      else {
        e._isValid = !1;
        return;
      }
    e._f = s + (o || "") + (l || ""), Ip(e);
  } else
    e._isValid = !1;
}
function Sz(e, t, i, n, r, a) {
  var s = [
    Mz(e),
    hS.indexOf(t),
    parseInt(i, 10),
    parseInt(n, 10),
    parseInt(r, 10)
  ];
  return a && s.push(parseInt(a, 10)), s;
}
function Mz(e) {
  var t = parseInt(e, 10);
  return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t;
}
function Tz(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Dz(e, t, i) {
  if (e) {
    var n = mS.indexOf(e), r = new Date(
      t[0],
      t[1],
      t[2]
    ).getDay();
    if (n !== r)
      return st(i).weekdayMismatch = !0, i._isValid = !1, !1;
  }
  return !0;
}
function Cz(e, t, i) {
  if (e)
    return wz[e];
  if (t)
    return 0;
  var n = parseInt(i, 10), r = n % 100, a = (n - r) / 100;
  return a * 60 + r;
}
function wS(e) {
  var t = xz.exec(Tz(e._i)), i;
  if (t) {
    if (i = Sz(
      t[4],
      t[3],
      t[2],
      t[5],
      t[6],
      t[7]
    ), !Dz(t[1], i, e))
      return;
    e._a = i, e._tzm = Cz(t[8], t[9], t[10]), e._d = Vo.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), st(e).rfc2822 = !0;
  } else
    e._isValid = !1;
}
function kz(e) {
  var t = bz.exec(e._i);
  if (t !== null) {
    e._d = /* @__PURE__ */ new Date(+t[1]);
    return;
  }
  if (xS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  if (wS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  e._strict ? e._isValid = !1 : V.createFromInputFallback(e);
}
V.createFromInputFallback = pi(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(e) {
    e._d = /* @__PURE__ */ new Date(e._i + (e._useUTC ? " UTC" : ""));
  }
);
function Ra(e, t, i) {
  return e ?? t ?? i;
}
function Pz(e) {
  var t = new Date(V.now());
  return e._useUTC ? [
    t.getUTCFullYear(),
    t.getUTCMonth(),
    t.getUTCDate()
  ] : [t.getFullYear(), t.getMonth(), t.getDate()];
}
function Op(e) {
  var t, i, n = [], r, a, s;
  if (!e._d) {
    for (r = Pz(e), e._w && e._a[$i] == null && e._a[gn] == null && Az(e), e._dayOfYear != null && (s = Ra(e._a[we], r[we]), (e._dayOfYear > mo(s) || e._dayOfYear === 0) && (st(e)._overflowDayOfYear = !0), i = Vo(s, 0, e._dayOfYear), e._a[gn] = i.getUTCMonth(), e._a[$i] = i.getUTCDate()), t = 0; t < 3 && e._a[t] == null; ++t)
      e._a[t] = n[t] = r[t];
    for (; t < 7; t++)
      e._a[t] = n[t] = e._a[t] == null ? t === 2 ? 1 : 0 : e._a[t];
    e._a[oe] === 24 && e._a[xi] === 0 && e._a[mn] === 0 && e._a[Wr] === 0 && (e._nextDay = !0, e._a[oe] = 0), e._d = (e._useUTC ? Vo : N4).apply(
      null,
      n
    ), a = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[oe] = 24), e._w && typeof e._w.d < "u" && e._w.d !== a && (st(e).weekdayMismatch = !0);
  }
}
function Az(e) {
  var t, i, n, r, a, s, o, l, u;
  t = e._w, t.GG != null || t.W != null || t.E != null ? (a = 1, s = 4, i = Ra(
    t.GG,
    e._a[we],
    $o(Vt(), 1, 4).year
  ), n = Ra(t.W, 1), r = Ra(t.E, 1), (r < 1 || r > 7) && (l = !0)) : (a = e._locale._week.dow, s = e._locale._week.doy, u = $o(Vt(), a, s), i = Ra(t.gg, e._a[we], u.year), n = Ra(t.w, u.week), t.d != null ? (r = t.d, (r < 0 || r > 6) && (l = !0)) : t.e != null ? (r = t.e + a, (t.e < 0 || t.e > 6) && (l = !0)) : r = a), n < 1 || n > xn(i, a, s) ? st(e)._overflowWeeks = !0 : l != null ? st(e)._overflowWeekday = !0 : (o = gS(i, n, r, a, s), e._a[we] = o.year, e._dayOfYear = o.dayOfYear);
}
V.ISO_8601 = function() {
};
V.RFC_2822 = function() {
};
function Ip(e) {
  if (e._f === V.ISO_8601) {
    xS(e);
    return;
  }
  if (e._f === V.RFC_2822) {
    wS(e);
    return;
  }
  e._a = [], st(e).empty = !0;
  var t = "" + e._i, i, n, r, a, s, o = t.length, l = 0, u, c;
  for (r = rS(e._f, e._locale).match(wp) || [], c = r.length, i = 0; i < c; i++)
    a = r[i], n = (t.match(m4(a, e)) || [])[0], n && (s = t.substr(0, t.indexOf(n)), s.length > 0 && st(e).unusedInput.push(s), t = t.slice(
      t.indexOf(n) + n.length
    ), l += n.length), qa[a] ? (n ? st(e).empty = !1 : st(e).unusedTokens.push(a), _4(a, n, e)) : e._strict && !n && st(e).unusedTokens.push(a);
  st(e).charsLeftOver = o - l, t.length > 0 && st(e).unusedInput.push(t), e._a[oe] <= 12 && st(e).bigHour === !0 && e._a[oe] > 0 && (st(e).bigHour = void 0), st(e).parsedDateParts = e._a.slice(0), st(e).meridiem = e._meridiem, e._a[oe] = Ez(
    e._locale,
    e._a[oe],
    e._meridiem
  ), u = st(e).era, u !== null && (e._a[we] = e._locale.erasConvertYear(u, e._a[we])), Op(e), Lp(e);
}
function Ez(e, t, i) {
  var n;
  return i == null ? t : e.meridiemHour != null ? e.meridiemHour(t, i) : (e.isPM != null && (n = e.isPM(i), n && t < 12 && (t += 12), !n && t === 12 && (t = 0)), t);
}
function Lz(e) {
  var t, i, n, r, a, s, o = !1, l = e._f.length;
  if (l === 0) {
    st(e).invalidFormat = !0, e._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    a = 0, s = !1, t = bp({}, e), e._useUTC != null && (t._useUTC = e._useUTC), t._f = e._f[r], Ip(t), _p(t) && (s = !0), a += st(t).charsLeftOver, a += st(t).unusedTokens.length * 10, st(t).score = a, o ? a < n && (n = a, i = t) : (n == null || a < n || s) && (n = a, i = t, s && (o = !0));
  Yn(e, i || t);
}
function Oz(e) {
  if (!e._d) {
    var t = Sp(e._i), i = t.day === void 0 ? t.date : t.day;
    e._a = eS(
      [t.year, t.month, i, t.hour, t.minute, t.second, t.millisecond],
      function(n) {
        return n && parseInt(n, 10);
      }
    ), Op(e);
  }
}
function Iz(e) {
  var t = new Zo(Lp(SS(e)));
  return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t;
}
function SS(e) {
  var t = e._i, i = e._f;
  return e._locale = e._locale || kn(e._l), t === null || i === void 0 && t === "" ? Bc({ nullInput: !0 }) : (typeof t == "string" && (e._i = t = e._locale.preparse(t)), Di(t) ? new Zo(Lp(t)) : (qo(t) ? e._d = t : Ti(i) ? Lz(e) : i ? Ip(e) : Rz(e), _p(e) || (e._d = null), e));
}
function Rz(e) {
  var t = e._i;
  Ne(t) ? e._d = new Date(V.now()) : qo(t) ? e._d = new Date(t.valueOf()) : typeof t == "string" ? kz(e) : Ti(t) ? (e._a = eS(t.slice(0), function(i) {
    return parseInt(i, 10);
  }), Op(e)) : ea(t) ? Oz(e) : Tn(t) ? e._d = new Date(t) : V.createFromInputFallback(e);
}
function MS(e, t, i, n, r) {
  var a = {};
  return (t === !0 || t === !1) && (n = t, t = void 0), (i === !0 || i === !1) && (n = i, i = void 0), (ea(e) && yp(e) || Ti(e) && e.length === 0) && (e = void 0), a._isAMomentObject = !0, a._useUTC = a._isUTC = r, a._l = i, a._i = e, a._f = t, a._strict = n, Iz(a);
}
function Vt(e, t, i, n) {
  return MS(e, t, i, n, !1);
}
var Nz = pi(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Vt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e < this ? this : e : Bc();
  }
), Fz = pi(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Vt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e > this ? this : e : Bc();
  }
);
function TS(e, t) {
  var i, n;
  if (t.length === 1 && Ti(t[0]) && (t = t[0]), !t.length)
    return Vt();
  for (i = t[0], n = 1; n < t.length; ++n)
    (!t[n].isValid() || t[n][e](i)) && (i = t[n]);
  return i;
}
function Bz() {
  var e = [].slice.call(arguments, 0);
  return TS("isBefore", e);
}
function zz() {
  var e = [].slice.call(arguments, 0);
  return TS("isAfter", e);
}
var Vz = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, Ys = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function $z(e) {
  var t, i = !1, n, r = Ys.length;
  for (t in e)
    if (xt(e, t) && !(Jt.call(Ys, t) !== -1 && (e[t] == null || !isNaN(e[t]))))
      return !1;
  for (n = 0; n < r; ++n)
    if (e[Ys[n]]) {
      if (i)
        return !1;
      parseFloat(e[Ys[n]]) !== vt(e[Ys[n]]) && (i = !0);
    }
  return !0;
}
function Hz() {
  return this._isValid;
}
function Yz() {
  return Ei(NaN);
}
function Gc(e) {
  var t = Sp(e), i = t.year || 0, n = t.quarter || 0, r = t.month || 0, a = t.week || t.isoWeek || 0, s = t.day || 0, o = t.hour || 0, l = t.minute || 0, u = t.second || 0, c = t.millisecond || 0;
  this._isValid = $z(t), this._milliseconds = +c + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  o * 1e3 * 60 * 60, this._days = +s + a * 7, this._months = +r + n * 3 + i * 12, this._data = {}, this._locale = kn(), this._bubble();
}
function fu(e) {
  return e instanceof Gc;
}
function Gd(e) {
  return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e);
}
function Wz(e, t, i) {
  var n = Math.min(e.length, t.length), r = Math.abs(e.length - t.length), a = 0, s;
  for (s = 0; s < n; s++)
    vt(e[s]) !== vt(t[s]) && a++;
  return a + r;
}
function DS(e, t) {
  X(e, 0, 0, function() {
    var i = this.utcOffset(), n = "+";
    return i < 0 && (i = -i, n = "-"), n + Zi(~~(i / 60), 2) + t + Zi(~~i % 60, 2);
  });
}
DS("Z", ":");
DS("ZZ", "");
U("Z", Yc);
U("ZZ", Yc);
Et(["Z", "ZZ"], function(e, t, i) {
  i._useUTC = !0, i._tzm = Rp(Yc, e);
});
var Uz = /([\+\-]|\d\d)/gi;
function Rp(e, t) {
  var i = (t || "").match(e), n, r, a;
  return i === null ? null : (n = i[i.length - 1] || [], r = (n + "").match(Uz) || ["-", 0, 0], a = +(r[1] * 60) + vt(r[2]), a === 0 ? 0 : r[0] === "+" ? a : -a);
}
function Np(e, t) {
  var i, n;
  return t._isUTC ? (i = t.clone(), n = (Di(e) || qo(e) ? e.valueOf() : Vt(e).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + n), V.updateOffset(i, !1), i) : Vt(e).local();
}
function jd(e) {
  return -Math.round(e._d.getTimezoneOffset());
}
V.updateOffset = function() {
};
function Gz(e, t, i) {
  var n = this._offset || 0, r;
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    if (typeof e == "string") {
      if (e = Rp(Yc, e), e === null)
        return this;
    } else Math.abs(e) < 16 && !i && (e = e * 60);
    return !this._isUTC && t && (r = jd(this)), this._offset = e, this._isUTC = !0, r != null && this.add(r, "m"), n !== e && (!t || this._changeInProgress ? PS(
      this,
      Ei(e - n, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, V.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? n : jd(this);
}
function jz(e, t) {
  return e != null ? (typeof e != "string" && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset();
}
function Xz(e) {
  return this.utcOffset(0, e);
}
function qz(e) {
  return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(jd(this), "m")), this;
}
function Zz() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var e = Rp(p4, this._i);
    e != null ? this.utcOffset(e) : this.utcOffset(0, !0);
  }
  return this;
}
function Kz(e) {
  return this.isValid() ? (e = e ? Vt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 === 0) : !1;
}
function Qz() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function Jz() {
  if (!Ne(this._isDSTShifted))
    return this._isDSTShifted;
  var e = {}, t;
  return bp(e, this), e = SS(e), e._a ? (t = e._isUTC ? Qi(e._a) : Vt(e._a), this._isDSTShifted = this.isValid() && Wz(e._a, t.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function tV() {
  return this.isValid() ? !this._isUTC : !1;
}
function eV() {
  return this.isValid() ? this._isUTC : !1;
}
function CS() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var iV = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, nV = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Ei(e, t) {
  var i = e, n = null, r, a, s;
  return fu(e) ? i = {
    ms: e._milliseconds,
    d: e._days,
    M: e._months
  } : Tn(e) || !isNaN(+e) ? (i = {}, t ? i[t] = +e : i.milliseconds = +e) : (n = iV.exec(e)) ? (r = n[1] === "-" ? -1 : 1, i = {
    y: 0,
    d: vt(n[$i]) * r,
    h: vt(n[oe]) * r,
    m: vt(n[xi]) * r,
    s: vt(n[mn]) * r,
    ms: vt(Gd(n[Wr] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (n = nV.exec(e)) ? (r = n[1] === "-" ? -1 : 1, i = {
    y: Lr(n[2], r),
    M: Lr(n[3], r),
    w: Lr(n[4], r),
    d: Lr(n[5], r),
    h: Lr(n[6], r),
    m: Lr(n[7], r),
    s: Lr(n[8], r)
  }) : i == null ? i = {} : typeof i == "object" && ("from" in i || "to" in i) && (s = rV(
    Vt(i.from),
    Vt(i.to)
  ), i = {}, i.ms = s.milliseconds, i.M = s.months), a = new Gc(i), fu(e) && xt(e, "_locale") && (a._locale = e._locale), fu(e) && xt(e, "_isValid") && (a._isValid = e._isValid), a;
}
Ei.fn = Gc.prototype;
Ei.invalid = Yz;
function Lr(e, t) {
  var i = e && parseFloat(e.replace(",", "."));
  return (isNaN(i) ? 0 : i) * t;
}
function O0(e, t) {
  var i = {};
  return i.months = t.month() - e.month() + (t.year() - e.year()) * 12, e.clone().add(i.months, "M").isAfter(t) && --i.months, i.milliseconds = +t - +e.clone().add(i.months, "M"), i;
}
function rV(e, t) {
  var i;
  return e.isValid() && t.isValid() ? (t = Np(t, e), e.isBefore(t) ? i = O0(e, t) : (i = O0(t, e), i.milliseconds = -i.milliseconds, i.months = -i.months), i) : { milliseconds: 0, months: 0 };
}
function kS(e, t) {
  return function(i, n) {
    var r, a;
    return n !== null && !isNaN(+n) && (nS(
      t,
      "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), a = i, i = n, n = a), r = Ei(i, n), PS(this, r, e), this;
  };
}
function PS(e, t, i, n) {
  var r = t._milliseconds, a = Gd(t._days), s = Gd(t._months);
  e.isValid() && (n = n ?? !0, s && dS(e, zo(e, "Month") + s * i), a && cS(e, "Date", zo(e, "Date") + a * i), r && e._d.setTime(e._d.valueOf() + r * i), n && V.updateOffset(e, a || s));
}
var aV = kS(1, "add"), sV = kS(-1, "subtract");
function AS(e) {
  return typeof e == "string" || e instanceof String;
}
function oV(e) {
  return Di(e) || qo(e) || AS(e) || Tn(e) || uV(e) || lV(e) || e === null || e === void 0;
}
function lV(e) {
  var t = ea(e) && !yp(e), i = !1, n = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, a, s = n.length;
  for (r = 0; r < s; r += 1)
    a = n[r], i = i || xt(e, a);
  return t && i;
}
function uV(e) {
  var t = Ti(e), i = !1;
  return t && (i = e.filter(function(n) {
    return !Tn(n) && AS(e);
  }).length === 0), t && i;
}
function cV(e) {
  var t = ea(e) && !yp(e), i = !1, n = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, a;
  for (r = 0; r < n.length; r += 1)
    a = n[r], i = i || xt(e, a);
  return t && i;
}
function hV(e, t) {
  var i = e.diff(t, "days", !0);
  return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse";
}
function fV(e, t) {
  arguments.length === 1 && (arguments[0] ? oV(arguments[0]) ? (e = arguments[0], t = void 0) : cV(arguments[0]) && (t = arguments[0], e = void 0) : (e = void 0, t = void 0));
  var i = e || Vt(), n = Np(i, this).startOf("day"), r = V.calendarFormat(this, n) || "sameElse", a = t && (Ji(t[r]) ? t[r].call(this, i) : t[r]);
  return this.format(
    a || this.localeData().calendar(r, this, Vt(i))
  );
}
function dV() {
  return new Zo(this);
}
function vV(e, t) {
  var i = Di(e) ? e : Vt(e);
  return this.isValid() && i.isValid() ? (t = gi(t) || "millisecond", t === "millisecond" ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(t).valueOf()) : !1;
}
function pV(e, t) {
  var i = Di(e) ? e : Vt(e);
  return this.isValid() && i.isValid() ? (t = gi(t) || "millisecond", t === "millisecond" ? this.valueOf() < i.valueOf() : this.clone().endOf(t).valueOf() < i.valueOf()) : !1;
}
function gV(e, t, i, n) {
  var r = Di(e) ? e : Vt(e), a = Di(t) ? t : Vt(t);
  return this.isValid() && r.isValid() && a.isValid() ? (n = n || "()", (n[0] === "(" ? this.isAfter(r, i) : !this.isBefore(r, i)) && (n[1] === ")" ? this.isBefore(a, i) : !this.isAfter(a, i))) : !1;
}
function mV(e, t) {
  var i = Di(e) ? e : Vt(e), n;
  return this.isValid() && i.isValid() ? (t = gi(t) || "millisecond", t === "millisecond" ? this.valueOf() === i.valueOf() : (n = i.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf())) : !1;
}
function yV(e, t) {
  return this.isSame(e, t) || this.isAfter(e, t);
}
function _V(e, t) {
  return this.isSame(e, t) || this.isBefore(e, t);
}
function bV(e, t, i) {
  var n, r, a;
  if (!this.isValid())
    return NaN;
  if (n = Np(e, this), !n.isValid())
    return NaN;
  switch (r = (n.utcOffset() - this.utcOffset()) * 6e4, t = gi(t), t) {
    case "year":
      a = du(this, n) / 12;
      break;
    case "month":
      a = du(this, n);
      break;
    case "quarter":
      a = du(this, n) / 3;
      break;
    case "second":
      a = (this - n) / 1e3;
      break;
    // 1000
    case "minute":
      a = (this - n) / 6e4;
      break;
    // 1000 * 60
    case "hour":
      a = (this - n) / 36e5;
      break;
    // 1000 * 60 * 60
    case "day":
      a = (this - n - r) / 864e5;
      break;
    // 1000 * 60 * 60 * 24, negate dst
    case "week":
      a = (this - n - r) / 6048e5;
      break;
    // 1000 * 60 * 60 * 24 * 7, negate dst
    default:
      a = this - n;
  }
  return i ? a : ci(a);
}
function du(e, t) {
  if (e.date() < t.date())
    return -du(t, e);
  var i = (t.year() - e.year()) * 12 + (t.month() - e.month()), n = e.clone().add(i, "months"), r, a;
  return t - n < 0 ? (r = e.clone().add(i - 1, "months"), a = (t - n) / (n - r)) : (r = e.clone().add(i + 1, "months"), a = (t - n) / (r - n)), -(i + a) || 0;
}
V.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
V.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function xV() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function wV(e) {
  if (!this.isValid())
    return null;
  var t = e !== !0, i = t ? this.clone().utc() : this;
  return i.year() < 0 || i.year() > 9999 ? hu(
    i,
    t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : Ji(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", hu(i, "Z")) : hu(
    i,
    t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function SV() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var e = "moment", t = "", i, n, r, a;
  return this.isLocal() || (e = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", t = "Z"), i = "[" + e + '("]', n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", a = t + '[")]', this.format(i + n + r + a);
}
function MV(e) {
  e || (e = this.isUtc() ? V.defaultFormatUtc : V.defaultFormat);
  var t = hu(this, e);
  return this.localeData().postformat(t);
}
function TV(e, t) {
  return this.isValid() && (Di(e) && e.isValid() || Vt(e).isValid()) ? Ei({ to: this, from: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function DV(e) {
  return this.from(Vt(), e);
}
function CV(e, t) {
  return this.isValid() && (Di(e) && e.isValid() || Vt(e).isValid()) ? Ei({ from: this, to: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function kV(e) {
  return this.to(Vt(), e);
}
function ES(e) {
  var t;
  return e === void 0 ? this._locale._abbr : (t = kn(e), t != null && (this._locale = t), this);
}
var LS = pi(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(e) {
    return e === void 0 ? this.localeData() : this.locale(e);
  }
);
function OS() {
  return this._locale;
}
var lc = 1e3, Za = 60 * lc, uc = 60 * Za, IS = (365 * 400 + 97) * 24 * uc;
function Ka(e, t) {
  return (e % t + t) % t;
}
function RS(e, t, i) {
  return e < 100 && e >= 0 ? new Date(e + 400, t, i) - IS : new Date(e, t, i).valueOf();
}
function NS(e, t, i) {
  return e < 100 && e >= 0 ? Date.UTC(e + 400, t, i) - IS : Date.UTC(e, t, i);
}
function PV(e) {
  var t, i;
  if (e = gi(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (i = this._isUTC ? NS : RS, e) {
    case "year":
      t = i(this.year(), 0, 1);
      break;
    case "quarter":
      t = i(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      t = i(this.year(), this.month(), 1);
      break;
    case "week":
      t = i(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      t = i(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      t = i(this.year(), this.month(), this.date());
      break;
    case "hour":
      t = this._d.valueOf(), t -= Ka(
        t + (this._isUTC ? 0 : this.utcOffset() * Za),
        uc
      );
      break;
    case "minute":
      t = this._d.valueOf(), t -= Ka(t, Za);
      break;
    case "second":
      t = this._d.valueOf(), t -= Ka(t, lc);
      break;
  }
  return this._d.setTime(t), V.updateOffset(this, !0), this;
}
function AV(e) {
  var t, i;
  if (e = gi(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (i = this._isUTC ? NS : RS, e) {
    case "year":
      t = i(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      t = i(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      t = i(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      t = i(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      t = i(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      t = i(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      t = this._d.valueOf(), t += uc - Ka(
        t + (this._isUTC ? 0 : this.utcOffset() * Za),
        uc
      ) - 1;
      break;
    case "minute":
      t = this._d.valueOf(), t += Za - Ka(t, Za) - 1;
      break;
    case "second":
      t = this._d.valueOf(), t += lc - Ka(t, lc) - 1;
      break;
  }
  return this._d.setTime(t), V.updateOffset(this, !0), this;
}
function EV() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function LV() {
  return Math.floor(this.valueOf() / 1e3);
}
function OV() {
  return new Date(this.valueOf());
}
function IV() {
  var e = this;
  return [
    e.year(),
    e.month(),
    e.date(),
    e.hour(),
    e.minute(),
    e.second(),
    e.millisecond()
  ];
}
function RV() {
  var e = this;
  return {
    years: e.year(),
    months: e.month(),
    date: e.date(),
    hours: e.hours(),
    minutes: e.minutes(),
    seconds: e.seconds(),
    milliseconds: e.milliseconds()
  };
}
function NV() {
  return this.isValid() ? this.toISOString() : null;
}
function FV() {
  return _p(this);
}
function BV() {
  return Yn({}, st(this));
}
function zV() {
  return st(this).overflow;
}
function VV() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
X("N", 0, 0, "eraAbbr");
X("NN", 0, 0, "eraAbbr");
X("NNN", 0, 0, "eraAbbr");
X("NNNN", 0, 0, "eraName");
X("NNNNN", 0, 0, "eraNarrow");
X("y", ["y", 1], "yo", "eraYear");
X("y", ["yy", 2], 0, "eraYear");
X("y", ["yyy", 3], 0, "eraYear");
X("y", ["yyyy", 4], 0, "eraYear");
U("N", Fp);
U("NN", Fp);
U("NNN", Fp);
U("NNNN", KV);
U("NNNNN", QV);
Et(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(e, t, i, n) {
    var r = i._locale.erasParse(e, n, i._strict);
    r ? st(i).era = r : st(i).invalidEra = e;
  }
);
U("y", ds);
U("yy", ds);
U("yyy", ds);
U("yyyy", ds);
U("yo", JV);
Et(["y", "yy", "yyy", "yyyy"], we);
Et(["yo"], function(e, t, i, n) {
  var r;
  i._locale._eraYearOrdinalRegex && (r = e.match(i._locale._eraYearOrdinalRegex)), i._locale.eraYearOrdinalParse ? t[we] = i._locale.eraYearOrdinalParse(e, r) : t[we] = parseInt(e, 10);
});
function $V(e, t) {
  var i, n, r, a = this._eras || kn("en")._eras;
  for (i = 0, n = a.length; i < n; ++i) {
    switch (typeof a[i].since) {
      case "string":
        r = V(a[i].since).startOf("day"), a[i].since = r.valueOf();
        break;
    }
    switch (typeof a[i].until) {
      case "undefined":
        a[i].until = 1 / 0;
        break;
      case "string":
        r = V(a[i].until).startOf("day").valueOf(), a[i].until = r.valueOf();
        break;
    }
  }
  return a;
}
function HV(e, t, i) {
  var n, r, a = this.eras(), s, o, l;
  for (e = e.toUpperCase(), n = 0, r = a.length; n < r; ++n)
    if (s = a[n].name.toUpperCase(), o = a[n].abbr.toUpperCase(), l = a[n].narrow.toUpperCase(), i)
      switch (t) {
        case "N":
        case "NN":
        case "NNN":
          if (o === e)
            return a[n];
          break;
        case "NNNN":
          if (s === e)
            return a[n];
          break;
        case "NNNNN":
          if (l === e)
            return a[n];
          break;
      }
    else if ([s, o, l].indexOf(e) >= 0)
      return a[n];
}
function YV(e, t) {
  var i = e.since <= e.until ? 1 : -1;
  return t === void 0 ? V(e.since).year() : V(e.since).year() + (t - e.offset) * i;
}
function WV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].name;
  return "";
}
function UV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].narrow;
  return "";
}
function GV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].abbr;
  return "";
}
function jV() {
  var e, t, i, n, r = this.localeData().eras();
  for (e = 0, t = r.length; e < t; ++e)
    if (i = r[e].since <= r[e].until ? 1 : -1, n = this.clone().startOf("day").valueOf(), r[e].since <= n && n <= r[e].until || r[e].until <= n && n <= r[e].since)
      return (this.year() - V(r[e].since).year()) * i + r[e].offset;
  return this.year();
}
function XV(e) {
  return xt(this, "_erasNameRegex") || Bp.call(this), e ? this._erasNameRegex : this._erasRegex;
}
function qV(e) {
  return xt(this, "_erasAbbrRegex") || Bp.call(this), e ? this._erasAbbrRegex : this._erasRegex;
}
function ZV(e) {
  return xt(this, "_erasNarrowRegex") || Bp.call(this), e ? this._erasNarrowRegex : this._erasRegex;
}
function Fp(e, t) {
  return t.erasAbbrRegex(e);
}
function KV(e, t) {
  return t.erasNameRegex(e);
}
function QV(e, t) {
  return t.erasNarrowRegex(e);
}
function JV(e, t) {
  return t._eraYearOrdinalRegex || ds;
}
function Bp() {
  var e = [], t = [], i = [], n = [], r, a, s, o, l, u = this.eras();
  for (r = 0, a = u.length; r < a; ++r)
    s = bn(u[r].name), o = bn(u[r].abbr), l = bn(u[r].narrow), t.push(s), e.push(o), i.push(l), n.push(s), n.push(o), n.push(l);
  this._erasRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  );
}
X(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
X(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function jc(e, t) {
  X(0, [e, e.length], 0, t);
}
jc("gggg", "weekYear");
jc("ggggg", "weekYear");
jc("GGGG", "isoWeekYear");
jc("GGGGG", "isoWeekYear");
U("G", Hc);
U("g", Hc);
U("GG", $t, Qe);
U("gg", $t, Qe);
U("GGGG", Tp, Mp);
U("gggg", Tp, Mp);
U("GGGGG", $c, zc);
U("ggggg", $c, zc);
Qo(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(e, t, i, n) {
    t[n.substr(0, 2)] = vt(e);
  }
);
Qo(["gg", "GG"], function(e, t, i, n) {
  t[n] = V.parseTwoDigitYear(e);
});
function t6(e) {
  return FS.call(
    this,
    e,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function e6(e) {
  return FS.call(
    this,
    e,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function i6() {
  return xn(this.year(), 1, 4);
}
function n6() {
  return xn(this.isoWeekYear(), 1, 4);
}
function r6() {
  var e = this.localeData()._week;
  return xn(this.year(), e.dow, e.doy);
}
function a6() {
  var e = this.localeData()._week;
  return xn(this.weekYear(), e.dow, e.doy);
}
function FS(e, t, i, n, r) {
  var a;
  return e == null ? $o(this, n, r).year : (a = xn(e, n, r), t > a && (t = a), s6.call(this, e, t, i, n, r));
}
function s6(e, t, i, n, r) {
  var a = gS(e, t, i, n, r), s = Vo(a.year, 0, a.dayOfYear);
  return this.year(s.getUTCFullYear()), this.month(s.getUTCMonth()), this.date(s.getUTCDate()), this;
}
X("Q", 0, "Qo", "quarter");
U("Q", aS);
Et("Q", function(e, t) {
  t[gn] = (vt(e) - 1) * 3;
});
function o6(e) {
  return e == null ? Math.ceil((this.month() + 1) / 3) : this.month((e - 1) * 3 + this.month() % 3);
}
X("D", ["DD", 2], "Do", "date");
U("D", $t, vs);
U("DD", $t, Qe);
U("Do", function(e, t) {
  return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient;
});
Et(["D", "DD"], $i);
Et("Do", function(e, t) {
  t[$i] = vt(e.match($t)[0]);
});
var BS = ps("Date", !0);
X("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
U("DDD", Vc);
U("DDDD", sS);
Et(["DDD", "DDDD"], function(e, t, i) {
  i._dayOfYear = vt(e);
});
function l6(e) {
  var t = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return e == null ? t : this.add(e - t, "d");
}
X("m", ["mm", 2], 0, "minute");
U("m", $t, Dp);
U("mm", $t, Qe);
Et(["m", "mm"], xi);
var u6 = ps("Minutes", !1);
X("s", ["ss", 2], 0, "second");
U("s", $t, Dp);
U("ss", $t, Qe);
Et(["s", "ss"], mn);
var c6 = ps("Seconds", !1);
X("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
X(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
X(0, ["SSS", 3], 0, "millisecond");
X(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
X(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
X(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
X(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
X(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
X(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
U("S", Vc, aS);
U("SS", Vc, Qe);
U("SSS", Vc, sS);
var Wn, zS;
for (Wn = "SSSS"; Wn.length <= 9; Wn += "S")
  U(Wn, ds);
function h6(e, t) {
  t[Wr] = vt(("0." + e) * 1e3);
}
for (Wn = "S"; Wn.length <= 9; Wn += "S")
  Et(Wn, h6);
zS = ps("Milliseconds", !1);
X("z", 0, 0, "zoneAbbr");
X("zz", 0, 0, "zoneName");
function f6() {
  return this._isUTC ? "UTC" : "";
}
function d6() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var z = Zo.prototype;
z.add = aV;
z.calendar = fV;
z.clone = dV;
z.diff = bV;
z.endOf = AV;
z.format = MV;
z.from = TV;
z.fromNow = DV;
z.to = CV;
z.toNow = kV;
z.get = S4;
z.invalidAt = zV;
z.isAfter = vV;
z.isBefore = pV;
z.isBetween = gV;
z.isSame = mV;
z.isSameOrAfter = yV;
z.isSameOrBefore = _V;
z.isValid = FV;
z.lang = LS;
z.locale = ES;
z.localeData = OS;
z.max = Fz;
z.min = Nz;
z.parsingFlags = BV;
z.set = M4;
z.startOf = PV;
z.subtract = sV;
z.toArray = IV;
z.toObject = RV;
z.toDate = OV;
z.toISOString = wV;
z.inspect = SV;
typeof Symbol < "u" && Symbol.for != null && (z[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
z.toJSON = NV;
z.toString = xV;
z.unix = LV;
z.valueOf = EV;
z.creationData = VV;
z.eraName = WV;
z.eraNarrow = UV;
z.eraAbbr = GV;
z.eraYear = jV;
z.year = uS;
z.isLeapYear = w4;
z.weekYear = t6;
z.isoWeekYear = e6;
z.quarter = z.quarters = o6;
z.month = vS;
z.daysInMonth = O4;
z.week = z.weeks = $4;
z.isoWeek = z.isoWeeks = H4;
z.weeksInYear = r6;
z.weeksInWeekYear = a6;
z.isoWeeksInYear = i6;
z.isoWeeksInISOWeekYear = n6;
z.date = BS;
z.day = z.days = ez;
z.weekday = iz;
z.isoWeekday = nz;
z.dayOfYear = l6;
z.hour = z.hours = cz;
z.minute = z.minutes = u6;
z.second = z.seconds = c6;
z.millisecond = z.milliseconds = zS;
z.utcOffset = Gz;
z.utc = Xz;
z.local = qz;
z.parseZone = Zz;
z.hasAlignedHourOffset = Kz;
z.isDST = Qz;
z.isLocal = tV;
z.isUtcOffset = eV;
z.isUtc = CS;
z.isUTC = CS;
z.zoneAbbr = f6;
z.zoneName = d6;
z.dates = pi(
  "dates accessor is deprecated. Use date instead.",
  BS
);
z.months = pi(
  "months accessor is deprecated. Use month instead",
  vS
);
z.years = pi(
  "years accessor is deprecated. Use year instead",
  uS
);
z.zone = pi(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  jz
);
z.isDSTShifted = pi(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  Jz
);
function v6(e) {
  return Vt(e * 1e3);
}
function p6() {
  return Vt.apply(null, arguments).parseZone();
}
function VS(e) {
  return e;
}
var wt = xp.prototype;
wt.calendar = t4;
wt.longDateFormat = r4;
wt.invalidDate = s4;
wt.ordinal = u4;
wt.preparse = VS;
wt.postformat = VS;
wt.relativeTime = h4;
wt.pastFuture = f4;
wt.set = Q3;
wt.eras = $V;
wt.erasParse = HV;
wt.erasConvertYear = YV;
wt.erasAbbrRegex = qV;
wt.erasNameRegex = XV;
wt.erasNarrowRegex = ZV;
wt.months = P4;
wt.monthsShort = A4;
wt.monthsParse = L4;
wt.monthsRegex = R4;
wt.monthsShortRegex = I4;
wt.week = F4;
wt.firstDayOfYear = V4;
wt.firstDayOfWeek = z4;
wt.weekdays = Z4;
wt.weekdaysMin = Q4;
wt.weekdaysShort = K4;
wt.weekdaysParse = tz;
wt.weekdaysRegex = rz;
wt.weekdaysShortRegex = az;
wt.weekdaysMinRegex = sz;
wt.isPM = lz;
wt.meridiem = hz;
function cc(e, t, i, n) {
  var r = kn(), a = Qi().set(n, t);
  return r[i](a, e);
}
function $S(e, t, i) {
  if (Tn(e) && (t = e, e = void 0), e = e || "", t != null)
    return cc(e, t, i, "month");
  var n, r = [];
  for (n = 0; n < 12; n++)
    r[n] = cc(e, n, i, "month");
  return r;
}
function zp(e, t, i, n) {
  typeof e == "boolean" ? (Tn(t) && (i = t, t = void 0), t = t || "") : (t = e, i = t, e = !1, Tn(t) && (i = t, t = void 0), t = t || "");
  var r = kn(), a = e ? r._week.dow : 0, s, o = [];
  if (i != null)
    return cc(t, (i + a) % 7, n, "day");
  for (s = 0; s < 7; s++)
    o[s] = cc(t, (s + a) % 7, n, "day");
  return o;
}
function g6(e, t) {
  return $S(e, t, "months");
}
function m6(e, t) {
  return $S(e, t, "monthsShort");
}
function y6(e, t, i) {
  return zp(e, t, i, "weekdays");
}
function _6(e, t, i) {
  return zp(e, t, i, "weekdaysShort");
}
function b6(e, t, i) {
  return zp(e, t, i, "weekdaysMin");
}
Zn("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(e) {
    var t = e % 10, i = vt(e % 100 / 10) === 1 ? "th" : t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th";
    return e + i;
  }
});
V.lang = pi(
  "moment.lang is deprecated. Use moment.locale instead.",
  Zn
);
V.langData = pi(
  "moment.langData is deprecated. Use moment.localeData instead.",
  kn
);
var sn = Math.abs;
function x6() {
  var e = this._data;
  return this._milliseconds = sn(this._milliseconds), this._days = sn(this._days), this._months = sn(this._months), e.milliseconds = sn(e.milliseconds), e.seconds = sn(e.seconds), e.minutes = sn(e.minutes), e.hours = sn(e.hours), e.months = sn(e.months), e.years = sn(e.years), this;
}
function HS(e, t, i, n) {
  var r = Ei(t, i);
  return e._milliseconds += n * r._milliseconds, e._days += n * r._days, e._months += n * r._months, e._bubble();
}
function w6(e, t) {
  return HS(this, e, t, 1);
}
function S6(e, t) {
  return HS(this, e, t, -1);
}
function I0(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e);
}
function M6() {
  var e = this._milliseconds, t = this._days, i = this._months, n = this._data, r, a, s, o, l;
  return e >= 0 && t >= 0 && i >= 0 || e <= 0 && t <= 0 && i <= 0 || (e += I0(Xd(i) + t) * 864e5, t = 0, i = 0), n.milliseconds = e % 1e3, r = ci(e / 1e3), n.seconds = r % 60, a = ci(r / 60), n.minutes = a % 60, s = ci(a / 60), n.hours = s % 24, t += ci(s / 24), l = ci(YS(t)), i += l, t -= I0(Xd(l)), o = ci(i / 12), i %= 12, n.days = t, n.months = i, n.years = o, this;
}
function YS(e) {
  return e * 4800 / 146097;
}
function Xd(e) {
  return e * 146097 / 4800;
}
function T6(e) {
  if (!this.isValid())
    return NaN;
  var t, i, n = this._milliseconds;
  if (e = gi(e), e === "month" || e === "quarter" || e === "year")
    switch (t = this._days + n / 864e5, i = this._months + YS(t), e) {
      case "month":
        return i;
      case "quarter":
        return i / 3;
      case "year":
        return i / 12;
    }
  else
    switch (t = this._days + Math.round(Xd(this._months)), e) {
      case "week":
        return t / 7 + n / 6048e5;
      case "day":
        return t + n / 864e5;
      case "hour":
        return t * 24 + n / 36e5;
      case "minute":
        return t * 1440 + n / 6e4;
      case "second":
        return t * 86400 + n / 1e3;
      // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(t * 864e5) + n;
      default:
        throw new Error("Unknown unit " + e);
    }
}
function Pn(e) {
  return function() {
    return this.as(e);
  };
}
var WS = Pn("ms"), D6 = Pn("s"), C6 = Pn("m"), k6 = Pn("h"), P6 = Pn("d"), A6 = Pn("w"), E6 = Pn("M"), L6 = Pn("Q"), O6 = Pn("y"), I6 = WS;
function R6() {
  return Ei(this);
}
function N6(e) {
  return e = gi(e), this.isValid() ? this[e + "s"]() : NaN;
}
function ha(e) {
  return function() {
    return this.isValid() ? this._data[e] : NaN;
  };
}
var F6 = ha("milliseconds"), B6 = ha("seconds"), z6 = ha("minutes"), V6 = ha("hours"), $6 = ha("days"), H6 = ha("months"), Y6 = ha("years");
function W6() {
  return ci(this.days() / 7);
}
var cn = Math.round, Ha = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function U6(e, t, i, n, r) {
  return r.relativeTime(t || 1, !!i, e, n);
}
function G6(e, t, i, n) {
  var r = Ei(e).abs(), a = cn(r.as("s")), s = cn(r.as("m")), o = cn(r.as("h")), l = cn(r.as("d")), u = cn(r.as("M")), c = cn(r.as("w")), h = cn(r.as("y")), f = a <= i.ss && ["s", a] || a < i.s && ["ss", a] || s <= 1 && ["m"] || s < i.m && ["mm", s] || o <= 1 && ["h"] || o < i.h && ["hh", o] || l <= 1 && ["d"] || l < i.d && ["dd", l];
  return i.w != null && (f = f || c <= 1 && ["w"] || c < i.w && ["ww", c]), f = f || u <= 1 && ["M"] || u < i.M && ["MM", u] || h <= 1 && ["y"] || ["yy", h], f[2] = t, f[3] = +e > 0, f[4] = n, U6.apply(null, f);
}
function j6(e) {
  return e === void 0 ? cn : typeof e == "function" ? (cn = e, !0) : !1;
}
function X6(e, t) {
  return Ha[e] === void 0 ? !1 : t === void 0 ? Ha[e] : (Ha[e] = t, e === "s" && (Ha.ss = t - 1), !0);
}
function q6(e, t) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var i = !1, n = Ha, r, a;
  return typeof e == "object" && (t = e, e = !1), typeof e == "boolean" && (i = e), typeof t == "object" && (n = Object.assign({}, Ha, t), t.s != null && t.ss == null && (n.ss = t.s - 1)), r = this.localeData(), a = G6(this, !i, n, r), i && (a = r.pastFuture(+this, a)), r.postformat(a);
}
var Af = Math.abs;
function Oa(e) {
  return (e > 0) - (e < 0) || +e;
}
function Xc() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var e = Af(this._milliseconds) / 1e3, t = Af(this._days), i = Af(this._months), n, r, a, s, o = this.asSeconds(), l, u, c, h;
  return o ? (n = ci(e / 60), r = ci(n / 60), e %= 60, n %= 60, a = ci(i / 12), i %= 12, s = e ? e.toFixed(3).replace(/\.?0+$/, "") : "", l = o < 0 ? "-" : "", u = Oa(this._months) !== Oa(o) ? "-" : "", c = Oa(this._days) !== Oa(o) ? "-" : "", h = Oa(this._milliseconds) !== Oa(o) ? "-" : "", l + "P" + (a ? u + a + "Y" : "") + (i ? u + i + "M" : "") + (t ? c + t + "D" : "") + (r || n || e ? "T" : "") + (r ? h + r + "H" : "") + (n ? h + n + "M" : "") + (e ? h + s + "S" : "")) : "P0D";
}
var _t = Gc.prototype;
_t.isValid = Hz;
_t.abs = x6;
_t.add = w6;
_t.subtract = S6;
_t.as = T6;
_t.asMilliseconds = WS;
_t.asSeconds = D6;
_t.asMinutes = C6;
_t.asHours = k6;
_t.asDays = P6;
_t.asWeeks = A6;
_t.asMonths = E6;
_t.asQuarters = L6;
_t.asYears = O6;
_t.valueOf = I6;
_t._bubble = M6;
_t.clone = R6;
_t.get = N6;
_t.milliseconds = F6;
_t.seconds = B6;
_t.minutes = z6;
_t.hours = V6;
_t.days = $6;
_t.weeks = W6;
_t.months = H6;
_t.years = Y6;
_t.humanize = q6;
_t.toISOString = Xc;
_t.toString = Xc;
_t.toJSON = Xc;
_t.locale = ES;
_t.localeData = OS;
_t.toIsoString = pi(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  Xc
);
_t.lang = LS;
X("X", 0, 0, "unix");
X("x", 0, 0, "valueOf");
U("x", Hc);
U("X", g4);
Et("X", function(e, t, i) {
  i._d = new Date(parseFloat(e) * 1e3);
});
Et("x", function(e, t, i) {
  i._d = new Date(vt(e));
});
V.version = "2.30.1";
Z3(Vt);
V.fn = z;
V.min = Bz;
V.max = zz;
V.now = Vz;
V.utc = Qi;
V.unix = v6;
V.months = g6;
V.isDate = qo;
V.locale = Zn;
V.invalid = Bc;
V.duration = Ei;
V.isMoment = Di;
V.weekdays = y6;
V.parseZone = p6;
V.localeData = kn;
V.isDuration = fu;
V.monthsShort = m6;
V.weekdaysMin = b6;
V.defineLocale = Ep;
V.updateLocale = pz;
V.locales = gz;
V.weekdaysShort = _6;
V.normalizeUnits = gi;
V.relativeTimeRounding = j6;
V.relativeTimeThreshold = X6;
V.calendarFormat = hV;
V.prototype = z;
V.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const ut = (e) => e == null ? "0" : new Intl.NumberFormat("en-US").format(e), R0 = (e, t = "USD") => e == null ? "$0.00" : new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: t,
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(e), Z6 = { class: "booking-manager-card" }, K6 = { class: "card-header" }, Q6 = { class: "header-content" }, J6 = {
  key: 0,
  class: "payment-success-badge"
}, t$ = { class: "badge-value" }, e$ = {
  key: 0,
  class: "loading-state"
}, i$ = {
  key: 1,
  class: "error-state"
}, n$ = { class: "error-content" }, r$ = { class: "error-description" }, a$ = {
  key: 2,
  class: "card-body"
}, s$ = { class: "chart-section" }, o$ = { class: "chart-wrapper" }, l$ = {
  key: 0,
  class: "table-section"
}, u$ = { class: "table-wrapper" }, c$ = { class: "data-table" }, h$ = { class: "table-body" }, f$ = { class: "table-cell font-medium" }, d$ = { class: "table-cell text-center" }, v$ = { class: "table-cell text-center" }, p$ = { class: "percentage-text" }, g$ = { class: "table-cell text-center" }, m$ = { class: "table-cell" }, y$ = { class: "badges-container" }, _$ = { class: "badge badge-success" }, b$ = { class: "badge badge-error" }, x$ = { class: "table-cell" }, w$ = { class: "badges-container" }, S$ = { class: "badge badge-error" }, M$ = { class: "badge badge-warning" }, T$ = { class: "badge badge-yellow" }, D$ = { class: "badge badge-error" }, C$ = {
  key: 1,
  class: "empty-state"
}, k$ = /* @__PURE__ */ Te({
  __name: "BookingManager",
  props: {
    data: { default: () => ({
      total_booking_initiated: 0,
      total_booking_started: 0,
      total_payment_initiated: 0,
      total_not_found: 0,
      total_cancelled: 0,
      total_no_pending_balance: 0,
      total_errors: 0,
      total_payment_success: 0,
      total_payment_failed: 0,
      booking_manager_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    error: { default: null }
  },
  setup(e) {
    const t = e, i = J(() => t.data?.booking_manager_by_day ? [...t.data.booking_manager_by_day].sort(
      (s, o) => new Date(s.date).getTime() - new Date(o.date).getTime()
    ) : []), n = J(() => {
      const s = t.data, o = s.total_booking_initiated || 0, l = s.total_booking_started || 0, u = s.total_payment_initiated || 0, c = s.total_not_found || 0, h = s.total_cancelled || 0, f = s.total_no_pending_balance || 0, d = s.total_errors || 0, v = s.total_payment_success || 0, g = s.total_payment_failed || 0, p = Math.max(0, o - l), m = Math.max(0, l - u - c - h - f - d), y = (x, w) => {
        const M = w > 0 ? Math.round(x / w * 100) : 0;
        return `${x.toLocaleString()} (${M}%)`;
      }, _ = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Payment Initiated" },
        { name: "Not Found" },
        { name: "Cancelled" },
        { name: "No Pending Balance" },
        { name: "Errors" },
        { name: "Payment Success" },
        { name: "Payment Failed" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], b = [];
      return l > 0 && b.push({
        source: "Initiated",
        target: "Started",
        value: l,
        label: y(l, o)
      }), p > 0 && b.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: p,
        label: y(p, o)
      }), u > 0 && b.push({
        source: "Started",
        target: "Payment Initiated",
        value: u,
        label: y(u, l)
      }), c > 0 && b.push({
        source: "Started",
        target: "Not Found",
        value: c,
        label: y(c, l)
      }), h > 0 && b.push({
        source: "Started",
        target: "Cancelled",
        value: h,
        label: y(h, l)
      }), f > 0 && b.push({
        source: "Started",
        target: "No Pending Balance",
        value: f,
        label: y(f, l)
      }), d > 0 && b.push({
        source: "Started",
        target: "Errors",
        value: d,
        label: y(d, l)
      }), m > 0 && b.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: m,
        label: y(m, l)
      }), v > 0 && b.push({
        source: "Payment Initiated",
        target: "Payment Success",
        value: v,
        label: y(v, u)
      }), g > 0 && b.push({
        source: "Payment Initiated",
        target: "Payment Failed",
        value: g,
        label: y(g, u)
      }), { nodes: _, links: b };
    }), r = {
      Initiated: "#DBEAFE",
      Started: "#93C5FD",
      "Payment Initiated": "#FED7AA",
      "Not Found": "#FECACA",
      Cancelled: "#FED7AA",
      "No Pending Balance": "#FEF08A",
      Errors: "#FCA5A5",
      "Payment Success": "#86EFAC",
      "Payment Failed": "#FCA5A5",
      "Abandoned (Init)": "#FEE2E2",
      "Abandoned (Start)": "#FEE2E2"
    }, a = (s, o) => !o || o === 0 ? "0%" : `${Math.round(s / o * 100)}%`;
    return (s, o) => (L(), O("article", Z6, [
      S("header", K6, [
        S("div", Q6, [
          o[1] || (o[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "Booking Manager Metrics"),
            S("p", { class: "card-subtitle" }, "Booking manager workflow tracking and analysis")
          ], -1)),
          t.loading ? ct("", !0) : (L(), O("div", J6, [
            o[0] || (o[0] = S("p", { class: "badge-label" }, "Payment Success", -1)),
            S("p", t$, F(Z(ut)(t.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      t.loading ? (L(), O("div", e$, [...o[2] || (o[2] = [
        zt('<div class="loading-container" data-v-ee0076af><div class="chart-flow-loader" data-v-ee0076af><div class="flow-line flow-1" data-v-ee0076af></div><div class="flow-line flow-2" data-v-ee0076af></div><div class="flow-line flow-3" data-v-ee0076af></div><div class="flow-line flow-4" data-v-ee0076af></div><div class="flow-line flow-5" data-v-ee0076af></div></div><p class="loading-text" data-v-ee0076af>Loading booking data...</p></div>', 1)
      ])])) : t.error ? (L(), O("div", i$, [
        S("div", n$, [
          o[3] || (o[3] = S("div", { class: "error-icon-wrapper" }, [
            S("svg", {
              class: "error-icon",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
            }, [
              S("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              })
            ])
          ], -1)),
          o[4] || (o[4] = S("p", { class: "error-title" }, "Error loading data", -1)),
          S("p", r$, F(t.error), 1)
        ])
      ])) : (L(), O("div", a$, [
        S("section", s$, [
          S("div", o$, [
            Ze(fs, {
              data: n.value,
              "node-colors": r,
              height: "500px",
              "node-gap": 15
            }, null, 8, ["data"])
          ])
        ]),
        i.value.length > 0 ? (L(), O("section", l$, [
          o[6] || (o[6] = S("div", { class: "section-header" }, [
            S("h4", { class: "section-title" }, "Daily Overview")
          ], -1)),
          S("div", u$, [
            S("table", c$, [
              o[5] || (o[5] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Initiated"),
                  S("th", { class: "table-header" }, "Started"),
                  S("th", { class: "table-header" }, "Payment Initiated"),
                  S("th", { class: "table-header" }, "Payment Results"),
                  S("th", { class: "table-header" }, "Outcomes")
                ])
              ], -1)),
              S("tbody", h$, [
                (L(!0), O(Nt, null, ve(i.value, (l) => (L(), O("tr", {
                  key: l.date,
                  class: "table-row"
                }, [
                  S("td", f$, F(Z(V)(l.date).format("DD/MM/YYYY")), 1),
                  S("td", d$, F(Z(ut)(l.booking_initiated_count)), 1),
                  S("td", v$, [
                    vu(F(Z(ut)(l.booking_started_count)) + " ", 1),
                    S("span", p$, " (" + F(a(l.booking_started_count, l.booking_initiated_count)) + ") ", 1)
                  ]),
                  S("td", g$, F(Z(ut)(l.payment_initiated_count)), 1),
                  S("td", m$, [
                    S("div", y$, [
                      S("span", _$, " Success: " + F(l.payment_success_count ? Z(ut)(l.payment_success_count) : "N/A"), 1),
                      S("span", b$, " Failed: " + F(l.payment_failed_count ? Z(ut)(l.payment_failed_count) : "N/A"), 1)
                    ])
                  ]),
                  S("td", x$, [
                    S("div", w$, [
                      S("span", S$, " Not Found: " + F(l.not_found_count ? Z(ut)(l.not_found_count) : "N/A"), 1),
                      S("span", M$, " Cancelled: " + F(l.cancelled_count ? Z(ut)(l.cancelled_count) : "N/A"), 1),
                      S("span", T$, " No Balance: " + F(l.no_pending_balance_count ? Z(ut)(l.no_pending_balance_count) : "N/A"), 1),
                      S("span", D$, " Errors: " + F(l.error_count ? Z(ut)(l.error_count) : "N/A"), 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (L(), O("section", C$, [...o[7] || (o[7] = [
          zt('<div class="empty-state-content" data-v-ee0076af><div class="empty-icon-wrapper" data-v-ee0076af><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-ee0076af><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" data-v-ee0076af></path></svg></div><p class="empty-title" data-v-ee0076af>No booking manager data available</p><p class="empty-description" data-v-ee0076af>No booking manager data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), P$ = /* @__PURE__ */ fe(k$, [["__scopeId", "data-v-ee0076af"]]), A$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: P$
}, Symbol.toStringTag, { value: "Module" })), E$ = { class: "checkin-metrics-card" }, L$ = {
  key: 0,
  class: "loading-state"
}, O$ = {
  key: 1,
  class: "card-body"
}, I$ = {
  key: 0,
  class: "chart-section"
}, R$ = { class: "chart-wrapper" }, N$ = {
  key: 1,
  class: "table-section"
}, F$ = { class: "table-wrapper" }, B$ = { class: "data-table" }, z$ = { class: "table-body" }, V$ = { class: "table-cell font-medium" }, $$ = { class: "table-cell text-center" }, H$ = { class: "table-cell text-center" }, Y$ = { class: "table-cell text-center" }, W$ = { class: "table-cell text-center" }, U$ = { class: "table-cell text-center" }, G$ = { class: "table-cell text-center" }, j$ = { class: "table-cell text-left" }, X$ = {
  key: 0,
  class: "failed-steps"
}, q$ = { class: "step-name" }, Z$ = { class: "step-count" }, K$ = {
  key: 1,
  class: "empty-cell"
}, Q$ = {
  key: 2,
  class: "empty-state"
}, J$ = {
  __name: "Checkin",
  props: {
    loading: {
      type: Boolean,
      default: !1
    },
    checkinData: {
      type: Object,
      default: () => ({
        total_checkin_init: 0,
        total_checkin_initiated: 0,
        total_checkin_init_abandoned: 0,
        total_checkin_started: 0,
        total_checkin_completed: 0,
        total_checkin_closed: 0,
        total_checkin_unrecovered: 0,
        checkin_by_day: []
      })
    },
    failedData: {
      type: Object,
      default: () => ({
        total_checkin_failed: 0,
        failed_by_step_by_day: [],
        unrecovered_by_step: []
      })
    }
  },
  setup(e) {
    const t = e, i = {
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }, n = {
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }, r = wi([]), a = J(() => t.checkinData ?? i), s = J(() => t.failedData ?? n), o = J(() => {
      const d = {
        // Main flow progression - from blue to purple to green
        "Checkin Init": "#93C5FD",
        // Blue for started state
        "Booking retrive": "#C7D2FE",
        // Light purple
        "Booking retrive success": "#A5B4FC",
        // Medium purple for success
        "Number of Passengers": "#8B8CF6",
        // Medium purple
        Completed: "#A7F3D0",
        // Light green
        "Closed with BP": "#7BE39E",
        // Green for success
        // Abandoned states - progressive yellow/orange
        "Abandoned (Init)": "#FCA5A5",
        // Light red
        "Abandoned (Started)": "#F87171",
        // Medium red
        "Abandoned (Flow)": "#EF4444",
        // Darker red
        "BP Error": "#EF4444",
        // Darker red for boarding pass error
        // Failed states - progressive red intensity
        Unrecovered: "#F87171"
        // Medium red for main unrecovered node
      };
      return (s.value.unrecovered_by_step || []).forEach((g) => {
        const m = g.step_name.replace(/_/g, " ").split(" ").map((_) => _.charAt(0).toUpperCase() + _.slice(1)).join(" "), y = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        d[m] = y[m] || "#DC2626";
      }), d;
    }), l = (d, v) => !v || v === 0 ? "0%" : `${Math.round(d / v * 100)}%`, u = (d, v) => {
      const g = ut(d), p = l(d, v);
      return `${g} (${p})`;
    }, c = (d) => d.reduce((v, g) => v + g.failed_count, 0), h = J(() => {
      const d = [], v = [];
      if (!a.value.total_checkin_initiated)
        return { nodes: d, links: v };
      d.push({ name: "Checkin Init" }), d.push({ name: "Booking retrive" }), d.push({ name: "Booking retrive success" }), d.push({ name: "Number of Passengers" }), d.push({ name: "Completed" }), d.push({ name: "Closed with BP" });
      const g = a.value.total_checkin_initiated, p = a.value.total_checkin_init, m = a.value.total_checkin_init_abandoned, y = p - m, _ = a.value.total_checkin_started, b = a.value.total_checkin_completed, x = a.value.total_checkin_closed, w = s.value.unrecovered_by_step || [], M = w.reduce((C, A) => C + A.count, 0);
      if (console.log(JSON.stringify(a.value)), p > 0) {
        const C = Math.round(p / g * 100);
        v.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: p,
          label: `${p.toLocaleString()} (${C}%)`
        });
      }
      const T = g - p;
      if (T > 0) {
        const C = Math.round(T / g * 100);
        d.push({ name: "Abandoned (Init)" }), v.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: T,
          label: `${T.toLocaleString()} (${C}%)`
        });
      }
      if (m > 0) {
        const C = Math.round(m / g * 100);
        d.push({ name: "Abandoned (Started)" }), v.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: m,
          label: `${m.toLocaleString()} (${C}%)`
        });
      }
      if (y > 0) {
        const C = Math.round(y / g * 100);
        v.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: y,
          label: `${y.toLocaleString()} (${C}%)`
        });
      }
      if (_ > 0) {
        const C = Math.round(_ / g * 100);
        v.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: _,
          label: `${_.toLocaleString()} (${C}%)`
        });
      }
      if (b > 0) {
        const C = Math.round(b / _ * 100);
        v.push({
          source: "Number of Passengers",
          target: "Completed",
          value: b,
          label: `${b.toLocaleString()} (${C}%)`
        });
      }
      if (w.length > 0 && M > 0) {
        d.push({ name: "Unrecovered" });
        const C = Math.round(M / _ * 100);
        v.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: M,
          label: `${M.toLocaleString()} (${C}%)`
        }), w.forEach((A) => {
          const R = A.step_name.replace(/_/g, " ").split(" ").map((N) => N.charAt(0).toUpperCase() + N.slice(1)).join(" "), I = Math.round(A.count / _ * 100);
          d.push({ name: R }), v.push({
            source: "Unrecovered",
            target: R,
            value: A.count,
            label: `${A.count.toLocaleString()} (${I}%)`
          });
        });
      }
      const D = _ - (b + M);
      if (D > 0) {
        const C = Math.round(D / _ * 100);
        d.push({ name: "Abandoned (Flow)" }), v.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: D,
          label: `${D.toLocaleString()} (${C}%)`
        });
      }
      const P = b - x;
      if (P > 0) {
        const C = Math.round(P / _ * 100);
        d.push({ name: "BP Error" }), v.push({
          source: "Completed",
          target: "BP Error",
          value: P,
          label: `${P.toLocaleString()} (${C}%)`
        });
      }
      if (x > 0) {
        const C = Math.round(x / _ * 100);
        v.push({
          source: "Completed",
          target: "Closed with BP",
          value: x,
          label: `${x.toLocaleString()} (${C}%)`
        });
      }
      return console.log(JSON.stringify(d)), console.log(JSON.stringify(v)), { nodes: d, links: v };
    }), f = () => {
      const d = a.value.checkin_by_day || [], v = s.value.failed_by_step_by_day || [];
      if (d.length === 0) {
        r.value = [];
        return;
      }
      r.value = [...d].map((g) => {
        const p = v.find(
          (m) => m.date === g.date
        );
        return {
          ...g,
          failed_steps: p?.steps || []
        };
      }), r.value.sort((g, p) => new Date(g.date) - new Date(p.date));
    };
    return watch(
      [() => t.checkinData, () => t.failedData],
      () => {
        f();
      },
      { deep: !0, immediate: !0 }
    ), (d, v) => (L(), O("article", E$, [
      v[3] || (v[3] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Check-in Metrics"),
          S("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      t.loading ? (L(), O("div", L$, [...v[0] || (v[0] = [
        zt('<div class="loading-container" data-v-b80e5719><div class="chart-flow-loader" data-v-b80e5719><div class="flow-line flow-1" data-v-b80e5719></div><div class="flow-line flow-2" data-v-b80e5719></div><div class="flow-line flow-3" data-v-b80e5719></div><div class="flow-line flow-4" data-v-b80e5719></div><div class="flow-line flow-5" data-v-b80e5719></div></div><p class="loading-text" data-v-b80e5719>Loading check-in data...</p></div>', 1)
      ])])) : (L(), O("div", O$, [
        h.value.nodes.length > 0 ? (L(), O("section", I$, [
          S("div", R$, [
            Ze(fs, {
              data: h.value,
              height: "500px",
              "node-colors": o.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : ct("", !0),
        r.value && r.value.length > 0 ? (L(), O("section", N$, [
          S("div", F$, [
            S("table", B$, [
              v[1] || (v[1] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Checkin Init"),
                  S("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  S("th", { class: "table-header" }, "Number of Passengers"),
                  S("th", { class: "table-header" }, "Completed (%)"),
                  S("th", { class: "table-header" }, "Closed with BP (%)"),
                  S("th", { class: "table-header" }, "Failed (%)"),
                  S("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              S("tbody", z$, [
                (L(!0), O(Nt, null, ve(r.value, (g) => (L(), O("tr", {
                  key: g.date,
                  class: "table-row"
                }, [
                  S("td", V$, F(Z(V)(g.date).format("DD/MM/YYYY")), 1),
                  S("td", $$, F(Z(ut)(g.checkin_initiated_count)), 1),
                  S("td", H$, F(u(g.checkin_init_count, g.checkin_initiated_count)), 1),
                  S("td", Y$, F(Z(ut)(g.checkin_started_count)), 1),
                  S("td", W$, F(u(g.checkin_completed_count, g.checkin_started_count)), 1),
                  S("td", U$, F(u(g.checkin_closed_count, g.checkin_started_count)), 1),
                  S("td", G$, F(u(c(g.failed_steps), g.checkin_started_count)), 1),
                  S("td", j$, [
                    g.failed_steps && g.failed_steps.length > 0 ? (L(), O("div", X$, [
                      (L(!0), O(Nt, null, ve(g.failed_steps, (p) => (L(), O("div", {
                        key: p.step_name,
                        class: "failed-step-item"
                      }, [
                        S("span", q$, F(p.step_name.replace(/_/g, " ")) + ":", 1),
                        S("span", Z$, F(p.failed_count), 1)
                      ]))), 128))
                    ])) : (L(), O("div", K$, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (L(), O("section", Q$, [...v[2] || (v[2] = [
          zt('<div class="empty-state-content" data-v-b80e5719><div class="empty-icon-wrapper" data-v-b80e5719><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-b80e5719><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-b80e5719></path></svg></div><p class="empty-title" data-v-b80e5719>No check-in data available</p><p class="empty-description" data-v-b80e5719>Try adjusting the date range or check your filters to see check-in performance data.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}, tH = /* @__PURE__ */ fe(J$, [["__scopeId", "data-v-b80e5719"]]), eH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: tH
}, Symbol.toStringTag, { value: "Module" })), iH = { class: "checkin-segments-card" }, nH = {
  key: 0,
  class: "loading-state"
}, rH = {
  key: 1,
  class: "card-body"
}, aH = {
  key: 0,
  class: "table-section"
}, sH = { class: "table-wrapper" }, oH = { class: "data-table" }, lH = { class: "table-body" }, uH = { class: "table-cell font-medium text-center" }, cH = { class: "airport-badge" }, hH = { class: "table-cell text-center" }, fH = {
  key: 0,
  class: "airport-badge connection"
}, dH = {
  key: 1,
  class: "empty-connection"
}, vH = { class: "table-cell text-center" }, pH = { class: "airport-badge" }, gH = { class: "table-cell text-center" }, mH = {
  key: 0,
  class: "trip-badge roundtrip"
}, yH = {
  key: 1,
  class: "trip-badge oneway"
}, _H = { class: "table-cell text-center" }, bH = { class: "table-cell text-center" }, xH = { class: "percentage-value" }, wH = { class: "table-cell text-center" }, SH = { class: "percentage-value" }, MH = { class: "table-cell text-center" }, TH = { class: "percentage-value success" }, DH = {
  key: 1,
  class: "empty-state"
}, CH = /* @__PURE__ */ Te({
  __name: "checkinSegments",
  props: {
    data: { default: () => [] },
    loading: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, i = (a, s) => !s || s === 0 || !a ? "0%" : `${Math.round(a / s * 100)}%`, n = (a) => !a || a === "None" ? "-" : String(a).trim().replace(/_[0-9]+$/i, ""), r = (a) => {
      const s = n(a?.departure_airport), o = n(a?.arrival_airport);
      return s === "-" || o === "-" ? !1 : s === o;
    };
    return (a, s) => (L(), O("article", iH, [
      s[5] || (s[5] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Checkin Segments"),
          S("p", { class: "card-subtitle" }, "Breakdown by flight segment with connection when applicable")
        ])
      ], -1)),
      t.loading ? (L(), O("div", nH, [...s[0] || (s[0] = [
        zt('<div class="loading-container" data-v-aaf02208><div class="chart-flow-loader" data-v-aaf02208><div class="flow-line flow-1" data-v-aaf02208></div><div class="flow-line flow-2" data-v-aaf02208></div><div class="flow-line flow-3" data-v-aaf02208></div><div class="flow-line flow-4" data-v-aaf02208></div><div class="flow-line flow-5" data-v-aaf02208></div></div><p class="loading-text" data-v-aaf02208>Loading segment data...</p></div>', 1)
      ])])) : (L(), O("div", rH, [
        t.data.length > 0 ? (L(), O("section", aH, [
          S("div", sH, [
            S("table", oH, [
              s[3] || (s[3] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Departure"),
                  S("th", { class: "table-header" }, "Connection"),
                  S("th", { class: "table-header" }, "Arrival"),
                  S("th", { class: "table-header" }, "Trip"),
                  S("th", { class: "table-header" }, "Init"),
                  S("th", { class: "table-header" }, "Started (%)"),
                  S("th", { class: "table-header" }, "Completed (%)"),
                  S("th", { class: "table-header" }, "Closed (%)")
                ])
              ], -1)),
              S("tbody", lH, [
                (L(!0), O(Nt, null, ve(t.data, (o, l) => (L(), O("tr", {
                  key: l,
                  class: "table-row"
                }, [
                  S("td", uH, [
                    S("span", cH, F(n(o.departure_airport)), 1)
                  ]),
                  S("td", hH, [
                    n(o.conexion_airport) !== "-" ? (L(), O("span", fH, F(n(o.conexion_airport)), 1)) : (L(), O("span", dH, "-"))
                  ]),
                  S("td", vH, [
                    S("span", pH, F(n(o.arrival_airport)), 1)
                  ]),
                  S("td", gH, [
                    r(o) ? (L(), O("span", mH, [...s[1] || (s[1] = [
                      S("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        S("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                        })
                      ], -1),
                      vu(" Roundtrip ", -1)
                    ])])) : (L(), O("span", yH, [...s[2] || (s[2] = [
                      S("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        S("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M14 5l7 7m0 0l-7 7m7-7H3"
                        })
                      ], -1),
                      vu(" One way ", -1)
                    ])]))
                  ]),
                  S("td", _H, F(Z(ut)(o.segment_init_count)), 1),
                  S("td", bH, [
                    S("span", xH, F(i(o.segment_started_count, o.segment_init_count)), 1)
                  ]),
                  S("td", wH, [
                    S("span", SH, F(i(o.segment_completed_count, o.segment_init_count)), 1)
                  ]),
                  S("td", MH, [
                    S("span", TH, F(i(o.segment_closed_count, o.segment_init_count)), 1)
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (L(), O("section", DH, [...s[4] || (s[4] = [
          zt('<div class="empty-state-content" data-v-aaf02208><div class="empty-icon-wrapper" data-v-aaf02208><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-aaf02208><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-aaf02208></path></svg></div><p class="empty-title" data-v-aaf02208>No segment data available</p><p class="empty-description" data-v-aaf02208>No flight segment data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), kH = /* @__PURE__ */ fe(CH, [["__scopeId", "data-v-aaf02208"]]), PH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: kH
}, Symbol.toStringTag, { value: "Module" })), AH = { class: "disruption-metrics-card" }, EH = { class: "card-header" }, LH = { class: "header-content" }, OH = {
  key: 0,
  class: "payment-success-badge"
}, IH = { class: "badge-value" }, RH = {
  key: 0,
  class: "loading-state"
}, NH = {
  key: 1,
  class: "card-body"
}, FH = { class: "chart-section" }, BH = { class: "chart-wrapper" }, zH = {
  key: 1,
  class: "empty-chart"
}, VH = {
  key: 0,
  class: "table-section"
}, $H = { class: "table-wrapper" }, HH = { class: "data-table" }, YH = { class: "table-body" }, WH = { class: "table-cell font-medium text-center" }, UH = { class: "table-cell text-center" }, GH = { class: "table-cell text-center" }, jH = { class: "percentage-text" }, XH = { class: "table-cell text-center" }, qH = { class: "abandoned-value" }, ZH = { class: "table-cell" }, KH = { class: "badges-container badges-wrap" }, QH = { class: "badge badge-vol" }, JH = { class: "badge badge-confirm" }, tY = { class: "badge badge-not-confirm" }, eY = { class: "badge badge-reject" }, iY = { class: "badge badge-not-paid" }, nY = { class: "badge badge-success" }, rY = { class: "table-cell" }, aY = { class: "badges-container badges-wrap" }, sY = { class: "badge badge-inv" }, oY = { class: "badge badge-human" }, lY = { class: "badge badge-accept" }, uY = {
  key: 1,
  class: "empty-state"
}, cY = /* @__PURE__ */ Te({
  __name: "Disruption",
  props: {
    data: { default: () => ({
      total_disruption_conversations: 0,
      total_disruption_initiated: 0,
      total_voluntary: 0,
      total_involuntary: 0,
      total_accepted: 0,
      total_confirmed: 0,
      total_sell_success: 0,
      total_sell_failed: 0,
      total_finished: 0,
      total_payment_success: 0,
      disruption_by_day: []
    }) },
    loading: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, i = J(() => t.data?.disruption_by_day ? [...t.data.disruption_by_day].sort(
      (s, o) => new Date(s.date).getTime() - new Date(o.date).getTime()
    ) : []), n = (s, o) => !o || o === 0 ? "0%" : `${Math.round(s / o * 100)}%`, r = J(() => {
      const s = t.data, o = s.total_disruption_conversations || 0, l = s.total_disruption_initiated || 0, u = s.total_voluntary || 0, c = s.total_involuntary || 0, h = s.total_accepted || 0, f = s.total_confirmed || 0, d = s.total_sell_success || 0, v = s.total_sell_failed || 0, g = Math.max(0, o - l), p = Math.max(0, l - u - c), m = Math.max(0, c - h), y = Math.max(0, u - f), _ = v, b = Math.max(0, f - d - _), x = (T, D) => {
        const P = D > 0 ? Math.round(T / D * 100) : 0;
        return `${T.toLocaleString()} (${P}%)`;
      }, w = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Voluntary" },
        { name: "Confirmed" },
        { name: "Paid" },
        { name: "Not Paid" },
        { name: "Rejected" },
        { name: "Not Confirmed" },
        { name: "Involuntary" },
        { name: "Accepted" },
        { name: "Redirect to Human" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], M = [];
      return l > 0 && M.push({
        source: "Initiated",
        target: "Started",
        value: l,
        label: x(l, o)
      }), g > 0 && M.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: g,
        label: x(g, o)
      }), u > 0 && M.push({
        source: "Started",
        target: "Voluntary",
        value: u,
        label: x(u, o)
      }), c > 0 && M.push({
        source: "Started",
        target: "Involuntary",
        value: c,
        label: x(c, o)
      }), p > 0 && M.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: p,
        label: x(p, o)
      }), h > 0 && M.push({
        source: "Involuntary",
        target: "Accepted",
        value: h,
        label: x(h, o)
      }), m > 0 && M.push({
        source: "Involuntary",
        target: "Redirect to Human",
        value: m,
        label: x(m, o)
      }), f > 0 && M.push({
        source: "Voluntary",
        target: "Confirmed",
        value: f,
        label: x(f, o)
      }), y > 0 && M.push({
        source: "Voluntary",
        target: "Not Confirmed",
        value: y,
        label: x(y, o)
      }), d > 0 && M.push({
        source: "Confirmed",
        target: "Paid",
        value: d,
        label: x(d, o)
      }), _ > 0 && M.push({
        source: "Confirmed",
        target: "Rejected",
        value: _,
        label: x(_, o)
      }), b > 0 && M.push({
        source: "Confirmed",
        target: "Not Paid",
        value: b,
        label: x(b, o)
      }), { nodes: w, links: M };
    }), a = {
      Initiated: "#E5E7EB",
      Started: "#DBEAFE",
      "Abandoned (Start)": "#FEE2E2",
      Voluntary: "#FED7AA",
      Involuntary: "#E9D5FF",
      "Abandoned (Init)": "#FEE2E2",
      Accepted: "#86EFAC",
      "Redirect to Human": "#FCA5A5",
      Confirmed: "#BFDBFE",
      "Not Confirmed": "#FED7AA",
      Paid: "#86EFAC",
      Rejected: "#FCA5A5",
      "Not Paid": "#FED7AA"
    };
    return (s, o) => (L(), O("article", AH, [
      S("header", EH, [
        S("div", LH, [
          o[1] || (o[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "Disruption Metrics"),
            S("p", { class: "card-subtitle" }, "Disruption workflow performance and completion tracking")
          ], -1)),
          t.loading ? ct("", !0) : (L(), O("div", OH, [
            o[0] || (o[0] = S("p", { class: "badge-label" }, "Payment Success", -1)),
            S("p", IH, F(Z(ut)(t.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      t.loading ? (L(), O("div", RH, [...o[2] || (o[2] = [
        zt('<div class="loading-container" data-v-30893461><div class="chart-bars-loader" data-v-30893461><div class="bar bar-1" data-v-30893461></div><div class="bar bar-2" data-v-30893461></div><div class="bar bar-3" data-v-30893461></div><div class="bar bar-4" data-v-30893461></div><div class="bar bar-5" data-v-30893461></div></div><p class="loading-text" data-v-30893461>Loading disruption data...</p></div>', 1)
      ])])) : (L(), O("div", NH, [
        S("section", FH, [
          S("div", BH, [
            r.value.nodes.length > 0 && r.value.links.length > 0 ? (L(), Y0(fs, {
              key: 0,
              data: r.value,
              "node-colors": a,
              height: "500px"
            }, null, 8, ["data"])) : (L(), O("div", zH, [...o[3] || (o[3] = [
              S("p", { class: "empty-chart-text" }, "No disruption data available for visualization", -1)
            ])]))
          ])
        ]),
        i.value && i.value.length > 0 ? (L(), O("section", VH, [
          o[5] || (o[5] = zt('<div class="section-header" data-v-30893461><h4 class="section-title" data-v-30893461>Daily Overview</h4></div><div class="legend-container" data-v-30893461><p class="legend-title" data-v-30893461>Legend</p><div class="legend-items" data-v-30893461><div class="legend-group" data-v-30893461><span class="legend-label" data-v-30893461>Voluntary:</span><span class="badge badge-vol" data-v-30893461>VOL</span></div><div class="legend-group" data-v-30893461><span class="legend-label" data-v-30893461>Involuntary:</span><span class="badge badge-inv" data-v-30893461>INV</span></div><div class="legend-note" data-v-30893461><span data-v-30893461>Vol=Voluntary</span><span data-v-30893461></span><span data-v-30893461>Inv=Involuntary</span></div></div></div>', 2)),
          S("div", $H, [
            S("table", HH, [
              o[4] || (o[4] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Initiated"),
                  S("th", { class: "table-header" }, "Started"),
                  S("th", { class: "table-header" }, "Abandoned (%)"),
                  S("th", { class: "table-header" }, "Voluntary"),
                  S("th", { class: "table-header" }, "Involuntary")
                ])
              ], -1)),
              S("tbody", YH, [
                (L(!0), O(Nt, null, ve(i.value, (l) => (L(), O("tr", {
                  key: l.date,
                  class: "table-row"
                }, [
                  S("td", WH, F(Z(V)(l.date).format("DD/MM")), 1),
                  S("td", UH, F(Z(ut)(l.disruption_conversations)), 1),
                  S("td", GH, [
                    vu(F(Z(ut)(l.disruption_initiated_count)) + " ", 1),
                    S("span", jH, " (" + F(n(l.disruption_initiated_count, l.disruption_conversations)) + ") ", 1)
                  ]),
                  S("td", XH, [
                    S("span", qH, F(Z(ut)(l.disruption_initiated_count - l.voluntary_count - l.involuntary_count)) + " (" + F(n(l.disruption_initiated_count - l.voluntary_count - l.involuntary_count, l.disruption_conversations)) + ") ", 1)
                  ]),
                  S("td", ZH, [
                    S("div", KH, [
                      S("span", QH, " VOL " + F(Z(ut)(l.voluntary_count)) + " (" + F(n(l.voluntary_count, l.disruption_conversations)) + ") ", 1),
                      S("span", JH, " Confirm " + F(Z(ut)(l.confirmed_count)) + " (" + F(n(l.confirmed_count, l.disruption_conversations)) + ") ", 1),
                      S("span", tY, " Not Confirm " + F(Z(ut)(l.voluntary_count - l.confirmed_count)) + " (" + F(n(l.voluntary_count - l.confirmed_count, l.disruption_conversations)) + ") ", 1),
                      S("span", eY, " Reject " + F(Z(ut)(l.sell_failed_count)) + " (" + F(n(l.sell_failed_count, l.disruption_conversations)) + ") ", 1),
                      S("span", iY, " Not Paid " + F(Z(ut)(Math.max(0, l.confirmed_count - l.sell_success_count - l.sell_failed_count))) + " (" + F(n(Math.max(0, l.confirmed_count - l.sell_success_count - l.sell_failed_count), l.disruption_conversations)) + ") ", 1),
                      S("span", nY, " Finish " + F(Z(ut)(l.sell_success_count)) + " (" + F(n(l.sell_success_count, l.disruption_conversations)) + ") ", 1)
                    ])
                  ]),
                  S("td", rY, [
                    S("div", aY, [
                      S("span", sY, " INV " + F(Z(ut)(l.involuntary_count)) + " (" + F(n(l.involuntary_count, l.disruption_conversations)) + ") ", 1),
                      S("span", oY, " Human " + F(Z(ut)(l.involuntary_count - l.accepted_count)) + " (" + F(n(l.involuntary_count - l.accepted_count, l.disruption_conversations)) + ") ", 1),
                      S("span", lY, " Accept " + F(Z(ut)(l.accepted_count)) + " (" + F(n(l.accepted_count, l.disruption_conversations)) + ") ", 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (L(), O("section", uY, [...o[6] || (o[6] = [
          zt('<div class="empty-state-content" data-v-30893461><div class="empty-icon-wrapper" data-v-30893461><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-30893461><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" data-v-30893461></path></svg></div><p class="empty-title" data-v-30893461>No disruption data available</p><p class="empty-description" data-v-30893461>No disruption data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), hY = /* @__PURE__ */ fe(cY, [["__scopeId", "data-v-30893461"]]), fY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: hY
}, Symbol.toStringTag, { value: "Module" })), dY = { class: "faq-metrics-card" }, vY = {
  key: 0,
  class: "card-body"
}, pY = { class: "kpi-grid" }, gY = { class: "kpi-card kpi-purple" }, mY = { class: "kpi-value" }, yY = { class: "kpi-card kpi-blue" }, _Y = { class: "kpi-value" }, bY = { class: "kpi-card kpi-green" }, xY = { class: "kpi-value" }, wY = { class: "kpi-card kpi-orange" }, SY = { class: "kpi-value" }, MY = { class: "kpi-card kpi-cyan" }, TY = { class: "kpi-value" }, DY = {
  key: 0,
  class: "chart-section"
}, CY = {
  key: 1,
  class: "empty-state"
}, kY = {
  key: 1,
  class: "loading-state"
}, PY = /* @__PURE__ */ Te({
  __name: "FAQ",
  props: {
    loading: { type: Boolean, default: !1 },
    data: { default: null }
  },
  setup(e) {
    const t = e, i = wi({ labels: [], datasets: [] }), n = J(() => t.data ?? {
      total_faq_events: 0,
      total_documents_found: 0,
      total_airline_information_retrieved: 0,
      total_booking_info_retrieved: 0,
      total_flight_status_retrieved: 0,
      faq_by_day: []
    }), r = J(() => ({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12
            }
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: "rgba(255, 255, 255, 0.95)",
          titleColor: "#1e293b",
          bodyColor: "#64748b",
          borderColor: "rgba(0, 0, 0, 0.1)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'Space Grotesk', sans-serif",
            size: 14,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 13
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: "#64748b"
          }
        },
        y: {
          type: "linear",
          display: !0,
          position: "left",
          beginAtZero: !0,
          grid: {
            color: "rgba(0, 0, 0, 0.05)"
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: "#64748b"
          }
        }
      },
      interaction: {
        mode: "nearest",
        axis: "x",
        intersect: !1
      }
    })), a = (s) => {
      if (!s) {
        i.value = { labels: [], datasets: [] };
        return;
      }
      const o = s.faq_by_day || [];
      if (o.length > 0) {
        const l = o.map((f) => V(f.date).format("MMM DD")), u = o.map((f) => f.airline_information_retrieved_count || 0), c = o.map((f) => f.flight_status_retrieved_count || 0), h = o.map((f) => f.booking_info_retrieved_count || 0);
        i.value = {
          labels: l,
          datasets: [
            {
              label: "Airline Information",
              data: u,
              borderColor: "#8b5cf6",
              backgroundColor: "rgba(139, 92, 246, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#8b5cf6",
              pointBorderColor: "#7c3aed",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Flight Status",
              data: c,
              borderColor: "#06b6d4",
              backgroundColor: "rgba(6, 182, 212, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#06b6d4",
              pointBorderColor: "#0891b2",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Booking Information",
              data: h,
              borderColor: "#f59e0b",
              backgroundColor: "rgba(245, 158, 11, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#f59e0b",
              pointBorderColor: "#d97706",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            }
          ]
        };
      } else
        i.value = { labels: [], datasets: [] };
    };
    return qd(
      () => t.data,
      (s) => {
        a(s ?? null);
      },
      { deep: !0, immediate: !0 }
    ), (s, o) => (L(), O("article", dY, [
      o[7] || (o[7] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "FAQ Metrics"),
          S("p", { class: "card-subtitle" }, "Daily FAQ consultation and retrieval metrics")
        ])
      ], -1)),
      t.loading ? (L(), O("div", kY, [...o[6] || (o[6] = [
        zt('<div class="loading-container" data-v-1314368e><div class="chart-bars-loader" data-v-1314368e><div class="bar bar-1" data-v-1314368e></div><div class="bar bar-2" data-v-1314368e></div><div class="bar bar-3" data-v-1314368e></div><div class="bar bar-4" data-v-1314368e></div><div class="bar bar-5" data-v-1314368e></div></div><p class="loading-text" data-v-1314368e>Loading FAQ metrics...</p></div>', 1)
      ])])) : (L(), O("div", vY, [
        S("div", pY, [
          S("div", gY, [
            o[0] || (o[0] = S("p", { class: "kpi-label" }, "Total FAQ", -1)),
            S("p", mY, F(Z(ut)(n.value.total_faq_events)), 1)
          ]),
          S("div", yY, [
            o[1] || (o[1] = S("p", { class: "kpi-label" }, "Documents Found", -1)),
            S("p", _Y, F(Z(ut)(n.value.total_documents_found)), 1)
          ]),
          S("div", bY, [
            o[2] || (o[2] = S("p", { class: "kpi-label" }, "Airline Info", -1)),
            S("p", xY, F(Z(ut)(n.value.total_airline_information_retrieved)), 1)
          ]),
          S("div", wY, [
            o[3] || (o[3] = S("p", { class: "kpi-label" }, "Booking Info", -1)),
            S("p", SY, F(Z(ut)(n.value.total_booking_info_retrieved)), 1)
          ]),
          S("div", MY, [
            o[4] || (o[4] = S("p", { class: "kpi-label" }, "Flight Status", -1)),
            S("p", TY, F(Z(ut)(n.value.total_flight_status_retrieved)), 1)
          ])
        ]),
        i.value.labels && i.value.labels.length ? (L(), O("section", DY, [
          Ze(vv, {
            data: i.value,
            options: r.value
          }, null, 8, ["data", "options"])
        ])) : (L(), O("section", CY, [...o[5] || (o[5] = [
          zt('<div class="empty-state-content" data-v-1314368e><div class="empty-icon-wrapper" data-v-1314368e><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-1314368e><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" data-v-1314368e></path></svg></div><p class="empty-title" data-v-1314368e>No FAQ data available</p><p class="empty-description" data-v-1314368e>No FAQ consultation data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), AY = /* @__PURE__ */ fe(PY, [["__scopeId", "data-v-1314368e"]]), EY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: AY
}, Symbol.toStringTag, { value: "Module" }));
function LY(e, t) {
  return L(), O("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    S("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z"
    })
  ]);
}
const OY = { class: "messages-per-agent-card" }, IY = {
  key: 0,
  class: "card-body"
}, RY = {
  key: 0,
  class: "chart-section"
}, NY = {
  key: 1,
  class: "empty-state"
}, FY = { class: "empty-state-content" }, BY = { class: "empty-icon-wrapper" }, zY = {
  key: 1,
  class: "loading-state"
}, VY = /* @__PURE__ */ Te({
  __name: "MessagesPerAgent",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 }
  },
  setup(e) {
    const t = {
      checkin: "#3B82F680",
      faq: "#EF444480",
      disruption_manager: "#F59E0B80",
      booking_manager: "#a78bfa80",
      triage: "#10B98180",
      seller: "#06B6D480",
      human: "#F472B680",
      agency: "#6366F180",
      loyalty: "#EAB30880"
    }, i = e, n = J(() => {
      const a = i.data?.agents_by_day || {}, s = Object.keys(a).sort();
      if (s.length === 0)
        return { labels: [], datasets: [] };
      const o = /* @__PURE__ */ new Set();
      for (const c of Object.values(a))
        for (const h of Object.keys(c))
          o.add(h);
      const u = Array.from(o).map((c) => ({
        label: c,
        data: s.map((h) => a[h]?.[c] || 0),
        borderColor: t[c] || "gray",
        tension: 0.3
      }));
      return {
        labels: s,
        datasets: u
      };
    }), r = J(() => i.options);
    return (a, s) => (L(), O("article", OY, [
      s[3] || (s[3] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Messages per Agent"),
          S("p", { class: "card-subtitle" }, "Agent interaction trends over time")
        ])
      ], -1)),
      e.loading ? (L(), O("div", zY, [...s[2] || (s[2] = [
        zt('<div class="loading-container" data-v-b7597778><div class="chart-lines-loader" data-v-b7597778><div class="line line-1" data-v-b7597778></div><div class="line line-2" data-v-b7597778></div><div class="line line-3" data-v-b7597778></div><div class="line line-4" data-v-b7597778></div><div class="line line-5" data-v-b7597778></div></div><p class="loading-text" data-v-b7597778>Loading chart data...</p></div>', 1)
      ])])) : (L(), O("div", IY, [
        n.value.labels && n.value.labels.length ? (L(), O("section", RY, [
          Ze(vv, {
            data: n.value,
            options: r.value
          }, null, 8, ["data", "options"])
        ])) : (L(), O("section", NY, [
          S("div", FY, [
            S("div", BY, [
              Ze(Z(LY), { class: "empty-icon" })
            ]),
            s[0] || (s[0] = S("p", { class: "empty-title" }, "No agent interactions data", -1)),
            s[1] || (s[1] = S("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), $Y = /* @__PURE__ */ fe(VY, [["__scopeId", "data-v-b7597778"]]), HY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $Y
}, Symbol.toStringTag, { value: "Module" })), YY = { class: "record-locator-card" }, WY = {
  key: 0,
  class: "loading-state"
}, UY = {
  key: 1,
  class: "card-body"
}, GY = {
  key: 0,
  class: "chart-section"
}, jY = { class: "chart-wrapper" }, XY = {
  key: 1,
  class: "table-section"
}, qY = { class: "table-wrapper" }, ZY = { class: "data-table" }, KY = { class: "table-header-row" }, QY = {
  key: 0,
  class: "table-header"
}, JY = {
  key: 1,
  class: "table-header"
}, t8 = { class: "table-body" }, e8 = { class: "table-cell font-medium" }, i8 = { class: "table-cell text-center" }, n8 = { class: "table-cell text-center" }, r8 = { class: "table-cell text-center" }, a8 = { class: "table-cell text-center" }, s8 = { class: "table-cell text-center success-value" }, o8 = { class: "table-cell text-center failed-value" }, l8 = { class: "table-cell text-center warning-value" }, u8 = {
  key: 0,
  class: "table-cell text-center"
}, c8 = {
  key: 1,
  class: "table-cell text-center failed-value"
}, h8 = {
  key: 2,
  class: "empty-state"
}, f8 = /* @__PURE__ */ Te({
  __name: "RecordLocator",
  props: {
    data: { default: () => ({
      total_checkin_initiated: 0,
      total_record_locator_init: 0,
      total_record_locator_started: 0,
      total_record_locator_completed: 0,
      total_record_locator_closed: 0,
      total_record_locator_failed: 0,
      total_record_locator_abandoned: 0,
      total_record_locator_init_abandoned: 0,
      record_locator_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    isAvianca: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, i = J(() => t.data?.record_locator_by_day ? [...t.data.record_locator_by_day].sort(
      (l, u) => new Date(l.date).getTime() - new Date(u.date).getTime()
    ) : []), n = J(() => t.data), r = J(() => ({
      // Main flow progression - from blue to cyan to green
      "Checkin Init": "#93C5FD",
      // Blue for started state
      "Booking retrive": "#67E8F9",
      // Light cyan
      "Checkin Started": "#22D3EE",
      // Medium cyan
      "Checkin Completed": "#A7F3D0",
      // Light green
      "Checkin Closed": "#7BE39E",
      // Green for success
      // Abandoned states - progressive red
      "Abandoned (Init)": "#FCA5A5",
      // Light red
      "Abandoned (Started)": "#F87171",
      // Medium red
      "Abandoned (Flow)": "#EF4444",
      // Darker red
      // Failed states
      "Checkin Failed": "#F87171"
      // Medium red for main failed node
    })), a = (l, u) => !u || u === 0 ? "0%" : `${Math.round(l / u * 100)}%`, s = (l, u) => {
      const c = ut(l), h = a(l, u);
      return `${c} (${h})`;
    }, o = J(() => {
      const l = [], u = [];
      if (!n.value.total_checkin_initiated)
        return { nodes: l, links: u };
      l.push({ name: "Checkin Init" }), l.push({ name: "Booking retrive" }), l.push({ name: "Checkin Started" }), l.push({ name: "Checkin Completed" }), l.push({ name: "Checkin Closed" });
      const c = n.value.total_checkin_initiated, h = n.value.total_record_locator_init, f = n.value.total_record_locator_started, d = n.value.total_record_locator_completed, v = n.value.total_record_locator_closed, g = n.value.total_record_locator_failed, p = n.value.total_record_locator_abandoned, m = n.value.total_record_locator_init_abandoned;
      if (h > 0) {
        const _ = Math.round(h / c * 100);
        u.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: h,
          label: `${h.toLocaleString()} (${_}%)`
        });
      }
      const y = c - h;
      if (y > 0) {
        const _ = Math.round(y / c * 100);
        l.push({ name: "Abandoned (Init)" }), u.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: y,
          label: `${y.toLocaleString()} (${_}%)`
        });
      }
      if (f > 0) {
        const _ = Math.round(f / c * 100);
        u.push({
          source: "Booking retrive",
          target: "Checkin Started",
          value: f,
          label: `${f.toLocaleString()} (${_}%)`
        });
      }
      if (m > 0) {
        const _ = Math.round(m / c * 100);
        l.push({ name: "Abandoned (Started)" }), u.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: m,
          label: `${m.toLocaleString()} (${_}%)`
        });
      }
      if (d > 0) {
        const _ = Math.round(d / f * 100);
        u.push({
          source: "Checkin Started",
          target: "Checkin Completed",
          value: d,
          label: `${d.toLocaleString()} (${_}%)`
        });
      }
      if (v > 0) {
        const _ = Math.round(v / f * 100);
        u.push({
          source: "Checkin Completed",
          target: "Checkin Closed",
          value: v,
          label: `${v.toLocaleString()} (${_}%)`
        });
      }
      if (g > 0) {
        const _ = Math.round(g / f * 100);
        l.push({ name: "Checkin Failed" }), u.push({
          source: "Checkin Started",
          target: "Checkin Failed",
          value: g,
          label: `${g.toLocaleString()} (${_}%)`
        });
      }
      if (p > 0) {
        const _ = Math.round(p / f * 100);
        l.push({ name: "Abandoned (Flow)" }), u.push({
          source: "Checkin Started",
          target: "Abandoned (Flow)",
          value: p,
          label: `${p.toLocaleString()} (${_}%)`
        });
      }
      return { nodes: l, links: u };
    });
    return (l, u) => (L(), O("article", YY, [
      u[10] || (u[10] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Checkin by Record Locator Metrics"),
          S("p", { class: "card-subtitle" }, "Checkin by record locator retrieval and completion analysis")
        ])
      ], -1)),
      t.loading ? (L(), O("div", WY, [...u[0] || (u[0] = [
        zt('<div class="loading-container" data-v-13f9abf0><div class="chart-flow-loader" data-v-13f9abf0><div class="flow-line flow-1" data-v-13f9abf0></div><div class="flow-line flow-2" data-v-13f9abf0></div><div class="flow-line flow-3" data-v-13f9abf0></div><div class="flow-line flow-4" data-v-13f9abf0></div><div class="flow-line flow-5" data-v-13f9abf0></div></div><p class="loading-text" data-v-13f9abf0>Loading record locator data...</p></div>', 1)
      ])])) : (L(), O("div", UY, [
        o.value.nodes.length > 0 ? (L(), O("section", GY, [
          S("div", jY, [
            Ze(fs, {
              data: o.value,
              height: "500px",
              "node-colors": r.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : ct("", !0),
        i.value && i.value.length > 0 ? (L(), O("section", XY, [
          S("div", qY, [
            S("table", ZY, [
              S("thead", null, [
                S("tr", KY, [
                  u[1] || (u[1] = S("th", { class: "table-header" }, "Date", -1)),
                  u[2] || (u[2] = S("th", { class: "table-header" }, "Checkin Init", -1)),
                  u[3] || (u[3] = S("th", { class: "table-header" }, "Booking Retrieve (%)", -1)),
                  u[4] || (u[4] = S("th", { class: "table-header" }, "Checkin Started", -1)),
                  u[5] || (u[5] = S("th", { class: "table-header" }, "Checkin Completed (%)", -1)),
                  u[6] || (u[6] = S("th", { class: "table-header" }, "Checkin Closed (%)", -1)),
                  u[7] || (u[7] = S("th", { class: "table-header" }, "Checkin Failed (%)", -1)),
                  u[8] || (u[8] = S("th", { class: "table-header" }, "Abandoned (%)", -1)),
                  t.isAvianca ? (L(), O("th", QY, "Create Payment")) : ct("", !0),
                  t.isAvianca ? (L(), O("th", JY, "Failed Payment")) : ct("", !0)
                ])
              ]),
              S("tbody", t8, [
                (L(!0), O(Nt, null, ve(i.value, (c) => (L(), O("tr", {
                  key: c.date,
                  class: "table-row"
                }, [
                  S("td", e8, F(Z(V)(c.date).format("DD/MM/YYYY")), 1),
                  S("td", i8, F(Z(ut)(c.checkin_initiated)), 1),
                  S("td", n8, F(s(c.record_locator_init_count, c.checkin_initiated)), 1),
                  S("td", r8, F(Z(ut)(c.record_locator_started_count)), 1),
                  S("td", a8, F(s(c.record_locator_completed_count, c.record_locator_started_count)), 1),
                  S("td", s8, F(s(c.record_locator_closed_count, c.record_locator_started_count)), 1),
                  S("td", o8, F(s(c.record_locator_failed_count, c.record_locator_started_count)), 1),
                  S("td", l8, F(s(c.record_locator_abandoned_count, c.record_locator_started_count)), 1),
                  t.isAvianca ? (L(), O("td", u8, F(Z(ut)(c.record_locator_create_payment_count)), 1)) : ct("", !0),
                  t.isAvianca ? (L(), O("td", c8, F(Z(ut)(c.record_locator_create_payment_failed_count)), 1)) : ct("", !0)
                ]))), 128))
              ])
            ])
          ])
        ])) : (L(), O("section", h8, [...u[9] || (u[9] = [
          zt('<div class="empty-state-content" data-v-13f9abf0><div class="empty-icon-wrapper" data-v-13f9abf0><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-13f9abf0><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" data-v-13f9abf0></path></svg></div><p class="empty-title" data-v-13f9abf0>No record locator data available</p><p class="empty-description" data-v-13f9abf0>No record locator data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), d8 = /* @__PURE__ */ fe(f8, [["__scopeId", "data-v-13f9abf0"]]), v8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: d8
}, Symbol.toStringTag, { value: "Module" })), p8 = { class: "seller-metrics-card" }, g8 = { class: "card-header" }, m8 = { class: "header-content" }, y8 = {
  key: 0,
  class: "total-sales-badge"
}, _8 = { class: "badge-value" }, b8 = {
  key: 0,
  class: "loading-state"
}, x8 = {
  key: 1,
  class: "card-body"
}, w8 = {
  key: 0,
  class: "chart-section"
}, S8 = { class: "chart-wrapper" }, M8 = {
  key: 1,
  class: "empty-state"
}, T8 = {
  key: 2,
  class: "table-section"
}, D8 = { class: "table-wrapper" }, C8 = { class: "data-table" }, k8 = { class: "table-body" }, P8 = { class: "table-cell font-medium" }, A8 = { class: "table-cell text-center" }, E8 = { class: "table-cell text-center" }, L8 = { class: "table-cell text-center" }, O8 = { class: "table-cell text-center" }, I8 = { class: "table-cell text-center" }, R8 = { class: "table-cell text-center success-value" }, N8 = { class: "table-cell text-left" }, F8 = {
  key: 0,
  class: "failed-reasons"
}, B8 = { class: "reason-name" }, z8 = { class: "reason-count" }, V8 = {
  key: 1,
  class: "empty-cell"
}, $8 = /* @__PURE__ */ Te({
  __name: "Seller",
  props: {
    sellerData: { default: () => ({
      total_seller_conversations: 0,
      total_sell_started: 0,
      total_sell_get_quote: 0,
      total_sell_booking_created: 0,
      total_sell_success: 0,
      total_value_sell_success: 0,
      seller_by_day: []
    }) },
    failedData: { default: () => ({
      total_sell_failed: 0,
      failed_by_reason_by_day: []
    }) },
    loading: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, i = J(() => {
      if (!t.sellerData?.seller_by_day) return [];
      const c = [...t.sellerData.seller_by_day];
      return t.failedData?.failed_by_reason_by_day && t.failedData.failed_by_reason_by_day.forEach((h) => {
        const f = c.findIndex((d) => d.date === h.date);
        f !== -1 ? c[f] = { ...c[f], reasons: h.reasons } : c.push({
          date: h.date,
          seller_conversations: 0,
          sell_started_count: 0,
          sell_get_quote_count: 0,
          sell_booking_created_count: 0,
          sell_success_count: 0,
          daily_value_sell_success: 0,
          reasons: h.reasons
        });
      }), c.sort((h, f) => new Date(h.date).getTime() - new Date(f.date).getTime());
    }), n = J(() => t.sellerData), r = J(() => t.failedData), a = J(() => {
      const {
        total_seller_conversations: c = 0,
        total_sell_started: h = 0,
        total_sell_booking_created: f = 0,
        total_sell_success: d = 0
      } = n.value, { failed_by_reason_by_day: v = [] } = r.value;
      if (c === 0) return { nodes: [], links: [] };
      const g = [
        { name: "Sell Initiated", value: c },
        { name: "Sell Started", value: h },
        { name: "Booking Created", value: f },
        { name: "Sell Success", value: d }
      ], p = [], m = c - h;
      if (m > 0) {
        const x = Math.round(m / c * 100);
        g.push({ name: "Abandoned (Init)", value: m }), p.push({
          source: "Sell Initiated",
          target: "Abandoned (Init)",
          value: m,
          label: `${m.toLocaleString()} (${x}%)`
        });
      }
      if (h > 0) {
        const x = Math.round(h / c * 100);
        p.push({
          source: "Sell Initiated",
          target: "Sell Started",
          value: h,
          label: `${h.toLocaleString()} (${x}%)`
        });
      }
      const y = v.reduce((x, w) => (w.reasons && Array.isArray(w.reasons) && w.reasons.forEach((M) => {
        const T = M.reason, D = M.failed_count;
        x[T] = (x[T] || 0) + D;
      }), x), {});
      if (f > 0) {
        const x = Math.round(f / c * 100);
        p.push({
          source: "Sell Started",
          target: "Booking Created",
          value: f,
          label: `${f.toLocaleString()} (${x}%)`
        });
      }
      if (d > 0) {
        const x = Math.round(d / c * 100);
        p.push({
          source: "Booking Created",
          target: "Sell Success",
          value: d,
          label: `${d.toLocaleString()} (${x}%)`
        });
      }
      const _ = h - f;
      if (_ > 0) {
        const x = Math.round(_ / c * 100);
        g.push({ name: "Failed at Booking", value: _ }), p.push({
          source: "Sell Started",
          target: "Failed at Booking",
          value: _,
          label: `${_.toLocaleString()} (${x}%)`
        });
      }
      if (Object.keys(y).length > 0) {
        const x = Object.values(y).reduce((M, T) => M + T, 0), w = _ - x;
        if (Object.entries(y).filter(([, M]) => M > 0).sort(([, M], [, T]) => T - M).forEach(([M, T]) => {
          const D = Math.round(T / c * 100);
          g.push({ name: `Failed: ${M}`, value: T }), p.push({
            source: "Failed at Booking",
            target: `Failed: ${M}`,
            value: T,
            label: `${T.toLocaleString()} (${D}%)`
          });
        }), w > 0) {
          const M = Math.round(w / c * 100);
          g.push({ name: "Failed: Without Reason", value: w }), p.push({
            source: "Failed at Booking",
            target: "Failed: Without Reason",
            value: w,
            label: `${w.toLocaleString()} (${M}%)`
          });
        }
      }
      const b = f - d;
      if (b > 0) {
        const x = Math.round(b / c * 100);
        g.push({ name: "Failed at Completion", value: b }), p.push({
          source: "Booking Created",
          target: "Failed at Completion",
          value: b,
          label: `${b.toLocaleString()} (${x}%)`
        });
      }
      return { nodes: g, links: p };
    }), s = {
      "Sell Initiated": "#DBEAFE",
      "Abandoned (Init)": "#FEE2E2",
      "Sell Started": "#93C5FD",
      "Get Quote": "#C7D2FE",
      "Booking Created": "#8B8CF6",
      "Sell Success": "#7BE39E",
      "Sell Failed": "#FCA5A5",
      "Failed at Quote": "#FCA5A5",
      "Failed at Booking": "#F87171",
      "Failed at Completion": "#EF4444",
      "Failed: rejected": "#F87171",
      "Failed: payment_processing": "#EF4444",
      "Failed: seat_selection": "#F87171",
      "Failed: booking_validation": "#EF4444",
      "Failed: flight_availability": "#DC2626",
      "Failed: passenger_data": "#F87171",
      "Failed: system_error": "#DC2626",
      "Failed: timeout": "#EF4444",
      "Failed: Without Reason": "#F87171"
    }, o = J(() => s), l = (c, h) => !h || h === 0 ? "0%" : `${Math.round(c / h * 100)}%`, u = (c, h) => {
      const f = ut(c), d = l(c, h);
      return `${f} (${d})`;
    };
    return (c, h) => (L(), O("article", p8, [
      S("header", g8, [
        S("div", m8, [
          h[1] || (h[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "Seller Metrics"),
            S("p", { class: "card-subtitle" }, "Sales performance and failure analysis")
          ], -1)),
          t.loading ? ct("", !0) : (L(), O("div", y8, [
            h[0] || (h[0] = S("p", { class: "badge-label" }, "Total Sales Value", -1)),
            S("p", _8, F(Z(R0)(t.sellerData.total_value_sell_success)), 1)
          ]))
        ])
      ]),
      t.loading ? (L(), O("div", b8, [...h[2] || (h[2] = [
        zt('<div class="loading-container" data-v-d1ed17b9><div class="chart-flow-loader" data-v-d1ed17b9><div class="flow-line flow-1" data-v-d1ed17b9></div><div class="flow-line flow-2" data-v-d1ed17b9></div><div class="flow-line flow-3" data-v-d1ed17b9></div><div class="flow-line flow-4" data-v-d1ed17b9></div><div class="flow-line flow-5" data-v-d1ed17b9></div></div><p class="loading-text" data-v-d1ed17b9>Loading sales data...</p></div>', 1)
      ])])) : (L(), O("div", x8, [
        a.value.nodes.length > 0 ? (L(), O("section", w8, [
          S("div", S8, [
            Ze(fs, {
              data: a.value,
              "node-colors": o.value,
              title: "",
              height: "320px"
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : (L(), O("section", M8, [...h[3] || (h[3] = [
          zt('<div class="empty-state-content" data-v-d1ed17b9><div class="empty-icon-wrapper" data-v-d1ed17b9><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-d1ed17b9><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-d1ed17b9></path></svg></div><p class="empty-title" data-v-d1ed17b9>No sales data available</p><p class="empty-description" data-v-d1ed17b9>No sales data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])])),
        i.value && i.value.length > 0 ? (L(), O("section", T8, [
          S("div", D8, [
            S("table", C8, [
              h[4] || (h[4] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Sell Initiated"),
                  S("th", { class: "table-header" }, "Sell Started"),
                  S("th", { class: "table-header" }, "Get Quote"),
                  S("th", { class: "table-header" }, "Booking Created"),
                  S("th", { class: "table-header" }, "Sell Success"),
                  S("th", { class: "table-header" }, "Total Sales Value"),
                  S("th", { class: "table-header" }, "Failed")
                ])
              ], -1)),
              S("tbody", k8, [
                (L(!0), O(Nt, null, ve(i.value, (f) => (L(), O("tr", {
                  key: f.date,
                  class: "table-row"
                }, [
                  S("td", P8, F(Z(V)(f.date).format("DD/MM/YYYY")), 1),
                  S("td", A8, F(Z(ut)(f.seller_conversations || 0)), 1),
                  S("td", E8, F(u(f.sell_started_count, f.seller_conversations || f.sell_started_count)), 1),
                  S("td", L8, F(u(f.sell_get_quote_count, f.seller_conversations || f.sell_started_count)), 1),
                  S("td", O8, F(u(f.sell_booking_created_count, f.seller_conversations || f.sell_started_count)), 1),
                  S("td", I8, F(u(f.sell_success_count, f.seller_conversations || f.sell_started_count)), 1),
                  S("td", R8, F(Z(R0)(f.daily_value_sell_success)), 1),
                  S("td", N8, [
                    f.reasons && f.reasons.length > 0 ? (L(), O("div", F8, [
                      (L(!0), O(Nt, null, ve(f.reasons, (d) => (L(), O("div", {
                        key: d.reason,
                        class: "failed-reason-item"
                      }, [
                        S("span", B8, F(d.reason) + ":", 1),
                        S("span", z8, F(d.failed_count), 1)
                      ]))), 128))
                    ])) : (L(), O("div", V8, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : ct("", !0)
      ]))
    ]));
  }
}), H8 = /* @__PURE__ */ fe($8, [["__scopeId", "data-v-d1ed17b9"]]), Y8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: H8
}, Symbol.toStringTag, { value: "Module" })), W8 = { class: "nps-daily-card" }, U8 = { class: "card-header" }, G8 = { class: "header-content" }, j8 = {
  key: 0,
  class: "stats-badge"
}, X8 = { class: "badge-value" }, q8 = {
  key: 0,
  class: "loading-state"
}, Z8 = {
  key: 1,
  class: "card-body"
}, K8 = { class: "tooltip-content" }, Q8 = { class: "tooltip-title" }, J8 = { class: "tooltip-stats" }, tW = { class: "tooltip-stat-row" }, eW = { class: "tooltip-value" }, iW = { class: "tooltip-stat-row" }, nW = { class: "tooltip-value" }, rW = { class: "tooltip-stat-row" }, aW = { class: "tooltip-value" }, sW = { class: "tooltip-stat-row" }, oW = { class: "tooltip-value" }, lW = { class: "tooltip-stat-row" }, uW = { class: "tooltip-value" }, cW = { class: "tooltip-stat-row" }, hW = { class: "tooltip-value" }, fW = {
  key: 2,
  class: "empty-state"
}, N0 = 400, Ws = 60, F0 = 90, B0 = 120, dW = {
  __name: "npsDailyMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, i = J(() => t.data), n = wi(null), r = wi({
      visible: !1,
      x: 0,
      y: 0,
      date: "",
      min: "",
      max: "",
      q1: "",
      avg: "",
      q3: "",
      median: ""
    }), a = J(() => {
      if (!i.value || !i.value.nps_by_day) return 800;
      const h = i.value.nps_by_day.length;
      return Math.max(800, Ws * 2 + h * B0);
    }), s = (h, f) => {
      const v = (h - 1) / 9;
      return Ws + f - v * f;
    }, o = (h) => h ? V(h).format("DD-MM-YYYY") : "", l = J(() => {
      if (!i.value || !i.value.nps_by_day || i.value.nps_by_day.length === 0)
        return [];
      const h = [], f = N0 - Ws - F0;
      return i.value.nps_by_day.forEach((d, v) => {
        const g = d.min_score || 0, p = d.q1_score || 0, m = d.median_score || 0, y = d.q3_score || 0, _ = d.max_score || 0, b = d.average_score || 0;
        h.push({
          label: o(d.date),
          responseCount: d.nps_responses_count || 0,
          isTotal: !1,
          open: p,
          // Q1 as open
          high: _,
          // Max as high
          low: g,
          // Min as low
          close: y,
          // Q3 as close
          median: m,
          average: b,
          openY: s(p, f),
          highY: s(_, f),
          lowY: s(g, f),
          closeY: s(y, f),
          medianY: s(m, f),
          averageY: b > 0 ? s(b, f) : null,
          centerX: Ws + (v + 1) * B0
        });
      }), h;
    }), u = (h, f) => {
      if (!n.value || !f || f.horizontal) return;
      const d = n.value.getBoundingClientRect(), v = h.clientX, g = h.clientY, p = 140, m = 160, y = 10, _ = 15;
      let b = v - d.left - p / 2, x = g - d.top - m - _;
      b = Math.max(y, Math.min(b, d.width - p - y)), x < y && (x = g - d.top + _), x = Math.max(y, Math.min(x, d.height - m - y)), r.value = {
        visible: !0,
        x: b,
        y: x,
        date: f.label || "",
        min: f.low !== void 0 ? f.low.toFixed(1) : "N/A",
        max: f.high !== void 0 ? f.high.toFixed(1) : "N/A",
        q1: f.open !== void 0 ? f.open.toFixed(1) : "N/A",
        avg: f.average !== void 0 && f.average > 0 ? f.average.toFixed(1) : "N/A",
        q3: f.close !== void 0 ? f.close.toFixed(1) : "N/A",
        median: f.median !== void 0 ? f.median.toFixed(1) : "N/A"
      };
    }, c = () => {
      r.value.visible = !1;
    };
    return (h, f) => (L(), O("article", W8, [
      S("header", U8, [
        S("div", G8, [
          f[1] || (f[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "NPS Daily Metrics"),
            S("p", { class: "card-subtitle" }, "Daily NPS Distribution")
          ], -1)),
          i.value && i.value.nps_by_day && i.value.nps_by_day.length > 0 ? (L(), O("div", j8, [
            f[0] || (f[0] = S("p", { class: "badge-label" }, "Days", -1)),
            S("p", X8, F(i.value.nps_by_day.length), 1)
          ])) : ct("", !0)
        ])
      ]),
      t.loading ? (L(), O("div", q8, [...f[2] || (f[2] = [
        zt('<div class="loading-container" data-v-53f0f668><div class="chart-flow-loader" data-v-53f0f668><div class="flow-line flow-1" data-v-53f0f668></div><div class="flow-line flow-2" data-v-53f0f668></div><div class="flow-line flow-3" data-v-53f0f668></div><div class="flow-line flow-4" data-v-53f0f668></div><div class="flow-line flow-5" data-v-53f0f668></div></div><p class="loading-text" data-v-53f0f668>Loading daily NPS data...</p></div>', 1)
      ])])) : i.value && i.value.nps_by_day && i.value.nps_by_day.length > 0 ? (L(), O("div", Z8, [
        S("div", {
          class: "chart-wrapper",
          ref_key: "chartContainerRef",
          ref: n
        }, [
          l.value && l.value.length > 0 ? (L(), Y0($b, {
            key: 0,
            "candlestick-data": l.value,
            "chart-width": a.value,
            "chart-height": N0,
            "chart-margin": Ws,
            "chart-bottom-margin": F0,
            "show-legend": !0,
            rotation: 0,
            "candle-width": 30,
            onCandleHover: u,
            onCandleLeave: c
          }, null, 8, ["candlestick-data", "chart-width"])) : ct("", !0),
          r.value.visible ? (L(), O("div", {
            key: 1,
            class: "tooltip-overlay",
            style: Ur({
              left: `${r.value.x}px`,
              top: `${r.value.y}px`
            })
          }, [
            S("div", K8, [
              S("div", Q8, F(r.value.date), 1),
              f[9] || (f[9] = S("div", { class: "tooltip-divider" }, null, -1)),
              S("div", J8, [
                S("div", tW, [
                  f[3] || (f[3] = S("span", { class: "tooltip-label tooltip-min" }, "Min:", -1)),
                  S("span", eW, F(r.value.min), 1)
                ]),
                S("div", iW, [
                  f[4] || (f[4] = S("span", { class: "tooltip-label tooltip-q1" }, "Q1:", -1)),
                  S("span", nW, F(r.value.q1), 1)
                ]),
                S("div", rW, [
                  f[5] || (f[5] = S("span", { class: "tooltip-label tooltip-median" }, "Median:", -1)),
                  S("span", aW, F(r.value.median), 1)
                ]),
                S("div", sW, [
                  f[6] || (f[6] = S("span", { class: "tooltip-label tooltip-avg" }, "Avg:", -1)),
                  S("span", oW, F(r.value.avg), 1)
                ]),
                S("div", lW, [
                  f[7] || (f[7] = S("span", { class: "tooltip-label tooltip-q3" }, "Q3:", -1)),
                  S("span", uW, F(r.value.q3), 1)
                ]),
                S("div", cW, [
                  f[8] || (f[8] = S("span", { class: "tooltip-label tooltip-max" }, "Max:", -1)),
                  S("span", hW, F(r.value.max), 1)
                ])
              ])
            ])
          ], 4)) : ct("", !0)
        ], 512)
      ])) : (L(), O("div", fW, [...f[10] || (f[10] = [
        zt('<div class="empty-state-content" data-v-53f0f668><div class="empty-icon-wrapper" data-v-53f0f668><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-53f0f668><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-53f0f668></path></svg></div><p class="empty-title" data-v-53f0f668>No daily NPS data available</p><p class="empty-description" data-v-53f0f668>No daily NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, US = /* @__PURE__ */ fe(dW, [["__scopeId", "data-v-53f0f668"]]), vW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: US
}, Symbol.toStringTag, { value: "Module" })), pW = { class: "nps-overview-card" }, gW = { class: "card-header" }, mW = { class: "header-content" }, yW = {
  key: 0,
  class: "stats-badge"
}, _W = { class: "badge-value" }, bW = {
  key: 0,
  class: "loading-state"
}, xW = {
  key: 1,
  class: "card-body"
}, wW = { class: "chart-wrapper" }, SW = {
  key: 2,
  class: "empty-state"
}, MW = 500, TW = 60, DW = 80, CW = {
  __name: "npsOverviewMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    const t = e, i = J(() => t.data), n = J(() => Math.max(600, window.innerWidth * 0.85));
    return (r, a) => (L(), O("article", pW, [
      S("header", gW, [
        S("div", mW, [
          a[1] || (a[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "NPS Overview Metrics"),
            S("p", { class: "card-subtitle" }, "Overall NPS Distribution")
          ], -1)),
          i.value && i.value.total_nps_responses > 0 ? (L(), O("div", yW, [
            a[0] || (a[0] = S("p", { class: "badge-label" }, "Responses", -1)),
            S("p", _W, F(i.value.total_nps_responses), 1)
          ])) : ct("", !0)
        ])
      ]),
      t.loading ? (L(), O("div", bW, [...a[2] || (a[2] = [
        zt('<div class="loading-container" data-v-3ffe1496><div class="chart-flow-loader" data-v-3ffe1496><div class="flow-line flow-1" data-v-3ffe1496></div><div class="flow-line flow-2" data-v-3ffe1496></div><div class="flow-line flow-3" data-v-3ffe1496></div><div class="flow-line flow-4" data-v-3ffe1496></div><div class="flow-line flow-5" data-v-3ffe1496></div></div><p class="loading-text" data-v-3ffe1496>Loading NPS data...</p></div>', 1)
      ])])) : i.value && i.value.total_nps_responses > 0 ? (L(), O("div", xW, [
        S("div", wW, [
          Ze(Hb, {
            histogram: i.value.histogram || [],
            "min-score": i.value.min_score || 0,
            "max-score": i.value.max_score || 0,
            "q1-score": i.value.q1_score || 0,
            "median-score": i.value.median_score || 0,
            "q3-score": i.value.q3_score || 0,
            "average-score": i.value.average_score || 0,
            "chart-width": n.value,
            "chart-height": MW,
            "chart-margin": TW,
            "chart-bottom-margin": DW
          }, null, 8, ["histogram", "min-score", "max-score", "q1-score", "median-score", "q3-score", "average-score", "chart-width"])
        ])
      ])) : (L(), O("div", SW, [...a[3] || (a[3] = [
        zt('<div class="empty-state-content" data-v-3ffe1496><div class="empty-icon-wrapper" data-v-3ffe1496><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-3ffe1496><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-3ffe1496></path></svg></div><p class="empty-title" data-v-3ffe1496>No NPS data available</p><p class="empty-description" data-v-3ffe1496>No NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, GS = /* @__PURE__ */ fe(CW, [["__scopeId", "data-v-3ffe1496"]]), kW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: GS
}, Symbol.toStringTag, { value: "Module" })), PW = { class: "nps-metrics-container" }, AW = {
  __name: "npsMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    return (t, i) => (L(), O("div", PW, [
      Ze(GS, {
        data: e.data,
        loading: e.loading
      }, null, 8, ["data", "loading"]),
      Ze(US, {
        data: e.data,
        loading: e.loading
      }, null, 8, ["data", "loading"])
    ]));
  }
}, EW = /* @__PURE__ */ fe(AW, [["__scopeId", "data-v-1ecde7da"]]), LW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: EW
}, Symbol.toStringTag, { value: "Module" })), zW = {
  install(e) {
    e.component("KiutChartBar", () => Promise.resolve().then(() => XC)), e.component("KiutChartLine", () => Promise.resolve().then(() => KC)), e.component("KiutPieChart", () => Promise.resolve().then(() => ek)), e.component("KiutBoxplotChart", () => Promise.resolve().then(() => Rk)), e.component("KiutCandlestickChart", () => Promise.resolve().then(() => oP)), e.component("KiutHistogramChart", () => Promise.resolve().then(() => $P)), e.component("KiutSankeyChart", () => Promise.resolve().then(() => q3)), e.component("KiutBookingManager", () => Promise.resolve().then(() => A$)), e.component("KiutCheckin", () => Promise.resolve().then(() => eH)), e.component("KiutCheckinSegments", () => Promise.resolve().then(() => PH)), e.component("KiutDisruption", () => Promise.resolve().then(() => fY)), e.component("KiutFAQ", () => Promise.resolve().then(() => EY)), e.component("KiutMessagesPerAgent", () => Promise.resolve().then(() => HY)), e.component("KiutRecordLocator", () => Promise.resolve().then(() => v8)), e.component("KiutSeller", () => Promise.resolve().then(() => Y8)), e.component("KiutNpsDailyMetrics", () => Promise.resolve().then(() => vW)), e.component("KiutNpsMetrics", () => Promise.resolve().then(() => LW)), e.component("KiutNpsOverviewMetrics", () => Promise.resolve().then(() => kW));
  }
};
export {
  P$ as BookingManager,
  Ik as BoxplotChart,
  $b as CandlestickChart,
  jC as ChartBar,
  vv as ChartLine,
  tH as Checkin,
  kH as CheckinSegments,
  hY as Disruption,
  AY as FAQ,
  Hb as HistogramChart,
  $Y as MessagesPerAgent,
  US as NpsDailyMetrics,
  EW as NpsMetrics,
  GS as NpsOverviewMetrics,
  tk as PieChart,
  d8 as RecordLocator,
  fs as SankeyChart,
  H8 as Seller,
  zW as default
};
//# sourceMappingURL=kiut-ui.es.js.map
