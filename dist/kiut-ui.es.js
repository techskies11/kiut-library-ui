import { defineComponent as jt, shallowRef as P0, h as th, ref as Ke, onMounted as hd, onUnmounted as I0, watch as sa, toRaw as eh, nextTick as R0, version as q1, isProxy as O0, computed as G, toRef as ne, createElementBlock as I, openBlock as A, createVNode as Qt, unref as Y, normalizeStyle as or, createCommentVNode as q, createElementVNode as x, toDisplayString as O, Fragment as Tt, renderList as Zt, onBeforeUnmount as Z1, createStaticVNode as Dt, withDirectives as Ff, vShow as $f, normalizeClass as zf, createBlock as _e, createTextVNode as rl } from "vue";
import br from "moment";
function Ho(e) {
  return e + 0.5 | 0;
}
const an = (e, t, i) => Math.max(Math.min(e, i), t);
function qa(e) {
  return an(Ho(e * 2.55), 0, 255);
}
function cn(e) {
  return an(Ho(e * 255), 0, 255);
}
function Fi(e) {
  return an(Ho(e / 2.55) / 100, 0, 1);
}
function Vf(e) {
  return an(Ho(e * 100), 0, 100);
}
const $e = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, ih = [..."0123456789ABCDEF"], K1 = (e) => ih[e & 15], Q1 = (e) => ih[(e & 240) >> 4] + ih[e & 15], jo = (e) => (e & 240) >> 4 === (e & 15), J1 = (e) => jo(e.r) && jo(e.g) && jo(e.b) && jo(e.a);
function tx(e) {
  var t = e.length, i;
  return e[0] === "#" && (t === 4 || t === 5 ? i = {
    r: 255 & $e[e[1]] * 17,
    g: 255 & $e[e[2]] * 17,
    b: 255 & $e[e[3]] * 17,
    a: t === 5 ? $e[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (i = {
    r: $e[e[1]] << 4 | $e[e[2]],
    g: $e[e[3]] << 4 | $e[e[4]],
    b: $e[e[5]] << 4 | $e[e[6]],
    a: t === 9 ? $e[e[7]] << 4 | $e[e[8]] : 255
  })), i;
}
const ex = (e, t) => e < 255 ? t(e) : "";
function ix(e) {
  var t = J1(e) ? K1 : Q1;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + ex(e.a, t) : void 0;
}
const nx = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function B0(e, t, i) {
  const n = t * Math.min(i, 1 - i), r = (a, o = (a + e / 30) % 12) => i - n * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [r(0), r(8), r(4)];
}
function rx(e, t, i) {
  const n = (r, a = (r + e / 60) % 6) => i - i * t * Math.max(Math.min(a, 4 - a, 1), 0);
  return [n(5), n(3), n(1)];
}
function ax(e, t, i) {
  const n = B0(e, 1, 0.5);
  let r;
  for (t + i > 1 && (r = 1 / (t + i), t *= r, i *= r), r = 0; r < 3; r++)
    n[r] *= 1 - t - i, n[r] += t;
  return n;
}
function ox(e, t, i, n, r) {
  return e === r ? (t - i) / n + (t < i ? 6 : 0) : t === r ? (i - e) / n + 2 : (e - t) / n + 4;
}
function dd(e) {
  const i = e.r / 255, n = e.g / 255, r = e.b / 255, a = Math.max(i, n, r), o = Math.min(i, n, r), s = (a + o) / 2;
  let l, u, c;
  return a !== o && (c = a - o, u = s > 0.5 ? c / (2 - a - o) : c / (a + o), l = ox(i, n, r, c, a), l = l * 60 + 0.5), [l | 0, u || 0, s];
}
function fd(e, t, i, n) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, i, n)).map(cn);
}
function vd(e, t, i) {
  return fd(B0, e, t, i);
}
function sx(e, t, i) {
  return fd(ax, e, t, i);
}
function lx(e, t, i) {
  return fd(rx, e, t, i);
}
function N0(e) {
  return (e % 360 + 360) % 360;
}
function ux(e) {
  const t = nx.exec(e);
  let i = 255, n;
  if (!t)
    return;
  t[5] !== n && (i = t[6] ? qa(+t[5]) : cn(+t[5]));
  const r = N0(+t[2]), a = +t[3] / 100, o = +t[4] / 100;
  return t[1] === "hwb" ? n = sx(r, a, o) : t[1] === "hsv" ? n = lx(r, a, o) : n = vd(r, a, o), {
    r: n[0],
    g: n[1],
    b: n[2],
    a: i
  };
}
function cx(e, t) {
  var i = dd(e);
  i[0] = N0(i[0] + t), i = vd(i), e.r = i[0], e.g = i[1], e.b = i[2];
}
function hx(e) {
  if (!e)
    return;
  const t = dd(e), i = t[0], n = Vf(t[1]), r = Vf(t[2]);
  return e.a < 255 ? `hsla(${i}, ${n}%, ${r}%, ${Fi(e.a)})` : `hsl(${i}, ${n}%, ${r}%)`;
}
const Hf = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Wf = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function dx() {
  const e = {}, t = Object.keys(Wf), i = Object.keys(Hf);
  let n, r, a, o, s;
  for (n = 0; n < t.length; n++) {
    for (o = s = t[n], r = 0; r < i.length; r++)
      a = i[r], s = s.replace(a, Hf[a]);
    a = parseInt(Wf[o], 16), e[s] = [a >> 16 & 255, a >> 8 & 255, a & 255];
  }
  return e;
}
let qo;
function fx(e) {
  qo || (qo = dx(), qo.transparent = [0, 0, 0, 0]);
  const t = qo[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const vx = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function px(e) {
  const t = vx.exec(e);
  let i = 255, n, r, a;
  if (t) {
    if (t[7] !== n) {
      const o = +t[7];
      i = t[8] ? qa(o) : an(o * 255, 0, 255);
    }
    return n = +t[1], r = +t[3], a = +t[5], n = 255 & (t[2] ? qa(n) : an(n, 0, 255)), r = 255 & (t[4] ? qa(r) : an(r, 0, 255)), a = 255 & (t[6] ? qa(a) : an(a, 0, 255)), {
      r: n,
      g: r,
      b: a,
      a: i
    };
  }
}
function gx(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${Fi(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Su = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, kr = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function mx(e, t, i) {
  const n = kr(Fi(e.r)), r = kr(Fi(e.g)), a = kr(Fi(e.b));
  return {
    r: cn(Su(n + i * (kr(Fi(t.r)) - n))),
    g: cn(Su(r + i * (kr(Fi(t.g)) - r))),
    b: cn(Su(a + i * (kr(Fi(t.b)) - a))),
    a: e.a + i * (t.a - e.a)
  };
}
function Zo(e, t, i) {
  if (e) {
    let n = dd(e);
    n[t] = Math.max(0, Math.min(n[t] + n[t] * i, t === 0 ? 360 : 1)), n = vd(n), e.r = n[0], e.g = n[1], e.b = n[2];
  }
}
function F0(e, t) {
  return e && Object.assign(t || {}, e);
}
function Yf(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = cn(e[3]))) : (t = F0(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = cn(t.a)), t;
}
function yx(e) {
  return e.charAt(0) === "r" ? px(e) : ux(e);
}
class xo {
  constructor(t) {
    if (t instanceof xo)
      return t;
    const i = typeof t;
    let n;
    i === "object" ? n = Yf(t) : i === "string" && (n = tx(t) || fx(t) || yx(t)), this._rgb = n, this._valid = !!n;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = F0(this._rgb);
    return t && (t.a = Fi(t.a)), t;
  }
  set rgb(t) {
    this._rgb = Yf(t);
  }
  rgbString() {
    return this._valid ? gx(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? ix(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? hx(this._rgb) : void 0;
  }
  mix(t, i) {
    if (t) {
      const n = this.rgb, r = t.rgb;
      let a;
      const o = i === a ? 0.5 : i, s = 2 * o - 1, l = n.a - r.a, u = ((s * l === -1 ? s : (s + l) / (1 + s * l)) + 1) / 2;
      a = 1 - u, n.r = 255 & u * n.r + a * r.r + 0.5, n.g = 255 & u * n.g + a * r.g + 0.5, n.b = 255 & u * n.b + a * r.b + 0.5, n.a = o * n.a + (1 - o) * r.a, this.rgb = n;
    }
    return this;
  }
  interpolate(t, i) {
    return t && (this._rgb = mx(this._rgb, t._rgb, i)), this;
  }
  clone() {
    return new xo(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = cn(t), this;
  }
  clearer(t) {
    const i = this._rgb;
    return i.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, i = Ho(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = i, this;
  }
  opaquer(t) {
    const i = this._rgb;
    return i.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return Zo(this._rgb, 2, t), this;
  }
  darken(t) {
    return Zo(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return Zo(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return Zo(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return cx(this._rgb, t), this;
  }
}
function Ai() {
}
const _x = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function gt(e) {
  return e == null;
}
function Ut(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function ut(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function de(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function di(e, t) {
  return de(e) ? e : t;
}
function at(e, t) {
  return typeof e > "u" ? t : e;
}
const bx = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, $0 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function At(e, t, i) {
  if (e && typeof e.call == "function")
    return e.apply(i, t);
}
function _t(e, t, i, n) {
  let r, a, o;
  if (Ut(e))
    for (a = e.length, r = 0; r < a; r++)
      t.call(i, e[r], r);
  else if (ut(e))
    for (o = Object.keys(e), a = o.length, r = 0; r < a; r++)
      t.call(i, e[o[r]], o[r]);
}
function al(e, t) {
  let i, n, r, a;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (i = 0, n = e.length; i < n; ++i)
    if (r = e[i], a = t[i], r.datasetIndex !== a.datasetIndex || r.index !== a.index)
      return !1;
  return !0;
}
function ol(e) {
  if (Ut(e))
    return e.map(ol);
  if (ut(e)) {
    const t = /* @__PURE__ */ Object.create(null), i = Object.keys(e), n = i.length;
    let r = 0;
    for (; r < n; ++r)
      t[i[r]] = ol(e[i[r]]);
    return t;
  }
  return e;
}
function z0(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function xx(e, t, i, n) {
  if (!z0(e))
    return;
  const r = t[e], a = i[e];
  ut(r) && ut(a) ? wo(r, a, n) : t[e] = ol(a);
}
function wo(e, t, i) {
  const n = Ut(t) ? t : [
    t
  ], r = n.length;
  if (!ut(e))
    return e;
  i = i || {};
  const a = i.merger || xx;
  let o;
  for (let s = 0; s < r; ++s) {
    if (o = n[s], !ut(o))
      continue;
    const l = Object.keys(o);
    for (let u = 0, c = l.length; u < c; ++u)
      a(l[u], e, o, i);
  }
  return e;
}
function so(e, t) {
  return wo(e, t, {
    merger: Sx
  });
}
function Sx(e, t, i) {
  if (!z0(e))
    return;
  const n = t[e], r = i[e];
  ut(n) && ut(r) ? so(n, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = ol(r));
}
const Uf = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function Cx(e) {
  const t = e.split("."), i = [];
  let n = "";
  for (const r of t)
    n += r, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n), n = "");
  return i;
}
function Tx(e) {
  const t = Cx(e);
  return (i) => {
    for (const n of t) {
      if (n === "")
        break;
      i = i && i[n];
    }
    return i;
  };
}
function gr(e, t) {
  return (Uf[t] || (Uf[t] = Tx(t)))(e);
}
function pd(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const So = (e) => typeof e < "u", pn = (e) => typeof e == "function", Gf = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const i of e)
    if (!t.has(i))
      return !1;
  return !0;
};
function Mx(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const bt = Math.PI, Rt = 2 * bt, kx = Rt + bt, sl = Number.POSITIVE_INFINITY, Dx = bt / 180, Kt = bt / 2, wn = bt / 4, Xf = bt * 2 / 3, V0 = Math.log10, Si = Math.sign;
function lo(e, t, i) {
  return Math.abs(e - t) < i;
}
function jf(e) {
  const t = Math.round(e);
  e = lo(e, t, e / 1e3) ? t : e;
  const i = Math.pow(10, Math.floor(V0(e))), n = e / i;
  return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i;
}
function Ex(e) {
  const t = [], i = Math.sqrt(e);
  let n;
  for (n = 1; n < i; n++)
    e % n === 0 && (t.push(n), t.push(e / n));
  return i === (i | 0) && t.push(i), t.sort((r, a) => r - a).pop(), t;
}
function Ax(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function Co(e) {
  return !Ax(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function Lx(e, t) {
  const i = Math.round(e);
  return i - t <= e && i + t >= e;
}
function Px(e, t, i) {
  let n, r, a;
  for (n = 0, r = e.length; n < r; n++)
    a = e[n][i], isNaN(a) || (t.min = Math.min(t.min, a), t.max = Math.max(t.max, a));
}
function $i(e) {
  return e * (bt / 180);
}
function Ix(e) {
  return e * (180 / bt);
}
function qf(e) {
  if (!de(e))
    return;
  let t = 1, i = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, i++;
  return i;
}
function H0(e, t) {
  const i = t.x - e.x, n = t.y - e.y, r = Math.sqrt(i * i + n * n);
  let a = Math.atan2(n, i);
  return a < -0.5 * bt && (a += Rt), {
    angle: a,
    distance: r
  };
}
function nh(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function Rx(e, t) {
  return (e - t + kx) % Rt - bt;
}
function Pe(e) {
  return (e % Rt + Rt) % Rt;
}
function To(e, t, i, n) {
  const r = Pe(e), a = Pe(t), o = Pe(i), s = Pe(a - r), l = Pe(o - r), u = Pe(r - a), c = Pe(r - o);
  return r === a || r === o || n && a === o || s > l && u < c;
}
function le(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function Ox(e) {
  return le(e, -32768, 32767);
}
function zi(e, t, i, n = 1e-6) {
  return e >= Math.min(t, i) - n && e <= Math.max(t, i) + n;
}
function gd(e, t, i) {
  i = i || ((o) => e[o] < t);
  let n = e.length - 1, r = 0, a;
  for (; n - r > 1; )
    a = r + n >> 1, i(a) ? r = a : n = a;
  return {
    lo: r,
    hi: n
  };
}
const tr = (e, t, i, n) => gd(e, i, n ? (r) => {
  const a = e[r][t];
  return a < i || a === i && e[r + 1][t] === i;
} : (r) => e[r][t] < i), Bx = (e, t, i) => gd(e, i, (n) => e[n][t] >= i);
function Nx(e, t, i) {
  let n = 0, r = e.length;
  for (; n < r && e[n] < t; )
    n++;
  for (; r > n && e[r - 1] > i; )
    r--;
  return n > 0 || r < e.length ? e.slice(n, r) : e;
}
const W0 = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function Fx(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), W0.forEach((i) => {
    const n = "_onData" + pd(i), r = e[i];
    Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !1,
      value(...a) {
        const o = r.apply(this, a);
        return e._chartjs.listeners.forEach((s) => {
          typeof s[n] == "function" && s[n](...a);
        }), o;
      }
    });
  });
}
function Zf(e, t) {
  const i = e._chartjs;
  if (!i)
    return;
  const n = i.listeners, r = n.indexOf(t);
  r !== -1 && n.splice(r, 1), !(n.length > 0) && (W0.forEach((a) => {
    delete e[a];
  }), delete e._chartjs);
}
function Y0(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const U0 = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function G0(e, t) {
  let i = [], n = !1;
  return function(...r) {
    i = r, n || (n = !0, U0.call(window, () => {
      n = !1, e.apply(t, i);
    }));
  };
}
function $x(e, t) {
  let i;
  return function(...n) {
    return t ? (clearTimeout(i), i = setTimeout(e, t, n)) : e.apply(this, n), t;
  };
}
const md = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", oe = (e, t, i) => e === "start" ? t : e === "end" ? i : (t + i) / 2, zx = (e, t, i, n) => e === (n ? "left" : "right") ? i : e === "center" ? (t + i) / 2 : t;
function Vx(e, t, i) {
  const n = t.length;
  let r = 0, a = n;
  if (e._sorted) {
    const { iScale: o, vScale: s, _parsed: l } = e, u = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, c = o.axis, { min: h, max: d, minDefined: f, maxDefined: v } = o.getUserBounds();
    if (f) {
      if (r = Math.min(
        // @ts-expect-error Need to type _parsed
        tr(l, c, h).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? n : tr(t, c, o.getPixelForValue(h)).lo
      ), u) {
        const m = l.slice(0, r + 1).reverse().findIndex((p) => !gt(p[s.axis]));
        r -= Math.max(0, m);
      }
      r = le(r, 0, n - 1);
    }
    if (v) {
      let m = Math.max(
        // @ts-expect-error Need to type _parsed
        tr(l, o.axis, d, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? 0 : tr(t, c, o.getPixelForValue(d), !0).hi + 1
      );
      if (u) {
        const p = l.slice(m - 1).findIndex((g) => !gt(g[s.axis]));
        m += Math.max(0, p);
      }
      a = le(m, r, n) - r;
    } else
      a = n - r;
  }
  return {
    start: r,
    count: a
  };
}
function Hx(e) {
  const { xScale: t, yScale: i, _scaleRanges: n } = e, r = {
    xmin: t.min,
    xmax: t.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!n)
    return e._scaleRanges = r, !0;
  const a = n.xmin !== t.min || n.xmax !== t.max || n.ymin !== i.min || n.ymax !== i.max;
  return Object.assign(n, r), a;
}
const Ko = (e) => e === 0 || e === 1, Kf = (e, t, i) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Rt / i)), Qf = (e, t, i) => Math.pow(2, -10 * e) * Math.sin((e - t) * Rt / i) + 1, uo = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * Kt) + 1,
  easeOutSine: (e) => Math.sin(e * Kt),
  easeInOutSine: (e) => -0.5 * (Math.cos(bt * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => Ko(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => Ko(e) ? e : Kf(e, 0.075, 0.3),
  easeOutElastic: (e) => Ko(e) ? e : Qf(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return Ko(e) ? e : e < 0.5 ? 0.5 * Kf(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * Qf(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - uo.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? uo.easeInBounce(e * 2) * 0.5 : uo.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function yd(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function Jf(e) {
  return yd(e) ? e : new xo(e);
}
function Cu(e) {
  return yd(e) ? e : new xo(e).saturate(0.5).darken(0.1).hexString();
}
const Wx = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], Yx = [
  "color",
  "borderColor",
  "backgroundColor"
];
function Ux(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: Yx
    },
    numbers: {
      type: "number",
      properties: Wx
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function Gx(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const tv = /* @__PURE__ */ new Map();
function Xx(e, t) {
  t = t || {};
  const i = e + JSON.stringify(t);
  let n = tv.get(i);
  return n || (n = new Intl.NumberFormat(e, t), tv.set(i, n)), n;
}
function _d(e, t, i) {
  return Xx(t, i).format(e);
}
const jx = {
  values(e) {
    return Ut(e) ? e : "" + e;
  },
  numeric(e, t, i) {
    if (e === 0)
      return "0";
    const n = this.chart.options.locale;
    let r, a = e;
    if (i.length > 1) {
      const u = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (u < 1e-4 || u > 1e15) && (r = "scientific"), a = qx(e, i);
    }
    const o = V0(Math.abs(a)), s = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
      notation: r,
      minimumFractionDigits: s,
      maximumFractionDigits: s
    };
    return Object.assign(l, this.options.ticks.format), _d(e, n, l);
  }
};
function qx(e, t) {
  let i = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(i) >= 1 && e !== Math.floor(e) && (i = e - Math.floor(e)), i;
}
var X0 = {
  formatters: jx
};
function Zx(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, i) => i.lineWidth,
      tickColor: (t, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: X0.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const mr = /* @__PURE__ */ Object.create(null), rh = /* @__PURE__ */ Object.create(null);
function co(e, t) {
  if (!t)
    return e;
  const i = t.split(".");
  for (let n = 0, r = i.length; n < r; ++n) {
    const a = i[n];
    e = e[a] || (e[a] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function Tu(e, t, i) {
  return typeof t == "string" ? wo(co(e, t), i) : wo(co(e, ""), t);
}
class Kx {
  constructor(t, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (n, r) => Cu(r.backgroundColor), this.hoverBorderColor = (n, r) => Cu(r.borderColor), this.hoverColor = (n, r) => Cu(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(i);
  }
  set(t, i) {
    return Tu(this, t, i);
  }
  get(t) {
    return co(this, t);
  }
  describe(t, i) {
    return Tu(rh, t, i);
  }
  override(t, i) {
    return Tu(mr, t, i);
  }
  route(t, i, n, r) {
    const a = co(this, t), o = co(this, n), s = "_" + i;
    Object.defineProperties(a, {
      [s]: {
        value: a[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const l = this[s], u = o[r];
          return ut(l) ? Object.assign({}, u, l) : at(l, u);
        },
        set(l) {
          this[s] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((i) => i(this));
  }
}
var Wt = /* @__PURE__ */ new Kx({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  Ux,
  Gx,
  Zx
]);
function Qx(e) {
  return !e || gt(e.size) || gt(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function ev(e, t, i, n, r) {
  let a = t[r];
  return a || (a = t[r] = e.measureText(r).width, i.push(r)), a > n && (n = a), n;
}
function Sn(e, t, i) {
  const n = e.currentDevicePixelRatio, r = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((t - r) * n) / n + r;
}
function iv(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function ah(e, t, i, n) {
  j0(e, t, i, n, null);
}
function j0(e, t, i, n, r) {
  let a, o, s, l, u, c, h, d;
  const f = t.pointStyle, v = t.rotation, m = t.radius;
  let p = (v || 0) * Dx;
  if (f && typeof f == "object" && (a = f.toString(), a === "[object HTMLImageElement]" || a === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(i, n), e.rotate(p), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), e.restore();
    return;
  }
  if (!(isNaN(m) || m <= 0)) {
    switch (e.beginPath(), f) {
      // Default includes circle
      default:
        r ? e.ellipse(i, n, r / 2, m, 0, 0, Rt) : e.arc(i, n, m, 0, Rt), e.closePath();
        break;
      case "triangle":
        c = r ? r / 2 : m, e.moveTo(i + Math.sin(p) * c, n - Math.cos(p) * m), p += Xf, e.lineTo(i + Math.sin(p) * c, n - Math.cos(p) * m), p += Xf, e.lineTo(i + Math.sin(p) * c, n - Math.cos(p) * m), e.closePath();
        break;
      case "rectRounded":
        u = m * 0.516, l = m - u, o = Math.cos(p + wn) * l, h = Math.cos(p + wn) * (r ? r / 2 - u : l), s = Math.sin(p + wn) * l, d = Math.sin(p + wn) * (r ? r / 2 - u : l), e.arc(i - h, n - s, u, p - bt, p - Kt), e.arc(i + d, n - o, u, p - Kt, p), e.arc(i + h, n + s, u, p, p + Kt), e.arc(i - d, n + o, u, p + Kt, p + bt), e.closePath();
        break;
      case "rect":
        if (!v) {
          l = Math.SQRT1_2 * m, c = r ? r / 2 : l, e.rect(i - c, n - l, 2 * c, 2 * l);
          break;
        }
        p += wn;
      /* falls through */
      case "rectRot":
        h = Math.cos(p) * (r ? r / 2 : m), o = Math.cos(p) * m, s = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - s), e.lineTo(i + d, n - o), e.lineTo(i + h, n + s), e.lineTo(i - d, n + o), e.closePath();
        break;
      case "crossRot":
        p += wn;
      /* falls through */
      case "cross":
        h = Math.cos(p) * (r ? r / 2 : m), o = Math.cos(p) * m, s = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - s), e.lineTo(i + h, n + s), e.moveTo(i + d, n - o), e.lineTo(i - d, n + o);
        break;
      case "star":
        h = Math.cos(p) * (r ? r / 2 : m), o = Math.cos(p) * m, s = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - s), e.lineTo(i + h, n + s), e.moveTo(i + d, n - o), e.lineTo(i - d, n + o), p += wn, h = Math.cos(p) * (r ? r / 2 : m), o = Math.cos(p) * m, s = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - s), e.lineTo(i + h, n + s), e.moveTo(i + d, n - o), e.lineTo(i - d, n + o);
        break;
      case "line":
        o = r ? r / 2 : Math.cos(p) * m, s = Math.sin(p) * m, e.moveTo(i - o, n - s), e.lineTo(i + o, n + s);
        break;
      case "dash":
        e.moveTo(i, n), e.lineTo(i + Math.cos(p) * (r ? r / 2 : m), n + Math.sin(p) * m);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function Mo(e, t, i) {
  return i = i || 0.5, !t || e && e.x > t.left - i && e.x < t.right + i && e.y > t.top - i && e.y < t.bottom + i;
}
function Zl(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function Kl(e) {
  e.restore();
}
function Jx(e, t, i, n, r) {
  if (!t)
    return e.lineTo(i.x, i.y);
  if (r === "middle") {
    const a = (t.x + i.x) / 2;
    e.lineTo(a, t.y), e.lineTo(a, i.y);
  } else r === "after" != !!n ? e.lineTo(t.x, i.y) : e.lineTo(i.x, t.y);
  e.lineTo(i.x, i.y);
}
function t2(e, t, i, n) {
  if (!t)
    return e.lineTo(i.x, i.y);
  e.bezierCurveTo(n ? t.cp1x : t.cp2x, n ? t.cp1y : t.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y);
}
function e2(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), gt(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function i2(e, t, i, n, r) {
  if (r.strikethrough || r.underline) {
    const a = e.measureText(n), o = t - a.actualBoundingBoxLeft, s = t + a.actualBoundingBoxRight, l = i - a.actualBoundingBoxAscent, u = i + a.actualBoundingBoxDescent, c = r.strikethrough ? (l + u) / 2 : u;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = r.decorationWidth || 2, e.moveTo(o, c), e.lineTo(s, c), e.stroke();
  }
}
function n2(e, t) {
  const i = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = i;
}
function ko(e, t, i, n, r, a = {}) {
  const o = Ut(t) ? t : [
    t
  ], s = a.strokeWidth > 0 && a.strokeColor !== "";
  let l, u;
  for (e.save(), e.font = r.string, e2(e, a), l = 0; l < o.length; ++l)
    u = o[l], a.backdrop && n2(e, a.backdrop), s && (a.strokeColor && (e.strokeStyle = a.strokeColor), gt(a.strokeWidth) || (e.lineWidth = a.strokeWidth), e.strokeText(u, i, n, a.maxWidth)), e.fillText(u, i, n, a.maxWidth), i2(e, i, n, u, a), n += Number(r.lineHeight);
  e.restore();
}
function ll(e, t) {
  const { x: i, y: n, w: r, h: a, radius: o } = t;
  e.arc(i + o.topLeft, n + o.topLeft, o.topLeft, 1.5 * bt, bt, !0), e.lineTo(i, n + a - o.bottomLeft), e.arc(i + o.bottomLeft, n + a - o.bottomLeft, o.bottomLeft, bt, Kt, !0), e.lineTo(i + r - o.bottomRight, n + a), e.arc(i + r - o.bottomRight, n + a - o.bottomRight, o.bottomRight, Kt, 0, !0), e.lineTo(i + r, n + o.topRight), e.arc(i + r - o.topRight, n + o.topRight, o.topRight, 0, -Kt, !0), e.lineTo(i + o.topLeft, n);
}
const r2 = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, a2 = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function o2(e, t) {
  const i = ("" + e).match(r2);
  if (!i || i[1] === "normal")
    return t * 1.2;
  switch (e = +i[2], i[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const s2 = (e) => +e || 0;
function bd(e, t) {
  const i = {}, n = ut(t), r = n ? Object.keys(t) : t, a = ut(e) ? n ? (o) => at(e[o], e[t[o]]) : (o) => e[o] : () => e;
  for (const o of r)
    i[o] = s2(a(o));
  return i;
}
function q0(e) {
  return bd(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function ea(e) {
  return bd(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function Je(e) {
  const t = q0(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function ue(e, t) {
  e = e || {}, t = t || Wt.font;
  let i = at(e.size, t.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let n = at(e.style, t.style);
  n && !("" + n).match(a2) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
  const r = {
    family: at(e.family, t.family),
    lineHeight: o2(at(e.lineHeight, t.lineHeight), i),
    size: i,
    style: n,
    weight: at(e.weight, t.weight),
    string: ""
  };
  return r.string = Qx(r), r;
}
function Qo(e, t, i, n) {
  let r, a, o;
  for (r = 0, a = e.length; r < a; ++r)
    if (o = e[r], o !== void 0 && o !== void 0)
      return o;
}
function l2(e, t, i) {
  const { min: n, max: r } = e, a = $0(t, (r - n) / 2), o = (s, l) => i && s === 0 ? 0 : s + l;
  return {
    min: o(n, -Math.abs(a)),
    max: o(r, a)
  };
}
function xr(e, t) {
  return Object.assign(Object.create(e), t);
}
function xd(e, t = [
  ""
], i, n, r = () => e[0]) {
  const a = i || e;
  typeof n > "u" && (n = J0("_fallback", e));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: a,
    _fallback: n,
    _getTarget: r,
    override: (s) => xd([
      s,
      ...e
    ], t, a, n)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(s, l) {
      return delete s[l], delete s._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(s, l) {
      return K0(s, l, () => g2(l, t, e, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(s, l) {
      return Reflect.getOwnPropertyDescriptor(s._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(s, l) {
      return rv(s).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(s) {
      return rv(s);
    },
    /**
    * A trap for setting property values.
    */
    set(s, l, u) {
      const c = s._storage || (s._storage = r());
      return s[l] = c[l] = u, delete s._keys, !0;
    }
  });
}
function la(e, t, i, n) {
  const r = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: Z0(e, n),
    setContext: (a) => la(e, a, i, n),
    override: (a) => la(e.override(a), t, i, n)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, o) {
      return delete a[o], delete e[o], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, o, s) {
      return K0(a, o, () => c2(a, o, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, o) {
      return a._descriptors.allKeys ? Reflect.has(e, o) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(a, o) {
      return Reflect.has(e, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(a, o, s) {
      return e[o] = s, delete a[o], !0;
    }
  });
}
function Z0(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = t.scriptable, _indexable: n = t.indexable, _allKeys: r = t.allKeys } = e;
  return {
    allKeys: r,
    scriptable: i,
    indexable: n,
    isScriptable: pn(i) ? i : () => i,
    isIndexable: pn(n) ? n : () => n
  };
}
const u2 = (e, t) => e ? e + pd(t) : t, wd = (e, t) => ut(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function K0(e, t, i) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const n = i();
  return e[t] = n, n;
}
function c2(e, t, i) {
  const { _proxy: n, _context: r, _subProxy: a, _descriptors: o } = e;
  let s = n[t];
  return pn(s) && o.isScriptable(t) && (s = h2(t, s, e, i)), Ut(s) && s.length && (s = d2(t, s, e, o.isIndexable)), wd(t, s) && (s = la(s, r, a && a[t], o)), s;
}
function h2(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: o, _stack: s } = i;
  if (s.has(e))
    throw new Error("Recursion detected: " + Array.from(s).join("->") + "->" + e);
  s.add(e);
  let l = t(a, o || n);
  return s.delete(e), wd(e, l) && (l = Sd(r._scopes, r, e, l)), l;
}
function d2(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: o, _descriptors: s } = i;
  if (typeof a.index < "u" && n(e))
    return t[a.index % t.length];
  if (ut(t[0])) {
    const l = t, u = r._scopes.filter((c) => c !== l);
    t = [];
    for (const c of l) {
      const h = Sd(u, r, e, c);
      t.push(la(h, a, o && o[e], s));
    }
  }
  return t;
}
function Q0(e, t, i) {
  return pn(e) ? e(t, i) : e;
}
const f2 = (e, t) => e === !0 ? t : typeof e == "string" ? gr(t, e) : void 0;
function v2(e, t, i, n, r) {
  for (const a of t) {
    const o = f2(i, a);
    if (o) {
      e.add(o);
      const s = Q0(o._fallback, i, r);
      if (typeof s < "u" && s !== i && s !== n)
        return s;
    } else if (o === !1 && typeof n < "u" && i !== n)
      return null;
  }
  return !1;
}
function Sd(e, t, i, n) {
  const r = t._rootScopes, a = Q0(t._fallback, i, n), o = [
    ...e,
    ...r
  ], s = /* @__PURE__ */ new Set();
  s.add(n);
  let l = nv(s, o, i, a || i, n);
  return l === null || typeof a < "u" && a !== i && (l = nv(s, o, a, l, n), l === null) ? !1 : xd(Array.from(s), [
    ""
  ], r, a, () => p2(t, i, n));
}
function nv(e, t, i, n, r) {
  for (; i; )
    i = v2(e, t, i, n, r);
  return i;
}
function p2(e, t, i) {
  const n = e._getTarget();
  t in n || (n[t] = {});
  const r = n[t];
  return Ut(r) && ut(i) ? i : r || {};
}
function g2(e, t, i, n) {
  let r;
  for (const a of t)
    if (r = J0(u2(a, e), i), typeof r < "u")
      return wd(e, r) ? Sd(i, n, e, r) : r;
}
function J0(e, t) {
  for (const i of t) {
    if (!i)
      continue;
    const n = i[e];
    if (typeof n < "u")
      return n;
  }
}
function rv(e) {
  let t = e._keys;
  return t || (t = e._keys = m2(e._scopes)), t;
}
function m2(e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    for (const n of Object.keys(i).filter((r) => !r.startsWith("_")))
      t.add(n);
  return Array.from(t);
}
const y2 = Number.EPSILON || 1e-14, ua = (e, t) => t < e.length && !e[t].skip && e[t], ty = (e) => e === "x" ? "y" : "x";
function _2(e, t, i, n) {
  const r = e.skip ? t : e, a = t, o = i.skip ? t : i, s = nh(a, r), l = nh(o, a);
  let u = s / (s + l), c = l / (s + l);
  u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c;
  const h = n * u, d = n * c;
  return {
    previous: {
      x: a.x - h * (o.x - r.x),
      y: a.y - h * (o.y - r.y)
    },
    next: {
      x: a.x + d * (o.x - r.x),
      y: a.y + d * (o.y - r.y)
    }
  };
}
function b2(e, t, i) {
  const n = e.length;
  let r, a, o, s, l, u = ua(e, 0);
  for (let c = 0; c < n - 1; ++c)
    if (l = u, u = ua(e, c + 1), !(!l || !u)) {
      if (lo(t[c], 0, y2)) {
        i[c] = i[c + 1] = 0;
        continue;
      }
      r = i[c] / t[c], a = i[c + 1] / t[c], s = Math.pow(r, 2) + Math.pow(a, 2), !(s <= 9) && (o = 3 / Math.sqrt(s), i[c] = r * o * t[c], i[c + 1] = a * o * t[c]);
    }
}
function x2(e, t, i = "x") {
  const n = ty(i), r = e.length;
  let a, o, s, l = ua(e, 0);
  for (let u = 0; u < r; ++u) {
    if (o = s, s = l, l = ua(e, u + 1), !s)
      continue;
    const c = s[i], h = s[n];
    o && (a = (c - o[i]) / 3, s[`cp1${i}`] = c - a, s[`cp1${n}`] = h - a * t[u]), l && (a = (l[i] - c) / 3, s[`cp2${i}`] = c + a, s[`cp2${n}`] = h + a * t[u]);
  }
}
function w2(e, t = "x") {
  const i = ty(t), n = e.length, r = Array(n).fill(0), a = Array(n);
  let o, s, l, u = ua(e, 0);
  for (o = 0; o < n; ++o)
    if (s = l, l = u, u = ua(e, o + 1), !!l) {
      if (u) {
        const c = u[t] - l[t];
        r[o] = c !== 0 ? (u[i] - l[i]) / c : 0;
      }
      a[o] = s ? u ? Si(r[o - 1]) !== Si(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o];
    }
  b2(e, r, a), x2(e, a, t);
}
function Jo(e, t, i) {
  return Math.max(Math.min(e, i), t);
}
function S2(e, t) {
  let i, n, r, a, o, s = Mo(e[0], t);
  for (i = 0, n = e.length; i < n; ++i)
    o = a, a = s, s = i < n - 1 && Mo(e[i + 1], t), a && (r = e[i], o && (r.cp1x = Jo(r.cp1x, t.left, t.right), r.cp1y = Jo(r.cp1y, t.top, t.bottom)), s && (r.cp2x = Jo(r.cp2x, t.left, t.right), r.cp2y = Jo(r.cp2y, t.top, t.bottom)));
}
function C2(e, t, i, n, r) {
  let a, o, s, l;
  if (t.spanGaps && (e = e.filter((u) => !u.skip)), t.cubicInterpolationMode === "monotone")
    w2(e, r);
  else {
    let u = n ? e[e.length - 1] : e[0];
    for (a = 0, o = e.length; a < o; ++a)
      s = e[a], l = _2(u, s, e[Math.min(a + 1, o - (n ? 0 : 1)) % o], t.tension), s.cp1x = l.previous.x, s.cp1y = l.previous.y, s.cp2x = l.next.x, s.cp2y = l.next.y, u = s;
  }
  t.capBezierPoints && S2(e, i);
}
function Cd() {
  return typeof window < "u" && typeof document < "u";
}
function Td(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function ul(e, t, i) {
  let n;
  return typeof e == "string" ? (n = parseInt(e, 10), e.indexOf("%") !== -1 && (n = n / 100 * t.parentNode[i])) : n = e, n;
}
const Ql = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function T2(e, t) {
  return Ql(e).getPropertyValue(t);
}
const M2 = [
  "top",
  "right",
  "bottom",
  "left"
];
function sr(e, t, i) {
  const n = {};
  i = i ? "-" + i : "";
  for (let r = 0; r < 4; r++) {
    const a = M2[r];
    n[a] = parseFloat(e[t + "-" + a + i]) || 0;
  }
  return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
}
const k2 = (e, t, i) => (e > 0 || t > 0) && (!i || !i.shadowRoot);
function D2(e, t) {
  const i = e.touches, n = i && i.length ? i[0] : e, { offsetX: r, offsetY: a } = n;
  let o = !1, s, l;
  if (k2(r, a, e.target))
    s = r, l = a;
  else {
    const u = t.getBoundingClientRect();
    s = n.clientX - u.left, l = n.clientY - u.top, o = !0;
  }
  return {
    x: s,
    y: l,
    box: o
  };
}
function qn(e, t) {
  if ("native" in e)
    return e;
  const { canvas: i, currentDevicePixelRatio: n } = t, r = Ql(i), a = r.boxSizing === "border-box", o = sr(r, "padding"), s = sr(r, "border", "width"), { x: l, y: u, box: c } = D2(e, i), h = o.left + (c && s.left), d = o.top + (c && s.top);
  let { width: f, height: v } = t;
  return a && (f -= o.width + s.width, v -= o.height + s.height), {
    x: Math.round((l - h) / f * i.width / n),
    y: Math.round((u - d) / v * i.height / n)
  };
}
function E2(e, t, i) {
  let n, r;
  if (t === void 0 || i === void 0) {
    const a = e && Td(e);
    if (!a)
      t = e.clientWidth, i = e.clientHeight;
    else {
      const o = a.getBoundingClientRect(), s = Ql(a), l = sr(s, "border", "width"), u = sr(s, "padding");
      t = o.width - u.width - l.width, i = o.height - u.height - l.height, n = ul(s.maxWidth, a, "clientWidth"), r = ul(s.maxHeight, a, "clientHeight");
    }
  }
  return {
    width: t,
    height: i,
    maxWidth: n || sl,
    maxHeight: r || sl
  };
}
const on = (e) => Math.round(e * 10) / 10;
function A2(e, t, i, n) {
  const r = Ql(e), a = sr(r, "margin"), o = ul(r.maxWidth, e, "clientWidth") || sl, s = ul(r.maxHeight, e, "clientHeight") || sl, l = E2(e, t, i);
  let { width: u, height: c } = l;
  if (r.boxSizing === "content-box") {
    const d = sr(r, "border", "width"), f = sr(r, "padding");
    u -= f.width + d.width, c -= f.height + d.height;
  }
  return u = Math.max(0, u - a.width), c = Math.max(0, n ? u / n : c - a.height), u = on(Math.min(u, o, l.maxWidth)), c = on(Math.min(c, s, l.maxHeight)), u && !c && (c = on(u / 2)), (t !== void 0 || i !== void 0) && n && l.height && c > l.height && (c = l.height, u = on(Math.floor(c * n))), {
    width: u,
    height: c
  };
}
function av(e, t, i) {
  const n = t || 1, r = on(e.height * n), a = on(e.width * n);
  e.height = on(e.height), e.width = on(e.width);
  const o = e.canvas;
  return o.style && (i || !o.style.height && !o.style.width) && (o.style.height = `${e.height}px`, o.style.width = `${e.width}px`), e.currentDevicePixelRatio !== n || o.height !== r || o.width !== a ? (e.currentDevicePixelRatio = n, o.height = r, o.width = a, e.ctx.setTransform(n, 0, 0, n, 0, 0), !0) : !1;
}
const L2 = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    Cd() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function ov(e, t) {
  const i = T2(e, t), n = i && i.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
function Zn(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: e.y + i * (t.y - e.y)
  };
}
function P2(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: n === "middle" ? i < 0.5 ? e.y : t.y : n === "after" ? i < 1 ? e.y : t.y : i > 0 ? t.y : e.y
  };
}
function I2(e, t, i, n) {
  const r = {
    x: e.cp2x,
    y: e.cp2y
  }, a = {
    x: t.cp1x,
    y: t.cp1y
  }, o = Zn(e, r, i), s = Zn(r, a, i), l = Zn(a, t, i), u = Zn(o, s, i), c = Zn(s, l, i);
  return Zn(u, c, i);
}
const R2 = function(e, t) {
  return {
    x(i) {
      return e + e + t - i;
    },
    setWidth(i) {
      t = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, n) {
      return i - n;
    },
    leftForLtr(i, n) {
      return i - n;
    }
  };
}, O2 = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function ia(e, t, i) {
  return e ? R2(t, i) : O2();
}
function ey(e, t) {
  let i, n;
  (t === "ltr" || t === "rtl") && (i = e.canvas.style, n = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", t, "important"), e.prevTextDirection = n);
}
function iy(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function ny(e) {
  return e === "angle" ? {
    between: To,
    compare: Rx,
    normalize: Pe
  } : {
    between: zi,
    compare: (t, i) => t - i,
    normalize: (t) => t
  };
}
function sv({ start: e, end: t, count: i, loop: n, style: r }) {
  return {
    start: e % i,
    end: t % i,
    loop: n && (t - e + 1) % i === 0,
    style: r
  };
}
function B2(e, t, i) {
  const { property: n, start: r, end: a } = i, { between: o, normalize: s } = ny(n), l = t.length;
  let { start: u, end: c, loop: h } = e, d, f;
  if (h) {
    for (u += l, c += l, d = 0, f = l; d < f && o(s(t[u % l][n]), r, a); ++d)
      u--, c--;
    u %= l, c %= l;
  }
  return c < u && (c += l), {
    start: u,
    end: c,
    loop: h,
    style: e.style
  };
}
function ry(e, t, i) {
  if (!i)
    return [
      e
    ];
  const { property: n, start: r, end: a } = i, o = t.length, { compare: s, between: l, normalize: u } = ny(n), { start: c, end: h, loop: d, style: f } = B2(e, t, i), v = [];
  let m = !1, p = null, g, y, _;
  const b = () => l(r, _, g) && s(r, _) !== 0, w = () => s(a, g) === 0 || l(a, _, g), S = () => m || b(), C = () => !m || w();
  for (let T = c, k = c; T <= h; ++T)
    y = t[T % o], !y.skip && (g = u(y[n]), g !== _ && (m = l(g, r, a), p === null && S() && (p = s(g, r) === 0 ? T : k), p !== null && C() && (v.push(sv({
      start: p,
      end: T,
      loop: d,
      count: o,
      style: f
    })), p = null), k = T, _ = g));
  return p !== null && v.push(sv({
    start: p,
    end: h,
    loop: d,
    count: o,
    style: f
  })), v;
}
function ay(e, t) {
  const i = [], n = e.segments;
  for (let r = 0; r < n.length; r++) {
    const a = ry(n[r], e.points, t);
    a.length && i.push(...a);
  }
  return i;
}
function N2(e, t, i, n) {
  let r = 0, a = t - 1;
  if (i && !n)
    for (; r < t && !e[r].skip; )
      r++;
  for (; r < t && e[r].skip; )
    r++;
  for (r %= t, i && (a += r); a > r && e[a % t].skip; )
    a--;
  return a %= t, {
    start: r,
    end: a
  };
}
function F2(e, t, i, n) {
  const r = e.length, a = [];
  let o = t, s = e[t], l;
  for (l = t + 1; l <= i; ++l) {
    const u = e[l % r];
    u.skip || u.stop ? s.skip || (n = !1, a.push({
      start: t % r,
      end: (l - 1) % r,
      loop: n
    }), t = o = u.stop ? l : null) : (o = l, s.skip && (t = l)), s = u;
  }
  return o !== null && a.push({
    start: t % r,
    end: o % r,
    loop: n
  }), a;
}
function $2(e, t) {
  const i = e.points, n = e.options.spanGaps, r = i.length;
  if (!r)
    return [];
  const a = !!e._loop, { start: o, end: s } = N2(i, r, a, n);
  if (n === !0)
    return lv(e, [
      {
        start: o,
        end: s,
        loop: a
      }
    ], i, t);
  const l = s < o ? s + r : s, u = !!e._fullLoop && o === 0 && s === r - 1;
  return lv(e, F2(i, o, l, u), i, t);
}
function lv(e, t, i, n) {
  return !n || !n.setContext || !i ? t : z2(e, t, i, n);
}
function z2(e, t, i, n) {
  const r = e._chart.getContext(), a = uv(e.options), { _datasetIndex: o, options: { spanGaps: s } } = e, l = i.length, u = [];
  let c = a, h = t[0].start, d = h;
  function f(v, m, p, g) {
    const y = s ? -1 : 1;
    if (v !== m) {
      for (v += l; i[v % l].skip; )
        v -= y;
      for (; i[m % l].skip; )
        m += y;
      v % l !== m % l && (u.push({
        start: v % l,
        end: m % l,
        loop: p,
        style: g
      }), c = g, h = m % l);
    }
  }
  for (const v of t) {
    h = s ? h : v.start;
    let m = i[h % l], p;
    for (d = h + 1; d <= v.end; d++) {
      const g = i[d % l];
      p = uv(n.setContext(xr(r, {
        type: "segment",
        p0: m,
        p1: g,
        p0DataIndex: (d - 1) % l,
        p1DataIndex: d % l,
        datasetIndex: o
      }))), V2(p, c) && f(h, d - 1, v.loop, c), m = g, c = p;
    }
    h < d - 1 && f(h, d - 1, v.loop, c);
  }
  return u;
}
function uv(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function V2(e, t) {
  if (!t)
    return !1;
  const i = [], n = function(r, a) {
    return yd(a) ? (i.includes(a) || i.push(a), i.indexOf(a)) : a;
  };
  return JSON.stringify(e, n) !== JSON.stringify(t, n);
}
function ts(e, t, i) {
  return e.options.clip ? e[i] : t[i];
}
function H2(e, t) {
  const { xScale: i, yScale: n } = e;
  return i && n ? {
    left: ts(i, t, "left"),
    right: ts(i, t, "right"),
    top: ts(n, t, "top"),
    bottom: ts(n, t, "bottom")
  } : t;
}
function oy(e, t) {
  const i = t._clip;
  if (i.disabled)
    return !1;
  const n = H2(t, e.chartArea);
  return {
    left: i.left === !1 ? 0 : n.left - (i.left === !0 ? 0 : i.left),
    right: i.right === !1 ? e.width : n.right + (i.right === !0 ? 0 : i.right),
    top: i.top === !1 ? 0 : n.top - (i.top === !0 ? 0 : i.top),
    bottom: i.bottom === !1 ? e.height : n.bottom + (i.bottom === !0 ? 0 : i.bottom)
  };
}
let W2 = class {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, i, n, r) {
    const a = i.listeners[r], o = i.duration;
    a.forEach((s) => s({
      chart: t,
      initial: i.initial,
      numSteps: o,
      currentStep: Math.min(n - i.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = U0.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let i = 0;
    this._charts.forEach((n, r) => {
      if (!n.running || !n.items.length)
        return;
      const a = n.items;
      let o = a.length - 1, s = !1, l;
      for (; o >= 0; --o)
        l = a[o], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(t), s = !0) : (a[o] = a[a.length - 1], a.pop());
      s && (r.draw(), this._notify(r, n, t, "progress")), a.length || (n.running = !1, this._notify(r, n, t, "complete"), n.initial = !1), i += a.length;
    }), this._lastDate = t, i === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const i = this._charts;
    let n = i.get(t);
    return n || (n = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(t, n)), n;
  }
  listen(t, i, n) {
    this._getAnims(t).listeners[i].push(n);
  }
  add(t, i) {
    !i || !i.length || this._getAnims(t).items.push(...i);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const i = this._charts.get(t);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((n, r) => Math.max(n, r._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const i = this._charts.get(t);
    return !(!i || !i.running || !i.items.length);
  }
  stop(t) {
    const i = this._charts.get(t);
    if (!i || !i.items.length)
      return;
    const n = i.items;
    let r = n.length - 1;
    for (; r >= 0; --r)
      n[r].cancel();
    i.items = [], this._notify(t, i, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
};
var Oi = /* @__PURE__ */ new W2();
const cv = "transparent", Y2 = {
  boolean(e, t, i) {
    return i > 0.5 ? t : e;
  },
  color(e, t, i) {
    const n = Jf(e || cv), r = n.valid && Jf(t || cv);
    return r && r.valid ? r.mix(n, i).hexString() : t;
  },
  number(e, t, i) {
    return e + (t - e) * i;
  }
};
let U2 = class {
  constructor(t, i, n, r) {
    const a = i[n];
    r = Qo([
      t.to,
      r,
      a,
      t.from
    ]);
    const o = Qo([
      t.from,
      a,
      r
    ]);
    this._active = !0, this._fn = t.fn || Y2[t.type || typeof o], this._easing = uo[t.easing] || uo.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = i, this._prop = n, this._from = o, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, i, n) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], a = n - this._start, o = this._duration - a;
      this._start = n, this._duration = Math.floor(Math.max(o, t.duration)), this._total += a, this._loop = !!t.loop, this._to = Qo([
        t.to,
        i,
        r,
        t.from
      ]), this._from = Qo([
        t.from,
        r,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const i = t - this._start, n = this._duration, r = this._prop, a = this._from, o = this._loop, s = this._to;
    let l;
    if (this._active = a !== s && (o || i < n), !this._active) {
      this._target[r] = s, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[r] = a;
      return;
    }
    l = i / n % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(a, s, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((i, n) => {
      t.push({
        res: i,
        rej: n
      });
    });
  }
  _notify(t) {
    const i = t ? "res" : "rej", n = this._promises || [];
    for (let r = 0; r < n.length; r++)
      n[r][i]();
  }
};
class sy {
  constructor(t, i) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(t) {
    if (!ut(t))
      return;
    const i = Object.keys(Wt.animation), n = this._properties;
    Object.getOwnPropertyNames(t).forEach((r) => {
      const a = t[r];
      if (!ut(a))
        return;
      const o = {};
      for (const s of i)
        o[s] = a[s];
      (Ut(a.properties) && a.properties || [
        r
      ]).forEach((s) => {
        (s === r || !n.has(s)) && n.set(s, o);
      });
    });
  }
  _animateOptions(t, i) {
    const n = i.options, r = X2(t, n);
    if (!r)
      return [];
    const a = this._createAnimations(r, n);
    return n.$shared && G2(t.options.$animations, n).then(() => {
      t.options = n;
    }, () => {
    }), a;
  }
  _createAnimations(t, i) {
    const n = this._properties, r = [], a = t.$animations || (t.$animations = {}), o = Object.keys(i), s = Date.now();
    let l;
    for (l = o.length - 1; l >= 0; --l) {
      const u = o[l];
      if (u.charAt(0) === "$")
        continue;
      if (u === "options") {
        r.push(...this._animateOptions(t, i));
        continue;
      }
      const c = i[u];
      let h = a[u];
      const d = n.get(u);
      if (h)
        if (d && h.active()) {
          h.update(d, c, s);
          continue;
        } else
          h.cancel();
      if (!d || !d.duration) {
        t[u] = c;
        continue;
      }
      a[u] = h = new U2(d, t, u, c), r.push(h);
    }
    return r;
  }
  update(t, i) {
    if (this._properties.size === 0) {
      Object.assign(t, i);
      return;
    }
    const n = this._createAnimations(t, i);
    if (n.length)
      return Oi.add(this._chart, n), !0;
  }
}
function G2(e, t) {
  const i = [], n = Object.keys(t);
  for (let r = 0; r < n.length; r++) {
    const a = e[n[r]];
    a && a.active() && i.push(a.wait());
  }
  return Promise.all(i);
}
function X2(e, t) {
  if (!t)
    return;
  let i = e.options;
  if (!i) {
    e.options = t;
    return;
  }
  return i.$shared && (e.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function hv(e, t) {
  const i = e && e.options || {}, n = i.reverse, r = i.min === void 0 ? t : 0, a = i.max === void 0 ? t : 0;
  return {
    start: n ? a : r,
    end: n ? r : a
  };
}
function j2(e, t, i) {
  if (i === !1)
    return !1;
  const n = hv(e, i), r = hv(t, i);
  return {
    top: r.end,
    right: n.end,
    bottom: r.start,
    left: n.start
  };
}
function q2(e) {
  let t, i, n, r;
  return ut(e) ? (t = e.top, i = e.right, n = e.bottom, r = e.left) : t = i = n = r = e, {
    top: t,
    right: i,
    bottom: n,
    left: r,
    disabled: e === !1
  };
}
function ly(e, t) {
  const i = [], n = e._getSortedDatasetMetas(t);
  let r, a;
  for (r = 0, a = n.length; r < a; ++r)
    i.push(n[r].index);
  return i;
}
function dv(e, t, i, n = {}) {
  const r = e.keys, a = n.mode === "single";
  let o, s, l, u;
  if (t === null)
    return;
  let c = !1;
  for (o = 0, s = r.length; o < s; ++o) {
    if (l = +r[o], l === i) {
      if (c = !0, n.all)
        continue;
      break;
    }
    u = e.values[l], de(u) && (a || t === 0 || Si(t) === Si(u)) && (t += u);
  }
  return !c && !n.all ? 0 : t;
}
function Z2(e, t) {
  const { iScale: i, vScale: n } = t, r = i.axis === "x" ? "x" : "y", a = n.axis === "x" ? "x" : "y", o = Object.keys(e), s = new Array(o.length);
  let l, u, c;
  for (l = 0, u = o.length; l < u; ++l)
    c = o[l], s[l] = {
      [r]: c,
      [a]: e[c]
    };
  return s;
}
function Mu(e, t) {
  const i = e && e.options.stacked;
  return i || i === void 0 && t.stack !== void 0;
}
function K2(e, t, i) {
  return `${e.id}.${t.id}.${i.stack || i.type}`;
}
function Q2(e) {
  const { min: t, max: i, minDefined: n, maxDefined: r } = e.getUserBounds();
  return {
    min: n ? t : Number.NEGATIVE_INFINITY,
    max: r ? i : Number.POSITIVE_INFINITY
  };
}
function J2(e, t, i) {
  const n = e[t] || (e[t] = {});
  return n[i] || (n[i] = {});
}
function fv(e, t, i, n) {
  for (const r of t.getMatchingVisibleMetas(n).reverse()) {
    const a = e[r.index];
    if (i && a > 0 || !i && a < 0)
      return r.index;
  }
  return null;
}
function vv(e, t) {
  const { chart: i, _cachedMeta: n } = e, r = i._stacks || (i._stacks = {}), { iScale: a, vScale: o, index: s } = n, l = a.axis, u = o.axis, c = K2(a, o, n), h = t.length;
  let d;
  for (let f = 0; f < h; ++f) {
    const v = t[f], { [l]: m, [u]: p } = v, g = v._stacks || (v._stacks = {});
    d = g[u] = J2(r, c, m), d[s] = p, d._top = fv(d, o, !0, n.type), d._bottom = fv(d, o, !1, n.type);
    const y = d._visualValues || (d._visualValues = {});
    y[s] = p;
  }
}
function ku(e, t) {
  const i = e.scales;
  return Object.keys(i).filter((n) => i[n].axis === t).shift();
}
function tw(e, t) {
  return xr(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function ew(e, t, i) {
  return xr(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: t,
    mode: "default",
    type: "data"
  });
}
function wa(e, t) {
  const i = e.controller.index, n = e.vScale && e.vScale.axis;
  if (n) {
    t = t || e._parsed;
    for (const r of t) {
      const a = r._stacks;
      if (!a || a[n] === void 0 || a[n][i] === void 0)
        return;
      delete a[n][i], a[n]._visualValues !== void 0 && a[n]._visualValues[i] !== void 0 && delete a[n]._visualValues[i];
    }
  }
}
const Du = (e) => e === "reset" || e === "none", pv = (e, t) => t ? e : Object.assign({}, e), iw = (e, t, i) => e && !t.hidden && t._stacked && {
  keys: ly(i, !0),
  values: null
};
class Jl {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, i) {
    this.chart = t, this._ctx = t.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = Mu(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && wa(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, i = this._cachedMeta, n = this.getDataset(), r = (h, d, f, v) => h === "x" ? d : h === "r" ? v : f, a = i.xAxisID = at(n.xAxisID, ku(t, "x")), o = i.yAxisID = at(n.yAxisID, ku(t, "y")), s = i.rAxisID = at(n.rAxisID, ku(t, "r")), l = i.indexAxis, u = i.iAxisID = r(l, a, o, s), c = i.vAxisID = r(l, o, a, s);
    i.xScale = this.getScaleForId(a), i.yScale = this.getScaleForId(o), i.rScale = this.getScaleForId(s), i.iScale = this.getScaleForId(u), i.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const i = this._cachedMeta;
    return t === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && Zf(this._data, this), t._stacked && wa(t);
  }
  _dataCheck() {
    const t = this.getDataset(), i = t.data || (t.data = []), n = this._data;
    if (ut(i)) {
      const r = this._cachedMeta;
      this._data = Z2(i, r);
    } else if (n !== i) {
      if (n) {
        Zf(n, this);
        const r = this._cachedMeta;
        wa(r), r._parsed = [];
      }
      i && Object.isExtensible(i) && Fx(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const i = this._cachedMeta, n = this.getDataset();
    let r = !1;
    this._dataCheck();
    const a = i._stacked;
    i._stacked = Mu(i.vScale, i), i.stack !== n.stack && (r = !0, wa(i), i.stack = n.stack), this._resyncElements(t), (r || a !== i._stacked) && (vv(this, i._parsed), i._stacked = Mu(i.vScale, i));
  }
  configure() {
    const t = this.chart.config, i = t.datasetScopeKeys(this._type), n = t.getOptionScopes(this.getDataset(), i, !0);
    this.options = t.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, i) {
    const { _cachedMeta: n, _data: r } = this, { iScale: a, _stacked: o } = n, s = a.axis;
    let l = t === 0 && i === r.length ? !0 : n._sorted, u = t > 0 && n._parsed[t - 1], c, h, d;
    if (this._parsing === !1)
      n._parsed = r, n._sorted = !0, d = r;
    else {
      Ut(r[t]) ? d = this.parseArrayData(n, r, t, i) : ut(r[t]) ? d = this.parseObjectData(n, r, t, i) : d = this.parsePrimitiveData(n, r, t, i);
      const f = () => h[s] === null || u && h[s] < u[s];
      for (c = 0; c < i; ++c)
        n._parsed[c + t] = h = d[c], l && (f() && (l = !1), u = h);
      n._sorted = l;
    }
    o && vv(this, d);
  }
  parsePrimitiveData(t, i, n, r) {
    const { iScale: a, vScale: o } = t, s = a.axis, l = o.axis, u = a.getLabels(), c = a === o, h = new Array(r);
    let d, f, v;
    for (d = 0, f = r; d < f; ++d)
      v = d + n, h[d] = {
        [s]: c || a.parse(u[v], v),
        [l]: o.parse(i[v], v)
      };
    return h;
  }
  parseArrayData(t, i, n, r) {
    const { xScale: a, yScale: o } = t, s = new Array(r);
    let l, u, c, h;
    for (l = 0, u = r; l < u; ++l)
      c = l + n, h = i[c], s[l] = {
        x: a.parse(h[0], c),
        y: o.parse(h[1], c)
      };
    return s;
  }
  parseObjectData(t, i, n, r) {
    const { xScale: a, yScale: o } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(r);
    let c, h, d, f;
    for (c = 0, h = r; c < h; ++c)
      d = c + n, f = i[d], u[c] = {
        x: a.parse(gr(f, s), d),
        y: o.parse(gr(f, l), d)
      };
    return u;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, i, n) {
    const r = this.chart, a = this._cachedMeta, o = i[t.axis], s = {
      keys: ly(r, !0),
      values: i._stacks[t.axis]._visualValues
    };
    return dv(s, o, a.index, {
      mode: n
    });
  }
  updateRangeFromParsed(t, i, n, r) {
    const a = n[i.axis];
    let o = a === null ? NaN : a;
    const s = r && n._stacks[i.axis];
    r && s && (r.values = s, o = dv(r, a, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);
  }
  getMinMax(t, i) {
    const n = this._cachedMeta, r = n._parsed, a = n._sorted && t === n.iScale, o = r.length, s = this._getOtherScale(t), l = iw(i, n, this.chart), u = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: h } = Q2(s);
    let d, f;
    function v() {
      f = r[d];
      const m = f[s.axis];
      return !de(f[t.axis]) || c > m || h < m;
    }
    for (d = 0; d < o && !(!v() && (this.updateRangeFromParsed(u, t, f, l), a)); ++d)
      ;
    if (a) {
      for (d = o - 1; d >= 0; --d)
        if (!v()) {
          this.updateRangeFromParsed(u, t, f, l);
          break;
        }
    }
    return u;
  }
  getAllParsedValues(t) {
    const i = this._cachedMeta._parsed, n = [];
    let r, a, o;
    for (r = 0, a = i.length; r < a; ++r)
      o = i[r][t.axis], de(o) && n.push(o);
    return n;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = i.iScale, r = i.vScale, a = this.getParsed(t);
    return {
      label: n ? "" + n.getLabelForValue(a[n.axis]) : "",
      value: r ? "" + r.getLabelForValue(a[r.axis]) : ""
    };
  }
  _update(t) {
    const i = this._cachedMeta;
    this.update(t || "default"), i._clip = q2(at(this.options.clip, j2(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, i = this.chart, n = this._cachedMeta, r = n.data || [], a = i.chartArea, o = [], s = this._drawStart || 0, l = this._drawCount || r.length - s, u = this.options.drawActiveElementsOnTop;
    let c;
    for (n.dataset && n.dataset.draw(t, a, s, l), c = s; c < s + l; ++c) {
      const h = r[c];
      h.hidden || (h.active && u ? o.push(h) : h.draw(t, a));
    }
    for (c = 0; c < o.length; ++c)
      o[c].draw(t, a);
  }
  getStyle(t, i) {
    const n = i ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(t || 0, n);
  }
  getContext(t, i, n) {
    const r = this.getDataset();
    let a;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[t];
      a = o.$context || (o.$context = ew(this.getContext(), t, o)), a.parsed = this.getParsed(t), a.raw = r.data[t], a.index = a.dataIndex = t;
    } else
      a = this.$context || (this.$context = tw(this.chart.getContext(), this.index)), a.dataset = r, a.index = a.datasetIndex = this.index;
    return a.active = !!i, a.mode = n, a;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, t);
  }
  _resolveElementOptions(t, i = "default", n) {
    const r = i === "active", a = this._cachedDataOpts, o = t + "-" + i, s = a[o], l = this.enableOptionSharing && So(n);
    if (s)
      return pv(s, l);
    const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, t), h = r ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], d = u.getOptionScopes(this.getDataset(), c), f = Object.keys(Wt.elements[t]), v = () => this.getContext(n, r, i), m = u.resolveNamedOptions(d, f, v, h);
    return m.$shared && (m.$shared = l, a[o] = Object.freeze(pv(m, l))), m;
  }
  _resolveAnimations(t, i, n) {
    const r = this.chart, a = this._cachedDataOpts, o = `animation-${i}`, s = a[o];
    if (s)
      return s;
    let l;
    if (r.options.animation !== !1) {
      const c = this.chart.config, h = c.datasetAnimationScopeKeys(this._type, i), d = c.getOptionScopes(this.getDataset(), h);
      l = c.createResolver(d, this.getContext(t, n, i));
    }
    const u = new sy(r, l && l.animations);
    return l && l._cacheable && (a[o] = Object.freeze(u)), u;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, i) {
    return !i || Du(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, i) {
    const n = this.resolveDataElementOptions(t, i), r = this._sharedOptions, a = this.getSharedOptions(n), o = this.includeOptions(i, a) || a !== r;
    return this.updateSharedOptions(a, i, n), {
      sharedOptions: a,
      includeOptions: o
    };
  }
  updateElement(t, i, n, r) {
    Du(r) ? Object.assign(t, n) : this._resolveAnimations(i, r).update(t, n);
  }
  updateSharedOptions(t, i, n) {
    t && !Du(i) && this._resolveAnimations(void 0, i).update(t, n);
  }
  _setStyle(t, i, n, r) {
    t.active = r;
    const a = this.getStyle(i, r);
    this._resolveAnimations(i, n, r).update(t, {
      options: !r && this.getSharedOptions(a) || a
    });
  }
  removeHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !1);
  }
  setHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const i = this._data, n = this._cachedMeta.data;
    for (const [s, l, u] of this._syncList)
      this[s](l, u);
    this._syncList = [];
    const r = n.length, a = i.length, o = Math.min(a, r);
    o && this.parse(0, o), a > r ? this._insertElements(r, a - r, t) : a < r && this._removeElements(a, r - a);
  }
  _insertElements(t, i, n = !0) {
    const r = this._cachedMeta, a = r.data, o = t + i;
    let s;
    const l = (u) => {
      for (u.length += i, s = u.length - 1; s >= o; s--)
        u[s] = u[s - i];
    };
    for (l(a), s = t; s < o; ++s)
      a[s] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(t, i), n && this.updateElements(a, t, i, "reset");
  }
  updateElements(t, i, n, r) {
  }
  _removeElements(t, i) {
    const n = this._cachedMeta;
    if (this._parsing) {
      const r = n._parsed.splice(t, i);
      n._stacked && wa(n, r);
    }
    n.data.splice(t, i);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [i, n, r] = t;
      this[i](n, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, i) {
    i && this._sync([
      "_removeElements",
      t,
      i
    ]);
    const n = arguments.length - 2;
    n && this._sync([
      "_insertElements",
      t,
      n
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function nw(e, t) {
  if (!e._cache.$bar) {
    const i = e.getMatchingVisibleMetas(t);
    let n = [];
    for (let r = 0, a = i.length; r < a; r++)
      n = n.concat(i[r].controller.getAllParsedValues(e));
    e._cache.$bar = Y0(n.sort((r, a) => r - a));
  }
  return e._cache.$bar;
}
function rw(e) {
  const t = e.iScale, i = nw(t, e.type);
  let n = t._length, r, a, o, s;
  const l = () => {
    o === 32767 || o === -32768 || (So(s) && (n = Math.min(n, Math.abs(o - s) || n)), s = o);
  };
  for (r = 0, a = i.length; r < a; ++r)
    o = t.getPixelForValue(i[r]), l();
  for (s = void 0, r = 0, a = t.ticks.length; r < a; ++r)
    o = t.getPixelForTick(r), l();
  return n;
}
function aw(e, t, i, n) {
  const r = i.barThickness;
  let a, o;
  return gt(r) ? (a = t.min * i.categoryPercentage, o = i.barPercentage) : (a = r * n, o = 1), {
    chunk: a / n,
    ratio: o,
    start: t.pixels[e] - a / 2
  };
}
function ow(e, t, i, n) {
  const r = t.pixels, a = r[e];
  let o = e > 0 ? r[e - 1] : null, s = e < r.length - 1 ? r[e + 1] : null;
  const l = i.categoryPercentage;
  o === null && (o = a - (s === null ? t.end - t.start : s - a)), s === null && (s = a + a - o);
  const u = a - (a - Math.min(o, s)) / 2 * l;
  return {
    chunk: Math.abs(s - o) / 2 * l / n,
    ratio: i.barPercentage,
    start: u
  };
}
function sw(e, t, i, n) {
  const r = i.parse(e[0], n), a = i.parse(e[1], n), o = Math.min(r, a), s = Math.max(r, a);
  let l = o, u = s;
  Math.abs(o) > Math.abs(s) && (l = s, u = o), t[i.axis] = u, t._custom = {
    barStart: l,
    barEnd: u,
    start: r,
    end: a,
    min: o,
    max: s
  };
}
function uy(e, t, i, n) {
  return Ut(e) ? sw(e, t, i, n) : t[i.axis] = i.parse(e, n), t;
}
function gv(e, t, i, n) {
  const r = e.iScale, a = e.vScale, o = r.getLabels(), s = r === a, l = [];
  let u, c, h, d;
  for (u = i, c = i + n; u < c; ++u)
    d = t[u], h = {}, h[r.axis] = s || r.parse(o[u], u), l.push(uy(d, h, a, u));
  return l;
}
function Eu(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function lw(e, t, i) {
  return e !== 0 ? Si(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= i ? 1 : -1);
}
function uw(e) {
  let t, i, n, r, a;
  return e.horizontal ? (t = e.base > e.x, i = "left", n = "right") : (t = e.base < e.y, i = "bottom", n = "top"), t ? (r = "end", a = "start") : (r = "start", a = "end"), {
    start: i,
    end: n,
    reverse: t,
    top: r,
    bottom: a
  };
}
function cw(e, t, i, n) {
  let r = t.borderSkipped;
  const a = {};
  if (!r) {
    e.borderSkipped = a;
    return;
  }
  if (r === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: o, end: s, reverse: l, top: u, bottom: c } = uw(e);
  r === "middle" && i && (e.enableBorderRadius = !0, (i._top || 0) === n ? r = u : (i._bottom || 0) === n ? r = c : (a[mv(c, o, s, l)] = !0, r = u)), a[mv(r, o, s, l)] = !0, e.borderSkipped = a;
}
function mv(e, t, i, n) {
  return n ? (e = hw(e, t, i), e = yv(e, i, t)) : e = yv(e, t, i), e;
}
function hw(e, t, i) {
  return e === t ? i : e === i ? t : e;
}
function yv(e, t, i) {
  return e === "start" ? t : e === "end" ? i : e;
}
function dw(e, { inflateAmount: t }, i) {
  e.inflateAmount = t === "auto" ? i === 1 ? 0.33 : 0 : t;
}
class fw extends Jl {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, i, n, r) {
    return gv(t, i, n, r);
  }
  parseArrayData(t, i, n, r) {
    return gv(t, i, n, r);
  }
  parseObjectData(t, i, n, r) {
    const { iScale: a, vScale: o } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, u = a.axis === "x" ? s : l, c = o.axis === "x" ? s : l, h = [];
    let d, f, v, m;
    for (d = n, f = n + r; d < f; ++d)
      m = i[d], v = {}, v[a.axis] = a.parse(gr(m, u), d), h.push(uy(gr(m, c), v, o, d));
    return h;
  }
  updateRangeFromParsed(t, i, n, r) {
    super.updateRangeFromParsed(t, i, n, r);
    const a = n._custom;
    a && i === this._cachedMeta.vScale && (t.min = Math.min(t.min, a.min), t.max = Math.max(t.max, a.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, { iScale: n, vScale: r } = i, a = this.getParsed(t), o = a._custom, s = Eu(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(a[r.axis]);
    return {
      label: "" + n.getLabelForValue(a[n.axis]),
      value: s
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const i = this._cachedMeta;
    this.updateElements(i.data, 0, i.data.length, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { index: o, _cachedMeta: { vScale: s } } = this, l = s.getBasePixel(), u = s.isHorizontal(), c = this._getRuler(), { sharedOptions: h, includeOptions: d } = this._getSharedOptions(i, r);
    for (let f = i; f < i + n; f++) {
      const v = this.getParsed(f), m = a || gt(v[s.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(f), p = this._calculateBarIndexPixels(f, c), g = (v._stacks || {})[s.axis], y = {
        horizontal: u,
        base: m.base,
        enableBorderRadius: !g || Eu(v._custom) || o === g._top || o === g._bottom,
        x: u ? m.head : p.center,
        y: u ? p.center : m.head,
        height: u ? p.size : Math.abs(m.size),
        width: u ? Math.abs(m.size) : p.size
      };
      d && (y.options = h || this.resolveDataElementOptions(f, t[f].active ? "active" : r));
      const _ = y.options || t[f].options;
      cw(y, _, g, o), dw(y, _, c.ratio), this.updateElement(t[f], f, y, r);
    }
  }
  _getStacks(t, i) {
    const { iScale: n } = this._cachedMeta, r = n.getMatchingVisibleMetas(this._type).filter((c) => c.controller.options.grouped), a = n.options.stacked, o = [], s = this._cachedMeta.controller.getParsed(i), l = s && s[n.axis], u = (c) => {
      const h = c._parsed.find((f) => f[n.axis] === l), d = h && h[c.vScale.axis];
      if (gt(d) || isNaN(d))
        return !0;
    };
    for (const c of r)
      if (!(i !== void 0 && u(c)) && ((a === !1 || o.indexOf(c.stack) === -1 || a === void 0 && c.stack === void 0) && o.push(c.stack), c.index === t))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, i = this.chart.options.indexAxis;
    return Object.keys(t).filter((n) => t[n].axis === i).shift();
  }
  _getAxis() {
    const t = {}, i = this.getFirstScaleIdForIndexAxis();
    for (const n of this.chart.data.datasets)
      t[at(this.chart.options.indexAxis === "x" ? n.xAxisID : n.yAxisID, i)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, i, n) {
    const r = this._getStacks(t, n), a = i !== void 0 ? r.indexOf(i) : -1;
    return a === -1 ? r.length - 1 : a;
  }
  _getRuler() {
    const t = this.options, i = this._cachedMeta, n = i.iScale, r = [];
    let a, o;
    for (a = 0, o = i.data.length; a < o; ++a)
      r.push(n.getPixelForValue(this.getParsed(a)[n.axis], a));
    const s = t.barThickness;
    return {
      min: s || rw(i),
      pixels: r,
      start: n._startPixel,
      end: n._endPixel,
      stackCount: this._getStackCount(),
      scale: n,
      grouped: t.grouped,
      ratio: s ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: i, _stacked: n, index: r }, options: { base: a, minBarLength: o } } = this, s = a || 0, l = this.getParsed(t), u = l._custom, c = Eu(u);
    let h = l[i.axis], d = 0, f = n ? this.applyStack(i, l, n) : h, v, m;
    f !== h && (d = f - h, f = h), c && (h = u.barStart, f = u.barEnd - u.barStart, h !== 0 && Si(h) !== Si(u.barEnd) && (d = 0), d += h);
    const p = !gt(a) && !c ? a : d;
    let g = i.getPixelForValue(p);
    if (this.chart.getDataVisibility(t) ? v = i.getPixelForValue(d + f) : v = g, m = v - g, Math.abs(m) < o) {
      m = lw(m, i, s) * o, h === s && (g -= m / 2);
      const y = i.getPixelForDecimal(0), _ = i.getPixelForDecimal(1), b = Math.min(y, _), w = Math.max(y, _);
      g = Math.max(Math.min(g, w), b), v = g + m, n && !c && (l._stacks[i.axis]._visualValues[r] = i.getValueForPixel(v) - i.getValueForPixel(g));
    }
    if (g === i.getPixelForValue(s)) {
      const y = Si(m) * i.getLineWidthForValue(s) / 2;
      g += y, m -= y;
    }
    return {
      size: m,
      base: g,
      head: v,
      center: v + m / 2
    };
  }
  _calculateBarIndexPixels(t, i) {
    const n = i.scale, r = this.options, a = r.skipNull, o = at(r.maxBarThickness, 1 / 0);
    let s, l;
    const u = this._getAxisCount();
    if (i.grouped) {
      const c = a ? this._getStackCount(t) : i.stackCount, h = r.barThickness === "flex" ? ow(t, i, r, c * u) : aw(t, i, r, c * u), d = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, f = this._getAxis().indexOf(at(d, this.getFirstScaleIdForIndexAxis())), v = this._getStackIndex(this.index, this._cachedMeta.stack, a ? t : void 0) + f;
      s = h.start + h.chunk * v + h.chunk / 2, l = Math.min(o, h.chunk * h.ratio);
    } else
      s = n.getPixelForValue(this.getParsed(t)[n.axis], t), l = Math.min(o, i.min * i.ratio);
    return {
      base: s - l / 2,
      head: s + l / 2,
      center: s,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, i = t.vScale, n = t.data, r = n.length;
    let a = 0;
    for (; a < r; ++a)
      this.getParsed(a)[i.axis] !== null && !n[a].hidden && n[a].draw(this._ctx);
  }
}
function vw(e, t, i) {
  let n = 1, r = 1, a = 0, o = 0;
  if (t < Rt) {
    const s = e, l = s + t, u = Math.cos(s), c = Math.sin(s), h = Math.cos(l), d = Math.sin(l), f = (_, b, w) => To(_, s, l, !0) ? 1 : Math.max(b, b * i, w, w * i), v = (_, b, w) => To(_, s, l, !0) ? -1 : Math.min(b, b * i, w, w * i), m = f(0, u, h), p = f(Kt, c, d), g = v(bt, u, h), y = v(bt + Kt, c, d);
    n = (m - g) / 2, r = (p - y) / 2, a = -(m + g) / 2, o = -(p + y) / 2;
  }
  return {
    ratioX: n,
    ratioY: r,
    offsetX: a,
    offsetY: o
  };
}
class pw extends Jl {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const i = t.data, { labels: { pointStyle: n, textAlign: r, color: a, useBorderRadius: o, borderRadius: s } } = t.legend.options;
            return i.labels.length && i.datasets.length ? i.labels.map((l, u) => {
              const h = t.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: l,
                fillStyle: h.backgroundColor,
                fontColor: a,
                hidden: !t.getDataVisibility(u),
                lineDash: h.borderDash,
                lineDashOffset: h.borderDashOffset,
                lineJoin: h.borderJoinStyle,
                lineWidth: h.borderWidth,
                strokeStyle: h.borderColor,
                textAlign: r,
                pointStyle: n,
                borderRadius: o && (s || h.borderRadius),
                index: u
              };
            }) : [];
          }
        },
        onClick(t, i, n) {
          n.chart.toggleDataVisibility(i.index), n.chart.update();
        }
      }
    }
  };
  constructor(t, i) {
    super(t, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, i) {
    const n = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = n;
    else {
      let a = (l) => +n[l];
      if (ut(n[t])) {
        const { key: l = "value" } = this._parsing;
        a = (u) => +gr(n[u], l);
      }
      let o, s;
      for (o = t, s = t + i; o < s; ++o)
        r._parsed[o] = a(o);
    }
  }
  _getRotation() {
    return $i(this.options.rotation - 90);
  }
  _getCircumference() {
    return $i(this.options.circumference);
  }
  _getRotationExtents() {
    let t = Rt, i = -Rt;
    for (let n = 0; n < this.chart.data.datasets.length; ++n)
      if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
        const r = this.chart.getDatasetMeta(n).controller, a = r._getRotation(), o = r._getCircumference();
        t = Math.min(t, a), i = Math.max(i, a + o);
      }
    return {
      rotation: t,
      circumference: i - t
    };
  }
  update(t) {
    const i = this.chart, { chartArea: n } = i, r = this._cachedMeta, a = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing, s = Math.max((Math.min(n.width, n.height) - o) / 2, 0), l = Math.min(bx(this.options.cutout, s), 1), u = this._getRingWeight(this.index), { circumference: c, rotation: h } = this._getRotationExtents(), { ratioX: d, ratioY: f, offsetX: v, offsetY: m } = vw(h, c, l), p = (n.width - o) / d, g = (n.height - o) / f, y = Math.max(Math.min(p, g) / 2, 0), _ = $0(this.options.radius, y), b = Math.max(_ * l, 0), w = (_ - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = v * _, this.offsetY = m * _, r.total = this.calculateTotal(), this.outerRadius = _ - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * u, 0), this.updateElements(a, 0, a.length, t);
  }
  _circumference(t, i) {
    const n = this.options, r = this._cachedMeta, a = this._getCircumference();
    return i && n.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * a / Rt);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", o = this.chart, s = o.chartArea, u = o.options.animation, c = (s.left + s.right) / 2, h = (s.top + s.bottom) / 2, d = a && u.animateScale, f = d ? 0 : this.innerRadius, v = d ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: p } = this._getSharedOptions(i, r);
    let g = this._getRotation(), y;
    for (y = 0; y < i; ++y)
      g += this._circumference(y, a);
    for (y = i; y < i + n; ++y) {
      const _ = this._circumference(y, a), b = t[y], w = {
        x: c + this.offsetX,
        y: h + this.offsetY,
        startAngle: g,
        endAngle: g + _,
        circumference: _,
        outerRadius: v,
        innerRadius: f
      };
      p && (w.options = m || this.resolveDataElementOptions(y, b.active ? "active" : r)), g += _, this.updateElement(b, y, w, r);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, i = t.data;
    let n = 0, r;
    for (r = 0; r < i.length; r++) {
      const a = t._parsed[r];
      a !== null && !isNaN(a) && this.chart.getDataVisibility(r) && !i[r].hidden && (n += Math.abs(a));
    }
    return n;
  }
  calculateCircumference(t) {
    const i = this._cachedMeta.total;
    return i > 0 && !isNaN(t) ? Rt * (Math.abs(t) / i) : 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = this.chart, r = n.data.labels || [], a = _d(i._parsed[t], n.options.locale);
    return {
      label: r[t] || "",
      value: a
    };
  }
  getMaxBorderWidth(t) {
    let i = 0;
    const n = this.chart;
    let r, a, o, s, l;
    if (!t) {
      for (r = 0, a = n.data.datasets.length; r < a; ++r)
        if (n.isDatasetVisible(r)) {
          o = n.getDatasetMeta(r), t = o.data, s = o.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (r = 0, a = t.length; r < a; ++r)
      l = s.resolveDataElementOptions(r), l.borderAlign !== "inner" && (i = Math.max(i, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return i;
  }
  getMaxOffset(t) {
    let i = 0;
    for (let n = 0, r = t.length; n < r; ++n) {
      const a = this.resolveDataElementOptions(n);
      i = Math.max(i, a.offset || 0, a.hoverOffset || 0);
    }
    return i;
  }
  _getRingWeightOffset(t) {
    let i = 0;
    for (let n = 0; n < t; ++n)
      this.chart.isDatasetVisible(n) && (i += this._getRingWeight(n));
    return i;
  }
  _getRingWeight(t) {
    return Math.max(at(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class gw extends Jl {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const i = this._cachedMeta, { dataset: n, data: r = [], _dataset: a } = i, o = this.chart._animationsDisabled;
    let { start: s, count: l } = Vx(i, r, o);
    this._drawStart = s, this._drawCount = l, Hx(i) && (s = 0, l = r.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!a._decimated, n.points = r;
    const u = this.resolveDatasetElementOptions(t);
    this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(n, void 0, {
      animated: !o,
      options: u
    }, t), this.updateElements(r, s, l, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { iScale: o, vScale: s, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: h } = this._getSharedOptions(i, r), d = o.axis, f = s.axis, { spanGaps: v, segment: m } = this.options, p = Co(v) ? v : Number.POSITIVE_INFINITY, g = this.chart._animationsDisabled || a || r === "none", y = i + n, _ = t.length;
    let b = i > 0 && this.getParsed(i - 1);
    for (let w = 0; w < _; ++w) {
      const S = t[w], C = g ? S : {};
      if (w < i || w >= y) {
        C.skip = !0;
        continue;
      }
      const T = this.getParsed(w), k = gt(T[f]), M = C[d] = o.getPixelForValue(T[d], w), D = C[f] = a || k ? s.getBasePixel() : s.getPixelForValue(l ? this.applyStack(s, T, l) : T[f], w);
      C.skip = isNaN(M) || isNaN(D) || k, C.stop = w > 0 && Math.abs(T[d] - b[d]) > p, m && (C.parsed = T, C.raw = u.data[w]), h && (C.options = c || this.resolveDataElementOptions(w, S.active ? "active" : r)), g || this.updateElement(S, w, C, r), b = T;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, i = t.dataset, n = i.options && i.options.borderWidth || 0, r = t.data || [];
    if (!r.length)
      return n;
    const a = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(n, a, o) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
class mw extends pw {
  static id = "pie";
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
}
function Cn() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class Md {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(Md.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return Cn();
  }
  parse() {
    return Cn();
  }
  format() {
    return Cn();
  }
  add() {
    return Cn();
  }
  diff() {
    return Cn();
  }
  startOf() {
    return Cn();
  }
  endOf() {
    return Cn();
  }
}
var yw = {
  _date: Md
};
function _w(e, t, i, n) {
  const { controller: r, data: a, _sorted: o } = e, s = r._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (s && t === s.axis && t !== "r" && o && a.length) {
    const u = s._reversePixels ? Bx : tr;
    if (n) {
      if (r._sharedOptions) {
        const c = a[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const d = u(a, t, i - h), f = u(a, t, i + h);
          return {
            lo: d.lo,
            hi: f.hi
          };
        }
      }
    } else {
      const c = u(a, t, i);
      if (l) {
        const { vScale: h } = r._cachedMeta, { _parsed: d } = e, f = d.slice(0, c.lo + 1).reverse().findIndex((m) => !gt(m[h.axis]));
        c.lo -= Math.max(0, f);
        const v = d.slice(c.hi).findIndex((m) => !gt(m[h.axis]));
        c.hi += Math.max(0, v);
      }
      return c;
    }
  }
  return {
    lo: 0,
    hi: a.length - 1
  };
}
function tu(e, t, i, n, r) {
  const a = e.getSortedVisibleDatasetMetas(), o = i[t];
  for (let s = 0, l = a.length; s < l; ++s) {
    const { index: u, data: c } = a[s], { lo: h, hi: d } = _w(a[s], t, o, r);
    for (let f = h; f <= d; ++f) {
      const v = c[f];
      v.skip || n(v, u, f);
    }
  }
}
function bw(e) {
  const t = e.indexOf("x") !== -1, i = e.indexOf("y") !== -1;
  return function(n, r) {
    const a = t ? Math.abs(n.x - r.x) : 0, o = i ? Math.abs(n.y - r.y) : 0;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2));
  };
}
function Au(e, t, i, n, r) {
  const a = [];
  return !r && !e.isPointInArea(t) || tu(e, i, t, function(s, l, u) {
    !r && !Mo(s, e.chartArea, 0) || s.inRange(t.x, t.y, n) && a.push({
      element: s,
      datasetIndex: l,
      index: u
    });
  }, !0), a;
}
function xw(e, t, i, n) {
  let r = [];
  function a(o, s, l) {
    const { startAngle: u, endAngle: c } = o.getProps([
      "startAngle",
      "endAngle"
    ], n), { angle: h } = H0(o, {
      x: t.x,
      y: t.y
    });
    To(h, u, c) && r.push({
      element: o,
      datasetIndex: s,
      index: l
    });
  }
  return tu(e, i, t, a), r;
}
function ww(e, t, i, n, r, a) {
  let o = [];
  const s = bw(i);
  let l = Number.POSITIVE_INFINITY;
  function u(c, h, d) {
    const f = c.inRange(t.x, t.y, r);
    if (n && !f)
      return;
    const v = c.getCenterPoint(r);
    if (!(!!a || e.isPointInArea(v)) && !f)
      return;
    const p = s(t, v);
    p < l ? (o = [
      {
        element: c,
        datasetIndex: h,
        index: d
      }
    ], l = p) : p === l && o.push({
      element: c,
      datasetIndex: h,
      index: d
    });
  }
  return tu(e, i, t, u), o;
}
function Lu(e, t, i, n, r, a) {
  return !a && !e.isPointInArea(t) ? [] : i === "r" && !n ? xw(e, t, i, r) : ww(e, t, i, n, r, a);
}
function _v(e, t, i, n, r) {
  const a = [], o = i === "x" ? "inXRange" : "inYRange";
  let s = !1;
  return tu(e, i, t, (l, u, c) => {
    l[o] && l[o](t[i], r) && (a.push({
      element: l,
      datasetIndex: u,
      index: c
    }), s = s || l.inRange(t.x, t.y, r));
  }), n && !s ? [] : a;
}
var Sw = {
  modes: {
    index(e, t, i, n) {
      const r = qn(t, e), a = i.axis || "x", o = i.includeInvisible || !1, s = i.intersect ? Au(e, r, a, n, o) : Lu(e, r, a, !1, n, o), l = [];
      return s.length ? (e.getSortedVisibleDatasetMetas().forEach((u) => {
        const c = s[0].index, h = u.data[c];
        h && !h.skip && l.push({
          element: h,
          datasetIndex: u.index,
          index: c
        });
      }), l) : [];
    },
    dataset(e, t, i, n) {
      const r = qn(t, e), a = i.axis || "xy", o = i.includeInvisible || !1;
      let s = i.intersect ? Au(e, r, a, n, o) : Lu(e, r, a, !1, n, o);
      if (s.length > 0) {
        const l = s[0].datasetIndex, u = e.getDatasetMeta(l).data;
        s = [];
        for (let c = 0; c < u.length; ++c)
          s.push({
            element: u[c],
            datasetIndex: l,
            index: c
          });
      }
      return s;
    },
    point(e, t, i, n) {
      const r = qn(t, e), a = i.axis || "xy", o = i.includeInvisible || !1;
      return Au(e, r, a, n, o);
    },
    nearest(e, t, i, n) {
      const r = qn(t, e), a = i.axis || "xy", o = i.includeInvisible || !1;
      return Lu(e, r, a, i.intersect, n, o);
    },
    x(e, t, i, n) {
      const r = qn(t, e);
      return _v(e, r, "x", i.intersect, n);
    },
    y(e, t, i, n) {
      const r = qn(t, e);
      return _v(e, r, "y", i.intersect, n);
    }
  }
};
const cy = [
  "left",
  "top",
  "right",
  "bottom"
];
function Sa(e, t) {
  return e.filter((i) => i.pos === t);
}
function bv(e, t) {
  return e.filter((i) => cy.indexOf(i.pos) === -1 && i.box.axis === t);
}
function Ca(e, t) {
  return e.sort((i, n) => {
    const r = t ? n : i, a = t ? i : n;
    return r.weight === a.weight ? r.index - a.index : r.weight - a.weight;
  });
}
function Cw(e) {
  const t = [];
  let i, n, r, a, o, s;
  for (i = 0, n = (e || []).length; i < n; ++i)
    r = e[i], { position: a, options: { stack: o, stackWeight: s = 1 } } = r, t.push({
      index: i,
      box: r,
      pos: a,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: o && a + o,
      stackWeight: s
    });
  return t;
}
function Tw(e) {
  const t = {};
  for (const i of e) {
    const { stack: n, pos: r, stackWeight: a } = i;
    if (!n || !cy.includes(r))
      continue;
    const o = t[n] || (t[n] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += a;
  }
  return t;
}
function Mw(e, t) {
  const i = Tw(e), { vBoxMaxWidth: n, hBoxMaxHeight: r } = t;
  let a, o, s;
  for (a = 0, o = e.length; a < o; ++a) {
    s = e[a];
    const { fullSize: l } = s.box, u = i[s.stack], c = u && s.stackWeight / u.weight;
    s.horizontal ? (s.width = c ? c * n : l && t.availableWidth, s.height = r) : (s.width = n, s.height = c ? c * r : l && t.availableHeight);
  }
  return i;
}
function kw(e) {
  const t = Cw(e), i = Ca(t.filter((u) => u.box.fullSize), !0), n = Ca(Sa(t, "left"), !0), r = Ca(Sa(t, "right")), a = Ca(Sa(t, "top"), !0), o = Ca(Sa(t, "bottom")), s = bv(t, "x"), l = bv(t, "y");
  return {
    fullSize: i,
    leftAndTop: n.concat(a),
    rightAndBottom: r.concat(l).concat(o).concat(s),
    chartArea: Sa(t, "chartArea"),
    vertical: n.concat(r).concat(l),
    horizontal: a.concat(o).concat(s)
  };
}
function xv(e, t, i, n) {
  return Math.max(e[i], t[i]) + Math.max(e[n], t[n]);
}
function hy(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function Dw(e, t, i, n) {
  const { pos: r, box: a } = i, o = e.maxPadding;
  if (!ut(r)) {
    i.size && (e[r] -= i.size);
    const h = n[i.stack] || {
      size: 0,
      count: 1
    };
    h.size = Math.max(h.size, i.horizontal ? a.height : a.width), i.size = h.size / h.count, e[r] += i.size;
  }
  a.getPadding && hy(o, a.getPadding());
  const s = Math.max(0, t.outerWidth - xv(o, e, "left", "right")), l = Math.max(0, t.outerHeight - xv(o, e, "top", "bottom")), u = s !== e.w, c = l !== e.h;
  return e.w = s, e.h = l, i.horizontal ? {
    same: u,
    other: c
  } : {
    same: c,
    other: u
  };
}
function Ew(e) {
  const t = e.maxPadding;
  function i(n) {
    const r = Math.max(t[n] - e[n], 0);
    return e[n] += r, r;
  }
  e.y += i("top"), e.x += i("left"), i("right"), i("bottom");
}
function Aw(e, t) {
  const i = t.maxPadding;
  function n(r) {
    const a = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((o) => {
      a[o] = Math.max(t[o], i[o]);
    }), a;
  }
  return n(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Za(e, t, i, n) {
  const r = [];
  let a, o, s, l, u, c;
  for (a = 0, o = e.length, u = 0; a < o; ++a) {
    s = e[a], l = s.box, l.update(s.width || t.w, s.height || t.h, Aw(s.horizontal, t));
    const { same: h, other: d } = Dw(t, i, s, n);
    u |= h && r.length, c = c || d, l.fullSize || r.push(s);
  }
  return u && Za(r, t, i, n) || c;
}
function es(e, t, i, n, r) {
  e.top = i, e.left = t, e.right = t + n, e.bottom = i + r, e.width = n, e.height = r;
}
function wv(e, t, i, n) {
  const r = i.padding;
  let { x: a, y: o } = t;
  for (const s of e) {
    const l = s.box, u = n[s.stack] || {
      placed: 0,
      weight: 1
    }, c = s.stackWeight / u.weight || 1;
    if (s.horizontal) {
      const h = t.w * c, d = u.size || l.height;
      So(u.start) && (o = u.start), l.fullSize ? es(l, r.left, o, i.outerWidth - r.right - r.left, d) : es(l, t.left + u.placed, o, h, d), u.start = o, u.placed += h, o = l.bottom;
    } else {
      const h = t.h * c, d = u.size || l.width;
      So(u.start) && (a = u.start), l.fullSize ? es(l, a, r.top, d, i.outerHeight - r.bottom - r.top) : es(l, a, t.top + u.placed, d, h), u.start = a, u.placed += h, a = l.right;
    }
  }
  t.x = a, t.y = o;
}
var Ze = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            t.draw(i);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const i = e.boxes ? e.boxes.indexOf(t) : -1;
    i !== -1 && e.boxes.splice(i, 1);
  },
  configure(e, t, i) {
    t.fullSize = i.fullSize, t.position = i.position, t.weight = i.weight;
  },
  update(e, t, i, n) {
    if (!e)
      return;
    const r = Je(e.options.layout.padding), a = Math.max(t - r.width, 0), o = Math.max(i - r.height, 0), s = kw(e.boxes), l = s.vertical, u = s.horizontal;
    _t(e.boxes, (m) => {
      typeof m.beforeLayout == "function" && m.beforeLayout();
    });
    const c = l.reduce((m, p) => p.box.options && p.box.options.display === !1 ? m : m + 1, 0) || 1, h = Object.freeze({
      outerWidth: t,
      outerHeight: i,
      padding: r,
      availableWidth: a,
      availableHeight: o,
      vBoxMaxWidth: a / 2 / c,
      hBoxMaxHeight: o / 2
    }), d = Object.assign({}, r);
    hy(d, Je(n));
    const f = Object.assign({
      maxPadding: d,
      w: a,
      h: o,
      x: r.left,
      y: r.top
    }, r), v = Mw(l.concat(u), h);
    Za(s.fullSize, f, h, v), Za(l, f, h, v), Za(u, f, h, v) && Za(l, f, h, v), Ew(f), wv(s.leftAndTop, f, h, v), f.x += f.w, f.y += f.h, wv(s.rightAndBottom, f, h, v), e.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, _t(s.chartArea, (m) => {
      const p = m.box;
      Object.assign(p, e.chartArea), p.update(f.w, f.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class dy {
  acquireContext(t, i) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, i, n) {
  }
  removeEventListener(t, i, n) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, i, n, r) {
    return i = Math.max(0, i || t.width), n = n || t.height, {
      width: i,
      height: Math.max(0, r ? Math.floor(i / r) : n)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class Lw extends dy {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const Ys = "$chartjs", Pw = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Sv = (e) => e === null || e === "";
function Iw(e, t) {
  const i = e.style, n = e.getAttribute("height"), r = e.getAttribute("width");
  if (e[Ys] = {
    initial: {
      height: n,
      width: r,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", Sv(r)) {
    const a = ov(e, "width");
    a !== void 0 && (e.width = a);
  }
  if (Sv(n))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const a = ov(e, "height");
      a !== void 0 && (e.height = a);
    }
  return e;
}
const fy = L2 ? {
  passive: !0
} : !1;
function Rw(e, t, i) {
  e && e.addEventListener(t, i, fy);
}
function Ow(e, t, i) {
  e && e.canvas && e.canvas.removeEventListener(t, i, fy);
}
function Bw(e, t) {
  const i = Pw[e.type] || e.type, { x: n, y: r } = qn(e, t);
  return {
    type: i,
    chart: t,
    native: e,
    x: n !== void 0 ? n : null,
    y: r !== void 0 ? r : null
  };
}
function cl(e, t) {
  for (const i of e)
    if (i === t || i.contains(t))
      return !0;
}
function Nw(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let o = !1;
    for (const s of a)
      o = o || cl(s.addedNodes, n), o = o && !cl(s.removedNodes, n);
    o && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function Fw(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let o = !1;
    for (const s of a)
      o = o || cl(s.removedNodes, n), o = o && !cl(s.addedNodes, n);
    o && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const Do = /* @__PURE__ */ new Map();
let Cv = 0;
function vy() {
  const e = window.devicePixelRatio;
  e !== Cv && (Cv = e, Do.forEach((t, i) => {
    i.currentDevicePixelRatio !== e && t();
  }));
}
function $w(e, t) {
  Do.size || window.addEventListener("resize", vy), Do.set(e, t);
}
function zw(e) {
  Do.delete(e), Do.size || window.removeEventListener("resize", vy);
}
function Vw(e, t, i) {
  const n = e.canvas, r = n && Td(n);
  if (!r)
    return;
  const a = G0((s, l) => {
    const u = r.clientWidth;
    i(s, l), u < r.clientWidth && i();
  }, window), o = new ResizeObserver((s) => {
    const l = s[0], u = l.contentRect.width, c = l.contentRect.height;
    u === 0 && c === 0 || a(u, c);
  });
  return o.observe(r), $w(e, a), o;
}
function Pu(e, t, i) {
  i && i.disconnect(), t === "resize" && zw(e);
}
function Hw(e, t, i) {
  const n = e.canvas, r = G0((a) => {
    e.ctx !== null && i(Bw(a, e));
  }, e);
  return Rw(n, t, r), r;
}
class Ww extends dy {
  acquireContext(t, i) {
    const n = t && t.getContext && t.getContext("2d");
    return n && n.canvas === t ? (Iw(t, i), n) : null;
  }
  releaseContext(t) {
    const i = t.canvas;
    if (!i[Ys])
      return !1;
    const n = i[Ys].initial;
    [
      "height",
      "width"
    ].forEach((a) => {
      const o = n[a];
      gt(o) ? i.removeAttribute(a) : i.setAttribute(a, o);
    });
    const r = n.style || {};
    return Object.keys(r).forEach((a) => {
      i.style[a] = r[a];
    }), i.width = i.width, delete i[Ys], !0;
  }
  addEventListener(t, i, n) {
    this.removeEventListener(t, i);
    const r = t.$proxies || (t.$proxies = {}), o = {
      attach: Nw,
      detach: Fw,
      resize: Vw
    }[i] || Hw;
    r[i] = o(t, i, n);
  }
  removeEventListener(t, i) {
    const n = t.$proxies || (t.$proxies = {}), r = n[i];
    if (!r)
      return;
    ({
      attach: Pu,
      detach: Pu,
      resize: Pu
    }[i] || Ow)(t, i, r), n[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, i, n, r) {
    return A2(t, i, n, r);
  }
  isAttached(t) {
    const i = t && Td(t);
    return !!(i && i.isConnected);
  }
}
function Yw(e) {
  return !Cd() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? Lw : Ww;
}
let ji = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  hasValue() {
    return Co(this.x) && Co(this.y);
  }
  getProps(t, i) {
    const n = this.$animations;
    if (!i || !n)
      return this;
    const r = {};
    return t.forEach((a) => {
      r[a] = n[a] && n[a].active() ? n[a]._to : this[a];
    }), r;
  }
};
function Uw(e, t) {
  const i = e.options.ticks, n = Gw(e), r = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? jw(t) : [], o = a.length, s = a[0], l = a[o - 1], u = [];
  if (o > r)
    return qw(t, u, a, o / r), u;
  const c = Xw(a, t, r);
  if (o > 0) {
    let h, d;
    const f = o > 1 ? Math.round((l - s) / (o - 1)) : null;
    for (is(t, u, c, gt(f) ? 0 : s - f, s), h = 0, d = o - 1; h < d; h++)
      is(t, u, c, a[h], a[h + 1]);
    return is(t, u, c, l, gt(f) ? t.length : l + f), u;
  }
  return is(t, u, c), u;
}
function Gw(e) {
  const t = e.options.offset, i = e._tickSize(), n = e._length / i + (t ? 0 : 1), r = e._maxLength / i;
  return Math.floor(Math.min(n, r));
}
function Xw(e, t, i) {
  const n = Zw(e), r = t.length / i;
  if (!n)
    return Math.max(r, 1);
  const a = Ex(n);
  for (let o = 0, s = a.length - 1; o < s; o++) {
    const l = a[o];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function jw(e) {
  const t = [];
  let i, n;
  for (i = 0, n = e.length; i < n; i++)
    e[i].major && t.push(i);
  return t;
}
function qw(e, t, i, n) {
  let r = 0, a = i[0], o;
  for (n = Math.ceil(n), o = 0; o < e.length; o++)
    o === a && (t.push(e[o]), r++, a = i[r * n]);
}
function is(e, t, i, n, r) {
  const a = at(n, 0), o = Math.min(at(r, e.length), e.length);
  let s = 0, l, u, c;
  for (i = Math.ceil(i), r && (l = r - n, i = l / Math.floor(l / i)), c = a; c < 0; )
    s++, c = Math.round(a + s * i);
  for (u = Math.max(a, 0); u < o; u++)
    u === c && (t.push(e[u]), s++, c = Math.round(a + s * i));
}
function Zw(e) {
  const t = e.length;
  let i, n;
  if (t < 2)
    return !1;
  for (n = e[0], i = 1; i < t; ++i)
    if (e[i] - e[i - 1] !== n)
      return !1;
  return n;
}
const Kw = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Tv = (e, t, i) => t === "top" || t === "left" ? e[t] + i : e[t] - i, Mv = (e, t) => Math.min(t || e, e);
function kv(e, t) {
  const i = [], n = e.length / t, r = e.length;
  let a = 0;
  for (; a < r; a += n)
    i.push(e[Math.floor(a)]);
  return i;
}
function Qw(e, t, i) {
  const n = e.ticks.length, r = Math.min(t, n - 1), a = e._startPixel, o = e._endPixel, s = 1e-6;
  let l = e.getPixelForTick(r), u;
  if (!(i && (n === 1 ? u = Math.max(l - a, o - l) : t === 0 ? u = (e.getPixelForTick(1) - l) / 2 : u = (l - e.getPixelForTick(r - 1)) / 2, l += r < t ? u : -u, l < a - s || l > o + s)))
    return l;
}
function Jw(e, t) {
  _t(e, (i) => {
    const n = i.gc, r = n.length / 2;
    let a;
    if (r > t) {
      for (a = 0; a < r; ++a)
        delete i.data[n[a]];
      n.splice(0, r);
    }
  });
}
function Ta(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function Dv(e, t) {
  if (!e.display)
    return 0;
  const i = ue(e.font, t), n = Je(e.padding);
  return (Ut(e.text) ? e.text.length : 1) * i.lineHeight + n.height;
}
function tS(e, t) {
  return xr(e, {
    scale: t,
    type: "scale"
  });
}
function eS(e, t, i) {
  return xr(e, {
    tick: i,
    index: t,
    type: "tick"
  });
}
function iS(e, t, i) {
  let n = md(e);
  return (i && t !== "right" || !i && t === "right") && (n = Kw(n)), n;
}
function nS(e, t, i, n) {
  const { top: r, left: a, bottom: o, right: s, chart: l } = e, { chartArea: u, scales: c } = l;
  let h = 0, d, f, v;
  const m = o - r, p = s - a;
  if (e.isHorizontal()) {
    if (f = oe(n, a, s), ut(i)) {
      const g = Object.keys(i)[0], y = i[g];
      v = c[g].getPixelForValue(y) + m - t;
    } else i === "center" ? v = (u.bottom + u.top) / 2 + m - t : v = Tv(e, i, t);
    d = s - a;
  } else {
    if (ut(i)) {
      const g = Object.keys(i)[0], y = i[g];
      f = c[g].getPixelForValue(y) - p + t;
    } else i === "center" ? f = (u.left + u.right) / 2 - p + t : f = Tv(e, i, t);
    v = oe(n, o, r), h = i === "left" ? -Kt : Kt;
  }
  return {
    titleX: f,
    titleY: v,
    maxWidth: d,
    rotation: h
  };
}
class ga extends ji {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, i) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: i, _suggestedMin: n, _suggestedMax: r } = this;
    return t = di(t, Number.POSITIVE_INFINITY), i = di(i, Number.NEGATIVE_INFINITY), n = di(n, Number.POSITIVE_INFINITY), r = di(r, Number.NEGATIVE_INFINITY), {
      min: di(t, n),
      max: di(i, r),
      minDefined: de(t),
      maxDefined: de(i)
    };
  }
  getMinMax(t) {
    let { min: i, max: n, minDefined: r, maxDefined: a } = this.getUserBounds(), o;
    if (r && a)
      return {
        min: i,
        max: n
      };
    const s = this.getMatchingVisibleMetas();
    for (let l = 0, u = s.length; l < u; ++l)
      o = s[l].controller.getMinMax(this, t), r || (i = Math.min(i, o.min)), a || (n = Math.max(n, o.max));
    return i = a && i > n ? n : i, n = r && i > n ? i : n, {
      min: di(i, di(n, i)),
      max: di(n, di(i, n))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    At(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, i, n) {
    const { beginAtZero: r, grace: a, ticks: o } = this.options, s = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = i, this._margins = n = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = l2(this, a, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = s < this.ticks.length;
    this._convertTicksToLabels(l ? kv(this.ticks, s) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = Uw(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, i, n;
    this.isHorizontal() ? (i = this.left, n = this.right) : (i = this.top, n = this.bottom, t = !t), this._startPixel = i, this._endPixel = n, this._reversePixels = t, this._length = n - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    At(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    At(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    At(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), At(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    At(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const i = this.options.ticks;
    let n, r, a;
    for (n = 0, r = t.length; n < r; n++)
      a = t[n], a.label = At(i.callback, [
        a.value,
        n,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    At(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    At(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, i = t.ticks, n = Mv(this.ticks.length, t.ticks.maxTicksLimit), r = i.minRotation || 0, a = i.maxRotation;
    let o = r, s, l, u;
    if (!this._isVisible() || !i.display || r >= a || n <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const c = this._getLabelSizes(), h = c.widest.width, d = c.highest.height, f = le(this.chart.width - h, 0, this.maxWidth);
    s = t.offset ? this.maxWidth / n : f / (n - 1), h + 6 > s && (s = f / (n - (t.offset ? 0.5 : 1)), l = this.maxHeight - Ta(t.grid) - i.padding - Dv(t.title, this.chart.options.font), u = Math.sqrt(h * h + d * d), o = Ix(Math.min(Math.asin(le((c.highest.height + 6) / s, -1, 1)), Math.asin(le(l / u, -1, 1)) - Math.asin(le(d / u, -1, 1)))), o = Math.max(r, Math.min(a, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    At(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    At(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: n, title: r, grid: a } } = this, o = this._isVisible(), s = this.isHorizontal();
    if (o) {
      const l = Dv(r, i.options.font);
      if (s ? (t.width = this.maxWidth, t.height = Ta(a) + l) : (t.height = this.maxHeight, t.width = Ta(a) + l), n.display && this.ticks.length) {
        const { first: u, last: c, widest: h, highest: d } = this._getLabelSizes(), f = n.padding * 2, v = $i(this.labelRotation), m = Math.cos(v), p = Math.sin(v);
        if (s) {
          const g = n.mirror ? 0 : p * h.width + m * d.height;
          t.height = Math.min(this.maxHeight, t.height + g + f);
        } else {
          const g = n.mirror ? 0 : m * h.width + p * d.height;
          t.width = Math.min(this.maxWidth, t.width + g + f);
        }
        this._calculatePadding(u, c, p, m);
      }
    }
    this._handleMargins(), s ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, i, n, r) {
    const { ticks: { align: a, padding: o }, position: s } = this.options, l = this.labelRotation !== 0, u = s !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);
      let d = 0, f = 0;
      l ? u ? (d = r * t.width, f = n * i.height) : (d = n * t.height, f = r * i.width) : a === "start" ? f = i.width : a === "end" ? d = t.width : a !== "inner" && (d = t.width / 2, f = i.width / 2), this.paddingLeft = Math.max((d - c + o) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - h + o) * this.width / (this.width - h), 0);
    } else {
      let c = i.height / 2, h = t.height / 2;
      a === "start" ? (c = 0, h = t.height) : a === "end" && (c = i.height, h = 0), this.paddingTop = c + o, this.paddingBottom = h + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    At(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: i } = this.options;
    return i === "top" || i === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let i, n;
    for (i = 0, n = t.length; i < n; i++)
      gt(t[i].label) && (t.splice(i, 1), n--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const i = this.options.ticks.sampleSize;
      let n = this.ticks;
      i < n.length && (n = kv(n, i)), this._labelSizes = t = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, i, n) {
    const { ctx: r, _longestTextCache: a } = this, o = [], s = [], l = Math.floor(i / Mv(i, n));
    let u = 0, c = 0, h, d, f, v, m, p, g, y, _, b, w;
    for (h = 0; h < i; h += l) {
      if (v = t[h].label, m = this._resolveTickFontOptions(h), r.font = p = m.string, g = a[p] = a[p] || {
        data: {},
        gc: []
      }, y = m.lineHeight, _ = b = 0, !gt(v) && !Ut(v))
        _ = ev(r, g.data, g.gc, _, v), b = y;
      else if (Ut(v))
        for (d = 0, f = v.length; d < f; ++d)
          w = v[d], !gt(w) && !Ut(w) && (_ = ev(r, g.data, g.gc, _, w), b += y);
      o.push(_), s.push(b), u = Math.max(_, u), c = Math.max(b, c);
    }
    Jw(a, i);
    const S = o.indexOf(u), C = s.indexOf(c), T = (k) => ({
      width: o[k] || 0,
      height: s[k] || 0
    });
    return {
      first: T(0),
      last: T(i - 1),
      widest: T(S),
      highest: T(C),
      widths: o,
      heights: s
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, i) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const i = this._startPixel + t * this._length;
    return Ox(this._alignToPixels ? Sn(this.chart, i, 0) : i);
  }
  getDecimalForPixel(t) {
    const i = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: i } = this;
    return t < 0 && i < 0 ? i : t > 0 && i > 0 ? t : 0;
  }
  getContext(t) {
    const i = this.ticks || [];
    if (t >= 0 && t < i.length) {
      const n = i[t];
      return n.$context || (n.$context = eS(this.getContext(), t, n));
    }
    return this.$context || (this.$context = tS(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, i = $i(this.labelRotation), n = Math.abs(Math.cos(i)), r = Math.abs(Math.sin(i)), a = this._getLabelSizes(), o = t.autoSkipPadding || 0, s = a ? a.widest.width + o : 0, l = a ? a.highest.height + o : 0;
    return this.isHorizontal() ? l * n > s * r ? s / n : l / r : l * r < s * n ? l / n : s / r;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const i = this.axis, n = this.chart, r = this.options, { grid: a, position: o, border: s } = r, l = a.offset, u = this.isHorizontal(), h = this.ticks.length + (l ? 1 : 0), d = Ta(a), f = [], v = s.setContext(this.getContext()), m = v.display ? v.width : 0, p = m / 2, g = function(F) {
      return Sn(n, F, m);
    };
    let y, _, b, w, S, C, T, k, M, D, L, P;
    if (o === "top")
      y = g(this.bottom), C = this.bottom - d, k = y - p, D = g(t.top) + p, P = t.bottom;
    else if (o === "bottom")
      y = g(this.top), D = t.top, P = g(t.bottom) - p, C = y + p, k = this.top + d;
    else if (o === "left")
      y = g(this.right), S = this.right - d, T = y - p, M = g(t.left) + p, L = t.right;
    else if (o === "right")
      y = g(this.left), M = t.left, L = g(t.right) - p, S = y + p, T = this.left + d;
    else if (i === "x") {
      if (o === "center")
        y = g((t.top + t.bottom) / 2 + 0.5);
      else if (ut(o)) {
        const F = Object.keys(o)[0], W = o[F];
        y = g(this.chart.scales[F].getPixelForValue(W));
      }
      D = t.top, P = t.bottom, C = y + p, k = C + d;
    } else if (i === "y") {
      if (o === "center")
        y = g((t.left + t.right) / 2);
      else if (ut(o)) {
        const F = Object.keys(o)[0], W = o[F];
        y = g(this.chart.scales[F].getPixelForValue(W));
      }
      S = y - p, T = S - d, M = t.left, L = t.right;
    }
    const R = at(r.ticks.maxTicksLimit, h), B = Math.max(1, Math.ceil(h / R));
    for (_ = 0; _ < h; _ += B) {
      const F = this.getContext(_), W = a.setContext(F), z = s.setContext(F), N = W.lineWidth, $ = W.color, X = z.dash || [], U = z.dashOffset, Q = W.tickWidth, it = W.tickColor, ft = W.tickBorderDash || [], yt = W.tickBorderDashOffset;
      b = Qw(this, _, l), b !== void 0 && (w = Sn(n, b, N), u ? S = T = M = L = w : C = k = D = P = w, f.push({
        tx1: S,
        ty1: C,
        tx2: T,
        ty2: k,
        x1: M,
        y1: D,
        x2: L,
        y2: P,
        width: N,
        color: $,
        borderDash: X,
        borderDashOffset: U,
        tickWidth: Q,
        tickColor: it,
        tickBorderDash: ft,
        tickBorderDashOffset: yt
      }));
    }
    return this._ticksLength = h, this._borderValue = y, f;
  }
  _computeLabelItems(t) {
    const i = this.axis, n = this.options, { position: r, ticks: a } = n, o = this.isHorizontal(), s = this.ticks, { align: l, crossAlign: u, padding: c, mirror: h } = a, d = Ta(n.grid), f = d + c, v = h ? -c : f, m = -$i(this.labelRotation), p = [];
    let g, y, _, b, w, S, C, T, k, M, D, L, P = "middle";
    if (r === "top")
      S = this.bottom - v, C = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      S = this.top + v, C = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const B = this._getYAxisLabelAlignment(d);
      C = B.textAlign, w = B.x;
    } else if (r === "right") {
      const B = this._getYAxisLabelAlignment(d);
      C = B.textAlign, w = B.x;
    } else if (i === "x") {
      if (r === "center")
        S = (t.top + t.bottom) / 2 + f;
      else if (ut(r)) {
        const B = Object.keys(r)[0], F = r[B];
        S = this.chart.scales[B].getPixelForValue(F) + f;
      }
      C = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (r === "center")
        w = (t.left + t.right) / 2 - f;
      else if (ut(r)) {
        const B = Object.keys(r)[0], F = r[B];
        w = this.chart.scales[B].getPixelForValue(F);
      }
      C = this._getYAxisLabelAlignment(d).textAlign;
    }
    i === "y" && (l === "start" ? P = "top" : l === "end" && (P = "bottom"));
    const R = this._getLabelSizes();
    for (g = 0, y = s.length; g < y; ++g) {
      _ = s[g], b = _.label;
      const B = a.setContext(this.getContext(g));
      T = this.getPixelForTick(g) + a.labelOffset, k = this._resolveTickFontOptions(g), M = k.lineHeight, D = Ut(b) ? b.length : 1;
      const F = D / 2, W = B.color, z = B.textStrokeColor, N = B.textStrokeWidth;
      let $ = C;
      o ? (w = T, C === "inner" && (g === y - 1 ? $ = this.options.reverse ? "left" : "right" : g === 0 ? $ = this.options.reverse ? "right" : "left" : $ = "center"), r === "top" ? u === "near" || m !== 0 ? L = -D * M + M / 2 : u === "center" ? L = -R.highest.height / 2 - F * M + M : L = -R.highest.height + M / 2 : u === "near" || m !== 0 ? L = M / 2 : u === "center" ? L = R.highest.height / 2 - F * M : L = R.highest.height - D * M, h && (L *= -1), m !== 0 && !B.showLabelBackdrop && (w += M / 2 * Math.sin(m))) : (S = T, L = (1 - D) * M / 2);
      let X;
      if (B.showLabelBackdrop) {
        const U = Je(B.backdropPadding), Q = R.heights[g], it = R.widths[g];
        let ft = L - U.top, yt = 0 - U.left;
        switch (P) {
          case "middle":
            ft -= Q / 2;
            break;
          case "bottom":
            ft -= Q;
            break;
        }
        switch (C) {
          case "center":
            yt -= it / 2;
            break;
          case "right":
            yt -= it;
            break;
          case "inner":
            g === y - 1 ? yt -= it : g > 0 && (yt -= it / 2);
            break;
        }
        X = {
          left: yt,
          top: ft,
          width: it + U.width,
          height: Q + U.height,
          color: B.backdropColor
        };
      }
      p.push({
        label: b,
        font: k,
        textOffset: L,
        options: {
          rotation: m,
          color: W,
          strokeColor: z,
          strokeWidth: N,
          textAlign: $,
          textBaseline: P,
          translation: [
            w,
            S
          ],
          backdrop: X
        }
      });
    }
    return p;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: i } = this.options;
    if (-$i(this.labelRotation))
      return t === "top" ? "left" : "right";
    let r = "center";
    return i.align === "start" ? r = "left" : i.align === "end" ? r = "right" : i.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(t) {
    const { position: i, ticks: { crossAlign: n, mirror: r, padding: a } } = this.options, o = this._getLabelSizes(), s = t + a, l = o.widest.width;
    let u, c;
    return i === "left" ? r ? (c = this.right + a, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - s, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : i === "right" ? r ? (c = this.left + a, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + s, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", {
      textAlign: u,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: i }, left: n, top: r, width: a, height: o } = this;
    i && (t.save(), t.fillStyle = i, t.fillRect(n, r, a, o), t.restore());
  }
  getLineWidthForValue(t) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const r = this.ticks.findIndex((a) => a.value === t);
    return r >= 0 ? i.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(t) {
    const i = this.options.grid, n = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let a, o;
    const s = (l, u, c) => {
      !c.width || !c.color || (n.save(), n.lineWidth = c.width, n.strokeStyle = c.color, n.setLineDash(c.borderDash || []), n.lineDashOffset = c.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(u.x, u.y), n.stroke(), n.restore());
    };
    if (i.display)
      for (a = 0, o = r.length; a < o; ++a) {
        const l = r[a];
        i.drawOnChartArea && s({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), i.drawTicks && s({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: i, options: { border: n, grid: r } } = this, a = n.setContext(this.getContext()), o = n.display ? a.width : 0;
    if (!o)
      return;
    const s = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let u, c, h, d;
    this.isHorizontal() ? (u = Sn(t, this.left, o) - o / 2, c = Sn(t, this.right, s) + s / 2, h = d = l) : (h = Sn(t, this.top, o) - o / 2, d = Sn(t, this.bottom, s) + s / 2, u = c = l), i.save(), i.lineWidth = a.width, i.strokeStyle = a.color, i.beginPath(), i.moveTo(u, h), i.lineTo(c, d), i.stroke(), i.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const n = this.ctx, r = this._computeLabelArea();
    r && Zl(n, r);
    const a = this.getLabelItems(t);
    for (const o of a) {
      const s = o.options, l = o.font, u = o.label, c = o.textOffset;
      ko(n, u, 0, c, l, s);
    }
    r && Kl(n);
  }
  drawTitle() {
    const { ctx: t, options: { position: i, title: n, reverse: r } } = this;
    if (!n.display)
      return;
    const a = ue(n.font), o = Je(n.padding), s = n.align;
    let l = a.lineHeight / 2;
    i === "bottom" || i === "center" || ut(i) ? (l += o.bottom, Ut(n.text) && (l += a.lineHeight * (n.text.length - 1))) : l += o.top;
    const { titleX: u, titleY: c, maxWidth: h, rotation: d } = nS(this, l, i, s);
    ko(t, n.text, 0, 0, a, {
      color: n.color,
      maxWidth: h,
      rotation: d,
      textAlign: iS(s, i, r),
      textBaseline: "middle",
      translation: [
        u,
        c
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, i = t.ticks && t.ticks.z || 0, n = at(t.grid && t.grid.z, -1), r = at(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== ga.prototype.draw ? [
      {
        z: i,
        draw: (a) => {
          this.draw(a);
        }
      }
    ] : [
      {
        z: n,
        draw: (a) => {
          this.drawBackground(), this.drawGrid(a), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (a) => {
          this.drawLabels(a);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const i = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", r = [];
    let a, o;
    for (a = 0, o = i.length; a < o; ++a) {
      const s = i[a];
      s[n] === this.id && (!t || s.type === t) && r.push(s);
    }
    return r;
  }
  _resolveTickFontOptions(t) {
    const i = this.options.ticks.setContext(this.getContext(t));
    return ue(i.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class ns {
  constructor(t, i, n) {
    this.type = t, this.scope = i, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const i = Object.getPrototypeOf(t);
    let n;
    oS(i) && (n = this.register(i));
    const r = this.items, a = t.id, o = this.scope + "." + a;
    if (!a)
      throw new Error("class does not have id: " + t);
    return a in r || (r[a] = t, rS(t, o, n), this.override && Wt.override(t.id, t.overrides)), o;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const i = this.items, n = t.id, r = this.scope;
    n in i && delete i[n], r && n in Wt[r] && (delete Wt[r][n], this.override && delete mr[n]);
  }
}
function rS(e, t, i) {
  const n = wo(/* @__PURE__ */ Object.create(null), [
    i ? Wt.get(i) : {},
    Wt.get(t),
    e.defaults
  ]);
  Wt.set(t, n), e.defaultRoutes && aS(t, e.defaultRoutes), e.descriptors && Wt.describe(t, e.descriptors);
}
function aS(e, t) {
  Object.keys(t).forEach((i) => {
    const n = i.split("."), r = n.pop(), a = [
      e
    ].concat(n).join("."), o = t[i].split("."), s = o.pop(), l = o.join(".");
    Wt.route(a, r, l, s);
  });
}
function oS(e) {
  return "id" in e && "defaults" in e;
}
class sS {
  constructor() {
    this.controllers = new ns(Jl, "datasets", !0), this.elements = new ns(ji, "elements"), this.plugins = new ns(Object, "plugins"), this.scales = new ns(ga, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, i, n) {
    [
      ...i
    ].forEach((r) => {
      const a = n || this._getRegistryForType(r);
      n || a.isForType(r) || a === this.plugins && r.id ? this._exec(t, a, r) : _t(r, (o) => {
        const s = n || this._getRegistryForType(o);
        this._exec(t, s, o);
      });
    });
  }
  _exec(t, i, n) {
    const r = pd(t);
    At(n["before" + r], [], n), i[t](n), At(n["after" + r], [], n);
  }
  _getRegistryForType(t) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const n = this._typedRegistries[i];
      if (n.isForType(t))
        return n;
    }
    return this.plugins;
  }
  _get(t, i, n) {
    const r = i.get(t);
    if (r === void 0)
      throw new Error('"' + t + '" is not a registered ' + n + ".");
    return r;
  }
}
var _i = /* @__PURE__ */ new sS();
class lS {
  constructor() {
    this._init = void 0;
  }
  notify(t, i, n, r) {
    if (i === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")), this._init === void 0)
      return;
    const a = r ? this._descriptors(t).filter(r) : this._descriptors(t), o = this._notify(a, t, i, n);
    return i === "afterDestroy" && (this._notify(a, t, "stop"), this._notify(this._init, t, "uninstall"), this._init = void 0), o;
  }
  _notify(t, i, n, r) {
    r = r || {};
    for (const a of t) {
      const o = a.plugin, s = o[n], l = [
        i,
        r,
        a.options
      ];
      if (At(s, l, o) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    gt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), i;
  }
  _createDescriptors(t, i) {
    const n = t && t.config, r = at(n.options && n.options.plugins, {}), a = uS(n);
    return r === !1 && !i ? [] : hS(t, a, r, i);
  }
  _notifyStateChanges(t) {
    const i = this._oldCache || [], n = this._cache, r = (a, o) => a.filter((s) => !o.some((l) => s.plugin.id === l.plugin.id));
    this._notify(r(i, n), t, "stop"), this._notify(r(n, i), t, "start");
  }
}
function uS(e) {
  const t = {}, i = [], n = Object.keys(_i.plugins.items);
  for (let a = 0; a < n.length; a++)
    i.push(_i.getPlugin(n[a]));
  const r = e.plugins || [];
  for (let a = 0; a < r.length; a++) {
    const o = r[a];
    i.indexOf(o) === -1 && (i.push(o), t[o.id] = !0);
  }
  return {
    plugins: i,
    localIds: t
  };
}
function cS(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function hS(e, { plugins: t, localIds: i }, n, r) {
  const a = [], o = e.getContext();
  for (const s of t) {
    const l = s.id, u = cS(n[l], r);
    u !== null && a.push({
      plugin: s,
      options: dS(e.config, {
        plugin: s,
        local: i[l]
      }, u, o)
    });
  }
  return a;
}
function dS(e, { plugin: t, local: i }, n, r) {
  const a = e.pluginScopeKeys(t), o = e.getOptionScopes(n, a);
  return i && t.defaults && o.push(t.defaults), e.createResolver(o, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function oh(e, t) {
  const i = Wt.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || i.indexAxis || "x";
}
function fS(e, t) {
  let i = e;
  return e === "_index_" ? i = t : e === "_value_" && (i = t === "x" ? "y" : "x"), i;
}
function vS(e, t) {
  return e === t ? "_index_" : "_value_";
}
function Ev(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function pS(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function sh(e, ...t) {
  if (Ev(e))
    return e;
  for (const i of t) {
    const n = i.axis || pS(i.position) || e.length > 1 && Ev(e[0].toLowerCase());
    if (n)
      return n;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function Av(e, t, i) {
  if (i[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function gS(e, t) {
  if (t.data && t.data.datasets) {
    const i = t.data.datasets.filter((n) => n.xAxisID === e || n.yAxisID === e);
    if (i.length)
      return Av(e, "x", i[0]) || Av(e, "y", i[0]);
  }
  return {};
}
function mS(e, t) {
  const i = mr[e.type] || {
    scales: {}
  }, n = t.scales || {}, r = oh(e.type, t), a = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach((o) => {
    const s = n[o];
    if (!ut(s))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (s._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const l = sh(o, s, gS(o, e), Wt.scales[s.type]), u = vS(l, r), c = i.scales || {};
    a[o] = so(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      s,
      c[l],
      c[u]
    ]);
  }), e.data.datasets.forEach((o) => {
    const s = o.type || e.type, l = o.indexAxis || oh(s, t), c = (mr[s] || {}).scales || {};
    Object.keys(c).forEach((h) => {
      const d = fS(h, l), f = o[d + "AxisID"] || d;
      a[f] = a[f] || /* @__PURE__ */ Object.create(null), so(a[f], [
        {
          axis: d
        },
        n[f],
        c[h]
      ]);
    });
  }), Object.keys(a).forEach((o) => {
    const s = a[o];
    so(s, [
      Wt.scales[s.type],
      Wt.scale
    ]);
  }), a;
}
function py(e) {
  const t = e.options || (e.options = {});
  t.plugins = at(t.plugins, {}), t.scales = mS(e, t);
}
function gy(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function yS(e) {
  return e = e || {}, e.data = gy(e.data), py(e), e;
}
const Lv = /* @__PURE__ */ new Map(), my = /* @__PURE__ */ new Set();
function rs(e, t) {
  let i = Lv.get(e);
  return i || (i = t(), Lv.set(e, i), my.add(i)), i;
}
const Ma = (e, t, i) => {
  const n = gr(t, i);
  n !== void 0 && e.add(n);
};
class _S {
  constructor(t) {
    this._config = yS(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = gy(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), py(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return rs(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, i) {
    return rs(`${t}.transition.${i}`, () => [
      [
        `datasets.${t}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, i) {
    return rs(`${t}-${i}`, () => [
      [
        `datasets.${t}.elements.${i}`,
        `datasets.${t}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const i = t.id, n = this.type;
    return rs(`${n}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, i) {
    const n = this._scopeCache;
    let r = n.get(t);
    return (!r || i) && (r = /* @__PURE__ */ new Map(), n.set(t, r)), r;
  }
  getOptionScopes(t, i, n) {
    const { options: r, type: a } = this, o = this._cachedScopes(t, n), s = o.get(i);
    if (s)
      return s;
    const l = /* @__PURE__ */ new Set();
    i.forEach((c) => {
      t && (l.add(t), c.forEach((h) => Ma(l, t, h))), c.forEach((h) => Ma(l, r, h)), c.forEach((h) => Ma(l, mr[a] || {}, h)), c.forEach((h) => Ma(l, Wt, h)), c.forEach((h) => Ma(l, rh, h));
    });
    const u = Array.from(l);
    return u.length === 0 && u.push(/* @__PURE__ */ Object.create(null)), my.has(i) && o.set(i, u), u;
  }
  chartOptionScopes() {
    const { options: t, type: i } = this;
    return [
      t,
      mr[i] || {},
      Wt.datasets[i] || {},
      {
        type: i
      },
      Wt,
      rh
    ];
  }
  resolveNamedOptions(t, i, n, r = [
    ""
  ]) {
    const a = {
      $shared: !0
    }, { resolver: o, subPrefixes: s } = Pv(this._resolverCache, t, r);
    let l = o;
    if (xS(o, i)) {
      a.$shared = !1, n = pn(n) ? n() : n;
      const u = this.createResolver(t, n, s);
      l = la(o, n, u);
    }
    for (const u of i)
      a[u] = l[u];
    return a;
  }
  createResolver(t, i, n = [
    ""
  ], r) {
    const { resolver: a } = Pv(this._resolverCache, t, n);
    return ut(i) ? la(a, i, void 0, r) : a;
  }
}
function Pv(e, t, i) {
  let n = e.get(t);
  n || (n = /* @__PURE__ */ new Map(), e.set(t, n));
  const r = i.join();
  let a = n.get(r);
  return a || (a = {
    resolver: xd(t, i),
    subPrefixes: i.filter((s) => !s.toLowerCase().includes("hover"))
  }, n.set(r, a)), a;
}
const bS = (e) => ut(e) && Object.getOwnPropertyNames(e).some((t) => pn(e[t]));
function xS(e, t) {
  const { isScriptable: i, isIndexable: n } = Z0(e);
  for (const r of t) {
    const a = i(r), o = n(r), s = (o || a) && e[r];
    if (a && (pn(s) || bS(s)) || o && Ut(s))
      return !0;
  }
  return !1;
}
var wS = "4.5.1";
const SS = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Iv(e, t) {
  return e === "top" || e === "bottom" || SS.indexOf(e) === -1 && t === "x";
}
function Rv(e, t) {
  return function(i, n) {
    return i[e] === n[e] ? i[t] - n[t] : i[e] - n[e];
  };
}
function Ov(e) {
  const t = e.chart, i = t.options.animation;
  t.notifyPlugins("afterRender"), At(i && i.onComplete, [
    e
  ], t);
}
function CS(e) {
  const t = e.chart, i = t.options.animation;
  At(i && i.onProgress, [
    e
  ], t);
}
function yy(e) {
  return Cd() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const Us = {}, Bv = (e) => {
  const t = yy(e);
  return Object.values(Us).filter((i) => i.canvas === t).pop();
};
function TS(e, t, i) {
  const n = Object.keys(e);
  for (const r of n) {
    const a = +r;
    if (a >= t) {
      const o = e[r];
      delete e[r], (i > 0 || a > t) && (e[a + i] = o);
    }
  }
}
function MS(e, t, i, n) {
  return !i || e.type === "mouseout" ? null : n ? t : e;
}
let ma = class {
  static defaults = Wt;
  static instances = Us;
  static overrides = mr;
  static registry = _i;
  static version = wS;
  static getChart = Bv;
  static register(...t) {
    _i.add(...t), Nv();
  }
  static unregister(...t) {
    _i.remove(...t), Nv();
  }
  constructor(t, i) {
    const n = this.config = new _S(i), r = yy(t), a = Bv(r);
    if (a)
      throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas with ID '" + a.canvas.id + "' can be reused.");
    const o = n.createResolver(n.chartOptionScopes(), this.getContext());
    this.platform = new (n.platform || Yw(r))(), this.platform.updateConfig(n);
    const s = this.platform.acquireContext(r, o.aspectRatio), l = s && s.canvas, u = l && l.height, c = l && l.width;
    if (this.id = _x(), this.ctx = s, this.canvas = l, this.width = c, this.height = u, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new lS(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = $x((h) => this.update(h), o.resizeDelay || 0), this._dataChanges = [], Us[this.id] = this, !s || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    Oi.listen(this, "complete", Ov), Oi.listen(this, "progress", CS), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: i }, width: n, height: r, _aspectRatio: a } = this;
    return gt(t) ? i && a ? a : r ? n / r : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return _i;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : av(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return iv(this.canvas, this.ctx), this;
  }
  stop() {
    return Oi.stop(this), this;
  }
  resize(t, i) {
    Oi.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: i
    } : this._resize(t, i);
  }
  _resize(t, i) {
    const n = this.options, r = this.canvas, a = n.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, t, i, a), s = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, av(this, s, !0) && (this.notifyPlugins("resize", {
      size: o
    }), At(n.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    _t(i, (n, r) => {
      n.id = r;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, i = t.scales, n = this.scales, r = Object.keys(n).reduce((o, s) => (o[s] = !1, o), {});
    let a = [];
    i && (a = a.concat(Object.keys(i).map((o) => {
      const s = i[o], l = sh(o, s), u = l === "r", c = l === "x";
      return {
        options: s,
        dposition: u ? "chartArea" : c ? "bottom" : "left",
        dtype: u ? "radialLinear" : c ? "category" : "linear"
      };
    }))), _t(a, (o) => {
      const s = o.options, l = s.id, u = sh(l, s), c = at(s.type, o.dtype);
      (s.position === void 0 || Iv(s.position, u) !== Iv(o.dposition)) && (s.position = o.dposition), r[l] = !0;
      let h = null;
      if (l in n && n[l].type === c)
        h = n[l];
      else {
        const d = _i.getScale(c);
        h = new d({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), n[h.id] = h;
      }
      h.init(s, t);
    }), _t(r, (o, s) => {
      o || delete n[s];
    }), _t(n, (o) => {
      Ze.configure(this, o, o.options), Ze.addBox(this, o);
    });
  }
  _updateMetasets() {
    const t = this._metasets, i = this.data.datasets.length, n = t.length;
    if (t.sort((r, a) => r.index - a.index), n > i) {
      for (let r = i; r < n; ++r)
        this._destroyDatasetMeta(r);
      t.splice(i, n - i);
    }
    this._sortedMetasets = t.slice(0).sort(Rv("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: i } } = this;
    t.length > i.length && delete this._stacks, t.forEach((n, r) => {
      i.filter((a) => a === n._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const t = [], i = this.data.datasets;
    let n, r;
    for (this._removeUnreferencedMetasets(), n = 0, r = i.length; n < r; n++) {
      const a = i[n];
      let o = this.getDatasetMeta(n);
      const s = a.type || this.config.type;
      if (o.type && o.type !== s && (this._destroyDatasetMeta(n), o = this.getDatasetMeta(n)), o.type = s, o.indexAxis = a.indexAxis || oh(s, this.options), o.order = a.order || 0, o.index = n, o.label = "" + a.label, o.visible = this.isDatasetVisible(n), o.controller)
        o.controller.updateIndex(n), o.controller.linkScales();
      else {
        const l = _i.getController(s), { datasetElementType: u, dataElementType: c } = Wt.datasets[s];
        Object.assign(l, {
          dataElementType: _i.getElement(c),
          datasetElementType: u && _i.getElement(u)
        }), o.controller = new l(this, n), t.push(o.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    _t(this.data.datasets, (t, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const i = this.config;
    i.update();
    const n = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !n.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const a = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let u = 0, c = this.data.datasets.length; u < c; u++) {
      const { controller: h } = this.getDatasetMeta(u), d = !r && a.indexOf(h) === -1;
      h.buildOrUpdateElements(d), o = Math.max(+h.getMaxOverflow(), o);
    }
    o = this._minPadding = n.layout.autoPadding ? o : 0, this._updateLayout(o), r || _t(a, (u) => {
      u.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(Rv("z", "_idx"));
    const { _active: s, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : s.length && this._updateHoverStyles(s, s, !0), this.render();
  }
  _updateScales() {
    _t(this.scales, (t) => {
      Ze.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, i = new Set(Object.keys(this._listeners)), n = new Set(t.events);
    (!Gf(i, n) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, i = this._getUniformDataChanges() || [];
    for (const { method: n, start: r, count: a } of i) {
      const o = n === "_removeElements" ? -a : a;
      TS(t, r, o);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, n = (a) => new Set(t.filter((o) => o[0] === a).map((o, s) => s + "," + o.splice(1).join(","))), r = n(0);
    for (let a = 1; a < i; a++)
      if (!Gf(r, n(a)))
        return;
    return Array.from(r).map((a) => a.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    Ze.update(this, this.width, this.height, t);
    const i = this.chartArea, n = i.width <= 0 || i.height <= 0;
    this._layers = [], _t(this.boxes, (r) => {
      n && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, a) => {
      r._idx = a;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this._updateDataset(i, pn(t) ? t({
          datasetIndex: i
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, i) {
    const n = this.getDatasetMeta(t), r = {
      meta: n,
      index: t,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (n.controller._update(i), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (Oi.has(this) ? this.attached && !Oi.running(this) && Oi.start(this) : (this.draw(), Ov({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: n, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(n, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (t = 0; t < i.length && i[t].z <= 0; ++t)
      i[t].draw(this.chartArea);
    for (this._drawDatasets(); t < i.length; ++t)
      i[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const i = this._sortedMetasets, n = [];
    let r, a;
    for (r = 0, a = i.length; r < a; ++r) {
      const o = i[r];
      (!t || o.visible) && n.push(o);
    }
    return n;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let i = t.length - 1; i >= 0; --i)
      this._drawDataset(t[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const i = this.ctx, n = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, r = oy(this, t);
    this.notifyPlugins("beforeDatasetDraw", n) !== !1 && (r && Zl(i, r), t.controller.draw(), r && Kl(i), n.cancelable = !1, this.notifyPlugins("afterDatasetDraw", n));
  }
  isPointInArea(t) {
    return Mo(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, i, n, r) {
    const a = Sw.modes[i];
    return typeof a == "function" ? a(this, t, n, r) : [];
  }
  getDatasetMeta(t) {
    const i = this.data.datasets[t], n = this._metasets;
    let r = n.filter((a) => a && a._dataset === i).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: t,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, n.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = xr(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const i = this.data.datasets[t];
    if (!i)
      return !1;
    const n = this.getDatasetMeta(t);
    return typeof n.hidden == "boolean" ? !n.hidden : !i.hidden;
  }
  setDatasetVisibility(t, i) {
    const n = this.getDatasetMeta(t);
    n.hidden = !i;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, i, n) {
    const r = n ? "show" : "hide", a = this.getDatasetMeta(t), o = a.controller._resolveAnimations(void 0, r);
    So(i) ? (a.data[i].hidden = !n, this.update()) : (this.setDatasetVisibility(t, n), o.update(a, {
      visible: n
    }), this.update((s) => s.datasetIndex === t ? r : void 0));
  }
  hide(t, i) {
    this._updateVisibility(t, i, !1);
  }
  show(t, i) {
    this._updateVisibility(t, i, !0);
  }
  _destroyDatasetMeta(t) {
    const i = this._metasets[t];
    i && i.controller && i.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, i;
    for (this.stop(), Oi.remove(this), t = 0, i = this.data.datasets.length; t < i; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: i } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), iv(t, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete Us[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, i = this.platform, n = (a, o) => {
      i.addEventListener(this, a, o), t[a] = o;
    }, r = (a, o, s) => {
      a.offsetX = o, a.offsetY = s, this._eventHandler(a);
    };
    _t(this.options.events, (a) => n(a, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, i = this.platform, n = (l, u) => {
      i.addEventListener(this, l, u), t[l] = u;
    }, r = (l, u) => {
      t[l] && (i.removeEventListener(this, l, u), delete t[l]);
    }, a = (l, u) => {
      this.canvas && this.resize(l, u);
    };
    let o;
    const s = () => {
      r("attach", s), this.attached = !0, this.resize(), n("resize", a), n("detach", o);
    };
    o = () => {
      this.attached = !1, r("resize", a), this._stop(), this._resize(0, 0), n("attach", s);
    }, i.isAttached(this.canvas) ? s() : o();
  }
  unbindEvents() {
    _t(this._listeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._listeners = {}, _t(this._responsiveListeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, i, n) {
    const r = n ? "set" : "remove";
    let a, o, s, l;
    for (i === "dataset" && (a = this.getDatasetMeta(t[0].datasetIndex), a.controller["_" + r + "DatasetHoverStyle"]()), s = 0, l = t.length; s < l; ++s) {
      o = t[s];
      const u = o && this.getDatasetMeta(o.datasetIndex).controller;
      u && u[r + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const i = this._active || [], n = t.map(({ datasetIndex: a, index: o }) => {
      const s = this.getDatasetMeta(a);
      if (!s)
        throw new Error("No dataset found at index " + a);
      return {
        datasetIndex: a,
        element: s.data[o],
        index: o
      };
    });
    !al(n, i) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, i));
  }
  notifyPlugins(t, i, n) {
    return this._plugins.notify(this, t, i, n);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((i) => i.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, i, n) {
    const r = this.options.hover, a = (l, u) => l.filter((c) => !u.some((h) => c.datasetIndex === h.datasetIndex && c.index === h.index)), o = a(i, t), s = n ? t : a(t, i);
    o.length && this.updateHoverStyle(o, r.mode, !1), s.length && r.mode && this.updateHoverStyle(s, r.mode, !0);
  }
  _eventHandler(t, i) {
    const n = {
      event: t,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, r = (o) => (o.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", n, r) === !1)
      return;
    const a = this._handleEvent(t, i, n.inChartArea);
    return n.cancelable = !1, this.notifyPlugins("afterEvent", n, r), (a || n.changed) && this.render(), this;
  }
  _handleEvent(t, i, n) {
    const { _active: r = [], options: a } = this, o = i, s = this._getActiveElements(t, r, n, o), l = Mx(t), u = MS(t, this._lastEvent, n, l);
    n && (this._lastEvent = null, At(a.onHover, [
      t,
      s,
      this
    ], this), l && At(a.onClick, [
      t,
      s,
      this
    ], this));
    const c = !al(s, r);
    return (c || i) && (this._active = s, this._updateHoverStyles(s, r, i)), this._lastEvent = u, c;
  }
  _getActiveElements(t, i, n, r) {
    if (t.type === "mouseout")
      return [];
    if (!n)
      return i;
    const a = this.options.hover;
    return this.getElementsAtEventForMode(t, a.mode, a, r);
  }
};
function Nv() {
  return _t(ma.instances, (e) => e._plugins.invalidate());
}
function kS(e, t, i) {
  const { startAngle: n, x: r, y: a, outerRadius: o, innerRadius: s, options: l } = t, { borderWidth: u, borderJoinStyle: c } = l, h = Math.min(u / o, Pe(n - i));
  if (e.beginPath(), e.arc(r, a, o - u / 2, n + h / 2, i - h / 2), s > 0) {
    const d = Math.min(u / s, Pe(n - i));
    e.arc(r, a, s + u / 2, i - d / 2, n + d / 2, !0);
  } else {
    const d = Math.min(u / 2, o * Pe(n - i));
    if (c === "round")
      e.arc(r, a, d, i - bt / 2, n + bt / 2, !0);
    else if (c === "bevel") {
      const f = 2 * d * d, v = -f * Math.cos(i + bt / 2) + r, m = -f * Math.sin(i + bt / 2) + a, p = f * Math.cos(n + bt / 2) + r, g = f * Math.sin(n + bt / 2) + a;
      e.lineTo(v, m), e.lineTo(p, g);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function DS(e, t, i) {
  const { startAngle: n, pixelMargin: r, x: a, y: o, outerRadius: s, innerRadius: l } = t;
  let u = r / s;
  e.beginPath(), e.arc(a, o, s, n - u, i + u), l > r ? (u = r / l, e.arc(a, o, l, i + u, n - u, !0)) : e.arc(a, o, r, i + Kt, n - Kt), e.closePath(), e.clip();
}
function ES(e) {
  return bd(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function AS(e, t, i, n) {
  const r = ES(e.options.borderRadius), a = (i - t) / 2, o = Math.min(a, n * t / 2), s = (l) => {
    const u = (i - Math.min(a, l)) * n / 2;
    return le(l, 0, Math.min(a, u));
  };
  return {
    outerStart: s(r.outerStart),
    outerEnd: s(r.outerEnd),
    innerStart: le(r.innerStart, 0, o),
    innerEnd: le(r.innerEnd, 0, o)
  };
}
function Dr(e, t, i, n) {
  return {
    x: i + e * Math.cos(t),
    y: n + e * Math.sin(t)
  };
}
function hl(e, t, i, n, r, a) {
  const { x: o, y: s, startAngle: l, pixelMargin: u, innerRadius: c } = t, h = Math.max(t.outerRadius + n + i - u, 0), d = c > 0 ? c + n + i + u : 0;
  let f = 0;
  const v = r - l;
  if (n) {
    const B = c > 0 ? c - n : 0, F = h > 0 ? h - n : 0, W = (B + F) / 2, z = W !== 0 ? v * W / (W + n) : v;
    f = (v - z) / 2;
  }
  const m = Math.max(1e-3, v * h - i / bt) / h, p = (v - m) / 2, g = l + p + f, y = r - p - f, { outerStart: _, outerEnd: b, innerStart: w, innerEnd: S } = AS(t, d, h, y - g), C = h - _, T = h - b, k = g + _ / C, M = y - b / T, D = d + w, L = d + S, P = g + w / D, R = y - S / L;
  if (e.beginPath(), a) {
    const B = (k + M) / 2;
    if (e.arc(o, s, h, k, B), e.arc(o, s, h, B, M), b > 0) {
      const N = Dr(T, M, o, s);
      e.arc(N.x, N.y, b, M, y + Kt);
    }
    const F = Dr(L, y, o, s);
    if (e.lineTo(F.x, F.y), S > 0) {
      const N = Dr(L, R, o, s);
      e.arc(N.x, N.y, S, y + Kt, R + Math.PI);
    }
    const W = (y - S / d + (g + w / d)) / 2;
    if (e.arc(o, s, d, y - S / d, W, !0), e.arc(o, s, d, W, g + w / d, !0), w > 0) {
      const N = Dr(D, P, o, s);
      e.arc(N.x, N.y, w, P + Math.PI, g - Kt);
    }
    const z = Dr(C, g, o, s);
    if (e.lineTo(z.x, z.y), _ > 0) {
      const N = Dr(C, k, o, s);
      e.arc(N.x, N.y, _, g - Kt, k);
    }
  } else {
    e.moveTo(o, s);
    const B = Math.cos(k) * h + o, F = Math.sin(k) * h + s;
    e.lineTo(B, F);
    const W = Math.cos(M) * h + o, z = Math.sin(M) * h + s;
    e.lineTo(W, z);
  }
  e.closePath();
}
function LS(e, t, i, n, r) {
  const { fullCircles: a, startAngle: o, circumference: s } = t;
  let l = t.endAngle;
  if (a) {
    hl(e, t, i, n, l, r);
    for (let u = 0; u < a; ++u)
      e.fill();
    isNaN(s) || (l = o + (s % Rt || Rt));
  }
  return hl(e, t, i, n, l, r), e.fill(), l;
}
function PS(e, t, i, n, r) {
  const { fullCircles: a, startAngle: o, circumference: s, options: l } = t, { borderWidth: u, borderJoinStyle: c, borderDash: h, borderDashOffset: d, borderRadius: f } = l, v = l.borderAlign === "inner";
  if (!u)
    return;
  e.setLineDash(h || []), e.lineDashOffset = d, v ? (e.lineWidth = u * 2, e.lineJoin = c || "round") : (e.lineWidth = u, e.lineJoin = c || "bevel");
  let m = t.endAngle;
  if (a) {
    hl(e, t, i, n, m, r);
    for (let p = 0; p < a; ++p)
      e.stroke();
    isNaN(s) || (m = o + (s % Rt || Rt));
  }
  v && DS(e, t, m), l.selfJoin && m - o >= bt && f === 0 && c !== "miter" && kS(e, t, m), a || (hl(e, t, i, n, m, r), e.stroke());
}
class IS extends ji {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.getProps([
      "x",
      "y"
    ], n), { angle: a, distance: o } = H0(r, {
      x: t,
      y: i
    }), { startAngle: s, endAngle: l, innerRadius: u, outerRadius: c, circumference: h } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], n), d = (this.options.spacing + this.options.borderWidth) / 2, f = at(h, l - s), v = To(a, s, l) && s !== l, m = f >= Rt || v, p = zi(o, u + d, c + d);
    return m && p;
  }
  getCenterPoint(t) {
    const { x: i, y: n, startAngle: r, endAngle: a, innerRadius: o, outerRadius: s } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: u } = this.options, c = (r + a) / 2, h = (o + s + u + l) / 2;
    return {
      x: i + Math.cos(c) * h,
      y: n + Math.sin(c) * h
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: i, circumference: n } = this, r = (i.offset || 0) / 4, a = (i.spacing || 0) / 2, o = i.circular;
    if (this.pixelMargin = i.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = n > Rt ? Math.floor(n / Rt) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const s = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(s) * r, Math.sin(s) * r);
    const l = 1 - Math.sin(Math.min(bt, n || 0)), u = r * l;
    t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor, LS(t, this, u, a, o), PS(t, this, u, a, o), t.restore();
  }
}
function _y(e, t, i = t) {
  e.lineCap = at(i.borderCapStyle, t.borderCapStyle), e.setLineDash(at(i.borderDash, t.borderDash)), e.lineDashOffset = at(i.borderDashOffset, t.borderDashOffset), e.lineJoin = at(i.borderJoinStyle, t.borderJoinStyle), e.lineWidth = at(i.borderWidth, t.borderWidth), e.strokeStyle = at(i.borderColor, t.borderColor);
}
function RS(e, t, i) {
  e.lineTo(i.x, i.y);
}
function OS(e) {
  return e.stepped ? Jx : e.tension || e.cubicInterpolationMode === "monotone" ? t2 : RS;
}
function by(e, t, i = {}) {
  const n = e.length, { start: r = 0, end: a = n - 1 } = i, { start: o, end: s } = t, l = Math.max(r, o), u = Math.min(a, s), c = r < o && a < o || r > s && a > s;
  return {
    count: n,
    start: l,
    loop: t.loop,
    ilen: u < l && !c ? n + u - l : u - l
  };
}
function BS(e, t, i, n) {
  const { points: r, options: a } = t, { count: o, start: s, loop: l, ilen: u } = by(r, i, n), c = OS(a);
  let { move: h = !0, reverse: d } = n || {}, f, v, m;
  for (f = 0; f <= u; ++f)
    v = r[(s + (d ? u - f : f)) % o], !v.skip && (h ? (e.moveTo(v.x, v.y), h = !1) : c(e, m, v, d, a.stepped), m = v);
  return l && (v = r[(s + (d ? u : 0)) % o], c(e, m, v, d, a.stepped)), !!l;
}
function NS(e, t, i, n) {
  const r = t.points, { count: a, start: o, ilen: s } = by(r, i, n), { move: l = !0, reverse: u } = n || {};
  let c = 0, h = 0, d, f, v, m, p, g;
  const y = (b) => (o + (u ? s - b : b)) % a, _ = () => {
    m !== p && (e.lineTo(c, p), e.lineTo(c, m), e.lineTo(c, g));
  };
  for (l && (f = r[y(0)], e.moveTo(f.x, f.y)), d = 0; d <= s; ++d) {
    if (f = r[y(d)], f.skip)
      continue;
    const b = f.x, w = f.y, S = b | 0;
    S === v ? (w < m ? m = w : w > p && (p = w), c = (h * c + b) / ++h) : (_(), e.lineTo(b, w), v = S, h = 0, m = p = w), g = w;
  }
  _();
}
function lh(e) {
  const t = e.options, i = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !i ? NS : BS;
}
function FS(e) {
  return e.stepped ? P2 : e.tension || e.cubicInterpolationMode === "monotone" ? I2 : Zn;
}
function $S(e, t, i, n) {
  let r = t._path;
  r || (r = t._path = new Path2D(), t.path(r, i, n) && r.closePath()), _y(e, t.options), e.stroke(r);
}
function zS(e, t, i, n) {
  const { segments: r, options: a } = t, o = lh(t);
  for (const s of r)
    _y(e, a, s.style), e.beginPath(), o(e, t, s, {
      start: i,
      end: i + n - 1
    }) && e.closePath(), e.stroke();
}
const VS = typeof Path2D == "function";
function HS(e, t, i, n) {
  VS && !t.options.segment ? $S(e, t, i, n) : zS(e, t, i, n);
}
class eu extends ji {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, i) {
    const n = this.options;
    if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
      const r = n.spanGaps ? this._loop : this._fullLoop;
      C2(this._points, n, t, r, i), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = $2(this, this.options.segment));
  }
  first() {
    const t = this.segments, i = this.points;
    return t.length && i[t[0].start];
  }
  last() {
    const t = this.segments, i = this.points, n = t.length;
    return n && i[t[n - 1].end];
  }
  interpolate(t, i) {
    const n = this.options, r = t[i], a = this.points, o = ay(this, {
      property: i,
      start: r,
      end: r
    });
    if (!o.length)
      return;
    const s = [], l = FS(n);
    let u, c;
    for (u = 0, c = o.length; u < c; ++u) {
      const { start: h, end: d } = o[u], f = a[h], v = a[d];
      if (f === v) {
        s.push(f);
        continue;
      }
      const m = Math.abs((r - f[i]) / (v[i] - f[i])), p = l(f, v, m, n.stepped);
      p[i] = t[i], s.push(p);
    }
    return s.length === 1 ? s[0] : s;
  }
  pathSegment(t, i, n) {
    return lh(this)(t, this, i, n);
  }
  path(t, i, n) {
    const r = this.segments, a = lh(this);
    let o = this._loop;
    i = i || 0, n = n || this.points.length - i;
    for (const s of r)
      o &= a(t, this, s, {
        start: i,
        end: i + n - 1
      });
    return !!o;
  }
  draw(t, i, n, r) {
    const a = this.options || {};
    (this.points || []).length && a.borderWidth && (t.save(), HS(t, this, n, r), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function Fv(e, t, i, n) {
  const r = e.options, { [i]: a } = e.getProps([
    i
  ], n);
  return Math.abs(t - a) < r.radius + r.hitRadius;
}
class WS extends ji {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.options, { x: a, y: o } = this.getProps([
      "x",
      "y"
    ], n);
    return Math.pow(t - a, 2) + Math.pow(i - o, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(t, i) {
    return Fv(this, t, "x", i);
  }
  inYRange(t, i) {
    return Fv(this, t, "y", i);
  }
  getCenterPoint(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  size(t) {
    t = t || this.options || {};
    let i = t.radius || 0;
    i = Math.max(i, i && t.hoverRadius || 0);
    const n = i && t.borderWidth || 0;
    return (i + n) * 2;
  }
  draw(t, i) {
    const n = this.options;
    this.skip || n.radius < 0.1 || !Mo(this, i, this.size(n) / 2) || (t.strokeStyle = n.borderColor, t.lineWidth = n.borderWidth, t.fillStyle = n.backgroundColor, ah(t, n, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function xy(e, t) {
  const { x: i, y: n, base: r, width: a, height: o } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let s, l, u, c, h;
  return e.horizontal ? (h = o / 2, s = Math.min(i, r), l = Math.max(i, r), u = n - h, c = n + h) : (h = a / 2, s = i - h, l = i + h, u = Math.min(n, r), c = Math.max(n, r)), {
    left: s,
    top: u,
    right: l,
    bottom: c
  };
}
function sn(e, t, i, n) {
  return e ? 0 : le(t, i, n);
}
function YS(e, t, i) {
  const n = e.options.borderWidth, r = e.borderSkipped, a = q0(n);
  return {
    t: sn(r.top, a.top, 0, i),
    r: sn(r.right, a.right, 0, t),
    b: sn(r.bottom, a.bottom, 0, i),
    l: sn(r.left, a.left, 0, t)
  };
}
function US(e, t, i) {
  const { enableBorderRadius: n } = e.getProps([
    "enableBorderRadius"
  ]), r = e.options.borderRadius, a = ea(r), o = Math.min(t, i), s = e.borderSkipped, l = n || ut(r);
  return {
    topLeft: sn(!l || s.top || s.left, a.topLeft, 0, o),
    topRight: sn(!l || s.top || s.right, a.topRight, 0, o),
    bottomLeft: sn(!l || s.bottom || s.left, a.bottomLeft, 0, o),
    bottomRight: sn(!l || s.bottom || s.right, a.bottomRight, 0, o)
  };
}
function GS(e) {
  const t = xy(e), i = t.right - t.left, n = t.bottom - t.top, r = YS(e, i / 2, n / 2), a = US(e, i / 2, n / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: i,
      h: n,
      radius: a
    },
    inner: {
      x: t.left + r.l,
      y: t.top + r.t,
      w: i - r.l - r.r,
      h: n - r.t - r.b,
      radius: {
        topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function Iu(e, t, i, n) {
  const r = t === null, a = i === null, s = e && !(r && a) && xy(e, n);
  return s && (r || zi(t, s.left, s.right)) && (a || zi(i, s.top, s.bottom));
}
function XS(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function jS(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function Ru(e, t, i = {}) {
  const n = e.x !== i.x ? -t : 0, r = e.y !== i.y ? -t : 0, a = (e.x + e.w !== i.x + i.w ? t : 0) - n, o = (e.y + e.h !== i.y + i.h ? t : 0) - r;
  return {
    x: e.x + n,
    y: e.y + r,
    w: e.w + a,
    h: e.h + o,
    radius: e.radius
  };
}
class qS extends ji {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: i, options: { borderColor: n, backgroundColor: r } } = this, { inner: a, outer: o } = GS(this), s = XS(o.radius) ? ll : jS;
    t.save(), (o.w !== a.w || o.h !== a.h) && (t.beginPath(), s(t, Ru(o, i, a)), t.clip(), s(t, Ru(a, -i, o)), t.fillStyle = n, t.fill("evenodd")), t.beginPath(), s(t, Ru(a, i)), t.fillStyle = r, t.fill(), t.restore();
  }
  inRange(t, i, n) {
    return Iu(this, t, i, n);
  }
  inXRange(t, i) {
    return Iu(this, t, null, i);
  }
  inYRange(t, i) {
    return Iu(this, null, t, i);
  }
  getCenterPoint(t) {
    const { x: i, y: n, base: r, horizontal: a } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: a ? (i + r) / 2 : i,
      y: a ? n : (n + r) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
function ZS(e, t, i) {
  const n = e.segments, r = e.points, a = t.points, o = [];
  for (const s of n) {
    let { start: l, end: u } = s;
    u = iu(l, u, r);
    const c = uh(i, r[l], r[u], s.loop);
    if (!t.segments) {
      o.push({
        source: s,
        target: c,
        start: r[l],
        end: r[u]
      });
      continue;
    }
    const h = ay(t, c);
    for (const d of h) {
      const f = uh(i, a[d.start], a[d.end], d.loop), v = ry(s, r, f);
      for (const m of v)
        o.push({
          source: m,
          target: d,
          start: {
            [i]: $v(c, f, "start", Math.max)
          },
          end: {
            [i]: $v(c, f, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function uh(e, t, i, n) {
  if (n)
    return;
  let r = t[e], a = i[e];
  return e === "angle" && (r = Pe(r), a = Pe(a)), {
    property: e,
    start: r,
    end: a
  };
}
function KS(e, t) {
  const { x: i = null, y: n = null } = e || {}, r = t.points, a = [];
  return t.segments.forEach(({ start: o, end: s }) => {
    s = iu(o, s, r);
    const l = r[o], u = r[s];
    n !== null ? (a.push({
      x: l.x,
      y: n
    }), a.push({
      x: u.x,
      y: n
    })) : i !== null && (a.push({
      x: i,
      y: l.y
    }), a.push({
      x: i,
      y: u.y
    }));
  }), a;
}
function iu(e, t, i) {
  for (; t > e; t--) {
    const n = i[t];
    if (!isNaN(n.x) && !isNaN(n.y))
      break;
  }
  return t;
}
function $v(e, t, i, n) {
  return e && t ? n(e[i], t[i]) : e ? e[i] : t ? t[i] : 0;
}
function wy(e, t) {
  let i = [], n = !1;
  return Ut(e) ? (n = !0, i = e) : i = KS(e, t), i.length ? new eu({
    points: i,
    options: {
      tension: 0
    },
    _loop: n,
    _fullLoop: n
  }) : null;
}
function zv(e) {
  return e && e.fill !== !1;
}
function QS(e, t, i) {
  let r = e[t].fill;
  const a = [
    t
  ];
  let o;
  if (!i)
    return r;
  for (; r !== !1 && a.indexOf(r) === -1; ) {
    if (!de(r))
      return r;
    if (o = e[r], !o)
      return !1;
    if (o.visible)
      return r;
    a.push(r), r = o.fill;
  }
  return !1;
}
function JS(e, t, i) {
  const n = nC(e);
  if (ut(n))
    return isNaN(n.value) ? !1 : n;
  let r = parseFloat(n);
  return de(r) && Math.floor(r) === r ? tC(n[0], t, r, i) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(n) >= 0 && n;
}
function tC(e, t, i, n) {
  return (e === "-" || e === "+") && (i = t + i), i === t || i < 0 || i >= n ? !1 : i;
}
function eC(e, t) {
  let i = null;
  return e === "start" ? i = t.bottom : e === "end" ? i = t.top : ut(e) ? i = t.getPixelForValue(e.value) : t.getBasePixel && (i = t.getBasePixel()), i;
}
function iC(e, t, i) {
  let n;
  return e === "start" ? n = i : e === "end" ? n = t.options.reverse ? t.min : t.max : ut(e) ? n = e.value : n = t.getBaseValue(), n;
}
function nC(e) {
  const t = e.options, i = t.fill;
  let n = at(i && i.target, i);
  return n === void 0 && (n = !!t.backgroundColor), n === !1 || n === null ? !1 : n === !0 ? "origin" : n;
}
function rC(e) {
  const { scale: t, index: i, line: n } = e, r = [], a = n.segments, o = n.points, s = aC(t, i);
  s.push(wy({
    x: null,
    y: t.bottom
  }, n));
  for (let l = 0; l < a.length; l++) {
    const u = a[l];
    for (let c = u.start; c <= u.end; c++)
      oC(r, o[c], s);
  }
  return new eu({
    points: r,
    options: {}
  });
}
function aC(e, t) {
  const i = [], n = e.getMatchingVisibleMetas("line");
  for (let r = 0; r < n.length; r++) {
    const a = n[r];
    if (a.index === t)
      break;
    a.hidden || i.unshift(a.dataset);
  }
  return i;
}
function oC(e, t, i) {
  const n = [];
  for (let r = 0; r < i.length; r++) {
    const a = i[r], { first: o, last: s, point: l } = sC(a, t, "x");
    if (!(!l || o && s)) {
      if (o)
        n.unshift(l);
      else if (e.push(l), !s)
        break;
    }
  }
  e.push(...n);
}
function sC(e, t, i) {
  const n = e.interpolate(t, i);
  if (!n)
    return {};
  const r = n[i], a = e.segments, o = e.points;
  let s = !1, l = !1;
  for (let u = 0; u < a.length; u++) {
    const c = a[u], h = o[c.start][i], d = o[c.end][i];
    if (zi(r, h, d)) {
      s = r === h, l = r === d;
      break;
    }
  }
  return {
    first: s,
    last: l,
    point: n
  };
}
class Sy {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, i, n) {
    const { x: r, y: a, radius: o } = this;
    return i = i || {
      start: 0,
      end: Rt
    }, t.arc(r, a, o, i.end, i.start, !0), !n.bounds;
  }
  interpolate(t) {
    const { x: i, y: n, radius: r } = this, a = t.angle;
    return {
      x: i + Math.cos(a) * r,
      y: n + Math.sin(a) * r,
      angle: a
    };
  }
}
function lC(e) {
  const { chart: t, fill: i, line: n } = e;
  if (de(i))
    return uC(t, i);
  if (i === "stack")
    return rC(e);
  if (i === "shape")
    return !0;
  const r = cC(e);
  return r instanceof Sy ? r : wy(r, n);
}
function uC(e, t) {
  const i = e.getDatasetMeta(t);
  return i && e.isDatasetVisible(t) ? i.dataset : null;
}
function cC(e) {
  return (e.scale || {}).getPointPositionForValue ? dC(e) : hC(e);
}
function hC(e) {
  const { scale: t = {}, fill: i } = e, n = eC(i, t);
  if (de(n)) {
    const r = t.isHorizontal();
    return {
      x: r ? n : null,
      y: r ? null : n
    };
  }
  return null;
}
function dC(e) {
  const { scale: t, fill: i } = e, n = t.options, r = t.getLabels().length, a = n.reverse ? t.max : t.min, o = iC(i, t, a), s = [];
  if (n.grid.circular) {
    const l = t.getPointPositionForValue(0, a);
    return new Sy({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(o)
    });
  }
  for (let l = 0; l < r; ++l)
    s.push(t.getPointPositionForValue(l, o));
  return s;
}
function Ou(e, t, i) {
  const n = lC(t), { chart: r, index: a, line: o, scale: s, axis: l } = t, u = o.options, c = u.fill, h = u.backgroundColor, { above: d = h, below: f = h } = c || {}, v = r.getDatasetMeta(a), m = oy(r, v);
  n && o.points.length && (Zl(e, i), fC(e, {
    line: o,
    target: n,
    above: d,
    below: f,
    area: i,
    scale: s,
    axis: l,
    clip: m
  }), Kl(e));
}
function fC(e, t) {
  const { line: i, target: n, above: r, below: a, area: o, scale: s, clip: l } = t, u = i._loop ? "angle" : t.axis;
  e.save();
  let c = a;
  a !== r && (u === "x" ? (Vv(e, n, o.top), Bu(e, {
    line: i,
    target: n,
    color: r,
    scale: s,
    property: u,
    clip: l
  }), e.restore(), e.save(), Vv(e, n, o.bottom)) : u === "y" && (Hv(e, n, o.left), Bu(e, {
    line: i,
    target: n,
    color: a,
    scale: s,
    property: u,
    clip: l
  }), e.restore(), e.save(), Hv(e, n, o.right), c = r)), Bu(e, {
    line: i,
    target: n,
    color: c,
    scale: s,
    property: u,
    clip: l
  }), e.restore();
}
function Vv(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, o = !1;
  e.beginPath();
  for (const s of n) {
    const { start: l, end: u } = s, c = r[l], h = r[iu(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(c.x, i), e.lineTo(c.x, c.y)), o = !!t.pathSegment(e, s, {
      move: o
    }), o ? e.closePath() : e.lineTo(h.x, i);
  }
  e.lineTo(t.first().x, i), e.closePath(), e.clip();
}
function Hv(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, o = !1;
  e.beginPath();
  for (const s of n) {
    const { start: l, end: u } = s, c = r[l], h = r[iu(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(i, c.y), e.lineTo(c.x, c.y)), o = !!t.pathSegment(e, s, {
      move: o
    }), o ? e.closePath() : e.lineTo(i, h.y);
  }
  e.lineTo(i, t.first().y), e.closePath(), e.clip();
}
function Bu(e, t) {
  const { line: i, target: n, property: r, color: a, scale: o, clip: s } = t, l = ZS(i, n, r);
  for (const { source: u, target: c, start: h, end: d } of l) {
    const { style: { backgroundColor: f = a } = {} } = u, v = n !== !0;
    e.save(), e.fillStyle = f, vC(e, o, s, v && uh(r, h, d)), e.beginPath();
    const m = !!i.pathSegment(e, u);
    let p;
    if (v) {
      m ? e.closePath() : Wv(e, n, d, r);
      const g = !!n.pathSegment(e, c, {
        move: m,
        reverse: !0
      });
      p = m && g, p || Wv(e, n, h, r);
    }
    e.closePath(), e.fill(p ? "evenodd" : "nonzero"), e.restore();
  }
}
function vC(e, t, i, n) {
  const r = t.chart.chartArea, { property: a, start: o, end: s } = n || {};
  if (a === "x" || a === "y") {
    let l, u, c, h;
    a === "x" ? (l = o, u = r.top, c = s, h = r.bottom) : (l = r.left, u = o, c = r.right, h = s), e.beginPath(), i && (l = Math.max(l, i.left), c = Math.min(c, i.right), u = Math.max(u, i.top), h = Math.min(h, i.bottom)), e.rect(l, u, c - l, h - u), e.clip();
  }
}
function Wv(e, t, i, n) {
  const r = t.interpolate(i, n);
  r && e.lineTo(r.x, r.y);
}
var pC = {
  id: "filler",
  afterDatasetsUpdate(e, t, i) {
    const n = (e.data.datasets || []).length, r = [];
    let a, o, s, l;
    for (o = 0; o < n; ++o)
      a = e.getDatasetMeta(o), s = a.dataset, l = null, s && s.options && s instanceof eu && (l = {
        visible: e.isDatasetVisible(o),
        index: o,
        fill: JS(s, o, n),
        chart: e,
        axis: a.controller.options.indexAxis,
        scale: a.vScale,
        line: s
      }), a.$filler = l, r.push(l);
    for (o = 0; o < n; ++o)
      l = r[o], !(!l || l.fill === !1) && (l.fill = QS(r, o, i.propagate));
  },
  beforeDraw(e, t, i) {
    const n = i.drawTime === "beforeDraw", r = e.getSortedVisibleDatasetMetas(), a = e.chartArea;
    for (let o = r.length - 1; o >= 0; --o) {
      const s = r[o].$filler;
      s && (s.line.updateControlPoints(a, s.axis), n && s.fill && Ou(e.ctx, s, a));
    }
  },
  beforeDatasetsDraw(e, t, i) {
    if (i.drawTime !== "beforeDatasetsDraw")
      return;
    const n = e.getSortedVisibleDatasetMetas();
    for (let r = n.length - 1; r >= 0; --r) {
      const a = n[r].$filler;
      zv(a) && Ou(e.ctx, a, e.chartArea);
    }
  },
  beforeDatasetDraw(e, t, i) {
    const n = t.meta.$filler;
    !zv(n) || i.drawTime !== "beforeDatasetDraw" || Ou(e.ctx, n, e.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Yv = (e, t) => {
  let { boxHeight: i = t, boxWidth: n = t } = e;
  return e.usePointStyle && (i = Math.min(i, t), n = e.pointStyleWidth || Math.min(n, t)), {
    boxWidth: n,
    boxHeight: i,
    itemHeight: Math.max(t, i)
  };
}, gC = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class Uv extends ji {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i, n) {
    this.maxWidth = t, this.maxHeight = i, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let i = At(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (i = i.filter((n) => t.filter(n, this.chart.data))), t.sort && (i = i.sort((n, r) => t.sort(n, r, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: t, ctx: i } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const n = t.labels, r = ue(n.font), a = r.size, o = this._computeTitleHeight(), { boxWidth: s, itemHeight: l } = Yv(n, a);
    let u, c;
    i.font = r.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(o, a, s, l) + 10) : (c = this.maxHeight, u = this._fitCols(o, r, s, l) + 10), this.width = Math.min(u, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, i, n, r) {
    const { ctx: a, maxWidth: o, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [
      0
    ], c = r + s;
    let h = t;
    a.textAlign = "left", a.textBaseline = "middle";
    let d = -1, f = -c;
    return this.legendItems.forEach((v, m) => {
      const p = n + i / 2 + a.measureText(v.text).width;
      (m === 0 || u[u.length - 1] + p + 2 * s > o) && (h += c, u[u.length - (m > 0 ? 0 : 1)] = 0, f += c, d++), l[m] = {
        left: 0,
        top: f,
        row: d,
        width: p,
        height: r
      }, u[u.length - 1] += p + s;
    }), h;
  }
  _fitCols(t, i, n, r) {
    const { ctx: a, maxHeight: o, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = o - t;
    let h = s, d = 0, f = 0, v = 0, m = 0;
    return this.legendItems.forEach((p, g) => {
      const { itemWidth: y, itemHeight: _ } = mC(n, i, a, p, r);
      g > 0 && f + _ + 2 * s > c && (h += d + s, u.push({
        width: d,
        height: f
      }), v += d + s, m++, d = f = 0), l[g] = {
        left: v,
        top: f,
        col: m,
        width: y,
        height: _
      }, d = Math.max(d, y), f += _ + s;
    }), h += d, u.push({
      width: d,
      height: f
    }), h;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: n, labels: { padding: r }, rtl: a } } = this, o = ia(a, this.left, this.width);
    if (this.isHorizontal()) {
      let s = 0, l = oe(n, this.left + r, this.right - this.lineWidths[s]);
      for (const u of i)
        s !== u.row && (s = u.row, l = oe(n, this.left + r, this.right - this.lineWidths[s])), u.top += this.top + t + r, u.left = o.leftForLtr(o.x(l), u.width), l += u.width + r;
    } else {
      let s = 0, l = oe(n, this.top + t + r, this.bottom - this.columnSizes[s].height);
      for (const u of i)
        u.col !== s && (s = u.col, l = oe(n, this.top + t + r, this.bottom - this.columnSizes[s].height)), u.top = l, u.left += this.left + r, u.left = o.leftForLtr(o.x(u.left), u.width), l += u.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      Zl(t, this), this._draw(), Kl(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: i, lineWidths: n, ctx: r } = this, { align: a, labels: o } = t, s = Wt.color, l = ia(t.rtl, this.left, this.width), u = ue(o.font), { padding: c } = o, h = u.size, d = h / 2;
    let f;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = u.string;
    const { boxWidth: v, boxHeight: m, itemHeight: p } = Yv(o, h), g = function(S, C, T) {
      if (isNaN(v) || v <= 0 || isNaN(m) || m < 0)
        return;
      r.save();
      const k = at(T.lineWidth, 1);
      if (r.fillStyle = at(T.fillStyle, s), r.lineCap = at(T.lineCap, "butt"), r.lineDashOffset = at(T.lineDashOffset, 0), r.lineJoin = at(T.lineJoin, "miter"), r.lineWidth = k, r.strokeStyle = at(T.strokeStyle, s), r.setLineDash(at(T.lineDash, [])), o.usePointStyle) {
        const M = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: T.pointStyle,
          rotation: T.rotation,
          borderWidth: k
        }, D = l.xPlus(S, v / 2), L = C + d;
        j0(r, M, D, L, o.pointStyleWidth && v);
      } else {
        const M = C + Math.max((h - m) / 2, 0), D = l.leftForLtr(S, v), L = ea(T.borderRadius);
        r.beginPath(), Object.values(L).some((P) => P !== 0) ? ll(r, {
          x: D,
          y: M,
          w: v,
          h: m,
          radius: L
        }) : r.rect(D, M, v, m), r.fill(), k !== 0 && r.stroke();
      }
      r.restore();
    }, y = function(S, C, T) {
      ko(r, T.text, S, C + p / 2, u, {
        strikethrough: T.hidden,
        textAlign: l.textAlign(T.textAlign)
      });
    }, _ = this.isHorizontal(), b = this._computeTitleHeight();
    _ ? f = {
      x: oe(a, this.left + c, this.right - n[0]),
      y: this.top + c + b,
      line: 0
    } : f = {
      x: this.left + c,
      y: oe(a, this.top + b + c, this.bottom - i[0].height),
      line: 0
    }, ey(this.ctx, t.textDirection);
    const w = p + c;
    this.legendItems.forEach((S, C) => {
      r.strokeStyle = S.fontColor, r.fillStyle = S.fontColor;
      const T = r.measureText(S.text).width, k = l.textAlign(S.textAlign || (S.textAlign = o.textAlign)), M = v + d + T;
      let D = f.x, L = f.y;
      l.setWidth(this.width), _ ? C > 0 && D + M + c > this.right && (L = f.y += w, f.line++, D = f.x = oe(a, this.left + c, this.right - n[f.line])) : C > 0 && L + w > this.bottom && (D = f.x = D + i[f.line].width + c, f.line++, L = f.y = oe(a, this.top + b + c, this.bottom - i[f.line].height));
      const P = l.x(D);
      if (g(P, L, S), D = zx(k, D + v + d, _ ? D + M : this.right, t.rtl), y(l.x(D), L, S), _)
        f.x += M + c;
      else if (typeof S.text != "string") {
        const R = u.lineHeight;
        f.y += Cy(S, R) + c;
      } else
        f.y += w;
    }), iy(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, i = t.title, n = ue(i.font), r = Je(i.padding);
    if (!i.display)
      return;
    const a = ia(t.rtl, this.left, this.width), o = this.ctx, s = i.position, l = n.size / 2, u = r.top + l;
    let c, h = this.left, d = this.width;
    if (this.isHorizontal())
      d = Math.max(...this.lineWidths), c = this.top + u, h = oe(t.align, h, this.right - d);
    else {
      const v = this.columnSizes.reduce((m, p) => Math.max(m, p.height), 0);
      c = u + oe(t.align, this.top, this.bottom - v - t.labels.padding - this._computeTitleHeight());
    }
    const f = oe(s, h, h + d);
    o.textAlign = a.textAlign(md(s)), o.textBaseline = "middle", o.strokeStyle = i.color, o.fillStyle = i.color, o.font = n.string, ko(o, i.text, f, c, n);
  }
  _computeTitleHeight() {
    const t = this.options.title, i = ue(t.font), n = Je(t.padding);
    return t.display ? i.lineHeight + n.height : 0;
  }
  _getLegendItemAt(t, i) {
    let n, r, a;
    if (zi(t, this.left, this.right) && zi(i, this.top, this.bottom)) {
      for (a = this.legendHitBoxes, n = 0; n < a.length; ++n)
        if (r = a[n], zi(t, r.left, r.left + r.width) && zi(i, r.top, r.top + r.height))
          return this.legendItems[n];
    }
    return null;
  }
  handleEvent(t) {
    const i = this.options;
    if (!bC(t.type, i))
      return;
    const n = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const r = this._hoveredItem, a = gC(r, n);
      r && !a && At(i.onLeave, [
        t,
        r,
        this
      ], this), this._hoveredItem = n, n && !a && At(i.onHover, [
        t,
        n,
        this
      ], this);
    } else n && At(i.onClick, [
      t,
      n,
      this
    ], this);
  }
}
function mC(e, t, i, n, r) {
  const a = yC(n, e, t, i), o = _C(r, n, t.lineHeight);
  return {
    itemWidth: a,
    itemHeight: o
  };
}
function yC(e, t, i, n) {
  let r = e.text;
  return r && typeof r != "string" && (r = r.reduce((a, o) => a.length > o.length ? a : o)), t + i.size / 2 + n.measureText(r).width;
}
function _C(e, t, i) {
  let n = e;
  return typeof t.text != "string" && (n = Cy(t, i)), n;
}
function Cy(e, t) {
  const i = e.text ? e.text.length : 0;
  return t * i;
}
function bC(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var kd = {
  id: "legend",
  _element: Uv,
  start(e, t, i) {
    const n = e.legend = new Uv({
      ctx: e.ctx,
      options: i,
      chart: e
    });
    Ze.configure(e, n, i), Ze.addBox(e, n);
  },
  stop(e) {
    Ze.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, i) {
    const n = e.legend;
    Ze.configure(e, n, i), n.options = i;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, i) {
      const n = t.datasetIndex, r = i.chart;
      r.isDatasetVisible(n) ? (r.hide(n), t.hidden = !0) : (r.show(n), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: i, pointStyle: n, textAlign: r, color: a, useBorderRadius: o, borderRadius: s } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const u = l.controller.getStyle(i ? 0 : void 0), c = Je(u.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: u.backgroundColor,
            fontColor: a,
            hidden: !l.visible,
            lineCap: u.borderCapStyle,
            lineDash: u.borderDash,
            lineDashOffset: u.borderDashOffset,
            lineJoin: u.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: u.borderColor,
            pointStyle: n || u.pointStyle,
            rotation: u.rotation,
            textAlign: r || u.textAlign,
            borderRadius: o && (s || u.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class Ty extends ji {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i) {
    const n = this.options;
    if (this.left = 0, this.top = 0, !n.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = i;
    const r = Ut(n.text) ? n.text.length : 1;
    this._padding = Je(n.padding);
    const a = r * ue(n.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = a : this.width = a;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: i, left: n, bottom: r, right: a, options: o } = this, s = o.align;
    let l = 0, u, c, h;
    return this.isHorizontal() ? (c = oe(s, n, a), h = i + t, u = a - n) : (o.position === "left" ? (c = n + t, h = oe(s, r, i), l = bt * -0.5) : (c = a - t, h = oe(s, i, r), l = bt * 0.5), u = r - i), {
      titleX: c,
      titleY: h,
      maxWidth: u,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, i = this.options;
    if (!i.display)
      return;
    const n = ue(i.font), a = n.lineHeight / 2 + this._padding.top, { titleX: o, titleY: s, maxWidth: l, rotation: u } = this._drawArgs(a);
    ko(t, i.text, 0, 0, n, {
      color: i.color,
      maxWidth: l,
      rotation: u,
      textAlign: md(i.align),
      textBaseline: "middle",
      translation: [
        o,
        s
      ]
    });
  }
}
function xC(e, t) {
  const i = new Ty({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  Ze.configure(e, i, t), Ze.addBox(e, i), e.titleBlock = i;
}
var My = {
  id: "title",
  _element: Ty,
  start(e, t, i) {
    xC(e, i);
  },
  stop(e) {
    const t = e.titleBlock;
    Ze.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, i) {
    const n = e.titleBlock;
    Ze.configure(e, n, i), n.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Ka = {
  average(e) {
    if (!e.length)
      return !1;
    let t, i, n = /* @__PURE__ */ new Set(), r = 0, a = 0;
    for (t = 0, i = e.length; t < i; ++t) {
      const s = e[t].element;
      if (s && s.hasValue()) {
        const l = s.tooltipPosition();
        n.add(l.x), r += l.y, ++a;
      }
    }
    return a === 0 || n.size === 0 ? !1 : {
      x: [
        ...n
      ].reduce((s, l) => s + l) / n.size,
      y: r / a
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let i = t.x, n = t.y, r = Number.POSITIVE_INFINITY, a, o, s;
    for (a = 0, o = e.length; a < o; ++a) {
      const l = e[a].element;
      if (l && l.hasValue()) {
        const u = l.getCenterPoint(), c = nh(t, u);
        c < r && (r = c, s = l);
      }
    }
    if (s) {
      const l = s.tooltipPosition();
      i = l.x, n = l.y;
    }
    return {
      x: i,
      y: n
    };
  }
};
function yi(e, t) {
  return t && (Ut(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function Bi(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function wC(e, t) {
  const { element: i, datasetIndex: n, index: r } = t, a = e.getDatasetMeta(n).controller, { label: o, value: s } = a.getLabelAndValue(r);
  return {
    chart: e,
    label: o,
    parsed: a.getParsed(r),
    raw: e.data.datasets[n].data[r],
    formattedValue: s,
    dataset: a.getDataset(),
    dataIndex: r,
    datasetIndex: n,
    element: i
  };
}
function Gv(e, t) {
  const i = e.chart.ctx, { body: n, footer: r, title: a } = e, { boxWidth: o, boxHeight: s } = t, l = ue(t.bodyFont), u = ue(t.titleFont), c = ue(t.footerFont), h = a.length, d = r.length, f = n.length, v = Je(t.padding);
  let m = v.height, p = 0, g = n.reduce((b, w) => b + w.before.length + w.lines.length + w.after.length, 0);
  if (g += e.beforeBody.length + e.afterBody.length, h && (m += h * u.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom), g) {
    const b = t.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight;
    m += f * b + (g - f) * l.lineHeight + (g - 1) * t.bodySpacing;
  }
  d && (m += t.footerMarginTop + d * c.lineHeight + (d - 1) * t.footerSpacing);
  let y = 0;
  const _ = function(b) {
    p = Math.max(p, i.measureText(b).width + y);
  };
  return i.save(), i.font = u.string, _t(e.title, _), i.font = l.string, _t(e.beforeBody.concat(e.afterBody), _), y = t.displayColors ? o + 2 + t.boxPadding : 0, _t(n, (b) => {
    _t(b.before, _), _t(b.lines, _), _t(b.after, _);
  }), y = 0, i.font = c.string, _t(e.footer, _), i.restore(), p += v.width, {
    width: p,
    height: m
  };
}
function SC(e, t) {
  const { y: i, height: n } = t;
  return i < n / 2 ? "top" : i > e.height - n / 2 ? "bottom" : "center";
}
function CC(e, t, i, n) {
  const { x: r, width: a } = n, o = i.caretSize + i.caretPadding;
  if (e === "left" && r + a + o > t.width || e === "right" && r - a - o < 0)
    return !0;
}
function TC(e, t, i, n) {
  const { x: r, width: a } = i, { width: o, chartArea: { left: s, right: l } } = e;
  let u = "center";
  return n === "center" ? u = r <= (s + l) / 2 ? "left" : "right" : r <= a / 2 ? u = "left" : r >= o - a / 2 && (u = "right"), CC(u, e, t, i) && (u = "center"), u;
}
function Xv(e, t, i) {
  const n = i.yAlign || t.yAlign || SC(e, i);
  return {
    xAlign: i.xAlign || t.xAlign || TC(e, t, i, n),
    yAlign: n
  };
}
function MC(e, t) {
  let { x: i, width: n } = e;
  return t === "right" ? i -= n : t === "center" && (i -= n / 2), i;
}
function kC(e, t, i) {
  let { y: n, height: r } = e;
  return t === "top" ? n += i : t === "bottom" ? n -= r + i : n -= r / 2, n;
}
function jv(e, t, i, n) {
  const { caretSize: r, caretPadding: a, cornerRadius: o } = e, { xAlign: s, yAlign: l } = i, u = r + a, { topLeft: c, topRight: h, bottomLeft: d, bottomRight: f } = ea(o);
  let v = MC(t, s);
  const m = kC(t, l, u);
  return l === "center" ? s === "left" ? v += u : s === "right" && (v -= u) : s === "left" ? v -= Math.max(c, d) + r : s === "right" && (v += Math.max(h, f) + r), {
    x: le(v, 0, n.width - t.width),
    y: le(m, 0, n.height - t.height)
  };
}
function as(e, t, i) {
  const n = Je(i.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - n.right : e.x + n.left;
}
function qv(e) {
  return yi([], Bi(e));
}
function DC(e, t, i) {
  return xr(e, {
    tooltip: t,
    tooltipItems: i,
    type: "tooltip"
  });
}
function Zv(e, t) {
  const i = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return i ? e.override(i) : e;
}
const ky = {
  beforeTitle: Ai,
  title(e) {
    if (e.length > 0) {
      const t = e[0], i = t.chart.data.labels, n = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (n > 0 && t.dataIndex < n)
        return i[t.dataIndex];
    }
    return "";
  },
  afterTitle: Ai,
  beforeBody: Ai,
  beforeLabel: Ai,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const i = e.formattedValue;
    return gt(i) || (t += i), t;
  },
  labelColor(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: Ai,
  afterBody: Ai,
  beforeFooter: Ai,
  footer: Ai,
  afterFooter: Ai
};
function xe(e, t, i, n) {
  const r = e[t].call(i, n);
  return typeof r > "u" ? ky[t].call(i, n) : r;
}
class Kv extends ji {
  static positioners = Ka;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const i = this.chart, n = this.options.setContext(this.getContext()), r = n.enabled && i.options.animation && n.animations, a = new sy(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(a)), a;
  }
  getContext() {
    return this.$context || (this.$context = DC(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, i) {
    const { callbacks: n } = i, r = xe(n, "beforeTitle", this, t), a = xe(n, "title", this, t), o = xe(n, "afterTitle", this, t);
    let s = [];
    return s = yi(s, Bi(r)), s = yi(s, Bi(a)), s = yi(s, Bi(o)), s;
  }
  getBeforeBody(t, i) {
    return qv(xe(i.callbacks, "beforeBody", this, t));
  }
  getBody(t, i) {
    const { callbacks: n } = i, r = [];
    return _t(t, (a) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, s = Zv(n, a);
      yi(o.before, Bi(xe(s, "beforeLabel", this, a))), yi(o.lines, xe(s, "label", this, a)), yi(o.after, Bi(xe(s, "afterLabel", this, a))), r.push(o);
    }), r;
  }
  getAfterBody(t, i) {
    return qv(xe(i.callbacks, "afterBody", this, t));
  }
  getFooter(t, i) {
    const { callbacks: n } = i, r = xe(n, "beforeFooter", this, t), a = xe(n, "footer", this, t), o = xe(n, "afterFooter", this, t);
    let s = [];
    return s = yi(s, Bi(r)), s = yi(s, Bi(a)), s = yi(s, Bi(o)), s;
  }
  _createItems(t) {
    const i = this._active, n = this.chart.data, r = [], a = [], o = [];
    let s = [], l, u;
    for (l = 0, u = i.length; l < u; ++l)
      s.push(wC(this.chart, i[l]));
    return t.filter && (s = s.filter((c, h, d) => t.filter(c, h, d, n))), t.itemSort && (s = s.sort((c, h) => t.itemSort(c, h, n))), _t(s, (c) => {
      const h = Zv(t.callbacks, c);
      r.push(xe(h, "labelColor", this, c)), a.push(xe(h, "labelPointStyle", this, c)), o.push(xe(h, "labelTextColor", this, c));
    }), this.labelColors = r, this.labelPointStyles = a, this.labelTextColors = o, this.dataPoints = s, s;
  }
  update(t, i) {
    const n = this.options.setContext(this.getContext()), r = this._active;
    let a, o = [];
    if (!r.length)
      this.opacity !== 0 && (a = {
        opacity: 0
      });
    else {
      const s = Ka[n.position].call(this, r, this._eventPosition);
      o = this._createItems(n), this.title = this.getTitle(o, n), this.beforeBody = this.getBeforeBody(o, n), this.body = this.getBody(o, n), this.afterBody = this.getAfterBody(o, n), this.footer = this.getFooter(o, n);
      const l = this._size = Gv(this, n), u = Object.assign({}, s, l), c = Xv(this.chart, n, u), h = jv(n, u, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, a = {
        opacity: 1,
        x: h.x,
        y: h.y,
        width: l.width,
        height: l.height,
        caretX: s.x,
        caretY: s.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, a && this._resolveAnimations().update(this, a), t && n.external && n.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(t, i, n, r) {
    const a = this.getCaretPosition(t, n, r);
    i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3);
  }
  getCaretPosition(t, i, n) {
    const { xAlign: r, yAlign: a } = this, { caretSize: o, cornerRadius: s } = n, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: h } = ea(s), { x: d, y: f } = t, { width: v, height: m } = i;
    let p, g, y, _, b, w;
    return a === "center" ? (b = f + m / 2, r === "left" ? (p = d, g = p - o, _ = b + o, w = b - o) : (p = d + v, g = p + o, _ = b - o, w = b + o), y = p) : (r === "left" ? g = d + Math.max(l, c) + o : r === "right" ? g = d + v - Math.max(u, h) - o : g = this.caretX, a === "top" ? (_ = f, b = _ - o, p = g - o, y = g + o) : (_ = f + m, b = _ + o, p = g + o, y = g - o), w = _), {
      x1: p,
      x2: g,
      x3: y,
      y1: _,
      y2: b,
      y3: w
    };
  }
  drawTitle(t, i, n) {
    const r = this.title, a = r.length;
    let o, s, l;
    if (a) {
      const u = ia(n.rtl, this.x, this.width);
      for (t.x = as(this, n.titleAlign, n), i.textAlign = u.textAlign(n.titleAlign), i.textBaseline = "middle", o = ue(n.titleFont), s = n.titleSpacing, i.fillStyle = n.titleColor, i.font = o.string, l = 0; l < a; ++l)
        i.fillText(r[l], u.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + s, l + 1 === a && (t.y += n.titleMarginBottom - s);
    }
  }
  _drawColorBox(t, i, n, r, a) {
    const o = this.labelColors[n], s = this.labelPointStyles[n], { boxHeight: l, boxWidth: u } = a, c = ue(a.bodyFont), h = as(this, "left", a), d = r.x(h), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, v = i.y + f;
    if (a.usePointStyle) {
      const m = {
        radius: Math.min(u, l) / 2,
        pointStyle: s.pointStyle,
        rotation: s.rotation,
        borderWidth: 1
      }, p = r.leftForLtr(d, u) + u / 2, g = v + l / 2;
      t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, ah(t, m, p, g), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, ah(t, m, p, g);
    } else {
      t.lineWidth = ut(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0;
      const m = r.leftForLtr(d, u), p = r.leftForLtr(r.xPlus(d, 1), u - 2), g = ea(o.borderRadius);
      Object.values(g).some((y) => y !== 0) ? (t.beginPath(), t.fillStyle = a.multiKeyBackground, ll(t, {
        x: m,
        y: v,
        w: u,
        h: l,
        radius: g
      }), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), ll(t, {
        x: p,
        y: v + 1,
        w: u - 2,
        h: l - 2,
        radius: g
      }), t.fill()) : (t.fillStyle = a.multiKeyBackground, t.fillRect(m, v, u, l), t.strokeRect(m, v, u, l), t.fillStyle = o.backgroundColor, t.fillRect(p, v + 1, u - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[n];
  }
  drawBody(t, i, n) {
    const { body: r } = this, { bodySpacing: a, bodyAlign: o, displayColors: s, boxHeight: l, boxWidth: u, boxPadding: c } = n, h = ue(n.bodyFont);
    let d = h.lineHeight, f = 0;
    const v = ia(n.rtl, this.x, this.width), m = function(T) {
      i.fillText(T, v.x(t.x + f), t.y + d / 2), t.y += d + a;
    }, p = v.textAlign(o);
    let g, y, _, b, w, S, C;
    for (i.textAlign = o, i.textBaseline = "middle", i.font = h.string, t.x = as(this, p, n), i.fillStyle = n.bodyColor, _t(this.beforeBody, m), f = s && p !== "right" ? o === "center" ? u / 2 + c : u + 2 + c : 0, b = 0, S = r.length; b < S; ++b) {
      for (g = r[b], y = this.labelTextColors[b], i.fillStyle = y, _t(g.before, m), _ = g.lines, s && _.length && (this._drawColorBox(i, t, b, v, n), d = Math.max(h.lineHeight, l)), w = 0, C = _.length; w < C; ++w)
        m(_[w]), d = h.lineHeight;
      _t(g.after, m);
    }
    f = 0, d = h.lineHeight, _t(this.afterBody, m), t.y -= a;
  }
  drawFooter(t, i, n) {
    const r = this.footer, a = r.length;
    let o, s;
    if (a) {
      const l = ia(n.rtl, this.x, this.width);
      for (t.x = as(this, n.footerAlign, n), t.y += n.footerMarginTop, i.textAlign = l.textAlign(n.footerAlign), i.textBaseline = "middle", o = ue(n.footerFont), i.fillStyle = n.footerColor, i.font = o.string, s = 0; s < a; ++s)
        i.fillText(r[s], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + n.footerSpacing;
    }
  }
  drawBackground(t, i, n, r) {
    const { xAlign: a, yAlign: o } = this, { x: s, y: l } = t, { width: u, height: c } = n, { topLeft: h, topRight: d, bottomLeft: f, bottomRight: v } = ea(r.cornerRadius);
    i.fillStyle = r.backgroundColor, i.strokeStyle = r.borderColor, i.lineWidth = r.borderWidth, i.beginPath(), i.moveTo(s + h, l), o === "top" && this.drawCaret(t, i, n, r), i.lineTo(s + u - d, l), i.quadraticCurveTo(s + u, l, s + u, l + d), o === "center" && a === "right" && this.drawCaret(t, i, n, r), i.lineTo(s + u, l + c - v), i.quadraticCurveTo(s + u, l + c, s + u - v, l + c), o === "bottom" && this.drawCaret(t, i, n, r), i.lineTo(s + f, l + c), i.quadraticCurveTo(s, l + c, s, l + c - f), o === "center" && a === "left" && this.drawCaret(t, i, n, r), i.lineTo(s, l + h), i.quadraticCurveTo(s, l, s + h, l), i.closePath(), i.fill(), r.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(t) {
    const i = this.chart, n = this.$animations, r = n && n.x, a = n && n.y;
    if (r || a) {
      const o = Ka[t.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const s = this._size = Gv(this, t), l = Object.assign({}, o, this._size), u = Xv(i, t, l), c = jv(t, l, u, i);
      (r._to !== c.x || a._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = s.width, this.height = s.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const i = this.options.setContext(this.getContext());
    let n = this.opacity;
    if (!n)
      return;
    this._updateAnimationTarget(i);
    const r = {
      width: this.width,
      height: this.height
    }, a = {
      x: this.x,
      y: this.y
    };
    n = Math.abs(n) < 1e-3 ? 0 : n;
    const o = Je(i.padding), s = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && s && (t.save(), t.globalAlpha = n, this.drawBackground(a, t, r, i), ey(t, i.textDirection), a.y += o.top, this.drawTitle(a, t, i), this.drawBody(a, t, i), this.drawFooter(a, t, i), iy(t, i.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, i) {
    const n = this._active, r = t.map(({ datasetIndex: s, index: l }) => {
      const u = this.chart.getDatasetMeta(s);
      if (!u)
        throw new Error("Cannot find a dataset at index " + s);
      return {
        datasetIndex: s,
        element: u.data[l],
        index: l
      };
    }), a = !al(n, r), o = this._positionChanged(r, i);
    (a || o) && (this._active = r, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, i, n = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, a = this._active || [], o = this._getActiveElements(t, a, i, n), s = this._positionChanged(o, t), l = i || !al(o, a) || s;
    return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, i))), l;
  }
  _getActiveElements(t, i, n, r) {
    const a = this.options;
    if (t.type === "mouseout")
      return [];
    if (!r)
      return i.filter((s) => this.chart.data.datasets[s.datasetIndex] && this.chart.getDatasetMeta(s.datasetIndex).controller.getParsed(s.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(t, a.mode, a, n);
    return a.reverse && o.reverse(), o;
  }
  _positionChanged(t, i) {
    const { caretX: n, caretY: r, options: a } = this, o = Ka[a.position].call(this, t, i);
    return o !== !1 && (n !== o.x || r !== o.y);
  }
}
var Dd = {
  id: "tooltip",
  _element: Kv,
  positioners: Ka,
  afterInit(e, t, i) {
    i && (e.tooltip = new Kv({
      chart: e,
      options: i
    }));
  },
  beforeUpdate(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  reset(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const i = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const i = t.replay;
      e.tooltip.handleEvent(t.event, i, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: ky
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const EC = (e, t, i, n) => (typeof t == "string" ? (i = e.push(t) - 1, n.unshift({
  index: i,
  label: t
})) : isNaN(t) && (i = null), i);
function AC(e, t, i, n) {
  const r = e.indexOf(t);
  if (r === -1)
    return EC(e, t, i, n);
  const a = e.lastIndexOf(t);
  return r !== a ? i : r;
}
const LC = (e, t) => e === null ? null : le(Math.round(e), 0, t);
function Qv(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Dy extends ga {
  static id = "category";
  static defaults = {
    ticks: {
      callback: Qv
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const i = this._addedLabels;
    if (i.length) {
      const n = this.getLabels();
      for (const { index: r, label: a } of i)
        n[r] === a && n.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, i) {
    if (gt(t))
      return null;
    const n = this.getLabels();
    return i = isFinite(i) && n[i] === t ? i : AC(n, t, at(i, t), this._addedLabels), LC(i, n.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: i } = this.getUserBounds();
    let { min: n, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (n = 0), i || (r = this.getLabels().length - 1)), this.min = n, this.max = r;
  }
  buildTicks() {
    const t = this.min, i = this.max, n = this.options.offset, r = [];
    let a = this.getLabels();
    a = t === 0 && i === a.length - 1 ? a : a.slice(t, i + 1), this._valueRange = Math.max(a.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
    for (let o = t; o <= i; o++)
      r.push({
        value: o
      });
    return r;
  }
  getLabelForValue(t) {
    return Qv.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function PC(e, t) {
  const i = [], { bounds: r, step: a, min: o, max: s, precision: l, count: u, maxTicks: c, maxDigits: h, includeBounds: d } = e, f = a || 1, v = c - 1, { min: m, max: p } = t, g = !gt(o), y = !gt(s), _ = !gt(u), b = (p - m) / (h + 1);
  let w = jf((p - m) / v / f) * f, S, C, T, k;
  if (w < 1e-14 && !g && !y)
    return [
      {
        value: m
      },
      {
        value: p
      }
    ];
  k = Math.ceil(p / w) - Math.floor(m / w), k > v && (w = jf(k * w / v / f) * f), gt(l) || (S = Math.pow(10, l), w = Math.ceil(w * S) / S), r === "ticks" ? (C = Math.floor(m / w) * w, T = Math.ceil(p / w) * w) : (C = m, T = p), g && y && a && Lx((s - o) / a, w / 1e3) ? (k = Math.round(Math.min((s - o) / w, c)), w = (s - o) / k, C = o, T = s) : _ ? (C = g ? o : C, T = y ? s : T, k = u - 1, w = (T - C) / k) : (k = (T - C) / w, lo(k, Math.round(k), w / 1e3) ? k = Math.round(k) : k = Math.ceil(k));
  const M = Math.max(qf(w), qf(C));
  S = Math.pow(10, gt(l) ? M : l), C = Math.round(C * S) / S, T = Math.round(T * S) / S;
  let D = 0;
  for (g && (d && C !== o ? (i.push({
    value: o
  }), C < o && D++, lo(Math.round((C + D * w) * S) / S, o, Jv(o, b, e)) && D++) : C < o && D++); D < k; ++D) {
    const L = Math.round((C + D * w) * S) / S;
    if (y && L > s)
      break;
    i.push({
      value: L
    });
  }
  return y && d && T !== s ? i.length && lo(i[i.length - 1].value, s, Jv(s, b, e)) ? i[i.length - 1].value = s : i.push({
    value: s
  }) : (!y || T === s) && i.push({
    value: T
  }), i;
}
function Jv(e, t, { horizontal: i, minRotation: n }) {
  const r = $i(n), a = (i ? Math.sin(r) : Math.cos(r)) || 1e-3, o = 0.75 * t * ("" + e).length;
  return Math.min(t / a, o);
}
class IC extends ga {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, i) {
    return gt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: i, maxDefined: n } = this.getUserBounds();
    let { min: r, max: a } = this;
    const o = (l) => r = i ? r : l, s = (l) => a = n ? a : l;
    if (t) {
      const l = Si(r), u = Si(a);
      l < 0 && u < 0 ? s(0) : l > 0 && u > 0 && o(0);
    }
    if (r === a) {
      let l = a === 0 ? 1 : Math.abs(a * 0.05);
      s(a + l), t || o(r - l);
    }
    this.min = r, this.max = a;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: i, stepSize: n } = t, r;
    return n ? (r = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), i = i || 11), i && (r = Math.min(i, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, i = t.ticks;
    let n = this.getTickLimit();
    n = Math.max(2, n);
    const r = {
      maxTicks: n,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, a = this._range || this, o = PC(r, a);
    return t.bounds === "ticks" && Px(o, this, "value"), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const t = this.ticks;
    let i = this.min, n = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const r = (n - i) / Math.max(t.length - 1, 1) / 2;
      i -= r, n += r;
    }
    this._startValue = i, this._endValue = n, this._valueRange = n - i;
  }
  getLabelForValue(t) {
    return _d(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Ey extends IC {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: X0.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: i } = this.getMinMax(!0);
    this.min = de(t) ? t : 0, this.max = de(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), i = t ? this.width : this.height, n = $i(this.options.ticks.minRotation), r = (t ? Math.sin(n) : Math.cos(n)) || 1e-3, a = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, a.lineHeight / r));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const nu = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, De = /* @__PURE__ */ Object.keys(nu);
function tp(e, t) {
  return e - t;
}
function ep(e, t) {
  if (gt(t))
    return null;
  const i = e._adapter, { parser: n, round: r, isoWeekday: a } = e._parseOpts;
  let o = t;
  return typeof n == "function" && (o = n(o)), de(o) || (o = typeof n == "string" ? i.parse(o, n) : i.parse(o)), o === null ? null : (r && (o = r === "week" && (Co(a) || a === !0) ? i.startOf(o, "isoWeek", a) : i.startOf(o, r)), +o);
}
function ip(e, t, i, n) {
  const r = De.length;
  for (let a = De.indexOf(e); a < r - 1; ++a) {
    const o = nu[De[a]], s = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((i - t) / (s * o.size)) <= n)
      return De[a];
  }
  return De[r - 1];
}
function RC(e, t, i, n, r) {
  for (let a = De.length - 1; a >= De.indexOf(i); a--) {
    const o = De[a];
    if (nu[o].common && e._adapter.diff(r, n, o) >= t - 1)
      return o;
  }
  return De[i ? De.indexOf(i) : 0];
}
function OC(e) {
  for (let t = De.indexOf(e) + 1, i = De.length; t < i; ++t)
    if (nu[De[t]].common)
      return De[t];
}
function np(e, t, i) {
  if (!i)
    e[t] = !0;
  else if (i.length) {
    const { lo: n, hi: r } = gd(i, t), a = i[n] >= t ? i[n] : i[r];
    e[a] = !0;
  }
}
function BC(e, t, i, n) {
  const r = e._adapter, a = +r.startOf(t[0].value, n), o = t[t.length - 1].value;
  let s, l;
  for (s = a; s <= o; s = +r.add(s, 1, n))
    l = i[s], l >= 0 && (t[l].major = !0);
  return t;
}
function rp(e, t, i) {
  const n = [], r = {}, a = t.length;
  let o, s;
  for (o = 0; o < a; ++o)
    s = t[o], r[s] = o, n.push({
      value: s,
      major: !1
    });
  return a === 0 || !i ? n : BC(e, n, r, i);
}
class ap extends ga {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, i = {}) {
    const n = t.time || (t.time = {}), r = this._adapter = new yw._date(t.adapters.date);
    r.init(i), so(n.displayFormats, r.formats()), this._parseOpts = {
      parser: n.parser,
      round: n.round,
      isoWeekday: n.isoWeekday
    }, super.init(t), this._normalized = i.normalized;
  }
  parse(t, i) {
    return t === void 0 ? null : ep(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, i = this._adapter, n = t.time.unit || "day";
    let { min: r, max: a, minDefined: o, maxDefined: s } = this.getUserBounds();
    function l(u) {
      !o && !isNaN(u.min) && (r = Math.min(r, u.min)), !s && !isNaN(u.max) && (a = Math.max(a, u.max));
    }
    (!o || !s) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), r = de(r) && !isNaN(r) ? r : +i.startOf(Date.now(), n), a = de(a) && !isNaN(a) ? a : +i.endOf(Date.now(), n) + 1, this.min = Math.min(r, a - 1), this.max = Math.max(r + 1, a);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
    return t.length && (i = t[0], n = t[t.length - 1]), {
      min: i,
      max: n
    };
  }
  buildTicks() {
    const t = this.options, i = t.time, n = t.ticks, r = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const a = this.min, o = this.max, s = Nx(r, a, o);
    return this._unit = i.unit || (n.autoSkip ? ip(i.minUnit, this.min, this.max, this._getLabelCapacity(a)) : RC(this, s.length, i.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : OC(this._unit), this.initOffsets(r), t.reverse && s.reverse(), rp(this, s, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let i = 0, n = 0, r, a;
    this.options.offset && t.length && (r = this.getDecimalForValue(t[0]), t.length === 1 ? i = 1 - r : i = (this.getDecimalForValue(t[1]) - r) / 2, a = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? n = a : n = (a - this.getDecimalForValue(t[t.length - 2])) / 2);
    const o = t.length < 3 ? 0.5 : 0.25;
    i = le(i, 0, o), n = le(n, 0, o), this._offsets = {
      start: i,
      end: n,
      factor: 1 / (i + 1 + n)
    };
  }
  _generate() {
    const t = this._adapter, i = this.min, n = this.max, r = this.options, a = r.time, o = a.unit || ip(a.minUnit, i, n, this._getLabelCapacity(i)), s = at(r.ticks.stepSize, 1), l = o === "week" ? a.isoWeekday : !1, u = Co(l) || l === !0, c = {};
    let h = i, d, f;
    if (u && (h = +t.startOf(h, "isoWeek", l)), h = +t.startOf(h, u ? "day" : o), t.diff(n, i, o) > 1e5 * s)
      throw new Error(i + " and " + n + " are too far apart with stepSize of " + s + " " + o);
    const v = r.ticks.source === "data" && this.getDataTimestamps();
    for (d = h, f = 0; d < n; d = +t.add(d, s, o), f++)
      np(c, d, v);
    return (d === n || r.bounds === "ticks" || f === 1) && np(c, d, v), Object.keys(c).sort(tp).map((m) => +m);
  }
  getLabelForValue(t) {
    const i = this._adapter, n = this.options.time;
    return n.tooltipFormat ? i.format(t, n.tooltipFormat) : i.format(t, n.displayFormats.datetime);
  }
  format(t, i) {
    const r = this.options.time.displayFormats, a = this._unit, o = i || r[a];
    return this._adapter.format(t, o);
  }
  _tickFormatFunction(t, i, n, r) {
    const a = this.options, o = a.ticks.callback;
    if (o)
      return At(o, [
        t,
        i,
        n
      ], this);
    const s = a.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && s[l], h = u && s[u], d = n[i], f = u && h && d && d.major;
    return this._adapter.format(t, r || (f ? h : c));
  }
  generateTickLabels(t) {
    let i, n, r;
    for (i = 0, n = t.length; i < n; ++i)
      r = t[i], r.label = this._tickFormatFunction(r.value, i, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const i = this._offsets, n = this.getDecimalForValue(t);
    return this.getPixelForDecimal((i.start + n) * i.factor);
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return this.min + n * (this.max - this.min);
  }
  _getLabelSize(t) {
    const i = this.options.ticks, n = this.ctx.measureText(t).width, r = $i(this.isHorizontal() ? i.maxRotation : i.minRotation), a = Math.cos(r), o = Math.sin(r), s = this._resolveTickFontOptions(0).size;
    return {
      w: n * a + s * o,
      h: n * o + s * a
    };
  }
  _getLabelCapacity(t) {
    const i = this.options.time, n = i.displayFormats, r = n[i.unit] || n.millisecond, a = this._tickFormatFunction(t, 0, rp(this, [
      t
    ], this._majorUnit), r), o = this._getLabelSize(a), s = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return s > 0 ? s : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], i, n;
    if (t.length)
      return t;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (i = 0, n = r.length; i < n; ++i)
      t = t.concat(r[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let i, n;
    if (t.length)
      return t;
    const r = this.getLabels();
    for (i = 0, n = r.length; i < n; ++i)
      t.push(ep(this, r[i]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return Y0(t.sort(tp));
  }
}
function os(e, t, i) {
  let n = 0, r = e.length - 1, a, o, s, l;
  i ? (t >= e[n].pos && t <= e[r].pos && ({ lo: n, hi: r } = tr(e, "pos", t)), { pos: a, time: s } = e[n], { pos: o, time: l } = e[r]) : (t >= e[n].time && t <= e[r].time && ({ lo: n, hi: r } = tr(e, "time", t)), { time: a, pos: s } = e[n], { time: o, pos: l } = e[r]);
  const u = o - a;
  return u ? s + (l - s) * (t - a) / u : s;
}
class hV extends ap {
  static id = "timeseries";
  static defaults = ap.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(t);
    this._minPos = os(i, this.min), this._tableRange = os(i, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: i, max: n } = this, r = [], a = [];
    let o, s, l, u, c;
    for (o = 0, s = t.length; o < s; ++o)
      u = t[o], u >= i && u <= n && r.push(u);
    if (r.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: n,
          pos: 1
        }
      ];
    for (o = 0, s = r.length; o < s; ++o)
      c = r[o + 1], l = r[o - 1], u = r[o], Math.round((c + l) / 2) !== u && a.push({
        time: u,
        pos: o / (s - 1)
      });
    return a;
  }
  _generate() {
    const t = this.min, i = this.max;
    let n = super.getDataTimestamps();
    return (!n.includes(t) || !n.length) && n.splice(0, 0, t), (!n.includes(i) || n.length === 1) && n.push(i), n.sort((r, a) => r - a);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const i = this.getDataTimestamps(), n = this.getLabelTimestamps();
    return i.length && n.length ? t = this.normalize(i.concat(n)) : t = i.length ? i : n, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (os(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return os(this._table, n * this._tableRange + this._minPos, !0);
  }
}
const Ay = {
  data: {
    type: Object,
    required: !0
  },
  options: {
    type: Object,
    default: () => ({})
  },
  plugins: {
    type: Array,
    default: () => []
  },
  datasetIdKey: {
    type: String,
    default: "label"
  },
  updateMode: {
    type: String,
    default: void 0
  }
}, NC = {
  ariaLabel: {
    type: String
  },
  ariaDescribedby: {
    type: String
  }
}, FC = {
  type: {
    type: String,
    required: !0
  },
  destroyDelay: {
    type: Number,
    default: 0
    // No delay by default
  },
  ...Ay,
  ...NC
}, $C = q1[0] === "2" ? (e, t) => Object.assign(e, {
  attrs: t
}) : (e, t) => Object.assign(e, t);
function Er(e) {
  return O0(e) ? eh(e) : e;
}
function zC(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
  return O0(t) ? new Proxy(e, {}) : e;
}
function VC(e, t) {
  const i = e.options;
  i && t && Object.assign(i, t);
}
function Ly(e, t) {
  e.labels = t;
}
function Py(e, t, i) {
  const n = [];
  e.datasets = t.map((r) => {
    const a = e.datasets.find((o) => o[i] === r[i]);
    return !a || !r.data || n.includes(a) ? {
      ...r
    } : (n.push(a), Object.assign(a, r), a);
  });
}
function HC(e, t) {
  const i = {
    labels: [],
    datasets: []
  };
  return Ly(i, e.labels), Py(i, e.datasets, t), i;
}
const WC = jt({
  props: FC,
  setup(e, t) {
    let { expose: i, slots: n } = t;
    const r = Ke(null), a = P0(null);
    i({
      chart: a
    });
    const o = () => {
      if (!r.value) return;
      const { type: u, data: c, options: h, plugins: d, datasetIdKey: f } = e, v = HC(c, f), m = zC(v, c);
      a.value = new ma(r.value, {
        type: u,
        data: m,
        options: {
          ...h
        },
        plugins: d
      });
    }, s = () => {
      const u = eh(a.value);
      u && (e.destroyDelay > 0 ? setTimeout(() => {
        u.destroy(), a.value = null;
      }, e.destroyDelay) : (u.destroy(), a.value = null));
    }, l = (u) => {
      u.update(e.updateMode);
    };
    return hd(o), I0(s), sa([
      () => e.options,
      () => e.data
    ], (u, c) => {
      let [h, d] = u, [f, v] = c;
      const m = eh(a.value);
      if (!m)
        return;
      let p = !1;
      if (h) {
        const g = Er(h), y = Er(f);
        g && g !== y && (VC(m, g), p = !0);
      }
      if (d) {
        const g = Er(d.labels), y = Er(v.labels), _ = Er(d.datasets), b = Er(v.datasets);
        g !== y && (Ly(m.config.data, g), p = !0), _ && _ !== b && (Py(m.config.data, _, e.datasetIdKey), p = !0);
      }
      p && R0(() => {
        l(m);
      });
    }, {
      deep: !0
    }), () => th("canvas", {
      role: "img",
      "aria-label": e.ariaLabel,
      "aria-describedby": e.ariaDescribedby,
      ref: r
    }, [
      th("p", {}, [
        n.default ? n.default() : ""
      ])
    ]);
  }
});
function Ed(e, t) {
  return ma.register(t), jt({
    props: Ay,
    setup(i, n) {
      let { expose: r } = n;
      const a = P0(null), o = (s) => {
        a.value = s?.chart;
      };
      return r({
        chart: a
      }), () => th(WC, $C({
        ref: o
      }, {
        type: e,
        ...i
      }));
    }
  });
}
const YC = /* @__PURE__ */ Ed("bar", fw), UC = /* @__PURE__ */ Ed("line", gw), GC = /* @__PURE__ */ Ed("pie", mw), op = {
  // Backgrounds
  bgPrimary: "#f8f9fa",
  bgSecondary: "#ffffff",
  bgCard: "#ffffff",
  bgCardGradientStart: "#ffffff",
  bgCardGradientEnd: "#fafafa",
  bgTable: "#ffffff",
  bgTableHeader: "#f8fafc",
  bgTableHover: "#f8fafc",
  // Text
  textPrimary: "#1e293b",
  textSecondary: "#64748b",
  textMuted: "#94a3b8",
  // Borders & Lines
  borderColor: "rgba(93, 75, 147, 0.1)",
  borderLight: "rgba(0, 0, 0, 0.05)",
  gridLines: "rgba(148, 163, 184, 0.12)",
  // Shadows
  shadowLight: "rgba(0, 0, 0, 0.05)",
  shadowMedium: "rgba(0, 0, 0, 0.08)",
  shadowHeavy: "rgba(0, 0, 0, 0.1)",
  // Charts specific
  tooltipBg: "rgba(15, 23, 42, 0.95)",
  tooltipText: "#f1f5f9",
  tooltipBorder: "rgba(148, 163, 184, 0.2)",
  // Status colors
  success: "#10b981",
  warning: "#f59e0b",
  danger: "#ef4444",
  info: "#3b82f6",
  // Brand colors
  primaryLight: "#c67dff",
  primaryDefault: "#5d4b93",
  primaryDark: "#4a3a75"
}, sp = {
  // Backgrounds
  bgPrimary: "#000000",
  bgSecondary: "#1a1a1d",
  bgCard: "#1a1a1d",
  bgCardGradientStart: "#1a1a1d",
  bgCardGradientEnd: "#0f0f11",
  bgTable: "#1a1a1d",
  bgTableHeader: "#252528",
  bgTableHover: "#252528",
  // Text
  textPrimary: "#f8f9fa",
  textSecondary: "#9ca3af",
  textMuted: "#6b7280",
  // Borders & Lines
  borderColor: "rgba(198, 125, 255, 0.15)",
  borderLight: "rgba(198, 125, 255, 0.08)",
  gridLines: "rgba(198, 125, 255, 0.12)",
  // Shadows
  shadowLight: "rgba(0, 0, 0, 0.3)",
  shadowMedium: "rgba(0, 0, 0, 0.4)",
  shadowHeavy: "rgba(0, 0, 0, 0.5)",
  // Charts specific
  tooltipBg: "rgba(26, 26, 29, 0.98)",
  tooltipText: "#f8f9fa",
  tooltipBorder: "rgba(198, 125, 255, 0.2)",
  // Status colors
  success: "#10b981",
  warning: "#f59e0b",
  danger: "#ef4444",
  info: "#3b82f6",
  // Brand colors
  primaryLight: "#c67dff",
  primaryDefault: "#5d4b93",
  primaryDark: "#4a3a75"
}, XC = [
  "#C67DFF",
  // Purple light
  "#5D4B93",
  // Purple default
  "#73D1D3",
  // Cyan
  "#1EC383",
  // Green
  "#F496A6",
  // Pink
  "#F3A332",
  // Orange
  "#7D8AFA"
  // Blue
];
function re(e) {
  const t = Ke("light");
  let i = null;
  const n = () => typeof document > "u" ? "light" : document.documentElement.classList.contains("dark") ? "dark" : "light", r = G(() => e?.value ? e.value : t.value), a = G(() => r.value === "dark"), o = G(() => a.value ? sp : op), s = () => {
    typeof document > "u" || (t.value = n(), i = new MutationObserver((u) => {
      for (const c of u)
        c.attributeName === "class" && (t.value = n());
    }), i.observe(document.documentElement, {
      attributes: !0,
      attributeFilter: ["class"]
    }));
  }, l = () => {
    i && (i.disconnect(), i = null);
  };
  return hd(() => {
    s();
  }), I0(() => {
    l();
  }), e && sa(e, () => {
  }), {
    isDark: a,
    currentTheme: r,
    colors: o,
    detectedTheme: t,
    // Export color constants for direct access if needed
    lightColors: op,
    darkColors: sp,
    chartSeriesColors: XC
  };
}
const jC = { class: "chart-container" }, qC = /* @__PURE__ */ jt({
  __name: "ChartBar",
  props: {
    data: {},
    options: {},
    stacked: { type: Boolean },
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    ma.register(
      Dy,
      Ey,
      qS,
      My,
      Dd,
      kd
    );
    const { isDark: n, colors: r } = re(ne(i, "theme")), a = i.data, o = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, s = G(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          },
          generateLabels: function(l) {
            return l.data.datasets.map((c, h) => ({
              text: o(c.label || ""),
              fillStyle: Array.isArray(c.backgroundColor) ? c.backgroundColor[0] : c.backgroundColor,
              strokeStyle: Array.isArray(c.borderColor) ? c.borderColor[0] : c.borderColor,
              lineWidth: c.borderWidth,
              hidden: !l.isDatasetVisible(h),
              index: h,
              datasetIndex: h
            }));
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(o(l[0].label)) : "";
            },
            label: function(l) {
              let u = String(o(l.dataset.label || ""));
              return u && (u += ": "), l.parsed.y !== null && (u += l.parsed.y), u;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          stacked: i.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            color: r.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              return o(l);
            }
          }
        },
        x: {
          stacked: i.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              const u = this.getLabelForValue(l);
              return o(u);
            }
          }
        }
      },
      elements: {
        bar: {
          borderRadius: 8,
          borderWidth: 0
        }
      }
    });
    return t({ isDark: n }), (l, u) => (A(), I("div", jC, [
      Qt(Y(YC), {
        data: Y(a),
        options: s.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), Vt = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [n, r] of t)
    i[n] = r;
  return i;
}, Iy = /* @__PURE__ */ Vt(qC, [["__scopeId", "data-v-be0a7bf2"]]), ZC = { class: "chart-container" }, KC = /* @__PURE__ */ jt({
  __name: "ChartLine",
  props: {
    data: {},
    options: {},
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    ma.register(
      Dy,
      Ey,
      WS,
      eu,
      My,
      Dd,
      kd,
      pC
    );
    const { isDark: n, colors: r } = re(ne(i, "theme")), a = i.data, o = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, s = G(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(l) {
              return l.data.datasets.map((c, h) => ({
                text: o(c.label || ""),
                fillStyle: c.backgroundColor,
                strokeStyle: c.borderColor,
                lineWidth: c.borderWidth,
                hidden: !l.isDatasetVisible(h),
                index: h,
                datasetIndex: h
              }));
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(o(l[0].label)) : "";
            },
            label: function(l) {
              let u = String(o(l.dataset.label || ""));
              return u && (u += ": "), l.parsed.y !== null && (u += l.parsed.y), u;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: r.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              return o(l);
            }
          }
        },
        x: {
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              const u = this.getLabelForValue(l);
              return o(u);
            }
          }
        }
      },
      elements: {
        line: {
          tension: 0.4,
          borderWidth: 2.5,
          borderCapStyle: "round"
        },
        point: {
          radius: 4,
          hoverRadius: 6,
          borderWidth: 2,
          backgroundColor: n.value ? "#1a1a1d" : "#ffffff",
          hoverBorderWidth: 3
        }
      }
    });
    return t({ isDark: n }), (l, u) => (A(), I("div", ZC, [
      Qt(Y(UC), {
        data: Y(a),
        options: s.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), Ad = /* @__PURE__ */ Vt(KC, [["__scopeId", "data-v-c400b486"]]), QC = { class: "chart-container" }, JC = /* @__PURE__ */ jt({
  __name: "PieChart",
  props: {
    data: {},
    options: {},
    doughnut: { type: Boolean },
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    ma.register(IS, Dd, kd);
    const { isDark: n, colors: r } = re(ne(i, "theme")), a = i.data, o = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, s = G(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      cutout: i.doughnut ? "60%" : 0,
      plugins: {
        legend: {
          display: !0,
          position: "bottom",
          align: "center",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 16,
            boxWidth: 14,
            boxHeight: 14,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(l) {
              const u = l.data;
              return u.labels.length && u.datasets.length ? u.labels.map((c, h) => {
                const d = l.getDatasetMeta(0), f = u.datasets[0], v = f.data[h], m = Array.isArray(f.backgroundColor) ? f.backgroundColor[h] : f.backgroundColor;
                return {
                  text: `${o(c)}: ${v}`,
                  fillStyle: m,
                  hidden: d.data[h]?.hidden || !1,
                  index: h
                };
              }) : [];
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(o(l[0].label)) : "";
            },
            label: function(l) {
              const u = l.label || "", c = l.parsed || 0, h = l.dataset.data.reduce((f, v) => f + v, 0), d = (c / h * 100).toFixed(1);
              return `${o(u)}: ${c} (${d}%)`;
            }
          }
        }
      },
      elements: {
        arc: {
          borderWidth: 2,
          borderColor: n.value ? "#1a1a1d" : "#ffffff",
          hoverOffset: 8
        }
      },
      animation: {
        animateRotate: !0,
        animateScale: !0
      }
    });
    return t({ isDark: n }), (l, u) => (A(), I("div", QC, [
      Qt(Y(GC), {
        data: Y(a),
        options: s.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), Ry = /* @__PURE__ */ Vt(JC, [["__scopeId", "data-v-23a84317"]]), tT = { class: "chart-container" }, eT = ["viewBox"], iT = ["transform"], nT = ["x", "width", "fill", "stroke"], rT = ["fill"], aT = ["x1", "y1", "x2", "y2", "stroke"], oT = ["points", "fill"], sT = ["x1", "y1", "x2", "y2", "stroke"], lT = ["x", "y", "fill"], uT = ["x1", "y1", "x2", "y2", "stroke"], cT = ["points", "fill"], hT = ["transform"], dT = ["y1", "y2"], fT = ["y1", "y2"], vT = ["y1", "y2"], pT = ["y1", "y2"], gT = ["y", "height"], mT = ["y1", "y2"], yT = ["y1", "y2"], _T = ["y1", "y2"], bT = ["y1", "y2"], xT = ["y", "height"], wT = ["cy", "stroke", "onMouseenter"], ST = ["cy", "stroke", "onMouseenter"], CT = ["cy", "stroke", "onMouseenter"], TT = ["cy", "stroke", "onMouseenter"], MT = ["y1", "y2", "onMouseenter"], kT = ["y1", "y2", "onMouseenter"], DT = ["x", "y", "fill"], ET = ["x", "y", "fill"], AT = ["transform"], LT = { transform: "translate(-200, 0)" }, PT = ["stroke"], IT = ["fill"], RT = { transform: "translate(-130, 0)" }, OT = ["stroke"], BT = ["fill"], NT = { transform: "translate(-60, 0)" }, FT = ["stroke"], $T = ["fill"], zT = { transform: "translate(10, 0)" }, VT = ["stroke"], HT = ["fill"], WT = { transform: "translate(80, 0)" }, YT = ["fill"], UT = { transform: "translate(150, 0)" }, GT = ["fill"], XT = /* @__PURE__ */ jt({
  __name: "BoxplotChart",
  props: {
    boxplotData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    showLegend: { type: Boolean, default: !0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = re(ne(i, "theme")), r = G(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569",
      // Dots
      dotStroke: n.value ? "#1a1a1d" : "#ffffff"
    })), a = Ke({
      visible: !1,
      x: 0,
      y: 0,
      text: ""
    }), o = (d) => typeof d == "string" ? d.charAt(0).toUpperCase() + d.slice(1).toLowerCase() : d, s = (d, f) => {
      const v = d.currentTarget.closest("svg");
      if (!v) return;
      const m = v.getBoundingClientRect(), p = v.createSVGPoint();
      p.x = d.clientX - m.left, p.y = d.clientY - m.top, a.value = {
        visible: !0,
        x: p.x,
        y: p.y - 20,
        text: f
      };
    }, l = (d) => {
      if (a.value.visible) {
        const f = d.currentTarget, v = f.getBoundingClientRect(), m = f.createSVGPoint();
        m.x = d.clientX - v.left, m.y = d.clientY - v.top, a.value.x = m.x, a.value.y = m.y - 20;
      }
    }, u = () => {
      a.value.visible = !1;
    }, c = () => {
      a.value.visible = !1;
    }, h = G(() => {
      const d = [], v = i.chartHeight - i.chartMargin - i.chartBottomMargin;
      for (let m = 1; m <= 10; m++) {
        const p = m, g = (p - 1) / 9, y = i.chartMargin + v - g * v;
        d.push({ value: p, y });
      }
      return d;
    });
    return t({ isDark: n }), (d, f) => (A(), I("div", tT, [
      (A(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full boxplot-svg",
        style: or(`min-height: ${e.chartHeight}px;`),
        onMousemove: l,
        onMouseleave: u
      }, [
        a.value.visible ? (A(), I("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -(a.value.text.length * 6 + 10),
            y: -16,
            width: a.value.text.length * 12 + 20,
            height: "24",
            fill: r.value.tooltipBg,
            rx: "6",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, nT),
          x("text", {
            x: "0",
            y: "0",
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "middle"
          }, O(a.value.text), 9, rT)
        ], 8, iT)) : q("", !0),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, aT),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, oT),
        (A(!0), I(Tt, null, Zt(h.value, (v, m) => (A(), I(Tt, { key: m }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: v.y,
            x2: e.chartMargin,
            y2: v.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, sT),
          x("text", {
            x: e.chartMargin - 12,
            y: v.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, O(v.value), 9, lT)
        ], 64))), 128)),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, uT),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, cT),
        (A(!0), I(Tt, null, Zt(e.boxplotData, (v, m) => (A(), I(Tt, { key: m }, [
          x("g", {
            transform: `translate(${v.centerX}, 0)`
          }, [
            v.isTotal ? (A(), I(Tt, { key: 0 }, [
              x("line", {
                x1: 0,
                y1: v.minY,
                x2: 0,
                y2: v.q1Y,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, dT),
              x("line", {
                x1: 0,
                y1: v.q3Y,
                x2: 0,
                y2: v.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, fT),
              x("line", {
                x1: -18,
                y1: v.minY,
                x2: 18,
                y2: v.minY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, vT),
              x("line", {
                x1: -18,
                y1: v.maxY,
                x2: 18,
                y2: v.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, pT),
              x("rect", {
                x: -24,
                y: v.q3Y,
                width: "48",
                height: v.q1Y - v.q3Y,
                fill: "#8b5cf6",
                "fill-opacity": "0.15",
                stroke: "#8b5cf6",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, gT)
            ], 64)) : (A(), I(Tt, { key: 1 }, [
              x("line", {
                x1: 0,
                y1: v.minY,
                x2: 0,
                y2: v.q1Y,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, mT),
              x("line", {
                x1: 0,
                y1: v.q3Y,
                x2: 0,
                y2: v.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, yT),
              x("line", {
                x1: -18,
                y1: v.minY,
                x2: 18,
                y2: v.minY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, _T),
              x("line", {
                x1: -18,
                y1: v.maxY,
                x2: 18,
                y2: v.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, bT),
              x("rect", {
                x: -24,
                y: v.q3Y,
                width: "48",
                height: v.q1Y - v.q3Y,
                fill: "#C67DFF",
                "fill-opacity": "0.15",
                stroke: "#C67DFF",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, xT)
            ], 64)),
            x("circle", {
              cx: 0,
              cy: v.minY,
              r: "6",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => s(p, `Min: ${v.min.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, wT),
            x("circle", {
              cx: 0,
              cy: v.q1Y,
              r: "6",
              fill: "#a855f7",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => s(p, `Q1: ${v.q1.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, ST),
            x("circle", {
              cx: 0,
              cy: v.q3Y,
              r: "6",
              fill: "#7c3aed",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => s(p, `Q3: ${v.q3.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, CT),
            x("circle", {
              cx: 0,
              cy: v.maxY,
              r: "6",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => s(p, `Max: ${v.max.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, TT),
            x("line", {
              x1: -24,
              y1: v.medianY,
              x2: 24,
              y2: v.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3.5",
              class: "hover-line",
              onMouseenter: (p) => s(p, `Median: ${v.median.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, MT),
            v.averageY ? (A(), I("line", {
              key: 2,
              x1: -24,
              y1: v.averageY,
              x2: 24,
              y2: v.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (p) => s(p, `Avg: ${v.average.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, kT)) : q("", !0)
          ], 8, hT),
          x("text", {
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, O(o(v.label)), 9, DT),
          v.responseCount ? (A(), I("text", {
            key: 0,
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: r.value.tickText,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + O(v.responseCount), 9, ET)) : q("", !0)
        ], 64))), 128)),
        e.showLegend ? (A(), I("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [
          x("g", LT, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, PT),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, IT)
          ]),
          x("g", RT, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#a855f7",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, OT),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, BT)
          ]),
          x("g", NT, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#7c3aed",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, FT),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, $T)
          ]),
          x("g", zT, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, VT),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, HT)
          ]),
          x("g", WT, [
            f[0] || (f[0] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, YT)
          ]),
          x("g", UT, [
            f[1] || (f[1] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, GT)
          ])
        ], 8, AT)) : q("", !0)
      ], 44, eT))
    ]));
  }
}), jT = /* @__PURE__ */ Vt(XT, [["__scopeId", "data-v-520c623f"]]), qT = { class: "chart-container" }, ZT = ["viewBox"], KT = ["transform"], QT = ["x", "y", "width", "height", "fill", "stroke"], JT = ["y", "fill"], tM = ["y", "fill"], eM = ["x1", "y1", "x2", "y2", "stroke"], iM = ["points", "fill"], nM = ["x1", "y1", "x2", "y2", "stroke"], rM = ["x1", "y1", "x2", "y2", "stroke"], aM = ["x", "y", "fill"], oM = ["x", "y", "fill", "transform"], sM = ["x1", "y1", "x2", "y2", "stroke"], lM = ["points", "fill"], uM = ["transform"], cM = ["y1", "y2", "stroke", "onMouseenter"], hM = ["x", "y", "width", "height", "fill", "stroke", "onMouseenter"], dM = ["x1", "y1", "x2", "y2", "onMouseenter"], fM = ["x1", "y1", "x2", "y2", "onMouseenter"], vM = ["cy", "stroke", "onMouseenter"], pM = ["cy", "stroke", "onMouseenter"], gM = ["x", "y", "fill"], mM = ["x", "y", "fill"], yM = ["transform"], _M = { transform: "translate(-180, 0)" }, bM = ["stroke"], xM = ["fill"], wM = { transform: "translate(-120, 0)" }, SM = ["fill"], CM = { transform: "translate(-60, 0)" }, TM = ["fill"], MM = { transform: "translate(0, 0)" }, kM = ["stroke"], DM = ["fill"], EM = { transform: "translate(60, 0)" }, AM = ["fill"], LM = { transform: "translate(130, 0)" }, PM = ["fill"], IM = /* @__PURE__ */ jt({
  __name: "CandlestickChart",
  props: {
    candlestickData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    candleWidth: { default: 35 },
    showLegend: { type: Boolean, default: !0 },
    yAxisLabel: { default: "score" },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = re(ne(i, "theme")), r = G(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      tooltipTextSecondary: n.value ? "#d1d5db" : "#e2e8f0",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Grid
      gridLine: n.value ? "#374151" : "#e5e7eb",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569",
      // Dots
      dotStroke: n.value ? "#1a1a1d" : "#ffffff"
    })), a = Ke({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), o = (d) => typeof d == "string" ? d.charAt(0).toUpperCase() + d.slice(1).toLowerCase() : d, s = (d, f, v) => {
      const m = d.currentTarget.closest("svg");
      if (!m) return;
      const p = m.getBoundingClientRect(), g = m.createSVGPoint();
      g.x = d.clientX - p.left, g.y = d.clientY - p.top;
      let y = o(f.label), _ = "";
      switch (v) {
        case "body":
          _ = `Q1: ${f.q1.toFixed(1)} | Q3: ${f.q3.toFixed(1)}`;
          break;
        case "wick":
          _ = `Min: ${f.low.toFixed(1)} | Max: ${f.high.toFixed(1)}`;
          break;
        case "median":
          _ = `Median: ${f.median.toFixed(1)}`;
          break;
        case "average":
          _ = `Average: ${f.average?.toFixed(1)}`;
          break;
        case "min":
          _ = `Min: ${f.low.toFixed(1)}`;
          break;
        case "max":
          _ = `Max: ${f.high.toFixed(1)}`;
          break;
      }
      const b = Math.max(180, _.length * 7 + 40), w = 48;
      a.value = {
        visible: !0,
        x: g.x,
        y: g.y - 20,
        title: y,
        text: _,
        width: b,
        height: w
      };
    }, l = (d) => {
      if (a.value.visible) {
        const f = d.currentTarget, v = f.getBoundingClientRect(), m = f.createSVGPoint();
        m.x = d.clientX - v.left, m.y = d.clientY - v.top, a.value.x = m.x, a.value.y = m.y - 20;
      }
    }, u = () => {
      a.value.visible = !1;
    }, c = () => {
      a.value.visible = !1;
    }, h = G(() => {
      const d = [], v = i.chartHeight - i.chartMargin - i.chartBottomMargin;
      for (let m = 1; m <= 10; m++) {
        const p = m, g = (p - 1) / 9, y = i.chartMargin + v - g * v;
        d.push({ value: p, y });
      }
      return d;
    });
    return t({ isDark: n }), (d, f) => (A(), I("div", qT, [
      (A(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full candlestick-svg",
        style: or(`min-height: ${e.chartHeight}px;`),
        onMousemove: l,
        onMouseleave: u
      }, [
        a.value.visible ? (A(), I("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -a.value.width / 2,
            y: -a.value.height - 10,
            width: a.value.width,
            height: a.value.height,
            fill: r.value.tooltipBg,
            rx: "8",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, QT),
          x("text", {
            x: "0",
            y: -a.value.height + 8,
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, O(a.value.title), 9, JT),
          x("text", {
            x: "0",
            y: -a.value.height + 26,
            "text-anchor": "middle",
            fill: r.value.tooltipTextSecondary,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, O(a.value.text), 9, tM)
        ], 8, KT)) : q("", !0),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, eM),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, iM),
        (A(!0), I(Tt, null, Zt(h.value, (v, m) => (A(), I("line", {
          key: `grid-${m}`,
          x1: e.chartMargin,
          y1: v.y,
          x2: e.chartWidth - e.chartMargin,
          y2: v.y,
          stroke: r.value.gridLine,
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, nM))), 128)),
        (A(!0), I(Tt, null, Zt(h.value, (v, m) => (A(), I(Tt, { key: m }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: v.y,
            x2: e.chartMargin,
            y2: v.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, rM),
          x("text", {
            x: e.chartMargin - 12,
            y: v.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, O(v.value), 9, aM)
        ], 64))), 128)),
        x("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, O(o(e.yAxisLabel)), 9, oM),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, sM),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, lM),
        (A(!0), I(Tt, null, Zt(e.candlestickData, (v, m) => (A(), I(Tt, { key: m }, [
          x("g", {
            transform: `translate(${v.centerX}, 0)`
          }, [
            x("line", {
              x1: 0,
              y1: v.highY,
              x2: 0,
              y2: v.lowY,
              stroke: v.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              class: "hover-line",
              onMouseenter: (p) => s(p, v, "wick"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, cM),
            x("rect", {
              x: -e.candleWidth / 2,
              y: Math.min(v.q1Y, v.q3Y),
              width: e.candleWidth,
              height: Math.abs(v.q3Y - v.q1Y),
              fill: v.isTotal ? "rgba(139, 92, 246, 0.15)" : "rgba(198, 125, 255, 0.15)",
              stroke: v.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              rx: "4",
              class: "hover-rect",
              onMouseenter: (p) => s(p, v, "body"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, hM),
            v.medianY ? (A(), I("line", {
              key: 0,
              x1: -e.candleWidth / 2,
              y1: v.medianY,
              x2: e.candleWidth / 2,
              y2: v.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3",
              class: "hover-line",
              onMouseenter: (p) => s(p, v, "median"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, dM)) : q("", !0),
            v.averageY ? (A(), I("line", {
              key: 1,
              x1: -e.candleWidth / 2,
              y1: v.averageY,
              x2: e.candleWidth / 2,
              y2: v.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (p) => s(p, v, "average"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, fM)) : q("", !0),
            x("circle", {
              cx: 0,
              cy: v.lowY,
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => s(p, v, "min"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, vM),
            x("circle", {
              cx: 0,
              cy: v.highY,
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => s(p, v, "max"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, pM)
          ], 8, uM),
          x("text", {
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, O(o(v.label)), 9, gM),
          v.responseCount ? (A(), I("text", {
            key: 0,
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: r.value.tickText,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + O(v.responseCount), 9, mM)) : q("", !0)
        ], 64))), 128)),
        e.showLegend ? (A(), I("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [
          x("g", _M, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, bM),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, xM)
          ]),
          x("g", wM, [
            f[0] || (f[0] = x("rect", {
              x: "-6",
              y: "-6",
              width: "12",
              height: "12",
              fill: "rgba(198, 125, 255, 0.15)",
              stroke: "#C67DFF",
              "stroke-width": "1.5",
              rx: "2"
            }, null, -1)),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, SM)
          ]),
          x("g", CM, [
            f[1] || (f[1] = x("rect", {
              x: "-6",
              y: "-6",
              width: "12",
              height: "12",
              fill: "rgba(198, 125, 255, 0.15)",
              stroke: "#C67DFF",
              "stroke-width": "1.5",
              rx: "2"
            }, null, -1)),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, TM)
          ]),
          x("g", MM, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, kM),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, DM)
          ]),
          x("g", EM, [
            f[2] || (f[2] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, AM)
          ]),
          x("g", LM, [
            f[3] || (f[3] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, PM)
          ])
        ], 8, yM)) : q("", !0)
      ], 44, ZT))
    ]));
  }
}), Oy = /* @__PURE__ */ Vt(IM, [["__scopeId", "data-v-0ecc8ae0"]]), RM = { class: "chart-container" }, OM = ["viewBox"], BM = ["transform"], NM = ["x", "y", "width", "height", "fill", "stroke"], FM = ["y", "fill"], $M = ["y", "fill"], zM = ["x1", "y1", "x2", "y2", "stroke"], VM = ["x1", "y1", "x2", "y2", "stroke"], HM = ["points", "fill"], WM = ["x1", "y1", "x2", "y2", "stroke"], YM = ["x", "y", "fill"], UM = ["x", "y", "fill", "transform"], GM = ["x1", "y1", "x2", "y2", "stroke"], XM = ["points", "fill"], jM = ["x1", "y1", "x2", "y2", "stroke"], qM = ["x", "y", "fill"], ZM = ["x", "y", "fill"], KM = ["d"], QM = ["x", "y", "width", "height", "onMouseenter"], JM = ["x1", "y1", "x2", "y2"], tk = ["x", "y"], ek = ["x1", "y1", "x2", "y2"], ik = ["x", "y"], nk = ["x1", "y1", "x2", "y2"], rk = ["x", "y"], ak = ["x1", "y1", "x2", "y2"], ok = ["x", "y"], sk = ["x1", "y1", "x2", "y2"], lk = ["x", "y"], uk = ["x1", "y1", "x2", "y2"], ck = ["x", "y"], hk = ["transform"], dk = { transform: "translate(-220, 0)" }, fk = ["fill"], vk = { transform: "translate(-140, 0)" }, pk = ["fill"], gk = { transform: "translate(-80, 0)" }, mk = ["fill"], yk = { transform: "translate(-20, 0)" }, _k = ["fill"], bk = { transform: "translate(60, 0)" }, xk = ["fill"], wk = { transform: "translate(130, 0)" }, Sk = ["fill"], Ck = { transform: "translate(180, 0)" }, Tk = ["fill"], Mk = /* @__PURE__ */ jt({
  __name: "HistogramChart",
  props: {
    histogram: { default: () => [] },
    minScore: { default: 0 },
    maxScore: { default: 0 },
    q1Score: { default: 0 },
    medianScore: { default: 0 },
    q3Score: { default: 0 },
    averageScore: { default: 0 },
    chartWidth: { default: 800 },
    chartHeight: { default: 450 },
    chartMargin: { default: 60 },
    chartBottomMargin: { default: 80 },
    showLegend: { type: Boolean, default: !0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = re(ne(i, "theme")), r = G(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      tooltipTextSecondary: n.value ? "#d1d5db" : "#e2e8f0",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Grid
      gridLine: n.value ? "#374151" : "#e5e7eb",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569"
    })), a = Ke({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), o = G(() => i.chartWidth - i.chartMargin * 2), s = G(() => i.chartHeight - i.chartMargin - i.chartBottomMargin), l = G(() => o.value / 10 * 0.6), u = G(() => !i.histogram || i.histogram.length === 0 ? 1 : Math.max(...i.histogram.map((N) => N.count || 0), 1) + 30), c = G(() => {
      if (!i.histogram || i.histogram.length === 0) return 1;
      const z = i.averageScore || 0;
      let N = 0, $ = 0;
      if (i.histogram.forEach((U) => {
        const Q = U.count || 0;
        N += Q;
        const it = U.score - z;
        $ += Q * (it * it);
      }), N === 0) return 1;
      const X = $ / N;
      return Math.sqrt(X) || 1;
    }), h = (z, N, $) => {
      if ($ === 0) return 0;
      const X = 1 / ($ * Math.sqrt(2 * Math.PI)), U = -0.5 * Math.pow((z - N) / $, 2);
      return X * Math.exp(U);
    }, d = G(() => {
      if (!i.histogram || i.histogram.length === 0 || i.averageScore === 0 && c.value === 0) return null;
      const z = i.averageScore, N = c.value, $ = [], X = 100, U = 1, Q = 10, it = i.histogram.reduce((xt, Mt) => xt + (Mt.count || 0), 0);
      if (it === 0) return null;
      let ft = 0;
      for (let xt = 0; xt <= X; xt++) {
        const Mt = U + (Q - U) * (xt / X), et = h(Mt, z, N);
        et > ft && (ft = et);
      }
      const ie = s.value * 0.75 / ft * it * 6e-3, ve = i.chartMargin;
      for (let xt = 0; xt <= X; xt++) {
        const Mt = U + (Q - U) * (xt / X), lt = h(Mt, z, N) * ie, hi = v(Mt);
        if (hi !== null) {
          let qt = i.chartHeight - i.chartBottomMargin - lt;
          qt = Math.max(qt, ve), $.push(`${xt === 0 ? "M" : "L"} ${hi} ${qt}`);
        }
      }
      return $.join(" ");
    }), f = G(() => {
      if (!i.histogram || i.histogram.length === 0) return [];
      const z = o.value / 10;
      return i.histogram.map((N, $) => {
        const X = i.chartMargin + ($ + 0.5) * z, U = N.count > 0 ? N.count / u.value * s.value : 0, Q = i.chartHeight - i.chartBottomMargin - U;
        return {
          score: N.score,
          count: N.count,
          x: X,
          y: Q,
          height: U
        };
      });
    }), v = (z) => {
      if (z < 1 || z > 10) return null;
      const N = o.value / 10;
      return i.chartMargin + (z - 0.5) * N;
    }, m = G(() => v(i.minScore)), p = G(() => v(i.maxScore)), g = G(() => v(i.q1Score)), y = G(() => v(i.medianScore)), _ = G(() => v(i.q3Score)), b = G(() => v(i.averageScore)), w = G(() => i.minScore), S = G(() => i.maxScore), C = G(() => i.q1Score), T = G(() => i.medianScore), k = G(() => i.q3Score), M = G(() => i.averageScore), D = G(() => {
      const z = [], N = i.chartMargin - 8, $ = 18;
      g.value !== null && z.push({
        x: g.value,
        y: N,
        value: i.q1Score,
        label: `Q1: ${C.value.toFixed(1)}`,
        color: "#a855f7",
        id: "q1",
        width: 55
      }), y.value !== null && z.push({
        x: y.value,
        y: N - $,
        value: i.medianScore,
        label: `Median: ${T.value.toFixed(1)}`,
        color: "#8b5cf6",
        id: "median",
        width: 90
      }), b.value !== null && z.push({
        x: b.value,
        y: N - $,
        value: i.averageScore,
        label: `Avg: ${M.value.toFixed(1)}`,
        color: "#f97316",
        id: "avg",
        width: 65
      }), _.value !== null && z.push({
        x: _.value,
        y: N,
        value: i.q3Score,
        label: `Q3: ${k.value.toFixed(1)}`,
        color: "#7c3aed",
        id: "q3",
        width: 55
      }), z.sort((Q, it) => (Q.x || 0) - (it.x || 0));
      const X = [[], [], []];
      z.forEach((Q) => {
        if (Q.x === null) return;
        let it = -1;
        for (let ft = 0; ft < X.length; ft++) {
          let yt = !1;
          for (const ie of X[ft]) {
            if (ie.x === null) continue;
            const ve = Math.abs(Q.x - ie.x), xt = (Q.width + ie.width) / 2 + 10;
            if (ve < xt) {
              yt = !0;
              break;
            }
          }
          if (!yt) {
            it = ft;
            break;
          }
        }
        it === -1 && (it = X.length - 1), Q.y = N - it * $, X[it].push(Q);
      });
      const U = 15;
      return z.forEach((Q) => {
        Q.y < U && (Q.y = U);
      }), z;
    }), L = (z) => D.value.find(($) => $.id === z)?.y || i.chartMargin - 10, P = G(() => {
      const z = [];
      for (let $ = 0; $ <= 5; $++) {
        const X = Math.round(u.value / 5 * $), U = i.chartHeight - i.chartBottomMargin - $ / 5 * s.value;
        z.push({ value: X, y: U });
      }
      return z;
    }), R = (z, N) => {
      const $ = z.currentTarget.closest("svg");
      if (!$) return;
      const X = $.getBoundingClientRect(), U = $.createSVGPoint();
      U.x = z.clientX - X.left, U.y = z.clientY - X.top;
      const Q = `Score: ${N.score}`, it = `Count: ${N.count}`, ft = 120, yt = 48;
      a.value = {
        visible: !0,
        x: U.x,
        y: U.y - 20,
        title: Q,
        text: it,
        width: ft,
        height: yt
      };
    }, B = (z) => {
      if (a.value.visible) {
        const N = z.currentTarget, $ = N.getBoundingClientRect(), X = N.createSVGPoint();
        X.x = z.clientX - $.left, X.y = z.clientY - $.top, a.value.x = X.x, a.value.y = X.y - 20;
      }
    }, F = () => {
      a.value.visible = !1;
    }, W = () => {
      a.value.visible = !1;
    };
    return t({ isDark: n }), (z, N) => (A(), I("div", RM, [
      (A(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full histogram-svg",
        style: or(`min-height: ${e.chartHeight}px;`),
        onMousemove: B,
        onMouseleave: F
      }, [
        a.value.visible ? (A(), I("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -a.value.width / 2,
            y: -a.value.height - 10,
            width: a.value.width,
            height: a.value.height,
            fill: r.value.tooltipBg,
            rx: "8",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, NM),
          x("text", {
            x: "0",
            y: -a.value.height + 8,
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, O(a.value.title), 9, FM),
          x("text", {
            x: "0",
            y: -a.value.height + 26,
            "text-anchor": "middle",
            fill: r.value.tooltipTextSecondary,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, O(a.value.text), 9, $M)
        ], 8, BM)) : q("", !0),
        (A(!0), I(Tt, null, Zt(P.value, ($, X) => (A(), I("line", {
          key: `grid-${X}`,
          x1: e.chartMargin,
          y1: $.y,
          x2: e.chartWidth - e.chartMargin,
          y2: $.y,
          stroke: r.value.gridLine,
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, zM))), 128)),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, VM),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, HM),
        (A(!0), I(Tt, null, Zt(P.value, ($, X) => (A(), I(Tt, {
          key: `y-tick-${X}`
        }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: $.y,
            x2: e.chartMargin,
            y2: $.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, WM),
          x("text", {
            x: e.chartMargin - 12,
            y: $.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, O($.value), 9, YM)
        ], 64))), 128)),
        x("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, " Count ", 8, UM),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, GM),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, XM),
        (A(!0), I(Tt, null, Zt(f.value, ($, X) => (A(), I(Tt, {
          key: `tick-${X}`
        }, [
          x("line", {
            x1: $.x,
            y1: e.chartHeight - e.chartBottomMargin,
            x2: $.x,
            y2: e.chartHeight - e.chartBottomMargin + 5,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, jM),
          x("text", {
            x: $.x,
            y: e.chartHeight - e.chartBottomMargin + 20,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, O($.score), 9, qM)
        ], 64))), 128)),
        x("text", {
          x: e.chartWidth / 2,
          y: e.chartHeight - e.chartBottomMargin + 40,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Score ", 8, ZM),
        d.value ? (A(), I("path", {
          key: 1,
          d: d.value,
          fill: "none",
          stroke: "#8b5cf6",
          "stroke-width": "2.5",
          opacity: "0.7",
          class: "gaussian-curve"
        }, null, 8, KM)) : q("", !0),
        (A(!0), I(Tt, null, Zt(f.value, ($, X) => (A(), I("rect", {
          key: `bar-${X}`,
          x: $.x - l.value / 2,
          y: $.y,
          width: l.value,
          height: $.height,
          fill: "rgba(198, 125, 255, 0.6)",
          stroke: "#C67DFF",
          "stroke-width": "2",
          rx: "4",
          class: "histogram-bar",
          onMouseenter: (U) => R(U, $),
          onMouseleave: W,
          style: { cursor: "pointer" }
        }, null, 40, QM))), 128)),
        m.value ? (A(), I("line", {
          key: 2,
          x1: m.value,
          y1: e.chartMargin,
          x2: m.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#5d4b93",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, JM)) : q("", !0),
        m.value ? (A(), I("text", {
          key: 3,
          x: m.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#5d4b93",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Min: " + O(w.value.toFixed(1)), 9, tk)) : q("", !0),
        g.value ? (A(), I("line", {
          key: 4,
          x1: g.value,
          y1: e.chartMargin,
          x2: g.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#a855f7",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, ek)) : q("", !0),
        g.value ? (A(), I("text", {
          key: 5,
          x: g.value,
          y: L("q1"),
          "text-anchor": "middle",
          fill: "#a855f7",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q1: " + O(C.value.toFixed(1)), 9, ik)) : q("", !0),
        y.value ? (A(), I("line", {
          key: 6,
          x1: y.value,
          y1: e.chartMargin,
          x2: y.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#8b5cf6",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, nk)) : q("", !0),
        y.value ? (A(), I("text", {
          key: 7,
          x: y.value,
          y: L("median"),
          "text-anchor": "middle",
          fill: "#8b5cf6",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Median: " + O(T.value.toFixed(1)), 9, rk)) : q("", !0),
        b.value ? (A(), I("line", {
          key: 8,
          x1: b.value,
          y1: e.chartMargin,
          x2: b.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#f97316",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, ak)) : q("", !0),
        b.value ? (A(), I("text", {
          key: 9,
          x: b.value,
          y: L("avg"),
          "text-anchor": "middle",
          fill: "#f97316",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Avg: " + O(M.value.toFixed(1)), 9, ok)) : q("", !0),
        _.value ? (A(), I("line", {
          key: 10,
          x1: _.value,
          y1: e.chartMargin,
          x2: _.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#7c3aed",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, sk)) : q("", !0),
        _.value ? (A(), I("text", {
          key: 11,
          x: _.value,
          y: L("q3"),
          "text-anchor": "middle",
          fill: "#7c3aed",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q3: " + O(k.value.toFixed(1)), 9, lk)) : q("", !0),
        p.value ? (A(), I("line", {
          key: 12,
          x1: p.value,
          y1: e.chartMargin,
          x2: p.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#C67DFF",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, uk)) : q("", !0),
        p.value ? (A(), I("text", {
          key: 13,
          x: p.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#C67DFF",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Max: " + O(S.value.toFixed(1)), 9, ck)) : q("", !0),
        e.showLegend ? (A(), I("g", {
          key: 14,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 50})`
        }, [
          x("g", dk, [
            N[0] || (N[0] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Gaussian ", 8, fk)
          ]),
          x("g", vk, [
            N[1] || (N[1] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#5d4b93",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, pk)
          ]),
          x("g", gk, [
            N[2] || (N[2] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#a855f7",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, mk)
          ]),
          x("g", yk, [
            N[3] || (N[3] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "3",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, _k)
          ]),
          x("g", bk, [
            N[4] || (N[4] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, xk)
          ]),
          x("g", wk, [
            N[5] || (N[5] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#7c3aed",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, Sk)
          ]),
          x("g", Ck, [
            N[6] || (N[6] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#C67DFF",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, Tk)
          ])
        ], 8, hk)) : q("", !0)
      ], 44, OM))
    ]));
  }
}), By = /* @__PURE__ */ Vt(Mk, [["__scopeId", "data-v-e67a4773"]]);
var ch = function(e, t) {
  return ch = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, ch(e, t);
};
function Xt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  ch(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
var kk = /* @__PURE__ */ (function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
})(), Dk = /* @__PURE__ */ (function() {
  function e() {
    this.browser = new kk(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
})(), nt = new Dk();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (nt.wxa = !0, nt.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? nt.worker = !0 : !nt.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (nt.node = !0, nt.svgSupported = !0) : Ek(navigator.userAgent, nt);
function Ek(e, t) {
  var i = t.browser, n = e.match(/Firefox\/([\d.]+)/), r = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), a = e.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(e);
  n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1], i.newEdge = +a[1].split(".")[0] > 18), o && (i.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !i.ie && !i.edge, t.pointerEventsSupported = "onpointerdown" in window && (i.edge || i.ie && +i.version >= 11);
  var s = t.domSupported = typeof document < "u";
  if (s) {
    var l = document.documentElement.style;
    t.transform3dSupported = (i.ie && "transition" in l || i.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || i.ie && +i.version >= 9;
  }
}
var Ld = 12, Ak = "sans-serif", gn = Ld + "px " + Ak, Lk = 20, Pk = 100, Ik = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function Rk(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var i = 0; i < e.length; i++) {
    var n = String.fromCharCode(i + 32), r = (e.charCodeAt(i) - Lk) / Pk;
    t[n] = r;
  }
  return t;
}
var Ok = Rk(Ik), Ui = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ (function() {
    var e, t;
    return function(i, n) {
      if (!e) {
        var r = Ui.createCanvas();
        e = r && r.getContext("2d");
      }
      if (e)
        return t !== n && (t = e.font = n || gn), e.measureText(i);
      i = i || "", n = n || gn;
      var a = /((?:\d+)?\.?\d*)px/.exec(n), o = a && +a[1] || Ld, s = 0;
      if (n.indexOf("mono") >= 0)
        s = o * i.length;
      else
        for (var l = 0; l < i.length; l++) {
          var u = Ok[i[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  })(),
  loadImage: function(e, t, i) {
    var n = new Image();
    return n.onload = t, n.onerror = i, n.src = e, n;
  }
}, Ny = _a([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), Fy = _a([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), ya = Object.prototype.toString, ru = Array.prototype, Bk = ru.forEach, Nk = ru.filter, Pd = ru.slice, Fk = ru.map, lp = (function() {
}).constructor, ss = lp ? lp.prototype : null, Id = "__proto__", $k = 2311;
function $y() {
  return $k++;
}
function lr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function ct(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, i = ya.call(e);
  if (i === "[object Array]") {
    if (!ho(e)) {
      t = [];
      for (var n = 0, r = e.length; n < r; n++)
        t[n] = ct(e[n]);
    }
  } else if (Fy[i]) {
    if (!ho(e)) {
      var a = e.constructor;
      if (a.from)
        t = a.from(e);
      else {
        t = new a(e.length);
        for (var n = 0, r = e.length; n < r; n++)
          t[n] = e[n];
      }
    }
  } else if (!Ny[i] && !ho(e) && !ca(e)) {
    t = {};
    for (var o in e)
      e.hasOwnProperty(o) && o !== Id && (t[o] = ct(e[o]));
  }
  return t;
}
function Gt(e, t, i) {
  if (!Z(t) || !Z(e))
    return i ? ct(t) : e;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== Id) {
      var r = e[n], a = t[n];
      Z(a) && Z(r) && !j(a) && !j(r) && !ca(a) && !ca(r) && !up(a) && !up(r) && !ho(a) && !ho(r) ? Gt(r, a, i) : (i || !(n in e)) && (e[n] = ct(t[n]));
    }
  return e;
}
function V(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var i in t)
      t.hasOwnProperty(i) && i !== Id && (e[i] = t[i]);
  return e;
}
function zt(e, t, i) {
  for (var n = Bt(t), r = 0, a = n.length; r < a; r++) {
    var o = n[r];
    e[o] == null && (e[o] = t[o]);
  }
  return e;
}
function Pt(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var i = 0, n = e.length; i < n; i++)
      if (e[i] === t)
        return i;
  }
  return -1;
}
function zk(e, t) {
  var i = e.prototype;
  function n() {
  }
  n.prototype = t.prototype, e.prototype = new n();
  for (var r in i)
    i.hasOwnProperty(r) && (e.prototype[r] = i[r]);
  e.prototype.constructor = e, e.superClass = t;
}
function si(e, t, i) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), r = 0; r < n.length; r++) {
      var a = n[r];
      a !== "constructor" && e[a] == null && (e[a] = t[a]);
    }
  else
    zt(e, t);
}
function Ae(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function E(e, t, i) {
  if (e && t)
    if (e.forEach && e.forEach === Bk)
      e.forEach(t, i);
    else if (e.length === +e.length)
      for (var n = 0, r = e.length; n < r; n++)
        t.call(i, e[n], n, e);
    else
      for (var a in e)
        e.hasOwnProperty(a) && t.call(i, e[a], a, e);
}
function dt(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return Rd(e);
  if (e.map && e.map === Fk)
    return e.map(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    n.push(t.call(i, e[r], r, e));
  return n;
}
function _a(e, t, i, n) {
  if (e && t) {
    for (var r = 0, a = e.length; r < a; r++)
      i = t.call(n, i, e[r], r, e);
    return i;
  }
}
function Re(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return Rd(e);
  if (e.filter && e.filter === Nk)
    return e.filter(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    t.call(i, e[r], r, e) && n.push(e[r]);
  return n;
}
function Bt(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var i in e)
    e.hasOwnProperty(i) && t.push(i);
  return t;
}
function Vk(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return function() {
    return e.apply(t, i.concat(Pd.call(arguments)));
  };
}
var mt = ss && ht(ss.bind) ? ss.call.bind(ss.bind) : Vk;
function me(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return function() {
    return e.apply(this, t.concat(Pd.call(arguments)));
  };
}
function j(e) {
  return Array.isArray ? Array.isArray(e) : ya.call(e) === "[object Array]";
}
function ht(e) {
  return typeof e == "function";
}
function K(e) {
  return typeof e == "string";
}
function dl(e) {
  return ya.call(e) === "[object String]";
}
function Nt(e) {
  return typeof e == "number";
}
function Z(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function up(e) {
  return !!Ny[ya.call(e)];
}
function be(e) {
  return !!Fy[ya.call(e)];
}
function ca(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function au(e) {
  return e.colorStops != null;
}
function Hk(e) {
  return e.image != null;
}
function Wk(e) {
  return ya.call(e) === "[object RegExp]";
}
function zy(e) {
  return e !== e;
}
function mn() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var i = 0, n = e.length; i < n; i++)
    if (e[i] != null)
      return e[i];
}
function tt(e, t) {
  return e ?? t;
}
function ur(e, t, i) {
  return e ?? t ?? i;
}
function Rd(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return Pd.apply(e, t);
}
function Od(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function J(e, t) {
  if (!e)
    throw new Error(t);
}
function xi(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var Vy = "__ec_primitive__";
function hh(e) {
  e[Vy] = !0;
}
function ho(e) {
  return e[Vy];
}
var Yk = (function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var i = this.has(t);
    return i && delete this.data[t], i;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, i) {
    return this.data[t] = i, this;
  }, e.prototype.keys = function() {
    return Bt(this.data);
  }, e.prototype.forEach = function(t) {
    var i = this.data;
    for (var n in i)
      i.hasOwnProperty(n) && t(i[n], n);
  }, e;
})(), Hy = typeof Map == "function";
function Uk() {
  return Hy ? /* @__PURE__ */ new Map() : new Yk();
}
var Gk = (function() {
  function e(t) {
    var i = j(t);
    this.data = Uk();
    var n = this;
    t instanceof e ? t.each(r) : t && E(t, r);
    function r(a, o) {
      i ? n.set(a, o) : n.set(o, a);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, i) {
    return this.data.set(t, i), i;
  }, e.prototype.each = function(t, i) {
    this.data.forEach(function(n, r) {
      t.call(i, n, r);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return Hy ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
})();
function ot(e) {
  return new Gk(e);
}
function Xk(e, t) {
  for (var i = new e.constructor(e.length + t.length), n = 0; n < e.length; n++)
    i[n] = e[n];
  for (var r = e.length, n = 0; n < t.length; n++)
    i[n + r] = t[n];
  return i;
}
function ou(e, t) {
  var i;
  if (Object.create)
    i = Object.create(e);
  else {
    var n = function() {
    };
    n.prototype = e, i = new n();
  }
  return t && V(i, t), i;
}
function Wy(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function Ci(e, t) {
  return e.hasOwnProperty(t);
}
function ce() {
}
var jk = 180 / Math.PI;
var dh = function(e, t) {
  return dh = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, dh(e, t);
};
function St(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  dh(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
function ba(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function qk(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function Zk(e) {
  return [e[0], e[1]];
}
function cp(e, t, i) {
  return e[0] = t[0] + i[0], e[1] = t[1] + i[1], e;
}
function Kk(e, t, i) {
  return e[0] = t[0] - i[0], e[1] = t[1] - i[1], e;
}
function Qk(e) {
  return Math.sqrt(Jk(e));
}
function Jk(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function Nu(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e;
}
function tD(e, t) {
  var i = Qk(t);
  return i === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / i, e[1] = t[1] / i), e;
}
function fh(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var eD = fh;
function iD(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var na = iD;
function Be(e, t, i) {
  var n = t[0], r = t[1];
  return e[0] = i[0] * n + i[2] * r + i[4], e[1] = i[1] * n + i[3] * r + i[5], e;
}
function qr(e, t, i) {
  return e[0] = Math.min(t[0], i[0]), e[1] = Math.min(t[1], i[1]), e;
}
function Zr(e, t, i) {
  return e[0] = Math.max(t[0], i[0]), e[1] = Math.max(t[1], i[1]), e;
}
var Ar = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.target = t, this.topTarget = i && i.topTarget;
  }
  return e;
})(), nD = (function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var i = t.target; i && !i.draggable; )
      i = i.parent || i.__hostTarget;
    i && (this._draggingTarget = i, i.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new Ar(i, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var i = this._draggingTarget;
    if (i) {
      var n = t.offsetX, r = t.offsetY, a = n - this._x, o = r - this._y;
      this._x = n, this._y = r, i.drift(a, o, t), this.handler.dispatchToElement(new Ar(i, t), "drag", t.event);
      var s = this.handler.findHover(n, r, i).target, l = this._dropTarget;
      this._dropTarget = s, i !== s && (l && s !== l && this.handler.dispatchToElement(new Ar(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new Ar(s, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var i = this._draggingTarget;
    i && (i.dragging = !1), this.handler.dispatchToElement(new Ar(i, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new Ar(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
})(), li = (function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, i, n, r) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof i == "function" && (r = n, n = i, i = null), !n || !t)
      return this;
    var o = this._$eventProcessor;
    i != null && o && o.normalizeQuery && (i = o.normalizeQuery(i)), a[t] || (a[t] = []);
    for (var s = 0; s < a[t].length; s++)
      if (a[t][s].h === n)
        return this;
    var l = {
      h: n,
      query: i,
      ctx: r || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var i = this._$handlers;
    return !i || !i[t] || !i[t].length;
  }, e.prototype.off = function(t, i) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (i) {
      if (n[t]) {
        for (var r = [], a = 0, o = n[t].length; a < o; a++)
          n[t][a].h !== i && r.push(n[t][a]);
        n[t] = r;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var o = i.length, s = r.length, l = 0; l < s; l++) {
        var u = r[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, i[0]);
              break;
            case 2:
              u.h.call(u.ctx, i[0], i[1]);
              break;
            default:
              u.h.apply(u.ctx, i);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var o = i.length, s = i[o - 1], l = r.length, u = 0; u < l; u++) {
        var c = r[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (o) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, i[0]);
              break;
            case 2:
              c.h.call(s, i[0], i[1]);
              break;
            default:
              c.h.apply(s, i.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e;
})(), rD = Math.log(2);
function vh(e, t, i, n, r, a) {
  var o = n + "-" + r, s = e.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (t === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~r) / rD);
    return e[i][l];
  }
  for (var u = n | 1 << i, c = i + 1; n & 1 << c; )
    c++;
  for (var h = 0, d = 0, f = 0; d < s; d++) {
    var v = 1 << d;
    v & r || (h += (f % 2 ? -1 : 1) * e[i][d] * vh(e, t - 1, c, u, r | v, a), f++);
  }
  return a[o] = h, h;
}
function hp(e, t) {
  var i = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], n = {}, r = vh(i, 8, 0, 0, 0, n);
  if (r !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * vh(i, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, n) / r * t[o];
    return function(l, u, c) {
      var h = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
    };
  }
}
var fl = "___zrEVENTSAVED", Fu = [];
function aD(e, t, i, n, r) {
  return ph(Fu, t, n, r, !0) && ph(e, i, Fu[0], Fu[1]);
}
function oD(e, t) {
  e && i(e), t && i(t);
  function i(n) {
    var r = n[fl];
    r && (r.clearMarkers && r.clearMarkers(), delete n[fl]);
  }
}
function ph(e, t, i, n, r) {
  if (t.getBoundingClientRect && nt.domSupported && !Yy(t)) {
    var a = t[fl] || (t[fl] = {}), o = sD(t, a), s = lD(o, a, r);
    if (s)
      return s(e, i, n), !0;
  }
  return !1;
}
function sD(e, t) {
  var i = t.markers;
  if (i)
    return i;
  i = t.markers = [];
  for (var n = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      r[u] + ":0",
      n[1 - l] + ":auto",
      r[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(o), i.push(o);
  }
  return t.clearMarkers = function() {
    E(i, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, i;
}
function lD(e, t, i) {
  for (var n = i ? "invTrans" : "trans", r = t[n], a = t.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), h = 2 * u, d = c.left, f = c.top;
    o.push(d, f), l = l && a && d === a[h] && f === a[h + 1], s.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && r ? r : (t.srcCoords = o, t[n] = i ? hp(s, o) : hp(o, s));
}
function Yy(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var uD = /([&<>"'])/g, cD = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Ce(e) {
  return e == null ? "" : (e + "").replace(uD, function(t, i) {
    return cD[i];
  });
}
var hD = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, $u = [], dD = nt.browser.firefox && +nt.browser.version.split(".")[0] < 39;
function gh(e, t, i, n) {
  return i = i || {}, n ? dp(e, t, i) : dD && t.layerX != null && t.layerX !== t.offsetX ? (i.zrX = t.layerX, i.zrY = t.layerY) : t.offsetX != null ? (i.zrX = t.offsetX, i.zrY = t.offsetY) : dp(e, t, i), i;
}
function dp(e, t, i) {
  if (nt.domSupported && e.getBoundingClientRect) {
    var n = t.clientX, r = t.clientY;
    if (Yy(e)) {
      var a = e.getBoundingClientRect();
      i.zrX = n - a.left, i.zrY = r - a.top;
      return;
    } else if (ph($u, e, n, r)) {
      i.zrX = $u[0], i.zrY = $u[1];
      return;
    }
  }
  i.zrX = i.zrY = 0;
}
function Bd(e) {
  return e || window.event;
}
function We(e, t, i) {
  if (t = Bd(t), t.zrX != null)
    return t;
  var n = t.type, r = n && n.indexOf("touch") >= 0;
  if (r) {
    var o = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    o && gh(e, o, t, i);
  } else {
    gh(e, t, t, i);
    var a = fD(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var s = t.button;
  return t.which == null && s !== void 0 && hD.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
}
function fD(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var i = e.deltaX, n = e.deltaY;
  if (i == null || n == null)
    return t;
  var r = Math.abs(n !== 0 ? n : i), a = n > 0 ? -1 : n < 0 ? 1 : i > 0 ? -1 : 1;
  return 3 * r * a;
}
function vD(e, t, i, n) {
  e.addEventListener(t, i, n);
}
function pD(e, t, i, n) {
  e.removeEventListener(t, i, n);
}
var vl = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function fp(e) {
  return e.which === 2 || e.which === 3;
}
var gD = (function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, i, n) {
    return this._doTrack(t, i, n), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, i, n) {
    var r = t.touches;
    if (r) {
      for (var a = {
        points: [],
        touches: [],
        target: i,
        event: t
      }, o = 0, s = r.length; o < s; o++) {
        var l = r[o], u = gh(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, e.prototype._recognize = function(t) {
    for (var i in zu)
      if (zu.hasOwnProperty(i)) {
        var n = zu[i](this._track, t);
        if (n)
          return n;
      }
  }, e;
})();
function vp(e) {
  var t = e[1][0] - e[0][0], i = e[1][1] - e[0][1];
  return Math.sqrt(t * t + i * i);
}
function mD(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var zu = {
  pinch: function(e, t) {
    var i = e.length;
    if (i) {
      var n = (e[i - 1] || {}).points, r = (e[i - 2] || {}).points || n;
      if (r && r.length > 1 && n && n.length > 1) {
        var a = vp(n) / vp(r);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var o = mD(n);
        return t.pinchX = o[0], t.pinchY = o[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function Ti() {
  return [1, 0, 0, 1, 0, 0];
}
function Nd(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function Fd(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function fo(e, t, i) {
  var n = t[0] * i[0] + t[2] * i[1], r = t[1] * i[0] + t[3] * i[1], a = t[0] * i[2] + t[2] * i[3], o = t[1] * i[2] + t[3] * i[3], s = t[0] * i[4] + t[2] * i[5] + t[4], l = t[1] * i[4] + t[3] * i[5] + t[5];
  return e[0] = n, e[1] = r, e[2] = a, e[3] = o, e[4] = s, e[5] = l, e;
}
function mh(e, t, i) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + i[0], e[5] = t[5] + i[1], e;
}
function $d(e, t, i, n) {
  n === void 0 && (n = [0, 0]);
  var r = t[0], a = t[2], o = t[4], s = t[1], l = t[3], u = t[5], c = Math.sin(i), h = Math.cos(i);
  return e[0] = r * h + s * c, e[1] = -r * c + s * h, e[2] = a * h + l * c, e[3] = -a * c + h * l, e[4] = h * (o - n[0]) + c * (u - n[1]) + n[0], e[5] = h * (u - n[1]) - c * (o - n[0]) + n[1], e;
}
function yD(e, t, i) {
  var n = i[0], r = i[1];
  return e[0] = t[0] * n, e[1] = t[1] * r, e[2] = t[2] * n, e[3] = t[3] * r, e[4] = t[4] * n, e[5] = t[5] * r, e;
}
function Wo(e, t) {
  var i = t[0], n = t[2], r = t[4], a = t[1], o = t[3], s = t[5], l = i * o - a * n;
  return l ? (l = 1 / l, e[0] = o * l, e[1] = -a * l, e[2] = -n * l, e[3] = i * l, e[4] = (n * s - o * r) * l, e[5] = (a * r - i * s) * l, e) : null;
}
var Ct = (function() {
  function e(t, i) {
    this.x = t || 0, this.y = i || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, i) {
    return this.x = t, this.y = i, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, i) {
    this.x += t.x * i, this.y += t.y * i;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(i * i + n * n);
  }, e.prototype.distanceSquare = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return i * i + n * n;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var i = this.x, n = this.y;
      return this.x = t[0] * i + t[2] * n + t[4], this.y = t[1] * i + t[3] * n + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, i, n) {
    t.x = i, t.y = n;
  }, e.copy = function(t, i) {
    t.x = i.x, t.y = i.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, i) {
    return t.x * i.x + t.y * i.y;
  }, e.add = function(t, i, n) {
    t.x = i.x + n.x, t.y = i.y + n.y;
  }, e.sub = function(t, i, n) {
    t.x = i.x - n.x, t.y = i.y - n.y;
  }, e.scale = function(t, i, n) {
    t.x = i.x * n, t.y = i.y * n;
  }, e.scaleAndAdd = function(t, i, n, r) {
    t.x = i.x + n.x * r, t.y = i.y + n.y * r;
  }, e.lerp = function(t, i, n, r) {
    var a = 1 - r;
    t.x = a * i.x + r * n.x, t.y = a * i.y + r * n.y;
  }, e;
})(), er = Math.min, Kr = Math.max, yh = Math.abs, pp = ["x", "y"], _D = ["width", "height"], Tn = new Ct(), Mn = new Ct(), kn = new Ct(), Dn = new Ct(), Ie = Uy(), Qa = Ie.minTv, _h = Ie.maxTv, vo = [0, 0], rt = (function() {
  function e(t, i, n, r) {
    e.set(this, t, i, n, r);
  }
  return e.set = function(t, i, n, r, a) {
    return r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), t.x = i, t.y = n, t.width = r, t.height = a, t;
  }, e.prototype.union = function(t) {
    var i = er(t.x, this.x), n = er(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Kr(t.x + t.width, this.x + this.width) - i : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Kr(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = i, this.y = n;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var i = this, n = t.width / i.width, r = t.height / i.height, a = Ti();
    return mh(a, a, [-i.x, -i.y]), yD(a, a, [n, r]), mh(a, a, [t.x, t.y]), a;
  }, e.prototype.intersect = function(t, i, n) {
    return e.intersect(this, t, i, n);
  }, e.intersect = function(t, i, n, r) {
    n && Ct.set(n, 0, 0);
    var a = r && r.outIntersectRect || null, o = r && r.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !i)
      return !1;
    t instanceof e || (t = e.set(bD, t.x, t.y, t.width, t.height)), i instanceof e || (i = e.set(xD, i.x, i.y, i.width, i.height));
    var s = !!n;
    Ie.reset(r, s);
    var l = Ie.touchThreshold, u = t.x + l, c = t.x + t.width - l, h = t.y + l, d = t.y + t.height - l, f = i.x + l, v = i.x + i.width - l, m = i.y + l, p = i.y + i.height - l;
    if (u > c || h > d || f > v || m > p)
      return !1;
    var g = !(c < f || v < u || d < m || p < h);
    return (s || a) && (vo[0] = 1 / 0, vo[1] = 0, gp(u, c, f, v, 0, s, a, o), gp(h, d, m, p, 1, s, a, o), s && Ct.copy(n, g ? Ie.useDir ? Ie.dirMinTv : Qa : _h)), g;
  }, e.contain = function(t, i, n) {
    return i >= t.x && i <= t.x + t.width && n >= t.y && n <= t.y + t.height;
  }, e.prototype.contain = function(t, i) {
    return e.contain(this, t, i);
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, i) {
    return t.x = i.x, t.y = i.y, t.width = i.width, t.height = i.height, t;
  }, e.applyTransform = function(t, i, n) {
    if (!n) {
      t !== i && e.copy(t, i);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var r = n[0], a = n[3], o = n[4], s = n[5];
      t.x = i.x * r + o, t.y = i.y * a + s, t.width = i.width * r, t.height = i.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    Tn.x = kn.x = i.x, Tn.y = Dn.y = i.y, Mn.x = Dn.x = i.x + i.width, Mn.y = kn.y = i.y + i.height, Tn.transform(n), Dn.transform(n), Mn.transform(n), kn.transform(n), t.x = er(Tn.x, Mn.x, kn.x, Dn.x), t.y = er(Tn.y, Mn.y, kn.y, Dn.y);
    var l = Kr(Tn.x, Mn.x, kn.x, Dn.x), u = Kr(Tn.y, Mn.y, kn.y, Dn.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
})(), bD = new rt(0, 0, 0, 0), xD = new rt(0, 0, 0, 0);
function gp(e, t, i, n, r, a, o, s) {
  var l = yh(t - i), u = yh(n - e), c = er(l, u), h = pp[r], d = pp[1 - r], f = _D[r];
  t < i || n < e ? l < u ? (a && (_h[h] = -l), s && (o[h] = t, o[f] = 0)) : (a && (_h[h] = u), s && (o[h] = e, o[f] = 0)) : (o && (o[h] = Kr(e, i), o[f] = er(t, n) - o[h]), a && (c < vo[0] || Ie.useDir) && (vo[0] = er(c, vo[0]), (l < u || !Ie.bidirectional) && (Qa[h] = l, Qa[d] = 0, Ie.useDir && Ie.calcDirMTV()), (l >= u || !Ie.bidirectional) && (Qa[h] = -u, Qa[d] = 0, Ie.useDir && Ie.calcDirMTV())));
}
function Uy() {
  var e = 0, t = new Ct(), i = new Ct(), n = {
    minTv: new Ct(),
    maxTv: new Ct(),
    useDir: !1,
    dirMinTv: new Ct(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, o) {
      n.touchThreshold = 0, a && a.touchThreshold != null && (n.touchThreshold = Kr(0, a.touchThreshold)), n.negativeSize = !1, o && (n.minTv.set(1 / 0, 1 / 0), n.maxTv.set(0, 0), n.useDir = !1, a && a.direction != null && (n.useDir = !0, n.dirMinTv.copy(n.minTv), i.copy(n.minTv), e = a.direction, n.bidirectional = a.bidirectional == null || !!a.bidirectional, n.bidirectional || t.set(Math.cos(e), Math.sin(e))));
    },
    calcDirMTV: function() {
      var a = n.minTv, o = n.dirMinTv, s = a.y * a.y + a.x * a.x, l = Math.sin(e), u = Math.cos(e), c = l * a.y + u * a.x;
      if (r(c)) {
        r(a.x) && r(a.y) && o.set(0, 0);
        return;
      }
      if (i.x = s * u / c, i.y = s * l / c, r(i.x) && r(i.y)) {
        o.set(0, 0);
        return;
      }
      (n.bidirectional || t.dot(i) > 0) && i.len() < o.len() && o.copy(i);
    }
  };
  function r(a) {
    return yh(a) < 1e-10;
  }
  return n;
}
var Gy = "silent";
function wD(e, t, i) {
  return {
    type: e,
    event: i,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: i.zrX,
    offsetY: i.zrY,
    gestureEvent: i.gestureEvent,
    pinchX: i.pinchX,
    pinchY: i.pinchY,
    pinchScale: i.pinchScale,
    wheelDelta: i.zrDelta,
    zrByTouch: i.zrByTouch,
    which: i.which,
    stop: SD
  };
}
function SD() {
  vl(this.event);
}
var CD = (function(e) {
  St(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.handler = null, i;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
})(li), ka = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.x = t, this.y = i;
  }
  return e;
})(), TD = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], Vu = new rt(0, 0, 0, 0), Xy = (function(e) {
  St(t, e);
  function t(i, n, r, a, o) {
    var s = e.call(this) || this;
    return s._hovered = new ka(0, 0), s.storage = i, s.painter = n, s.painterRoot = a, s._pointerSize = o, r = r || new CD(), s.proxy = null, s.setHandlerProxy(r), s._draggingMgr = new nD(s), s;
  }
  return t.prototype.setHandlerProxy = function(i) {
    this.proxy && this.proxy.dispose(), i && (E(TD, function(n) {
      i.on && i.on(n, this[n], this);
    }, this), i.handler = this), this.proxy = i;
  }, t.prototype.mousemove = function(i) {
    var n = i.zrX, r = i.zrY, a = jy(this, n, r), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new ka(n, r) : this.findHover(n, r), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", i), this.dispatchToElement(l, "mousemove", i), u && u !== s && this.dispatchToElement(l, "mouseover", i);
  }, t.prototype.mouseout = function(i) {
    var n = i.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", i), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: i });
  }, t.prototype.resize = function() {
    this._hovered = new ka(0, 0);
  }, t.prototype.dispatch = function(i, n) {
    var r = this[i];
    r && r.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(i) {
    var n = this.proxy;
    n.setCursor && n.setCursor(i);
  }, t.prototype.dispatchToElement = function(i, n, r) {
    i = i || {};
    var a = i.target;
    if (!(a && a.silent)) {
      for (var o = "on" + n, s = wD(n, i, r); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(n, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(n, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(n, s);
      }));
    }
  }, t.prototype.findHover = function(i, n, r) {
    var a = this.storage.getDisplayList(), o = new ka(i, n);
    if (mp(a, o, i, n, r), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new rt(i - u, n - u, l, l), h = a.length - 1; h >= 0; h--) {
        var d = a[h];
        d !== r && !d.ignore && !d.ignoreCoarsePointer && (!d.parent || !d.parent.ignoreCoarsePointer) && (Vu.copy(d.getBoundingRect()), d.transform && Vu.applyTransform(d.transform), Vu.intersect(c) && s.push(d));
      }
      if (s.length)
        for (var f = 4, v = Math.PI / 12, m = Math.PI * 2, p = 0; p < u; p += f)
          for (var g = 0; g < m; g += v) {
            var y = i + p * Math.cos(g), _ = n + p * Math.sin(g);
            if (mp(s, o, y, _, r), o.target)
              return o;
          }
    }
    return o;
  }, t.prototype.processGesture = function(i, n) {
    this._gestureMgr || (this._gestureMgr = new gD());
    var r = this._gestureMgr;
    n === "start" && r.clear();
    var a = r.recognize(i, this.findHover(i.zrX, i.zrY, null).target, this.proxy.dom);
    if (n === "end" && r.clear(), a) {
      var o = a.type;
      i.gestureEvent = o;
      var s = new ka();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, t;
})(li);
E(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  Xy.prototype[e] = function(t) {
    var i = t.zrX, n = t.zrY, r = jy(this, i, n), a, o;
    if ((e !== "mouseup" || !r) && (a = this.findHover(i, n), o = a.target), e === "mousedown")
      this._downEl = o, this._downPoint = [t.zrX, t.zrY], this._upEl = o;
    else if (e === "mouseup")
      this._upEl = o;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || eD(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, e, t);
  };
});
function MD(e, t, i) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, i)) {
    for (var n = e, r = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var o = n.getClipPath();
        if (o && !o.contain(t, i))
          return !1;
      }
      n.silent && (r = !0);
      var s = n.__hostTarget;
      n = s ? n.ignoreHostSilent ? null : s : n.parent;
    }
    return r ? Gy : !0;
  }
  return !1;
}
function mp(e, t, i, n, r) {
  for (var a = e.length - 1; a >= 0; a--) {
    var o = e[a], s = void 0;
    if (o !== r && !o.ignore && (s = MD(o, i, n)) && (!t.topTarget && (t.topTarget = o), s !== Gy)) {
      t.target = o;
      break;
    }
  }
}
function jy(e, t, i) {
  var n = e.painter;
  return t < 0 || t > n.getWidth() || i < 0 || i > n.getHeight();
}
var qy = 32, Da = 7;
function kD(e) {
  for (var t = 0; e >= qy; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function yp(e, t, i, n) {
  var r = t + 1;
  if (r === i)
    return 1;
  if (n(e[r++], e[t]) < 0) {
    for (; r < i && n(e[r], e[r - 1]) < 0; )
      r++;
    DD(e, t, r);
  } else
    for (; r < i && n(e[r], e[r - 1]) >= 0; )
      r++;
  return r - t;
}
function DD(e, t, i) {
  for (i--; t < i; ) {
    var n = e[t];
    e[t++] = e[i], e[i--] = n;
  }
}
function _p(e, t, i, n, r) {
  for (n === t && n++; n < i; n++) {
    for (var a = e[n], o = t, s = n, l; o < s; )
      l = o + s >>> 1, r(a, e[l]) < 0 ? s = l : o = l + 1;
    var u = n - o;
    switch (u) {
      case 3:
        e[o + 3] = e[o + 2];
      case 2:
        e[o + 2] = e[o + 1];
      case 1:
        e[o + 1] = e[o];
        break;
      default:
        for (; u > 0; )
          e[o + u] = e[o + u - 1], u--;
    }
    e[o] = a;
  }
}
function Hu(e, t, i, n, r, a) {
  var o = 0, s = 0, l = 1;
  if (a(e, t[i + r]) > 0) {
    for (s = n - r; l < s && a(e, t[i + r + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += r, l += r;
  } else {
    for (s = r + 1; l < s && a(e, t[i + r - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = r - l, l = r - u;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(e, t[i + c]) > 0 ? o = c + 1 : l = c;
  }
  return l;
}
function Wu(e, t, i, n, r, a) {
  var o = 0, s = 0, l = 1;
  if (a(e, t[i + r]) < 0) {
    for (s = r + 1; l < s && a(e, t[i + r - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = r - l, l = r - u;
  } else {
    for (s = n - r; l < s && a(e, t[i + r + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += r, l += r;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(e, t[i + c]) < 0 ? l = c : o = c + 1;
  }
  return l;
}
function ED(e, t) {
  var i = Da, n, r, a = 0, o = [];
  n = [], r = [];
  function s(f, v) {
    n[a] = f, r[a] = v, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var f = a - 2;
      if (f >= 1 && r[f - 1] <= r[f] + r[f + 1] || f >= 2 && r[f - 2] <= r[f] + r[f - 1])
        r[f - 1] < r[f + 1] && f--;
      else if (r[f] > r[f + 1])
        break;
      c(f);
    }
  }
  function u() {
    for (; a > 1; ) {
      var f = a - 2;
      f > 0 && r[f - 1] < r[f + 1] && f--, c(f);
    }
  }
  function c(f) {
    var v = n[f], m = r[f], p = n[f + 1], g = r[f + 1];
    r[f] = m + g, f === a - 3 && (n[f + 1] = n[f + 2], r[f + 1] = r[f + 2]), a--;
    var y = Wu(e[p], e, v, m, 0, t);
    v += y, m -= y, m !== 0 && (g = Hu(e[v + m - 1], e, p, g, g - 1, t), g !== 0 && (m <= g ? h(v, m, p, g) : d(v, m, p, g)));
  }
  function h(f, v, m, p) {
    var g = 0;
    for (g = 0; g < v; g++)
      o[g] = e[f + g];
    var y = 0, _ = m, b = f;
    if (e[b++] = e[_++], --p === 0) {
      for (g = 0; g < v; g++)
        e[b + g] = o[y + g];
      return;
    }
    if (v === 1) {
      for (g = 0; g < p; g++)
        e[b + g] = e[_ + g];
      e[b + p] = o[y];
      return;
    }
    for (var w = i, S, C, T; ; ) {
      S = 0, C = 0, T = !1;
      do
        if (t(e[_], o[y]) < 0) {
          if (e[b++] = e[_++], C++, S = 0, --p === 0) {
            T = !0;
            break;
          }
        } else if (e[b++] = o[y++], S++, C = 0, --v === 1) {
          T = !0;
          break;
        }
      while ((S | C) < w);
      if (T)
        break;
      do {
        if (S = Wu(e[_], o, y, v, 0, t), S !== 0) {
          for (g = 0; g < S; g++)
            e[b + g] = o[y + g];
          if (b += S, y += S, v -= S, v <= 1) {
            T = !0;
            break;
          }
        }
        if (e[b++] = e[_++], --p === 0) {
          T = !0;
          break;
        }
        if (C = Hu(o[y], e, _, p, 0, t), C !== 0) {
          for (g = 0; g < C; g++)
            e[b + g] = e[_ + g];
          if (b += C, _ += C, p -= C, p === 0) {
            T = !0;
            break;
          }
        }
        if (e[b++] = o[y++], --v === 1) {
          T = !0;
          break;
        }
        w--;
      } while (S >= Da || C >= Da);
      if (T)
        break;
      w < 0 && (w = 0), w += 2;
    }
    if (i = w, i < 1 && (i = 1), v === 1) {
      for (g = 0; g < p; g++)
        e[b + g] = e[_ + g];
      e[b + p] = o[y];
    } else {
      if (v === 0)
        throw new Error();
      for (g = 0; g < v; g++)
        e[b + g] = o[y + g];
    }
  }
  function d(f, v, m, p) {
    var g = 0;
    for (g = 0; g < p; g++)
      o[g] = e[m + g];
    var y = f + v - 1, _ = p - 1, b = m + p - 1, w = 0, S = 0;
    if (e[b--] = e[y--], --v === 0) {
      for (w = b - (p - 1), g = 0; g < p; g++)
        e[w + g] = o[g];
      return;
    }
    if (p === 1) {
      for (b -= v, y -= v, S = b + 1, w = y + 1, g = v - 1; g >= 0; g--)
        e[S + g] = e[w + g];
      e[b] = o[_];
      return;
    }
    for (var C = i; ; ) {
      var T = 0, k = 0, M = !1;
      do
        if (t(o[_], e[y]) < 0) {
          if (e[b--] = e[y--], T++, k = 0, --v === 0) {
            M = !0;
            break;
          }
        } else if (e[b--] = o[_--], k++, T = 0, --p === 1) {
          M = !0;
          break;
        }
      while ((T | k) < C);
      if (M)
        break;
      do {
        if (T = v - Wu(o[_], e, f, v, v - 1, t), T !== 0) {
          for (b -= T, y -= T, v -= T, S = b + 1, w = y + 1, g = T - 1; g >= 0; g--)
            e[S + g] = e[w + g];
          if (v === 0) {
            M = !0;
            break;
          }
        }
        if (e[b--] = o[_--], --p === 1) {
          M = !0;
          break;
        }
        if (k = p - Hu(e[y], o, 0, p, p - 1, t), k !== 0) {
          for (b -= k, _ -= k, p -= k, S = b + 1, w = _ + 1, g = 0; g < k; g++)
            e[S + g] = o[w + g];
          if (p <= 1) {
            M = !0;
            break;
          }
        }
        if (e[b--] = e[y--], --v === 0) {
          M = !0;
          break;
        }
        C--;
      } while (T >= Da || k >= Da);
      if (M)
        break;
      C < 0 && (C = 0), C += 2;
    }
    if (i = C, i < 1 && (i = 1), p === 1) {
      for (b -= v, y -= v, S = b + 1, w = y + 1, g = v - 1; g >= 0; g--)
        e[S + g] = e[w + g];
      e[b] = o[_];
    } else {
      if (p === 0)
        throw new Error();
      for (w = b - (p - 1), g = 0; g < p; g++)
        e[w + g] = o[g];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function Gs(e, t, i, n) {
  i || (i = 0), n || (n = e.length);
  var r = n - i;
  if (!(r < 2)) {
    var a = 0;
    if (r < qy) {
      a = yp(e, i, n, t), _p(e, i, n, i + a, t);
      return;
    }
    var o = ED(e, t), s = kD(r);
    do {
      if (a = yp(e, i, n, t), a < s) {
        var l = r;
        l > s && (l = s), _p(e, i, i + l, i + a, t), a = l;
      }
      o.pushRun(i, a), o.mergeRuns(), r -= a, i += a;
    } while (r !== 0);
    o.forceMergeRuns();
  }
}
var Oe = 1, Ja = 2, jr = 4, bp = !1;
function Yu() {
  bp || (bp = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function xp(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var AD = (function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = xp;
  }
  return e.prototype.traverse = function(t, i) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, i);
  }, e.prototype.getDisplayList = function(t, i) {
    i = i || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(i), n;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var i = this._roots, n = this._displayList, r = 0, a = i.length; r < a; r++)
      this._updateAndAddDisplayable(i[r], null, t);
    n.length = this._displayListLen, Gs(n, xp);
  }, e.prototype._updateAndAddDisplayable = function(t, i, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var r = t.getClipPath(), a = i && i.length, o = 0, s = t.__clipPaths;
      if (!t.ignoreClip && (a || r)) {
        if (s || (s = t.__clipPaths = []), a)
          for (var l = 0; l < i.length; l++)
            s[o++] = i[l];
        for (var u = r, c = t; u; )
          u.parent = c, u.updateTransform(), s[o++] = u, c = u, u = u.getClipPath();
      }
      if (s && (s.length = o), t.childrenRef) {
        for (var h = t.childrenRef(), d = 0; d < h.length; d++) {
          var f = h[d];
          t.__dirty && (f.__dirty |= Oe), this._updateAndAddDisplayable(f, s, n);
        }
        t.__dirty = 0;
      } else {
        var v = t;
        isNaN(v.z) && (Yu(), v.z = 0), isNaN(v.z2) && (Yu(), v.z2 = 0), isNaN(v.zlevel) && (Yu(), v.zlevel = 0), this._displayList[this._displayListLen++] = v;
      }
      var m = t.getDecalElement && t.getDecalElement();
      m && this._updateAndAddDisplayable(m, s, n);
      var p = t.getTextGuideLine();
      p && this._updateAndAddDisplayable(p, s, n);
      var g = t.getTextContent();
      g && this._updateAndAddDisplayable(g, s, n);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var i = 0, n = t.length; i < n; i++)
        this.delRoot(t[i]);
      return;
    }
    var r = Pt(this._roots, t);
    r >= 0 && this._roots.splice(r, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
})(), pl;
pl = nt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var po = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - po.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? po.bounceIn(e * 2) * 0.5 : po.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, ls = Math.pow, hn = Math.sqrt, gl = 1e-8, Zy = 1e-4, wp = hn(3), us = 1 / 3, bi = ba(), Ge = ba(), ra = ba();
function ln(e) {
  return e > -gl && e < gl;
}
function Ky(e) {
  return e > gl || e < -gl;
}
function ge(e, t, i, n, r) {
  var a = 1 - r;
  return a * a * (a * e + 3 * r * t) + r * r * (r * n + 3 * a * i);
}
function Sp(e, t, i, n, r) {
  var a = 1 - r;
  return 3 * (((t - e) * a + 2 * (i - t) * r) * a + (n - i) * r * r);
}
function Qy(e, t, i, n, r, a) {
  var o = n + 3 * (t - i) - e, s = 3 * (i - t * 2 + e), l = 3 * (t - e), u = e - r, c = s * s - 3 * o * l, h = s * l - 9 * o * u, d = l * l - 3 * s * u, f = 0;
  if (ln(c) && ln(h))
    if (ln(s))
      a[0] = 0;
    else {
      var v = -l / s;
      v >= 0 && v <= 1 && (a[f++] = v);
    }
  else {
    var m = h * h - 4 * c * d;
    if (ln(m)) {
      var p = h / c, v = -s / o + p, g = -p / 2;
      v >= 0 && v <= 1 && (a[f++] = v), g >= 0 && g <= 1 && (a[f++] = g);
    } else if (m > 0) {
      var y = hn(m), _ = c * s + 1.5 * o * (-h + y), b = c * s + 1.5 * o * (-h - y);
      _ < 0 ? _ = -ls(-_, us) : _ = ls(_, us), b < 0 ? b = -ls(-b, us) : b = ls(b, us);
      var v = (-s - (_ + b)) / (3 * o);
      v >= 0 && v <= 1 && (a[f++] = v);
    } else {
      var w = (2 * c * s - 3 * o * h) / (2 * hn(c * c * c)), S = Math.acos(w) / 3, C = hn(c), T = Math.cos(S), v = (-s - 2 * C * T) / (3 * o), g = (-s + C * (T + wp * Math.sin(S))) / (3 * o), k = (-s + C * (T - wp * Math.sin(S))) / (3 * o);
      v >= 0 && v <= 1 && (a[f++] = v), g >= 0 && g <= 1 && (a[f++] = g), k >= 0 && k <= 1 && (a[f++] = k);
    }
  }
  return f;
}
function Jy(e, t, i, n, r) {
  var a = 6 * i - 12 * t + 6 * e, o = 9 * t + 3 * n - 3 * e - 9 * i, s = 3 * t - 3 * e, l = 0;
  if (ln(o)) {
    if (Ky(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (ln(c))
      r[0] = -a / (2 * o);
    else if (c > 0) {
      var h = hn(c), u = (-a + h) / (2 * o), d = (-a - h) / (2 * o);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function ml(e, t, i, n, r, a) {
  var o = (t - e) * r + e, s = (i - t) * r + t, l = (n - i) * r + i, u = (s - o) * r + o, c = (l - s) * r + s, h = (c - u) * r + u;
  a[0] = e, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n;
}
function LD(e, t, i, n, r, a, o, s, l, u, c) {
  var h, d = 5e-3, f = 1 / 0, v, m, p, g;
  bi[0] = l, bi[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    Ge[0] = ge(e, i, r, o, y), Ge[1] = ge(t, n, a, s, y), p = na(bi, Ge), p < f && (h = y, f = p);
  f = 1 / 0;
  for (var _ = 0; _ < 32 && !(d < Zy); _++)
    v = h - d, m = h + d, Ge[0] = ge(e, i, r, o, v), Ge[1] = ge(t, n, a, s, v), p = na(Ge, bi), v >= 0 && p < f ? (h = v, f = p) : (ra[0] = ge(e, i, r, o, m), ra[1] = ge(t, n, a, s, m), g = na(ra, bi), m <= 1 && g < f ? (h = m, f = g) : d *= 0.5);
  return hn(f);
}
function PD(e, t, i, n, r, a, o, s, l) {
  for (var u = e, c = t, h = 0, d = 1 / l, f = 1; f <= l; f++) {
    var v = f * d, m = ge(e, i, r, o, v), p = ge(t, n, a, s, v), g = m - u, y = p - c;
    h += Math.sqrt(g * g + y * y), u = m, c = p;
  }
  return h;
}
function Te(e, t, i, n) {
  var r = 1 - n;
  return r * (r * e + 2 * n * t) + n * n * i;
}
function Cp(e, t, i, n) {
  return 2 * ((1 - n) * (t - e) + n * (i - t));
}
function ID(e, t, i, n, r) {
  var a = e - 2 * t + i, o = 2 * (t - e), s = e - n, l = 0;
  if (ln(a)) {
    if (Ky(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (ln(c)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u);
    } else if (c > 0) {
      var h = hn(c), u = (-o + h) / (2 * a), d = (-o - h) / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function t_(e, t, i) {
  var n = e + i - 2 * t;
  return n === 0 ? 0.5 : (e - t) / n;
}
function yl(e, t, i, n, r) {
  var a = (t - e) * n + e, o = (i - t) * n + t, s = (o - a) * n + a;
  r[0] = e, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = i;
}
function RD(e, t, i, n, r, a, o, s, l) {
  var u, c = 5e-3, h = 1 / 0;
  bi[0] = o, bi[1] = s;
  for (var d = 0; d < 1; d += 0.05) {
    Ge[0] = Te(e, i, r, d), Ge[1] = Te(t, n, a, d);
    var f = na(bi, Ge);
    f < h && (u = d, h = f);
  }
  h = 1 / 0;
  for (var v = 0; v < 32 && !(c < Zy); v++) {
    var m = u - c, p = u + c;
    Ge[0] = Te(e, i, r, m), Ge[1] = Te(t, n, a, m);
    var f = na(Ge, bi);
    if (m >= 0 && f < h)
      u = m, h = f;
    else {
      ra[0] = Te(e, i, r, p), ra[1] = Te(t, n, a, p);
      var g = na(ra, bi);
      p <= 1 && g < h ? (u = p, h = g) : c *= 0.5;
    }
  }
  return hn(h);
}
function OD(e, t, i, n, r, a, o) {
  for (var s = e, l = t, u = 0, c = 1 / o, h = 1; h <= o; h++) {
    var d = h * c, f = Te(e, i, r, d), v = Te(t, n, a, d), m = f - s, p = v - l;
    u += Math.sqrt(m * m + p * p), s = f, l = v;
  }
  return u;
}
var BD = /cubic-bezier\(([0-9,\.e ]+)\)/;
function e_(e) {
  var t = e && BD.exec(e);
  if (t) {
    var i = t[1].split(","), n = +xi(i[0]), r = +xi(i[1]), a = +xi(i[2]), o = +xi(i[3]);
    if (isNaN(n + r + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : Qy(0, n, a, 1, l, s) && ge(0, r, o, 1, s[0]);
    };
  }
}
var ND = (function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || ce, this.ondestroy = t.ondestroy || ce, this.onrestart = t.onrestart || ce, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, i) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += i;
      return;
    }
    var n = this._life, r = t - this._startTime - this._pausedTime, a = r / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = r % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = ht(t) ? t : po[t] || e_(t);
  }, e;
})(), i_ = /* @__PURE__ */ (function() {
  function e(t) {
    this.value = t;
  }
  return e;
})(), FD = (function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var i = new i_(t);
    return this.insertEntry(i), i;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var i = t.prev, n = t.next;
    i ? i.next = n : this.head = n, n ? n.prev = i : this.tail = i, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
})(), ha = (function() {
  function e(t) {
    this._list = new FD(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, i) {
    var n = this._list, r = this._map, a = null;
    if (r[t] == null) {
      var o = n.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = n.head;
        n.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = i : s = new i_(i), s.key = t, n.insertEntry(s), r[t] = s;
    }
    return a;
  }, e.prototype.get = function(t) {
    var i = this._map[t], n = this._list;
    if (i != null)
      return i !== n.tail && (n.remove(i), n.insertEntry(i)), i.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
})(), Tp = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function dn(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function $D(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function _l(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function Uu(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? dn(parseFloat(t) / 100 * 255) : dn(parseInt(t, 10));
}
function cr(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? _l(parseFloat(t) / 100) : _l(parseFloat(t));
}
function Gu(e, t, i) {
  return i < 0 ? i += 1 : i > 1 && (i -= 1), i * 6 < 1 ? e + (t - e) * i * 6 : i * 2 < 1 ? t : i * 3 < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e;
}
function cs(e, t, i) {
  return e + (t - e) * i;
}
function He(e, t, i, n, r) {
  return e[0] = t, e[1] = i, e[2] = n, e[3] = r, e;
}
function bh(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var n_ = new ha(20), hs = null;
function Lr(e, t) {
  hs && bh(hs, t), hs = n_.put(e, hs || t.slice());
}
function Wi(e, t) {
  if (e) {
    t = t || [];
    var i = n_.get(e);
    if (i)
      return bh(t, i);
    e = e + "";
    var n = e.replace(/ /g, "").toLowerCase();
    if (n in Tp)
      return bh(t, Tp[n]), Lr(e, t), t;
    var r = n.length;
    if (n.charAt(0) === "#") {
      if (r === 4 || r === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          He(t, 0, 0, 0, 1);
          return;
        }
        return He(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(n.slice(4), 16) / 15 : 1), Lr(e, t), t;
      } else if (r === 7 || r === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          He(t, 0, 0, 0, 1);
          return;
        }
        return He(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(n.slice(7), 16) / 255 : 1), Lr(e, t), t;
      }
      return;
    }
    var o = n.indexOf("("), s = n.indexOf(")");
    if (o !== -1 && s + 1 === r) {
      var l = n.substr(0, o), u = n.substr(o + 1, s - (o + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? He(t, +u[0], +u[1], +u[2], 1) : He(t, 0, 0, 0, 1);
          c = cr(u.pop());
        case "rgb":
          if (u.length >= 3)
            return He(t, Uu(u[0]), Uu(u[1]), Uu(u[2]), u.length === 3 ? c : cr(u[3])), Lr(e, t), t;
          He(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            He(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = cr(u[3]), xh(u, t), Lr(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            He(t, 0, 0, 0, 1);
            return;
          }
          return xh(u, t), Lr(e, t), t;
        default:
          return;
      }
    }
    He(t, 0, 0, 0, 1);
  }
}
function xh(e, t) {
  var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = cr(e[1]), r = cr(e[2]), a = r <= 0.5 ? r * (n + 1) : r + n - r * n, o = r * 2 - a;
  return t = t || [], He(t, dn(Gu(o, a, i + 1 / 3) * 255), dn(Gu(o, a, i) * 255), dn(Gu(o, a, i - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function zD(e) {
  if (e) {
    var t = e[0] / 255, i = e[1] / 255, n = e[2] / 255, r = Math.min(t, i, n), a = Math.max(t, i, n), o = a - r, s = (a + r) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + r) : u = o / (2 - a - r);
      var c = ((a - t) / 6 + o / 2) / o, h = ((a - i) / 6 + o / 2) / o, d = ((a - n) / 6 + o / 2) / o;
      t === a ? l = d - h : i === a ? l = 1 / 3 + c - d : n === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var f = [l * 360, u, s];
    return e[3] != null && f.push(e[3]), f;
  }
}
function Mp(e, t) {
  var i = Wi(e);
  if (i) {
    for (var n = 0; n < 3; n++)
      i[n] = i[n] * (1 - t) | 0, i[n] > 255 ? i[n] = 255 : i[n] < 0 && (i[n] = 0);
    return hr(i, i.length === 4 ? "rgba" : "rgb");
  }
}
function Xu(e, t, i) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    i = i || [];
    var n = e * (t.length - 1), r = Math.floor(n), a = Math.ceil(n), o = t[r], s = t[a], l = n - r;
    return i[0] = dn(cs(o[0], s[0], l)), i[1] = dn(cs(o[1], s[1], l)), i[2] = dn(cs(o[2], s[2], l)), i[3] = _l(cs(o[3], s[3], l)), i;
  }
}
function aa(e, t, i, n) {
  var r = Wi(e);
  if (e)
    return r = zD(r), t != null && (r[0] = $D(ht(t) ? t(r[0]) : t)), i != null && (r[1] = cr(ht(i) ? i(r[1]) : i)), n != null && (r[2] = cr(ht(n) ? n(r[2]) : n)), hr(xh(r), "rgba");
}
function VD(e, t) {
  var i = Wi(e);
  if (i && t != null)
    return i[3] = _l(t), hr(i, "rgba");
}
function hr(e, t) {
  if (!(!e || !e.length)) {
    var i = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (i += "," + e[3]), t + "(" + i + ")";
  }
}
function bl(e, t) {
  var i = Wi(e);
  return i ? (0.299 * i[0] + 0.587 * i[1] + 0.114 * i[2]) * i[3] / 255 + (1 - i[3]) * t : 0;
}
var kp = new ha(100);
function Dp(e) {
  if (K(e)) {
    var t = kp.get(e);
    return t || (t = Mp(e, -0.1), kp.put(e, t)), t;
  } else if (au(e)) {
    var i = V({}, e);
    return i.colorStops = dt(e.colorStops, function(n) {
      return {
        offset: n.offset,
        color: Mp(n.color, -0.1)
      };
    }), i;
  }
  return e;
}
function HD(e) {
  return e.type === "linear";
}
function WD(e) {
  return e.type === "radial";
}
(function() {
  return nt.hasGlobalWindow && ht(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && lr("Base64 isn't natively supported in the current environment."), null;
  };
})();
var wh = Array.prototype.slice;
function Ni(e, t, i) {
  return (t - e) * i + e;
}
function ju(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = Ni(t[a], i[a], n);
  return e;
}
function YD(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
    e[o] || (e[o] = []);
    for (var s = 0; s < a; s++)
      e[o][s] = Ni(t[o][s], i[o][s], n);
  }
  return e;
}
function ds(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = t[a] + i[a] * n;
  return e;
}
function Ep(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
    e[o] || (e[o] = []);
    for (var s = 0; s < a; s++)
      e[o][s] = t[o][s] + i[o][s] * n;
  }
  return e;
}
function UD(e, t) {
  for (var i = e.length, n = t.length, r = i > n ? t : e, a = Math.min(i, n), o = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(i, n); s++)
    r.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function GD(e, t, i) {
  var n = e, r = t;
  if (!(!n.push || !r.push)) {
    var a = n.length, o = r.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        n.length = o;
      else
        for (var l = a; l < o; l++)
          n.push(i === 1 ? r[l] : wh.call(r[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (i === 1)
        isNaN(n[l]) && (n[l] = r[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = r[l][c]);
  }
}
function Xs(e) {
  if (Ae(e)) {
    var t = e.length;
    if (Ae(e[0])) {
      for (var i = [], n = 0; n < t; n++)
        i.push(wh.call(e[n]));
      return i;
    }
    return wh.call(e);
  }
  return e;
}
function js(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function XD(e) {
  return Ae(e && e[0]) ? 2 : 1;
}
var fs = 0, qs = 1, r_ = 2, to = 3, Sh = 4, Ch = 5, Ap = 6;
function Lp(e) {
  return e === Sh || e === Ch;
}
function vs(e) {
  return e === qs || e === r_;
}
var Ea = [0, 0, 0, 0], jD = (function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, i, n) {
    this._needsSort = !0;
    var r = this.keyframes, a = r.length, o = !1, s = Ap, l = i;
    if (Ae(i)) {
      var u = XD(i);
      s = u, (u === 1 && !Nt(i[0]) || u === 2 && !Nt(i[0][0])) && (o = !0);
    } else if (Nt(i) && !zy(i))
      s = fs;
    else if (K(i))
      if (!isNaN(+i))
        s = fs;
      else {
        var c = Wi(i);
        c && (l = c, s = to);
      }
    else if (au(i)) {
      var h = V({}, l);
      h.colorStops = dt(i.colorStops, function(f) {
        return {
          offset: f.offset,
          color: Wi(f.color)
        };
      }), HD(i) ? s = Sh : WD(i) && (s = Ch), l = h;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === Ap) && (o = !0), this.discrete = this.discrete || o;
    var d = {
      time: t,
      value: l,
      rawValue: i,
      percent: 0
    };
    return n && (d.easing = n, d.easingFunc = ht(n) ? n : po[n] || e_(n)), r.push(d), d;
  }, e.prototype.prepare = function(t, i) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(m, p) {
      return m.time - p.time;
    });
    for (var r = this.valType, a = n.length, o = n[a - 1], s = this.discrete, l = vs(r), u = Lp(r), c = 0; c < a; c++) {
      var h = n[c], d = h.value, f = o.value;
      h.percent = h.time / t, s || (l && c !== a - 1 ? GD(d, f, r) : u && UD(d.colorStops, f.colorStops));
    }
    if (!s && r !== Ch && i && this.needsAnimate() && i.needsAnimate() && r === i.valType && !i._finished) {
      this._additiveTrack = i;
      for (var v = n[0].value, c = 0; c < a; c++)
        r === fs ? n[c].additiveValue = n[c].value - v : r === to ? n[c].additiveValue = ds([], n[c].value, v, -1) : vs(r) && (n[c].additiveValue = r === qs ? ds([], n[c].value, v, -1) : Ep([], n[c].value, v, -1));
    }
  }, e.prototype.step = function(t, i) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, r = n ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === to, c, h = this._lastFr, d = Math.min, f, v;
      if (s === 1)
        f = v = o[0];
      else {
        if (i < 0)
          c = 0;
        else if (i < this._lastFrP) {
          var m = d(h + 1, s - 1);
          for (c = m; c >= 0 && !(o[c].percent <= i); c--)
            ;
          c = d(c, s - 2);
        } else {
          for (c = h; c < s && !(o[c].percent > i); c++)
            ;
          c = d(c - 1, s - 2);
        }
        v = o[c + 1], f = o[c];
      }
      if (f && v) {
        this._lastFr = c, this._lastFrP = i;
        var p = v.percent - f.percent, g = p === 0 ? 1 : d((i - f.percent) / p, 1);
        v.easingFunc && (g = v.easingFunc(g));
        var y = n ? this._additiveValue : u ? Ea : t[l];
        if ((vs(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = g < 1 ? f.rawValue : v.rawValue;
        else if (vs(a))
          a === qs ? ju(y, f[r], v[r], g) : YD(y, f[r], v[r], g);
        else if (Lp(a)) {
          var _ = f[r], b = v[r], w = a === Sh;
          t[l] = {
            type: w ? "linear" : "radial",
            x: Ni(_.x, b.x, g),
            y: Ni(_.y, b.y, g),
            colorStops: dt(_.colorStops, function(C, T) {
              var k = b.colorStops[T];
              return {
                offset: Ni(C.offset, k.offset, g),
                color: js(ju([], C.color, k.color, g))
              };
            }),
            global: b.global
          }, w ? (t[l].x2 = Ni(_.x2, b.x2, g), t[l].y2 = Ni(_.y2, b.y2, g)) : t[l].r = Ni(_.r, b.r, g);
        } else if (u)
          ju(y, f[r], v[r], g), n || (t[l] = js(y));
        else {
          var S = Ni(f[r], v[r], g);
          n ? this._additiveValue = S : t[l] = S;
        }
        n && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var i = this.valType, n = this.propName, r = this._additiveValue;
    i === fs ? t[n] = t[n] + r : i === to ? (Wi(t[n], Ea), ds(Ea, Ea, r, 1), t[n] = js(Ea)) : i === qs ? ds(t[n], t[n], r, 1) : i === r_ && Ep(t[n], t[n], r, 1);
  }, e;
})(), zd = (function() {
  function e(t, i, n, r) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = i, i && r) {
      lr("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = r, this._allowDiscrete = n;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, i, n) {
    return this.whenWithKeys(t, i, Bt(i), n);
  }, e.prototype.whenWithKeys = function(t, i, n, r) {
    for (var a = this._tracks, o = 0; o < n.length; o++) {
      var s = n[o], l = a[s];
      if (!l) {
        l = a[s] = new jD(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var h = c.keyframes, d = h[h.length - 1];
          u = d && d.value, c.valType === to && u && (u = js(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, Xs(u), r), this._trackKeys.push(s);
      }
      l.addKeyframe(t, Xs(i[s]), r);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var i = t.length, n = 0; n < i; n++)
        t[n].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, i = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, i)
      for (var n = 0; n < i.length; n++)
        i[n].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, i = this._trackKeys, n = 0; n < i.length; n++)
      t[i[n]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var i, n = this._additiveAnimators;
    if (n)
      for (var r = 0; r < n.length; r++) {
        var a = n[r].getTrack(t);
        a && (i = a);
      }
    return i;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var i = this, n = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
        if (s.prepare(r, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var h = u[c - 1];
            h && (i._target[s.propName] = h.rawValue), s.setFinished();
          } else
            n.push(s);
      }
      if (n.length || this._force) {
        var d = new ND({
          life: r,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(f) {
            i._started = 2;
            var v = i._additiveAnimators;
            if (v) {
              for (var m = !1, p = 0; p < v.length; p++)
                if (v[p]._clip) {
                  m = !0;
                  break;
                }
              m || (i._additiveAnimators = null);
            }
            for (var p = 0; p < n.length; p++)
              n[p].step(i._target, f);
            var g = i._onframeCbs;
            if (g)
              for (var p = 0; p < g.length; p++)
                g[p](i._target, f);
          },
          ondestroy: function() {
            i._doneCallback();
          }
        });
        this._clip = d, this.animation && this.animation.addClip(d), t && d.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var i = this._clip;
      t && i.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return dt(this._trackKeys, function(i) {
      return t._tracks[i];
    });
  }, e.prototype.stopTracks = function(t, i) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
      var o = n[t[a]];
      o && !o.isFinished() && (i ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < r.length; a++)
      if (!n[r[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, e.prototype.saveTo = function(t, i, n) {
    if (t) {
      i = i || this._trackKeys;
      for (var r = 0; r < i.length; r++) {
        var a = i[r], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[n ? 0 : s.length - 1];
          l && (t[a] = Xs(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, i) {
    i = i || Bt(t);
    for (var n = 0; n < i.length; n++) {
      var r = i[n], a = this._tracks[r];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, e;
})();
function Qr() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var qD = (function(e) {
  St(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, i = i || {}, n.stage = i.stage || {}, n;
  }
  return t.prototype.addClip = function(i) {
    i.animation && this.removeClip(i), this._head ? (this._tail.next = i, i.prev = this._tail, i.next = null, this._tail = i) : this._head = this._tail = i, i.animation = this;
  }, t.prototype.addAnimator = function(i) {
    i.animation = this;
    var n = i.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(i) {
    if (i.animation) {
      var n = i.prev, r = i.next;
      n ? n.next = r : this._head = r, r ? r.prev = n : this._tail = n, i.next = i.prev = i.animation = null;
    }
  }, t.prototype.removeAnimator = function(i) {
    var n = i.getClip();
    n && this.removeClip(n), i.animation = null;
  }, t.prototype.update = function(i) {
    for (var n = Qr() - this._pausedTime, r = n - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(n, r);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = n, i || (this.trigger("frame", r), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var i = this;
    this._running = !0;
    function n() {
      i._running && (pl(n), !i._paused && i.update());
    }
    pl(n);
  }, t.prototype.start = function() {
    this._running || (this._time = Qr(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = Qr(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += Qr() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var i = this._head; i; ) {
      var n = i.next;
      i.prev = i.next = i.animation = null, i = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(i, n) {
    n = n || {}, this.start();
    var r = new zd(i, n.loop);
    return this.addAnimator(r), r;
  }, t;
})(li), ZD = 300, qu = nt.domSupported, Zu = (function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], i = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = dt(e, function(r) {
    var a = r.replace("mouse", "pointer");
    return i.hasOwnProperty(a) ? a : r;
  });
  return {
    mouse: e,
    touch: t,
    pointer: n
  };
})(), Pp = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, Ip = !1;
function Th(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function KD(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function Ku(e) {
  e && (e.zrByTouch = !0);
}
function QD(e, t) {
  return We(e.dom, new JD(e, t), !0);
}
function a_(e, t) {
  for (var i = t, n = !1; i && i.nodeType !== 9 && !(n = i.domBelongToZr || i !== t && i === e.painterRoot); )
    i = i.parentNode;
  return n;
}
var JD = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.stopPropagation = ce, this.stopImmediatePropagation = ce, this.preventDefault = ce, this.type = i.type, this.target = this.currentTarget = t.dom, this.pointerType = i.pointerType, this.clientX = i.clientX, this.clientY = i.clientY;
  }
  return e;
})(), ii = {
  mousedown: function(e) {
    e = We(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = We(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = We(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = We(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    a_(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    Ip = !0, e = We(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    Ip || (e = We(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = We(this.dom, e), Ku(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), ii.mousemove.call(this, e), ii.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = We(this.dom, e), Ku(e), this.handler.processGesture(e, "change"), ii.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = We(this.dom, e), Ku(e), this.handler.processGesture(e, "end"), ii.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < ZD && ii.click.call(this, e);
  },
  pointerdown: function(e) {
    ii.mousedown.call(this, e);
  },
  pointermove: function(e) {
    Th(e) || ii.mousemove.call(this, e);
  },
  pointerup: function(e) {
    ii.mouseup.call(this, e);
  },
  pointerout: function(e) {
    Th(e) || ii.mouseout.call(this, e);
  }
};
E(["click", "dblclick", "contextmenu"], function(e) {
  ii[e] = function(t) {
    t = We(this.dom, t), this.trigger(e, t);
  };
});
var Mh = {
  pointermove: function(e) {
    Th(e) || Mh.mousemove.call(this, e);
  },
  pointerup: function(e) {
    Mh.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function tE(e, t) {
  var i = t.domHandlers;
  nt.pointerEventsSupported ? E(Zu.pointer, function(n) {
    Zs(t, n, function(r) {
      i[n].call(e, r);
    });
  }) : (nt.touchEventsSupported && E(Zu.touch, function(n) {
    Zs(t, n, function(r) {
      i[n].call(e, r), KD(t);
    });
  }), E(Zu.mouse, function(n) {
    Zs(t, n, function(r) {
      r = Bd(r), t.touching || i[n].call(e, r);
    });
  }));
}
function eE(e, t) {
  nt.pointerEventsSupported ? E(Pp.pointer, i) : nt.touchEventsSupported || E(Pp.mouse, i);
  function i(n) {
    function r(a) {
      a = Bd(a), a_(e, a.target) || (a = QD(e, a), t.domHandlers[n].call(e, a));
    }
    Zs(t, n, r, { capture: !0 });
  }
}
function Zs(e, t, i, n) {
  e.mounted[t] = i, e.listenerOpts[t] = n, vD(e.domTarget, t, i, n);
}
function Qu(e) {
  var t = e.mounted;
  for (var i in t)
    t.hasOwnProperty(i) && pD(e.domTarget, i, t[i], e.listenerOpts[i]);
  e.mounted = {};
}
var Rp = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = i;
  }
  return e;
})(), iE = (function(e) {
  St(t, e);
  function t(i, n) {
    var r = e.call(this) || this;
    return r.__pointerCapturing = !1, r.dom = i, r.painterRoot = n, r._localHandlerScope = new Rp(i, ii), qu && (r._globalHandlerScope = new Rp(document, Mh)), tE(r, r._localHandlerScope), r;
  }
  return t.prototype.dispose = function() {
    Qu(this._localHandlerScope), qu && Qu(this._globalHandlerScope);
  }, t.prototype.setCursor = function(i) {
    this.dom.style && (this.dom.style.cursor = i || "default");
  }, t.prototype.__togglePointerCapture = function(i) {
    if (this.__mayPointerCapture = null, qu && +this.__pointerCapturing ^ +i) {
      this.__pointerCapturing = i;
      var n = this._globalHandlerScope;
      i ? eE(this, n) : Qu(n);
    }
  }, t;
})(li), o_ = 1;
nt.hasGlobalWindow && (o_ = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var xl = o_, kh = 0.4, Dh = "#333", Eh = "#ccc", nE = "#eee", Op = Nd, Bp = 5e-5;
function En(e) {
  return e > Bp || e < -Bp;
}
var An = [], Pr = [], Ju = Ti(), tc = Math.abs, ir = (function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return En(this.rotation) || En(this.x) || En(this.y) || En(this.scaleX - 1) || En(this.scaleY - 1) || En(this.skewX) || En(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, i = this.needLocalTransform(), n = this.transform;
    if (!(i || t)) {
      n && (Op(n), this.invTransform = null);
      return;
    }
    n = n || Ti(), i ? this.getLocalTransform(n) : Op(n), t && (i ? fo(n, t, n) : Fd(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var i = this.globalScaleRatio;
    if (i != null && i !== 1) {
      this.getGlobalScale(An);
      var n = An[0] < 0 ? -1 : 1, r = An[1] < 0 ? -1 : 1, a = ((An[0] - n) * i + n) / An[0] || 0, o = ((An[1] - r) * i + r) / An[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
    }
    this.invTransform = this.invTransform || Ti(), Wo(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, i = []; t; )
      i.push(t), t = t.parent;
    for (; t = i.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var i = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(a), i = Math.sqrt(i), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = i, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, i = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || Ti(), fo(Pr, t.invTransform, i), i = Pr);
      var n = this.originX, r = this.originY;
      (n || r) && (Ju[4] = n, Ju[5] = r, fo(Pr, i, Ju), Pr[4] -= n, Pr[5] -= r, i = Pr), this.setLocalTransform(i);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var i = this.transform;
    return t = t || [], i ? (t[0] = Math.sqrt(i[0] * i[0] + i[1] * i[1]), t[1] = Math.sqrt(i[2] * i[2] + i[3] * i[3]), i[0] < 0 && (t[0] = -t[0]), i[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, i) {
    var n = [t, i], r = this.invTransform;
    return r && Be(n, n, r), n;
  }, e.prototype.transformCoordToGlobal = function(t, i) {
    var n = [t, i], r = this.transform;
    return r && Be(n, n, r), n;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && tc(t[0] - 1) > 1e-10 && tc(t[3] - 1) > 1e-10 ? Math.sqrt(tc(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    Ah(this, t);
  }, e.getLocalTransform = function(t, i) {
    i = i || [];
    var n = t.originX || 0, r = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, h = t.y, d = t.skewX ? Math.tan(t.skewX) : 0, f = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || r || s || l) {
      var v = n + s, m = r + l;
      i[4] = -v * a - d * m * o, i[5] = -m * o - f * v * a;
    } else
      i[4] = i[5] = 0;
    return i[0] = a, i[3] = o, i[1] = f * a, i[2] = d * o, u && $d(i, i, u), i[4] += n + c, i[5] += r + h, i;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  })(), e;
})(), Eo = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function Ah(e, t) {
  for (var i = 0; i < Eo.length; i++) {
    var n = Eo[i];
    e[n] = t[n];
  }
}
function Mi(e) {
  ps || (ps = new ha(100)), e = e || gn;
  var t = ps.get(e);
  return t || (t = {
    font: e,
    strWidthCache: new ha(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: Ui.measureText("", e).width,
    asciiCharWidth: Ui.measureText("a", e).width
  }, ps.put(e, t)), t;
}
var ps;
function rE(e) {
  if (!(ec >= Np)) {
    e = e || gn;
    for (var t = [], i = +/* @__PURE__ */ new Date(), n = 0; n <= 127; n++)
      t[n] = Ui.measureText(String.fromCharCode(n), e).width;
    var r = +/* @__PURE__ */ new Date() - i;
    return r > 16 ? ec = Np : r > 2 && ec++, t;
  }
}
var ec = 0, Np = 5;
function s_(e, t) {
  return e.asciiWidthMapTried || (e.asciiWidthMap = rE(e.font), e.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? e.asciiWidthMap != null ? e.asciiWidthMap[t] : e.asciiCharWidth : e.stWideCharWidth;
}
function ki(e, t) {
  var i = e.strWidthCache, n = i.get(t);
  return n == null && (n = Ui.measureText(t, e.font).width, i.put(t, n)), n;
}
function Fp(e, t, i, n) {
  var r = ki(Mi(t), e), a = su(t), o = da(0, r, i), s = dr(0, a, n), l = new rt(o, s, r, a);
  return l;
}
function aE(e, t, i, n) {
  var r = ((e || "") + "").split(`
`), a = r.length;
  if (a === 1)
    return Fp(r[0], t, i, n);
  for (var o = new rt(0, 0, 0, 0), s = 0; s < r.length; s++) {
    var l = Fp(r[s], t, i, n);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function da(e, t, i, n) {
  return i === "right" ? n ? e += t : e -= t : i === "center" && (n ? e += t / 2 : e -= t / 2), e;
}
function dr(e, t, i, n) {
  return i === "middle" ? n ? e += t / 2 : e -= t / 2 : i === "bottom" && (n ? e += t : e -= t), e;
}
function su(e) {
  return Mi(e).stWideCharWidth;
}
function Ao(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function l_(e, t, i) {
  var n = t.position || "inside", r = t.distance != null ? t.distance : 5, a = i.height, o = i.width, s = a / 2, l = i.x, u = i.y, c = "left", h = "top";
  if (n instanceof Array)
    l += Ao(n[0], i.width), u += Ao(n[1], i.height), c = null, h = null;
  else
    switch (n) {
      case "left":
        l -= r, u += s, c = "right", h = "middle";
        break;
      case "right":
        l += r + o, u += s, h = "middle";
        break;
      case "top":
        l += o / 2, u -= r, c = "center", h = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + r, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += r, u += s, h = "middle";
        break;
      case "insideRight":
        l += o - r, u += s, c = "right", h = "middle";
        break;
      case "insideTop":
        l += o / 2, u += r, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - r, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += r, u += r;
        break;
      case "insideTopRight":
        l += o - r, u += r, c = "right";
        break;
      case "insideBottomLeft":
        l += r, u += a - r, h = "bottom";
        break;
      case "insideBottomRight":
        l += o - r, u += a - r, c = "right", h = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = h, e;
}
var ic = "__zr_normal__", nc = Eo.concat(["ignore"]), oE = _a(Eo, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), Ir = {}, sE = new rt(0, 0, 0, 0), gs = [], lu = (function() {
  function e(t) {
    this.id = $y(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, i, n) {
    switch (this.draggable) {
      case "horizontal":
        i = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var r = this.transform;
    r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += i, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var i = this._textContent;
    if (i && (!i.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, r = n.local, a = i.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = r ? this : null;
      var u = !1;
      a.copyTransform(i);
      var c = n.position != null, h = n.autoOverflowArea, d = void 0;
      if ((h || c) && (d = sE, n.layoutRect ? d.copy(n.layoutRect) : d.copy(this.getBoundingRect()), r || d.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(Ir, n, d) : l_(Ir, n, d), a.x = Ir.x, a.y = Ir.y, o = Ir.align, s = Ir.verticalAlign;
        var f = n.origin;
        if (f && n.rotation != null) {
          var v = void 0, m = void 0;
          f === "center" ? (v = d.width * 0.5, m = d.height * 0.5) : (v = Ao(f[0], d.width), m = Ao(f[1], d.height)), u = !0, a.originX = -a.x + v + (r ? 0 : d.x), a.originY = -a.y + m + (r ? 0 : d.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var p = n.offset;
      p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
      var g = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (h) {
        var y = g.overflowRect = g.overflowRect || new rt(0, 0, 0, 0);
        a.getLocalTransform(gs), Wo(gs, gs), rt.copy(y, d), y.applyTransform(gs);
      } else
        g.overflowRect = null;
      var _ = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, b = void 0, w = void 0, S = void 0;
      _ && this.canBeInsideText() ? (b = n.insideFill, w = n.insideStroke, (b == null || b === "auto") && (b = this.getInsideTextFill()), (w == null || w === "auto") && (w = this.getInsideTextStroke(b), S = !0)) : (b = n.outsideFill, w = n.outsideStroke, (b == null || b === "auto") && (b = this.getOutsideFill()), (w == null || w === "auto") && (w = this.getOutsideStroke(b), S = !0)), b = b || "#000", (b !== g.fill || w !== g.stroke || S !== g.autoStroke || o !== g.align || s !== g.verticalAlign) && (l = !0, g.fill = b, g.stroke = w, g.autoStroke = S, g.align = o, g.verticalAlign = s, i.setDefaultTextStyle(g)), i.__dirty |= Oe, l && i.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? Eh : Dh;
  }, e.prototype.getOutsideStroke = function(t) {
    var i = this.__zr && this.__zr.getBackgroundColor(), n = typeof i == "string" && Wi(i);
    n || (n = [255, 255, 255, 1]);
    for (var r = n[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      n[o] = n[o] * r + (a ? 0 : 255) * (1 - r);
    return n[3] = 1, hr(n, "rgba");
  }, e.prototype.traverse = function(t, i) {
  }, e.prototype.attrKV = function(t, i) {
    t === "textConfig" ? this.setTextConfig(i) : t === "textContent" ? this.setTextContent(i) : t === "clipPath" ? this.setClipPath(i) : t === "extra" ? (this.extra = this.extra || {}, V(this.extra, i)) : this[t] = i;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, i) {
    if (typeof t == "string")
      this.attrKV(t, i);
    else if (Z(t))
      for (var n = t, r = Bt(n), a = 0; a < r.length; a++) {
        var o = r[a];
        this.attrKV(o, t[o]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var i = this._normalState, n = 0; n < this.animators.length; n++) {
      var r = this.animators[n], a = r.__fromStateTransition;
      if (!(r.getLoop() || a && a !== ic)) {
        var o = r.targetName, s = o ? i[o] : i;
        r.saveTo(s);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var i = this._normalState;
    i || (i = this._normalState = {}), t.textConfig && !i.textConfig && (i.textConfig = this.textConfig), this._savePrimaryToNormal(t, i, nc);
  }, e.prototype._savePrimaryToNormal = function(t, i, n) {
    for (var r = 0; r < n.length; r++) {
      var a = n[r];
      t[a] != null && !(a in i) && (i[a] = this[a]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var i = this.states;
    return i[t] || (i[t] = {}), i[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(ic, !1, t);
  }, e.prototype.useState = function(t, i, n, r) {
    var a = t === ic, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(Pt(s, t) >= 0 && (i || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          lr("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || r);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, i, !n && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, d = this._textGuide;
        return h && h.useState(t, i, n, c), d && d.useState(t, i, n, c), a ? (this.currentStates = [], this._normalState = {}) : i ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Oe), u;
      }
    }
  }, e.prototype.useStates = function(t, i, n) {
    if (!t.length)
      this.clearStates();
    else {
      var r = [], a = this.currentStates, o = t.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (t[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && r.push(c);
      }
      var h = r[o - 1], d = !!(h && h.hoverLayer || n);
      d && this._toggleHoverLayerFlag(!0);
      var f = this._mergeStates(r), v = this.stateTransition;
      this.saveCurrentToNormalState(f), this._applyStateObj(t.join(","), f, this._normalState, !1, !i && !this.__inHover && v && v.duration > 0, v);
      var m = this._textContent, p = this._textGuide;
      m && m.useStates(t, i, d), p && p.useStates(t, i, d), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !d && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Oe);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var i = t.__hostTarget;
      t = i ? t.ignoreHostSilent ? null : i : t.parent;
    }
    return !1;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var i = this.animators[t];
      i.targetName && i.changeTarget(this[i.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var i = Pt(this.currentStates, t);
    if (i >= 0) {
      var n = this.currentStates.slice();
      n.splice(i, 1), this.useStates(n);
    }
  }, e.prototype.replaceState = function(t, i, n) {
    var r = this.currentStates.slice(), a = Pt(r, t), o = Pt(r, i) >= 0;
    a >= 0 ? o ? r.splice(a, 1) : r[a] = i : n && !o && r.push(i), this.useStates(r);
  }, e.prototype.toggleState = function(t, i) {
    i ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var i = {}, n, r = 0; r < t.length; r++) {
      var a = t[r];
      V(i, a), a.textConfig && (n = n || {}, V(n, a.textConfig));
    }
    return n && (i.textConfig = n), i;
  }, e.prototype._applyStateObj = function(t, i, n, r, a, o) {
    var s = !(i && r);
    i && i.textConfig ? (this.textConfig = V({}, r ? this.textConfig : n.textConfig), V(this.textConfig, i.textConfig)) : s && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < nc.length; c++) {
      var h = nc[c], d = a && oE[h];
      i && i[h] != null ? d ? (u = !0, l[h] = i[h]) : this[h] = i[h] : s && n[h] != null && (d ? (u = !0, l[h] = n[h]) : this[h] = n[h]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], v = f.targetName;
        f.getLoop() || f.__changeFinalValue(v ? (i || n)[v] : i || n);
      }
    u && this._transitionState(t, l, o);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var i = this.__zr;
    i && t.addSelfToZr(i), t.__zr = i, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var i = this._textContent;
    if (i !== t) {
      if (i && i !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new ir(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), V(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= Oe;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var i = this._textContent, n = this._textGuide;
    i && (i.__inHover = t), n && (n.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.addAnimator(i[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.removeAnimator(i[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, i, n) {
    var r = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !r) {
      lr('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new zd(r, i, n);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, e.prototype.addAnimator = function(t, i) {
    var n = this.__zr, r = this;
    t.during(function() {
      r.updateDuringAnimation(i);
    }).done(function() {
      var a = r.animators, o = Pt(a, t);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, i) {
    for (var n = this.animators, r = n.length, a = [], o = 0; o < r; o++) {
      var s = n[o];
      !t || t === s.scope ? s.stop(i) : a.push(s);
    }
    return this.animators = a, this;
  }, e.prototype.animateTo = function(t, i, n) {
    rc(this, t, i, n);
  }, e.prototype.animateFrom = function(t, i, n) {
    rc(this, t, i, n, !0);
  }, e.prototype._transitionState = function(t, i, n, r) {
    for (var a = rc(this, i, n, r), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = Oe;
    var i = {};
    function n(a, o, s) {
      i[a + o + s] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + o + "', '" + s + "' instead"), i[a + o + s] = !0);
    }
    function r(a, o, s, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(a, s, l), !this[o]) {
            var c = this[o] = [];
            u(this, c);
          }
          return this[o];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(a, s, l), this[s] = c[0], this[l] = c[1], this[o] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[s];
          },
          set: function(d) {
            c[s] = d;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(d) {
            c[l] = d;
          }
        });
      }
    }
    Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
  })(), e;
})();
si(lu, li);
si(lu, ir);
function rc(e, t, i, n, r) {
  i = i || {};
  var a = [];
  u_(e, "", e, t, i, n, a, r);
  var o = a.length, s = !1, l = i.done, u = i.aborted, c = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, h = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && i.during && a[0].during(function(v, m) {
    i.during(m);
  });
  for (var d = 0; d < a.length; d++) {
    var f = a[d];
    c && f.done(c), h && f.aborted(h), i.force && f.duration(i.duration), f.start(i.easing);
  }
  return a;
}
function ac(e, t, i) {
  for (var n = 0; n < i; n++)
    e[n] = t[n];
}
function lE(e) {
  return Ae(e[0]);
}
function uE(e, t, i) {
  if (Ae(t[i]))
    if (Ae(e[i]) || (e[i] = []), be(t[i])) {
      var n = t[i].length;
      e[i].length !== n && (e[i] = new t[i].constructor(n), ac(e[i], t[i], n));
    } else {
      var r = t[i], a = e[i], o = r.length;
      if (lE(r))
        for (var s = r[0].length, l = 0; l < o; l++)
          a[l] ? ac(a[l], r[l], s) : a[l] = Array.prototype.slice.call(r[l]);
      else
        ac(a, r, o);
      a.length = r.length;
    }
  else
    e[i] = t[i];
}
function cE(e, t) {
  return e === t || Ae(e) && Ae(t) && hE(e, t);
}
function hE(e, t) {
  var i = e.length;
  if (i !== t.length)
    return !1;
  for (var n = 0; n < i; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function u_(e, t, i, n, r, a, o, s) {
  for (var l = Bt(n), u = r.duration, c = r.delay, h = r.additive, d = r.setToFinal, f = !Z(a), v = e.animators, m = [], p = 0; p < l.length; p++) {
    var g = l[p], y = n[g];
    if (y != null && i[g] != null && (f || a[g]))
      if (Z(y) && !Ae(y) && !au(y)) {
        if (t) {
          s || (i[g] = y, e.updateDuringAnimation(t));
          continue;
        }
        u_(e, g, i[g], y, r, a && a[g], o, s);
      } else
        m.push(g);
    else s || (i[g] = y, e.updateDuringAnimation(t), m.push(g));
  }
  var _ = m.length;
  if (!h && _)
    for (var b = 0; b < v.length; b++) {
      var w = v[b];
      if (w.targetName === t) {
        var S = w.stopTracks(m);
        if (S) {
          var C = Pt(v, w);
          v.splice(C, 1);
        }
      }
    }
  if (r.force || (m = Re(m, function(D) {
    return !cE(n[D], i[D]);
  }), _ = m.length), _ > 0 || r.force && !o.length) {
    var T = void 0, k = void 0, M = void 0;
    if (s) {
      k = {}, d && (T = {});
      for (var b = 0; b < _; b++) {
        var g = m[b];
        k[g] = i[g], d ? T[g] = n[g] : i[g] = n[g];
      }
    } else if (d) {
      M = {};
      for (var b = 0; b < _; b++) {
        var g = m[b];
        M[g] = Xs(i[g]), uE(i, n, g);
      }
    }
    var w = new zd(i, !1, !1, h ? Re(v, function(L) {
      return L.targetName === t;
    }) : null);
    w.targetName = t, r.scope && (w.scope = r.scope), d && T && w.whenWithKeys(0, T, m), M && w.whenWithKeys(0, M, m), w.whenWithKeys(u ?? 500, s ? k : n, m).delay(c || 0), e.addAnimator(w, t), o.push(w);
  }
}
var oi = (function(e) {
  St(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(i) {
    return this._children[i];
  }, t.prototype.childOfName = function(i) {
    for (var n = this._children, r = 0; r < n.length; r++)
      if (n[r].name === i)
        return n[r];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(i) {
    if (i && (i !== this && i.parent !== this && (this._children.push(i), this._doAdd(i)), process.env.NODE_ENV !== "production" && i.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(i, n) {
    if (i && i !== this && i.parent !== this && n && n.parent === this) {
      var r = this._children, a = r.indexOf(n);
      a >= 0 && (r.splice(a, 0, i), this._doAdd(i));
    }
    return this;
  }, t.prototype.replace = function(i, n) {
    var r = Pt(this._children, i);
    return r >= 0 && this.replaceAt(n, r), this;
  }, t.prototype.replaceAt = function(i, n) {
    var r = this._children, a = r[n];
    if (i && i !== this && i.parent !== this && i !== a) {
      r[n] = i, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(i);
    }
    return this;
  }, t.prototype._doAdd = function(i) {
    i.parent && i.parent.remove(i), i.parent = this;
    var n = this.__zr;
    n && n !== i.__zr && i.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(i) {
    var n = this.__zr, r = this._children, a = Pt(r, i);
    return a < 0 ? this : (r.splice(a, 1), i.parent = null, n && i.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var i = this._children, n = this.__zr, r = 0; r < i.length; r++) {
      var a = i[r];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return i.length = 0, this;
  }, t.prototype.eachChild = function(i, n) {
    for (var r = this._children, a = 0; a < r.length; a++) {
      var o = r[a];
      i.call(n, o, a);
    }
    return this;
  }, t.prototype.traverse = function(i, n) {
    for (var r = 0; r < this._children.length; r++) {
      var a = this._children[r], o = i.call(n, a);
      a.isGroup && !o && a.traverse(i, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.addSelfToZr(i);
    }
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.removeSelfFromZr(i);
    }
  }, t.prototype.getBoundingRect = function(i) {
    for (var n = new rt(0, 0, 0, 0), r = i || this._children, a = [], o = null, s = 0; s < r.length; s++) {
      var l = r[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (rt.applyTransform(n, u, c), o = o || n.clone(), o.union(n)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || n;
  }, t;
})(lu);
oi.prototype.type = "group";
var eo = {}, c_ = {};
function dE(e) {
  delete c_[e];
}
function fE(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return bl(e, 1) < kh;
  if (e.colorStops) {
    for (var t = e.colorStops, i = 0, n = t.length, r = 0; r < n; r++)
      i += bl(t[r].color, 1);
    return i /= n, i < kh;
  }
  return !1;
}
var vE = (function() {
  function e(t, i, n) {
    var r = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = i, this.id = t;
    var a = new AD(), o = n.renderer || "canvas";
    if (eo[o] || (o = Bt(eo)[0]), process.env.NODE_ENV !== "production" && !eo[o])
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var s = new eo[o](i, a, n, t), l = n.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !nt.node && !nt.worker && !l ? new iE(s.getViewportRoot(), s.root) : null, c = n.useCoarsePointer, h = c == null || c === "auto" ? nt.touchEventsSupported : !!c, d = 44, f;
    h && (f = tt(n.pointerSize, d)), this.handler = new Xy(a, s, u, s.root, f), this.animation = new qD({
      stage: {
        update: l ? null : function() {
          return r._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, i) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, i), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = fE(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var i, n = Qr();
    this._needsRefresh && (i = !0, this.refreshImmediately(t)), this._needsRefreshHover && (i = !0, this.refreshHoverImmediately());
    var r = Qr();
    i ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: r - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, i) {
    if (!this._disposed)
      return this.handler.findHover(t, i);
  }, e.prototype.on = function(t, i, n) {
    return this._disposed || this.handler.on(t, i, n), this;
  }, e.prototype.off = function(t, i) {
    this._disposed || this.handler.off(t, i);
  }, e.prototype.trigger = function(t, i) {
    this._disposed || this.handler.trigger(t, i);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), i = 0; i < t.length; i++)
        t[i] instanceof oi && t[i].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, dE(this.id));
  }, e;
})();
function $p(e, t) {
  var i = new vE($y(), e, t);
  return c_[i.id] = i, i;
}
function pE(e, t) {
  eo[e] = t;
}
var zp = 1e-4, h_ = 20;
function gE(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
var Lo = Math.min, ri = Math.max, Vi = Math.abs;
function Po(e, t, i, n) {
  var r = t[0], a = t[1], o = i[0], s = i[1], l = a - r, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (l > 0) {
    if (e <= r)
      return o;
    if (e >= a)
      return s;
  } else {
    if (e >= r)
      return o;
    if (e <= a)
      return s;
  }
  return (e - r) / l * u + o;
}
var Me = mE;
function mE(e, t, i) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return yE(e, t, i);
}
function yE(e, t, i) {
  return K(e) ? gE(e).match(/%$/) ? parseFloat(e) / 100 * t + (i || 0) : parseFloat(e) : e == null ? NaN : +e;
}
function _E(e, t, i) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), h_), e = (+e).toFixed(t), i ? e : +e;
}
function Vp(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, i = 0; i < 15; i++, t *= 10)
      if (Math.round(e * t) / t === e)
        return i;
  }
  return bE(e);
}
function bE(e) {
  var t = e.toString().toLowerCase(), i = t.indexOf("e"), n = i > 0 ? +t.slice(i + 1) : 0, r = i > 0 ? i : t.length, a = t.indexOf("."), o = a < 0 ? 0 : r - 1 - a;
  return Math.max(0, o - n);
}
function xE(e, t) {
  var i = Math.max(Vp(e), Vp(t)), n = e + t;
  return i > h_ ? n : _E(n, i);
}
function d_(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function wl(e) {
  return e > -zp && e < zp;
}
var wE = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function uu(e) {
  if (e instanceof Date)
    return e;
  if (K(e)) {
    var t = wE.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var i = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (i -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, i, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function Sl(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !K(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function f_(e) {
  return !isNaN(Sl(e));
}
function v_() {
  return Math.round(Math.random() * 9);
}
function p_(e, t) {
  return t === 0 ? e : p_(t, e % t);
}
function Hp(e, t) {
  return e == null ? t : t == null ? e : e * t / p_(e, t);
}
var SE = "[ECharts] ", Wp = {}, CE = typeof console < "u" && console.warn && console.log;
function cu(e, t, i) {
  if (CE) {
    if (i) {
      if (Wp[t])
        return;
      Wp[t] = !0;
    }
    console[e](SE + t);
  }
}
function TE(e, t) {
  cu("log", e, t);
}
function Xe(e, t) {
  cu("warn", e, t);
}
function Ft(e, t) {
  cu("error", e, t);
}
function Gi(e) {
  process.env.NODE_ENV !== "production" && cu("warn", "DEPRECATED: " + e, !0);
}
function ee(e, t, i) {
  process.env.NODE_ENV !== "production" && Gi((i ? "[" + i + "]" : "") + (e + " is deprecated; use " + t + " instead."));
}
function Cl() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var i = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(r) {
      return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : zy(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : ht(r) ? "function () { ... }" : Wk(r) ? r + "" : null;
    };
    i = dt(e, function(r) {
      if (K(r))
        return r;
      var a = n(r);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(r, function(o, s) {
            var l = n(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return i;
}
function ke(e) {
  throw new Error(e);
}
var g_ = "series\0", ME = "\0_ec_\0";
function ye(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function Yp(e, t, i) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var n = 0, r = i.length; n < r; n++) {
      var a = i[n];
      !e.emphasis[t].hasOwnProperty(a) && e[t].hasOwnProperty(a) && (e.emphasis[t][a] = e[t][a]);
    }
  }
}
var Up = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function Yo(e) {
  return Z(e) && !j(e) && !(e instanceof Date) ? e.value : e;
}
function kE(e) {
  return Z(e) && !(e instanceof Array);
}
function DE(e, t, i) {
  var n = i === "normalMerge", r = i === "replaceMerge", a = i === "replaceAll";
  e = e || [], t = (t || []).slice();
  var o = ot();
  E(t, function(l, u) {
    if (!Z(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !Xp(l.id) && Gp(l.id), l.name != null && !Xp(l.name) && Gp(l.name));
  });
  var s = EE(e, o, i);
  return (n || r) && AE(s, e, o, t), n && LE(s, t), n || r ? PE(s, t, r) : a && IE(s, t), RE(s), s;
}
function EE(e, t, i) {
  var n = [];
  if (i === "replaceAll")
    return n;
  for (var r = 0; r < e.length; r++) {
    var a = e[r];
    a && a.id != null && t.set(a.id, r), n.push({
      existing: i === "replaceMerge" || fa(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function AE(e, t, i, n) {
  E(n, function(r, a) {
    if (!(!r || r.id == null)) {
      var o = go(r.id), s = i.get(o);
      if (s != null) {
        var l = e[s];
        J(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = r, l.existing = t[s], n[a] = null;
      }
    }
  });
}
function LE(e, t) {
  E(t, function(i, n) {
    if (!(!i || i.name == null))
      for (var r = 0; r < e.length; r++) {
        var a = e[r].existing;
        if (!e[r].newOption && a && (a.id == null || i.id == null) && !fa(i) && !fa(a) && m_("name", a, i)) {
          e[r].newOption = i, t[n] = null;
          return;
        }
      }
  });
}
function PE(e, t, i) {
  E(t, function(n) {
    if (n) {
      for (
        var r, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (r = e[a]) && (r.newOption || fa(r.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        r.existing && n.id != null && !m_("id", n, r.existing));
      )
        a++;
      r ? (r.newOption = n, r.brandNew = i) : e.push({
        newOption: n,
        brandNew: i,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function IE(e, t) {
  E(t, function(i) {
    e.push({
      newOption: i,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function RE(e) {
  var t = ot();
  E(e, function(i) {
    var n = i.existing;
    n && t.set(n.id, i);
  }), E(e, function(i) {
    var n = i.newOption;
    J(!n || n.id == null || !t.get(n.id) || t.get(n.id) === i, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, i), !i.keyInfo && (i.keyInfo = {});
  }), E(e, function(i, n) {
    var r = i.existing, a = i.newOption, o = i.keyInfo;
    if (Z(a)) {
      if (o.name = a.name != null ? go(a.name) : r ? r.name : g_ + n, r)
        o.id = go(r.id);
      else if (a.id != null)
        o.id = go(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (t.get(o.id));
      }
      t.set(o.id, i);
    }
  });
}
function m_(e, t, i) {
  var n = ai(t[e], null), r = ai(i[e], null);
  return n != null && r != null && n === r;
}
function go(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return ai(e, "");
}
function ai(e, t) {
  return e == null ? t : K(e) ? e : Nt(e) || dl(e) ? e + "" : t;
}
function Gp(e) {
  process.env.NODE_ENV !== "production" && Xe("`" + e + "` is invalid id or name. Must be a string or number.");
}
function Xp(e) {
  return dl(e) || f_(e);
}
function y_(e) {
  var t = e.name;
  return !!(t && t.indexOf(g_));
}
function fa(e) {
  return e && e.id != null && go(e.id).indexOf(ME) === 0;
}
function OE(e, t, i) {
  E(e, function(n) {
    var r = n.newOption;
    Z(r) && (n.keyInfo.mainType = t, n.keyInfo.subType = BE(t, r, n.existing, i));
  });
}
function BE(e, t, i, n) {
  var r = t.type ? t.type : i ? i.subType : n.determineSubType(e, t);
  return r;
}
function Uo(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return j(t.dataIndex) ? dt(t.dataIndex, function(i) {
      return e.indexOfRawIndex(i);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return j(t.name) ? dt(t.name, function(i) {
      return e.indexOfName(i);
    }) : e.indexOfName(t.name);
}
function It() {
  var e = "__ec_inner_" + NE++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var NE = v_();
function oc(e, t, i) {
  var n = Vd(t, i), r = n.mainTypeSpecified, a = n.queryOptionMap, o = n.others, s = o, l = i ? i.defaultMainType : null;
  return !r && l && a.set(l, {}), a.each(function(u, c) {
    var h = Go(e, c, u, {
      useDefault: l === c,
      enableAll: i && i.enableAll != null ? i.enableAll : !0,
      enableNone: i && i.enableNone != null ? i.enableNone : !0
    });
    s[c + "Models"] = h.models, s[c + "Model"] = h.models[0];
  }), s;
}
function Vd(e, t) {
  var i;
  if (K(e)) {
    var n = {};
    n[e + "Index"] = 0, i = n;
  } else
    i = e;
  var r = ot(), a = {}, o = !1;
  return E(i, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || t && t.includeMainTypes && Pt(t.includeMainTypes, c) < 0)) {
      o = o || !!c;
      var d = r.get(c) || r.set(c, {});
      d[h] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: r,
    others: a
  };
}
var rn = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
};
function Go(e, t, i, n) {
  n = n || rn;
  var r = i.index, a = i.id, o = i.name, s = {
    models: null,
    specified: r != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = n.useDefault && (l = e.getComponent(t)) ? [l] : [], s;
  }
  if (r === "none" || r === !1) {
    if (n.enableNone)
      return s.models = [], s;
    process.env.NODE_ENV !== "production" && Ft('`"none"` or `false` is not a valid value on index option.'), r = -1;
  }
  return r === "all" && (n.enableAll ? r = a = o = null : (process.env.NODE_ENV !== "production" && Ft('`"all"` is not a valid value on index option.'), r = -1)), s.models = e.queryComponents({
    mainType: t,
    index: r,
    id: a,
    name: o
  }), s;
}
function __(e, t, i) {
  e.setAttribute ? e.setAttribute(t, i) : e[t] = i;
}
function FE(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function $E(e) {
  return e === "auto" ? nt.domSupported ? "html" : "richText" : e || "html";
}
function zE(e, t) {
  var i = ot(), n = [];
  return E(e, function(r) {
    var a = t(r);
    (i.get(a) || (n.push(a), i.set(a, []))).push(r);
  }), {
    keys: n,
    buckets: i
  };
}
var VE = ".", Ln = "___EC__COMPONENT__CONTAINER___", b_ = "___EC__EXTENDED_CLASS___";
function wi(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var i = e.split(VE);
    t.main = i[0] || "", t.sub = i[1] || "";
  }
  return t;
}
function HE(e) {
  J(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function WE(e) {
  return !!(e && e[b_]);
}
function Hd(e, t) {
  e.$constructor = e, e.extend = function(i) {
    process.env.NODE_ENV !== "production" && E(t, function(a) {
      i[a] || console.warn("Method `" + a + "` should be implemented" + (i.type ? " in " + i.type : "") + ".");
    });
    var n = this, r;
    return YE(n) ? r = /** @class */
    (function(a) {
      Xt(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    })(n) : (r = function() {
      (i.$constructor || n).apply(this, arguments);
    }, zk(r, this)), V(r.prototype, i), r[b_] = !0, r.extend = this.extend, r.superCall = XE, r.superApply = jE, r.superClass = n, r;
  };
}
function YE(e) {
  return ht(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function x_(e, t) {
  e.extend = t.extend;
}
var UE = Math.round(Math.random() * 10);
function GE(e) {
  var t = ["__\0is_clz", UE++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && J(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(i) {
    return !!(i && i[t]);
  };
}
function XE(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(e, i);
}
function jE(e, t, i) {
  return this.superClass.prototype[t].apply(e, i);
}
function Wd(e) {
  var t = {};
  e.registerClass = function(n) {
    var r = n.type || n.prototype.type;
    if (r) {
      HE(r), n.prototype.type = r;
      var a = wi(r);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = n;
      else if (a.sub !== Ln) {
        var o = i(a);
        o[a.sub] = n;
      }
    }
    return n;
  }, e.getClass = function(n, r, a) {
    var o = t[n];
    if (o && o[Ln] && (o = r ? o[r] : null), a && !o)
      throw new Error(r ? "Component " + n + "." + (r || "") + " is used but not imported." : n + ".type should be specified.");
    return o;
  }, e.getClassesByMainType = function(n) {
    var r = wi(n), a = [], o = t[r.main];
    return o && o[Ln] ? E(o, function(s, l) {
      l !== Ln && a.push(s);
    }) : a.push(o), a;
  }, e.hasClass = function(n) {
    var r = wi(n);
    return !!t[r.main];
  }, e.getAllClassMainTypes = function() {
    var n = [];
    return E(t, function(r, a) {
      n.push(a);
    }), n;
  }, e.hasSubTypes = function(n) {
    var r = wi(n), a = t[r.main];
    return a && a[Ln];
  };
  function i(n) {
    var r = t[n.main];
    return (!r || !r[Ln]) && (r = t[n.main] = {}, r[Ln] = !0), r;
  }
}
function Io(e, t) {
  for (var i = 0; i < e.length; i++)
    e[i][1] || (e[i][1] = e[i][0]);
  return t = t || !1, function(n, r, a) {
    for (var o = {}, s = 0; s < e.length; s++) {
      var l = e[s][1];
      if (!(r && Pt(r, l) >= 0 || a && Pt(a, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (o[e[s][0]] = u);
      }
    }
    return o;
  };
}
var qE = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], ZE = Io(qE), KE = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, i) {
      return ZE(this, t, i);
    }, e;
  })()
), Lh = new ha(50);
function QE(e) {
  if (typeof e == "string") {
    var t = Lh.get(e);
    return t && t.image;
  } else
    return e;
}
function w_(e, t, i, n, r) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !i)
        return t;
      var a = Lh.get(e), o = { hostEl: i, cb: n, cbPayload: r };
      return a ? (t = a.image, !hu(t) && a.pending.push(o)) : (t = Ui.loadImage(e, jp, jp), t.__zrImageSrc = e, Lh.put(e, t.__cachedImgObj = {
        image: t,
        pending: [o]
      })), t;
    } else
      return e;
  else return t;
}
function jp() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var i = e.pending[t], n = i.cb;
    n && n(this, i.cbPayload), i.hostEl.dirty();
  }
  e.pending.length = 0;
}
function hu(e) {
  return e && e.width && e.height;
}
var sc = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function JE(e, t, i, n, r, a) {
  if (!i) {
    e.text = "", e.isTruncated = !1;
    return;
  }
  var o = (t + "").split(`
`);
  a = S_(i, n, r, a);
  for (var s = !1, l = {}, u = 0, c = o.length; u < c; u++)
    C_(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
  e.text = o.join(`
`), e.isTruncated = s;
}
function S_(e, t, i, n) {
  n = n || {};
  var r = V({}, n);
  i = tt(i, "..."), r.maxIterations = tt(n.maxIterations, 2);
  var a = r.minChar = tt(n.minChar, 0), o = r.fontMeasureInfo = Mi(t), s = o.asciiCharWidth;
  r.placeholder = tt(n.placeholder, "");
  for (var l = e = Math.max(0, e - 1), u = 0; u < a && l >= s; u++)
    l -= s;
  var c = ki(o, i);
  return c > l && (i = "", c = 0), l = e - c, r.ellipsis = i, r.ellipsisWidth = c, r.contentWidth = l, r.containerWidth = e, r;
}
function C_(e, t, i) {
  var n = i.containerWidth, r = i.contentWidth, a = i.fontMeasureInfo;
  if (!n) {
    e.textLine = "", e.isTruncated = !1;
    return;
  }
  var o = ki(a, t);
  if (o <= n) {
    e.textLine = t, e.isTruncated = !1;
    return;
  }
  for (var s = 0; ; s++) {
    if (o <= r || s >= i.maxIterations) {
      t += i.ellipsis;
      break;
    }
    var l = s === 0 ? tA(t, r, a) : o > 0 ? Math.floor(t.length * r / o) : 0;
    t = t.substr(0, l), o = ki(a, t);
  }
  t === "" && (t = i.placeholder), e.textLine = t, e.isTruncated = !0;
}
function tA(e, t, i) {
  for (var n = 0, r = 0, a = e.length; r < a && n < t; r++)
    n += s_(i, e.charCodeAt(r));
  return r;
}
function eA(e, t, i, n) {
  var r = Yd(e), a = t.overflow, o = t.padding, s = o ? o[1] + o[3] : 0, l = o ? o[0] + o[2] : 0, u = t.font, c = a === "truncate", h = su(u), d = tt(t.lineHeight, h), f = t.lineOverflow === "truncate", v = !1, m = t.width;
  m == null && i != null && (m = i - s);
  var p = t.height;
  p == null && n != null && (p = n - l);
  var g;
  m != null && (a === "break" || a === "breakAll") ? g = r ? T_(r, t.font, m, a === "breakAll", 0).lines : [] : g = r ? r.split(`
`) : [];
  var y = g.length * d;
  if (p == null && (p = y), y > p && f) {
    var _ = Math.floor(p / d);
    v = v || g.length > _, g = g.slice(0, _), y = g.length * d;
  }
  if (r && c && m != null)
    for (var b = S_(m, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), w = {}, S = 0; S < g.length; S++)
      C_(w, g[S], b), g[S] = w.textLine, v = v || w.isTruncated;
  for (var C = p, T = 0, k = Mi(u), S = 0; S < g.length; S++)
    T = Math.max(ki(k, g[S]), T);
  m == null && (m = T);
  var M = m;
  return C += l, M += s, {
    lines: g,
    height: p,
    outerWidth: M,
    outerHeight: C,
    lineHeight: d,
    calculatedLineHeight: h,
    contentWidth: T,
    contentHeight: y,
    width: m,
    isTruncated: v
  };
}
var iA = /* @__PURE__ */ (function() {
  function e() {
  }
  return e;
})(), qp = /* @__PURE__ */ (function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
})(), nA = /* @__PURE__ */ (function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return e;
})();
function rA(e, t, i, n, r) {
  var a = new nA(), o = Yd(e);
  if (!o)
    return a;
  var s = t.padding, l = s ? s[1] + s[3] : 0, u = s ? s[0] + s[2] : 0, c = t.width;
  c == null && i != null && (c = i - l);
  var h = t.height;
  h == null && n != null && (h = n - u);
  for (var d = t.overflow, f = (d === "break" || d === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: d === "breakAll" } : null, v = sc.lastIndex = 0, m; (m = sc.exec(o)) != null; ) {
    var p = m.index;
    p > v && lc(a, o.substring(v, p), t, f), lc(a, m[2], t, f, m[1]), v = sc.lastIndex;
  }
  v < o.length && lc(a, o.substring(v, o.length), t, f);
  var g = [], y = 0, _ = 0, b = d === "truncate", w = t.lineOverflow === "truncate", S = {};
  function C(yt, ie, ve) {
    yt.width = ie, yt.lineHeight = ve, y += ve, _ = Math.max(_, ie);
  }
  t: for (var T = 0; T < a.lines.length; T++) {
    for (var k = a.lines[T], M = 0, D = 0, L = 0; L < k.tokens.length; L++) {
      var P = k.tokens[L], R = P.styleName && t.rich[P.styleName] || {}, B = P.textPadding = R.padding, F = B ? B[1] + B[3] : 0, W = P.font = R.font || t.font;
      P.contentHeight = su(W);
      var z = tt(R.height, P.contentHeight);
      if (P.innerHeight = z, B && (z += B[0] + B[2]), P.height = z, P.lineHeight = ur(R.lineHeight, t.lineHeight, z), P.align = R && R.align || r, P.verticalAlign = R && R.verticalAlign || "middle", w && h != null && y + P.lineHeight > h) {
        var N = a.lines.length;
        L > 0 ? (k.tokens = k.tokens.slice(0, L), C(k, D, M), a.lines = a.lines.slice(0, T + 1)) : a.lines = a.lines.slice(0, T), a.isTruncated = a.isTruncated || a.lines.length < N;
        break t;
      }
      var $ = R.width, X = $ == null || $ === "auto";
      if (typeof $ == "string" && $.charAt($.length - 1) === "%")
        P.percentWidth = $, g.push(P), P.contentWidth = ki(Mi(W), P.text);
      else {
        if (X) {
          var U = R.backgroundColor, Q = U && U.image;
          Q && (Q = QE(Q), hu(Q) && (P.width = Math.max(P.width, Q.width * z / Q.height)));
        }
        var it = b && c != null ? c - D : null;
        it != null && it < P.width ? !X || it < F ? (P.text = "", P.width = P.contentWidth = 0) : (JE(S, P.text, it - F, W, t.ellipsis, { minChar: t.truncateMinChar }), P.text = S.text, a.isTruncated = a.isTruncated || S.isTruncated, P.width = P.contentWidth = ki(Mi(W), P.text)) : P.contentWidth = ki(Mi(W), P.text);
      }
      P.width += F, D += P.width, R && (M = Math.max(M, P.lineHeight));
    }
    C(k, D, M);
  }
  a.outerWidth = a.width = tt(c, _), a.outerHeight = a.height = tt(h, y), a.contentHeight = y, a.contentWidth = _, a.outerWidth += l, a.outerHeight += u;
  for (var T = 0; T < g.length; T++) {
    var P = g[T], ft = P.percentWidth;
    P.width = parseInt(ft, 10) / 100 * a.width;
  }
  return a;
}
function lc(e, t, i, n, r) {
  var a = t === "", o = r && i.rich[r] || {}, s = e.lines, l = o.font || i.font, u = !1, c, h;
  if (n) {
    var d = o.padding, f = d ? d[1] + d[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var v = Ao(o.width, n.width) + f;
      s.length > 0 && v + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = v;
    } else {
      var m = T_(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = m.accumWidth + f, h = m.linesWidths, c = m.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var p = Mi(l), g = 0; g < c.length; g++) {
    var y = c[g], _ = new iA();
    if (_.styleName = r, _.text = y, _.isLineHolder = !y && !a, typeof o.width == "number" ? _.width = o.width : _.width = h ? h[g] : ki(p, y), !g && !u) {
      var b = (s[s.length - 1] || (s[0] = new qp())).tokens, w = b.length;
      w === 1 && b[0].isLineHolder ? b[0] = _ : (y || !w || a) && b.push(_);
    } else
      s.push(new qp([_]));
  }
}
function aA(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var oA = _a(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function sA(e) {
  return aA(e) ? !!oA[e] : !0;
}
function T_(e, t, i, n, r) {
  for (var a = [], o = [], s = "", l = "", u = 0, c = 0, h = Mi(t), d = 0; d < e.length; d++) {
    var f = e.charAt(d);
    if (f === `
`) {
      l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var v = s_(h, f.charCodeAt(0)), m = n ? !1 : !sA(f);
    if (a.length ? c + v > i : r + c + v > i) {
      c ? (s || l) && (m ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += f, u += v, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = f, c = v)) : m ? (a.push(l), o.push(u), l = f, u = v) : (a.push(f), o.push(v));
      continue;
    }
    c += v, m ? (l += f, u += v) : (l && (s += l, l = "", u = 0), s += f);
  }
  return l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += r), {
    accumWidth: c,
    lines: a,
    linesWidths: o
  };
}
function Zp(e, t, i, n, r, a) {
  if (e.baseX = i, e.baseY = n, e.outerWidth = e.outerHeight = null, !!t) {
    var o = t.width * 2, s = t.height * 2;
    rt.set(Kp, da(i, o, r), dr(n, s, a), o, s), rt.intersect(t, Kp, null, Qp);
    var l = Qp.outIntersectRect;
    e.outerWidth = l.width, e.outerHeight = l.height, e.baseX = da(l.x, l.width, r, !0), e.baseY = dr(l.y, l.height, a, !0);
  }
}
var Kp = new rt(0, 0, 0, 0), Qp = { outIntersectRect: {}, clamp: !0 };
function Yd(e) {
  return e != null ? e += "" : e = "";
}
function lA(e) {
  var t = Yd(e.text), i = e.font, n = ki(Mi(i), t), r = su(i);
  return Ph(e, n, r, null);
}
function Ph(e, t, i, n) {
  var r = new rt(da(e.x || 0, t, e.textAlign), dr(e.y || 0, i, e.textBaseline), t, i), a = n ?? (M_(e) ? e.lineWidth : 0);
  return a > 0 && (r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a), r;
}
function M_(e) {
  var t = e.stroke;
  return t != null && t !== "none" && e.lineWidth > 0;
}
var Ih = "__zr_style_" + Math.round(Math.random() * 10), fr = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, du = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
fr[Ih] = !0;
var Jp = ["z", "z2", "invisible"], uA = ["invisible"], Xo = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype._init = function(i) {
    for (var n = Bt(i), r = 0; r < n.length; r++) {
      var a = n[r];
      a === "style" ? this.useStyle(i[a]) : e.prototype.attrKV.call(this, a, i[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(i, n, r, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && cA(this, i, n) || o && !o[0] && !o[3])
      return !1;
    if (r && this.__clipPaths && this.__clipPaths.length) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(i, n) {
    return this.rectContain(i, n);
  }, t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.rectContain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    return a.contain(r[0], r[1]);
  }, t.prototype.getPaintRect = function() {
    var i = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, r = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      i = this._paintRect || (this._paintRect = new rt(0, 0, 0, 0)), n ? rt.applyTransform(i, r, n) : i.copy(r), (o || s || l) && (i.width += o * 2 + Math.abs(s), i.height += o * 2 + Math.abs(l), i.x = Math.min(i.x, i.x + s - o), i.y = Math.min(i.y, i.y + l - o));
      var u = this.dirtyRectTolerance;
      i.isZero() || (i.x = Math.floor(i.x - u), i.y = Math.floor(i.y - u), i.width = Math.ceil(i.width + 1 + u * 2), i.height = Math.ceil(i.height + 1 + u * 2));
    }
    return i;
  }, t.prototype.setPrevPaintRect = function(i) {
    i ? (this._prevPaintRect = this._prevPaintRect || new rt(0, 0, 0, 0), this._prevPaintRect.copy(i)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(i) {
    return this.animate("style", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i !== "style" ? e.prototype.attrKV.call(this, i, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(i, n) {
    return typeof i == "string" ? this.style[i] = n : V(this.style, i), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(i) {
    i || this.markRedraw(), this.__dirty |= Ja, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & Ja);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~Ja;
  }, t.prototype.createStyle = function(i) {
    return ou(fr, i);
  }, t.prototype.useStyle = function(i) {
    i[Ih] || (i = this.createStyle(i)), this.__inHover ? this.__hoverStyle = i : this.style = i, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(i) {
    return i[Ih];
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(i, n, Jp);
  }, t.prototype._applyStateObj = function(i, n, r, a, o, s) {
    e.prototype._applyStateObj.call(this, i, n, r, a, o, s);
    var l = !(n && a), u;
    if (n && n.style ? o ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, n.style)) : l && (u = r.style), u)
      if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = Bt(c), d = 0; d < h.length; d++) {
            var f = h[d];
            f in u && (u[f] = u[f], this.style[f] = c[f]);
          }
        for (var v = Bt(u), d = 0; d < v.length; d++) {
          var f = v[d];
          this.style[f] = this.style[f];
        }
        this._transitionState(i, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var m = this.__inHover ? uA : Jp, d = 0; d < m.length; d++) {
      var f = m[d];
      n && n[f] != null ? this[f] = n[f] : l && r[f] != null && (this[f] = r[f]);
    }
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var o = i[a];
      o.style && (r = r || {}, this._mergeStyle(r, o.style));
    }
    return r && (n.style = r), n;
  }, t.prototype._mergeStyle = function(i, n) {
    return V(i, n), i;
  }, t.prototype.getAnimationStyleProps = function() {
    return du;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "displayable", i.invisible = !1, i.z = 0, i.z2 = 0, i.zlevel = 0, i.culling = !1, i.cursor = "pointer", i.rectHover = !1, i.incremental = !1, i._rect = null, i.dirtyRectTolerance = 0, i.__dirty = Oe | Ja;
  })(), t;
})(lu), uc = new rt(0, 0, 0, 0), cc = new rt(0, 0, 0, 0);
function cA(e, t, i) {
  return uc.copy(e.getBoundingRect()), e.transform && uc.applyTransform(e.transform), cc.width = t, cc.height = i, !uc.intersect(cc);
}
var je = Math.min, qe = Math.max, hc = Math.sin, dc = Math.cos, Pn = Math.PI * 2, ms = ba(), ys = ba(), _s = ba();
function tg(e, t, i, n, r, a) {
  r[0] = je(e, i), r[1] = je(t, n), a[0] = qe(e, i), a[1] = qe(t, n);
}
var eg = [], ig = [];
function hA(e, t, i, n, r, a, o, s, l, u) {
  var c = Jy, h = ge, d = c(e, i, r, o, eg);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var f = 0; f < d; f++) {
    var v = h(e, i, r, o, eg[f]);
    l[0] = je(v, l[0]), u[0] = qe(v, u[0]);
  }
  d = c(t, n, a, s, ig);
  for (var f = 0; f < d; f++) {
    var m = h(t, n, a, s, ig[f]);
    l[1] = je(m, l[1]), u[1] = qe(m, u[1]);
  }
  l[0] = je(e, l[0]), u[0] = qe(e, u[0]), l[0] = je(o, l[0]), u[0] = qe(o, u[0]), l[1] = je(t, l[1]), u[1] = qe(t, u[1]), l[1] = je(s, l[1]), u[1] = qe(s, u[1]);
}
function dA(e, t, i, n, r, a, o, s) {
  var l = t_, u = Te, c = qe(je(l(e, i, r), 1), 0), h = qe(je(l(t, n, a), 1), 0), d = u(e, i, r, c), f = u(t, n, a, h);
  o[0] = je(e, r, d), o[1] = je(t, a, f), s[0] = qe(e, r, d), s[1] = qe(t, a, f);
}
function fA(e, t, i, n, r, a, o, s, l) {
  var u = qr, c = Zr, h = Math.abs(r - a);
  if (h % Pn < 1e-4 && h > 1e-4) {
    s[0] = e - i, s[1] = t - n, l[0] = e + i, l[1] = t + n;
    return;
  }
  if (ms[0] = dc(r) * i + e, ms[1] = hc(r) * n + t, ys[0] = dc(a) * i + e, ys[1] = hc(a) * n + t, u(s, ms, ys), c(l, ms, ys), r = r % Pn, r < 0 && (r = r + Pn), a = a % Pn, a < 0 && (a = a + Pn), r > a && !o ? a += Pn : r < a && o && (r += Pn), o) {
    var d = a;
    a = r, r = d;
  }
  for (var f = 0; f < a; f += Math.PI / 2)
    f > r && (_s[0] = dc(f) * i + e, _s[1] = hc(f) * n + t, u(s, _s, s), c(l, _s, l));
}
var pt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, In = [], Rn = [], fi = [], Zi = [], vi = [], pi = [], fc = Math.min, vc = Math.max, On = Math.cos, Bn = Math.sin, Li = Math.abs, Rh = Math.PI, en = Rh * 2, pc = typeof Float32Array < "u", Aa = [];
function gc(e) {
  var t = Math.round(e / Rh * 1e8) / 1e8;
  return t % 2 * Rh;
}
function vA(e, t) {
  var i = gc(e[0]);
  i < 0 && (i += en);
  var n = i - e[0], r = e[1];
  r += n, !t && r - i >= en ? r = i + en : t && i - r >= en ? r = i - en : !t && i > r ? r = i + (en - gc(i - r)) : t && i < r && (r = i - (en - gc(r - i))), e[0] = i, e[1] = r;
}
var va = (function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, i, n) {
    n = n || 0, n > 0 && (this._ux = Li(n / xl / t) || 0, this._uy = Li(n / xl / i) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, i) {
    return this._drawPendingPt(), this.addData(pt.M, t, i), this._ctx && this._ctx.moveTo(t, i), this._x0 = t, this._y0 = i, this._xi = t, this._yi = i, this;
  }, e.prototype.lineTo = function(t, i) {
    var n = Li(t - this._xi), r = Li(i - this._yi), a = n > this._ux || r > this._uy;
    if (this.addData(pt.L, t, i), this._ctx && a && this._ctx.lineTo(t, i), a)
      this._xi = t, this._yi = i, this._pendingPtDist = 0;
    else {
      var o = n * n + r * r;
      o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = i, this._pendingPtDist = o);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, i, n, r, a, o) {
    return this._drawPendingPt(), this.addData(pt.C, t, i, n, r, a, o), this._ctx && this._ctx.bezierCurveTo(t, i, n, r, a, o), this._xi = a, this._yi = o, this;
  }, e.prototype.quadraticCurveTo = function(t, i, n, r) {
    return this._drawPendingPt(), this.addData(pt.Q, t, i, n, r), this._ctx && this._ctx.quadraticCurveTo(t, i, n, r), this._xi = n, this._yi = r, this;
  }, e.prototype.arc = function(t, i, n, r, a, o) {
    this._drawPendingPt(), Aa[0] = r, Aa[1] = a, vA(Aa, o), r = Aa[0], a = Aa[1];
    var s = a - r;
    return this.addData(pt.A, t, i, n, n, r, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, i, n, r, a, o), this._xi = On(a) * n + t, this._yi = Bn(a) * n + i, this;
  }, e.prototype.arcTo = function(t, i, n, r, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, i, n, r, a), this;
  }, e.prototype.rect = function(t, i, n, r) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, i, n, r), this.addData(pt.R, t, i, n, r), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(pt.Z);
    var t = this._ctx, i = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = i, this._yi = n, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    if (this._saveData) {
      var i = t.length;
      !(this.data && this.data.length === i) && pc && (this.data = new Float32Array(i));
      for (var n = 0; n < i; n++)
        this.data[n] = t[n];
      this._len = i;
    }
  }, e.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var i = t.length, n = 0, r = this._len, a = 0; a < i; a++)
        n += t[a].len();
      var o = this.data;
      if (pc && (o instanceof Float32Array || !o) && (this.data = new Float32Array(r + n), r > 0 && o))
        for (var s = 0; s < r; s++)
          this.data[s] = o[s];
      for (var a = 0; a < i; a++)
        for (var l = t[a].data, s = 0; s < l.length; s++)
          this.data[r++] = l[s];
      this._len = r;
    }
  }, e.prototype.addData = function(t, i, n, r, a, o, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], i = 0; i < this._len; i++)
        t[i] = this.data[i];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, pc && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    fi[0] = fi[1] = vi[0] = vi[1] = Number.MAX_VALUE, Zi[0] = Zi[1] = pi[0] = pi[1] = -Number.MAX_VALUE;
    var t = this.data, i = 0, n = 0, r = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = t[o++], l = o === 1;
      switch (l && (i = t[o], n = t[o + 1], r = i, a = n), s) {
        case pt.M:
          i = r = t[o++], n = a = t[o++], vi[0] = r, vi[1] = a, pi[0] = r, pi[1] = a;
          break;
        case pt.L:
          tg(i, n, t[o], t[o + 1], vi, pi), i = t[o++], n = t[o++];
          break;
        case pt.C:
          hA(i, n, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], vi, pi), i = t[o++], n = t[o++];
          break;
        case pt.Q:
          dA(i, n, t[o++], t[o++], t[o], t[o + 1], vi, pi), i = t[o++], n = t[o++];
          break;
        case pt.A:
          var u = t[o++], c = t[o++], h = t[o++], d = t[o++], f = t[o++], v = t[o++] + f;
          o += 1;
          var m = !t[o++];
          l && (r = On(f) * h + u, a = Bn(f) * d + c), fA(u, c, h, d, f, v, m, vi, pi), i = On(v) * h + u, n = Bn(v) * d + c;
          break;
        case pt.R:
          r = i = t[o++], a = n = t[o++];
          var p = t[o++], g = t[o++];
          tg(r, a, r + p, a + g, vi, pi);
          break;
        case pt.Z:
          i = r, n = a;
          break;
      }
      qr(fi, fi, vi), Zr(Zi, Zi, pi);
    }
    return o === 0 && (fi[0] = fi[1] = Zi[0] = Zi[1] = 0), new rt(fi[0], fi[1], Zi[0] - fi[0], Zi[1] - fi[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, i = this._len, n = this._ux, r = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, d = 0; d < i; ) {
      var f = t[d++], v = d === 1;
      v && (a = t[d], o = t[d + 1], s = a, l = o);
      var m = -1;
      switch (f) {
        case pt.M:
          a = s = t[d++], o = l = t[d++];
          break;
        case pt.L: {
          var p = t[d++], g = t[d++], y = p - a, _ = g - o;
          (Li(y) > n || Li(_) > r || d === i - 1) && (m = Math.sqrt(y * y + _ * _), a = p, o = g);
          break;
        }
        case pt.C: {
          var b = t[d++], w = t[d++], p = t[d++], g = t[d++], S = t[d++], C = t[d++];
          m = PD(a, o, b, w, p, g, S, C, 10), a = S, o = C;
          break;
        }
        case pt.Q: {
          var b = t[d++], w = t[d++], p = t[d++], g = t[d++];
          m = OD(a, o, b, w, p, g, 10), a = p, o = g;
          break;
        }
        case pt.A:
          var T = t[d++], k = t[d++], M = t[d++], D = t[d++], L = t[d++], P = t[d++], R = P + L;
          d += 1, v && (s = On(L) * M + T, l = Bn(L) * D + k), m = vc(M, D) * fc(en, Math.abs(P)), a = On(R) * M + T, o = Bn(R) * D + k;
          break;
        case pt.R: {
          s = a = t[d++], l = o = t[d++];
          var B = t[d++], F = t[d++];
          m = B * 2 + F * 2;
          break;
        }
        case pt.Z: {
          var y = s - a, _ = l - o;
          m = Math.sqrt(y * y + _ * _), a = s, o = l;
          break;
        }
      }
      m >= 0 && (u[h++] = m, c += m);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, i) {
    var n = this.data, r = this._ux, a = this._uy, o = this._len, s, l, u, c, h, d, f = i < 1, v, m, p = 0, g = 0, y, _ = 0, b, w;
    if (!(f && (this._pathSegLen || this._calculateLength(), v = this._pathSegLen, m = this._pathLen, y = i * m, !y)))
      t: for (var S = 0; S < o; ) {
        var C = n[S++], T = S === 1;
        switch (T && (u = n[S], c = n[S + 1], s = u, l = c), C !== pt.L && _ > 0 && (t.lineTo(b, w), _ = 0), C) {
          case pt.M:
            s = u = n[S++], l = c = n[S++], t.moveTo(u, c);
            break;
          case pt.L: {
            h = n[S++], d = n[S++];
            var k = Li(h - u), M = Li(d - c);
            if (k > r || M > a) {
              if (f) {
                var D = v[g++];
                if (p + D > y) {
                  var L = (y - p) / D;
                  t.lineTo(u * (1 - L) + h * L, c * (1 - L) + d * L);
                  break t;
                }
                p += D;
              }
              t.lineTo(h, d), u = h, c = d, _ = 0;
            } else {
              var P = k * k + M * M;
              P > _ && (b = h, w = d, _ = P);
            }
            break;
          }
          case pt.C: {
            var R = n[S++], B = n[S++], F = n[S++], W = n[S++], z = n[S++], N = n[S++];
            if (f) {
              var D = v[g++];
              if (p + D > y) {
                var L = (y - p) / D;
                ml(u, R, F, z, L, In), ml(c, B, W, N, L, Rn), t.bezierCurveTo(In[1], Rn[1], In[2], Rn[2], In[3], Rn[3]);
                break t;
              }
              p += D;
            }
            t.bezierCurveTo(R, B, F, W, z, N), u = z, c = N;
            break;
          }
          case pt.Q: {
            var R = n[S++], B = n[S++], F = n[S++], W = n[S++];
            if (f) {
              var D = v[g++];
              if (p + D > y) {
                var L = (y - p) / D;
                yl(u, R, F, L, In), yl(c, B, W, L, Rn), t.quadraticCurveTo(In[1], Rn[1], In[2], Rn[2]);
                break t;
              }
              p += D;
            }
            t.quadraticCurveTo(R, B, F, W), u = F, c = W;
            break;
          }
          case pt.A:
            var $ = n[S++], X = n[S++], U = n[S++], Q = n[S++], it = n[S++], ft = n[S++], yt = n[S++], ie = !n[S++], ve = U > Q ? U : Q, xt = Li(U - Q) > 1e-3, Mt = it + ft, et = !1;
            if (f) {
              var D = v[g++];
              p + D > y && (Mt = it + ft * (y - p) / D, et = !0), p += D;
            }
            if (xt && t.ellipse ? t.ellipse($, X, U, Q, yt, it, Mt, ie) : t.arc($, X, ve, it, Mt, ie), et)
              break t;
            T && (s = On(it) * U + $, l = Bn(it) * Q + X), u = On(Mt) * U + $, c = Bn(Mt) * Q + X;
            break;
          case pt.R:
            s = u = n[S], l = c = n[S + 1], h = n[S++], d = n[S++];
            var lt = n[S++], hi = n[S++];
            if (f) {
              var D = v[g++];
              if (p + D > y) {
                var qt = y - p;
                t.moveTo(h, d), t.lineTo(h + fc(qt, lt), d), qt -= lt, qt > 0 && t.lineTo(h + lt, d + fc(qt, hi)), qt -= hi, qt > 0 && t.lineTo(h + vc(lt - qt, 0), d + hi), qt -= lt, qt > 0 && t.lineTo(h, d + vc(hi - qt, 0));
                break t;
              }
              p += D;
            }
            t.rect(h, d, lt, hi);
            break;
          case pt.Z:
            if (f) {
              var D = v[g++];
              if (p + D > y) {
                var L = (y - p) / D;
                t.lineTo(u * (1 - L) + s * L, c * (1 - L) + l * L);
                break t;
              }
              p += D;
            }
            t.closePath(), u = s, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), i = this.data;
    return t.data = i.slice ? i.slice() : Array.prototype.slice.call(i), t._len = this._len, t;
  }, e.prototype.canSave = function() {
    return !!this._saveData;
  }, e.CMD = pt, e.initDefaultProps = (function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  })(), e;
})();
function Rr(e, t, i, n, r, a, o) {
  if (r === 0)
    return !1;
  var s = r, l = 0, u = e;
  if (o > t + s && o > n + s || o < t - s && o < n - s || a > e + s && a > i + s || a < e - s && a < i - s)
    return !1;
  if (e !== i)
    l = (t - n) / (e - i), u = (e * n - i * t) / (e - i);
  else
    return Math.abs(a - e) <= s / 2;
  var c = l * a - o + u, h = c * c / (l * l + 1);
  return h <= s / 2 * s / 2;
}
function pA(e, t, i, n, r, a, o, s, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > t + h && c > n + h && c > a + h && c > s + h || c < t - h && c < n - h && c < a - h && c < s - h || u > e + h && u > i + h && u > r + h && u > o + h || u < e - h && u < i - h && u < r - h && u < o - h)
    return !1;
  var d = LD(e, t, i, n, r, a, o, s, u, c);
  return d <= h / 2;
}
function gA(e, t, i, n, r, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > t + u && l > n + u && l > a + u || l < t - u && l < n - u && l < a - u || s > e + u && s > i + u && s > r + u || s < e - u && s < i - u && s < r - u)
    return !1;
  var c = RD(e, t, i, n, r, a, s, l);
  return c <= u / 2;
}
var ng = Math.PI * 2;
function bs(e) {
  return e %= ng, e < 0 && (e += ng), e;
}
var La = Math.PI * 2;
function mA(e, t, i, n, r, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= e, l -= t;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > i || c + u < i)
    return !1;
  if (Math.abs(n - r) % La < 1e-4)
    return !0;
  if (a) {
    var h = n;
    n = bs(r), r = bs(h);
  } else
    n = bs(n), r = bs(r);
  n > r && (r += La);
  var d = Math.atan2(l, s);
  return d < 0 && (d += La), d >= n && d <= r || d + La >= n && d + La <= r;
}
function Nn(e, t, i, n, r, a) {
  if (a > t && a > n || a < t && a < n || n === t)
    return 0;
  var o = (a - t) / (n - t), s = n < t ? 1 : -1;
  (o === 1 || o === 0) && (s = n < t ? 0.5 : -0.5);
  var l = o * (i - e) + e;
  return l === r ? 1 / 0 : l > r ? s : 0;
}
var Ki = va.CMD, Fn = Math.PI * 2, yA = 1e-4;
function _A(e, t) {
  return Math.abs(e - t) < yA;
}
var pe = [-1, -1, -1], Ue = [-1, -1];
function bA() {
  var e = Ue[0];
  Ue[0] = Ue[1], Ue[1] = e;
}
function xA(e, t, i, n, r, a, o, s, l, u) {
  if (u > t && u > n && u > a && u > s || u < t && u < n && u < a && u < s)
    return 0;
  var c = Qy(t, n, a, s, u, pe);
  if (c === 0)
    return 0;
  for (var h = 0, d = -1, f = void 0, v = void 0, m = 0; m < c; m++) {
    var p = pe[m], g = p === 0 || p === 1 ? 0.5 : 1, y = ge(e, i, r, o, p);
    y < l || (d < 0 && (d = Jy(t, n, a, s, Ue), Ue[1] < Ue[0] && d > 1 && bA(), f = ge(t, n, a, s, Ue[0]), d > 1 && (v = ge(t, n, a, s, Ue[1]))), d === 2 ? p < Ue[0] ? h += f < t ? g : -g : p < Ue[1] ? h += v < f ? g : -g : h += s < v ? g : -g : p < Ue[0] ? h += f < t ? g : -g : h += s < f ? g : -g);
  }
  return h;
}
function wA(e, t, i, n, r, a, o, s) {
  if (s > t && s > n && s > a || s < t && s < n && s < a)
    return 0;
  var l = ID(t, n, a, s, pe);
  if (l === 0)
    return 0;
  var u = t_(t, n, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = Te(t, n, a, u), d = 0; d < l; d++) {
      var f = pe[d] === 0 || pe[d] === 1 ? 0.5 : 1, v = Te(e, i, r, pe[d]);
      v < o || (pe[d] < u ? c += h < t ? f : -f : c += a < h ? f : -f);
    }
    return c;
  } else {
    var f = pe[0] === 0 || pe[0] === 1 ? 0.5 : 1, v = Te(e, i, r, pe[0]);
    return v < o ? 0 : a < t ? f : -f;
  }
}
function SA(e, t, i, n, r, a, o, s) {
  if (s -= t, s > i || s < -i)
    return 0;
  var l = Math.sqrt(i * i - s * s);
  pe[0] = -l, pe[1] = l;
  var u = Math.abs(n - r);
  if (u < 1e-4)
    return 0;
  if (u >= Fn - 1e-4) {
    n = 0, r = Fn;
    var c = a ? 1 : -1;
    return o >= pe[0] + e && o <= pe[1] + e ? c : 0;
  }
  if (n > r) {
    var h = n;
    n = r, r = h;
  }
  n < 0 && (n += Fn, r += Fn);
  for (var d = 0, f = 0; f < 2; f++) {
    var v = pe[f];
    if (v + e > o) {
      var m = Math.atan2(s, v), c = a ? 1 : -1;
      m < 0 && (m = Fn + m), (m >= n && m <= r || m + Fn >= n && m + Fn <= r) && (m > Math.PI / 2 && m < Math.PI * 1.5 && (c = -c), d += c);
    }
  }
  return d;
}
function k_(e, t, i, n, r) {
  for (var a = e.data, o = e.len(), s = 0, l = 0, u = 0, c = 0, h = 0, d, f, v = 0; v < o; ) {
    var m = a[v++], p = v === 1;
    switch (m === Ki.M && v > 1 && (i || (s += Nn(l, u, c, h, n, r))), p && (l = a[v], u = a[v + 1], c = l, h = u), m) {
      case Ki.M:
        c = a[v++], h = a[v++], l = c, u = h;
        break;
      case Ki.L:
        if (i) {
          if (Rr(l, u, a[v], a[v + 1], t, n, r))
            return !0;
        } else
          s += Nn(l, u, a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Ki.C:
        if (i) {
          if (pA(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          s += xA(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Ki.Q:
        if (i) {
          if (gA(l, u, a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          s += wA(l, u, a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Ki.A:
        var g = a[v++], y = a[v++], _ = a[v++], b = a[v++], w = a[v++], S = a[v++];
        v += 1;
        var C = !!(1 - a[v++]);
        d = Math.cos(w) * _ + g, f = Math.sin(w) * b + y, p ? (c = d, h = f) : s += Nn(l, u, d, f, n, r);
        var T = (n - g) * b / _ + g;
        if (i) {
          if (mA(g, y, b, w, w + S, C, t, T, r))
            return !0;
        } else
          s += SA(g, y, b, w, w + S, C, T, r);
        l = Math.cos(w + S) * _ + g, u = Math.sin(w + S) * b + y;
        break;
      case Ki.R:
        c = l = a[v++], h = u = a[v++];
        var k = a[v++], M = a[v++];
        if (d = c + k, f = h + M, i) {
          if (Rr(c, h, d, h, t, n, r) || Rr(d, h, d, f, t, n, r) || Rr(d, f, c, f, t, n, r) || Rr(c, f, c, h, t, n, r))
            return !0;
        } else
          s += Nn(d, h, d, f, n, r), s += Nn(c, f, c, h, n, r);
        break;
      case Ki.Z:
        if (i) {
          if (Rr(l, u, c, h, t, n, r))
            return !0;
        } else
          s += Nn(l, u, c, h, n, r);
        l = c, u = h;
        break;
    }
  }
  return !i && !_A(u, h) && (s += Nn(l, u, c, h, n, r) || 0), s !== 0;
}
function CA(e, t, i) {
  return k_(e, 0, !1, t, i);
}
function TA(e, t, i, n) {
  return k_(e, t, !0, i, n);
}
var D_ = zt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, fr), MA = {
  style: zt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, du.style)
}, mc = Eo.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Et = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.update = function() {
    var i = this;
    e.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var r = this._decalEl = this._decalEl || new t();
      r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
        i.buildPath(l, i.shape);
      }), r.silent = !0;
      var a = r.style;
      for (var o in n)
        a[o] !== n[o] && (a[o] = n[o]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var s = 0; s < mc.length; ++s)
        r[mc[s]] = this[mc[s]];
      r.__dirty |= Oe;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(i) {
    var n = Bt(i);
    this.shape = this.getDefaultShape();
    var r = this.getDefaultStyle();
    r && this.useStyle(r);
    for (var a = 0; a < n.length; a++) {
      var o = n[a], s = i[o];
      o === "style" ? this.style ? V(this.style, s) : this.useStyle(s) : o === "shape" ? V(this.shape, s) : e.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var i = this.style.fill;
    if (i !== "none") {
      if (K(i)) {
        var n = bl(i, 0);
        return n > 0.5 ? Dh : n > 0.2 ? nE : Eh;
      } else if (i)
        return Eh;
    }
    return Dh;
  }, t.prototype.getInsideTextStroke = function(i) {
    var n = this.style.fill;
    if (K(n)) {
      var r = this.__zr, a = !!(r && r.isDarkMode()), o = bl(i, 0) < kh;
      if (a === o)
        return n;
    }
  }, t.prototype.buildPath = function(i, n, r) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~jr;
  }, t.prototype.getUpdatedPathProxy = function(i) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, i), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new va(!1);
  }, t.prototype.hasStroke = function() {
    var i = this.style, n = i.stroke;
    return !(n == null || n === "none" || !(i.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var i = this._rect, n = this.style, r = !i;
    if (r) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & jr) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), i = o.getBoundingRect();
    }
    if (this._rect = i, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = i.clone());
      if (this.__dirty || r) {
        s.copy(i);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return i;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect(), o = this.style;
    if (i = r[0], n = r[1], a.contain(i, n)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), TA(s, l / u, i, n)))
          return !0;
      }
      if (this.hasFill())
        return CA(s, i, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= jr, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(i) {
    return this.animate("shape", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : i === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i === "shape" ? this.setShape(n) : e.prototype.attrKV.call(this, i, n);
  }, t.prototype.setShape = function(i, n) {
    var r = this.shape;
    return r || (r = this.shape = {}), typeof i == "string" ? r[i] = n : V(r, i), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & jr);
  }, t.prototype.createStyle = function(i) {
    return ou(D_, i);
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.shape && !n.shape && (n.shape = V({}, this.shape));
  }, t.prototype._applyStateObj = function(i, n, r, a, o, s) {
    e.prototype._applyStateObj.call(this, i, n, r, a, o, s);
    var l = !(n && a), u;
    if (n && n.shape ? o ? a ? u = n.shape : (u = V({}, r.shape), V(u, n.shape)) : (u = V({}, a ? this.shape : r.shape), V(u, n.shape)) : l && (u = r.shape), u)
      if (o) {
        this.shape = V({}, this.shape);
        for (var c = {}, h = Bt(u), d = 0; d < h.length; d++) {
          var f = h[d];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(i, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var o = i[a];
      o.shape && (r = r || {}, this._mergeStyle(r, o.shape));
    }
    return r && (n.shape = r), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return MA;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(i) {
    var n = (function(a) {
      St(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return i.init && i.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return ct(i.style);
      }, o.prototype.getDefaultShape = function() {
        return ct(i.shape);
      }, o;
    })(t);
    for (var r in i)
      typeof i[r] == "function" && (n.prototype[r] = i[r]);
    return n;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "path", i.strokeContainThreshold = 5, i.segmentIgnoreThreshold = 0, i.subPixelOptimize = !1, i.autoBatch = !1, i.__dirty = Oe | Ja | jr;
  })(), t;
})(Xo), kA = zt({
  strokeFirst: !0,
  font: gn,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, D_), Tl = (function(e) {
  St(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return M_(this.style);
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(i) {
    return ou(kA, i);
  }, t.prototype.setBoundingRect = function(i) {
    this._rect = i;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = lA(this.style)), this._rect;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.dirtyRectTolerance = 10;
  })(), t;
})(Xo);
Tl.prototype.type = "tspan";
var DA = zt({
  x: 0,
  y: 0
}, fr), EA = {
  style: zt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, du.style)
};
function AA(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var wr = (function(e) {
  St(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(i) {
    return ou(DA, i);
  }, t.prototype._getSize = function(i) {
    var n = this.style, r = n[i];
    if (r != null)
      return r;
    var a = AA(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var o = i === "width" ? "height" : "width", s = n[o];
    return s == null ? a[i] : a[i] / a[o] * s;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return EA;
  }, t.prototype.getBoundingRect = function() {
    var i = this.style;
    return this._rect || (this._rect = new rt(i.x || 0, i.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
})(Xo);
wr.prototype.type = "image";
function LA(e, t) {
  var i = t.x, n = t.y, r = t.width, a = t.height, o = t.r, s, l, u, c;
  r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
  var h;
  s + l > r && (h = s + l, s *= r / h, l *= r / h), u + c > r && (h = u + c, u *= r / h, c *= r / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), s + c > a && (h = s + c, s *= a / h, c *= a / h), e.moveTo(i + s, n), e.lineTo(i + r - l, n), l !== 0 && e.arc(i + r - l, n + l, l, -Math.PI / 2, 0), e.lineTo(i + r, n + a - u), u !== 0 && e.arc(i + r - u, n + a - u, u, 0, Math.PI / 2), e.lineTo(i + c, n + a), c !== 0 && e.arc(i + c, n + a - c, c, Math.PI / 2, Math.PI), e.lineTo(i, n + s), s !== 0 && e.arc(i + s, n + s, s, Math.PI, Math.PI * 1.5);
}
var Jr = Math.round;
function E_(e, t, i) {
  if (t) {
    var n = t.x1, r = t.x2, a = t.y1, o = t.y2;
    e.x1 = n, e.x2 = r, e.y1 = a, e.y2 = o;
    var s = i && i.lineWidth;
    return s && (Jr(n * 2) === Jr(r * 2) && (e.x1 = e.x2 = nr(n, s, !0)), Jr(a * 2) === Jr(o * 2) && (e.y1 = e.y2 = nr(a, s, !0))), e;
  }
}
function A_(e, t, i) {
  if (t) {
    var n = t.x, r = t.y, a = t.width, o = t.height;
    e.x = n, e.y = r, e.width = a, e.height = o;
    var s = i && i.lineWidth;
    return s && (e.x = nr(n, s, !0), e.y = nr(r, s, !0), e.width = Math.max(nr(n + a, s, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max(nr(r + o, s, !1) - e.y, o === 0 ? 0 : 1)), e;
  }
}
function nr(e, t, i) {
  if (!t)
    return e;
  var n = Jr(e * 2);
  return (n + Jr(t)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
}
var PA = /* @__PURE__ */ (function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
})(), IA = {}, he = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new PA();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, o, s;
    if (this.subPixelOptimize) {
      var l = A_(IA, n, this.style);
      r = l.x, a = l.y, o = l.width, s = l.height, l.r = n.r, n = l;
    } else
      r = n.x, a = n.y, o = n.width, s = n.height;
    n.r ? LA(i, n) : i.rect(r, a, o, s);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
})(Et);
he.prototype.type = "rect";
var rg = {
  fill: "#000"
}, ag = 2, gi = {}, RA = {
  style: zt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, du.style)
}, ti = (function(e) {
  St(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = rg, n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var i = this.innerTransformable;
    i ? (i.updateTransform(), i.transform && (this.transform = i.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(i) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(i) : e.prototype.getLocalTransform.call(this, i);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, $A(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = i;
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var i = new rt(0, 0, 0, 0), n = this._children, r = [], a = null, o = 0; o < n.length; o++) {
        var s = n[o], l = s.getBoundingRect(), u = s.getLocalTransform(r);
        u ? (i.copy(l), i.applyTransform(u), a = a || i.clone(), a.union(i)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || i;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(i) {
    this._defaultStyle = i || rg;
  }, t.prototype.setTextContent = function(i) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(i, n) {
    if (!n)
      return i;
    var r = n.rich, a = i.rich || r && {};
    return V(i, n), r && a ? (this._mergeRich(a, r), i.rich = a) : a && (i.rich = a), i;
  }, t.prototype._mergeRich = function(i, n) {
    for (var r = Bt(n), a = 0; a < r.length; a++) {
      var o = r[a];
      i[o] = i[o] || {}, V(i[o], n[o]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return RA;
  }, t.prototype._getOrCreateChild = function(i) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof i)) && (n = new i()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var i = this.style, n = i.font || gn, r = i.padding, a = this._defaultStyle, o = i.x || 0, s = i.y || 0, l = i.align || a.align || "left", u = i.verticalAlign || a.verticalAlign || "top";
    Zp(gi, a.overflowRect, o, s, l, u), o = gi.baseX, s = gi.baseY;
    var c = dg(i), h = eA(c, i, gi.outerWidth, gi.outerHeight), d = yc(i), f = !!i.backgroundColor, v = h.outerHeight, m = h.outerWidth, p = h.lines, g = h.lineHeight;
    this.isTruncated = !!h.isTruncated;
    var y = o, _ = dr(s, h.contentHeight, u);
    if (d || r) {
      var b = da(o, m, l), w = dr(s, v, u);
      d && this._renderBackground(i, i, b, w, m, v);
    }
    _ += g / 2, r && (y = hg(o, l, r), u === "top" ? _ += r[0] : u === "bottom" && (_ -= r[2]));
    for (var S = 0, C = !1, T = !1, k = cg("fill" in i ? i.fill : (T = !0, a.fill)), M = ug("stroke" in i ? i.stroke : !f && (!a.autoStroke || T) ? (S = ag, C = !0, a.stroke) : null), D = i.textShadowBlur > 0, L = 0; L < p.length; L++) {
      var P = this._getOrCreateChild(Tl), R = P.createStyle();
      P.useStyle(R), R.text = p[L], R.x = y, R.y = _, R.textAlign = l, R.textBaseline = "middle", R.opacity = i.opacity, R.strokeFirst = !0, D && (R.shadowBlur = i.textShadowBlur || 0, R.shadowColor = i.textShadowColor || "transparent", R.shadowOffsetX = i.textShadowOffsetX || 0, R.shadowOffsetY = i.textShadowOffsetY || 0), R.stroke = M, R.fill = k, M && (R.lineWidth = i.lineWidth || S, R.lineDash = i.lineDash, R.lineDashOffset = i.lineDashOffset || 0), R.font = n, sg(R, i), _ += g, P.setBoundingRect(Ph(R, h.contentWidth, h.calculatedLineHeight, C ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var i = this.style, n = this._defaultStyle, r = i.align || n.align, a = i.verticalAlign || n.verticalAlign, o = i.x || 0, s = i.y || 0;
    Zp(gi, n.overflowRect, o, s, r, a), o = gi.baseX, s = gi.baseY;
    var l = dg(i), u = rA(l, i, gi.outerWidth, gi.outerHeight, r), c = u.width, h = u.outerWidth, d = u.outerHeight, f = i.padding;
    this.isTruncated = !!u.isTruncated;
    var v = da(o, h, r), m = dr(s, d, a), p = v, g = m;
    f && (p += f[3], g += f[0]);
    var y = p + c;
    yc(i) && this._renderBackground(i, i, v, m, h, d);
    for (var _ = !!i.backgroundColor, b = 0; b < u.lines.length; b++) {
      for (var w = u.lines[b], S = w.tokens, C = S.length, T = w.lineHeight, k = w.width, M = 0, D = p, L = y, P = C - 1, R = void 0; M < C && (R = S[M], !R.align || R.align === "left"); )
        this._placeToken(R, i, T, g, D, "left", _), k -= R.width, D += R.width, M++;
      for (; P >= 0 && (R = S[P], R.align === "right"); )
        this._placeToken(R, i, T, g, L, "right", _), k -= R.width, L -= R.width, P--;
      for (D += (c - (D - p) - (y - L) - k) / 2; M <= P; )
        R = S[M], this._placeToken(R, i, T, g, D + R.width / 2, "center", _), D += R.width, M++;
      g += T;
    }
  }, t.prototype._placeToken = function(i, n, r, a, o, s, l) {
    var u = n.rich[i.styleName] || {};
    u.text = i.text;
    var c = i.verticalAlign, h = a + r / 2;
    c === "top" ? h = a + i.height / 2 : c === "bottom" && (h = a + r - i.height / 2);
    var d = !i.isLineHolder && yc(u);
    d && this._renderBackground(u, n, s === "right" ? o - i.width : s === "center" ? o - i.width / 2 : o, h - i.height / 2, i.width, i.height);
    var f = !!u.backgroundColor, v = i.textPadding;
    v && (o = hg(o, s, v), h -= i.height / 2 - v[0] - i.innerHeight / 2);
    var m = this._getOrCreateChild(Tl), p = m.createStyle();
    m.useStyle(p);
    var g = this._defaultStyle, y = !1, _ = 0, b = !1, w = cg("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, g.fill)), S = ug("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !f && !l && (!g.autoStroke || y) ? (_ = ag, b = !0, g.stroke) : null), C = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    p.text = i.text, p.x = o, p.y = h, C && (p.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, p.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), p.textAlign = s, p.textBaseline = "middle", p.font = i.font || gn, p.opacity = ur(u.opacity, n.opacity, 1), sg(p, u), S && (p.lineWidth = ur(u.lineWidth, n.lineWidth, _), p.lineDash = tt(u.lineDash, n.lineDash), p.lineDashOffset = n.lineDashOffset || 0, p.stroke = S), w && (p.fill = w), m.setBoundingRect(Ph(p, i.contentWidth, i.contentHeight, b ? 0 : null));
  }, t.prototype._renderBackground = function(i, n, r, a, o, s) {
    var l = i.backgroundColor, u = i.borderWidth, c = i.borderColor, h = l && l.image, d = l && !h, f = i.borderRadius, v = this, m, p;
    if (d || i.lineHeight || u && c) {
      m = this._getOrCreateChild(he), m.useStyle(m.createStyle()), m.style.fill = null;
      var g = m.shape;
      g.x = r, g.y = a, g.width = o, g.height = s, g.r = f, m.dirtyShape();
    }
    if (d) {
      var y = m.style;
      y.fill = l || null, y.fillOpacity = tt(i.fillOpacity, 1);
    } else if (h) {
      p = this._getOrCreateChild(wr), p.onload = function() {
        v.dirtyStyle();
      };
      var _ = p.style;
      _.image = l.image, _.x = r, _.y = a, _.width = o, _.height = s;
    }
    if (u && c) {
      var y = m.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = tt(i.strokeOpacity, 1), y.lineDash = i.borderDash, y.lineDashOffset = i.borderDashOffset || 0, m.strokeContainThreshold = 0, m.hasFill() && m.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var b = (m || p).style;
    b.shadowBlur = i.shadowBlur || 0, b.shadowColor = i.shadowColor || "transparent", b.shadowOffsetX = i.shadowOffsetX || 0, b.shadowOffsetY = i.shadowOffsetY || 0, b.opacity = ur(i.opacity, n.opacity, 1);
  }, t.makeFont = function(i) {
    var n = "";
    return FA(i) && (n = [
      i.fontStyle,
      i.fontWeight,
      NA(i.fontSize),
      i.fontFamily || "sans-serif"
    ].join(" ")), n && xi(n) || i.textFont || i.font;
  }, t;
})(Xo), OA = { left: !0, right: 1, center: 1 }, BA = { top: 1, bottom: 1, middle: 1 }, og = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function NA(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? Ld + "px" : e + "px";
}
function sg(e, t) {
  for (var i = 0; i < og.length; i++) {
    var n = og[i], r = t[n];
    r != null && (e[n] = r);
  }
}
function FA(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function $A(e) {
  return lg(e), E(e.rich, lg), e;
}
function lg(e) {
  if (e) {
    e.font = ti.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || OA[t] ? t : "left";
    var i = e.verticalAlign;
    i === "center" && (i = "middle"), e.verticalAlign = i == null || BA[i] ? i : "top";
    var n = e.padding;
    n && (e.padding = Od(e.padding));
  }
}
function ug(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function cg(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function hg(e, t, i) {
  return t === "right" ? e - i[1] : t === "center" ? e + i[3] / 2 - i[1] / 2 : e + i[3];
}
function dg(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function yc(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
var Lt = It(), zA = function(e, t, i, n) {
  if (n) {
    var r = Lt(n);
    r.dataIndex = i, r.dataType = t, r.seriesIndex = e, r.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var o = Lt(a);
      o.seriesIndex = e, o.dataIndex = i, o.dataType = t, o.ssrType = "chart";
    });
  }
}, fg = 1, vg = {}, L_ = It(), Ud = It(), P_ = 0, Gd = 1, Xd = 2, yn = ["emphasis", "blur", "select"], pg = ["normal", "emphasis", "blur", "select"], VA = 10, HA = 9, vr = "highlight", Ks = "downplay", Ml = "select", Oh = "unselect", kl = "toggleSelect", jd = "selectchanged";
function Or(e) {
  return e != null && e !== "none";
}
function fu(e, t, i) {
  e.onHoverStateChange && (e.hoverState || 0) !== i && e.onHoverStateChange(t), e.hoverState = i;
}
function I_(e) {
  fu(e, "emphasis", Xd);
}
function R_(e) {
  e.hoverState === Xd && fu(e, "normal", P_);
}
function qd(e) {
  fu(e, "blur", Gd);
}
function O_(e) {
  e.hoverState === Gd && fu(e, "normal", P_);
}
function WA(e) {
  e.selected = !0;
}
function YA(e) {
  e.selected = !1;
}
function gg(e, t, i) {
  t(e, i);
}
function qi(e, t, i) {
  gg(e, t, i), e.isGroup && e.traverse(function(n) {
    gg(n, t, i);
  });
}
function UA(e, t, i, n) {
  for (var r = e.style, a = {}, o = 0; o < t.length; o++) {
    var s = t[o], l = r[s];
    a[s] = l ?? (n && n[s]);
  }
  for (var o = 0; o < e.animators.length; o++) {
    var u = e.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(i) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function GA(e, t, i, n) {
  var r = i && Pt(i, "select") >= 0, a = !1;
  if (e instanceof Et) {
    var o = L_(e), s = r && o.selectFill || o.normalFill, l = r && o.selectStroke || o.normalStroke;
    if (Or(s) || Or(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = V({}, n), u = V({}, u), u.fill = s) : !Or(u.fill) && Or(s) ? (a = !0, n = V({}, n), u = V({}, u), u.fill = Dp(s)) : !Or(u.stroke) && Or(l) && (a || (n = V({}, n), u = V({}, u)), u.stroke = Dp(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = V({}, n));
    var c = e.z2EmphasisLift;
    n.z2 = e.z2 + (c ?? VA);
  }
  return n;
}
function XA(e, t, i) {
  if (i && i.z2 == null) {
    i = V({}, i);
    var n = e.z2SelectLift;
    i.z2 = e.z2 + (n ?? HA);
  }
  return i;
}
function jA(e, t, i) {
  var n = Pt(e.currentStates, t) >= 0, r = e.style.opacity, a = n ? null : UA(e, ["opacity"], t, {
    opacity: 1
  });
  i = i || {};
  var o = i.style || {};
  return o.opacity == null && (i = V({}, i), o = V({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? r : a.opacity * 0.1
  }, o), i.style = o), i;
}
function _c(e, t) {
  var i = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return GA(this, e, t, i);
    if (e === "blur")
      return jA(this, e, i);
    if (e === "select")
      return XA(this, e, i);
  }
  return i;
}
function qA(e) {
  e.stateProxy = _c;
  var t = e.getTextContent(), i = e.getTextGuideLine();
  t && (t.stateProxy = _c), i && (i.stateProxy = _c);
}
function mg(e, t) {
  !$_(e, t) && !e.__highByOuter && qi(e, I_);
}
function yg(e, t) {
  !$_(e, t) && !e.__highByOuter && qi(e, R_);
}
function Dl(e, t) {
  e.__highByOuter |= 1 << (t || 0), qi(e, I_);
}
function El(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && qi(e, R_);
}
function ZA(e) {
  qi(e, qd);
}
function B_(e) {
  qi(e, O_);
}
function N_(e) {
  qi(e, WA);
}
function F_(e) {
  qi(e, YA);
}
function $_(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function z_(e) {
  var t = e.getModel(), i = [], n = [];
  t.eachComponent(function(r, a) {
    var o = Ud(a), s = r === "series", l = s ? e.getViewOfSeriesModel(a) : e.getViewOfComponentModel(a);
    !s && n.push(l), o.isBlured && (l.group.traverse(function(u) {
      O_(u);
    }), s && i.push(a)), o.isBlured = !1;
  }), E(n, function(r) {
    r && r.toggleBlurSeries && r.toggleBlurSeries(i, !1, t);
  });
}
function Bh(e, t, i, n) {
  var r = n.getModel();
  i = i || "coordinateSystem";
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var d = u.getItemGraphicEl(c[h]);
      d && B_(d);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var o = r.getSeriesByIndex(e), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    r.eachSeries(function(u) {
      var c = o === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var d = h && s ? h === s : c;
      if (!// Not blur other series if blurScope series
      (i === "series" && !c || i === "coordinateSystem" && !d || t === "series" && c)) {
        var f = n.getViewOfSeriesModel(u);
        if (f.group.traverse(function(p) {
          p.__highByOuter && c && t === "self" || qd(p);
        }), Ae(t))
          a(u.getData(), t);
        else if (Z(t))
          for (var v = Bt(t), m = 0; m < v.length; m++)
            a(u.getData(v[m]), t[v[m]]);
        l.push(u), Ud(u).isBlured = !0;
      }
    }), r.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = n.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, r);
      }
    });
  }
}
function Nh(e, t, i) {
  if (!(e == null || t == null)) {
    var n = i.getModel().getComponent(e, t);
    if (n) {
      Ud(n).isBlured = !0;
      var r = i.getViewOfComponentModel(n);
      !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
        qd(a);
      });
    }
  }
}
function KA(e, t, i) {
  var n = e.seriesIndex, r = e.getData(t.dataType);
  if (!r) {
    process.env.NODE_ENV !== "production" && Ft("Unknown dataType " + t.dataType);
    return;
  }
  var a = Uo(r, t);
  a = (j(a) ? a[0] : a) || 0;
  var o = r.getItemGraphicEl(a);
  if (!o)
    for (var s = r.count(), l = 0; !o && l < s; )
      o = r.getItemGraphicEl(l++);
  if (o) {
    var u = Lt(o);
    Bh(n, u.focus, u.blurScope, i);
  } else {
    var c = e.get(["emphasis", "focus"]), h = e.get(["emphasis", "blurScope"]);
    c != null && Bh(n, c, h, i);
  }
}
function Zd(e, t, i, n) {
  var r = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || i == null)
    return r;
  var a = n.getModel().getComponent(e, t);
  if (!a)
    return r;
  var o = n.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return r;
  for (var s = o.findHighDownDispatchers(i), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !pa(s[u]) && Ft("param should be highDownDispatcher"), Lt(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function QA(e, t, i) {
  process.env.NODE_ENV !== "production" && !pa(e) && Ft("param should be highDownDispatcher");
  var n = Lt(e), r = Zd(n.componentMainType, n.componentIndex, n.componentHighDownName, i), a = r.dispatchers, o = r.focusSelf;
  a ? (o && Nh(n.componentMainType, n.componentIndex, i), E(a, function(s) {
    return mg(s, t);
  })) : (Bh(n.seriesIndex, n.focus, n.blurScope, i), n.focus === "self" && Nh(n.componentMainType, n.componentIndex, i), mg(e, t));
}
function JA(e, t, i) {
  process.env.NODE_ENV !== "production" && !pa(e) && Ft("param should be highDownDispatcher"), z_(i);
  var n = Lt(e), r = Zd(n.componentMainType, n.componentIndex, n.componentHighDownName, i).dispatchers;
  r ? E(r, function(a) {
    return yg(a, t);
  }) : yg(e, t);
}
function tL(e, t, i) {
  if (Fh(t)) {
    var n = t.dataType, r = e.getData(n), a = Uo(r, t);
    j(a) || (a = [a]), e[t.type === kl ? "toggleSelect" : t.type === Ml ? "select" : "unselect"](a, n);
  }
}
function _g(e) {
  var t = e.getAllData();
  E(t, function(i) {
    var n = i.data, r = i.type;
    n.eachItemGraphicEl(function(a, o) {
      e.isSelected(o, r) ? N_(a) : F_(a);
    });
  });
}
function eL(e) {
  var t = [];
  return e.eachSeries(function(i) {
    var n = i.getAllData();
    E(n, function(r) {
      r.data;
      var a = r.type, o = i.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: i.seriesIndex
        };
        a != null && (s.dataType = a), t.push(s);
      }
    });
  }), t;
}
function iL(e, t, i) {
  V_(e, !0), qi(e, qA), rL(e, t, i);
}
function nL(e) {
  V_(e, !1);
}
function bg(e, t, i, n) {
  n ? nL(e) : iL(e, t, i);
}
function rL(e, t, i) {
  var n = Lt(e);
  t != null ? (n.focus = t, n.blurScope = i) : n.focus && (n.focus = null);
}
var xg = ["emphasis", "blur", "select"], aL = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function wg(e, t, i, n) {
  i = i || "itemStyle";
  for (var r = 0; r < xg.length; r++) {
    var a = xg[r], o = t.getModel([a, i]), s = e.ensureState(a);
    s.style = n ? n(o) : o[aL[i]]();
  }
}
function V_(e, t) {
  var i = t === !1, n = e;
  e.highDownSilentOnTouch && (n.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!i || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !i);
}
function pa(e) {
  return !!(e && e.__highDownDispatcher);
}
function oL(e) {
  var t = vg[e];
  return t == null && fg <= 32 && (t = vg[e] = fg++), t;
}
function Fh(e) {
  var t = e.type;
  return t === Ml || t === Oh || t === kl;
}
function Sg(e) {
  var t = e.type;
  return t === vr || t === Ks;
}
function sL(e) {
  var t = L_(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var i = e.states.select || {};
  t.selectFill = i.style && i.style.fill || null, t.selectStroke = i.style && i.style.stroke || null;
}
var Br = va.CMD, lL = [[], [], []], Cg = Math.sqrt, uL = Math.atan2;
function cL(e, t) {
  if (t) {
    var i = e.data, n = e.len(), r, a, o, s, l, u, c = Br.M, h = Br.C, d = Br.L, f = Br.R, v = Br.A, m = Br.Q;
    for (o = 0, s = 0; o < n; ) {
      switch (r = i[o++], s = o, a = 0, r) {
        case c:
          a = 1;
          break;
        case d:
          a = 1;
          break;
        case h:
          a = 3;
          break;
        case m:
          a = 2;
          break;
        case v:
          var p = t[4], g = t[5], y = Cg(t[0] * t[0] + t[1] * t[1]), _ = Cg(t[2] * t[2] + t[3] * t[3]), b = uL(-t[1] / _, t[0] / y);
          i[o] *= y, i[o++] += p, i[o] *= _, i[o++] += g, i[o++] *= y, i[o++] *= _, i[o++] += b, i[o++] += b, o += 2, s = o;
          break;
        case f:
          u[0] = i[o++], u[1] = i[o++], Be(u, u, t), i[s++] = u[0], i[s++] = u[1], u[0] += i[o++], u[1] += i[o++], Be(u, u, t), i[s++] = u[0], i[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var w = lL[l];
        w[0] = i[o++], w[1] = i[o++], Be(w, w, t), i[s++] = w[0], i[s++] = w[1];
      }
    }
    e.increaseVersion();
  }
}
var bc = Math.sqrt, xs = Math.sin, ws = Math.cos, Pa = Math.PI;
function Tg(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function $h(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (Tg(e) * Tg(t));
}
function Mg(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos($h(e, t));
}
function kg(e, t, i, n, r, a, o, s, l, u, c) {
  var h = l * (Pa / 180), d = ws(h) * (e - i) / 2 + xs(h) * (t - n) / 2, f = -1 * xs(h) * (e - i) / 2 + ws(h) * (t - n) / 2, v = d * d / (o * o) + f * f / (s * s);
  v > 1 && (o *= bc(v), s *= bc(v));
  var m = (r === a ? -1 : 1) * bc((o * o * (s * s) - o * o * (f * f) - s * s * (d * d)) / (o * o * (f * f) + s * s * (d * d))) || 0, p = m * o * f / s, g = m * -s * d / o, y = (e + i) / 2 + ws(h) * p - xs(h) * g, _ = (t + n) / 2 + xs(h) * p + ws(h) * g, b = Mg([1, 0], [(d - p) / o, (f - g) / s]), w = [(d - p) / o, (f - g) / s], S = [(-1 * d - p) / o, (-1 * f - g) / s], C = Mg(w, S);
  if ($h(w, S) <= -1 && (C = Pa), $h(w, S) >= 1 && (C = 0), C < 0) {
    var T = Math.round(C / Pa * 1e6) / 1e6;
    C = Pa * 2 + T % 2 * Pa;
  }
  c.addData(u, y, _, o, s, b, C, h, a);
}
var hL = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, dL = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function fL(e) {
  var t = new va();
  if (!e)
    return t;
  var i = 0, n = 0, r = i, a = n, o, s = va.CMD, l = e.match(hL);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), d = void 0, f = c.match(dL) || [], v = f.length, m = 0; m < v; m++)
      f[m] = parseFloat(f[m]);
    for (var p = 0; p < v; ) {
      var g = void 0, y = void 0, _ = void 0, b = void 0, w = void 0, S = void 0, C = void 0, T = i, k = n, M = void 0, D = void 0;
      switch (h) {
        case "l":
          i += f[p++], n += f[p++], d = s.L, t.addData(d, i, n);
          break;
        case "L":
          i = f[p++], n = f[p++], d = s.L, t.addData(d, i, n);
          break;
        case "m":
          i += f[p++], n += f[p++], d = s.M, t.addData(d, i, n), r = i, a = n, h = "l";
          break;
        case "M":
          i = f[p++], n = f[p++], d = s.M, t.addData(d, i, n), r = i, a = n, h = "L";
          break;
        case "h":
          i += f[p++], d = s.L, t.addData(d, i, n);
          break;
        case "H":
          i = f[p++], d = s.L, t.addData(d, i, n);
          break;
        case "v":
          n += f[p++], d = s.L, t.addData(d, i, n);
          break;
        case "V":
          n = f[p++], d = s.L, t.addData(d, i, n);
          break;
        case "C":
          d = s.C, t.addData(d, f[p++], f[p++], f[p++], f[p++], f[p++], f[p++]), i = f[p - 2], n = f[p - 1];
          break;
        case "c":
          d = s.C, t.addData(d, f[p++] + i, f[p++] + n, f[p++] + i, f[p++] + n, f[p++] + i, f[p++] + n), i += f[p - 2], n += f[p - 1];
          break;
        case "S":
          g = i, y = n, M = t.len(), D = t.data, o === s.C && (g += i - D[M - 4], y += n - D[M - 3]), d = s.C, T = f[p++], k = f[p++], i = f[p++], n = f[p++], t.addData(d, g, y, T, k, i, n);
          break;
        case "s":
          g = i, y = n, M = t.len(), D = t.data, o === s.C && (g += i - D[M - 4], y += n - D[M - 3]), d = s.C, T = i + f[p++], k = n + f[p++], i += f[p++], n += f[p++], t.addData(d, g, y, T, k, i, n);
          break;
        case "Q":
          T = f[p++], k = f[p++], i = f[p++], n = f[p++], d = s.Q, t.addData(d, T, k, i, n);
          break;
        case "q":
          T = f[p++] + i, k = f[p++] + n, i += f[p++], n += f[p++], d = s.Q, t.addData(d, T, k, i, n);
          break;
        case "T":
          g = i, y = n, M = t.len(), D = t.data, o === s.Q && (g += i - D[M - 4], y += n - D[M - 3]), i = f[p++], n = f[p++], d = s.Q, t.addData(d, g, y, i, n);
          break;
        case "t":
          g = i, y = n, M = t.len(), D = t.data, o === s.Q && (g += i - D[M - 4], y += n - D[M - 3]), i += f[p++], n += f[p++], d = s.Q, t.addData(d, g, y, i, n);
          break;
        case "A":
          _ = f[p++], b = f[p++], w = f[p++], S = f[p++], C = f[p++], T = i, k = n, i = f[p++], n = f[p++], d = s.A, kg(T, k, i, n, S, C, _, b, w, d, t);
          break;
        case "a":
          _ = f[p++], b = f[p++], w = f[p++], S = f[p++], C = f[p++], T = i, k = n, i += f[p++], n += f[p++], d = s.A, kg(T, k, i, n, S, C, _, b, w, d, t);
          break;
      }
    }
    (h === "z" || h === "Z") && (d = s.Z, t.addData(d), i = r, n = a), o = d;
  }
  return t.toStatic(), t;
}
var H_ = (function(e) {
  St(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(i) {
  }, t;
})(Et);
function W_(e) {
  return e.setData != null;
}
function Y_(e, t) {
  var i = fL(e), n = V({}, t);
  return n.buildPath = function(r) {
    var a = W_(r);
    if (a && r.canSave()) {
      r.appendPath(i);
      var o = r.getContext();
      o && r.rebuildPath(o, 1);
    } else {
      var o = a ? r.getContext() : r;
      o && i.rebuildPath(o, 1);
    }
  }, n.applyTransform = function(r) {
    cL(i, r), this.dirtyShape();
  }, n;
}
function vL(e, t) {
  return new H_(Y_(e, t));
}
function pL(e, t) {
  var i = Y_(e, t), n = (function(r) {
    St(a, r);
    function a(o) {
      var s = r.call(this, o) || this;
      return s.applyTransform = i.applyTransform, s.buildPath = i.buildPath, s;
    }
    return a;
  })(H_);
  return n;
}
function gL(e, t) {
  for (var i = [], n = e.length, r = 0; r < n; r++) {
    var a = e[r];
    i.push(a.getUpdatedPathProxy(!0));
  }
  var o = new Et(t);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (W_(s)) {
      s.appendPath(i);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
var mL = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
})(), vu = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new mL();
  }, t.prototype.buildPath = function(i, n) {
    i.moveTo(n.cx + n.r, n.cy), i.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
})(Et);
vu.prototype.type = "circle";
var yL = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
})(), Kd = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new yL();
  }, t.prototype.buildPath = function(i, n) {
    var r = 0.5522848, a = n.cx, o = n.cy, s = n.rx, l = n.ry, u = s * r, c = l * r;
    i.moveTo(a - s, o), i.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), i.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), i.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), i.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), i.closePath();
  }, t;
})(Et);
Kd.prototype.type = "ellipse";
var U_ = Math.PI, xc = U_ * 2, $n = Math.sin, Nr = Math.cos, _L = Math.acos, ae = Math.atan2, Dg = Math.abs, mo = Math.sqrt, io = Math.max, mi = Math.min, ei = 1e-4;
function bL(e, t, i, n, r, a, o, s) {
  var l = i - e, u = n - t, c = o - r, h = s - a, d = h * l - c * u;
  if (!(d * d < ei))
    return d = (c * (t - a) - h * (e - r)) / d, [e + d * l, t + d * u];
}
function Ss(e, t, i, n, r, a, o) {
  var s = e - i, l = t - n, u = (o ? a : -a) / mo(s * s + l * l), c = u * l, h = -u * s, d = e + c, f = t + h, v = i + c, m = n + h, p = (d + v) / 2, g = (f + m) / 2, y = v - d, _ = m - f, b = y * y + _ * _, w = r - a, S = d * m - v * f, C = (_ < 0 ? -1 : 1) * mo(io(0, w * w * b - S * S)), T = (S * _ - y * C) / b, k = (-S * y - _ * C) / b, M = (S * _ + y * C) / b, D = (-S * y + _ * C) / b, L = T - p, P = k - g, R = M - p, B = D - g;
  return L * L + P * P > R * R + B * B && (T = M, k = D), {
    cx: T,
    cy: k,
    x0: -c,
    y0: -h,
    x1: T * (r / w - 1),
    y1: k * (r / w - 1)
  };
}
function xL(e) {
  var t;
  if (j(e)) {
    var i = e.length;
    if (!i)
      return e;
    i === 1 ? t = [e[0], e[0], 0, 0] : i === 2 ? t = [e[0], e[0], e[1], e[1]] : i === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function wL(e, t) {
  var i, n = io(t.r, 0), r = io(t.r0 || 0, 0), a = n > 0, o = r > 0;
  if (!(!a && !o)) {
    if (a || (n = r, r = 0), r > n) {
      var s = n;
      n = r, r = s;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, h = t.cy, d = !!t.clockwise, f = Dg(u - l), v = f > xc && f % xc;
      if (v > ei && (f = v), !(n > ei))
        e.moveTo(c, h);
      else if (f > xc - ei)
        e.moveTo(c + n * Nr(l), h + n * $n(l)), e.arc(c, h, n, l, u, !d), r > ei && (e.moveTo(c + r * Nr(u), h + r * $n(u)), e.arc(c, h, r, u, l, d));
      else {
        var m = void 0, p = void 0, g = void 0, y = void 0, _ = void 0, b = void 0, w = void 0, S = void 0, C = void 0, T = void 0, k = void 0, M = void 0, D = void 0, L = void 0, P = void 0, R = void 0, B = n * Nr(l), F = n * $n(l), W = r * Nr(u), z = r * $n(u), N = f > ei;
        if (N) {
          var $ = t.cornerRadius;
          $ && (i = xL($), m = i[0], p = i[1], g = i[2], y = i[3]);
          var X = Dg(n - r) / 2;
          if (_ = mi(X, g), b = mi(X, y), w = mi(X, m), S = mi(X, p), k = C = io(_, b), M = T = io(w, S), (C > ei || T > ei) && (D = n * Nr(u), L = n * $n(u), P = r * Nr(l), R = r * $n(l), f < U_)) {
            var U = bL(B, F, P, R, D, L, W, z);
            if (U) {
              var Q = B - U[0], it = F - U[1], ft = D - U[0], yt = L - U[1], ie = 1 / $n(_L((Q * ft + it * yt) / (mo(Q * Q + it * it) * mo(ft * ft + yt * yt))) / 2), ve = mo(U[0] * U[0] + U[1] * U[1]);
              k = mi(C, (n - ve) / (ie + 1)), M = mi(T, (r - ve) / (ie - 1));
            }
          }
        }
        if (!N)
          e.moveTo(c + B, h + F);
        else if (k > ei) {
          var xt = mi(g, k), Mt = mi(y, k), et = Ss(P, R, B, F, n, xt, d), lt = Ss(D, L, W, z, n, Mt, d);
          e.moveTo(c + et.cx + et.x0, h + et.cy + et.y0), k < C && xt === Mt ? e.arc(c + et.cx, h + et.cy, k, ae(et.y0, et.x0), ae(lt.y0, lt.x0), !d) : (xt > 0 && e.arc(c + et.cx, h + et.cy, xt, ae(et.y0, et.x0), ae(et.y1, et.x1), !d), e.arc(c, h, n, ae(et.cy + et.y1, et.cx + et.x1), ae(lt.cy + lt.y1, lt.cx + lt.x1), !d), Mt > 0 && e.arc(c + lt.cx, h + lt.cy, Mt, ae(lt.y1, lt.x1), ae(lt.y0, lt.x0), !d));
        } else
          e.moveTo(c + B, h + F), e.arc(c, h, n, l, u, !d);
        if (!(r > ei) || !N)
          e.lineTo(c + W, h + z);
        else if (M > ei) {
          var xt = mi(m, M), Mt = mi(p, M), et = Ss(W, z, D, L, r, -Mt, d), lt = Ss(B, F, P, R, r, -xt, d);
          e.lineTo(c + et.cx + et.x0, h + et.cy + et.y0), M < T && xt === Mt ? e.arc(c + et.cx, h + et.cy, M, ae(et.y0, et.x0), ae(lt.y0, lt.x0), !d) : (Mt > 0 && e.arc(c + et.cx, h + et.cy, Mt, ae(et.y0, et.x0), ae(et.y1, et.x1), !d), e.arc(c, h, r, ae(et.cy + et.y1, et.cx + et.x1), ae(lt.cy + lt.y1, lt.cx + lt.x1), d), xt > 0 && e.arc(c + lt.cx, h + lt.cy, xt, ae(lt.y1, lt.x1), ae(lt.y0, lt.x0), !d));
        } else
          e.lineTo(c + W, h + z), e.arc(c, h, r, u, l, d);
      }
      e.closePath();
    }
  }
}
var SL = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
})(), Qd = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new SL();
  }, t.prototype.buildPath = function(i, n) {
    wL(i, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
})(Et);
Qd.prototype.type = "sector";
var CL = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
})(), Jd = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new CL();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, o = Math.PI * 2;
    i.moveTo(r + n.r, a), i.arc(r, a, n.r, 0, o, !1), i.moveTo(r + n.r0, a), i.arc(r, a, n.r0, 0, o, !0);
  }, t;
})(Et);
Jd.prototype.type = "ring";
function TL(e, t, i, n) {
  var r = [], a = [], o = [], s = [], l, u, c, h;
  if (n) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var d = 0, f = e.length; d < f; d++)
      qr(c, c, e[d]), Zr(h, h, e[d]);
    qr(c, c, n[0]), Zr(h, h, n[1]);
  }
  for (var d = 0, f = e.length; d < f; d++) {
    var v = e[d];
    if (i)
      l = e[d ? d - 1 : f - 1], u = e[(d + 1) % f];
    else if (d === 0 || d === f - 1) {
      r.push(Zk(e[d]));
      continue;
    } else
      l = e[d - 1], u = e[d + 1];
    Kk(a, u, l), Nu(a, a, t);
    var m = fh(v, l), p = fh(v, u), g = m + p;
    g !== 0 && (m /= g, p /= g), Nu(o, a, -m), Nu(s, a, p);
    var y = cp([], v, o), _ = cp([], v, s);
    n && (Zr(y, y, c), qr(y, y, h), Zr(_, _, c), qr(_, _, h)), r.push(y), r.push(_);
  }
  return i && r.push(r.shift()), r;
}
function G_(e, t, i) {
  var n = t.smooth, r = t.points;
  if (r && r.length >= 2) {
    if (n) {
      var a = TL(r, n, i, t.smoothConstraint);
      e.moveTo(r[0][0], r[0][1]);
      for (var o = r.length, s = 0; s < (i ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], c = r[(s + 1) % o];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(r[0][0], r[0][1]);
      for (var s = 1, h = r.length; s < h; s++)
        e.lineTo(r[s][0], r[s][1]);
    }
    i && e.closePath();
  }
}
var ML = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), tf = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new ML();
  }, t.prototype.buildPath = function(i, n) {
    G_(i, n, !0);
  }, t;
})(Et);
tf.prototype.type = "polygon";
var kL = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), ef = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new kL();
  }, t.prototype.buildPath = function(i, n) {
    G_(i, n, !1);
  }, t;
})(Et);
ef.prototype.type = "polyline";
var DL = {}, EL = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
})(), xa = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new EL();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, o, s;
    if (this.subPixelOptimize) {
      var l = E_(DL, n, this.style);
      r = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      r = n.x1, a = n.y1, o = n.x2, s = n.y2;
    var u = n.percent;
    u !== 0 && (i.moveTo(r, a), u < 1 && (o = r * (1 - u) + o * u, s = a * (1 - u) + s * u), i.lineTo(o, s));
  }, t.prototype.pointAt = function(i) {
    var n = this.shape;
    return [
      n.x1 * (1 - i) + n.x2 * i,
      n.y1 * (1 - i) + n.y2 * i
    ];
  }, t;
})(Et);
xa.prototype.type = "line";
var we = [], AL = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
})();
function Eg(e, t, i) {
  var n = e.cpx2, r = e.cpy2;
  return n != null || r != null ? [
    (i ? Sp : ge)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (i ? Sp : ge)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (i ? Cp : Te)(e.x1, e.cpx1, e.x2, t),
    (i ? Cp : Te)(e.y1, e.cpy1, e.y2, t)
  ];
}
var nf = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new AL();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.x1, a = n.y1, o = n.x2, s = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, h = n.cpy2, d = n.percent;
    d !== 0 && (i.moveTo(r, a), c == null || h == null ? (d < 1 && (yl(r, l, o, d, we), l = we[1], o = we[2], yl(a, u, s, d, we), u = we[1], s = we[2]), i.quadraticCurveTo(l, u, o, s)) : (d < 1 && (ml(r, l, c, o, d, we), l = we[1], c = we[2], o = we[3], ml(a, u, h, s, d, we), u = we[1], h = we[2], s = we[3]), i.bezierCurveTo(l, u, c, h, o, s)));
  }, t.prototype.pointAt = function(i) {
    return Eg(this.shape, i, !1);
  }, t.prototype.tangentAt = function(i) {
    var n = Eg(this.shape, i, !0);
    return tD(n, n);
  }, t;
})(Et);
nf.prototype.type = "bezier-curve";
var LL = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
})(), pu = (function(e) {
  St(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new LL();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, o = Math.max(n.r, 0), s = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(s), h = Math.sin(s);
    i.moveTo(c * o + r, h * o + a), i.arc(r, a, o, s, l, !u);
  }, t;
})(Et);
pu.prototype.type = "arc";
var PL = (function(e) {
  St(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.type = "compound", i;
  }
  return t.prototype._updatePathDirty = function() {
    for (var i = this.shape.paths, n = this.shapeChanged(), r = 0; r < i.length; r++)
      n = n || i[r].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var i = this.shape.paths || [], n = this.getGlobalScale(), r = 0; r < i.length; r++)
      i[r].path || i[r].createPathProxy(), i[r].path.setScale(n[0], n[1], i[r].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(i, n) {
    for (var r = n.paths || [], a = 0; a < r.length; a++)
      r[a].buildPath(i, r[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var i = this.shape.paths || [], n = 0; n < i.length; n++)
      i[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Et.prototype.getBoundingRect.call(this);
  }, t;
})(Et), X_ = (function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, i) {
    this.colorStops.push({
      offset: t,
      color: i
    });
  }, e;
})(), j_ = (function(e) {
  St(t, e);
  function t(i, n, r, a, o, s) {
    var l = e.call(this, o) || this;
    return l.x = i ?? 0, l.y = n ?? 0, l.x2 = r ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return t;
})(X_), IL = (function(e) {
  St(t, e);
  function t(i, n, r, a, o) {
    var s = e.call(this, a) || this;
    return s.x = i ?? 0.5, s.y = n ?? 0.5, s.r = r ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return t;
})(X_), wc = Math.min, RL = Math.max, Cs = Math.abs, zn = [0, 0], Vn = [0, 0], te = Uy(), Ts = te.minTv, Ms = te.maxTv, q_ = (function() {
  function e(t, i) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new Ct();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new Ct();
    t && this.fromBoundingRect(t, i);
  }
  return e.prototype.fromBoundingRect = function(t, i) {
    var n = this._corners, r = this._axes, a = t.x, o = t.y, s = a + t.width, l = o + t.height;
    if (n[0].set(a, o), n[1].set(s, o), n[2].set(s, l), n[3].set(a, l), i)
      for (var u = 0; u < 4; u++)
        n[u].transform(i);
    Ct.sub(r[0], n[1], n[0]), Ct.sub(r[1], n[3], n[0]), r[0].normalize(), r[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = r[u].dot(n[0]);
  }, e.prototype.intersect = function(t, i, n) {
    var r = !0, a = !i;
    return i && Ct.set(i, 0, 0), te.reset(n, !a), !this._intersectCheckOneSide(this, t, a, 1) && (r = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (r = !1, a) || !a && !te.negativeSize && Ct.copy(i, r ? te.useDir ? te.dirMinTv : Ts : Ms), r;
  }, e.prototype._intersectCheckOneSide = function(t, i, n, r) {
    for (var a = !0, o = 0; o < 2; o++) {
      var s = t._axes[o];
      if (t._getProjMinMaxOnAxis(o, t._corners, zn), t._getProjMinMaxOnAxis(o, i._corners, Vn), te.negativeSize || zn[1] < Vn[0] || zn[0] > Vn[1]) {
        if (a = !1, te.negativeSize || n)
          return a;
        var l = Cs(Vn[0] - zn[1]), u = Cs(zn[0] - Vn[1]);
        wc(l, u) > Ms.len() && (l < u ? Ct.scale(Ms, s, -l * r) : Ct.scale(Ms, s, u * r));
      } else if (!n) {
        var l = Cs(Vn[0] - zn[1]), u = Cs(zn[0] - Vn[1]);
        (te.useDir || wc(l, u) < Ts.len()) && ((l < u || !te.bidirectional) && (Ct.scale(Ts, s, l * r), te.useDir && te.calcDirMTV()), (l >= u || !te.bidirectional) && (Ct.scale(Ts, s, -u * r), te.useDir && te.calcDirMTV()));
      }
    }
    return a;
  }, e.prototype._getProjMinMaxOnAxis = function(t, i, n) {
    for (var r = this._axes[t], a = this._origin, o = i[0].dot(r) + a[t], s = o, l = o, u = 1; u < i.length; u++) {
      var c = i[u].dot(r) + a[t];
      s = wc(c, s), l = RL(c, l);
    }
    n[0] = s + te.touchThreshold, n[1] = l - te.touchThreshold, te.negativeSize = n[1] < n[0];
  }, e;
})(), OL = [], BL = (function(e) {
  St(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.notClear = !0, i.incremental = !0, i._displayables = [], i._temporaryDisplayables = [], i._cursor = 0, i;
  }
  return t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(i, n) {
    n ? this._temporaryDisplayables.push(i) : this._displayables.push(i), this.markRedraw();
  }, t.prototype.addDisplayables = function(i, n) {
    n = n || !1;
    for (var r = 0; r < i.length; r++)
      this.addDisplayable(i[r], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(i) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      i && i(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      i && i(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var n = this._displayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var n = this._temporaryDisplayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var i = new rt(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var r = this._displayables[n], a = r.getBoundingRect().clone();
        r.needLocalTransform() && a.applyTransform(r.getLocalTransform(OL)), i.union(a);
      }
      this._rect = i;
    }
    return this._rect;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    if (a.contain(r[0], r[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(i, n))
          return !0;
      }
    return !1;
  }, t;
})(Xo);
It();
function NL(e, t, i, n, r) {
  var a;
  if (t && t.ecModel) {
    var o = t.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = t && t.isAnimationEnabled(), l = e === "update";
  if (s) {
    var u = void 0, c = void 0, h = void 0;
    n ? (u = tt(n.duration, 200), c = tt(n.easing, "cubicOut"), h = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), ht(h) && (h = h(i, r)), ht(u) && (u = u(i));
    var d = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return d;
  } else
    return null;
}
function rf(e, t, i, n, r, a, o) {
  var s = !1, l;
  ht(r) ? (o = a, a = r, r = null) : Z(r) && (a = r.cb, o = r.during, s = r.isFrom, l = r.removeOpt, r = r.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = NL(e, n, r, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, r) : null);
  if (c && c.duration > 0) {
    var h = c.duration, d = c.delay, f = c.easing, v = {
      duration: h,
      delay: d || 0,
      easing: f,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: o
    };
    s ? t.animateFrom(i, v) : t.animateTo(i, v);
  } else
    t.stopAnimation(), !s && t.attr(i), o && o(1), a && a();
}
function af(e, t, i, n, r, a) {
  rf("update", e, t, i, n, r, a);
}
function Z_(e, t, i, n, r, a) {
  rf("enter", e, t, i, n, r, a);
}
function yo(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var i = e.animators[t];
    if (i.scope === "leave")
      return !0;
  }
  return !1;
}
function K_(e, t, i, n, r, a) {
  yo(e) || rf("leave", e, t, i, n, r, a);
}
function Ag(e, t, i, n) {
  e.removeTextContent(), e.removeTextGuideLine(), K_(e, {
    style: {
      opacity: 0
    }
  }, t, i, n);
}
function FL(e, t, i) {
  function n() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(r) {
    r.isGroup || Ag(r, t, i, n);
  }) : Ag(e, t, i, n);
}
var zh = {}, $L = ["x", "y"], zL = ["width", "height"];
function VL(e) {
  return Et.extend(e);
}
var HL = pL;
function WL(e, t) {
  return HL(e, t);
}
function ui(e, t) {
  zh[e] = t;
}
function YL(e) {
  if (zh.hasOwnProperty(e))
    return zh[e];
}
function of(e, t, i, n) {
  var r = vL(e, t);
  return i && (n === "center" && (i = J_(i, r.getBoundingRect())), tb(r, i)), r;
}
function Q_(e, t, i) {
  var n = new wr({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(r) {
      if (i === "center") {
        var a = {
          width: r.width,
          height: r.height
        };
        n.setStyle(J_(t, a));
      }
    }
  });
  return n;
}
function J_(e, t) {
  var i = t.width / t.height, n = e.height * i, r;
  n <= e.width ? r = e.height : (n = e.width, r = n / i);
  var a = e.x + e.width / 2, o = e.y + e.height / 2;
  return {
    x: a - n / 2,
    y: o - r / 2,
    width: n,
    height: r
  };
}
var UL = gL;
function tb(e, t) {
  if (e.applyTransform) {
    var i = e.getBoundingRect(), n = i.calculateTransform(t);
    e.applyTransform(n);
  }
}
function sf(e, t) {
  return E_(e, e, {
    lineWidth: t
  }), e;
}
function GL(e, t) {
  return A_(e, e, t), e;
}
var XL = nr;
function jL(e, t) {
  for (var i = Nd([]); e && e !== t; )
    fo(i, e.getLocalTransform(), i), e = e.parent;
  return i;
}
function lf(e, t, i) {
  return t && !Ae(t) && (t = ir.getLocalTransform(t)), i && (t = Wo([], t)), Be([], e, t);
}
function qL(e, t, i) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : Vi(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : Vi(2 * t[4] / t[2]), a = [e === "left" ? -n : e === "right" ? n : 0, e === "top" ? -r : e === "bottom" ? r : 0];
  return a = lf(a, t, i), Vi(a[0]) > Vi(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function Lg(e) {
  return !e.isGroup;
}
function ZL(e) {
  return e.shape != null;
}
function KL(e, t, i) {
  if (!e || !t)
    return;
  function n(o) {
    var s = {};
    return o.traverse(function(l) {
      Lg(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function r(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return ZL(o) && (s.shape = ct(o.shape)), s;
  }
  var a = n(e);
  t.traverse(function(o) {
    if (Lg(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = r(o);
        o.attr(r(s)), af(o, l, i, Lt(o).dataIndex);
      }
    }
  });
}
function QL(e, t) {
  return dt(e, function(i) {
    var n = i[0];
    n = ri(n, t.x), n = Lo(n, t.x + t.width);
    var r = i[1];
    return r = ri(r, t.y), r = Lo(r, t.y + t.height), [n, r];
  });
}
function JL(e, t) {
  var i = ri(e.x, t.x), n = Lo(e.x + e.width, t.x + t.width), r = ri(e.y, t.y), a = Lo(e.y + e.height, t.y + t.height);
  if (n >= i && a >= r)
    return {
      x: i,
      y: r,
      width: n - i,
      height: a - r
    };
}
function eb(e, t, i) {
  var n = V({
    rectHover: !0
  }, t), r = n.style = {
    strokeNoScale: !0
  };
  if (i = i || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (r.image = e.slice(8), zt(r, i), new wr(n)) : of(e.replace("path://", ""), n, i, "center");
}
function tP(e, t, i, n, r) {
  for (var a = 0, o = r[r.length - 1]; a < r.length; a++) {
    var s = r[a];
    if (ib(e, t, i, n, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function ib(e, t, i, n, r, a, o, s) {
  var l = i - e, u = n - t, c = o - r, h = s - a, d = Sc(c, h, l, u);
  if (eP(d))
    return !1;
  var f = e - r, v = t - a, m = Sc(f, v, l, u) / d;
  if (m < 0 || m > 1)
    return !1;
  var p = Sc(f, v, c, h) / d;
  return !(p < 0 || p > 1);
}
function Sc(e, t, i, n) {
  return e * n - i * t;
}
function eP(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function Vh(e, t, i, n, r) {
  return t == null || (Nt(t) ? kt[0] = kt[1] = kt[2] = kt[3] = t : (process.env.NODE_ENV !== "production" && J(t.length === 4), kt[0] = t[0], kt[1] = t[1], kt[2] = t[2], kt[3] = t[3]), n && (kt[0] = ri(0, kt[0]), kt[1] = ri(0, kt[1]), kt[2] = ri(0, kt[2]), kt[3] = ri(0, kt[3])), i && (kt[0] = -kt[0], kt[1] = -kt[1], kt[2] = -kt[2], kt[3] = -kt[3]), Pg(e, kt, "x", "width", 3, 1, r && r[0] || 0), Pg(e, kt, "y", "height", 0, 2, r && r[1] || 0)), e;
}
var kt = [0, 0, 0, 0];
function Pg(e, t, i, n, r, a, o) {
  var s = t[a] + t[r], l = e[n];
  e[n] += s, o = ri(0, Lo(o, l)), e[n] < o ? (e[n] = o, e[i] += t[r] >= 0 ? -t[r] : t[a] >= 0 ? l + t[a] : Vi(s) > 1e-8 ? (l - o) * t[r] / s : 0) : e[i] -= t[r];
}
function uf(e) {
  var t = e.itemTooltipOption, i = e.componentModel, n = e.itemName, r = K(t) ? {
    formatter: t
  } : t, a = i.mainType, o = i.componentIndex, s = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = e.formatterParamsExtra;
  l && E(Bt(l), function(c) {
    Ci(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = Lt(e.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: n,
    option: zt({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: s
    }, r)
  };
}
function Hh(e, t) {
  var i;
  e.isGroup && (i = t(e)), i || e.traverse(t);
}
function nb(e, t) {
  if (e)
    if (j(e))
      for (var i = 0; i < e.length; i++)
        Hh(e[i], t);
    else
      Hh(e, t);
}
function cf(e) {
  return !e || Vi(e[1]) < ks && Vi(e[2]) < ks || Vi(e[0]) < ks && Vi(e[3]) < ks;
}
var ks = 1e-5;
function Ro(e, t) {
  return e ? rt.copy(e, t) : t.clone();
}
function hf(e, t) {
  return t ? Fd(e || Ti(), t) : void 0;
}
function Oo(e) {
  return {
    z: e.get("z") || 0,
    zlevel: e.get("zlevel") || 0
  };
}
function iP(e) {
  var t = -1 / 0, i = 1 / 0;
  Hh(e, function(a) {
    n(a), n(a.getTextContent()), n(a.getTextGuideLine());
  });
  function n(a) {
    if (!(!a || a.isGroup)) {
      var o = a.currentStates;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          r(a.states[o[s]]);
      r(a);
    }
  }
  function r(a) {
    if (a) {
      var o = a.z2;
      o > t && (t = o), o < i && (i = o);
    }
  }
  return i > t && (i = t = 0), {
    min: i,
    max: t
  };
}
function rb(e, t, i) {
  ab(e, t, i, -1 / 0);
}
function ab(e, t, i, n) {
  if (e.ignoreModelZ)
    return n;
  var r = e.getTextContent(), a = e.getTextGuideLine(), o = e.isGroup;
  if (o)
    for (var s = e.childrenRef(), l = 0; l < s.length; l++)
      n = ri(ab(s[l], t, i, n), n);
  else
    e.z = t, e.zlevel = i, n = ri(e.z2 || 0, n);
  if (r && (r.z = t, r.zlevel = i, isFinite(n) && (r.z2 = n + 2)), a) {
    var u = e.textGuideLineConfig;
    a.z = t, a.zlevel = i, isFinite(n) && (a.z2 = n + (u && u.showAbove ? 1 : -1));
  }
  return n;
}
ui("circle", vu);
ui("ellipse", Kd);
ui("sector", Qd);
ui("ring", Jd);
ui("polygon", tf);
ui("polyline", ef);
ui("rect", he);
ui("line", xa);
ui("bezierCurve", nf);
ui("arc", pu);
const nP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: pu,
  BezierCurve: nf,
  BoundingRect: rt,
  Circle: vu,
  CompoundPath: PL,
  Ellipse: Kd,
  Group: oi,
  Image: wr,
  IncrementalDisplayable: BL,
  Line: xa,
  LinearGradient: j_,
  OrientedBoundingRect: q_,
  Path: Et,
  Point: Ct,
  Polygon: tf,
  Polyline: ef,
  RadialGradient: IL,
  Rect: he,
  Ring: Jd,
  Sector: Qd,
  Text: ti,
  WH: zL,
  XY: $L,
  applyTransform: lf,
  calcZ2Range: iP,
  clipPointsByRect: QL,
  clipRectByRect: JL,
  createIcon: eb,
  ensureCopyRect: Ro,
  ensureCopyTransform: hf,
  expandOrShrinkRect: Vh,
  extendPath: WL,
  extendShape: VL,
  getShapeClass: YL,
  getTransform: jL,
  groupTransition: KL,
  initProps: Z_,
  isBoundingRectAxisAligned: cf,
  isElementRemoved: yo,
  lineLineIntersect: ib,
  linePolygonIntersect: tP,
  makeImage: Q_,
  makePath: of,
  mergePath: UL,
  registerShape: ui,
  removeElement: K_,
  removeElementWithFadeOut: FL,
  resizePath: tb,
  retrieveZInfo: Oo,
  setTooltipConfig: uf,
  subPixelOptimize: XL,
  subPixelOptimizeLine: sf,
  subPixelOptimizeRect: GL,
  transformDirection: qL,
  traverseElements: nb,
  traverseUpdateZ: rb,
  updateProps: af
}, Symbol.toStringTag, { value: "Module" }));
var gu = {};
function rP(e, t) {
  for (var i = 0; i < yn.length; i++) {
    var n = yn[i], r = t[n], a = e.ensureState(n);
    a.style = a.style || {}, a.style.text = r;
  }
  var o = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(o, !0);
}
function Ig(e, t, i) {
  var n = e.labelFetcher, r = e.labelDataIndex, a = e.labelDimIndex, o = t.normal, s;
  n && (s = n.getFormattedLabel(r, "normal", null, a, o && o.get("formatter"), i != null ? {
    interpolatedValue: i
  } : null)), s == null && (s = ht(e.defaultText) ? e.defaultText(r, e, i) : e.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < yn.length; u++) {
    var c = yn[u], h = t[c];
    l[c] = tt(n ? n.getFormattedLabel(r, c, null, a, h && h.get("formatter")) : null, s);
  }
  return l;
}
function Rg(e, t, i, n) {
  i = i || gu;
  for (var r = e instanceof ti, a = !1, o = 0; o < pg.length; o++) {
    var s = t[pg[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = r ? e : e.getTextContent();
  if (a) {
    r || (l || (l = new ti(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = Ig(i, t), c = t.normal, h = !!c.getShallow("show"), d = yr(c, n, i, !1, !r);
    d.text = u.normal, r || e.setTextConfig(Bg(c, i, !1));
    for (var o = 0; o < yn.length; o++) {
      var f = yn[o], s = t[f];
      if (s) {
        var v = l.ensureState(f), m = !!tt(s.getShallow("show"), h);
        if (m !== h && (v.ignore = !m), v.style = yr(s, n, i, !0, !r), v.style.text = u[f], !r) {
          var p = e.ensureState(f);
          p.textConfig = Bg(s, i, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (d.x = l.style.x), l.style.y != null && (d.y = l.style.y), l.ignore = !h, l.useStyle(d), l.dirty(), i.enableTextSetter && (lP(l).setLabelText = function(g) {
      var y = Ig(i, t, g);
      rP(l, y);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function Og(e, t) {
  t = t || "label";
  for (var i = {
    normal: e.getModel(t)
  }, n = 0; n < yn.length; n++) {
    var r = yn[n];
    i[r] = e.getModel([r, t]);
  }
  return i;
}
function yr(e, t, i, n, r) {
  var a = {};
  return aP(a, e, i, n, r), t && V(a, t), a;
}
function Bg(e, t, i) {
  t = t || {};
  var n = {}, r, a = e.getShallow("rotate"), o = tt(e.getShallow("distance"), i ? null : 5), s = e.getShallow("offset");
  return r = e.getShallow("position") || (i ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (n.position = r), s != null && (n.offset = s), a != null && (a *= Math.PI / 180, n.rotation = a), o != null && (n.distance = o), n.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (n.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (n.layoutRect = t.layoutRect), n;
}
function aP(e, t, i, n, r) {
  i = i || gu;
  var a = t.ecModel, o = a && a.option.textStyle, s = oP(t), l;
  if (s) {
    l = {};
    var u = "richInheritPlainLabel", c = tt(t.get(u), a ? a.get(u) : void 0);
    for (var h in s)
      if (s.hasOwnProperty(h)) {
        var d = t.getModel(["rich", h]);
        zg(l[h] = {}, d, o, t, c, i, n, r, !1, !0);
      }
  }
  l && (e.rich = l);
  var f = t.get("overflow");
  f && (e.overflow = f);
  var v = t.get("lineOverflow");
  v && (e.lineOverflow = v);
  var m = e, p = t.get("minMargin");
  if (p != null)
    p = Nt(p) ? p / 2 : 0, m.margin = [p, p, p, p], m.__marginType = ta.minMargin;
  else {
    var g = t.get("textMargin");
    g != null && (m.margin = Od(g), m.__marginType = ta.textMargin);
  }
  zg(e, t, o, null, null, i, n, r, !0, !1);
}
function oP(e) {
  for (var t; e && e !== e.ecModel; ) {
    var i = (e.option || gu).rich;
    if (i) {
      t = t || {};
      for (var n = Bt(i), r = 0; r < n.length; r++) {
        var a = n[r];
        t[a] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var Ng = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], Fg = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], $g = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function zg(e, t, i, n, r, a, o, s, l, u) {
  i = !o && i || gu;
  var c = a && a.inheritColor, h = t.getShallow("color"), d = t.getShallow("textBorderColor"), f = tt(t.getShallow("opacity"), i.opacity);
  (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && ee("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), (d === "inherit" || d === "auto") && (process.env.NODE_ENV !== "production" && d === "auto" && ee("color: 'auto'", "color: 'inherit'"), c ? d = c : d = null), s || (h = h || i.color, d = d || i.textBorderColor), h != null && (e.fill = h), d != null && (e.stroke = d);
  var v = tt(t.getShallow("textBorderWidth"), i.textBorderWidth);
  v != null && (e.lineWidth = v);
  var m = tt(t.getShallow("textBorderType"), i.textBorderType);
  m != null && (e.lineDash = m);
  var p = tt(t.getShallow("textBorderDashOffset"), i.textBorderDashOffset);
  p != null && (e.lineDashOffset = p), !o && f == null && !u && (f = a && a.defaultOpacity), f != null && (e.opacity = f), !o && !s && e.fill == null && a.inheritColor && (e.fill = a.inheritColor);
  for (var g = 0; g < Ng.length; g++) {
    var y = Ng[g], _ = r !== !1 && n ? ur(t.getShallow(y), n.getShallow(y), i[y]) : tt(t.getShallow(y), i[y]);
    _ != null && (e[y] = _);
  }
  for (var g = 0; g < Fg.length; g++) {
    var y = Fg[g], _ = t.getShallow(y);
    _ != null && (e[y] = _);
  }
  if (e.verticalAlign == null) {
    var b = t.getShallow("baseline");
    b != null && (e.verticalAlign = b);
  }
  if (!l || !a.disableBox) {
    for (var g = 0; g < $g.length; g++) {
      var y = $g[g], _ = t.getShallow(y);
      _ != null && (e[y] = _);
    }
    var w = t.getShallow("borderType");
    w != null && (e.borderDash = w), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && ee("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = c), (e.borderColor === "auto" || e.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && ee("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = c);
  }
}
function sP(e, t) {
  var i = t && t.getModel("textStyle");
  return xi([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || i && i.getShallow("fontStyle") || "",
    e.fontWeight || i && i.getShallow("fontWeight") || "",
    (e.fontSize || i && i.getShallow("fontSize") || 12) + "px",
    e.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var lP = It(), ta = {
  minMargin: 1,
  textMargin: 2
}, uP = ["textStyle", "color"], Cc = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Tc = new ti(), cP = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var i = this.ecModel;
      return this.getShallow("color") || (!t && i ? i.get(uP) : null);
    }, e.prototype.getFont = function() {
      return sP({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var i = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Cc.length; n++)
        i[Cc[n]] = this.getShallow(Cc[n]);
      return Tc.useStyle(i), Tc.update(), Tc.getBoundingRect();
    }, e;
  })()
), ob = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], hP = Io(ob), dP = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return hP(this, t);
    }, e;
  })()
), sb = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], fP = Io(sb), vP = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, i) {
      return fP(this, t, i);
    }, e;
  })()
), Ot = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.parentModel = i, this.ecModel = n, this.option = t;
    }
    return e.prototype.init = function(t, i, n) {
    }, e.prototype.mergeOption = function(t, i) {
      Gt(this.option, t, !0);
    }, e.prototype.get = function(t, i) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !i && this.parentModel);
    }, e.prototype.getShallow = function(t, i) {
      var n = this.option, r = n == null ? n : n[t];
      if (r == null && !i) {
        var a = this.parentModel;
        a && (r = a.getShallow(t));
      }
      return r;
    }, e.prototype.getModel = function(t, i) {
      var n = t != null, r = n ? this.parsePath(t) : null, a = n ? this._doGet(r) : this.option;
      return i = i || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new e(a, i, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(ct(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!nt.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, i) {
      var n = this.option;
      if (!t)
        return n;
      for (var r = 0; r < t.length && !(t[r] && (n = n && typeof n == "object" ? n[t[r]] : null, n == null)); r++)
        ;
      return n == null && i && (n = i._doGet(this.resolveParentPath(t), i.parentModel)), n;
    }, e;
  })()
);
Hd(Ot);
GE(Ot);
si(Ot, dP);
si(Ot, vP);
si(Ot, KE);
si(Ot, cP);
var pP = Math.round(Math.random() * 10);
function mu(e) {
  return [e || "", pP++].join("_");
}
function gP(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(i, n) {
    var r = wi(i);
    t[r.main] = n;
  }, e.determineSubType = function(i, n) {
    var r = n.type;
    if (!r) {
      var a = wi(i).main;
      e.hasSubTypes(i) && t[a] && (r = t[a](n));
    }
    return r;
  };
}
function mP(e, t) {
  e.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = i(o), c = u.graph, h = u.noEntryList, d = {};
    for (E(a, function(y) {
      d[y] = !0;
    }); h.length; ) {
      var f = h.pop(), v = c[f], m = !!d[f];
      m && (s.call(l, f, v.originalDeps.slice()), delete d[f]), E(v.successor, m ? g : p);
    }
    E(d, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = Cl("Circular dependency may exists: ", d, a, o)), new Error(y);
    });
    function p(y) {
      c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
    }
    function g(y) {
      d[y] = !0, p(y);
    }
  };
  function i(a) {
    var o = {}, s = [];
    return E(a, function(l) {
      var u = n(o, l), c = u.originalDeps = t(l), h = r(c, a);
      u.entryCount = h.length, u.entryCount === 0 && s.push(l), E(h, function(d) {
        Pt(u.predecessor, d) < 0 && u.predecessor.push(d);
        var f = n(o, d);
        Pt(f.successor, d) < 0 && f.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function n(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function r(a, o) {
    var s = [];
    return E(a, function(l) {
      Pt(o, l) >= 0 && s.push(l);
    }), s;
  }
}
const yP = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, _P = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var Al = "ZH", df = "EN", oa = df, Qs = {}, ff = {}, lb = nt.domSupported ? (function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || oa).toUpperCase()
  );
  return e.indexOf(Al) > -1 ? Al : oa;
})() : oa;
function ub(e, t) {
  e = e.toUpperCase(), ff[e] = new Ot(t), Qs[e] = t;
}
function bP(e) {
  if (K(e)) {
    var t = Qs[e.toUpperCase()] || {};
    return e === Al || e === df ? ct(t) : Gt(ct(t), ct(Qs[oa]), !1);
  } else
    return Gt(ct(e), ct(Qs[oa]), !1);
}
function xP(e) {
  return ff[e];
}
function wP() {
  return ff[oa];
}
ub(df, yP);
ub(Al, _P);
function Qi(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function cb(e, t, i, n) {
  var r = uu(e), a = r[SP(i)](), o = r[CP(i)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = r[TP(i)](), u = r["get" + (i ? "UTC" : "") + "Day"](), c = r[MP(i)](), h = (c - 1) % 12 + 1, d = r[kP(i)](), f = r[DP(i)](), v = r[EP(i)](), m = c >= 12 ? "pm" : "am", p = m.toUpperCase(), g = n instanceof Ot ? n : xP(lb) || wP(), y = g.getModel("time"), _ = y.get("month"), b = y.get("monthAbbr"), w = y.get("dayOfWeek"), S = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, m + "").replace(/{A}/g, p + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, Qi(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, _[o - 1]).replace(/{MMM}/g, b[o - 1]).replace(/{MM}/g, Qi(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, Qi(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, w[u]).replace(/{ee}/g, S[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Qi(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Qi(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Qi(d, 2)).replace(/{m}/g, d + "").replace(/{ss}/g, Qi(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, Qi(v, 3)).replace(/{S}/g, v + "");
}
function SP(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function CP(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function TP(e) {
  return e ? "getUTCDate" : "getDate";
}
function MP(e) {
  return e ? "getUTCHours" : "getHours";
}
function kP(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function DP(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function EP(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function AP(e) {
  if (!f_(e))
    return K(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function hb(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(i, n) {
    return n.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var vf = Od;
function Wh(e, t, i) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function r(c) {
    return c && xi(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var o = t === "time", s = e instanceof Date;
  if (o || s) {
    var l = o ? uu(e) : e;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else return cb(l, n, i);
  }
  if (t === "ordinal")
    return dl(e) ? r(e) : Nt(e) && a(e) ? e + "" : "-";
  var u = Sl(e);
  return a(u) ? AP(u) : dl(e) ? r(e) : typeof e == "boolean" ? e + "" : "-";
}
var Vg = ["a", "b", "c", "d", "e", "f", "g"], Mc = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function db(e, t, i) {
  j(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
    var o = Vg[a];
    e = e.replace(Mc(o), Mc(o, 0));
  }
  for (var s = 0; s < n; s++)
    for (var l = 0; l < r.length; l++) {
      var u = t[s][r[l]];
      e = e.replace(Mc(Vg[l], s), i ? Ce(u) : u);
    }
  return e;
}
function LP(e, t) {
  var i = K(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, n = i.color, r = i.type;
  t = i.extraCssText;
  var a = i.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ce(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Ce(n) + ";" + (t || "") + '"></span>';
  var o = i.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: r === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function Bo(e, t) {
  return t = t || "transparent", K(e) ? e : Z(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function Hg(e, t) {
  if (t === "_blank" || t === "blank") {
    var i = window.open();
    i.opener = null, i.location.href = e;
  } else
    window.open(e, t);
}
var kc = {}, Dc = {}, yu = (
  /** @class */
  (function() {
    function e() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return e.prototype.create = function(t, i) {
      this._nonSeriesBoxMasterList = n(kc, !0), this._normalMasterList = n(Dc, !1);
      function n(r, a) {
        var o = [];
        return E(r, function(s, l) {
          var u = s.create(t, i);
          o = o.concat(u || []), process.env.NODE_ENV !== "production" && a && E(u, function(c) {
            return J(!c.update);
          });
        }), o;
      }
    }, e.prototype.update = function(t, i) {
      E(this._normalMasterList, function(n) {
        n.update && n.update(t, i);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, e.register = function(t, i) {
      if (t === "matrix" || t === "calendar") {
        kc[t] = i;
        return;
      }
      Dc[t] = i;
    }, e.get = function(t) {
      return Dc[t] || kc[t];
    }, e;
  })()
), Wg = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
}, PP = ot();
function IP(e) {
  var t = e.getShallow("coord", !0), i = Wg.coord;
  if (t == null) {
    var n = PP.get(e.type);
    n && n.getCoord2 && (i = Wg.coord2, t = n.getCoord2(e));
  }
  return {
    coord: t,
    from: i
  };
}
var Js = E, RP = ["left", "right", "top", "bottom", "width", "height"], Ds = [["width", "left", "right"], ["height", "top", "bottom"]];
function fb(e, t, i, n, r) {
  var a = 0, o = 0;
  n == null && (n = 1 / 0), r == null && (r = 1 / 0);
  var s = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = t.childAt(u + 1), d = h && h.getBoundingRect(), f, v;
    if (e === "horizontal") {
      var m = c.width + (d ? -d.x + c.x : 0);
      f = a + m, f > n || l.newline ? (a = 0, f = m, o += s + i, s = c.height) : s = Math.max(s, c.height);
    } else {
      var p = c.height + (d ? -d.y + c.y : 0);
      v = o + p, v > r || l.newline ? (a += s + i, o = 0, v = p, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), e === "horizontal" ? a = f + i : o = v + i);
  });
}
me(fb, "vertical");
me(fb, "horizontal");
function OP(e, t) {
  return {
    left: e.getShallow("left", t),
    top: e.getShallow("top", t),
    right: e.getShallow("right", t),
    bottom: e.getShallow("bottom", t),
    width: e.getShallow("width", t),
    height: e.getShallow("height", t)
  };
}
function pf(e, t, i) {
  i = vf(i || 0);
  var n = t.width, r = t.height, a = Me(e.left, n), o = Me(e.top, r), s = Me(e.right, n), l = Me(e.bottom, r), u = Me(e.width, n), c = Me(e.height, r), h = i[2] + i[0], d = i[1] + i[3], f = e.aspect;
  switch (isNaN(u) && (u = n - s - d - a), isNaN(c) && (c = r - l - h - o), f != null && (isNaN(u) && isNaN(c) && (f > n / r ? u = n * 0.8 : c = r * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(a) && (a = n - s - u - d), isNaN(o) && (o = r - l - c - h), e.left || e.right) {
    case "center":
      a = n / 2 - u / 2 - i[3];
      break;
    case "right":
      a = n - u - d;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      o = r / 2 - c / 2 - i[0];
      break;
    case "bottom":
      o = r - c - h;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = n - d - a - (s || 0)), isNaN(c) && (c = r - h - o - (l || 0));
  var v = new rt((t.x || 0) + a + i[3], (t.y || 0) + o + i[0], u, c);
  return v.margin = i, v;
}
var Ec = {
  rect: 1
};
function vb(e, t, i) {
  var n, r, a, o = e.boxCoordinateSystem, s;
  if (o) {
    var l = IP(e), u = l.coord, c = l.from;
    if (o.dataToLayout) {
      a = Ec.rect, s = c;
      var h = o.dataToLayout(u);
      n = h.contentRect || h.rect;
    } else
      process.env.NODE_ENV !== "production" && Ft(e.type + "[" + e.componentIndex + "]" + (" layout based on " + o.type + " is not supported."));
  }
  return a == null && (a = Ec.rect), a === Ec.rect && (n || (n = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), r = [n.x + n.width / 2, n.y + n.height / 2]), {
    type: a,
    refContainer: n,
    refPoint: r,
    boxCoordFrom: s
  };
}
function Ll(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return Z(t) ? t : t ? {
    type: t
  } : null;
}
function Pl(e, t, i) {
  var n = i && i.ignoreSize;
  !j(n) && (n = [n, n]);
  var r = o(Ds[0], 0), a = o(Ds[1], 1);
  l(Ds[0], e, r), l(Ds[1], e, a);
  function o(u, c) {
    var h = {}, d = 0, f = {}, v = 0, m = 2;
    if (Js(u, function(y) {
      f[y] = e[y];
    }), Js(u, function(y) {
      Ci(t, y) && (h[y] = f[y] = t[y]), s(h, y) && d++, s(f, y) && v++;
    }), n[c])
      return s(t, u[1]) ? f[u[2]] = null : s(t, u[2]) && (f[u[1]] = null), f;
    if (v === m || !d)
      return f;
    if (d >= m)
      return h;
    for (var p = 0; p < u.length; p++) {
      var g = u[p];
      if (!Ci(h, g) && Ci(e, g)) {
        h[g] = e[g];
        break;
      }
    }
    return h;
  }
  function s(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, h) {
    Js(u, function(d) {
      c[d] = h[d];
    });
  }
}
function pb(e) {
  return BP({}, e);
}
function BP(e, t) {
  return t && e && Js(RP, function(i) {
    Ci(t, i) && (e[i] = t[i]);
  }), e;
}
var NP = It(), wt = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t(i, n, r) {
      var a = e.call(this, i, n, r) || this;
      return a.uid = mu("ec_cpt_model"), a;
    }
    return t.prototype.init = function(i, n, r) {
      this.mergeDefaultAndTheme(i, r);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = Ll(this), a = r ? pb(i) : {}, o = n.getTheme();
      Gt(i, o.get(this.mainType)), Gt(i, this.getDefaultOption()), r && Pl(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      Gt(this.option, i, !0);
      var r = Ll(this);
      r && Pl(this.option, i, r);
    }, t.prototype.optionUpdated = function(i, n) {
    }, t.prototype.getDefaultOption = function() {
      var i = this.constructor;
      if (!WE(i))
        return i.defaultOption;
      var n = NP(this);
      if (!n.defaultOption) {
        for (var r = [], a = i; a; ) {
          var o = a.prototype.defaultOption;
          o && r.push(o), a = a.superClass;
        }
        for (var s = {}, l = r.length - 1; l >= 0; l--)
          s = Gt(s, r[l], !0);
        n.defaultOption = s;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(i, n) {
      var r = i + "Index", a = i + "Id";
      return Go(this.ecModel, i, {
        index: this.get(r, !0),
        id: this.get(a, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      return OP(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(i) {
      this.option.zlevel = i;
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "component", i.id = "", i.name = "", i.mainType = "", i.subType = "", i.componentIndex = 0;
    })(), t;
  })(Ot)
);
x_(wt, Ot);
Wd(wt);
gP(wt);
mP(wt, FP);
function FP(e) {
  var t = [];
  return E(wt.getClassesByMainType(e), function(i) {
    t = t.concat(i.dependencies || i.prototype.dependencies || []);
  }), t = dt(t, function(i) {
    return wi(i).main;
  }), e !== "dataset" && Pt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var vt = {
  color: {},
  darkColor: {},
  size: {}
}, $t = vt.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
V($t, {
  primary: $t.neutral80,
  secondary: $t.neutral70,
  tertiary: $t.neutral60,
  quaternary: $t.neutral50,
  disabled: $t.neutral20,
  border: $t.neutral30,
  borderTint: $t.neutral20,
  borderShade: $t.neutral40,
  background: $t.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: $t.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: $t.neutral70,
  axisLineTint: $t.neutral40,
  axisTick: $t.neutral70,
  axisTickMinor: $t.neutral60,
  axisLabel: $t.neutral70,
  axisSplitLine: $t.neutral15,
  axisMinorSplitLine: $t.neutral05
});
for (var Hn in $t)
  if ($t.hasOwnProperty(Hn)) {
    var Yg = $t[Hn];
    Hn === "theme" ? vt.darkColor.theme = $t.theme.slice() : Hn === "highlight" ? vt.darkColor.highlight = "rgba(255,231,130,0.4)" : Hn.indexOf("accent") === 0 ? vt.darkColor[Hn] = aa(Yg, null, function(e) {
      return e * 0.5;
    }, function(e) {
      return Math.min(1, 1.3 - e);
    }) : vt.darkColor[Hn] = aa(Yg, null, function(e) {
      return e * 0.9;
    }, function(e) {
      return 1 - Math.pow(e, 1.5);
    });
  }
vt.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var gb = "";
typeof navigator < "u" && (gb = navigator.platform || "");
var Fr = "rgba(0, 0, 0, 0.2)", mb = vt.color.theme[0], $P = aa(mb, null, null, 0.9);
const zP = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: vt.color.theme,
  gradientColor: [$P, mb],
  aria: {
    decal: {
      decals: [{
        color: Fr,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Fr,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Fr,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Fr,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Fr,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Fr,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: gb.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Yh = ot(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Ne = "original", fe = "arrayRows", ci = "objectRows", Ei = "keyedColumns", Yi = "typedArray", yb = "unknown", Di = "column", Sr = "row", Le = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, _b = It();
function VP(e) {
  _b(e).datasetMap = ot();
}
function HP(e, t, i) {
  var n = {}, r = bb(t);
  if (!r || !e)
    return n;
  var a = [], o = [], s = t.ecModel, l = _b(s).datasetMap, u = r.uid + "_" + i.seriesLayoutBy, c, h;
  e = e.slice(), E(e, function(m, p) {
    var g = Z(m) ? m : e[p] = {
      name: m
    };
    g.type === "ordinal" && c == null && (c = p, h = v(g)), n[g.name] = [];
  });
  var d = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  E(e, function(m, p) {
    var g = m.name, y = v(m);
    if (c == null) {
      var _ = d.valueWayDim;
      f(n[g], _, y), f(o, _, y), d.valueWayDim += y;
    } else if (c === p)
      f(n[g], 0, y), f(a, 0, y);
    else {
      var _ = d.categoryWayDim;
      f(n[g], _, y), f(o, _, y), d.categoryWayDim += y;
    }
  });
  function f(m, p, g) {
    for (var y = 0; y < g; y++)
      m.push(p + y);
  }
  function v(m) {
    var p = m.dimsDef;
    return p ? p.length : 1;
  }
  return a.length && (n.itemName = a), o.length && (n.seriesName = o), n;
}
function bb(e) {
  var t = e.get("data", !0);
  if (!t)
    return Go(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, rn).models[0];
}
function WP(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : Go(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, rn).models;
}
function xb(e, t) {
  return YP(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function YP(e, t, i, n, r, a) {
  var o, s = 5;
  if (be(e))
    return Le.Not;
  var l, u;
  if (n) {
    var c = n[a];
    Z(c) ? (l = c.name, u = c.type) : K(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Le.Must : Le.Not;
  if (t === fe) {
    var h = e;
    if (i === Sr) {
      for (var d = h[a], f = 0; f < (d || []).length && f < s; f++)
        if ((o = b(d[r + f])) != null)
          return o;
    } else
      for (var f = 0; f < h.length && f < s; f++) {
        var v = h[r + f];
        if (v && (o = b(v[a])) != null)
          return o;
      }
  } else if (t === ci) {
    var m = e;
    if (!l)
      return Le.Not;
    for (var f = 0; f < m.length && f < s; f++) {
      var p = m[f];
      if (p && (o = b(p[l])) != null)
        return o;
    }
  } else if (t === Ei) {
    var g = e;
    if (!l)
      return Le.Not;
    var d = g[l];
    if (!d || be(d))
      return Le.Not;
    for (var f = 0; f < d.length && f < s; f++)
      if ((o = b(d[f])) != null)
        return o;
  } else if (t === Ne)
    for (var y = e, f = 0; f < y.length && f < s; f++) {
      var p = y[f], _ = Yo(p);
      if (!j(_))
        return Le.Not;
      if ((o = b(_[a])) != null)
        return o;
    }
  function b(w) {
    var S = K(w);
    if (w != null && Number.isFinite(Number(w)) && w !== "")
      return S ? Le.Might : Le.Not;
    if (S && w !== "-")
      return Le.Must;
  }
  return Le.Not;
}
var UP = ot();
function GP(e, t, i) {
  var n = UP.get(t);
  if (!n)
    return i;
  var r = n(e);
  if (!r)
    return i;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < r.length; a++)
      J(fa(r[a]));
  return i.concat(r);
}
var Ug = It();
It();
var gf = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, i, n) {
      var r = ye(this.get("color", !0)), a = this.get("colorLayer", !0);
      return jP(this, Ug, r, a, t, i, n);
    }, e.prototype.clearColorPalette = function() {
      qP(this, Ug);
    }, e;
  })()
);
function XP(e, t) {
  for (var i = e.length, n = 0; n < i; n++)
    if (e[n].length > t)
      return e[n];
  return e[i - 1];
}
function jP(e, t, i, n, r, a, o) {
  a = a || e;
  var s = t(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(r))
    return u[r];
  var c = o == null || !n ? i : XP(n, o);
  if (c = c || i, !(!c || !c.length)) {
    var h = c[l];
    return r && (u[r] = h), s.paletteIdx = (l + 1) % c.length, h;
  }
}
function qP(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var Es, Ia, Gg, Ac = "\0_ec_inner", Xg = 1, ZP = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, KP = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Il = {};
function QP(e) {
  E(e, function(t, i) {
    if (!wt.hasClass(i)) {
      var n = ZP[i];
      n && !Il[n] && (Ft("Component " + i + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), Il[n] = !0);
    }
  });
}
var mf = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(i, n, r, a, o, s) {
      a = a || {}, this.option = null, this._theme = new Ot(a), this._locale = new Ot(o), this._optionManager = s;
    }, t.prototype.setOption = function(i, n, r) {
      process.env.NODE_ENV !== "production" && (J(i != null, "option is null/undefined"), J(i[Ac] !== Xg, "please use chart.getOption()"));
      var a = Zg(n);
      this._optionManager.setOption(i, r, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(i, n) {
      return this._resetOption(i, Zg(n));
    }, t.prototype._resetOption = function(i, n) {
      var r = !1, a = this._optionManager;
      if (!i || i === "recreate") {
        var o = a.mountOption(i === "recreate");
        process.env.NODE_ENV !== "production" && QP(o), !this.option || i === "recreate" ? Gg(this, o) : (this.restoreData(), this._mergeOption(o, n)), r = !0;
      }
      if ((i === "timeline" || i === "media") && this.restoreData(), !i || i === "recreate" || i === "timeline") {
        var s = a.getTimelineOption(this);
        s && (r = !0, this._mergeOption(s, n));
      }
      if (!i || i === "recreate" || i === "media") {
        var l = a.getMediaOption(this);
        l.length && E(l, function(u) {
          r = !0, this._mergeOption(u, n);
        }, this);
      }
      return r;
    }, t.prototype.mergeOption = function(i) {
      this._mergeOption(i, null);
    }, t.prototype._mergeOption = function(i, n) {
      var r = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = ot(), u = n && n.replaceMergeMainTypeMap;
      VP(this), E(i, function(h, d) {
        h != null && (wt.hasClass(d) ? d && (s.push(d), l.set(d, !0)) : r[d] = r[d] == null ? ct(h) : Gt(r[d], h, !0));
      }), u && u.each(function(h, d) {
        wt.hasClass(d) && !l.get(d) && (s.push(d), l.set(d, !0));
      }), wt.topologicalTravel(s, wt.getAllClassMainTypes(), c, this);
      function c(h) {
        var d = GP(this, h, ye(i[h])), f = a.get(h), v = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          f ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), m = DE(f, d, v);
        OE(m, h, wt), r[h] = null, a.set(h, null), o.set(h, 0);
        var p = [], g = [], y = 0, _, b;
        E(m, function(w, S) {
          var C = w.existing, T = w.newOption;
          if (!T)
            C && (C.mergeOption({}, this), C.optionUpdated({}, !1));
          else {
            var k = h === "series", M = wt.getClass(
              h,
              w.keyInfo.subType,
              !k
              // Give a more detailed warn later if series don't exists
            );
            if (!M) {
              if (process.env.NODE_ENV !== "production") {
                var D = w.keyInfo.subType, L = KP[D];
                Il[D] || (Il[D] = !0, Ft(L ? "Series " + D + ` is used but not imported.
import { ` + L + ` } from 'echarts/charts';
echarts.use([` + L + "]);" : "Unknown series " + D));
              }
              return;
            }
            if (h === "tooltip") {
              if (_) {
                process.env.NODE_ENV !== "production" && (b || (Xe("Currently only one tooltip component is allowed."), b = !0));
                return;
              }
              _ = !0;
            }
            if (C && C.constructor === M)
              C.name = w.keyInfo.name, C.mergeOption(T, this), C.optionUpdated(T, !1);
            else {
              var P = V({
                componentIndex: S
              }, w.keyInfo);
              C = new M(T, this, this, P), V(C, P), w.brandNew && (C.__requireNewView = !0), C.init(T, this, this), C.optionUpdated(null, !0);
            }
          }
          C ? (p.push(C.option), g.push(C), y++) : (p.push(void 0), g.push(void 0));
        }, this), r[h] = p, a.set(h, g), o.set(h, y), h === "series" && Es(this);
      }
      this._seriesIndices || Es(this);
    }, t.prototype.getOption = function() {
      var i = ct(this.option);
      return E(i, function(n, r) {
        if (wt.hasClass(r)) {
          for (var a = ye(n), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !fa(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, i[r] = a;
        }
      }), delete i[Ac], i;
    }, t.prototype.setTheme = function(i) {
      this._theme = new Ot(i), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(i) {
      this._payload = i;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(i, n) {
      var r = this._componentsMap.get(i);
      if (r) {
        var a = r[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var o = 0; o < r.length; o++)
            if (r[o])
              return r[o];
        }
      }
    }, t.prototype.queryComponents = function(i) {
      var n = i.mainType;
      if (!n)
        return [];
      var r = i.index, a = i.id, o = i.name, s = this._componentsMap.get(n);
      if (!s || !s.length)
        return [];
      var l;
      return r != null ? (l = [], E(ye(r), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = jg("id", a, s) : o != null ? l = jg("name", o, s) : l = Re(s, function(u) {
        return !!u;
      }), qg(l, i);
    }, t.prototype.findComponents = function(i) {
      var n = i.query, r = i.mainType, a = s(n), o = a ? this.queryComponents(a) : Re(this._componentsMap.get(r), function(u) {
        return !!u;
      });
      return l(qg(o, i));
      function s(u) {
        var c = r + "Index", h = r + "Id", d = r + "Name";
        return u && (u[c] != null || u[h] != null || u[d] != null) ? {
          mainType: r,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[d]
        } : null;
      }
      function l(u) {
        return i.filter ? Re(u, i.filter) : u;
      }
    }, t.prototype.eachComponent = function(i, n, r) {
      var a = this._componentsMap;
      if (ht(i)) {
        var o = n, s = i;
        a.each(function(h, d) {
          for (var f = 0; h && f < h.length; f++) {
            var v = h[f];
            v && s.call(o, d, v, v.componentIndex);
          }
        });
      } else
        for (var l = K(i) ? a.get(i) : Z(i) ? this.findComponents(i) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(r, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(i) {
      var n = ai(i, null);
      return Re(this._componentsMap.get("series"), function(r) {
        return !!r && n != null && r.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(i) {
      return this._componentsMap.get("series")[i];
    }, t.prototype.getSeriesByType = function(i) {
      return Re(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === i;
      });
    }, t.prototype.getSeries = function() {
      return Re(this._componentsMap.get("series"), function(i) {
        return !!i;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(i, n) {
      Ia(this), E(this._seriesIndices, function(r) {
        var a = this._componentsMap.get("series")[r];
        i.call(n, a, r);
      }, this);
    }, t.prototype.eachRawSeries = function(i, n) {
      E(this._componentsMap.get("series"), function(r) {
        r && i.call(n, r, r.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(i, n, r) {
      Ia(this), E(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === i && n.call(r, o, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(i, n, r) {
      return E(this.getSeriesByType(i), n, r);
    }, t.prototype.isSeriesFiltered = function(i) {
      return Ia(this), this._seriesIndicesMap.get(i.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(i, n) {
      Ia(this);
      var r = [];
      E(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        i.call(n, o, a) && r.push(a);
      }, this), this._seriesIndices = r, this._seriesIndicesMap = ot(r);
    }, t.prototype.restoreData = function(i) {
      Es(this);
      var n = this._componentsMap, r = [];
      n.each(function(a, o) {
        wt.hasClass(o) && r.push(o);
      }), wt.topologicalTravel(r, wt.getAllClassMainTypes(), function(a) {
        E(n.get(a), function(o) {
          o && (a !== "series" || !JP(o, i)) && o.restoreData();
        });
      });
    }, t.internalField = (function() {
      Es = function(i) {
        var n = i._seriesIndices = [];
        E(i._componentsMap.get("series"), function(r) {
          r && n.push(r.componentIndex);
        }), i._seriesIndicesMap = ot(n);
      }, Ia = function(i) {
        if (process.env.NODE_ENV !== "production" && !i._seriesIndices)
          throw new Error("Option should contains series.");
      }, Gg = function(i, n) {
        i.option = {}, i.option[Ac] = Xg, i._componentsMap = ot({
          series: []
        }), i._componentsCount = ot();
        var r = n.aria;
        Z(r) && r.enabled == null && (r.enabled = !0), t5(n, i._theme.option), Gt(n, zP, !1), i._mergeOption(n, null);
      };
    })(), t;
  })(Ot)
);
function JP(e, t) {
  if (t) {
    var i = t.seriesIndex, n = t.seriesId, r = t.seriesName;
    return i != null && e.componentIndex !== i || n != null && e.id !== n || r != null && e.name !== r;
  }
}
function t5(e, t) {
  var i = e.color && !e.colorLayer;
  E(t, function(n, r) {
    r === "colorLayer" && i || r === "color" && e.color || wt.hasClass(r) || (typeof n == "object" ? e[r] = e[r] ? Gt(e[r], n, !1) : ct(n) : e[r] == null && (e[r] = n));
  });
}
function jg(e, t, i) {
  if (j(t)) {
    var n = ot();
    return E(t, function(a) {
      if (a != null) {
        var o = ai(a, null);
        o != null && n.set(a, !0);
      }
    }), Re(i, function(a) {
      return a && n.get(a[e]);
    });
  } else {
    var r = ai(t, null);
    return Re(i, function(a) {
      return a && r != null && a[e] === r;
    });
  }
}
function qg(e, t) {
  return t.hasOwnProperty("subType") ? Re(e, function(i) {
    return i && i.subType === t.subType;
  }) : e;
}
function Zg(e) {
  var t = ot();
  return e && E(ye(e.replaceMerge), function(i) {
    process.env.NODE_ENV !== "production" && J(wt.hasClass(i), '"' + i + '" is not valid component main type in "replaceMerge"'), t.set(i, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
si(mf, gf);
var e5 = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], wb = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      E(e5, function(i) {
        this[i] = mt(t[i], t);
      }, this);
    }
    return e;
  })()
), i5 = /^(min|max)?(.+)$/, n5 = (
  /** @class */
  (function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, i, n) {
      t && (E(ye(t.series), function(o) {
        o && o.data && be(o.data) && hh(o.data);
      }), E(ye(t.dataset), function(o) {
        o && o.source && be(o.source) && hh(o.source);
      })), t = ct(t);
      var r = this._optionBackup, a = r5(t, i, !r);
      this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, e.prototype.mountOption = function(t) {
      var i = this._optionBackup;
      return this._timelineOptions = i.timelineOptions, this._mediaList = i.mediaList, this._mediaDefault = i.mediaDefault, this._currentMediaIndices = [], ct(t ? i.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var i, n = this._timelineOptions;
      if (n.length) {
        var r = t.getComponent("timeline");
        r && (i = ct(
          // FIXME:TS as TimelineModel or quivlant interface
          n[r.getCurrentIndex()]
        ));
      }
      return i;
    }, e.prototype.getMediaOption = function(t) {
      var i = this._api.getWidth(), n = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!r.length && !a)
        return s;
      for (var l = 0, u = r.length; l < u; l++)
        a5(r[l].query, i, n) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !s5(o, this._currentMediaIndices) && (s = dt(o, function(c) {
        return ct(c === -1 ? a.option : r[c].option);
      })), this._currentMediaIndices = o, s;
    }, e;
  })()
);
function r5(e, t, i) {
  var n = [], r, a, o = e.baseOption, s = e.timeline, l = e.options, u = e.media, c = !!e.media, h = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((h || c) && (e.options = e.media = null), a = e), c && (j(u) ? E(u, function(f) {
    process.env.NODE_ENV !== "production" && f && !f.option && Z(f.query) && Z(f.query.option) && Ft("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), f && f.option && (f.query ? n.push(f) : r || (r = f));
  }) : process.env.NODE_ENV !== "production" && Ft("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), d(a), E(l, function(f) {
    return d(f);
  }), E(n, function(f) {
    return d(f.option);
  });
  function d(f) {
    E(t, function(v) {
      v(f, i);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: r,
    mediaList: n
  };
}
function a5(e, t, i) {
  var n = {
    width: t,
    height: i,
    aspectratio: t / i
    // lower case for convenience.
  }, r = !0;
  return E(e, function(a, o) {
    var s = o.match(i5);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      o5(n[u], a, l) || (r = !1);
    }
  }), r;
}
function o5(e, t, i) {
  return i === "min" ? e >= t : i === "max" ? e <= t : e === t;
}
function s5(e, t) {
  return e.join(",") === t.join(",");
}
var ze = E, No = Z, Kg = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function Lc(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0, n = Kg.length; i < n; i++) {
      var r = Kg[i], a = t.normal, o = t.emphasis;
      a && a[r] && (process.env.NODE_ENV !== "production" && ee("itemStyle.normal." + r, r), e[r] = e[r] || {}, e[r].normal ? Gt(e[r].normal, a[r]) : e[r].normal = a[r], a[r] = null), o && o[r] && (process.env.NODE_ENV !== "production" && ee("itemStyle.emphasis." + r, "emphasis." + r), e[r] = e[r] || {}, e[r].emphasis ? Gt(e[r].emphasis, o[r]) : e[r].emphasis = o[r], o[r] = null);
    }
}
function se(e, t, i) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var n = e[t].normal, r = e[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && Gi("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), i ? (e[t].normal = e[t].emphasis = null, zt(e[t], n)) : e[t] = n), r && (process.env.NODE_ENV !== "production" && Gi(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = r, r.focus && (e.emphasis.focus = r.focus), r.blurScope && (e.emphasis.blurScope = r.blurScope));
  }
}
function no(e) {
  se(e, "itemStyle"), se(e, "lineStyle"), se(e, "areaStyle"), se(e, "label"), se(e, "labelLine"), se(e, "upperLabel"), se(e, "edgeLabel");
}
function Ht(e, t) {
  var i = No(e) && e[t], n = No(i) && i.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && Gi("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var r = 0, a = Up.length; r < a; r++) {
      var o = Up[r];
      n.hasOwnProperty(o) && (i[o] = n[o]);
    }
  }
}
function Ye(e) {
  e && (no(e), Ht(e, "label"), e.emphasis && Ht(e.emphasis, "label"));
}
function l5(e) {
  if (No(e)) {
    Lc(e), no(e), Ht(e, "label"), Ht(e, "upperLabel"), Ht(e, "edgeLabel"), e.emphasis && (Ht(e.emphasis, "label"), Ht(e.emphasis, "upperLabel"), Ht(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (Lc(t), Ye(t));
    var i = e.markLine;
    i && (Lc(i), Ye(i));
    var n = e.markArea;
    n && Ye(n);
    var r = e.data;
    if (e.type === "graph") {
      r = r || e.nodes;
      var a = e.links || e.edges;
      if (a && !be(a))
        for (var o = 0; o < a.length; o++)
          Ye(a[o]);
      E(e.categories, function(u) {
        no(u);
      });
    }
    if (r && !be(r))
      for (var o = 0; o < r.length; o++)
        Ye(r[o]);
    if (t = e.markPoint, t && t.data)
      for (var s = t.data, o = 0; o < s.length; o++)
        Ye(s[o]);
    if (i = e.markLine, i && i.data)
      for (var l = i.data, o = 0; o < l.length; o++)
        j(l[o]) ? (Ye(l[o][0]), Ye(l[o][1])) : Ye(l[o]);
    e.type === "gauge" ? (Ht(e, "axisLabel"), Ht(e, "title"), Ht(e, "detail")) : e.type === "treemap" ? (se(e.breadcrumb, "itemStyle"), E(e.levels, function(u) {
      no(u);
    })) : e.type === "tree" && no(e.leaves);
  }
}
function Pi(e) {
  return j(e) ? e : e ? [e] : [];
}
function Qg(e) {
  return (j(e) ? e[0] : e) || {};
}
function u5(e, t) {
  ze(Pi(e.series), function(n) {
    No(n) && l5(n);
  });
  var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), ze(i, function(n) {
    ze(Pi(e[n]), function(r) {
      r && (Ht(r, "axisLabel"), Ht(r.axisPointer, "label"));
    });
  }), ze(Pi(e.parallel), function(n) {
    var r = n && n.parallelAxisDefault;
    Ht(r, "axisLabel"), Ht(r && r.axisPointer, "label");
  }), ze(Pi(e.calendar), function(n) {
    se(n, "itemStyle"), Ht(n, "dayLabel"), Ht(n, "monthLabel"), Ht(n, "yearLabel");
  }), ze(Pi(e.radar), function(n) {
    Ht(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && Gi("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && Gi("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && ze(n.indicator, function(r) {
      r.text && ee("text", "name", "radar.indicator");
    });
  }), ze(Pi(e.geo), function(n) {
    No(n) && (Ye(n), ze(Pi(n.regions), function(r) {
      Ye(r);
    }));
  }), ze(Pi(e.timeline), function(n) {
    Ye(n), se(n, "label"), se(n, "itemStyle"), se(n, "controlStyle", !0);
    var r = n.data;
    j(r) && E(r, function(a) {
      Z(a) && (se(a, "label"), se(a, "itemStyle"));
    });
  }), ze(Pi(e.toolbox), function(n) {
    se(n, "iconStyle"), ze(n.feature, function(r) {
      se(r, "iconStyle");
    });
  }), Ht(Qg(e.axisPointer), "label"), Ht(Qg(e.tooltip).axisPointer, "label");
}
function c5(e, t) {
  for (var i = t.split(","), n = e, r = 0; r < i.length && (n = n && n[i[r]], n != null); r++)
    ;
  return n;
}
function h5(e, t, i, n) {
  for (var r = t.split(","), a = e, o, s = 0; s < r.length - 1; s++)
    o = r[s], a[o] == null && (a[o] = {}), a = a[o];
  a[r[s]] == null && (a[r[s]] = i);
}
function Jg(e) {
  e && E(d5, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var d5 = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], f5 = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], Pc = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Ra(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0; i < Pc.length; i++) {
      var n = Pc[i][1], r = Pc[i][0];
      t[n] != null && (t[r] = t[n], process.env.NODE_ENV !== "production" && ee(n, r));
    }
}
function tm(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && ee("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function em(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && ee("downplay", "blur", "sunburst"));
}
function v5(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && ee("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function Sb(e, t) {
  if (e)
    for (var i = 0; i < e.length; i++)
      t(e[i]), e[i] && Sb(e[i].children, t);
}
function Cb(e, t) {
  u5(e, t), e.series = ye(e.series), E(e.series, function(i) {
    if (Z(i)) {
      var n = i.type;
      if (n === "line")
        i.clipOverflow != null && (i.clip = i.clipOverflow, process.env.NODE_ENV !== "production" && ee("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        i.clockWise != null && (i.clockwise = i.clockWise, process.env.NODE_ENV !== "production" && ee("clockWise", "clockwise")), tm(i.label);
        var r = i.data;
        if (r && !be(r))
          for (var a = 0; a < r.length; a++)
            tm(r[a]);
        i.hoverOffset != null && (i.emphasis = i.emphasis || {}, (i.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && ee("hoverOffset", "emphasis.scaleSize"), i.emphasis.scaleSize = i.hoverOffset));
      } else if (n === "gauge") {
        var o = c5(i, "pointer.color");
        o != null && h5(i, "itemStyle.color", o);
      } else if (n === "bar") {
        Ra(i), Ra(i.backgroundStyle), Ra(i.emphasis);
        var r = i.data;
        if (r && !be(r))
          for (var a = 0; a < r.length; a++)
            typeof r[a] == "object" && (Ra(r[a]), Ra(r[a] && r[a].emphasis));
      } else if (n === "sunburst") {
        var s = i.highlightPolicy;
        s && (i.emphasis = i.emphasis || {}, i.emphasis.focus || (i.emphasis.focus = s, process.env.NODE_ENV !== "production" && ee("highlightPolicy", "emphasis.focus", "sunburst"))), em(i), Sb(i.data, em);
      } else n === "graph" || n === "sankey" ? v5(i) : n === "map" && (i.mapType && !i.map && (process.env.NODE_ENV !== "production" && ee("mapType", "map", "map"), i.map = i.mapType), i.mapLocation && (process.env.NODE_ENV !== "production" && Gi("`mapLocation` is not used anymore."), zt(i, i.mapLocation)));
      i.hoverAnimation != null && (i.emphasis = i.emphasis || {}, i.emphasis && i.emphasis.scale == null && (process.env.NODE_ENV !== "production" && ee("hoverAnimation", "emphasis.scale"), i.emphasis.scale = i.hoverAnimation)), Jg(i);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), E(f5, function(i) {
    var n = e[i];
    n && (j(n) || (n = [n]), E(n, function(r) {
      Jg(r);
    }));
  });
}
function p5(e) {
  var t = ot();
  e.eachSeries(function(i) {
    var n = i.get("stack");
    if (n) {
      var r = t.get(n) || t.set(n, []), a = i.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: i
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      r.push(o);
    }
  }), t.each(function(i) {
    if (i.length !== 0) {
      var n = i[0].seriesModel, r = n.get("stackOrder") || "seriesAsc";
      r === "seriesDesc" && i.reverse(), E(i, function(a, o) {
        a.data.setCalculationInfo("stackedOnSeries", o > 0 ? i[o - 1].seriesModel : null);
      }), g5(i);
    }
  });
}
function g5(e) {
  E(e, function(t, i) {
    var n = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], o = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, c, h) {
      var d = o.get(t.stackedDimension, h);
      if (isNaN(d))
        return r;
      var f, v;
      s ? v = o.getRawIndex(h) : f = o.get(t.stackedByDimension, h);
      for (var m = NaN, p = i - 1; p >= 0; p--) {
        var g = e[p];
        if (s || (v = g.data.rawIndexOf(g.stackedByDimension, f)), v >= 0) {
          var y = g.data.getByRawIndex(g.stackResultDimension, v);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && d >= 0 && y > 0 || l === "samesign" && d <= 0 && y < 0) {
            d = xE(d, y), m = y;
            break;
          }
        }
      }
      return n[0] = d, n[1] = m, n;
    });
  });
}
var _u = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === Ei ? {} : []), this.sourceFormat = t.sourceFormat || yb, this.seriesLayoutBy = t.seriesLayoutBy || Di, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var i = this.dimensionsDefine = t.dimensionsDefine;
      if (i)
        for (var n = 0; n < i.length; n++) {
          var r = i[n];
          r.type == null && xb(this, n) === Le.Must && (r.type = "ordinal");
        }
    }
    return e;
  })()
);
function yf(e) {
  return e instanceof _u;
}
function Uh(e, t, i) {
  i = i || Tb(e);
  var n = t.seriesLayoutBy, r = y5(e, i, n, t.sourceHeader, t.dimensions), a = new _u({
    data: e,
    sourceFormat: i,
    seriesLayoutBy: n,
    dimensionsDefine: r.dimensionsDefine,
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount,
    metaRawOption: ct(t)
  });
  return a;
}
function _f(e) {
  return new _u({
    data: e,
    sourceFormat: be(e) ? Yi : Ne
  });
}
function m5(e) {
  return new _u({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: ct(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function Tb(e) {
  var t = yb;
  if (be(e))
    t = Yi;
  else if (j(e)) {
    e.length === 0 && (t = fe);
    for (var i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      if (r != null) {
        if (j(r) || be(r)) {
          t = fe;
          break;
        } else if (Z(r)) {
          t = ci;
          break;
        }
      }
    }
  } else if (Z(e)) {
    for (var a in e)
      if (Ci(e, a) && Ae(e[a])) {
        t = Ei;
        break;
      }
  }
  return t;
}
function y5(e, t, i, n, r) {
  var a, o;
  if (!e)
    return {
      dimensionsDefine: im(r),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (t === fe) {
    var s = e;
    n === "auto" || n == null ? nm(function(u) {
      u != null && u !== "-" && (K(u) ? o == null && (o = 1) : o = 0);
    }, i, s, 10) : o = Nt(n) ? n : n ? 1 : 0, !r && o === 1 && (r = [], nm(function(u, c) {
      r[c] = u != null ? u + "" : "";
    }, i, s, 1 / 0)), a = r ? r.length : i === Sr ? s.length : s[0] ? s[0].length : null;
  } else if (t === ci)
    r || (r = _5(e));
  else if (t === Ei)
    r || (r = [], E(e, function(u, c) {
      r.push(c);
    }));
  else if (t === Ne) {
    var l = Yo(e[0]);
    a = j(l) && l.length || 1;
  } else t === Yi && process.env.NODE_ENV !== "production" && J(!!r, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: o,
    dimensionsDefine: im(r),
    dimensionsDetectedCount: a
  };
}
function _5(e) {
  for (var t = 0, i; t < e.length && !(i = e[t++]); )
    ;
  if (i)
    return Bt(i);
}
function im(e) {
  if (e) {
    var t = ot();
    return dt(e, function(i, n) {
      i = Z(i) ? i : {
        name: i
      };
      var r = {
        name: i.name,
        displayName: i.displayName,
        type: i.type
      };
      if (r.name == null)
        return r;
      r.name += "", r.displayName == null && (r.displayName = r.name);
      var a = t.get(r.name);
      return a ? r.name += "-" + a.count++ : t.set(r.name, {
        count: 1
      }), r;
    });
  }
}
function nm(e, t, i, n) {
  if (t === Sr)
    for (var r = 0; r < i.length && r < n; r++)
      e(i[r] ? i[r][0] : null, r);
  else
    for (var a = i[0] || [], r = 0; r < a.length && r < n; r++)
      e(a[r], r);
}
function Mb(e) {
  var t = e.sourceFormat;
  return t === ci || t === Ei;
}
var Wn, Yn, Un, Gn, rm, am, kb = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = yf(t) ? t : _f(t);
      this._source = n;
      var r = this._data = n.data, a = n.sourceFormat, o = n.seriesLayoutBy;
      if (a === Yi) {
        if (process.env.NODE_ENV !== "production" && i == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = i, this._data = r;
      }
      if (process.env.NODE_ENV !== "production") {
        var s = b5[Rl(a, o)];
        s && s(r, n.dimensionsDefine);
      }
      am(this, r, n);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, i) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    })(), e.internalField = (function() {
      var t;
      am = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, d = l.dimensionsDefine, f = rm[Rl(u, c)];
        if (process.env.NODE_ENV !== "production" && J(f, "Invalide sourceFormat: " + u), V(o, f), u === Yi)
          o.getItem = i, o.count = r, o.fillStorage = n;
        else {
          var v = Db(u, c);
          o.getItem = mt(v, null, s, h, d);
          var m = Eb(u, c);
          o.count = mt(m, null, s, h, d);
        }
      };
      var i = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, h = 0; h < u; h++)
          s[h] = l[c + h];
        return s;
      }, n = function(o, s, l, u) {
        for (var c = this._data, h = this._dimSize, d = 0; d < h; d++) {
          for (var f = u[d], v = f[0] == null ? 1 / 0 : f[0], m = f[1] == null ? -1 / 0 : f[1], p = s - o, g = l[d], y = 0; y < p; y++) {
            var _ = c[y * h + d];
            g[o + y] = _, _ < v && (v = _), _ > m && (m = _);
          }
          f[0] = v, f[1] = m;
        }
      }, r = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      rm = (t = {}, t[fe + "_" + Di] = {
        pure: !0,
        appendData: a
      }, t[fe + "_" + Sr] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[ci] = {
        pure: !0,
        appendData: a
      }, t[Ei] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          E(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, t[Ne] = {
        appendData: a
      }, t[Yi] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          process.env.NODE_ENV !== "production" && J(be(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    })(), e;
  })()
), As = function(e) {
  j(e) || Ft("series.data or dataset.source must be an array.");
}, b5 = (Wn = {}, Wn[fe + "_" + Di] = As, Wn[fe + "_" + Sr] = As, Wn[ci] = As, Wn[Ei] = function(e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i].name;
    n == null && Ft("dimension name must not be null/undefined.");
  }
}, Wn[Ne] = As, Wn), om = function(e, t, i, n) {
  return e[n];
}, x5 = (Yn = {}, Yn[fe + "_" + Di] = function(e, t, i, n) {
  return e[n + t];
}, Yn[fe + "_" + Sr] = function(e, t, i, n, r) {
  n += t;
  for (var a = r || [], o = e, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[n] : null;
  }
  return a;
}, Yn[ci] = om, Yn[Ei] = function(e, t, i, n, r) {
  for (var a = r || [], o = 0; o < i.length; o++) {
    var s = i[o].name, l = s != null ? e[s] : null;
    a[o] = l ? l[n] : null;
  }
  return a;
}, Yn[Ne] = om, Yn);
function Db(e, t) {
  var i = x5[Rl(e, t)];
  return process.env.NODE_ENV !== "production" && J(i, 'Do not support get item on "' + e + '", "' + t + '".'), i;
}
var sm = function(e, t, i) {
  return e.length;
}, w5 = (Un = {}, Un[fe + "_" + Di] = function(e, t, i) {
  return Math.max(0, e.length - t);
}, Un[fe + "_" + Sr] = function(e, t, i) {
  var n = e[0];
  return n ? Math.max(0, n.length - t) : 0;
}, Un[ci] = sm, Un[Ei] = function(e, t, i) {
  var n = i[0].name, r = n != null ? e[n] : null;
  return r ? r.length : 0;
}, Un[Ne] = sm, Un);
function Eb(e, t) {
  var i = w5[Rl(e, t)];
  return process.env.NODE_ENV !== "production" && J(i, 'Do not support count on "' + e + '", "' + t + '".'), i;
}
var Ic = function(e, t, i) {
  return e[t];
}, S5 = (Gn = {}, Gn[fe] = Ic, Gn[ci] = function(e, t, i) {
  return e[i];
}, Gn[Ei] = Ic, Gn[Ne] = function(e, t, i) {
  var n = Yo(e);
  return n instanceof Array ? n[t] : n;
}, Gn[Yi] = Ic, Gn);
function Ab(e) {
  var t = S5[e];
  return process.env.NODE_ENV !== "production" && J(t, 'Do not support get value on "' + e + '".'), t;
}
function Rl(e, t) {
  return e === fe ? e + "_" + t : e;
}
function Ol(e, t, i) {
  if (e) {
    var n = e.getRawDataItem(t);
    if (n != null) {
      var r = e.getStore(), a = r.getSource().sourceFormat;
      if (i != null) {
        var o = e.getDimensionIndex(i), s = r.getDimensionProperty(o);
        return Ab(a)(n, o, s);
      } else {
        var l = n;
        return a === Ne && (l = Yo(n)), l;
      }
    }
  }
}
var C5 = /\{@(.+?)\}/g, T5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, i) {
      var n = this.getData(i), r = this.getRawValue(t, i), a = n.getRawIndex(t), o = n.getName(t), s = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, d = h === "series", f = n.userOutput && n.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: d ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: d ? this.id : null,
        seriesName: d ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: i,
        value: r,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, i, n, r, a, o) {
      i = i || "normal";
      var s = this.getData(n), l = this.getDataParams(t, n);
      if (o && (l.value = o.interpolatedValue), r != null && j(l.value) && (l.value = l.value[r]), !a) {
        var u = s.getItemModel(t);
        a = u.get(i === "normal" ? ["label", "formatter"] : [i, "label", "formatter"]);
      }
      if (ht(a))
        return l.status = i, l.dimensionIndex = r, a(l);
      if (K(a)) {
        var c = db(a, l);
        return c.replace(C5, function(h, d) {
          var f = d.length, v = d;
          v.charAt(0) === "[" && v.charAt(f - 1) === "]" && (v = +v.slice(1, f - 1), process.env.NODE_ENV !== "production" && isNaN(v) && Ft("Invalide label formatter: @" + d + ", only support @[0], @[1], @[2], ..."));
          var m = Ol(s, t, v);
          if (o && j(o.interpolatedValue)) {
            var p = s.getDimensionIndex(v);
            p >= 0 && (m = o.interpolatedValue[p]);
          }
          return m != null ? m + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, i) {
      return Ol(this.getData(i), t);
    }, e.prototype.formatTooltip = function(t, i, n) {
    }, e;
  })()
);
function lm(e) {
  var t, i;
  return Z(e) ? e.type ? i = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + Cl(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: i
  };
}
function _o(e) {
  return new M5(e);
}
var M5 = (
  /** @class */
  (function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var i = this._upstream, n = t && t.skip;
      if (this._dirty && i) {
        var r = this.context;
        r.data = r.outputData = i.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = !1, h = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var d = t && t.step;
      if (i ? (process.env.NODE_ENV !== "production" && J(i._outputDueEnd != null), this._dueEnd = i._outputDueEnd) : (process.env.NODE_ENV !== "production" && J(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var f = this._dueIndex, v = Math.min(d != null ? this._dueIndex + d : 1 / 0, this._dueEnd);
        if (!n && (h || f < v)) {
          var m = this._progress;
          if (j(m))
            for (var p = 0; p < m.length; p++)
              this._doProgress(m[p], f, v, l, u);
          else
            this._doProgress(m, f, v, l, u);
        }
        this._dueIndex = v;
        var g = this._settedOutputEnd != null ? this._settedOutputEnd : v;
        process.env.NODE_ENV !== "production" && J(g >= this._outputDueEnd), this._outputDueEnd = g;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, i, n, r, a) {
      um.reset(i, n, r, a), this._callingProgress = t, this._callingProgress({
        start: i,
        end: n,
        count: n - i,
        next: um.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var i, n;
      !t && this._reset && (i = this._reset(this.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), j(i) && !i.length && (i = null)), this._progress = i, this._modBy = this._modDataCount = null;
      var r = this._downstream;
      return r && r.dirty(), n;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && J(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  })()
), um = /* @__PURE__ */ (function() {
  var e, t, i, n, r, a = {
    reset: function(l, u, c, h) {
      t = l, e = u, i = c, n = h, r = Math.ceil(n / i), a.next = i > 1 && n > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return t < e ? t++ : null;
  }
  function s() {
    var l = t % r * i + Math.ceil(t / r), u = t >= e ? null : l < n ? l : t;
    return t++, u;
  }
})();
function tl(e, t) {
  var i = t && t.type;
  return i === "ordinal" ? e : (i === "time" && !Nt(e) && e != null && e !== "-" && (e = +uu(e)), e == null || e === "" ? NaN : Number(e));
}
ot({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +uu(e);
  },
  trim: function(e) {
    return K(e) ? xi(e) : e;
  }
});
var k5 = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, i == null && (i = n ? "min" : "max"), this._incomparable = i === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, i) {
      var n = Nt(t) ? t : Sl(t), r = Nt(i) ? i : Sl(i), a = isNaN(n), o = isNaN(r);
      if (a && (n = this._incomparable), o && (r = this._incomparable), a && o) {
        var s = K(t), l = K(i);
        s && (n = l ? t : 0), l && (r = s ? i : 0);
      }
      return n < r ? this._resultLT : n > r ? -this._resultLT : 0;
    }, e;
  })()
), D5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, i) {
    }, e.prototype.retrieveValueFromItem = function(t, i) {
    }, e.prototype.convertValue = function(t, i) {
      return tl(t, i);
    }, e;
  })()
);
function E5(e, t) {
  var i = new D5(), n = e.data, r = i.sourceFormat = e.sourceFormat, a = e.startIndex, o = "";
  e.seriesLayoutBy !== Di && (process.env.NODE_ENV !== "production" && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), ke(o));
  var s = [], l = {}, u = e.dimensionsDefine;
  if (u)
    E(u, function(m, p) {
      var g = m.name, y = {
        index: p,
        name: g,
        displayName: m.displayName
      };
      if (s.push(y), g != null) {
        var _ = "";
        Ci(l, g) && (process.env.NODE_ENV !== "production" && (_ = 'dimension name "' + g + '" duplicated.'), ke(_)), l[g] = y;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var h = Db(r, Di);
  t.__isBuiltIn && (i.getRawDataItem = function(m) {
    return h(n, a, s, m);
  }, i.getRawData = mt(A5, null, e)), i.cloneRawData = mt(L5, null, e);
  var d = Eb(r, Di);
  i.count = mt(d, null, n, a, s);
  var f = Ab(r);
  i.retrieveValue = function(m, p) {
    var g = h(n, a, s, m);
    return v(g, p);
  };
  var v = i.retrieveValueFromItem = function(m, p) {
    if (m != null) {
      var g = s[p];
      if (g)
        return f(m, p, g.name);
    }
  };
  return i.getDimensionInfo = mt(P5, null, s, l), i.cloneAllDimensionInfo = mt(I5, null, s), i;
}
function A5(e) {
  var t = e.sourceFormat;
  if (!bf(t)) {
    var i = "";
    process.env.NODE_ENV !== "production" && (i = "`getRawData` is not supported in source format " + t), ke(i);
  }
  return e.data;
}
function L5(e) {
  var t = e.sourceFormat, i = e.data;
  if (!bf(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), ke(n);
  }
  if (t === fe) {
    for (var r = [], a = 0, o = i.length; a < o; a++)
      r.push(i[a].slice());
    return r;
  } else if (t === ci) {
    for (var r = [], a = 0, o = i.length; a < o; a++)
      r.push(V({}, i[a]));
    return r;
  }
}
function P5(e, t, i) {
  if (i != null) {
    if (Nt(i) || !isNaN(i) && !Ci(t, i))
      return e[i];
    if (Ci(t, i))
      return t[i];
  }
}
function I5(e) {
  return ct(e);
}
var Lb = ot();
function R5(e) {
  e = ct(e);
  var t = e.type, i = "";
  t || (process.env.NODE_ENV !== "production" && (i = "Must have a `type` when `registerTransform`."), ke(i));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (i = 'Name must include namespace like "ns:regression".'), ke(i));
  var r = !1;
  n[0] === "echarts" && (t = n[1], r = !0), e.__isBuiltIn = r, Lb.set(t, e);
}
function O5(e, t, i) {
  var n = ye(e), r = n.length, a = "";
  r || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), ke(a));
  for (var o = 0, s = r; o < s; o++) {
    var l = n[o];
    t = B5(l, t, i, r === 1 ? null : o), o !== s - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function B5(e, t, i, n) {
  var r = "";
  t.length || (process.env.NODE_ENV !== "production" && (r = "Must have at least one upstream dataset."), ke(r)), Z(e) || (process.env.NODE_ENV !== "production" && (r = "transform declaration must be an object rather than " + typeof e + "."), ke(r));
  var a = e.type, o = Lb.get(a);
  o || (process.env.NODE_ENV !== "production" && (r = 'Can not find transform on type "' + a + '".'), ke(r));
  var s = dt(t, function(c) {
    return E5(c, o);
  }), l = ye(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: ct(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = dt(l, function(c) {
      var h = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + i.datasetIndex + h + " ===", "- transform result data:", Cl(c.data), "- transform result dimensions:", Cl(c.dimensions)].join(`
`);
    }).join(`
`);
    TE(u);
  }
  return dt(l, function(c, h) {
    var d = "";
    Z(c) || (process.env.NODE_ENV !== "production" && (d = "A transform should not return some empty results."), ke(d)), c.data || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be not be null or undefined"), ke(d));
    var f = Tb(c.data);
    bf(f) || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be array rows or object rows."), ke(d));
    var v, m = t[0];
    if (m && h === 0 && !c.dimensions) {
      var p = m.startIndex;
      p && (c.data = m.data.slice(0, p).concat(c.data)), v = {
        seriesLayoutBy: Di,
        sourceHeader: p,
        dimensions: m.metaRawOption.dimensions
      };
    } else
      v = {
        seriesLayoutBy: Di,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return Uh(c.data, v, null);
  });
}
function bf(e) {
  return e === fe || e === ci;
}
var bu = "undefined", N5 = typeof Uint32Array === bu ? Array : Uint32Array, F5 = typeof Uint16Array === bu ? Array : Uint16Array, Pb = typeof Int32Array === bu ? Array : Int32Array, cm = typeof Float64Array === bu ? Array : Float64Array, Ib = {
  float: cm,
  int: Pb,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: cm
}, Rc;
function $r(e) {
  return e > 65535 ? N5 : F5;
}
function zr() {
  return [1 / 0, -1 / 0];
}
function $5(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function hm(e, t, i, n, r) {
  var a = Ib[i || "float"];
  if (r) {
    var o = e[t], s = o && o.length;
    if (s !== n) {
      for (var l = new a(n), u = 0; u < s; u++)
        l[u] = o[u];
      e[t] = l;
    }
  } else
    e[t] = new a(n);
}
var Gh = (
  /** @class */
  (function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = ot();
    }
    return e.prototype.initData = function(t, i, n) {
      process.env.NODE_ENV !== "production" && J(ht(t.getItem) && ht(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var r = t.getSource(), a = this.defaultDimValueGetter = Rc[r.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var o = Mb(r);
      this._dimensions = dt(i, function(s) {
        return process.env.NODE_ENV !== "production" && o && J(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, i) {
      var n = this._calcDimNameToIdx, r = this._dimensions, a = n.get(t);
      if (a != null) {
        if (r[a].type === i)
          return a;
      } else
        a = r.length;
      return r[a] = {
        type: i
      }, n.set(t, a), this._chunks[a] = new Ib[i || "float"](this._rawCount), this._rawExtent[a] = zr(), a;
    }, e.prototype.collectOrdinalMeta = function(t, i) {
      var n = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, o = r.ordinalOffset || 0, s = n.length;
      o === 0 && (a[t] = zr());
      for (var l = a[t], u = o; u < s; u++) {
        var c = n[u] = i.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      r.ordinalMeta = i, r.ordinalOffset = s, r.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var i = this._dimensions[t], n = i.ordinalMeta;
      return n;
    }, e.prototype.getDimensionProperty = function(t) {
      var i = this._dimensions[t];
      return i && i.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && J(!this._indices, "appendData can only be called on raw data.");
      var i = this._provider, n = this.count();
      i.appendData(t);
      var r = i.count();
      return i.persistent || (r += n), n < r && this._initDataFromProvider(n, r, !0), [n, r];
    }, e.prototype.appendValues = function(t, i) {
      for (var n = this._chunks, r = this._dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, i || 0), u = 0; u < a; u++) {
        var c = r[u];
        hm(n, u, c.type, l, !0);
      }
      for (var h = [], d = s; d < l; d++)
        for (var f = d - s, v = 0; v < a; v++) {
          var c = r[v], m = Rc.arrayRows.call(this, t[f] || h, c.property, f, v);
          n[v][d] = m;
          var p = o[v];
          m < p[0] && (p[0] = m), m > p[1] && (p[1] = m);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, i, n) {
      for (var r = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = dt(o, function(y) {
        return y.property;
      }), c = 0; c < s; c++) {
        var h = o[c];
        l[c] || (l[c] = zr()), hm(a, c, h.type, i, n);
      }
      if (r.fillStorage)
        r.fillStorage(t, i, a, l);
      else
        for (var d = [], f = t; f < i; f++) {
          d = r.getItem(f, d);
          for (var v = 0; v < s; v++) {
            var m = a[v], p = this._dimValueGetter(d, u[v], f, v);
            m[f] = p;
            var g = l[v];
            p < g[0] && (g[0] = p), p > g[1] && (g[1] = p);
          }
        }
      !r.persistent && r.clean && r.clean(), this._rawCount = this._count = i, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, i) {
      if (!(i >= 0 && i < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(i)] : NaN;
    }, e.prototype.getValues = function(t, i) {
      var n = [], r = [];
      if (i == null) {
        i = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          r.push(a);
      } else
        r = t;
      for (var a = 0, o = r.length; a < o; a++)
        n.push(this.get(r[a], i));
      return n;
    }, e.prototype.getByRawIndex = function(t, i) {
      if (!(i >= 0 && i < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[i] : NaN;
    }, e.prototype.getSum = function(t) {
      var i = this._chunks[t], n = 0;
      if (i)
        for (var r = 0, a = this.count(); r < a; r++) {
          var o = this.get(t, r);
          isNaN(o) || (n += o);
        }
      return n;
    }, e.prototype.getMedian = function(t) {
      var i = [];
      this.each([t], function(a) {
        isNaN(a) || i.push(a);
      });
      var n = i.sort(function(a, o) {
        return a - o;
      }), r = this.count();
      return r === 0 ? 0 : r % 2 === 1 ? n[(r - 1) / 2] : (n[r / 2] + n[r / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var i = this._indices, n = i[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var r = 0, a = this._count - 1; r <= a; ) {
        var o = (r + a) / 2 | 0;
        if (i[o] < t)
          r = o + 1;
        else if (i[o] > t)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, e.prototype.getIndices = function() {
      var t, i = this._indices;
      if (i) {
        var n = i.constructor, r = this._count;
        if (n === Array) {
          t = new n(r);
          for (var a = 0; a < r; a++)
            t[a] = i[a];
        } else
          t = new n(i.buffer, 0, r);
      } else {
        var n = $r(this._rawCount);
        t = new n(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, e.prototype.filter = function(t, i) {
      if (!this._count)
        return this;
      for (var n = this.clone(), r = n.count(), a = $r(n._rawCount), o = new a(r), s = [], l = t.length, u = 0, c = t[0], h = n._chunks, d = 0; d < r; d++) {
        var f = void 0, v = n.getRawIndex(d);
        if (l === 0)
          f = i(d);
        else if (l === 1) {
          var m = h[c][v];
          f = i(m, d);
        } else {
          for (var p = 0; p < l; p++)
            s[p] = h[t[p]][v];
          s[p] = d, f = i.apply(null, s);
        }
        f && (o[u++] = v);
      }
      return u < r && (n._indices = o), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.selectRange = function(t) {
      var i = this.clone(), n = i._count;
      if (!n)
        return this;
      var r = Bt(t), a = r.length;
      if (!a)
        return this;
      var o = i.count(), s = $r(i._rawCount), l = new s(o), u = 0, c = r[0], h = t[c][0], d = t[c][1], f = i._chunks, v = !1;
      if (!i._indices) {
        var m = 0;
        if (a === 1) {
          for (var p = f[r[0]], g = 0; g < n; g++) {
            var y = p[g];
            (y >= h && y <= d || isNaN(y)) && (l[u++] = m), m++;
          }
          v = !0;
        } else if (a === 2) {
          for (var p = f[r[0]], _ = f[r[1]], b = t[r[1]][0], w = t[r[1]][1], g = 0; g < n; g++) {
            var y = p[g], S = _[g];
            (y >= h && y <= d || isNaN(y)) && (S >= b && S <= w || isNaN(S)) && (l[u++] = m), m++;
          }
          v = !0;
        }
      }
      if (!v)
        if (a === 1)
          for (var g = 0; g < o; g++) {
            var C = i.getRawIndex(g), y = f[r[0]][C];
            (y >= h && y <= d || isNaN(y)) && (l[u++] = C);
          }
        else
          for (var g = 0; g < o; g++) {
            for (var T = !0, C = i.getRawIndex(g), k = 0; k < a; k++) {
              var M = r[k], y = f[M][C];
              (y < t[M][0] || y > t[M][1]) && (T = !1);
            }
            T && (l[u++] = i.getRawIndex(g));
          }
      return u < o && (i._indices = l), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, e.prototype.map = function(t, i) {
      var n = this.clone(t);
      return this._updateDims(n, t, i), n;
    }, e.prototype.modify = function(t, i) {
      this._updateDims(this, t, i);
    }, e.prototype._updateDims = function(t, i, n) {
      for (var r = t._chunks, a = [], o = i.length, s = t.count(), l = [], u = t._rawExtent, c = 0; c < i.length; c++)
        u[i[c]] = zr();
      for (var h = 0; h < s; h++) {
        for (var d = t.getRawIndex(h), f = 0; f < o; f++)
          l[f] = r[i[f]][d];
        l[o] = h;
        var v = n && n.apply(null, l);
        if (v != null) {
          typeof v != "object" && (a[0] = v, v = a);
          for (var c = 0; c < v.length; c++) {
            var m = i[c], p = v[c], g = u[m], y = r[m];
            y && (y[d] = p), p < g[0] && (g[0] = p), p > g[1] && (g[1] = p);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = this.clone([t], !0), r = n._chunks, a = r[t], o = this.count(), s = 0, l = Math.floor(1 / i), u = this.getRawIndex(0), c, h, d, f = new ($r(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      f[s++] = u;
      for (var v = 1; v < o - 1; v += l) {
        for (var m = Math.min(v + l, o - 1), p = Math.min(v + l * 2, o), g = (p + m) / 2, y = 0, _ = m; _ < p; _++) {
          var b = this.getRawIndex(_), w = a[b];
          isNaN(w) || (y += w);
        }
        y /= p - m;
        var S = v, C = Math.min(v + l, o), T = v - 1, k = a[u];
        c = -1, d = S;
        for (var M = -1, D = 0, _ = S; _ < C; _++) {
          var b = this.getRawIndex(_), w = a[b];
          if (isNaN(w)) {
            D++, M < 0 && (M = b);
            continue;
          }
          h = Math.abs((T - g) * (w - k) - (T - _) * (y - k)), h > c && (c = h, d = b);
        }
        D > 0 && D < C - S && (f[s++] = Math.min(M, d), d = Math.max(M, d)), f[s++] = d, u = d;
      }
      return f[s++] = this.getRawIndex(o - 1), n._count = s, n._indices = f, n.getRawIndex = this._getRawIdx, n;
    }, e.prototype.minmaxDownSample = function(t, i) {
      for (var n = this.clone([t], !0), r = n._chunks, a = Math.floor(1 / i), o = r[t], s = this.count(), l = new ($r(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var h = c, d = o[this.getRawIndex(h)], f = c, v = o[this.getRawIndex(f)], m = a;
        c + a > s && (m = s - c);
        for (var p = 0; p < m; p++) {
          var g = this.getRawIndex(c + p), y = o[g];
          y < d && (d = y, h = c + p), y > v && (v = y, f = c + p);
        }
        var _ = this.getRawIndex(h), b = this.getRawIndex(f);
        h < f ? (l[u++] = _, l[u++] = b) : (l[u++] = b, l[u++] = _);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, e.prototype.downSample = function(t, i, n, r) {
      for (var a = this.clone([t], !0), o = a._chunks, s = [], l = Math.floor(1 / i), u = o[t], c = this.count(), h = a._rawExtent[t] = zr(), d = new ($r(this._rawCount))(Math.ceil(c / l)), f = 0, v = 0; v < c; v += l) {
        l > c - v && (l = c - v, s.length = l);
        for (var m = 0; m < l; m++) {
          var p = this.getRawIndex(v + m);
          s[m] = u[p];
        }
        var g = n(s), y = this.getRawIndex(Math.min(v + r(s, g) || 0, c - 1));
        u[y] = g, g < h[0] && (h[0] = g), g > h[1] && (h[1] = g), d[f++] = y;
      }
      return a._count = f, a._indices = d, a._updateGetRawIdx(), a;
    }, e.prototype.each = function(t, i) {
      if (this._count)
        for (var n = t.length, r = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (n) {
            case 0:
              i(a);
              break;
            case 1:
              i(r[t[0]][s], a);
              break;
            case 2:
              i(r[t[0]][s], r[t[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = r[t[l]][s];
              u[l] = a, i.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var i = this._chunks[t], n = zr();
      if (!i)
        return n;
      var r = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[t].slice();
      if (o = this._extent[t], o)
        return o.slice();
      o = n;
      for (var s = o[0], l = o[1], u = 0; u < r; u++) {
        var c = this.getRawIndex(u), h = i[c];
        h < s && (s = h), h > l && (l = h);
      }
      return o = [s, l], this._extent[t] = o, o;
    }, e.prototype.getRawDataItem = function(t) {
      var i = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(i);
      for (var n = [], r = this._chunks, a = 0; a < r.length; a++)
        n.push(r[a][i]);
      return n;
    }, e.prototype.clone = function(t, i) {
      var n = new e(), r = this._chunks, a = t && _a(t, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < r.length; o++)
          n._chunks[o] = a[o] ? $5(r[o]) : r[o];
      else
        n._chunks = r;
      return this._copyCommonProps(n), i || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = ct(this._extent), t._rawExtent = ct(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, i = void 0;
        if (t === Array) {
          var n = this._indices.length;
          i = new t(n);
          for (var r = 0; r < n; r++)
            i[r] = this._indices[r];
        } else
          i = new t(this._indices);
        return i;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = (function() {
      function t(i, n, r, a) {
        return tl(i[a], this._dimensions[a]);
      }
      Rc = {
        arrayRows: t,
        objectRows: function(i, n, r, a) {
          return tl(i[n], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(i, n, r, a) {
          var o = i && (i.value == null ? i : i.value);
          return tl(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(i, n, r, a) {
          return i[a];
        }
      };
    })(), e;
  })()
), z5 = (
  /** @class */
  (function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, i) {
      this._sourceList = t, this._upstreamSignList = i, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, i = this._getUpstreamSourceManagers(), n = !!i.length, r, a;
      if (Oa(t)) {
        var o = t, s = void 0, l = void 0, u = void 0;
        if (n) {
          var c = i[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          s = o.get("data", !0), l = be(s) ? Yi : Ne, a = [];
        var h = this._getSourceMetaRawOption() || {}, d = u && u.metaRawOption || {}, f = tt(h.seriesLayoutBy, d.seriesLayoutBy) || null, v = tt(h.sourceHeader, d.sourceHeader), m = tt(h.dimensions, d.dimensions), p = f !== d.seriesLayoutBy || !!v != !!d.sourceHeader || m;
        r = p ? [Uh(s, {
          seriesLayoutBy: f,
          sourceHeader: v,
          dimensions: m
        }, l)] : [];
      } else {
        var g = t;
        if (n) {
          var y = this._applyTransform(i);
          r = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = g.get("source", !0);
          r = [Uh(_, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && J(r && a), this._setLocalSource(r, a);
    }, e.prototype._applyTransform = function(t) {
      var i = this._sourceHost, n = i.get("transform", !0), r = i.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && J(r != null || n != null), r != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), dm(a));
      }
      var o, s = [], l = [];
      return E(t, function(u) {
        u.prepareSource();
        var c = u.getSource(r || 0), h = "";
        r != null && !c && (process.env.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + r), dm(h)), s.push(c), l.push(u._getVersionSign());
      }), n ? o = O5(n, s, {
        datasetIndex: i.componentIndex
      }) : r != null && (o = [m5(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), i = 0; i < t.length; i++) {
        var n = t[i];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[i] !== n._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var i = this._sourceList[t];
      if (!i) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return i;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && J(Oa(this._sourceHost), "Can only call getDataStore on series source manager.");
      var i = t.makeStoreSchema();
      return this._innerGetDataStore(i.dimensions, t.source, i.hash);
    }, e.prototype._innerGetDataStore = function(t, i, n) {
      var r = 0, a = this._storeList, o = a[r];
      o || (o = a[r] = {});
      var s = o[n];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        Oa(this._sourceHost) && l ? s = l._innerGetDataStore(t, i, n) : (s = new Gh(), s.initData(new kb(i, t.length), t)), o[n] = s;
      }
      return s;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (Oa(t)) {
        var i = bb(t);
        return i ? [i.getSourceManager()] : [];
      } else
        return dt(WP(t), function(n) {
          return n.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, i, n, r;
      if (Oa(t))
        i = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), r = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        i = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), r = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: i,
        sourceHeader: n,
        dimensions: r
      };
    }, e;
  })()
);
function Oa(e) {
  return e.mainType === "series";
}
function dm(e) {
  throw new Error(e);
}
var V5 = "line-height:1";
function Rb(e) {
  var t = e.lineHeight;
  return t == null ? V5 : "line-height:" + Ce(t + "") + "px";
}
function Ob(e, t) {
  var i = e.color || vt.color.tertiary, n = e.fontSize || 12, r = e.fontWeight || "400", a = e.color || vt.color.secondary, o = e.fontSize || 14, s = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Ce(n + "") + "px;color:" + Ce(i) + ";font-weight:" + Ce(r + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Ce(o + "") + "px;color:" + Ce(a) + ";font-weight:" + Ce(s + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: i,
      fontWeight: r
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var H5 = [0, 10, 20, 30], W5 = ["", `
`, `

`, `


`];
function _r(e, t) {
  return t.type = e, t;
}
function Xh(e) {
  return e.type === "section";
}
function Bb(e) {
  return Xh(e) ? Y5 : U5;
}
function Nb(e) {
  if (Xh(e)) {
    var t = 0, i = e.blocks.length, n = i > 1 || i > 0 && !e.noHeader;
    return E(e.blocks, function(r) {
      var a = Nb(r);
      a >= t && (t = a + +(n && // 0 always can not be readable gap level.
      (!a || Xh(r) && !r.noHeader)));
    }), t;
  }
  return 0;
}
function Y5(e, t, i, n) {
  var r = t.noHeader, a = G5(Nb(t)), o = [], s = t.blocks || [];
  J(!s || j(s)), s = s || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Ci(u, l)) {
      var c = new k5(u[l], null);
      s.sort(function(m, p) {
        return c.evaluate(m.sortParam, p.sortParam);
      });
    } else l === "seriesDesc" && s.reverse();
  }
  E(s, function(m, p) {
    var g = t.valueFormatter, y = Bb(m)(
      // Inherit valueFormatter
      g ? V(V({}, e), {
        valueFormatter: g
      }) : e,
      m,
      p > 0 ? a.html : 0,
      n
    );
    y != null && o.push(y);
  });
  var h = e.renderMode === "richText" ? o.join(a.richText) : jh(n, o.join(""), r ? i : a.html);
  if (r)
    return h;
  var d = Wh(t.header, "ordinal", e.useUTC), f = Ob(n, e.renderMode).nameStyle, v = Rb(n);
  return e.renderMode === "richText" ? Fb(e, d, f) + a.richText + h : jh(n, '<div style="' + f + ";" + v + ';">' + Ce(d) + "</div>" + h, i);
}
function U5(e, t, i, n) {
  var r = e.renderMode, a = t.noName, o = t.noValue, s = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(b) {
    return b = j(b) ? b : [b], dt(b, function(w, S) {
      return Wh(w, j(f) ? f[S] : f, u);
    });
  };
  if (!(a && o)) {
    var h = s ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || vt.color.secondary, r), d = a ? "" : Wh(l, "ordinal", u), f = t.valueType, v = o ? [] : c(t.value, t.dataIndex), m = !s || !a, p = !s && a, g = Ob(n, r), y = g.nameStyle, _ = g.valueStyle;
    return r === "richText" ? (s ? "" : h) + (a ? "" : Fb(e, d, y)) + (o ? "" : q5(e, v, m, p, _)) : jh(n, (s ? "" : h) + (a ? "" : X5(d, !s, y)) + (o ? "" : j5(v, m, p, _)), i);
  }
}
function fm(e, t, i, n, r, a) {
  if (e) {
    var o = Bb(e), s = {
      useUTC: r,
      renderMode: i,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return o(s, e, 0, a);
  }
}
function G5(e) {
  return {
    html: H5[e],
    richText: W5[e]
  };
}
function jh(e, t, i) {
  var n = '<div style="clear:both"></div>', r = "margin: " + i + "px 0 0", a = Rb(e);
  return '<div style="' + r + ";" + a + ';">' + t + n + "</div>";
}
function X5(e, t, i) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + i + ";" + n + '">' + Ce(e) + "</span>";
}
function j5(e, t, i, n) {
  var r = i ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
  return e = j(e) ? e : [e], '<span style="' + a + ";" + n + '">' + dt(e, function(o) {
    return Ce(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function Fb(e, t, i) {
  return e.markupStyleCreator.wrapRichTextStyle(t, i);
}
function q5(e, t, i, n, r) {
  var a = [r], o = n ? 10 : 20;
  return i && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(j(t) ? t.join("  ") : t, a);
}
function Z5(e, t) {
  var i = e.getData().getItemVisual(t, "style"), n = i[e.visualDrawType];
  return Bo(n);
}
function $b(e, t) {
  var i = e.get("padding");
  return i ?? (t === "richText" ? [8, 10] : 10);
}
var Oc = (
  /** @class */
  (function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = v_();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, i, n) {
      var r = n === "richText" ? this._generateStyleName() : null, a = LP({
        color: i,
        type: t,
        renderMode: n,
        markerId: r
      });
      return K(a) ? a : (process.env.NODE_ENV !== "production" && J(r), this.richTextStyles[r] = a.style, a.content);
    }, e.prototype.wrapRichTextStyle = function(t, i) {
      var n = {};
      j(i) ? E(i, function(a) {
        return V(n, a);
      }) : V(n, i);
      var r = this._generateStyleName();
      return this.richTextStyles[r] = n, "{" + r + "|" + t + "}";
    }, e;
  })()
);
function K5(e) {
  var t = e.series, i = e.dataIndex, n = e.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), o = a.length, s = t.getRawValue(i), l = j(s), u = Z5(t, i), c, h, d, f;
  if (o > 1 || l && !o) {
    var v = Q5(s, t, i, a, u);
    c = v.inlineValues, h = v.inlineValueTypes, d = v.blocks, f = v.inlineValues[0];
  } else if (o) {
    var m = r.getDimensionInfo(a[0]);
    f = c = Ol(r, i, a[0]), h = m.type;
  } else
    f = c = l ? s[0] : s;
  var p = y_(t), g = p && t.name || "", y = r.getName(i), _ = n ? g : y;
  return _r("section", {
    header: g,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !p,
    sortParam: f,
    blocks: [_r("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: _,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !xi(_),
      value: c,
      valueType: h,
      dataIndex: i
    })].concat(d || [])
  });
}
function Q5(e, t, i, n, r) {
  var a = t.getData(), o = _a(e, function(h, d, f) {
    var v = a.getDimensionInfo(f);
    return h = h || v && v.tooltip !== !1 && v.displayName != null;
  }, !1), s = [], l = [], u = [];
  n.length ? E(n, function(h) {
    c(Ol(a, i, h), h);
  }) : E(e, c);
  function c(h, d) {
    var f = a.getDimensionInfo(d);
    !f || f.otherDims.tooltip === !1 || (o ? u.push(_r("nameValue", {
      markerType: "subItem",
      markerColor: r,
      name: f.displayName,
      value: h,
      valueType: f.type
    })) : (s.push(h), l.push(f.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var Ji = It();
function Ls(e, t) {
  return e.getName(t) || e.getId(t);
}
var J5 = "__universalTransitionEnabled", _n = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i._selectedDataIndicesMap = {}, i;
    }
    return t.prototype.init = function(i, n, r) {
      this.seriesIndex = this.componentIndex, this.dataTask = _o({
        count: eI,
        reset: iI
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(i, r);
      var a = Ji(this).sourceManager = new z5(this);
      a.prepareSource();
      var o = this.getInitialData(i, r);
      pm(o, this), this.dataTask.context.data = o, process.env.NODE_ENV !== "production" && J(o, "getInitialData returned invalid data."), Ji(this).dataBeforeProcessed = o, vm(this), this._initSelectedMapFromData(o);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = Ll(this), a = r ? pb(i) : {}, o = this.subType;
      wt.hasClass(o) && (o += "Series"), Gt(i, n.getTheme().get(this.subType)), Gt(i, this.getDefaultOption()), Yp(i, "label", ["show"]), this.fillDataTextStyle(i.data), r && Pl(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      i = Gt(this.option, i, !0), this.fillDataTextStyle(i.data);
      var r = Ll(this);
      r && Pl(this.option, i, r);
      var a = Ji(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(i, n);
      pm(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, Ji(this).dataBeforeProcessed = o, vm(this), this._initSelectedMapFromData(o);
    }, t.prototype.fillDataTextStyle = function(i) {
      if (i && !be(i))
        for (var n = ["show"], r = 0; r < i.length; r++)
          i[r] && i[r].label && Yp(i[r], "label", n);
    }, t.prototype.getInitialData = function(i, n) {
    }, t.prototype.appendData = function(i) {
      var n = this.getRawData();
      n.appendData(i.data);
    }, t.prototype.getData = function(i) {
      var n = qh(this);
      if (n) {
        var r = n.context.data;
        return i == null || !r.getLinkedData ? r : r.getLinkedData(i);
      } else
        return Ji(this).data;
    }, t.prototype.getAllData = function() {
      var i = this.getData();
      return i && i.getLinkedDataAll ? i.getLinkedDataAll() : [{
        data: i
      }];
    }, t.prototype.setData = function(i) {
      var n = qh(this);
      if (n) {
        var r = n.context;
        r.outputData = i, n !== this.dataTask && (r.data = i);
      }
      Ji(this).data = i;
    }, t.prototype.getEncode = function() {
      var i = this.get("encode", !0);
      if (i)
        return ot(i);
    }, t.prototype.getSourceManager = function() {
      return Ji(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return Ji(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var i = this.get("colorBy");
      return i || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var i = this.coordinateSystem;
      return i && i.getBaseAxis && i.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(i, n, r, a) {
      var o = this.getData(), s = this.coordinateSystem, l = s && s.getAxis(i);
      if (!s || !l)
        return [];
      var u = l.dataToCoord(r);
      a == null && (a = 1 / 0);
      var c = [], h = 1 / 0, d = -1, f = 0;
      return o.each(n, function(v, m) {
        var p = l.dataToCoord(v), g = u - p, y = Math.abs(g);
        y <= a && ((y < h || y === h && g >= 0 && d < 0) && (h = y, d = g, f = 0), g === d && (c[f++] = m));
      }), c.length = f, c;
    }, t.prototype.formatTooltip = function(i, n, r) {
      return K5({
        series: this,
        dataIndex: i,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var i = this.ecModel;
      if (nt.node && !(i && i.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(i, n, r) {
      var a = this.ecModel, o = gf.prototype.getColorFromPalette.call(this, i, n, r);
      return o || (o = a.getColorFromPalette(i, n, r)), o;
    }, t.prototype.coordDimToDataDim = function(i) {
      return this.getRawData().mapDimensionsAll(i);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(i, n) {
      this._innerSelect(this.getData(n), i);
    }, t.prototype.unselect = function(i, n) {
      var r = this.option.selectedMap;
      if (r) {
        var a = this.option.selectedMode, o = this.getData(n);
        if (a === "series" || r === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < i.length; s++) {
          var l = i[s], u = Ls(o, l);
          r[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(i, n) {
      for (var r = [], a = 0; a < i.length; a++)
        r[0] = i[a], this.isSelected(i[a], n) ? this.unselect(r, n) : this.select(r, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var i = this._selectedDataIndicesMap, n = Bt(i), r = [], a = 0; a < n.length; a++) {
        var o = i[n[a]];
        o >= 0 && r.push(o);
      }
      return r;
    }, t.prototype.isSelected = function(i, n) {
      var r = this.option.selectedMap;
      if (!r)
        return !1;
      var a = this.getData(n);
      return (r === "all" || r[Ls(a, i)]) && !a.getItemModel(i).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[J5])
        return !0;
      var i = this.option.universalTransition;
      return i ? i === !0 ? !0 : i && i.enabled : !1;
    }, t.prototype._innerSelect = function(i, n) {
      var r, a, o = this.option, s = o.selectedMode, l = n.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          Z(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var h = n[c], d = Ls(i, h);
            u[d] = !0, this._selectedDataIndicesMap[d] = i.getRawIndex(h);
          }
        } else if (s === "single" || s === !0) {
          var f = n[l - 1], d = Ls(i, f);
          o.selectedMap = (r = {}, r[d] = !0, r), this._selectedDataIndicesMap = (a = {}, a[d] = i.getRawIndex(f), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(i) {
      if (!this.option.selectedMap) {
        var n = [];
        i.hasItemOption && i.each(function(r) {
          var a = i.getRawDataItem(r);
          a && a.selected && n.push(r);
        }), n.length > 0 && this._innerSelect(i, n);
      }
    }, t.registerClass = function(i) {
      return wt.registerClass(i);
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "series.__base__", i.seriesIndex = 0, i.ignoreStyleOnData = !1, i.hasSymbolVisual = !1, i.defaultSymbol = "circle", i.visualStyleAccessPath = "itemStyle", i.visualDrawType = "fill";
    })(), t;
  })(wt)
);
si(_n, T5);
si(_n, gf);
x_(_n, wt);
function vm(e) {
  var t = e.name;
  y_(e) || (e.name = tI(e) || t);
}
function tI(e) {
  var t = e.getRawData(), i = t.mapDimensionsAll("seriesName"), n = [];
  return E(i, function(r) {
    var a = t.getDimensionInfo(r);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function eI(e) {
  return e.model.getRawData().count();
}
function iI(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), nI;
}
function nI(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function pm(e, t) {
  E(Xk(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(i) {
    e.wrapMethod(i, me(rI, t));
  });
}
function rI(e, t) {
  var i = qh(e);
  return i && i.setOutputEnd((t || this).count()), t;
}
function qh(e) {
  var t = (e.ecModel || {}).scheduler, i = t && t.getPipeline(e.uid);
  if (i) {
    var n = i.currentTask;
    if (n) {
      var r = n.agentStubMap;
      r && (n = r.get(e.uid));
    }
    return n;
  }
}
var Xi = (
  /** @class */
  (function() {
    function e() {
      this.group = new oi(), this.uid = mu("viewComponent");
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
    }, e.prototype.updateLayout = function(t, i, n, r) {
    }, e.prototype.updateVisual = function(t, i, n, r) {
    }, e.prototype.toggleBlurSeries = function(t, i, n) {
    }, e.prototype.eachRendered = function(t) {
      var i = this.group;
      i && i.traverse(t);
    }, e;
  })()
);
Hd(Xi);
Wd(Xi);
function aI() {
  var e = It();
  return function(t) {
    var i = e(t), n = t.pipelineContext, r = !!i.large, a = !!i.progressiveRender, o = i.large = !!(n && n.large), s = i.progressiveRender = !!(n && n.progressiveRender);
    return (r !== o || a !== s) && "reset";
  };
}
var zb = It(), oI = aI(), fn = (
  /** @class */
  (function() {
    function e() {
      this.group = new oi(), this.uid = mu("viewChart"), this.renderTask = _o({
        plan: sI,
        reset: lI
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Ft("Unknown dataType " + r.dataType);
        return;
      }
      mm(a, r, "emphasis");
    }, e.prototype.downplay = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Ft("Unknown dataType " + r.dataType);
        return;
      }
      mm(a, r, "normal");
    }, e.prototype.remove = function(t, i) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateLayout = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateVisual = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.eachRendered = function(t) {
      nb(this.group, t);
    }, e.markUpdateMethod = function(t, i) {
      zb(t).updateMethod = i;
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.type = "chart";
    })(), e;
  })()
);
function gm(e, t, i) {
  e && pa(e) && (t === "emphasis" ? Dl : El)(e, i);
}
function mm(e, t, i) {
  var n = Uo(e, t), r = t && t.highlightKey != null ? oL(t.highlightKey) : null;
  n != null ? E(ye(n), function(a) {
    gm(e.getItemGraphicEl(a), i, r);
  }) : e.eachItemGraphicEl(function(a) {
    gm(a, i, r);
  });
}
Hd(fn, ["dispose"]);
Wd(fn);
function sI(e) {
  return oI(e.model);
}
function lI(e) {
  var t = e.model, i = e.ecModel, n = e.api, r = e.payload, a = t.pipelineContext.progressiveRender, o = e.view, s = r && zb(r).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](t, i, n, r), uI[l];
}
var uI = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, Bl = "\0__throttleOriginMethod", ym = "\0__throttleRate", _m = "\0__throttleType";
function Vb(e, t, i) {
  var n, r = 0, a = 0, o = null, s, l, u, c;
  t = t || 0;
  function h() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, e.apply(l, u || []);
  }
  var d = function() {
    for (var f = [], v = 0; v < arguments.length; v++)
      f[v] = arguments[v];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
    var m = c || t, p = c || i;
    c = null, s = n - (p ? r : a) - m, clearTimeout(o), p ? o = setTimeout(h, m) : s >= 0 ? h() : o = setTimeout(h, -s), r = n;
  };
  return d.clear = function() {
    o && (clearTimeout(o), o = null);
  }, d.debounceNextCall = function(f) {
    c = f;
  }, d;
}
function Hb(e, t, i, n) {
  var r = e[t];
  if (r) {
    var a = r[Bl] || r, o = r[_m], s = r[ym];
    if (s !== i || o !== n) {
      if (i == null || !n)
        return e[t] = a;
      r = e[t] = Vb(a, i, n === "debounce"), r[Bl] = a, r[_m] = n, r[ym] = i;
    }
    return r;
  }
}
function Zh(e, t) {
  var i = e[t];
  i && i[Bl] && (i.clear && i.clear(), e[t] = i[Bl]);
}
var bm = It(), xm = {
  itemStyle: Io(sb, !0),
  lineStyle: Io(ob, !0)
}, cI = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function Wb(e, t) {
  var i = e.visualStyleMapper || xm[t];
  return i || (console.warn("Unknown style type '" + t + "'."), xm.itemStyle);
}
function Yb(e, t) {
  var i = e.visualDrawType || cI[t];
  return i || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var hI = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = e.getModel(n), a = Wb(e, n), o = a(r), s = r.getShallow("decal");
    s && (i.setVisual("decal", s), s.dirty = !0);
    var l = Yb(e, n), u = o[l], c = ht(u) ? u : null, h = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || c || h) {
      var d = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      o[l] || (o[l] = d, i.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || ht(o.fill) ? d : o.fill, o.stroke = o.stroke === "auto" || ht(o.stroke) ? d : o.stroke;
    }
    if (i.setVisual("style", o), i.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return i.setVisual("colorFromPalette", !1), {
        dataEach: function(f, v) {
          var m = e.getDataParams(v), p = V({}, o);
          p[l] = c(m), f.setItemVisual(v, "style", p);
        }
      };
  }
}, Ba = new Ot(), dI = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = Wb(e, n), a = i.getVisual("drawType");
      return {
        dataEach: i.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[n]) {
            Ba.option = l[n];
            var u = r(Ba), c = o.ensureUniqueItemVisual(s, "style");
            V(c, u), Ba.option.decal && (o.setItemVisual(s, "decal", Ba.option.decal), Ba.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, fI = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = ot();
    e.eachSeries(function(i) {
      var n = i.getColorBy();
      if (!i.isColorBySeries()) {
        var r = i.type + "-" + n, a = t.get(r);
        a || (a = {}, t.set(r, a)), bm(i).scope = a;
      }
    }), e.eachSeries(function(i) {
      if (!(i.isColorBySeries() || e.isSeriesFiltered(i))) {
        var n = i.getRawData(), r = {}, a = i.getData(), o = bm(i).scope, s = i.visualStyleAccessPath || "itemStyle", l = Yb(i, s);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          r[c] = u;
        }), n.each(function(u) {
          var c = r[u], h = a.getItemVisual(c, "colorFromPalette");
          if (h) {
            var d = a.ensureUniqueItemVisual(c, "style"), f = n.getName(u) || u + "", v = n.count();
            d[l] = i.getColorFromPalette(f, o, v);
          }
        });
      }
    });
  }
}, Ps = Math.PI;
function vI(e, t) {
  t = t || {}, zt(t, {
    text: "loading",
    textColor: vt.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: vt.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var i = new oi(), n = new he({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  i.add(n);
  var r = new ti({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new he({
    style: {
      fill: "none"
    },
    textContent: r,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  i.add(a);
  var o;
  return t.showSpinner && (o = new pu({
    shape: {
      startAngle: -Ps / 2,
      endAngle: -Ps / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: Ps * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: Ps * 3 / 2
  }).delay(300).start("circularInOut"), i.add(o)), i.resize = function() {
    var s = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && o.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, i.resize(), i;
}
var Ub = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this._stageTaskMap = ot(), this.ecInstance = t, this.api = i, n = this._dataProcessorHandlers = n.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = n.concat(r);
    }
    return e.prototype.restoreData = function(t, i) {
      t.restoreData(i), this._stageTaskMap.each(function(n) {
        var r = n.overallTask;
        r && r.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, i) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), r = n.context, a = !i && n.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > n.blockIndex, o = a ? n.step : null, s = r && r.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, i) {
      var n = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), o = n.progressiveEnabled && i.incrementalPrepareRender && a >= n.threshold, s = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = n.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, e.prototype.restorePipelines = function(t) {
      var i = this, n = i._pipelineMap = ot();
      t.eachSeries(function(r) {
        var a = r.getProgressive(), o = r.uid;
        n.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: r.getProgressiveThreshold(),
          progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), i._pipe(r, r.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, i = this.api.getModel(), n = this.api;
      E(this._allHandlers, function(r) {
        var a = t.get(r.uid) || t.set(r.uid, {}), o = "";
        process.env.NODE_ENV !== "production" && (o = '"reset" and "overallReset" must not be both specified.'), J(!(r.reset && r.overallReset), o), r.reset && this._createSeriesStageTask(r, a, i, n), r.overallReset && this._createOverallStageTask(r, a, i, n);
      }, this);
    }, e.prototype.prepareView = function(t, i, n, r) {
      var a = t.renderTask, o = a.context;
      o.model = i, o.ecModel = n, o.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(i, a);
    }, e.prototype.performDataProcessorTasks = function(t, i) {
      this._performStageTasks(this._dataProcessorHandlers, t, i, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, i, n) {
      this._performStageTasks(this._visualHandlers, t, i, n);
    }, e.prototype._performStageTasks = function(t, i, n, r) {
      r = r || {};
      var a = !1, o = this;
      E(t, function(l, u) {
        if (!(r.visualType && r.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), h = c.seriesTaskMap, d = c.overallTask;
          if (d) {
            var f, v = d.agentStubMap;
            v.each(function(p) {
              s(r, p) && (p.dirty(), f = !0);
            }), f && d.dirty(), o.updatePayload(d, n);
            var m = o.getPerformArgs(d, r.block);
            v.each(function(p) {
              p.perform(m);
            }), d.perform(m) && (a = !0);
          } else h && h.each(function(p, g) {
            s(r, p) && p.dirty();
            var y = o.getPerformArgs(p, r.block);
            y.skip = !l.performRawSeries && i.isSeriesFiltered(p.context.model), o.updatePayload(p, n), p.perform(y) && (a = !0);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var i;
      t.eachSeries(function(n) {
        i = n.dataTask.perform() || i;
      }), this.unfinished = i || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var i = t.tail;
        do {
          if (i.__block) {
            t.blockIndex = i.__idxInPipeline;
            break;
          }
          i = i.getUpstream();
        } while (i);
      });
    }, e.prototype.updatePayload = function(t, i) {
      i !== "remain" && (t.context.payload = i);
    }, e.prototype._createSeriesStageTask = function(t, i, n, r) {
      var a = this, o = i.seriesTaskMap, s = i.seriesTaskMap = ot(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, r).each(c);
      function c(h) {
        var d = h.uid, f = s.set(d, o && o.get(d) || _o({
          plan: _I,
          reset: bI,
          count: wI
        }));
        f.context = {
          model: h,
          ecModel: n,
          api: r,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(h, f);
      }
    }, e.prototype._createOverallStageTask = function(t, i, n, r) {
      var a = this, o = i.overallTask = i.overallTask || _o({
        reset: pI
      });
      o.context = {
        ecModel: n,
        api: r,
        overallReset: t.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = ot(), u = t.seriesType, c = t.getTargetSeries, h = !0, d = !1, f = "";
      process.env.NODE_ENV !== "production" && (f = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), J(!t.createOnAllSeries, f), u ? n.eachRawSeriesByType(u, v) : c ? c(n, r).each(v) : (h = !1, E(n.getSeries(), v));
      function v(m) {
        var p = m.uid, g = l.set(p, s && s.get(p) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (d = !0, _o({
          reset: gI,
          onDirty: yI
        })));
        g.context = {
          model: m,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, g.agent = o, g.__block = h, a._pipe(m, g);
      }
      d && o.dirty();
    }, e.prototype._pipe = function(t, i) {
      var n = t.uid, r = this._pipelineMap.get(n);
      !r.head && (r.head = i), r.tail && r.tail.pipe(i), r.tail = i, i.__idxInPipeline = r.count++, i.__pipeline = r;
    }, e.wrapStageHandler = function(t, i) {
      return ht(t) && (t = {
        overallReset: t,
        seriesType: SI(t)
      }), t.uid = mu("stageHandler"), i && (t.visualType = i), t;
    }, e;
  })()
);
function pI(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function gI(e) {
  return e.overallProgress && mI;
}
function mI() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function yI() {
  this.agent && this.agent.dirty();
}
function _I(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function bI(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = ye(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? dt(t, function(i, n) {
    return Gb(n);
  }) : xI;
}
var xI = Gb(0);
function Gb(e) {
  return function(t, i) {
    var n = i.data, r = i.resetDefines[e];
    if (r && r.dataEach)
      for (var a = t.start; a < t.end; a++)
        r.dataEach(n, a);
    else r && r.progress && r.progress(t, n);
  };
}
function wI(e) {
  return e.data.count();
}
function SI(e) {
  Nl = null;
  try {
    e(Fo, Xb);
  } catch {
  }
  return Nl;
}
var Fo = {}, Xb = {}, Nl;
jb(Fo, mf);
jb(Xb, wb);
Fo.eachSeriesByType = Fo.eachRawSeriesByType = function(e) {
  Nl = e;
};
Fo.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (Nl = e.subType);
};
function jb(e, t) {
  for (var i in t.prototype)
    e[i] = ce;
}
var H = vt.darkColor, CI = H.background, Na = function() {
  return {
    axisLine: {
      lineStyle: {
        color: H.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: H.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [H.backgroundTint, H.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: H.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: H.axisLabel
    },
    axisName: {}
  };
}, wm = {
  label: {
    color: H.secondary
  },
  itemStyle: {
    borderColor: H.borderTint
  },
  dividerLineStyle: {
    color: H.border
  }
}, qb = {
  darkMode: !0,
  color: H.theme,
  backgroundColor: CI,
  axisPointer: {
    lineStyle: {
      color: H.border
    },
    crossStyle: {
      color: H.borderShade
    },
    label: {
      color: H.tertiary
    }
  },
  legend: {
    textStyle: {
      color: H.secondary
    },
    pageTextStyle: {
      color: H.tertiary
    }
  },
  textStyle: {
    color: H.secondary
  },
  title: {
    textStyle: {
      color: H.primary
    },
    subtextStyle: {
      color: H.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: H.accent50
    }
  },
  tooltip: {
    backgroundColor: H.neutral20,
    defaultBorderColor: H.border,
    textStyle: {
      color: H.tertiary
    }
  },
  dataZoom: {
    borderColor: H.accent10,
    textStyle: {
      color: H.tertiary
    },
    brushStyle: {
      color: H.backgroundTint
    },
    handleStyle: {
      color: H.neutral00,
      borderColor: H.accent20
    },
    moveHandleStyle: {
      color: H.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: H.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: H.accent30
      },
      areaStyle: {
        color: H.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: H.accent50
      },
      areaStyle: {
        color: H.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: H.secondary
    },
    handleStyle: {
      borderColor: H.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: H.accent10
    },
    label: {
      color: H.tertiary
    },
    controlStyle: {
      color: H.accent30,
      borderColor: H.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: H.neutral00,
      borderColor: H.neutral20
    },
    dayLabel: {
      color: H.tertiary
    },
    monthLabel: {
      color: H.secondary
    },
    yearLabel: {
      color: H.secondary
    }
  },
  matrix: {
    x: wm,
    y: wm,
    backgroundColor: {
      borderColor: H.axisLine
    },
    body: {
      itemStyle: {
        borderColor: H.borderTint
      }
    }
  },
  timeAxis: Na(),
  logAxis: Na(),
  valueAxis: Na(),
  categoryAxis: Na(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: H.theme
  },
  gauge: {
    title: {
      color: H.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, H.neutral05]]
      }
    },
    axisLabel: {
      color: H.axisLabel
    },
    detail: {
      color: H.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: H.background
    }
  },
  radar: (function() {
    var e = Na();
    return e.axisName = {
      color: H.axisLabel
    }, e.axisLine.lineStyle.color = H.neutral20, e;
  })(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: H.neutral20,
        textStyle: {
          color: H.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: H.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: H.background
    }
  },
  map: {
    itemStyle: {
      borderColor: H.border,
      areaColor: H.neutral10
    },
    label: {
      color: H.tertiary
    },
    emphasis: {
      label: {
        color: H.primary
      },
      itemStyle: {
        areaColor: H.highlight
      }
    },
    select: {
      label: {
        color: H.primary
      },
      itemStyle: {
        areaColor: H.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: H.border,
      areaColor: H.neutral10
    },
    emphasis: {
      label: {
        color: H.primary
      },
      itemStyle: {
        areaColor: H.highlight
      }
    },
    select: {
      label: {
        color: H.primary
      },
      itemStyle: {
        color: H.highlight
      }
    }
  }
};
qb.categoryAxis.splitLine.show = !1;
var TI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var i = {}, n = {}, r = {};
      if (K(t)) {
        var a = wi(t);
        i.mainType = a.main || null, i.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        E(t, function(l, u) {
          for (var c = !1, h = 0; h < o.length; h++) {
            var d = o[h], f = u.lastIndexOf(d);
            if (f > 0 && f === u.length - d.length) {
              var v = u.slice(0, f);
              v !== "data" && (i.mainType = v, i[d.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (n[u] = l, c = !0), c || (r[u] = l);
        });
      }
      return {
        cptQuery: i,
        dataQuery: n,
        otherQuery: r
      };
    }, e.prototype.filter = function(t, i) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var r = n.targetEl, a = n.packedEvent, o = n.model, s = n.view;
      if (!o || !s)
        return !0;
      var l = i.cptQuery, u = i.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, i.otherQuery, r, a));
      function c(h, d, f, v) {
        return h[f] == null || d[v || f] === h[f];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  })()
), Kh = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], Sm = Kh.concat(["symbolKeepAspect"]), MI = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData();
    if (e.legendIcon && i.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var n = {}, r = {}, a = !1, o = 0; o < Kh.length; o++) {
      var s = Kh[o], l = e.get(s);
      ht(l) ? (a = !0, r[s] = l) : n[s] = l;
    }
    if (n.symbol = n.symbol || e.defaultSymbol, i.setVisual(V({
      legendIcon: e.legendIcon || n.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(e))
      return;
    var u = Bt(r);
    function c(h, d) {
      for (var f = e.getRawValue(d), v = e.getDataParams(d), m = 0; m < u.length; m++) {
        var p = u[m];
        h.setItemVisual(d, p, r[p](f, v));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, kI = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var i = e.getData();
    function n(r, a) {
      for (var o = r.getItemModel(a), s = 0; s < Sm.length; s++) {
        var l = Sm[s], u = o.getShallow(l, !0);
        u != null && r.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: i.hasItemOption ? n : null
    };
  }
};
function DI(e, t, i) {
  switch (i) {
    case "color":
      var n = e.getItemVisual(t, "style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, i);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + i);
  }
}
function EI(e, t) {
  switch (t) {
    case "color":
      var i = e.getVisual("style");
      return i[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Vr(e, t, i, n, r) {
  var a = e + t;
  i.isSilent(a) || (process.env.NODE_ENV !== "production" && Gi("event " + a + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = r.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var h = o.getData(), d = Uo(h, r.fromActionPayload);
        i.trigger(a, {
          type: a,
          seriesId: o.id,
          name: j(d) ? h.getName(d[0]) : h.getName(d),
          selected: K(l) ? l : V({}, l)
        });
      }
  }));
}
function AI(e, t, i) {
  e.on("selectchanged", function(n) {
    var r = i.getModel();
    n.isFromClick ? (Vr("map", "selectchanged", t, r, n), Vr("pie", "selectchanged", t, r, n)) : n.fromAction === "select" ? (Vr("map", "selected", t, r, n), Vr("pie", "selected", t, r, n)) : n.fromAction === "unselect" && (Vr("map", "unselected", t, r, n), Vr("pie", "unselected", t, r, n));
  });
}
function ro(e, t, i) {
  for (var n; e && !(t(e) && (n = e, i)); )
    e = e.__hostTarget || e.parent;
  return n;
}
var LI = Math.round(Math.random() * 9), PI = typeof Object.defineProperty == "function", II = (function() {
  function e() {
    this._id = "__ec_inner_" + LI++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, i) {
    var n = this._guard(t);
    return PI ? Object.defineProperty(n, this._id, {
      value: i,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = i, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
})(), RI = Et.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n + a), e.lineTo(i - r, n + a), e.closePath();
  }
}), OI = Et.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n), e.lineTo(i, n + a), e.lineTo(i - r, n), e.closePath();
  }
}), BI = Et.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.x, n = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), o = r / 2, s = o * o / (a - o), l = n - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, h = Math.sin(u), d = Math.cos(u), f = o * 0.6, v = o * 0.7;
    e.moveTo(i - c, l + s), e.arc(i, l, o, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(i + c - h * f, l + s + d * f, i, n - v, i, n), e.bezierCurveTo(i, n - v, i - c + h * f, l + s + d * f, i - c, l + s), e.closePath();
  }
}), NI = Et.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.height, n = t.width, r = t.x, a = t.y, o = n / 3 * 2;
    e.moveTo(r, a), e.lineTo(r + o, a + i), e.lineTo(r, a + i / 4 * 3), e.lineTo(r - o, a + i), e.lineTo(r, a), e.closePath();
  }
}), FI = {
  line: xa,
  rect: he,
  roundRect: he,
  square: he,
  circle: vu,
  diamond: OI,
  pin: BI,
  arrow: NI,
  triangle: RI
}, $I = {
  line: function(e, t, i, n, r) {
    r.x1 = e, r.y1 = t + n / 2, r.x2 = e + i, r.y2 = t + n / 2;
  },
  rect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n;
  },
  roundRect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n, r.r = Math.min(i, n) / 4;
  },
  square: function(e, t, i, n, r) {
    var a = Math.min(i, n);
    r.x = e, r.y = t, r.width = a, r.height = a;
  },
  circle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.r = Math.min(i, n) / 2;
  },
  diamond: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  },
  pin: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  arrow: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  triangle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  }
}, Qh = {};
E(FI, function(e, t) {
  Qh[t] = new e();
});
var zI = Et.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, i) {
    var n = l_(e, t, i), r = this.shape;
    return r && r.symbolType === "pin" && t.position === "inside" && (n.y = i.y + i.height * 0.4), n;
  },
  buildPath: function(e, t, i) {
    var n = t.symbolType;
    if (n !== "none") {
      var r = Qh[n];
      r || (n = "rect", r = Qh[n]), $I[n](t.x, t.y, t.width, t.height, r.shape), r.buildPath(e, r.shape, i);
    }
  }
});
function VI(e, t) {
  if (this.type !== "image") {
    var i = this.style;
    this.__isEmptyBrush ? (i.stroke = e, i.fill = t || vt.color.neutral00, i.lineWidth = 2) : this.shape.symbolType === "line" ? i.stroke = e : i.fill = e, this.markRedraw();
  }
}
function Zb(e, t, i, n, r, a, o) {
  var s = e.indexOf("empty") === 0;
  s && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = Q_(e.slice(8), new rt(t, i, n, r), o ? "center" : "cover") : e.indexOf("path://") === 0 ? l = of(e.slice(7), {}, new rt(t, i, n, r), o ? "center" : "cover") : l = new zI({
    shape: {
      symbolType: e,
      x: t,
      y: i,
      width: n,
      height: r
    }
  }), l.__isEmptyBrush = s, l.setColor = VI, a && l.setColor(a), l;
}
function HI(e, t) {
  if (e != null)
    return j(e) || (e = [e, e]), [Me(e[0], t[0]) || 0, Me(tt(e[1], e[0]), t[1]) || 0];
}
function rr(e) {
  return isFinite(e);
}
function WI(e, t, i) {
  var n = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, o = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, o = o * i.height + i.y), n = rr(n) ? n : 0, r = rr(r) ? r : 1, a = rr(a) ? a : 0, o = rr(o) ? o : 0;
  var s = e.createLinearGradient(n, a, r, o);
  return s;
}
function YI(e, t, i) {
  var n = i.width, r = i.height, a = Math.min(n, r), o = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (o = o * n + i.x, s = s * r + i.y, l = l * a), o = rr(o) ? o : 0.5, s = rr(s) ? s : 0.5, l = l >= 0 && rr(l) ? l : 0.5;
  var u = e.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function Jh(e, t, i) {
  for (var n = t.type === "radial" ? YI(e, t, i) : WI(e, t, i), r = t.colorStops, a = 0; a < r.length; a++)
    n.addColorStop(r[a].offset, r[a].color);
  return n;
}
function UI(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var i = 0; i < e.length; i++)
    if (e[i] !== t[i])
      return !0;
  return !1;
}
function Is(e) {
  return parseInt(e, 10);
}
function Rs(e, t, i) {
  var n = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], o = ["paddingRight", "paddingBottom"][t];
  if (i[n] != null && i[n] !== "auto")
    return parseFloat(i[n]);
  var s = document.defaultView.getComputedStyle(e);
  return (e[r] || Is(s[n]) || Is(e.style[n])) - (Is(s[a]) || 0) - (Is(s[o]) || 0) | 0;
}
function GI(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : Nt(e) ? [e] : j(e) ? e : null;
}
function Kb(e) {
  var t = e.style, i = t.lineDash && t.lineWidth > 0 && GI(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (i) {
    var r = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    r && r !== 1 && (i = dt(i, function(a) {
      return a / r;
    }), n /= r);
  }
  return [i, n];
}
var XI = new va(!0);
function Fl(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function Cm(e) {
  return typeof e == "string" && e !== "none";
}
function $l(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function Tm(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = i;
  } else
    e.fill();
}
function Mm(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = i;
  } else
    e.stroke();
}
function td(e, t, i) {
  var n = w_(t.image, t.__image, i);
  if (hu(n)) {
    var r = e.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && r && r.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * jk), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
    }
    return r;
  }
}
function jI(e, t, i, n) {
  var r, a = Fl(i), o = $l(i), s = i.strokePercent, l = s < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || XI, h = t.__dirty;
  if (!n) {
    var d = i.fill, f = i.stroke, v = o && !!d.colorStops, m = a && !!f.colorStops, p = o && !!d.image, g = a && !!f.image, y = void 0, _ = void 0, b = void 0, w = void 0, S = void 0;
    (v || m) && (S = t.getBoundingRect()), v && (y = h ? Jh(e, d, S) : t.__canvasFillGradient, t.__canvasFillGradient = y), m && (_ = h ? Jh(e, f, S) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = _), p && (b = h || !t.__canvasFillPattern ? td(e, d, t) : t.__canvasFillPattern, t.__canvasFillPattern = b), g && (w = h || !t.__canvasStrokePattern ? td(e, f, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = w), v ? e.fillStyle = y : p && (b ? e.fillStyle = b : o = !1), m ? e.strokeStyle = _ : g && (w ? e.strokeStyle = w : a = !1);
  }
  var C = t.getGlobalScale();
  c.setScale(C[0], C[1], t.segmentIgnoreThreshold);
  var T, k;
  e.setLineDash && i.lineDash && (r = Kb(t), T = r[0], k = r[1]);
  var M = !0;
  (u || h & jr) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), M = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), M && c.rebuildPath(e, l ? s : 1), T && (e.setLineDash(T), e.lineDashOffset = k), n || (i.strokeFirst ? (a && Mm(e, i), o && Tm(e, i)) : (o && Tm(e, i), a && Mm(e, i))), T && e.setLineDash([]);
}
function qI(e, t, i) {
  var n = t.__image = w_(i.image, t.__image, t, t.onload);
  if (!(!n || !hu(n))) {
    var r = i.x || 0, a = i.y || 0, o = t.getWidth(), s = t.getHeight(), l = n.width / n.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = n.width, s = n.height), i.sWidth && i.sHeight) {
      var u = i.sx || 0, c = i.sy || 0;
      e.drawImage(n, u, c, i.sWidth, i.sHeight, r, a, o, s);
    } else if (i.sx && i.sy) {
      var u = i.sx, c = i.sy, h = o - u, d = s - c;
      e.drawImage(n, u, c, h, d, r, a, o, s);
    } else
      e.drawImage(n, r, a, o, s);
  }
}
function ZI(e, t, i) {
  var n, r = i.text;
  if (r != null && (r += ""), r) {
    e.font = i.font || gn, e.textAlign = i.textAlign, e.textBaseline = i.textBaseline;
    var a = void 0, o = void 0;
    e.setLineDash && i.lineDash && (n = Kb(t), a = n[0], o = n[1]), a && (e.setLineDash(a), e.lineDashOffset = o), i.strokeFirst ? (Fl(i) && e.strokeText(r, i.x, i.y), $l(i) && e.fillText(r, i.x, i.y)) : ($l(i) && e.fillText(r, i.x, i.y), Fl(i) && e.strokeText(r, i.x, i.y)), a && e.setLineDash([]);
  }
}
var km = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], Dm = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function Qb(e, t, i, n, r) {
  var a = !1;
  if (!n && (i = i || {}, t === i))
    return !1;
  if (n || t.opacity !== i.opacity) {
    Ee(e, r), a = !0;
    var o = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(o) ? fr.opacity : o;
  }
  (n || t.blend !== i.blend) && (a || (Ee(e, r), a = !0), e.globalCompositeOperation = t.blend || fr.blend);
  for (var s = 0; s < km.length; s++) {
    var l = km[s];
    (n || t[l] !== i[l]) && (a || (Ee(e, r), a = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== i.shadowColor) && (a || (Ee(e, r), a = !0), e.shadowColor = t.shadowColor || fr.shadowColor), a;
}
function Em(e, t, i, n, r) {
  var a = $o(t, r.inHover), o = n ? null : i && $o(i, r.inHover) || {};
  if (a === o)
    return !1;
  var s = Qb(e, a, o, n, r);
  if ((n || a.fill !== o.fill) && (s || (Ee(e, r), s = !0), Cm(a.fill) && (e.fillStyle = a.fill)), (n || a.stroke !== o.stroke) && (s || (Ee(e, r), s = !0), Cm(a.stroke) && (e.strokeStyle = a.stroke)), (n || a.opacity !== o.opacity) && (s || (Ee(e, r), s = !0), e.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (s || (Ee(e, r), s = !0), e.lineWidth = u);
  }
  for (var c = 0; c < Dm.length; c++) {
    var h = Dm[c], d = h[0];
    (n || a[d] !== o[d]) && (s || (Ee(e, r), s = !0), e[d] = a[d] || h[1]);
  }
  return s;
}
function KI(e, t, i, n, r) {
  return Qb(e, $o(t, r.inHover), i && $o(i, r.inHover), n, r);
}
function Jb(e, t) {
  var i = t.transform, n = e.dpr || 1;
  i ? e.setTransform(n * i[0], n * i[1], n * i[2], n * i[3], n * i[4], n * i[5]) : e.setTransform(n, 0, 0, n, 0, 0);
}
function QI(e, t, i) {
  for (var n = !1, r = 0; r < e.length; r++) {
    var a = e[r];
    n = n || a.isZeroArea(), Jb(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  i.allClipped = n;
}
function JI(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var Am = 1, Lm = 2, Pm = 3, Im = 4;
function tR(e) {
  var t = $l(e), i = Fl(e);
  return !(e.lineDash || !(+t ^ +i) || t && typeof e.fill != "string" || i && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function Ee(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function $o(e, t) {
  return t && e.__hoverStyle || e.style;
}
function t1(e, t) {
  ar(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function ar(e, t, i, n) {
  var r = t.transform;
  if (!t.shouldBePainted(i.viewWidth, i.viewHeight, !1, !1)) {
    t.__dirty &= ~Oe, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, o = i.prevElClipPaths, s = !1, l = !1;
  if ((!o || UI(a, o)) && (o && o.length && (Ee(e, i), e.restore(), l = s = !0, i.prevElClipPaths = null, i.allClipped = !1, i.prevEl = null), a && a.length && (Ee(e, i), e.save(), QI(a, e, i), s = !0), i.prevElClipPaths = a), i.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = i.prevEl;
  u || (l = s = !0);
  var c = t instanceof Et && t.autoBatch && tR(t.style);
  s || JI(r, u.transform) ? (Ee(e, i), Jb(e, t)) : c || Ee(e, i);
  var h = $o(t, i.inHover);
  t instanceof Et ? (i.lastDrawType !== Am && (l = !0, i.lastDrawType = Am), Em(e, t, u, l, i), (!c || !i.batchFill && !i.batchStroke) && e.beginPath(), jI(e, t, h, c), c && (i.batchFill = h.fill || "", i.batchStroke = h.stroke || "")) : t instanceof Tl ? (i.lastDrawType !== Pm && (l = !0, i.lastDrawType = Pm), Em(e, t, u, l, i), ZI(e, t, h)) : t instanceof wr ? (i.lastDrawType !== Lm && (l = !0, i.lastDrawType = Lm), KI(e, t, u, l, i), qI(e, t, h)) : t.getTemporalDisplayables && (i.lastDrawType !== Im && (l = !0, i.lastDrawType = Im), eR(e, t, i)), c && n && Ee(e, i), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), i.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function eR(e, t, i) {
  var n = t.getDisplayables(), r = t.getTemporalDisplayables();
  e.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: i.viewWidth,
    viewHeight: i.viewHeight,
    inHover: i.inHover
  }, o, s;
  for (o = t.getCursor(), s = n.length; o < s; o++) {
    var l = n[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), ar(e, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = r.length; u < c; u++) {
    var l = r[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), ar(e, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var Bc = new II(), Rm = new ha(100), Om = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Bm(e, t) {
  if (e === "none")
    return null;
  var i = t.getDevicePixelRatio(), n = t.getZr(), r = n.painter.type === "svg";
  e.dirty && Bc.delete(e);
  var a = Bc.get(e);
  if (a)
    return a;
  var o = zt(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = r ? 1 : 1 / i, Bc.set(e, s), e.dirty = !1, s;
  function l(u) {
    for (var c = [i], h = !0, d = 0; d < Om.length; ++d) {
      var f = o[Om[d]];
      if (f != null && !j(f) && !K(f) && !Nt(f) && typeof f != "boolean") {
        h = !1;
        break;
      }
      c.push(f);
    }
    var v;
    if (h) {
      v = c.join(",") + (r ? "-svg" : "");
      var m = Rm.get(v);
      m && (r ? u.svgElement = m : u.image = m);
    }
    var p = i1(o.dashArrayX), g = iR(o.dashArrayY), y = e1(o.symbol), _ = nR(p), b = n1(g), w = !r && Ui.createCanvas(), S = r && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, C = k(), T;
    w && (w.width = C.width * i, w.height = C.height * i, T = w.getContext("2d")), M(), h && Rm.put(v, w || S), u.image = w, u.svgElement = S, u.svgWidth = C.width, u.svgHeight = C.height;
    function k() {
      for (var D = 1, L = 0, P = _.length; L < P; ++L)
        D = Hp(D, _[L]);
      for (var R = 1, L = 0, P = y.length; L < P; ++L)
        R = Hp(R, y[L].length);
      D *= R;
      var B = b * _.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var F = function(W) {
          console.warn("Calculated decal size is greater than " + W + " due to decal option settings so " + W + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + W + " to be larger to avoid incontinuity.");
        };
        D > o.maxTileWidth && F("maxTileWidth"), B > o.maxTileHeight && F("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(D, o.maxTileWidth)),
        height: Math.max(1, Math.min(B, o.maxTileHeight))
      };
    }
    function M() {
      T && (T.clearRect(0, 0, w.width, w.height), o.backgroundColor && (T.fillStyle = o.backgroundColor, T.fillRect(0, 0, w.width, w.height)));
      for (var D = 0, L = 0; L < g.length; ++L)
        D += g[L];
      if (D <= 0)
        return;
      for (var P = -b, R = 0, B = 0, F = 0; P < C.height; ) {
        if (R % 2 === 0) {
          for (var W = B / 2 % y.length, z = 0, N = 0, $ = 0; z < C.width * 2; ) {
            for (var X = 0, L = 0; L < p[F].length; ++L)
              X += p[F][L];
            if (X <= 0)
              break;
            if (N % 2 === 0) {
              var U = (1 - o.symbolSize) * 0.5, Q = z + p[F][N] * U, it = P + g[R] * U, ft = p[F][N] * o.symbolSize, yt = g[R] * o.symbolSize, ie = $ / 2 % y[W].length;
              ve(Q, it, ft, yt, y[W][ie]);
            }
            z += p[F][N], ++$, ++N, N === p[F].length && (N = 0);
          }
          ++F, F === p.length && (F = 0);
        }
        P += g[R], ++B, ++R, R === g.length && (R = 0);
      }
      function ve(xt, Mt, et, lt, hi) {
        var qt = r ? 1 : i, Bf = Zb(hi, xt * qt, Mt * qt, et * qt, lt * qt, o.color, o.symbolKeepAspect);
        if (r) {
          var Nf = n.painter.renderOneToVNode(Bf);
          Nf && S.children.push(Nf);
        } else
          t1(T, Bf);
      }
    }
  }
}
function e1(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (K(e))
    return [[e]];
  for (var t = !0, i = 0; i < e.length; ++i)
    if (!K(e[i])) {
      t = !1;
      break;
    }
  if (t)
    return e1([e]);
  for (var n = [], i = 0; i < e.length; ++i)
    K(e[i]) ? n.push([e[i]]) : n.push(e[i]);
  return n;
}
function i1(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if (Nt(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var i = !0, n = 0; n < e.length; ++n)
    if (!Nt(e[n])) {
      i = !1;
      break;
    }
  if (i)
    return i1([e]);
  for (var r = [], n = 0; n < e.length; ++n)
    if (Nt(e[n])) {
      var t = Math.ceil(e[n]);
      r.push([t, t]);
    } else {
      var t = dt(e[n], function(s) {
        return Math.ceil(s);
      });
      t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
    }
  return r;
}
function iR(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if (Nt(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var i = dt(e, function(n) {
    return Math.ceil(n);
  });
  return e.length % 2 ? i.concat(i) : i;
}
function nR(e) {
  return dt(e, function(t) {
    return n1(t);
  });
}
function n1(e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += e[i];
  return e.length % 2 === 1 ? t * 2 : t;
}
function rR(e, t) {
  e.eachRawSeries(function(i) {
    if (!e.isSeriesFiltered(i)) {
      var n = i.getData();
      n.hasItemVisual() && n.each(function(o) {
        var s = n.getItemVisual(o, "decal");
        if (s) {
          var l = n.ensureUniqueItemVisual(o, "style");
          l.decal = Bm(s, t);
        }
      });
      var r = n.getVisual("decal");
      if (r) {
        var a = n.getVisual("style");
        a.decal = Bm(r, t);
      }
    }
  });
}
var ni = new li(), zl = {};
function aR(e, t) {
  process.env.NODE_ENV !== "production" && zl[e] && Ft("Already has an implementation of " + e + "."), zl[e] = t;
}
function oR(e) {
  return process.env.NODE_ENV !== "production" && (zl[e] || Ft("Implementation of " + e + " doesn't exists.")), zl[e];
}
var sR = 1, lR = 800, uR = 900, cR = 1e3, hR = 2e3, dR = 5e3, r1 = 1e3, fR = 1100, xf = 2e3, a1 = 3e3, vR = 4e3, xu = 4500, pR = 4600, gR = 5e3, mR = 6e3, o1 = 7e3, yR = {
  PROCESSOR: {
    FILTER: cR,
    SERIES_FILTER: lR,
    STATISTIC: dR
  },
  VISUAL: {
    LAYOUT: r1,
    PROGRESSIVE_LAYOUT: fR,
    GLOBAL: xf,
    CHART: a1,
    POST_CHART_LAYOUT: pR,
    COMPONENT: vR,
    BRUSH: gR,
    CHART_ITEM: xu,
    ARIA: mR,
    DECAL: o1
  }
}, Yt = "__flagInMainProcess", Os = "__mainProcessVersion", Jt = "__pendingUpdate", Nc = "__needsUpdateStatus", Nm = /^[a-zA-Z0-9_]+$/, Fc = "__connectUpdateStatus", Fm = 0, _R = 1, bR = 2;
function s1(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    if (this.isDisposed()) {
      Se(this.id);
      return;
    }
    return u1(this, e, t);
  };
}
function l1(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    return u1(this, e, t);
  };
}
function u1(e, t, i) {
  return i[0] = i[0] && i[0].toLowerCase(), li.prototype[t].apply(e, i);
}
var c1 = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  })(li)
), h1 = c1.prototype;
h1.on = l1("on");
h1.off = l1("off");
var Xn, $c, Bs, Ii, Ns, zc, Vc, Hr, Wr, $m, zm, Hc, Vm, Fs, Hm, d1, Ve, Wm, Yr, f1 = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t(i, n, r) {
      var a = e.call(this, new TI()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, a._dom = i;
      var o = "canvas", s = "auto", l = !1;
      if (a[Os] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          nt.hasGlobalWindow ? window : global
        );
        u && (o = tt(u.__ECHARTS__DEFAULT__RENDERER__, o), s = tt(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = tt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      r.ssr;
      var c = a._zr = $p(i, {
        renderer: r.renderer || o,
        devicePixelRatio: r.devicePixelRatio,
        width: r.width,
        height: r.height,
        ssr: r.ssr,
        useDirtyRect: tt(r.useDirtyRect, l),
        useCoarsePointer: tt(r.useCoarsePointer, s),
        pointerSize: r.pointerSize
      });
      a._ssr = r.ssr, a._throttledZrFlush = Vb(mt(c.flush, c), 17), a._updateTheme(n), a._locale = bP(r.locale || lb), a._coordSysMgr = new yu();
      var h = a._api = Hm(a);
      function d(f, v) {
        return f.__prio - v.__prio;
      }
      return Gs(Wl, d), Gs(id, d), a._scheduler = new Ub(a, h, id, Wl), a._messageCenter = new c1(), a._initEvents(), a.resize = mt(a.resize, a), c.animation.on("frame", a._onframe, a), $m(c, a), zm(c, a), hh(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        Wm(this);
        var i = this._scheduler;
        if (this[Jt]) {
          var n = this[Jt].silent;
          this[Yt] = !0, Yr(this);
          try {
            Xn(this), Ii.update.call(this, null, this[Jt].updateParams);
          } catch (l) {
            throw this[Yt] = !1, this[Jt] = null, l;
          }
          this._zr.flush(), this[Yt] = !1, this[Jt] = null, Hr.call(this, n), Wr.call(this, n);
        } else if (i.unfinished) {
          var r = sR, a = this._model, o = this._api;
          i.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            i.performSeriesTasks(a), i.performDataProcessorTasks(a), zc(this, a), i.performVisualTasks(a), Fs(this, this._model, o, "remain", {}), r -= +/* @__PURE__ */ new Date() - s;
          } while (r > 0 && i.unfinished);
          i.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(i, n, r) {
      if (this[Yt]) {
        process.env.NODE_ENV !== "production" && Ft("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Se(this.id);
        return;
      }
      var a, o, s;
      if (Z(n) && (r = n.lazyUpdate, a = n.silent, o = n.replaceMerge, s = n.transition, n = n.notMerge), this[Yt] = !0, Yr(this), !this._model || n) {
        var l = new n5(this._api), u = this._theme, c = this._model = new mf();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(i, {
        replaceMerge: o
      }, nd);
      var h = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (r)
        this[Jt] = {
          silent: a,
          updateParams: h
        }, this[Yt] = !1, this.getZr().wakeUp();
      else {
        try {
          Xn(this), Ii.update.call(this, null, h);
        } catch (d) {
          throw this[Jt] = null, this[Yt] = !1, d;
        }
        this._ssr || this._zr.flush(), this[Jt] = null, this[Yt] = !1, Hr.call(this, a), Wr.call(this, a);
      }
    }, t.prototype.setTheme = function(i, n) {
      if (this[Yt]) {
        process.env.NODE_ENV !== "production" && Ft("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Se(this.id);
        return;
      }
      var r = this._model;
      if (r) {
        var a = n && n.silent, o = null;
        this[Jt] && (a == null && (a = this[Jt].silent), o = this[Jt].updateParams, this[Jt] = null), this[Yt] = !0, Yr(this);
        try {
          this._updateTheme(i), r.setTheme(this._theme), Xn(this), Ii.update.call(this, {
            type: "setTheme"
          }, o);
        } catch (s) {
          throw this[Yt] = !1, s;
        }
        this[Yt] = !1, Hr.call(this, a), Wr.call(this, a);
      }
    }, t.prototype._updateTheme = function(i) {
      K(i) && (i = v1[i]), i && (i = ct(i), i && Cb(i, !0), this._theme = i);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || nt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(i) {
      return process.env.NODE_ENV !== "production" && ee("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(i);
    }, t.prototype.renderToCanvas = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: i.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: i.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: i.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var i = this._zr, n = i.storage.getDisplayList();
      return E(n, function(r) {
        r.stopAnimation(null, !0);
      }), i.painter.toDataURL();
    }, t.prototype.getDataURL = function(i) {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      i = i || {};
      var n = i.excludeComponents, r = this._model, a = [], o = this;
      E(n, function(l) {
        r.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(i).toDataURL("image/" + (i && i.type || "png"));
      return E(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, t.prototype.getConnectedDataURL = function(i) {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      var n = i.type === "svg", r = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (Ym[r]) {
        var l = s, u = s, c = -s, h = -s, d = [], f = i && i.pixelRatio || this.getDevicePixelRatio();
        E(bo, function(_, b) {
          if (_.group === r) {
            var w = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(ct(i)), S = _.getDom().getBoundingClientRect();
            l = a(S.left, l), u = a(S.top, u), c = o(S.right, c), h = o(S.bottom, h), d.push({
              dom: w,
              left: S.left,
              top: S.top
            });
          }
        }), l *= f, u *= f, c *= f, h *= f;
        var v = c - l, m = h - u, p = Ui.createCanvas(), g = $p(p, {
          renderer: n ? "svg" : "canvas"
        });
        if (g.resize({
          width: v,
          height: m
        }), n) {
          var y = "";
          return E(d, function(_) {
            var b = _.left - l, w = _.top - u;
            y += '<g transform="translate(' + b + "," + w + ')">' + _.dom + "</g>";
          }), g.painter.getSvgRoot().innerHTML = y, i.connectedBackgroundColor && g.painter.setBackgroundColor(i.connectedBackgroundColor), g.refreshImmediately(), g.painter.toDataURL();
        } else
          return i.connectedBackgroundColor && g.add(new he({
            shape: {
              x: 0,
              y: 0,
              width: v,
              height: m
            },
            style: {
              fill: i.connectedBackgroundColor
            }
          })), E(d, function(_) {
            var b = new wr({
              style: {
                x: _.left * f - l,
                y: _.top * f - u,
                image: _.dom
              }
            });
            g.add(b);
          }), g.refreshImmediately(), p.toDataURL("image/" + (i && i.type || "png"));
      } else
        return this.getDataURL(i);
    }, t.prototype.convertToPixel = function(i, n, r) {
      return Ns(this, "convertToPixel", i, n, r);
    }, t.prototype.convertToLayout = function(i, n, r) {
      return Ns(this, "convertToLayout", i, n, r);
    }, t.prototype.convertFromPixel = function(i, n, r) {
      return Ns(this, "convertFromPixel", i, n, r);
    }, t.prototype.containPixel = function(i, n) {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      var r = this._model, a, o = oc(r, i);
      return E(o, function(s, l) {
        l.indexOf("Models") >= 0 && E(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? a = a || h.containPoint(n, u) : process.env.NODE_ENV !== "production" && Xe(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && Xe(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(i, n) {
      var r = this._model, a = oc(r, i, {
        defaultMainType: "series"
      }), o = a.seriesModel;
      process.env.NODE_ENV !== "production" && (o || Xe("There is no specified series model"));
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? DI(s, l, n) : EI(s, n);
    }, t.prototype.getViewOfComponentModel = function(i) {
      return this._componentsMap[i.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(i) {
      return this._chartsMap[i.__viewId];
    }, t.prototype._initEvents = function() {
      var i = this;
      E(xR, function(r) {
        var a = function(o) {
          var s = i.getModel(), l = o.target, u, c = r === "globalout";
          if (c ? u = {} : l && ro(l, function(m) {
            var p = Lt(m);
            if (p && p.dataIndex != null) {
              var g = p.dataModel || s.getSeriesByIndex(p.seriesIndex);
              return u = g && g.getDataParams(p.dataIndex, p.dataType, l) || {}, !0;
            } else if (p.eventData)
              return u = V({}, p.eventData), !0;
          }, !0), u) {
            var h = u.componentType, d = u.componentIndex;
            (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", d = u.seriesIndex);
            var f = h && d != null && s.getComponent(h, d), v = f && i[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(f && v) && Xe("model or view can not be found by params"), u.event = o, u.type = r, i._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: f,
              view: v
            }, i.trigger(r, u);
          }
        };
        a.zrEventfulCallAtLast = !0, i._zr.on(r, a, i);
      });
      var n = this._messageCenter;
      E(ed, function(r, a) {
        n.on(a, function(o) {
          i.trigger(a, o);
        });
      }), AI(n, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      this._disposed = !0;
      var i = this.getDom();
      i && __(this.getDom(), Sf, "");
      var n = this, r = n._api, a = n._model;
      E(n._componentsViews, function(o) {
        o.dispose(a, r);
      }), E(n._chartsViews, function(o) {
        o.dispose(a, r);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete bo[n.id];
    }, t.prototype.resize = function(i) {
      if (this[Yt]) {
        process.env.NODE_ENV !== "production" && Ft("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Se(this.id);
        return;
      }
      this._zr.resize(i);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var r = n.resetOption("media"), a = i && i.silent;
        this[Jt] && (a == null && (a = this[Jt].silent), r = !0, this[Jt] = null), this[Yt] = !0, Yr(this);
        try {
          r && Xn(this), Ii.update.call(this, {
            type: "resize",
            animation: V({
              // Disable animation
              duration: 0
            }, i && i.animation)
          });
        } catch (o) {
          throw this[Yt] = !1, o;
        }
        this[Yt] = !1, Hr.call(this, a), Wr.call(this, a);
      }
    }, t.prototype.showLoading = function(i, n) {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      if (Z(i) && (n = i, i = ""), i = i || "default", this.hideLoading(), !rd[i]) {
        process.env.NODE_ENV !== "production" && Xe("Loading effects " + i + " not exists.");
        return;
      }
      var r = rd[i](this._api, n), a = this._zr;
      this._loadingFX = r, a.add(r);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(i) {
      var n = V({}, i);
      return n.type = Hl[i.type], n;
    }, t.prototype.dispatchAction = function(i, n) {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      if (Z(n) || (n = {
        silent: !!n
      }), !!Vl[i.type] && this._model) {
        if (this[Yt]) {
          this._pendingActions.push(i);
          return;
        }
        var r = n.silent;
        Vc.call(this, i, r);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && nt.browser.weChat && this._throttledZrFlush(), Hr.call(this, r), Wr.call(this, r);
      }
    }, t.prototype.updateLabelLayout = function() {
      ni.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(i) {
      if (this._disposed) {
        Se(this.id);
        return;
      }
      var n = i.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && J(i.data && a), a.appendData(i), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = (function() {
      Xn = function(h) {
        var d = h._scheduler;
        d.restorePipelines(h._model), d.prepareStageTasks(), $c(h, !0), $c(h, !1), d.plan();
      }, $c = function(h, d) {
        for (var f = h._model, v = h._scheduler, m = d ? h._componentsViews : h._chartsViews, p = d ? h._componentsMap : h._chartsMap, g = h._zr, y = h._api, _ = 0; _ < m.length; _++)
          m[_].__alive = !1;
        d ? f.eachComponent(function(S, C) {
          S !== "series" && b(C);
        }) : f.eachSeries(b);
        function b(S) {
          var C = S.__requireNewView;
          S.__requireNewView = !1;
          var T = "_ec_" + S.id + "_" + S.type, k = !C && p[T];
          if (!k) {
            var M = wi(S.type), D = d ? Xi.getClass(M.main, M.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              fn.getClass(M.sub)
            );
            process.env.NODE_ENV !== "production" && J(D, M.sub + " does not exist."), k = new D(), k.init(f, y), p[T] = k, m.push(k), g.add(k.group);
          }
          S.__viewId = k.__id = T, k.__alive = !0, k.__model = S, k.group.__ecComponentInfo = {
            mainType: S.mainType,
            index: S.componentIndex
          }, !d && v.prepareView(k, S, f, y);
        }
        for (var _ = 0; _ < m.length; ) {
          var w = m[_];
          w.__alive ? _++ : (!d && w.renderTask.dispose(), g.remove(w.group), w.dispose(f, y), m.splice(_, 1), p[w.__id] === w && delete p[w.__id], w.__id = w.group.__ecComponentInfo = null);
        }
      }, Bs = function(h, d, f, v, m) {
        var p = h._model;
        if (p.setUpdatePayload(f), !v) {
          E([].concat(h._componentsViews).concat(h._chartsViews), w);
          return;
        }
        var g = {};
        g[v + "Id"] = f[v + "Id"], g[v + "Index"] = f[v + "Index"], g[v + "Name"] = f[v + "Name"];
        var y = {
          mainType: v,
          query: g
        };
        m && (y.subType = m);
        var _ = f.excludeSeriesId, b;
        _ != null && (b = ot(), E(ye(_), function(S) {
          var C = ai(S, null);
          C != null && b.set(C, !0);
        })), p && p.eachComponent(y, function(S) {
          var C = b && b.get(S.id) != null;
          if (!C)
            if (Sg(f))
              if (S instanceof _n)
                f.type === vr && !f.notBlur && !S.get(["emphasis", "disabled"]) && KA(S, f, h._api);
              else {
                var T = Zd(S.mainType, S.componentIndex, f.name, h._api), k = T.focusSelf, M = T.dispatchers;
                f.type === vr && k && !f.notBlur && Nh(S.mainType, S.componentIndex, h._api), M && E(M, function(D) {
                  f.type === vr ? Dl(D) : El(D);
                });
              }
            else Fh(f) && S instanceof _n && (tL(S, f, h._api), _g(S), Ve(h));
        }, h), p && p.eachComponent(y, function(S) {
          var C = b && b.get(S.id) != null;
          C || w(h[v === "series" ? "_chartsMap" : "_componentsMap"][S.__viewId]);
        }, h);
        function w(S) {
          S && S.__alive && S[d] && S[d](S.__model, p, h._api, f);
        }
      }, Ii = {
        prepareAndUpdate: function(h) {
          Xn(this), Ii.update.call(this, h, h && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, d) {
          var f = this._model, v = this._api, m = this._zr, p = this._coordSysMgr, g = this._scheduler;
          if (f) {
            f.setUpdatePayload(h), g.restoreData(f, h), g.performSeriesTasks(f), p.create(f, v), g.performDataProcessorTasks(f, h), zc(this, f), p.update(f, v), n(f), g.performVisualTasks(f, h);
            var y = f.get("backgroundColor") || "transparent";
            m.setBackgroundColor(y);
            var _ = f.get("darkMode");
            _ != null && _ !== "auto" && m.setDarkMode(_), Hc(this, f, v, h, d), ni.trigger("afterupdate", f, v);
          }
        },
        updateTransform: function(h) {
          var d = this, f = this._model, v = this._api;
          if (f) {
            f.setUpdatePayload(h);
            var m = [];
            f.eachComponent(function(g, y) {
              if (g !== "series") {
                var _ = d.getViewOfComponentModel(y);
                if (_ && _.__alive)
                  if (_.updateTransform) {
                    var b = _.updateTransform(y, f, v, h);
                    b && b.update && m.push(_);
                  } else
                    m.push(_);
              }
            });
            var p = ot();
            f.eachSeries(function(g) {
              var y = d._chartsMap[g.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(g, f, v, h);
                _ && _.update && p.set(g.uid, 1);
              } else
                p.set(g.uid, 1);
            }), n(f), this._scheduler.performVisualTasks(f, h, {
              setDirty: !0,
              dirtyMap: p
            }), Fs(this, f, v, h, {}, p), ni.trigger("afterupdate", f, v);
          }
        },
        updateView: function(h) {
          var d = this._model;
          d && (d.setUpdatePayload(h), fn.markUpdateMethod(h, "updateView"), n(d), this._scheduler.performVisualTasks(d, h, {
            setDirty: !0
          }), Hc(this, d, this._api, h, {}), ni.trigger("afterupdate", d, this._api));
        },
        updateVisual: function(h) {
          var d = this, f = this._model;
          f && (f.setUpdatePayload(h), f.eachSeries(function(v) {
            v.getData().clearAllVisual();
          }), fn.markUpdateMethod(h, "updateVisual"), n(f), this._scheduler.performVisualTasks(f, h, {
            visualType: "visual",
            setDirty: !0
          }), f.eachComponent(function(v, m) {
            if (v !== "series") {
              var p = d.getViewOfComponentModel(m);
              p && p.__alive && p.updateVisual(m, f, d._api, h);
            }
          }), f.eachSeries(function(v) {
            var m = d._chartsMap[v.__viewId];
            m.updateVisual(v, f, d._api, h);
          }), ni.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(h) {
          Ii.update.call(this, h);
        }
      };
      function i(h, d, f, v, m) {
        if (h._disposed) {
          Se(h.id);
          return;
        }
        for (var p = h._model, g = h._coordSysMgr.getCoordinateSystems(), y, _ = oc(p, f), b = 0; b < g.length; b++) {
          var w = g[b];
          if (w[d] && (y = w[d](p, _, v, m)) != null)
            return y;
        }
        process.env.NODE_ENV !== "production" && Xe("No coordinate system that supports " + d + " found by the given finder.");
      }
      Ns = i, zc = function(h, d) {
        var f = h._chartsMap, v = h._scheduler;
        d.eachSeries(function(m) {
          v.updateStreamModes(m, f[m.__viewId]);
        });
      }, Vc = function(h, d) {
        var f = this, v = this.getModel(), m = h.type, p = h.escapeConnect, g = Vl[m], y = (g.update || "update").split(":"), _ = y.pop(), b = y[0] != null && wi(y[0]);
        this[Yt] = !0, Yr(this);
        var w = [h], S = !1;
        h.batch && (S = !0, w = dt(h.batch, function(F) {
          return F = zt(V({}, F), h), F.batch = null, F;
        }));
        var C = [], T, k = [], M = g.nonRefinedEventType, D = Fh(h), L = Sg(h);
        if (L && z_(this._api), E(w, function(F) {
          var W = g.action(F, v, f._api);
          if (g.refineEvent ? k.push(W) : T = W, T = T || V({}, F), T.type = M, C.push(T), L) {
            var z = Vd(h), N = z.queryOptionMap, $ = z.mainTypeSpecified, X = $ ? N.keys()[0] : "series";
            Bs(f, _, F, X), Ve(f);
          } else D ? (Bs(f, _, F, "series"), Ve(f)) : b && Bs(f, _, F, b.main, b.sub);
        }), _ !== "none" && !L && !D && !b)
          try {
            this[Jt] ? (Xn(this), Ii.update.call(this, h), this[Jt] = null) : Ii[_].call(this, h);
          } catch (F) {
            throw this[Yt] = !1, F;
          }
        if (S ? T = {
          type: M,
          escapeConnect: p,
          batch: C
        } : T = C[0], this[Yt] = !1, !d) {
          var P = void 0;
          if (g.refineEvent) {
            var R = g.refineEvent(k, h, v, this._api).eventContent;
            J(Z(R)), P = zt({
              type: g.refinedEventType
            }, R), P.fromAction = h.type, P.fromActionPayload = h, P.escapeConnect = !0;
          }
          var B = this._messageCenter;
          B.trigger(T.type, T), P && B.trigger(P.type, P);
        }
      }, Hr = function(h) {
        for (var d = this._pendingActions; d.length; ) {
          var f = d.shift();
          Vc.call(this, f, h);
        }
      }, Wr = function(h) {
        !h && this.trigger("updated");
      }, $m = function(h, d) {
        h.on("rendered", function(f) {
          d.trigger("rendered", f), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !d[Jt] && !d._scheduler.unfinished && !d._pendingActions.length && d.trigger("finished");
        });
      }, zm = function(h, d) {
        h.on("mouseover", function(f) {
          var v = f.target, m = ro(v, pa);
          m && (QA(m, f, d._api), Ve(d));
        }).on("mouseout", function(f) {
          var v = f.target, m = ro(v, pa);
          m && (JA(m, f, d._api), Ve(d));
        }).on("click", function(f) {
          var v = f.target, m = ro(v, function(y) {
            return Lt(y).dataIndex != null;
          }, !0);
          if (m) {
            var p = m.selected ? "unselect" : "select", g = Lt(m);
            d._api.dispatchAction({
              type: p,
              dataType: g.dataType,
              dataIndexInside: g.dataIndex,
              seriesIndex: g.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function n(h) {
        h.clearColorPalette(), h.eachSeries(function(d) {
          d.clearColorPalette();
        });
      }
      function r(h) {
        var d = [], f = [], v = !1;
        if (h.eachComponent(function(y, _) {
          var b = _.get("zlevel") || 0, w = _.get("z") || 0, S = _.getZLevelKey();
          v = v || !!S, (y === "series" ? f : d).push({
            zlevel: b,
            z: w,
            idx: _.componentIndex,
            type: y,
            key: S
          });
        }), v) {
          var m = d.concat(f), p, g;
          Gs(m, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), E(m, function(y) {
            var _ = h.getComponent(y.type, y.idx), b = y.zlevel, w = y.key;
            p != null && (b = Math.max(p, b)), w ? (b === p && w !== g && b++, g = w) : g && (b === p && b++, g = ""), p = b, _.setZLevel(b);
          });
        }
      }
      Hc = function(h, d, f, v, m) {
        r(d), Vm(h, d, f, v, m), E(h._chartsViews, function(p) {
          p.__alive = !1;
        }), Fs(h, d, f, v, m), E(h._chartsViews, function(p) {
          p.__alive || p.remove(d, f);
        });
      }, Vm = function(h, d, f, v, m, p) {
        E(p || h._componentsViews, function(g) {
          var y = g.__model;
          u(y, g), g.render(y, d, f, v), l(y, g), c(y, g);
        });
      }, Fs = function(h, d, f, v, m, p) {
        var g = h._scheduler;
        m = V(m || {}, {
          updatedSeries: d.getSeries()
        }), ni.trigger("series:beforeupdate", d, f, m);
        var y = !1;
        d.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          b.__alive = !0;
          var w = b.renderTask;
          g.updatePayload(w, v), u(_, b), p && p.get(_.uid) && w.dirty(), w.perform(g.getPerformArgs(w)) && (y = !0), b.group.silent = !!_.get("silent"), s(_, b), _g(_);
        }), g.unfinished = y || g.unfinished, ni.trigger("series:layoutlabels", d, f, m), ni.trigger("series:transition", d, f, m), d.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          l(_, b), c(_, b);
        }), o(h, d), ni.trigger("series:afterupdate", d, f, m);
      }, Ve = function(h) {
        h[Nc] = !0, h.getZr().wakeUp();
      }, Yr = function(h) {
        h[Os] = (h[Os] + 1) % 1e3;
      }, Wm = function(h) {
        h[Nc] && (h.getZr().storage.traverse(function(d) {
          yo(d) || a(d);
        }), h[Nc] = !1);
      };
      function a(h) {
        for (var d = [], f = h.currentStates, v = 0; v < f.length; v++) {
          var m = f[v];
          m === "emphasis" || m === "blur" || m === "select" || d.push(m);
        }
        h.selected && h.states.select && d.push("select"), h.hoverState === Xd && h.states.emphasis ? d.push("emphasis") : h.hoverState === Gd && h.states.blur && d.push("blur"), h.useStates(d);
      }
      function o(h, d) {
        var f = h._zr, v = f.storage, m = 0;
        v.traverse(function(p) {
          p.isGroup || m++;
        }), m > d.get("hoverLayerThreshold") && !nt.node && !nt.worker && d.eachSeries(function(p) {
          if (!p.preventUsingHoverLayer) {
            var g = h._chartsMap[p.__viewId];
            g.__alive && g.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function s(h, d) {
        var f = h.get("blendMode") || null;
        d.eachRendered(function(v) {
          v.isGroup || (v.style.blend = f);
        });
      }
      function l(h, d) {
        if (!h.preventAutoZ) {
          var f = Oo(h);
          d.eachRendered(function(v) {
            return rb(v, f.z, f.zlevel), !0;
          });
        }
      }
      function u(h, d) {
        d.eachRendered(function(f) {
          if (!yo(f)) {
            var v = f.getTextContent(), m = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), m && m.stateTransition && (m.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(h, d) {
        var f = h.getModel("stateAnimation"), v = h.isAnimationEnabled(), m = f.get("duration"), p = m > 0 ? {
          duration: m,
          delay: f.get("delay"),
          easing: f.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        d.eachRendered(function(g) {
          if (g.states && g.states.emphasis) {
            if (yo(g))
              return;
            if (g instanceof Et && sL(g), g.__dirty) {
              var y = g.prevStates;
              y && g.useStates(y);
            }
            if (v) {
              g.stateTransition = p;
              var _ = g.getTextContent(), b = g.getTextGuideLine();
              _ && (_.stateTransition = p), b && (b.stateTransition = p);
            }
            g.__dirty && a(g);
          }
        });
      }
      Hm = function(h) {
        return new /** @class */
        ((function(d) {
          Xt(f, d);
          function f() {
            return d !== null && d.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(v) {
            for (; v; ) {
              var m = v.__ecComponentInfo;
              if (m != null)
                return h._model.getComponent(m.mainType, m.index);
              v = v.parent;
            }
          }, f.prototype.enterEmphasis = function(v, m) {
            Dl(v, m), Ve(h);
          }, f.prototype.leaveEmphasis = function(v, m) {
            El(v, m), Ve(h);
          }, f.prototype.enterBlur = function(v) {
            ZA(v), Ve(h);
          }, f.prototype.leaveBlur = function(v) {
            B_(v), Ve(h);
          }, f.prototype.enterSelect = function(v) {
            N_(v), Ve(h);
          }, f.prototype.leaveSelect = function(v) {
            F_(v), Ve(h);
          }, f.prototype.getModel = function() {
            return h.getModel();
          }, f.prototype.getViewOfComponentModel = function(v) {
            return h.getViewOfComponentModel(v);
          }, f.prototype.getViewOfSeriesModel = function(v) {
            return h.getViewOfSeriesModel(v);
          }, f.prototype.getMainProcessVersion = function() {
            return h[Os];
          }, f;
        })(wb))(h);
      }, d1 = function(h) {
        function d(f, v) {
          for (var m = 0; m < f.length; m++) {
            var p = f[m];
            p[Fc] = v;
          }
        }
        E(Hl, function(f, v) {
          h._messageCenter.on(v, function(m) {
            if (Ym[h.group] && h[Fc] !== Fm) {
              if (m && m.escapeConnect)
                return;
              var p = h.makeActionFromEvent(m), g = [];
              E(bo, function(y) {
                y !== h && y.group === h.group && g.push(y);
              }), d(g, Fm), E(g, function(y) {
                y[Fc] !== _R && y.dispatchAction(p);
              }), d(g, bR);
            }
          });
        });
      };
    })(), t;
  })(li)
), wf = f1.prototype;
wf.on = s1("on");
wf.off = s1("off");
wf.one = function(e, t, i) {
  var n = this;
  Gi("ECharts#one is deprecated.");
  function r() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    t && t.apply && t.apply(this, a), n.off(e, r);
  }
  this.on.call(this, e, r, i);
};
var xR = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function Se(e) {
  process.env.NODE_ENV !== "production" && Xe("Instance " + e + " has been disposed");
}
var Vl = {}, Hl = {}, ed = {}, id = [], nd = [], Wl = [], v1 = {}, rd = {}, bo = {}, Ym = {}, wR = +/* @__PURE__ */ new Date() - 0, Sf = "_echarts_instance_";
function SR(e, t, i) {
  {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var n = CR(e);
    if (n)
      return process.env.NODE_ENV !== "production" && Xe("There is a chart instance already initialized on the dom."), n;
    process.env.NODE_ENV !== "production" && ca(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && !i || !e.clientHeight && !i) && Xe("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var r = new f1(e, t, i);
  return r.id = "ec_" + wR++, bo[r.id] = r, __(e, Sf, r.id), d1(r), ni.trigger("afterinit", r), r;
}
function CR(e) {
  return bo[FE(e, Sf)];
}
function p1(e, t) {
  v1[e] = t;
}
function g1(e) {
  Pt(nd, e) < 0 && nd.push(e);
}
function m1(e, t) {
  Tf(id, e, t, hR);
}
function TR(e) {
  Cf("afterinit", e);
}
function MR(e) {
  Cf("afterupdate", e);
}
function Cf(e, t) {
  ni.on(e, t);
}
function Cr(e, t, i) {
  var n, r, a, o, s;
  ht(t) && (i = t, t = ""), Z(e) ? (n = e.type, r = e.event, o = e.update, s = e.publishNonRefinedEvent, i || (i = e.action), a = e.refineEvent) : (n = e, r = t);
  function l(c) {
    return c.toLowerCase();
  }
  r = l(r || n);
  var u = a ? l(n) : r;
  Vl[n] || (J(Nm.test(n) && Nm.test(r)), a && J(r !== n), Vl[n] = {
    actionType: n,
    refinedEventType: r,
    nonRefinedEventType: u,
    update: o,
    action: i,
    refineEvent: a
  }, ed[r] = 1, a && s && (ed[u] = 1), process.env.NODE_ENV !== "production" && Hl[u] && Ft(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), Hl[u] = n);
}
function kR(e, t) {
  yu.register(e, t);
}
function DR(e, t) {
  Tf(Wl, e, t, r1, "layout");
}
function Tr(e, t) {
  Tf(Wl, e, t, a1, "visual");
}
var Um = [];
function Tf(e, t, i, n, r) {
  if ((ht(t) || Z(t)) && (i = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    E(e, function(o) {
      J(o.__raw !== i);
    });
  }
  if (!(Pt(Um, i) >= 0)) {
    Um.push(i);
    var a = Ub.wrapStageHandler(i, r);
    a.__prio = t, a.__raw = i, e.push(a);
  }
}
function y1(e, t) {
  rd[e] = t;
}
function ER(e, t, i) {
  var n = oR("registerMap");
  n && n(e, t, i);
}
var AR = R5;
Tr(xf, hI);
Tr(xu, dI);
Tr(xu, fI);
Tr(xf, MI);
Tr(xu, kI);
Tr(o1, rR);
g1(Cb);
m1(uR, p5);
y1("default", vI);
Cr({
  type: vr,
  event: vr,
  update: vr
}, ce);
Cr({
  type: Ks,
  event: Ks,
  update: Ks
}, ce);
Cr({
  type: Ml,
  event: jd,
  update: Ml,
  action: ce,
  refineEvent: Mf,
  publishNonRefinedEvent: !0
});
Cr({
  type: Oh,
  event: jd,
  update: Oh,
  action: ce,
  refineEvent: Mf,
  publishNonRefinedEvent: !0
});
Cr({
  type: kl,
  event: jd,
  update: kl,
  action: ce,
  refineEvent: Mf,
  publishNonRefinedEvent: !0
});
function Mf(e, t, i, n) {
  return {
    eventContent: {
      selected: eL(i),
      isFromClick: t.isFromClick || !1
    }
  };
}
p1("default", {});
p1("dark", qb);
function Fa(e) {
  return e == null ? 0 : e.length || 1;
}
function Gm(e) {
  return e;
}
var LR = (
  /** @class */
  (function() {
    function e(t, i, n, r, a, o) {
      this._old = t, this._new = i, this._oldKeyGetter = n || Gm, this._newKeyGetter = r || Gm, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, i = this._new, n = {}, r = new Array(t.length), a = new Array(i.length);
      this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(i, n, a, "_newKeyGetter");
      for (var o = 0; o < t.length; o++) {
        var s = r[o], l = n[s], u = Fa(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[s] = l[0]), this._update && this._update(c, o);
        } else u === 1 ? (n[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, n);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, i = this._new, n = {}, r = {}, a = [], o = [];
      this._initIndexMap(t, n, a, "_oldKeyGetter"), this._initIndexMap(i, r, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = n[l], c = r[l], h = Fa(u), d = Fa(c);
        if (h > 1 && d === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), r[l] = null;
        else if (h === 1 && d > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), r[l] = null;
        else if (h === 1 && d === 1)
          this._update && this._update(c, u), r[l] = null;
        else if (h > 1 && d > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), r[l] = null;
        else if (h > 1)
          for (var f = 0; f < h; f++)
            this._remove && this._remove(u[f]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, r);
    }, e.prototype._performRestAdd = function(t, i) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n], a = i[r], o = Fa(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else o === 1 && this._add && this._add(a);
        i[r] = null;
      }
    }, e.prototype._initIndexMap = function(t, i, n, r) {
      for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
        var s = "_ec_" + this[r](t[o], o);
        if (a || (n[o] = s), !!i) {
          var l = i[s], u = Fa(l);
          u === 0 ? (i[s] = o, a && n.push(s)) : u === 1 ? i[s] = [l, o] : l.push(o);
        }
      }
    }, e;
  })()
), PR = (
  /** @class */
  (function() {
    function e(t, i) {
      this._encode = t, this._schema = i;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  })()
);
function IR(e, t) {
  var i = {}, n = i.encode = {}, r = ot(), a = [], o = [], s = {};
  E(e.dimensions, function(d) {
    var f = e.getDimensionInfo(d), v = f.coordDim;
    if (v) {
      process.env.NODE_ENV !== "production" && J(Yh.get(v) == null);
      var m = f.coordDimIndex;
      Wc(n, v)[m] = d, f.isExtraCoord || (r.set(v, 1), OR(f.type) && (a[0] = d), Wc(s, v)[m] = e.getDimensionIndex(f.name)), f.defaultTooltip && o.push(d);
    }
    Yh.each(function(p, g) {
      var y = Wc(n, g), _ = f.otherDims[g];
      _ != null && _ !== !1 && (y[_] = f.name);
    });
  });
  var l = [], u = {};
  r.each(function(d, f) {
    var v = n[f];
    u[f] = v[0], l = l.concat(v);
  }), i.dataDimsOnCoord = l, i.dataDimIndicesOnCoord = dt(l, function(d) {
    return e.getDimensionInfo(d).storeDimIndex;
  }), i.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (a = c.slice());
  var h = n.tooltip;
  return h && h.length ? o = h.slice() : o.length || (o = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = o, i.userOutput = new PR(s, t), i;
}
function Wc(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function RR(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function OR(e) {
  return !(e === "ordinal" || e === "time");
}
var el = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.otherDims = {}, t != null && V(this, t);
    }
    return e;
  })()
), BR = It(), NR = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, _1 = (
  /** @class */
  (function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = w1(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return tt(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var i = this.source.dimensionsDefine;
      if (i)
        return i[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, i = Mb(this.source), n = !S1(t), r = "", a = [], o = 0, s = 0; o < t; o++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[s];
        if (h && h.storeDimIndex === o)
          l = i ? h.name : null, u = h.type, c = h.ordinalMeta, s++;
        else {
          var d = this.getSourceDimension(o);
          d && (l = i ? d.name : null, u = d.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), i && l != null && (!h || !h.isCalculationCoord) && (r += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += NR[u] || "f", c && (r += c.uid), r += "$";
      }
      var f = this.source, v = [f.seriesLayoutBy, f.startIndex, r].join("$$");
      return {
        dimensions: a,
        hash: v
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], i = 0, n = 0; i < this._fullDimCount; i++) {
        var r = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === i)
          a.isCalculationCoord || (r = a.name), n++;
        else {
          var o = this.getSourceDimension(i);
          o && (r = o.name);
        }
        t.push(r);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  })()
);
function b1(e) {
  return e instanceof _1;
}
function x1(e) {
  for (var t = ot(), i = 0; i < (e || []).length; i++) {
    var n = e[i], r = Z(n) ? n.name : n;
    r != null && t.get(r) == null && t.set(r, i);
  }
  return t;
}
function w1(e) {
  var t = BR(e);
  return t.dimNameMap || (t.dimNameMap = x1(e.dimensionsDefine));
}
function S1(e) {
  return e > 30;
}
var $a = Z, tn = dt, FR = typeof Int32Array > "u" ? Array : Int32Array, $R = "e\0\0", Xm = -1, zR = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], VR = ["_approximateExtent"], jm, $s, za, Ur, Yc, Va, Uc, ad = (
  /** @class */
  (function() {
    function e(t, i) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var n, r = !1;
      b1(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = !0, n = t), n = n || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var h = n[c], d = K(h) ? new el({
          name: h
        }) : h instanceof el ? h : new el(h), f = d.name;
        d.type = d.type || "float", d.coordDim || (d.coordDim = f, d.coordDimIndex = 0);
        var v = d.otherDims = d.otherDims || {};
        o.push(f), a[f] = d, u[f] != null && (l = !0), d.createInvertedIndices && (s[f] = []);
        var m = c;
        Nt(d.storeDimIndex) && (m = d.storeDimIndex), v.itemName === 0 && (this._nameDimIdx = m), v.itemId === 0 && (this._idDimIdx = m), process.env.NODE_ENV !== "production" && J(r || d.storeDimIndex >= 0), r && (d.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = i, this._invertedIndicesMap = s, this._dimOmitted) {
        var p = this._dimIdxToName = ot();
        E(o, function(g) {
          p.set(a[g].storeDimIndex, g);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i == null)
        return t;
      if (i = t, !this._dimOmitted)
        return this.dimensions[i];
      var n = this._dimIdxToName.get(i);
      if (n != null)
        return n;
      var r = this._schema.getSourceDimension(i);
      if (r)
        return r.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i != null)
        return i;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if (Nt(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var i = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && i == null)
        throw new Error("Unknown dimension " + t);
      return i;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var i = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return i.hasOwnProperty(n) ? i[n] : void 0;
      } : function(n) {
        return i[n];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, i) {
      var n = this._dimSummary;
      if (i == null)
        return n.encodeFirstDimNotExtra[t];
      var r = n.encode[t];
      return r ? r[i] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var i = this._dimSummary, n = i.encode[t];
      return (n || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, i, n) {
      var r = this, a;
      if (t instanceof Gh && (a = t), !a) {
        var o = this.dimensions, s = yf(t) || Ae(t) ? new kb(t, o.length) : t;
        a = new Gh();
        var l = tn(o, function(u) {
          return {
            type: r._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, n);
      }
      this._store = a, this._nameList = (i || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = IR(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var i = this._store.appendData(t);
      this._doInit(i[0], i[1]);
    }, e.prototype.appendValues = function(t, i) {
      var n = this._store.appendValues(t, i && i.length), r = n.start, a = n.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), i)
        for (var s = r; s < a; s++) {
          var l = s - r;
          this._nameList[s] = i[l], o && Uc(this, s);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, i = this.dimensions, n = 0; n < i.length; n++) {
        var r = this._dimInfos[i[n]];
        r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== Yi && !t.fillStorage;
    }, e.prototype._doInit = function(t, i) {
      if (!(t >= i)) {
        var n = this._store, r = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = r.getSource().sourceFormat, l = s === Ne;
        if (l && !r.pure)
          for (var u = [], c = t; c < i; c++) {
            var h = r.getItem(c, u);
            if (!this.hasItemOption && kE(h) && (this.hasItemOption = !0), h) {
              var d = h.name;
              a[c] == null && d != null && (a[c] = ai(d, null));
              var f = h.id;
              o[c] == null && f != null && (o[c] = ai(f, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < i; c++)
            Uc(this, c);
        jm(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, i) {
      i = this.getDimension(i), this._approximateExtent[i] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, i) {
      $a(t) ? V(this._calculationInfo, t) : this._calculationInfo[t] = i;
    }, e.prototype.getName = function(t) {
      var i = this.getRawIndex(t), n = this._nameList[i];
      return n == null && this._nameDimIdx != null && (n = za(this, this._nameDimIdx, i)), n == null && (n = ""), n;
    }, e.prototype._getCategory = function(t, i) {
      var n = this._store.get(t, i), r = this._store.getOrdinalMeta(t);
      return r ? r.categories[n] : n;
    }, e.prototype.getId = function(t) {
      return $s(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.get(r.storeDimIndex, i);
    }, e.prototype.getByRawIndex = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.getByRawIndex(r.storeDimIndex, i);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, i) {
      var n = this, r = this._store;
      return j(t) ? r.getValues(tn(t, function(a) {
        return n._getStoreDimIndex(a);
      }), i) : r.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var i = this._dimSummary.dataDimIndicesOnCoord, n = 0, r = i.length; n < r; n++)
        if (isNaN(this._store.get(i[n], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var i = 0, n = this._store.count(); i < n; i++)
        if (this.getName(i) === t)
          return i;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, i) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var r = n && n[i];
      return r == null || isNaN(r) ? Xm : r;
    }, e.prototype.each = function(t, i, n) {
      ht(t) && (n = i, i = t, t = []);
      var r = n || this, a = tn(Ur(t), this._getStoreDimIndex, this);
      this._store.each(a, r ? mt(i, r) : i);
    }, e.prototype.filterSelf = function(t, i, n) {
      ht(t) && (n = i, i = t, t = []);
      var r = n || this, a = tn(Ur(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, r ? mt(i, r) : i), this;
    }, e.prototype.selectRange = function(t) {
      var i = this, n = {}, r = Bt(t);
      return E(r, function(a) {
        var o = i._getStoreDimIndex(a);
        n[o] = t[a];
      }), this._store = this._store.selectRange(n), this;
    }, e.prototype.mapArray = function(t, i, n) {
      ht(t) && (n = i, i = t, t = []), n = n || this;
      var r = [];
      return this.each(t, function() {
        r.push(i && i.apply(this, arguments));
      }, n), r;
    }, e.prototype.map = function(t, i, n, r) {
      var a = n || r || this, o = tn(Ur(t), this._getStoreDimIndex, this), s = Va(this);
      return s._store = this._store.map(o, a ? mt(i, a) : i), s;
    }, e.prototype.modify = function(t, i, n, r) {
      var a = this, o = n || r || this;
      process.env.NODE_ENV !== "production" && E(Ur(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = tn(Ur(t), this._getStoreDimIndex, this);
      this._store.modify(s, o ? mt(i, o) : i);
    }, e.prototype.downSample = function(t, i, n, r) {
      var a = Va(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), i, n, r), a;
    }, e.prototype.minmaxDownSample = function(t, i) {
      var n = Va(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = Va(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var i = this.hostModel, n = this.getRawDataItem(t);
      return new Ot(n, i, i && i.ecModel);
    }, e.prototype.diff = function(t) {
      var i = this;
      return new LR(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return $s(t, n);
      }, function(n) {
        return $s(i, n);
      });
    }, e.prototype.getVisual = function(t) {
      var i = this._visual;
      return i && i[t];
    }, e.prototype.setVisual = function(t, i) {
      this._visual = this._visual || {}, $a(t) ? V(this._visual, t) : this._visual[t] = i;
    }, e.prototype.getItemVisual = function(t, i) {
      var n = this._itemVisuals[t], r = n && n[i];
      return r ?? this.getVisual(i);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, i) {
      var n = this._itemVisuals, r = n[t];
      r || (r = n[t] = {});
      var a = r[i];
      return a == null && (a = this.getVisual(i), j(a) ? a = a.slice() : $a(a) && (a = V({}, a)), r[i] = a), a;
    }, e.prototype.setItemVisual = function(t, i, n) {
      var r = this._itemVisuals[t] || {};
      this._itemVisuals[t] = r, $a(i) ? V(r, i) : r[i] = n;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, i) {
      $a(t) ? V(this._layout, t) : this._layout[t] = i;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, i, n) {
      this._itemLayouts[t] = n ? V(this._itemLayouts[t] || {}, i) : i;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, i) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      zA(n, this.dataType, t, i), this._graphicEls[t] = i;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, i) {
      E(this._graphicEls, function(n, r) {
        n && t && t.call(i, n, r);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : tn(this.dimensions, this._getDimInfo, this), this.hostModel)), Yc(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, i) {
      var n = this[t];
      ht(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var r = n.apply(this, arguments);
        return i.apply(this, [r].concat(Rd(arguments)));
      });
    }, e.internalField = (function() {
      jm = function(t) {
        var i = t._invertedIndicesMap;
        E(i, function(n, r) {
          var a = t._dimInfos[r], o = a.ordinalMeta, s = t._store;
          if (o) {
            n = i[r] = new FR(o.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = Xm;
            for (var l = 0; l < s.count(); l++)
              n[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, za = function(t, i, n) {
        return ai(t._getCategory(i, n), null);
      }, $s = function(t, i) {
        var n = t._idList[i];
        return n == null && t._idDimIdx != null && (n = za(t, t._idDimIdx, i)), n == null && (n = $R + i), n;
      }, Ur = function(t) {
        return j(t) || (t = t != null ? [t] : []), t;
      }, Va = function(t) {
        var i = new e(t._schema ? t._schema : tn(t.dimensions, t._getDimInfo, t), t.hostModel);
        return Yc(i, t), i;
      }, Yc = function(t, i) {
        E(zR.concat(i.__wrappedMethods || []), function(n) {
          i.hasOwnProperty(n) && (t[n] = i[n]);
        }), t.__wrappedMethods = i.__wrappedMethods, E(VR, function(n) {
          t[n] = ct(i[n]);
        }), t._calculationInfo = V({}, i._calculationInfo);
      }, Uc = function(t, i) {
        var n = t._nameList, r = t._idList, a = t._nameDimIdx, o = t._idDimIdx, s = n[i], l = r[i];
        if (s == null && a != null && (n[i] = s = za(t, a, i)), l == null && o != null && (r[i] = l = za(t, o, i)), l == null && s != null) {
          var u = t._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), r[i] = l;
        }
      };
    })(), e;
  })()
);
function C1(e, t) {
  yf(e) || (e = _f(e)), t = t || {};
  var i = t.coordDimensions || [], n = t.dimensionsDefine || e.dimensionsDefine || [], r = ot(), a = [], o = WR(e, i, n, t.dimensionsCount), s = t.canOmitUnusedDimensions && S1(o), l = n === e.dimensionsDefine, u = l ? w1(e) : x1(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, o));
  for (var h = ot(c), d = new Pb(o), f = 0; f < d.length; f++)
    d[f] = -1;
  function v(k) {
    var M = d[k];
    if (M < 0) {
      var D = n[k], L = Z(D) ? D : {
        name: D
      }, P = new el(), R = L.name;
      R != null && u.get(R) != null && (P.name = P.displayName = R), L.type != null && (P.type = L.type), L.displayName != null && (P.displayName = L.displayName);
      var B = a.length;
      return d[k] = B, P.storeDimIndex = k, a.push(P), P;
    }
    return a[M];
  }
  if (!s)
    for (var f = 0; f < o; f++)
      v(f);
  h.each(function(k, M) {
    var D = ye(k).slice();
    if (D.length === 1 && !K(D[0]) && D[0] < 0) {
      h.set(M, !1);
      return;
    }
    var L = h.set(M, []);
    E(D, function(P, R) {
      var B = K(P) ? u.get(P) : P;
      B != null && B < o && (L[R] = B, p(v(B), M, R));
    });
  });
  var m = 0;
  E(i, function(k) {
    var M, D, L, P;
    if (K(k))
      M = k, P = {};
    else {
      P = k, M = P.name;
      var R = P.ordinalMeta;
      P.ordinalMeta = null, P = V({}, P), P.ordinalMeta = R, D = P.dimsDef, L = P.otherDims, P.name = P.coordDim = P.coordDimIndex = P.dimsDef = P.otherDims = null;
    }
    var B = h.get(M);
    if (B !== !1) {
      if (B = ye(B), !B.length)
        for (var F = 0; F < (D && D.length || 1); F++) {
          for (; m < o && v(m).coordDim != null; )
            m++;
          m < o && B.push(m++);
        }
      E(B, function(W, z) {
        var N = v(W);
        if (l && P.type != null && (N.type = P.type), p(zt(N, P), M, z), N.name == null && D) {
          var $ = D[z];
          !Z($) && ($ = {
            name: $
          }), N.name = N.displayName = $.name, N.defaultTooltip = $.defaultTooltip;
        }
        L && zt(N.otherDims, L);
      });
    }
  });
  function p(k, M, D) {
    Yh.get(M) != null ? k.otherDims[M] = D : (k.coordDim = M, k.coordDimIndex = D, r.set(M, !0));
  }
  var g = t.generateCoord, y = t.generateCoordCount, _ = y != null;
  y = g ? y || 1 : 0;
  var b = g || "value";
  function w(k) {
    k.name == null && (k.name = k.coordDim);
  }
  if (s)
    E(a, function(k) {
      w(k);
    }), a.sort(function(k, M) {
      return k.storeDimIndex - M.storeDimIndex;
    });
  else
    for (var S = 0; S < o; S++) {
      var C = v(S), T = C.coordDim;
      T == null && (C.coordDim = YR(b, r, _), C.coordDimIndex = 0, (!g || y <= 0) && (C.isExtraCoord = !0), y--), w(C), C.type == null && (xb(e, S) === Le.Must || C.isExtraCoord && (C.otherDims.itemName != null || C.otherDims.seriesName != null)) && (C.type = "ordinal");
    }
  return HR(a), new _1({
    source: e,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function HR(e) {
  for (var t = ot(), i = 0; i < e.length; i++) {
    var n = e[i], r = n.name, a = t.get(r) || 0;
    a > 0 && (n.name = r + (a - 1)), a++, t.set(r, a);
  }
}
function WR(e, t, i, n) {
  var r = Math.max(e.dimensionsDetectedCount || 1, t.length, i.length, n || 0);
  return E(t, function(a) {
    var o;
    Z(a) && (o = a.dimsDef) && (r = Math.max(r, o.length));
  }), r;
}
function YR(e, t, i) {
  if (i || t.hasKey(e)) {
    for (var n = 0; t.hasKey(e + n); )
      n++;
    e += n;
  }
  return t.set(e, !0), e;
}
var UR = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = ot(), this.categoryAxisMap = ot(), this.coordSysName = t;
    }
    return e;
  })()
);
function GR(e) {
  var t = e.get("coordinateSystem"), i = new UR(t), n = XR[t];
  if (n)
    return n(e, i, i.axisMap, i.categoryAxisMap), i;
}
var XR = {
  cartesian2d: function(e, t, i, n) {
    var r = e.getReferringComponents("xAxis", rn).models[0], a = e.getReferringComponents("yAxis", rn).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error('xAxis "' + mn(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + mn(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], i.set("x", r), i.set("y", a), Gr(r) && (n.set("x", r), t.firstCategoryDimIndex = 0), Gr(a) && (n.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, i, n) {
    var r = e.getReferringComponents("singleAxis", rn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], i.set("single", r), Gr(r) && (n.set("single", r), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, i, n) {
    var r = e.getReferringComponents("polar", rn).models[0], a = r.findAxisModel("radiusAxis"), o = r.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!o)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", o), Gr(a) && (n.set("radius", a), t.firstCategoryDimIndex = 0), Gr(o) && (n.set("angle", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, i, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, i, n) {
    var r = e.ecModel, a = r.getComponent("parallel", e.get("parallelIndex")), o = t.coordSysDims = a.dimensions.slice();
    E(a.parallelAxisIndex, function(s, l) {
      var u = r.getComponent("parallelAxis", s), c = o[l];
      i.set(c, u), Gr(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(e, t, i, n) {
    var r = e.getReferringComponents("matrix", rn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = r.getDimensionModel("x"), o = r.getDimensionModel("y");
    i.set("x", a), i.set("y", o), n.set("x", a), n.set("y", o);
  }
};
function Gr(e) {
  return e.get("type") === "category";
}
function jR(e, t, i) {
  i = i || {};
  var n = i.byIndex, r = i.stackedCoordDimension, a, o, s;
  qR(t) ? a = t : (o = t.schema, a = o.dimensions, s = t.store);
  var l = !!(e && e.get("stack")), u, c, h, d;
  if (E(a, function(y, _) {
    K(y) && (a[_] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!r || r === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    h = "__\0ecstackresult_" + e.id, d = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var f = c.coordDim, v = c.type, m = 0;
    E(a, function(y) {
      y.coordDim === f && m++;
    });
    var p = {
      name: h,
      coordDim: f,
      coordDimIndex: m,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, g = {
      name: d,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: d,
      coordDimIndex: m + 1,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (p.storeDimIndex = s.ensureCalculationDimension(d, v), g.storeDimIndex = s.ensureCalculationDimension(h, v)), o.appendCalculationDimension(p), o.appendCalculationDimension(g)) : (a.push(p), a.push(g));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: d,
    stackResultDimension: h
  };
}
function qR(e) {
  return !b1(e.schema);
}
function ZR(e, t) {
  var i = e.get("coordinateSystem"), n = yu.get(i), r;
  return t && t.coordSysDims && (r = dt(t.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = t.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = RR(l);
    }
    return o;
  })), r || (r = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), r;
}
function KR(e, t, i) {
  var n, r;
  return i && E(e, function(a, o) {
    var s = a.coordDim, l = i.categoryAxisMap.get(s);
    l && (n == null && (n = o), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (r = !0);
  }), !r && n != null && (e[n].otherDims.itemName = 0), n;
}
function QR(e, t, i) {
  i = i || {};
  var n = t.getSourceManager(), r, a = !1;
  e ? (a = !0, r = _f(e)) : (r = n.getSource(), a = r.sourceFormat === Ne);
  var o = GR(t), s = ZR(t, o), l = i.useEncodeDefaulter, u = ht(l) ? l : l ? me(HP, s, t) : null, c = {
    coordDimensions: s,
    generateCoord: i.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, h = C1(r, c), d = KR(h.dimensions, i.createInvertedIndices, o), f = a ? null : n.getSharedDataStore(h), v = jR(t, {
    schema: h,
    store: f
  }), m = new ad(h, t);
  m.setCalculationInfo(v);
  var p = d != null && JR(r) ? function(g, y, _, b) {
    return b === d ? _ : this.defaultDimValueGetter(g, y, _, b);
  } : null;
  return m.hasItemOption = !1, m.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? r : f,
    null,
    p
  ), m;
}
function JR(e) {
  if (e.sourceFormat === Ne) {
    var t = tO(e.data || []);
    return !j(Yo(t));
  }
}
function tO(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
function T1(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function eO(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function iO(e) {
  return e.type === "category" && eO(e.getLabelModel()) === 0;
}
function Yl(e) {
  return e === "middle" || e === "center";
}
var qm = [], nO = {
  registerPreprocessor: g1,
  registerProcessor: m1,
  registerPostInit: TR,
  registerPostUpdate: MR,
  registerUpdateLifecycle: Cf,
  registerAction: Cr,
  registerCoordinateSystem: kR,
  registerLayout: DR,
  registerVisual: Tr,
  registerTransform: AR,
  registerLoading: y1,
  registerMap: ER,
  registerImpl: aR,
  PRIORITY: yR,
  ComponentModel: wt,
  ComponentView: Xi,
  SeriesModel: _n,
  ChartView: fn,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    wt.registerClass(e);
  },
  registerComponentView: function(e) {
    Xi.registerClass(e);
  },
  registerSeriesModel: function(e) {
    _n.registerClass(e);
  },
  registerChartView: function(e) {
    fn.registerClass(e);
  },
  registerCustomSeries: function(e, t) {
  },
  registerSubTypeDefaulter: function(e, t) {
    wt.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    pE(e, t);
  }
};
function kf(e) {
  if (j(e)) {
    E(e, function(t) {
      kf(t);
    });
    return;
  }
  Pt(qm, e) >= 0 || (qm.push(e), ht(e) && (e = {
    install: e
  }), e.install(nO));
}
It();
It();
var Zm = {
  estimate: 1,
  determine: 2
};
function rO(e) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: e
  };
}
var Km = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], aO = 1, Ul = 2, M1 = aO | Ul;
function Gl(e, t, i) {
  i = i || M1, t ? e.dirty |= i : e.dirty &= ~i;
}
function k1(e, t) {
  return t = t || M1, e.dirty == null || !!(e.dirty & t);
}
function bn(e) {
  if (e)
    return k1(e) && oO(e, e.label, e), e;
}
function oO(e, t, i) {
  var n = t.getComputedTransform();
  e.transform = hf(e.transform, n);
  var r = e.localRect = Ro(e.localRect, t.getBoundingRect()), a = t.style, o = a.margin, s = i && i.marginForce, l = i && i.minMarginForce, u = i && i.marginDefault, c = a.__marginType;
  c == null && u && (o = u, c = ta.textMargin);
  for (var h = 0; h < 4; h++)
    Gc[h] = c === ta.minMargin && l && l[h] != null ? l[h] : s && s[h] != null ? s[h] : o ? o[h] : 0;
  c === ta.textMargin && Vh(r, Gc, !1, !1);
  var d = e.rect = Ro(e.rect, r);
  return n && d.applyTransform(n), c === ta.minMargin && Vh(d, Gc, !1, !1), e.axisAligned = cf(n), (e.label = e.label || {}).ignore = t.ignore, Gl(e, !1), Gl(e, !0, Ul), e;
}
var Gc = [0, 0, 0, 0];
function sO(e, t, i) {
  return e.transform = hf(e.transform, i), e.localRect = Ro(e.localRect, t), e.rect = Ro(e.rect, t), i && e.rect.applyTransform(i), e.axisAligned = cf(i), e.obb = void 0, (e.label = e.label || {}).ignore = !1, e;
}
function lO(e, t) {
  if (e) {
    e.label.x += t.x, e.label.y += t.y, e.label.markRedraw();
    var i = e.transform;
    i && (i[4] += t.x, i[5] += t.y);
    var n = e.rect;
    n && (n.x += t.x, n.y += t.y);
    var r = e.obb;
    r && r.fromBoundingRect(e.localRect, i);
  }
}
function Qm(e, t) {
  for (var i = 0; i < Km.length; i++) {
    var n = Km[i];
    e[n] == null && (e[n] = t[n]);
  }
  return bn(e);
}
function Jm(e) {
  var t = e.obb;
  return (!t || k1(e, Ul)) && (e.obb = t = t || new q_(), t.fromBoundingRect(e.localRect, e.transform), Gl(e, !1, Ul)), t;
}
function uO(e) {
  var t = [];
  e.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function i(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var n = 0; n < e.length; n++) {
    var r = bn(e[n]);
    if (!r.label.ignore) {
      for (var a = r.label, o = r.labelLine, s = !1, l = 0; l < t.length; l++)
        if (Df(r, t[l], null, {
          touchThreshold: 0.05
        })) {
          s = !0;
          break;
        }
      s ? (i(a), o && i(o)) : t.push(r);
    }
  }
}
function Df(e, t, i, n) {
  return !e || !t || e.label && e.label.ignore || t.label && t.label.ignore || !e.rect.intersect(t.rect, i, n) ? !1 : e.axisAligned && t.axisAligned ? !0 : Jm(e).intersect(Jm(t), i, n);
}
var cO = null;
function hO() {
  return cO;
}
var dO = "expandAxisBreak", un = Math.PI, fO = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], vO = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], Xl = It(), D1 = It(), pO = (
  /** @class */
  (function() {
    function e(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return e.prototype.ensureRecord = function(t) {
      var i = t.axis.dim, n = t.componentIndex, r = this.recordMap, a = r[i] || (r[i] = []);
      return a[n] || (a[n] = {
        ready: {}
      });
    }, e;
  })()
);
function gO(e, t, i, n) {
  var r = i.axis, a = t.ensureRecord(i), o = [], s, l = Ef(e.axisName) && Yl(e.nameLocation);
  E(n, function(v) {
    var m = bn(v);
    if (!(!m || m.label.ignore)) {
      o.push(m);
      var p = a.transGroup;
      l && (p.transform ? Wo(Ha, p.transform) : Nd(Ha), m.transform && fo(Ha, Ha, m.transform), rt.copy(zs, m.localRect), zs.applyTransform(Ha), s ? s.union(zs) : rt.copy(s = new rt(0, 0, 0, 0), zs));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (o.sort(function(v, m) {
    return Math.abs(v.label[u] - c) - Math.abs(m.label[u] - c);
  }), l && s) {
    var h = r.getExtent(), d = Math.min(h[0], h[1]), f = Math.max(h[0], h[1]) - d;
    s.union(new rt(d, 0, f, 1));
  }
  a.stOccupiedRect = s, a.labelInfoList = o;
}
var Ha = Ti(), zs = new rt(0, 0, 0, 0), mO = function(e, t, i, n, r, a) {
  if (Yl(e.nameLocation)) {
    var o = a.stOccupiedRect;
    o && E1(sO({}, o, a.transGroup.transform), n, r);
  } else
    yO(a.labelInfoList, a.dirVec, n, r);
};
function E1(e, t, i) {
  var n = new Ct();
  Df(e, t, n, {
    direction: Math.atan2(i.y, i.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && lO(t, n);
}
function yO(e, t, i, n) {
  for (var r = Ct.dot(n, t) >= 0, a = 0, o = e.length; a < o; a++) {
    var s = e[r ? a : o - 1 - a];
    s.label.ignore || E1(s, i, n);
  }
}
var pr = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this.group = new oi(), this._axisModel = t, this._api = i, this._local = {}, this._shared = r || new pO(mO), this._resetCfgDetermined(n);
    }
    return e.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var i = this._shared.ensureRecord(this._axisModel).ready;
        J(!i.axisLine && !i.axisTickLabelDetermine), i.axisName = i.axisTickLabelEstimate = !1;
      }
      var n = this._cfg.raw;
      n.position = t.position, n.labelOffset = t.labelOffset, this._resetCfgDetermined(n);
    }, e.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, e.prototype._resetCfgDetermined = function(t) {
      var i = this._axisModel, n = i.getDefaultOption ? i.getDefaultOption() : {}, r = tt(t.axisName, i.get("name")), a = i.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = tt(t.defaultNameMoveOverlap, !0));
      var o = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: tt(t.nameDirection, 1),
        tickDirection: tt(t.tickDirection, 1),
        labelDirection: tt(t.labelDirection, 1),
        labelOffset: tt(t.labelOffset, 0),
        silent: tt(t.silent, !0),
        axisName: r,
        nameLocation: ur(i.get("nameLocation"), n.nameLocation, "end"),
        shouldNameMoveOverlap: Ef(r) && a,
        optionHideOverlap: i.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: i.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (J(o.position != null), J(o.rotation != null)), this._cfg = o;
      var s = new oi({
        x: o.position[0],
        y: o.position[1],
        rotation: o.rotation
      });
      s.updateTransform(), this._transformGroup = s;
      var l = this._shared.ensureRecord(i);
      l.transGroup = this._transformGroup, l.dirVec = new Ct(Math.cos(-o.rotation), Math.sin(-o.rotation));
    }, e.prototype.build = function(t, i) {
      var n = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), E(_O, function(r) {
        t[r] && bO[r](n._cfg, n._local, n._shared, n._axisModel, n.group, n._transformGroup, n._api, i || {});
      }), this;
    }, e.innerTextLayout = function(t, i, n) {
      var r = d_(i - t), a, o;
      return wl(r) ? (o = n > 0 ? "top" : "bottom", a = "center") : wl(r - un) ? (o = n > 0 ? "bottom" : "top", a = "center") : (o = "middle", r > 0 && r < un ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: r,
        textAlign: a,
        textVerticalAlign: o
      };
    }, e.makeAxisEventDataBase = function(t) {
      var i = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return i[t.mainType + "Index"] = t.componentIndex, i;
    }, e.isLabelSilent = function(t) {
      var i = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || i && i.show);
    }, e;
  })()
), _O = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], bO = {
  axisLine: function(e, t, i, n, r, a, o) {
    if (process.env.NODE_ENV !== "production") {
      var s = i.ensureRecord(n).ready;
      J(!s.axisLine), s.axisLine = !0;
    }
    var l = n.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, e.raw.axisLineAutoShow != null && (l = !!e.raw.axisLineAutoShow)), !!l) {
      var u = n.axis.getExtent(), c = a.transform, h = [u[0], 0], d = [u[1], 0], f = h[0] > d[0];
      c && (Be(h, h, c), Be(d, d, c));
      var v = V({
        lineCap: "round"
      }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), m = {
        strokeContainThreshold: e.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: v
      };
      if (n.get(["axisLine", "breakLine"]) && n.axis.scale.hasBreaks())
        hO().buildAxisBreakLine(n, r, a, m);
      else {
        var p = new xa(V({
          shape: {
            x1: h[0],
            y1: h[1],
            x2: d[0],
            y2: d[1]
          }
        }, m));
        sf(p.shape, p.style.lineWidth), p.anid = "line", r.add(p);
      }
      var g = n.get(["axisLine", "symbol"]);
      if (g != null) {
        var y = n.get(["axisLine", "symbolSize"]);
        K(g) && (g = [g, g]), (K(y) || Nt(y)) && (y = [y, y]);
        var _ = HI(n.get(["axisLine", "symbolOffset"]) || 0, y), b = y[0], w = y[1];
        E([{
          rotate: e.rotation + Math.PI / 2,
          offset: _[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: _[1],
          r: Math.sqrt((h[0] - d[0]) * (h[0] - d[0]) + (h[1] - d[1]) * (h[1] - d[1]))
        }], function(S, C) {
          if (g[C] !== "none" && g[C] != null) {
            var T = Zb(g[C], -b / 2, -w / 2, b, w, v.stroke, !0), k = S.r + S.offset, M = f ? d : h;
            T.attr({
              rotation: S.rotate,
              x: M[0] + k * Math.cos(e.rotation),
              y: M[1] - k * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(T);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(e, t, i, n, r, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      J(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = e0(t, r, s);
    u && t0(e, t, i, n, r, a, o, Zm.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(e, t, i, n, r, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = e0(t, r, s);
    u && t0(e, t, i, n, r, a, o, Zm.determine);
    var c = CO(e, r, a, n);
    SO(e, t.labelLayoutList, c), TO(e, r, a, n, e.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(e, t, i, n, r, a, o, s) {
    var l = i.ensureRecord(n);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      J(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (r.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = e.axisName;
    if (Ef(c)) {
      var h = e.nameLocation, d = e.nameDirection, f = n.getModel("nameTextStyle"), v = n.get("nameGap") || 0, m = n.axis.getExtent(), p = n.axis.inverse ? -1 : 1, g = new Ct(0, 0), y = new Ct(0, 0);
      h === "start" ? (g.x = m[0] - p * v, y.x = -p) : h === "end" ? (g.x = m[1] + p * v, y.x = p) : (g.x = (m[0] + m[1]) / 2, g.y = e.labelOffset + d * v, y.y = d);
      var _ = Ti();
      y.transform($d(_, _, e.rotation));
      var b = n.get("nameRotate");
      b != null && (b = b * un / 180);
      var w, S;
      Yl(h) ? w = pr.innerTextLayout(
        e.rotation,
        b ?? e.rotation,
        // Adapt to axis.
        d
      ) : (w = xO(e.rotation, h, b || 0, m), S = e.raw.axisNameAvailableWidth, S != null && (S = Math.abs(S / Math.sin(w.rotation)), !isFinite(S) && (S = null)));
      var C = f.getFont(), T = n.get("nameTruncate", !0) || {}, k = T.ellipsis, M = mn(e.raw.nameTruncateMaxWidth, T.maxWidth, S), D = s.nameMarginLevel || 0, L = new ti({
        x: g.x,
        y: g.y,
        rotation: w.rotation,
        silent: pr.isLabelSilent(n),
        style: yr(f, {
          text: c,
          font: C,
          overflow: "truncate",
          width: M,
          ellipsis: k,
          fill: f.getTextColor() || n.get(["axisLine", "lineStyle", "color"]),
          align: f.get("align") || w.textAlign,
          verticalAlign: f.get("verticalAlign") || w.textVerticalAlign
        }),
        z2: 1
      });
      if (uf({
        el: L,
        componentModel: n,
        itemName: c
      }), L.__fullText = c, L.anid = "name", n.get("triggerEvent")) {
        var P = pr.makeAxisEventDataBase(n);
        P.targetType = "axisName", P.name = c, Lt(L).eventData = P;
      }
      a.add(L), L.updateTransform(), t.nameEl = L;
      var R = l.nameLayout = bn({
        label: L,
        priority: L.z2,
        defaultAttr: {
          ignore: L.ignore
        },
        marginDefault: Yl(h) ? fO[D] : vO[D]
      });
      if (l.nameLocation = h, r.add(L), L.decomposeTransform(), e.shouldNameMoveOverlap && R) {
        var B = i.ensureRecord(n);
        process.env.NODE_ENV !== "production" && J(B.labelInfoList), i.resolveAxisNameOverlap(e, i, n, R, y, B);
      }
    }
  }
};
function t0(e, t, i, n, r, a, o, s) {
  L1(t) || MO(e, t, r, s, n, o);
  var l = t.labelLayoutList;
  kO(e, n, l, a), e.rotation;
  var u = e.optionHideOverlap;
  wO(n, l, u), u && uO(
    // Filter the already ignored labels by the previous overlap resolving methods.
    Re(l, function(c) {
      return c && !c.label.ignore;
    })
  ), gO(e, i, n, l);
}
function xO(e, t, i, n) {
  var r = d_(i - e), a, o, s = n[0] > n[1], l = t === "start" && !s || t !== "start" && s;
  return wl(r - un / 2) ? (o = l ? "bottom" : "top", a = "center") : wl(r - un * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", r < un * 1.5 && r > un / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: r,
    textAlign: a,
    textVerticalAlign: o
  };
}
function wO(e, t, i) {
  if (iO(e.axis))
    return;
  function n(s, l, u) {
    var c = bn(t[l]), h = bn(t[u]);
    if (!(!c || !h)) {
      if (s === !1 || c.suggestIgnore) {
        ao(c.label);
        return;
      }
      if (h.suggestIgnore) {
        ao(h.label);
        return;
      }
      var d = 0.1;
      if (!i) {
        var f = [0, 0, 0, 0];
        c = Qm({
          marginForce: f
        }, c), h = Qm({
          marginForce: f
        }, h);
      }
      Df(c, h, null, {
        touchThreshold: d
      }) && ao(s ? h.label : c.label);
    }
  }
  var r = e.get(["axisLabel", "showMinLabel"]), a = e.get(["axisLabel", "showMaxLabel"]), o = t.length;
  n(r, 0, 1), n(a, o - 1, o - 2);
}
function SO(e, t, i) {
  e.showMinorTicks || E(t, function(n) {
    if (n && n.label.ignore)
      for (var r = 0; r < i.length; r++) {
        var a = i[r], o = D1(a), s = Xl(n.label);
        if (o.tickValue != null && !o.onBand && o.tickValue === s.tickValue) {
          ao(a);
          return;
        }
      }
  });
}
function ao(e) {
  e && (e.ignore = !0);
}
function A1(e, t, i, n, r) {
  for (var a = [], o = [], s = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = i, t && (Be(o, o, t), Be(s, s, t));
    var c = new xa({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    sf(c.shape, c.style.lineWidth), c.anid = r + "_" + e[l].tickValue, a.push(c);
    var h = D1(c);
    h.onBand = !!e[l].onBand, h.tickValue = e[l].tickValue;
  }
  return a;
}
function CO(e, t, i, n) {
  var r = n.axis, a = n.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && (o = !0, e.raw.axisTickAutoShow != null && (o = !!e.raw.axisTickAutoShow)), !o || r.scale.isBlank())
    return [];
  for (var s = a.getModel("lineStyle"), l = e.tickDirection * a.get("length"), u = r.getTicksCoords(), c = A1(u, i.transform, l, zt(s.getLineStyle(), {
    stroke: n.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), h = 0; h < c.length; h++)
    t.add(c[h]);
  return c;
}
function TO(e, t, i, n, r) {
  var a = n.axis, o = n.getModel("minorTick");
  if (!(!e.showMinorTicks || a.scale.isBlank())) {
    var s = a.getMinorTicksCoords();
    if (s.length)
      for (var l = o.getModel("lineStyle"), u = r * o.get("length"), c = zt(l.getLineStyle(), zt(n.getModel("axisTick").getLineStyle(), {
        stroke: n.get(["axisLine", "lineStyle", "color"])
      })), h = 0; h < s.length; h++)
        for (var d = A1(s[h], i.transform, u, c, "minorticks_" + h), f = 0; f < d.length; f++)
          t.add(d[f]);
  }
}
function e0(e, t, i) {
  if (L1(e)) {
    var n = e.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && J(e.labelGroup && n);
    var r = n.out.noPxChangeTryDetermine;
    if (i.noPxChange) {
      for (var a = !0, o = 0; o < r.length; o++)
        a = a && r[o]();
      if (a)
        return !1;
    }
    r.length && (t.remove(e.labelGroup), od(e, null, null, null));
  }
  return !0;
}
function MO(e, t, i, n, r, a) {
  var o = r.axis, s = mn(e.raw.axisLabelShow, r.get(["axisLabel", "show"])), l = new oi();
  i.add(l);
  var u = rO(n);
  if (!s || o.scale.isBlank()) {
    od(t, [], l, u);
    return;
  }
  var c = r.getModel("axisLabel"), h = o.getViewLabels(u), d = (mn(e.raw.labelRotate, c.get("rotate")) || 0) * un / 180, f = pr.innerTextLayout(e.rotation, d, e.labelDirection), v = r.getCategories && r.getCategories(!0), m = [], p = r.get("triggerEvent"), g = 1 / 0, y = -1 / 0;
  E(h, function(b, w) {
    var S, C = o.scale.type === "ordinal" ? o.scale.getRawOrdinalNumber(b.tickValue) : b.tickValue, T = b.formattedLabel, k = b.rawLabel, M = c;
    if (v && v[C]) {
      var D = v[C];
      Z(D) && D.textStyle && (M = new Ot(D.textStyle, c, r.ecModel));
    }
    var L = M.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), P = M.getShallow("align", !0) || f.textAlign, R = tt(M.getShallow("alignMinLabel", !0), P), B = tt(M.getShallow("alignMaxLabel", !0), P), F = M.getShallow("verticalAlign", !0) || M.getShallow("baseline", !0) || f.textVerticalAlign, W = tt(M.getShallow("verticalAlignMinLabel", !0), F), z = tt(M.getShallow("verticalAlignMaxLabel", !0), F), N = 10 + (((S = b.time) === null || S === void 0 ? void 0 : S.level) || 0);
    g = Math.min(g, N), y = Math.max(y, N);
    var $ = new ti({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: pr.isLabelSilent(r),
      z2: N,
      style: yr(M, {
        text: T,
        align: w === 0 ? R : w === h.length - 1 ? B : P,
        verticalAlign: w === 0 ? W : w === h.length - 1 ? z : F,
        fill: ht(L) ? L(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          o.type === "category" ? k : o.type === "value" ? C + "" : C,
          w
        ) : L
      })
    });
    $.anid = "label_" + C;
    var X = Xl($);
    if (X.break = b.break, X.tickValue = C, X.layoutRotation = f.rotation, uf({
      el: $,
      componentModel: r,
      itemName: T,
      formatterParamsExtra: {
        isTruncated: function() {
          return $.isTruncated;
        },
        value: k,
        tickIndex: w
      }
    }), p) {
      var U = pr.makeAxisEventDataBase(r);
      U.targetType = "axisLabel", U.value = k, U.tickIndex = w, b.break && (U.break = {
        // type: labelItem.break.type,
        start: b.break.parsedBreak.vmin,
        end: b.break.parsedBreak.vmax
      }), o.type === "category" && (U.dataIndex = C), Lt($).eventData = U, b.break && EO(r, a, $, b.break);
    }
    m.push($), l.add($);
  });
  var _ = dt(m, function(b) {
    return {
      label: b,
      priority: Xl(b).break ? b.z2 + (y - g + 1) : b.z2,
      defaultAttr: {
        ignore: b.ignore
      }
    };
  });
  od(t, _, l, u);
}
function L1(e) {
  return !!e.labelLayoutList;
}
function od(e, t, i, n) {
  e.labelLayoutList = t, e.labelGroup = i, e.axisLabelsCreationContext = n;
}
function kO(e, t, i, n) {
  var r = t.get(["axisLabel", "margin"]);
  E(i, function(a, o) {
    var s = bn(a);
    if (s) {
      var l = s.label, u = Xl(l);
      s.suggestIgnore = l.ignore, l.ignore = !1, Ah(Ri, DO), Ri.x = t.axis.dataToCoord(u.tickValue), Ri.y = e.labelOffset + e.labelDirection * r, Ri.rotation = u.layoutRotation, n.add(Ri), Ri.updateTransform(), n.remove(Ri), Ri.decomposeTransform(), Ah(l, Ri), l.markRedraw(), Gl(s, !0), bn(s);
    }
  });
}
var Ri = new he(), DO = new he();
function Ef(e) {
  return !!e;
}
function EO(e, t, i, n) {
  i.on("click", function(r) {
    var a = {
      type: dO,
      breaks: [{
        start: n.parsedBreak.breakOption.start,
        end: n.parsedBreak.breakOption.end
      }]
    };
    a[e.axis.dim + "AxisIndex"] = e.componentIndex, t.dispatchAction(a);
  });
}
function i0(e, t, i) {
  i = i || {};
  var n = t.axis, r = {}, a = n.getAxesOnZeroOf()[0], o = n.position, s = a ? "onZero" : o, l = n.dim, u = [e.x, e.x + e.width, e.y, e.y + e.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, h = t.get("offset") || 0, d = l === "x" ? [u[2] - h, u[3] + h] : [u[0] - h, u[1] + h];
  if (a) {
    var f = a.toGlobalCoord(a.dataToCoord(0));
    d[c.onZero] = Math.max(Math.min(f, d[1]), d[0]);
  }
  r.position = [l === "y" ? d[c[s]] : u[0], l === "x" ? d[c[s]] : u[3]], r.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  r.labelDirection = r.tickDirection = r.nameDirection = v[o], r.labelOffset = a ? d[c[o]] - d[c.onZero] : 0, t.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), mn(i.labelInside, t.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
  var m = t.get(["axisLabel", "rotate"]);
  return r.labelRotate = s === "top" ? -m : m, r.z2 = 1, r;
}
function AO(e, t) {
  var i = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return LO(i, e, t), i.seriesInvolved && IO(i, e), i;
}
function LO(e, t, i) {
  var n = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", !0) || [], o = [];
  E(i.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = zo(s.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = s;
    var c = s.model, h = c.getModel("tooltip", n);
    if (E(s.getAxes(), me(m, !1, null)), s.getTooltipAxes && n && h.get("show")) {
      var d = h.get("trigger") === "axis", f = h.get(["axisPointer", "type"]) === "cross", v = s.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (d || f) && E(v.baseAxes, me(m, f ? "cross" : !0, d)), f && E(v.otherAxes, me(m, "cross", !1));
    }
    function m(p, g, y) {
      var _ = y.model.getModel("axisPointer", r), b = _.get("show");
      if (!(!b || b === "auto" && !p && !sd(_))) {
        g == null && (g = _.get("triggerTooltip")), _ = p ? PO(y, h, r, t, p, g) : _;
        var w = _.get("snap"), S = _.get("triggerEmphasis"), C = zo(y.model), T = g || w || y.type === "category", k = e.axesInfo[C] = {
          key: C,
          axis: y,
          coordSys: s,
          axisPointerModel: _,
          triggerTooltip: g,
          triggerEmphasis: S,
          involveSeries: T,
          snap: w,
          useHandle: sd(_),
          seriesModels: [],
          linkGroup: null
        };
        u[C] = k, e.seriesInvolved = e.seriesInvolved || T;
        var M = RO(a, y);
        if (M != null) {
          var D = o[M] || (o[M] = {
            axesInfo: {}
          });
          D.axesInfo[C] = k, D.mapper = a[M].mapper, k.linkGroup = D;
        }
      }
    }
  });
}
function PO(e, t, i, n, r, a) {
  var o = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  E(s, function(d) {
    l[d] = ct(o.get(d));
  }), l.snap = e.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), r === "cross") {
    var c = o.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var h = l.lineStyle = o.get("crossStyle");
      h && zt(u, h.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new Ot(l, i, n));
}
function IO(e, t) {
  t.eachSeries(function(i) {
    var n = i.coordinateSystem, r = i.get(["tooltip", "trigger"], !0), a = i.get(["tooltip", "show"], !0);
    !n || !n.model || r === "none" || r === !1 || r === "item" || a === !1 || i.get(["axisPointer", "show"], !0) === !1 || E(e.coordSysAxesInfo[zo(n.model)], function(o) {
      var s = o.axis;
      n.getAxis(s.dim) === s && (o.seriesModels.push(i), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += i.getData().count());
    });
  });
}
function RO(e, t) {
  for (var i = t.model, n = t.dim, r = 0; r < e.length; r++) {
    var a = e[r] || {};
    if (Xc(a[n + "AxisId"], i.id) || Xc(a[n + "AxisIndex"], i.componentIndex) || Xc(a[n + "AxisName"], i.name))
      return r;
  }
}
function Xc(e, t) {
  return e === "all" || j(e) && Pt(e, t) >= 0 || e === t;
}
function OO(e) {
  var t = Af(e);
  if (t) {
    var i = t.axisPointerModel, n = t.axis.scale, r = i.option, a = i.get("status"), o = i.get("value");
    o != null && (o = n.parse(o));
    var s = sd(i);
    a == null && (r.status = s ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function Af(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[zo(e)];
}
function BO(e) {
  var t = Af(e);
  return t && t.axisPointerModel;
}
function sd(e) {
  return !!e.get(["handle", "show"]);
}
function zo(e) {
  return e.type + "||" + e.id;
}
var jc = {}, NO = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r, a) {
      this.axisPointerClass && OO(i), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(i, r, !0);
    }, t.prototype.updateAxisPointer = function(i, n, r, a) {
      this._doUpdateAxisPointerClass(i, r, !1);
    }, t.prototype.remove = function(i, n) {
      var r = this._axisPointer;
      r && r.remove(n);
    }, t.prototype.dispose = function(i, n) {
      this._disposeAxisPointer(n), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(i, n, r) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = BO(i);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(i, o, n, r) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(i) {
      this._axisPointer && this._axisPointer.dispose(i), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(i, n) {
      if (process.env.NODE_ENV !== "production" && jc[i])
        throw new Error("axisPointer " + i + " exists");
      jc[i] = n;
    }, t.getAxisPointerClass = function(i) {
      return i && jc[i];
    }, t.type = "axis", t;
  })(Xi)
), Jn = It(), n0 = ct, qc = mt, FO = (
  /** @class */
  (function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, i, n, r) {
      var a = i.get("value"), o = i.get("status");
      if (this._axisModel = t, this._axisPointerModel = i, this._api = n, !(!r && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, i, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(t, i);
        if (!s)
          s = this._group = new oi(), this.createPointerEl(s, u, t, i), this.createLabelEl(s, u, t, i), n.getZr().add(s);
        else {
          var d = me(r0, i, h);
          this.updatePointerEl(s, u, d), this.updateLabelEl(s, u, d, i);
        }
        o0(s, i, !0), this._renderHandle(a);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, i) {
      var n = i.get("animation"), r = t.axis, a = r.type === "category", o = i.get("snap");
      if (!o && !a)
        return !1;
      if (n === "auto" || n == null) {
        var s = this.animationThreshold;
        if (a && r.getBandWidth() > s)
          return !0;
        if (o) {
          var l = Af(t).seriesDataCount, u = r.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return n === !0;
    }, e.prototype.makeElOption = function(t, i, n, r, a) {
    }, e.prototype.createPointerEl = function(t, i, n, r) {
      var a = i.pointer;
      if (a) {
        var o = Jn(t).pointerEl = new nP[a.type](n0(i.pointer));
        t.add(o);
      }
    }, e.prototype.createLabelEl = function(t, i, n, r) {
      if (i.label) {
        var a = Jn(t).labelEl = new ti(n0(i.label));
        t.add(a), a0(a, r);
      }
    }, e.prototype.updatePointerEl = function(t, i, n) {
      var r = Jn(t).pointerEl;
      r && i.pointer && (r.setStyle(i.pointer.style), n(r, {
        shape: i.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, i, n, r) {
      var a = Jn(t).labelEl;
      a && (a.setStyle(i.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: i.label.x,
        y: i.label.y
      }), a0(a, r));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var i = this._axisPointerModel, n = this._api.getZr(), r = this._handle, a = i.getModel("handle"), o = i.get("status");
        if (!a.get("show") || !o || o === "hide") {
          r && n.remove(r), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, r = this._handle = eb(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            vl(u.event);
          },
          onmousedown: qc(this._onHandleDragMove, this, 0, 0),
          drift: qc(this._onHandleDragMove, this),
          ondragend: qc(this._onHandleDragEnd, this)
        }), n.add(r)), o0(r, i, !1), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        j(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, Hb(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
      }
    }, e.prototype._moveHandleToValue = function(t, i) {
      r0(this._axisPointerModel, !i && this._moveAnimation, this._handle, Zc(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, i) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var r = this.updateHandleTransform(Zc(n), [t, i], this._axisModel, this._axisPointerModel);
        this._payloadInfo = r, n.stopAnimation(), n.attr(Zc(r)), Jn(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var i = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: i.cursorPoint[0],
          y: i.cursorPoint[1],
          tooltipOption: i.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var i = this._axisPointerModel.get("value");
        this._moveHandleToValue(i), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var i = t.getZr(), n = this._group, r = this._handle;
      i && n && (this._lastGraphicKey = null, n && i.remove(n), r && i.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), Zh(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, i, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: i[n],
        height: i[1 - n]
      };
    }, e;
  })()
);
function r0(e, t, i, n) {
  P1(Jn(i).lastProp, n) || (Jn(i).lastProp = n, t ? af(i, n, e) : (i.stopAnimation(), i.attr(n)));
}
function P1(e, t) {
  if (Z(e) && Z(t)) {
    var i = !0;
    return E(t, function(n, r) {
      i = i && P1(e[r], n);
    }), !!i;
  } else
    return e === t;
}
function a0(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function Zc(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function o0(e, t, i) {
  var n = t.get("z"), r = t.get("zlevel");
  e && e.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), r != null && (a.zlevel = r), a.silent = i);
  });
}
function $O(e) {
  var t = e.get("type"), i = e.getModel(t + "Style"), n;
  return t === "line" ? (n = i.getLineStyle(), n.fill = null) : t === "shadow" && (n = i.getAreaStyle(), n.stroke = null), n;
}
function zO(e, t, i, n, r) {
  var a = i.get("value"), o = I1(a, t.axis, t.ecModel, i.get("seriesDataIndices"), {
    precision: i.get(["label", "precision"]),
    formatter: i.get(["label", "formatter"])
  }), s = i.getModel("label"), l = vf(s.get("padding") || 0), u = s.getFont(), c = aE(o, u), h = r.position, d = c.width + l[1] + l[3], f = c.height + l[0] + l[2], v = r.align;
  v === "right" && (h[0] -= d), v === "center" && (h[0] -= d / 2);
  var m = r.verticalAlign;
  m === "bottom" && (h[1] -= f), m === "middle" && (h[1] -= f / 2), VO(h, d, f, n);
  var p = s.get("backgroundColor");
  (!p || p === "auto") && (p = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: yr(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: p
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function VO(e, t, i, n) {
  var r = n.getWidth(), a = n.getHeight();
  e[0] = Math.min(e[0] + t, r) - t, e[1] = Math.min(e[1] + i, a) - i, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function I1(e, t, i, n, r) {
  e = t.scale.parse(e);
  var a = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: r.precision
  }), o = r.formatter;
  if (o) {
    var s = {
      value: T1(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    E(n, function(l) {
      var u = i.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && s.seriesData.push(h);
    }), K(o) ? a = o.replace("{value}", a) : ht(o) && (a = o(s));
  }
  return a;
}
function R1(e, t, i) {
  var n = Ti();
  return $d(n, n, i.rotation), mh(n, n, i.position), lf([e.dataToCoord(t), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
}
function HO(e, t, i, n, r, a) {
  var o = pr.innerTextLayout(i.rotation, 0, i.labelDirection);
  i.labelMargin = r.get(["label", "margin"]), zO(t, n, r, a, {
    position: R1(n.axis, e, i),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function WO(e, t, i) {
  return i = i || 0, {
    x1: e[i],
    y1: e[1 - i],
    x2: t[i],
    y2: t[1 - i]
  };
}
function YO(e, t, i) {
  return i = i || 0, {
    x: e[i],
    y: e[1 - i],
    width: t[i],
    height: t[1 - i]
  };
}
var UO = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(i, n, r, a, o) {
      var s = r.axis, l = s.grid, u = a.get("type"), c = s0(l, s).getOtherAxis(s).getGlobalExtent(), h = s.toGlobalCoord(s.dataToCoord(n, !0));
      if (u && u !== "none") {
        var d = $O(a), f = GO[u](s, h, c);
        f.style = d, i.graphicKey = f.type, i.pointer = f;
      }
      var v = i0(l.getRect(), r);
      HO(n, i, v, r, a, o);
    }, t.prototype.getHandleTransform = function(i, n, r) {
      var a = i0(n.axis.grid.getRect(), n, {
        labelInside: !1
      });
      a.labelMargin = r.get(["handle", "margin"]);
      var o = R1(n.axis, i, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(i, n, r, a) {
      var o = r.axis, s = o.grid, l = o.getGlobalExtent(!0), u = s0(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, h = [i.x, i.y];
      h[c] += n[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var d = (u[1] + u[0]) / 2, f = [d, d];
      f[c] = h[c];
      var v = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: i.rotation,
        cursorPoint: f,
        tooltipOption: v[c]
      };
    }, t;
  })(FO)
);
function s0(e, t) {
  var i = {};
  return i[t.dim + "AxisIndex"] = t.index, e.getCartesian(i);
}
var GO = {
  line: function(e, t, i) {
    var n = WO([t, i[0]], [t, i[1]], l0(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, i) {
    var n = Math.max(1, e.getBandWidth()), r = i[1] - i[0];
    return {
      type: "Rect",
      shape: YO([t - n / 2, i[0]], [n, r], l0(e))
    };
  }
};
function l0(e) {
  return e.dim === "x" ? 0 : 1;
}
var XO = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: vt.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: vt.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: vt.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: vt.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: vt.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  })(wt)
), Hi = It(), jO = E;
function O1(e, t, i) {
  if (!nt.node) {
    var n = t.getZr();
    Hi(n).records || (Hi(n).records = {}), qO(n, t);
    var r = Hi(n).records[e] || (Hi(n).records[e] = {});
    r.handler = i;
  }
}
function qO(e, t) {
  if (Hi(e).initialized)
    return;
  Hi(e).initialized = !0, i("click", me(u0, "click")), i("mousemove", me(u0, "mousemove")), i("globalout", KO);
  function i(n, r) {
    e.on(n, function(a) {
      var o = QO(t);
      jO(Hi(e).records, function(s) {
        s && r(s, a, o.dispatchAction);
      }), ZO(o.pendings, t);
    });
  }
}
function ZO(e, t) {
  var i = e.showTip.length, n = e.hideTip.length, r;
  i ? r = e.showTip[i - 1] : n && (r = e.hideTip[n - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
}
function KO(e, t, i) {
  e.handler("leave", null, i);
}
function u0(e, t, i, n) {
  t.handler(e, i, n);
}
function QO(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, i = function(n) {
    var r = t[n.type];
    r ? r.push(n) : (n.dispatchAction = i, e.dispatchAction(n));
  };
  return {
    dispatchAction: i,
    pendings: t
  };
}
function ld(e, t) {
  if (!nt.node) {
    var i = t.getZr(), n = (Hi(i).records || {})[e];
    n && (Hi(i).records[e] = null);
  }
}
var JO = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      var a = n.getComponent("tooltip"), o = i.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      O1("axisPointer", r, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(i, n) {
      ld("axisPointer", n);
    }, t.prototype.dispose = function(i, n) {
      ld("axisPointer", n);
    }, t.type = "axisPointer", t;
  })(Xi)
);
function B1(e, t) {
  var i = [], n = e.seriesIndex, r;
  if (n == null || !(r = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = r.getData(), o = Uo(a, e);
  if (o == null || o < 0 || j(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = r.coordinateSystem;
  if (r.getTooltipPosition)
    i = r.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, d = u.dim, f = h === "x" || h === "radius" ? 1 : 0, v = a.mapDimension(d), m = [];
      m[f] = a.get(v, o), m[1 - f] = a.get(a.getCalculationInfo("stackResultDimension"), o), i = l.dataToPoint(m) || [];
    } else
      i = l.dataToPoint(a.getValues(dt(l.dimensions, function(g) {
        return a.mapDimension(g);
      }), o)) || [];
  else if (s) {
    var p = s.getBoundingRect().clone();
    p.applyTransform(s.transform), i = [p.x + p.width / 2, p.y + p.height / 2];
  }
  return {
    point: i,
    el: s
  };
}
var c0 = It();
function tB(e, t, i) {
  var n = e.currTrigger, r = [e.x, e.y], a = e, o = e.dispatchAction || mt(i.dispatchAction, i), s = t.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    il(r) && (r = B1({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = il(r), u = a.axesInfo, c = s.axesInfo, h = n === "leave" || il(r), d = {}, f = {}, v = {
      list: [],
      map: {}
    }, m = {
      showPointer: me(iB, f),
      showTooltip: me(nB, v)
    };
    E(s.coordSysMap, function(g, y) {
      var _ = l || g.containPoint(r);
      E(s.coordSysAxesInfo[y], function(b, w) {
        var S = b.axis, C = sB(u, b);
        if (!h && _ && (!u || C)) {
          var T = C && C.value;
          T == null && !l && (T = S.pointToData(r)), T != null && h0(b, T, m, !1, d);
        }
      });
    });
    var p = {};
    return E(c, function(g, y) {
      var _ = g.linkGroup;
      _ && !f[y] && E(_.axesInfo, function(b, w) {
        var S = f[w];
        if (b !== g && S) {
          var C = S.value;
          _.mapper && (C = g.axis.scale.parse(_.mapper(C, d0(b), d0(g)))), p[g.key] = C;
        }
      });
    }), E(p, function(g, y) {
      h0(c[y], g, m, !0, d);
    }), rB(f, c, d), aB(v, r, e, o), oB(c, o, i), d;
  }
}
function h0(e, t, i, n, r) {
  var a = e.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!e.involveSeries) {
      i.showPointer(e, t);
      return;
    }
    var o = eB(t, e), s = o.payloadBatch, l = o.snapToValue;
    s[0] && r.seriesIndex == null && V(r, s[0]), !n && e.snap && a.containData(l) && l != null && (t = l), i.showPointer(e, t, s), i.showTooltip(e, o, l);
  }
}
function eB(e, t) {
  var i = t.axis, n = i.dim, r = e, a = [], o = Number.MAX_VALUE, s = -1;
  return E(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), h, d;
    if (l.getAxisTooltipData) {
      var f = l.getAxisTooltipData(c, e, i);
      d = f.dataIndices, h = f.nestestValue;
    } else {
      if (d = l.indicesOfNearest(
        n,
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        i.type === "category" ? 0.5 : null
      ), !d.length)
        return;
      h = l.getData().get(c[0], d[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var v = e - h, m = Math.abs(v);
      m <= o && ((m < o || v >= 0 && s < 0) && (o = m, s = v, r = h, a.length = 0), E(d, function(p) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: p,
          dataIndex: l.getData().getRawIndex(p)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: r
  };
}
function iB(e, t, i, n) {
  e[t.key] = {
    value: i,
    payloadBatch: n
  };
}
function nB(e, t, i, n) {
  var r = i.payloadBatch, a = t.axis, o = a.model, s = t.axisPointerModel;
  if (!(!t.triggerTooltip || !r.length)) {
    var l = t.coordSys.model, u = zo(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: r.slice()
    });
  }
}
function rB(e, t, i) {
  var n = i.axesInfo = [];
  E(t, function(r, a) {
    var o = r.axisPointerModel.option, s = e[a];
    s ? (!r.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !r.useHandle && (o.status = "hide"), o.status === "show" && n.push({
      axisDim: r.axis.dim,
      axisIndex: r.axis.model.componentIndex,
      value: o.value
    });
  });
}
function aB(e, t, i, n) {
  if (il(t) || !e.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var r = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: i.tooltipOption,
    position: i.position,
    dataIndexInside: r.dataIndexInside,
    dataIndex: r.dataIndex,
    seriesIndex: r.seriesIndex,
    dataByCoordSys: e.list
  });
}
function oB(e, t, i) {
  var n = i.getZr(), r = "axisPointerLastHighlights", a = c0(n)[r] || {}, o = c0(n)[r] = {};
  E(e, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && E(h.seriesDataIndices, function(d) {
      var f = d.seriesIndex + " | " + d.dataIndex;
      o[f] = d;
    });
  });
  var s = [], l = [];
  E(a, function(u, c) {
    !o[c] && l.push(u);
  }), E(o, function(u, c) {
    !a[c] && s.push(u);
  }), l.length && i.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && i.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function sB(e, t) {
  for (var i = 0; i < (e || []).length; i++) {
    var n = e[i];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function d0(e) {
  var t = e.axis.model, i = {}, n = i.axisDim = e.axis.dim;
  return i.axisIndex = i[n + "AxisIndex"] = t.componentIndex, i.axisName = i[n + "AxisName"] = t.name, i.axisId = i[n + "AxisId"] = t.id, i;
}
function il(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function lB(e) {
  NO.registerAxisPointerClass("CartesianAxisPointer", UO), e.registerComponentModel(XO), e.registerComponentView(JO), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var i = t.axisPointer.link;
      i && !j(i) && (t.axisPointer.link = [i]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, i) {
    t.getComponent("axisPointer").coordSysAxesInfo = AO(t, i);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, tB);
}
function uB(e, t, i) {
  var n = e.target;
  n.x += t, n.y += i, n.dirty();
}
function cB(e, t, i, n) {
  var r = e.target, a = e.zoomLimit, o = e.zoom = e.zoom || 1;
  o *= t, o = Lf(o, a);
  var s = o / e.zoom;
  e.zoom = o, N1(r, i, n, s), r.dirty();
}
function hB(e, t, i, n, r, a) {
  var o = new rt(0, 0, 0, 0);
  n.enable(e.get("roam"), {
    api: t,
    zInfo: {
      component: e
    },
    triggerInfo: {
      roamTrigger: e.get("roamTrigger"),
      isInSelf: function(u, c, h) {
        return o.copy(i.getBoundingRect()), o.applyTransform(i.getComputedTransform()), o.contain(c, h);
      },
      isInClip: function(u, c, h) {
        return !0;
      }
    }
  }), r.zoomLimit = e.get("scaleLimit");
  var s = e.coordinateSystem;
  r.zoom = s ? s.getZoom() : 1;
  var l = e.subType + "Roam";
  n.off("pan").off("zoom").on("pan", function(u) {
    uB(r, u.dx, u.dy), t.dispatchAction({
      seriesId: e.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    cB(r, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: e.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function f0(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function dB(e, t, i) {
  var n = e.getZoom(), r = e.getCenter(), a = t.zoom, o = e.projectedToPoint ? e.projectedToPoint(r) : e.dataToPoint(r);
  return t.dx != null && t.dy != null && (o[0] -= t.dx, o[1] -= t.dy, e.setCenter(f0(e, o))), a != null && (a = Lf(n * a, i) / n, N1(e, t.originX, t.originY, a), e.updateTransform(), e.setCenter(f0(e, o)), e.setZoom(a * n)), {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
function N1(e, t, i, n) {
  e.x -= (t - e.x) * (n - 1), e.y -= (i - e.y) * (n - 1), e.scaleX *= n, e.scaleY *= n;
}
function Lf(e, t) {
  if (t) {
    var i = t.min || 0, n = t.max || 1 / 0;
    e = Math.max(Math.min(n, e), i);
  }
  return e;
}
var v0 = Be, fB = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t(i, n) {
      var r = e.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new ir(), r._rawTransformable = new ir(), r.name = i, r._opt = n, r;
    }
    return t.prototype.setBoundingRect = function(i, n, r, a) {
      return this._rect = new rt(i, n, r, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(i, n, r, a) {
      this._transformTo(i, n, r, a), this._viewRect = new rt(i, n, r, a);
    }, t.prototype._transformTo = function(i, n, r, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new rt(i, n, r, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(i) {
      var n = this._opt;
      n && n.api && n.ecModel && n.ecModel.getShallow("legacyViewCoordSysCenterBase") && i && (i = [Me(i[0], n.api.getWidth()), Me(i[1], n.api.getWidth())]), this._centerOption = ct(i), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(i) {
      this._zoom = Lf(i || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var i = this.getBoundingRect(), n = i.x + i.width / 2, r = i.y + i.height / 2;
      return [n, r];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var i = this._centerOption, n = this._rect;
      i && n && (this._center = [Me(i[0], n.width, n.x), Me(i[1], n.height, n.y)]);
      var r = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, o = this.getDefaultCenter(), s = this.getCenter(), l = this.getZoom();
      s = Be([], s, r), o = Be([], o, r), a.originX = s[0], a.originY = s[1], a.x = o[0] - s[0], a.y = o[1] - s[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var i = this._roamTransformable, n = this._rawTransformable;
      n.parent = i, i.updateTransform(), n.updateTransform(), Fd(this.transform || (this.transform = []), n.transform || Ti()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Wo(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var i = this._rawTransformable, n = this._roamTransformable, r = new ir();
      return r.transform = n.transform, r.decomposeTransform(), {
        roam: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        },
        raw: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var i = this.getBoundingRect().clone();
      return i.applyTransform(this.transform), i;
    }, t.prototype.dataToPoint = function(i, n, r) {
      var a = n ? this._rawTransform : this.transform;
      return r = r || [], a ? v0(r, i, a) : qk(r, i);
    }, t.prototype.pointToData = function(i, n, r) {
      r = r || [];
      var a = this.invTransform;
      return a ? v0(r, i, a) : (r[0] = i[0], r[1] = i[1], r);
    }, t.prototype.convertToPixel = function(i, n, r) {
      var a = p0(n);
      return a === this ? a.dataToPoint(r) : null;
    }, t.prototype.convertFromPixel = function(i, n, r) {
      var a = p0(n);
      return a === this ? a.pointToData(r) : null;
    }, t.prototype.containPoint = function(i) {
      return this.getViewRectAfterRoam().contain(i[0], i[1]);
    }, t.dimensions = ["x", "y"], t;
  })(ir)
);
function p0(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var vB = It();
function g0(e, t) {
  return !!vB(e)[t];
}
Cr({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, ce);
var pB = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function gB(e, t, i) {
  var n = t.getComponentByElement(e.topTarget);
  if (!n || n === i || pB.hasOwnProperty(n.mainType))
    return !1;
  var r = n.coordinateSystem;
  if (!r || r.model === i)
    return !1;
  var a = Oo(n), o = Oo(i);
  return !((a.zlevel - o.zlevel || a.z - o.z) <= 0);
}
var mB = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t(i) {
      var n = e.call(this) || this;
      n._zr = i;
      var r = mt(n._mousedownHandler, n), a = mt(n._mousemoveHandler, n), o = mt(n._mouseupHandler, n), s = mt(n._mousewheelHandler, n), l = mt(n._pinchHandler, n);
      return n.enable = function(u, c) {
        var h = c.zInfo, d = Oo(h.component), f = d.z, v = d.zlevel, m = {
          component: h.component,
          z: f,
          zlevel: v,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: tt(h.z2, -1 / 0)
        }, p = V({}, c.triggerInfo);
        this._opt = zt(V({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: m,
          triggerInfo: p
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && (Ya(i, "mousedown", r, m), Ya(i, "mousemove", a, m), Ya(i, "mouseup", o, m)), (u === !0 || u === "scale" || u === "zoom") && (Ya(i, "mousewheel", s, m), Ya(i, "pinch", l, m)));
      }, n.disable = function() {
        this._enabled = !1, Ua(i, "mousedown", r), Ua(i, "mousemove", a), Ua(i, "mouseup", o), Ua(i, "mousewheel", s), Ua(i, "pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(i, n, r) {
      var a = this._opt, o = a.zInfoParsed;
      if (gB(i, a.api, o.component))
        return !1;
      var s = a.triggerInfo, l = s.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = s.isInSelf(i, n, r)), u && s.isInClip && !s.isInClip(i, n, r) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(i, n, r, a) {
      var o = i.target;
      if (!o && this._checkPointer(i, n, r))
        return "grab";
      if (a)
        return o && o.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(i) {
      if (!(fp(i) || Wa(i))) {
        for (var n = i.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var r = i.offsetX, a = i.offsetY;
        this._checkPointer(i, r, a) && (this._x = r, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(i) {
      var n = this._zr;
      if (!(i.gestureEvent === "pinch" || g0(n, "globalPan") || Wa(i))) {
        var r = i.offsetX, a = i.offsetY;
        if (!this._dragging || !nl("moveOnMouseMove", i, this._opt)) {
          var o = this._decideCursorStyle(i, r, a, !1);
          o && n.setCursorStyle(o);
          return;
        }
        n.setCursorStyle("grabbing");
        var s = this._x, l = this._y, u = r - s, c = a - l;
        this._x = r, this._y = a, this._opt.preventDefaultMouseMove && vl(i.event), i.__ecRoamConsumed = !0, m0(this, "pan", "moveOnMouseMove", i, {
          dx: u,
          dy: c,
          oldX: s,
          oldY: l,
          newX: r,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(i) {
      if (!Wa(i)) {
        var n = this._zr;
        if (!fp(i)) {
          this._dragging = !1;
          var r = this._decideCursorStyle(i, i.offsetX, i.offsetY, !0);
          r && n.setCursorStyle(r);
        }
      }
    }, t.prototype._mousewheelHandler = function(i) {
      if (!Wa(i)) {
        var n = nl("zoomOnMouseWheel", i, this._opt), r = nl("moveOnMouseWheel", i, this._opt), a = i.wheelDelta, o = Math.abs(a), s = i.offsetX, l = i.offsetY;
        if (!(a === 0 || !n && !r)) {
          if (n) {
            var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", i, {
              scale: c,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (r) {
            var h = Math.abs(a), d = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", i, {
              scrollDelta: d,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(i) {
      if (!(g0(this._zr, "globalPan") || Wa(i))) {
        var n = i.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, i, {
          scale: n,
          originX: i.pinchX,
          originY: i.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(i, n, r, a, o) {
      i._checkPointer(a, o.originX, o.originY) && (vl(a.event), a.__ecRoamConsumed = !0, m0(i, n, r, a, o));
    }, t;
  })(li)
);
function Wa(e) {
  return e.__ecRoamConsumed;
}
var yB = It();
function wu(e) {
  var t = yB(e);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function Ya(e, t, i, n) {
  for (var r = wu(e), a = r.roam, o = a[t] = a[t] || [], s = 0; s < o.length; s++) {
    var l = o[s].zInfoParsed;
    if ((l.zlevel - n.zlevel || l.z - n.z || l.z2 - n.z2) <= 0)
      break;
  }
  o.splice(s, 0, {
    listener: i,
    zInfoParsed: n
  }), _B(e, t);
}
function Ua(e, t, i) {
  for (var n = wu(e), r = n.roam[t] || [], a = 0; a < r.length; a++)
    if (r[a].listener === i) {
      r.splice(a, 1), r.length || bB(e, t);
      return;
    }
}
function _B(e, t) {
  var i = wu(e);
  i.uniform[t] || e.on(t, i.uniform[t] = function(n) {
    var r = i.roam[t];
    if (r)
      for (var a = 0; a < r.length; a++)
        r[a].listener(n);
  });
}
function bB(e, t) {
  var i = wu(e), n = i.uniform;
  n[t] && (e.off(t, n[t]), n[t] = null);
}
function m0(e, t, i, n, r) {
  r.isAvailableBehavior = mt(nl, null, i, n), e.trigger(t, r);
}
function nl(e, t, i) {
  var n = i[e];
  return !e || n && (!K(n) || t.event[n + "Key"]);
}
var xB = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: vt.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: vt.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: vt.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: vt.color.tertiary,
        fontSize: 14
      }
    }, t;
  })(wt)
);
function F1(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function $1(e) {
  if (nt.domSupported) {
    for (var t = document.documentElement.style, i = 0, n = e.length; i < n; i++)
      if (e[i] in t)
        return e[i];
  }
}
var z1 = $1(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), wB = $1(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function V1(e, t) {
  if (!e)
    return t;
  t = hb(t, !0);
  var i = e.indexOf(t);
  return e = i === -1 ? t : "-" + e.slice(0, i) + "-" + t, e.toLowerCase();
}
function SB(e, t) {
  var i = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return i ? i[t] : null;
}
var CB = V1(wB, "transition"), Pf = V1(z1, "transform"), TB = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (nt.transform3dSupported ? "will-change:transform;" : "");
function MB(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function kB(e, t, i) {
  if (!K(i) || i === "inside")
    return "";
  var n = e.get("backgroundColor"), r = e.get("borderWidth");
  t = Bo(t);
  var a = MB(i), o = Math.max(Math.round(r) * 1.5, 6), s = "", l = Pf + ":", u;
  Pt(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = o + r, d = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), f = Math.round(((d - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (d - h) / 2) * 100) / 100;
  s += ";" + a + ":-" + f + "px";
  var v = t + " solid " + r + "px;", m = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + v, "border-right:" + v, "background-color:" + n + ";"];
  return '<div style="' + m.join("") + '"></div>';
}
function DB(e, t, i) {
  var n = "cubic-bezier(0.23,1,0.32,1)", r = "", a = "";
  return i && (r = " " + e / 2 + "s " + n, a = "opacity" + r + ",visibility" + r), t || (r = " " + e + "s " + n, a += (a.length ? "," : "") + (nt.transformSupported ? "" + Pf + r : ",left" + r + ",top" + r)), CB + ":" + a;
}
function y0(e, t, i) {
  var n = e.toFixed(0) + "px", r = t.toFixed(0) + "px";
  if (!nt.transformSupported)
    return i ? "top:" + r + ";left:" + n + ";" : [["top", r], ["left", n]];
  var a = nt.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + n + "," + r + (a ? ",0" : "") + ")";
  return i ? "top:0;left:0;" + Pf + ":" + o + ";" : [["top", 0], ["left", 0], [z1, o]];
}
function EB(e) {
  var t = [], i = e.get("fontSize"), n = e.getTextColor();
  n && t.push("color:" + n), t.push("font:" + e.getFont());
  var r = tt(e.get("lineHeight"), Math.round(i * 3 / 2));
  i && t.push("line-height:" + r + "px");
  var a = e.get("textShadowColor"), o = e.get("textShadowBlur") || 0, s = e.get("textShadowOffsetX") || 0, l = e.get("textShadowOffsetY") || 0;
  return a && o && t.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), E(["decoration", "align"], function(u) {
    var c = e.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function AB(e, t, i, n) {
  var r = [], a = e.get("transitionDuration"), o = e.get("backgroundColor"), s = e.get("shadowBlur"), l = e.get("shadowColor"), u = e.get("shadowOffsetX"), c = e.get("shadowOffsetY"), h = e.getModel("textStyle"), d = $b(e, "html"), f = u + "px " + c + "px " + s + "px " + l;
  return r.push("box-shadow:" + f), t && a > 0 && r.push(DB(a, i, n)), o && r.push("background-color:" + o), E(["width", "color", "radius"], function(v) {
    var m = "border-" + v, p = hb(m), g = e.get(p);
    g != null && r.push(m + ":" + g + (v === "color" ? "" : "px"));
  }), r.push(EB(h)), d != null && r.push("padding:" + vf(d).join("px ") + "px"), r.join(";") + ";";
}
function _0(e, t, i, n, r) {
  var a = t && t.painter;
  if (i) {
    var o = a && a.getViewportRoot();
    o && aD(e, o, i, n, r);
  } else {
    e[0] = n, e[1] = r;
    var s = a && a.getViewportRootOffset();
    s && (e[0] += s.offsetLeft, e[1] += s.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var LB = (
  /** @class */
  (function() {
    function e(t, i) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, nt.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var r = this._zr = t.getZr(), a = i.appendTo, o = a && (K(a) ? document.querySelector(a) : ca(a) ? a : ht(a) && a(t.getDom()));
      _0(this._styleCoord, r, o, t.getWidth() / 2, t.getHeight() / 2), (o || t.getDom()).appendChild(n), this._api = t, this._container = o;
      var s = this;
      n.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = r.handler, c = r.painter.getViewportRoot();
          We(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var i = this._api.getDom(), n = SB(i, "position"), r = i.style;
        r.position !== "absolute" && n !== "absolute" && (r.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, i) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, r = n.style, a = this._styleCoord;
      n.innerHTML ? r.cssText = TB + AB(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + y0(a[0], a[1], !0) + ("border-color:" + Bo(i) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var o = this.el;
      if (t == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (K(a) && n.get("trigger") === "item" && !F1(n) && (s = kB(n, r, a)), K(t))
        o.innerHTML = t + s;
      else if (t) {
        o.innerHTML = "", j(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          ca(t[l]) && t[l].parentNode !== o && o.appendChild(t[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, e.prototype.moveTo = function(t, i) {
      if (this.el) {
        var n = this._styleCoord;
        if (_0(n, this._zr, this._container, t, i), n[0] != null && n[1] != null) {
          var r = this.el.style, a = y0(n[0], n[1]);
          E(a, function(o) {
            r[o[0]] = o[1];
          });
        }
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, i = this.el.style;
      this._enableDisplayTransition ? (i.visibility = "hidden", i.opacity = "0") : i.display = "none", nt.transform3dSupported && (i.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(mt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      oD(t && t.painter && t.painter.getViewportRoot(), this._container);
      var i = this.el;
      if (i) {
        i.onmouseenter = i.onmousemove = i.onmouseleave = null;
        var n = i.parentNode;
        n && n.removeChild(i);
      }
      this.el = this._container = null;
    }, e;
  })()
), PB = (
  /** @class */
  (function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), x0(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var i = t.get("alwaysShowContent");
      i && this._moveIfResized(), this._alwaysShowContent = i;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var o = this;
      Z(t) && ke(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = n.getModel("textStyle");
      this.el = new ti({
        style: {
          rich: i.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: r,
          textShadowColor: s.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: $b(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), E(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = n.get(u);
      }), E(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, i = this.el.getBoundingRect(), n = b0(t.style);
      return [i.width + n.left + n.right, i.height + n.top + n.bottom];
    }, e.prototype.moveTo = function(t, i) {
      var n = this.el;
      if (n) {
        var r = this._styleCoord;
        x0(r, this._zr, t, i), t = r[0], i = r[1];
        var a = n.style, o = nn(a.borderWidth || 0), s = b0(a);
        n.x = t + o + s.left, n.y = i + o + s.top, n.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(mt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  })()
);
function nn(e) {
  return Math.max(0, e);
}
function b0(e) {
  var t = nn(e.shadowBlur || 0), i = nn(e.shadowOffsetX || 0), n = nn(e.shadowOffsetY || 0);
  return {
    left: nn(t - i),
    right: nn(t + i),
    top: nn(t - n),
    bottom: nn(t + n)
  };
}
function x0(e, t, i, n) {
  e[0] = i, e[1] = n, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var IB = new he({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), RB = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.init = function(i, n) {
      if (!(nt.node || !n.getDom())) {
        var r = i.getComponent("tooltip"), a = this._renderMode = $E(r.get("renderMode"));
        this._tooltipContent = a === "richText" ? new PB(n) : new LB(n, {
          appendTo: r.get("appendToBody", !0) ? "body" : r.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(i, n, r) {
      if (!(nt.node || !r.getDom())) {
        this.group.removeAll(), this._tooltipModel = i, this._ecModel = n, this._api = r;
        var a = this._tooltipContent;
        a.update(i), a.setEnterable(i.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && i.get("transitionDuration") ? Hb(this, "_updatePosition", 50, "fixRate") : Zh(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var i = this._tooltipModel, n = i.get("triggerOn");
      O1("itemTooltip", this._api, mt(function(r, a, o) {
        n !== "none" && (n.indexOf(r) >= 0 ? this._tryShow(a, o) : r === "leave" && this._hide(o));
      }, this));
    }, t.prototype._keepShow = function() {
      var i = this._tooltipModel, n = this._ecModel, r = this._api, a = i.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !r.isDisposed() && o.manuallyShowTip(i, n, r, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(i, n, r, a) {
      if (!(a.from === this.uid || nt.node || !r.getDom())) {
        var o = w0(a, r);
        this._ticket = "";
        var s = a.dataByCoordSys, l = FB(a, n, r);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = IB;
          c.x = a.x, c.y = a.y, c.update(), Lt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(i, n, r, a))
            return;
          var h = B1(a, n), d = h.point[0], f = h.point[1];
          d != null && f != null && this._tryShow({
            offsetX: d,
            offsetY: f,
            target: h.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else a.x != null && a.y != null && (r.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: r.getZr().findHover(a.x, a.y).target
        }, o));
      }
    }, t.prototype.manuallyHideTip = function(i, n, r, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(w0(a, r));
    }, t.prototype._manuallyAxisShowTip = function(i, n, r, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = n.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), h = Ga([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return r.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(i, n) {
      var r = i.target, a = this._tooltipModel;
      if (a) {
        this._lastX = i.offsetX, this._lastY = i.offsetY;
        var o = i.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, i);
        else if (r) {
          var s = Lt(r);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          ro(r, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (Lt(c).dataIndex != null ? l = c : Lt(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(i, l, n) : u ? this._showComponentItemTooltip(i, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(i, n) {
      var r = i.get("showDelay");
      n = mt(n, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(n, r) : n();
    }, t.prototype._showAxisTooltip = function(i, n) {
      var r = this._ecModel, a = this._tooltipModel, o = [n.offsetX, n.offsetY], s = Ga([n.tooltipOption], a), l = this._renderMode, u = [], c = _r("section", {
        blocks: [],
        noHeader: !0
      }), h = [], d = new Oc();
      E(i, function(y) {
        E(y.dataByAxis, function(_) {
          var b = r.getComponent(_.axisDim + "Axis", _.axisIndex), w = _.value;
          if (!(!b || w == null)) {
            var S = I1(w, b.axis, r, _.seriesDataIndices, _.valueLabelOpt), C = _r("section", {
              header: S,
              noHeader: !xi(S),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(C), E(_.seriesDataIndices, function(T) {
              var k = r.getSeriesByIndex(T.seriesIndex), M = T.dataIndexInside, D = k.getDataParams(M);
              if (!(D.dataIndex < 0)) {
                D.axisDim = _.axisDim, D.axisIndex = _.axisIndex, D.axisType = _.axisType, D.axisId = _.axisId, D.axisValue = T1(b.axis, {
                  value: w
                }), D.axisValueLabel = S, D.marker = d.makeTooltipMarker("item", Bo(D.color), l);
                var L = lm(k.formatTooltip(M, !0, null)), P = L.frag;
                if (P) {
                  var R = Ga([k], a).get("valueFormatter");
                  C.blocks.push(R ? V({
                    valueFormatter: R
                  }, P) : P);
                }
                L.text && h.push(L.text), u.push(D);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var f = n.position, v = s.get("order"), m = fm(c, d, l, v, r.get("useUTC"), s.get("textStyle"));
      m && h.unshift(m);
      var p = l === "richText" ? `

` : "<br/>", g = h.join(p);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(i, u) ? this._updatePosition(s, f, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, g, u, Math.random() + "", o[0], o[1], f, null, d);
      });
    }, t.prototype._showSeriesItemTooltip = function(i, n, r) {
      var a = this._ecModel, o = Lt(n), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, h = o.dataType, d = u.getData(h), f = this._renderMode, v = i.positionDefault, m = Ga([d.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, v ? {
        position: v
      } : null), p = m.get("trigger");
      if (!(p != null && p !== "item")) {
        var g = u.getDataParams(c, h), y = new Oc();
        g.marker = y.makeTooltipMarker("item", Bo(g.color), f);
        var _ = lm(u.formatTooltip(c, !1, h)), b = m.get("order"), w = m.get("valueFormatter"), S = _.frag, C = S ? fm(w ? V({
          valueFormatter: w
        }, S) : S, y, f, b, a.get("useUTC"), m.get("textStyle")) : _.text, T = "item_" + u.name + "_" + c;
        this._showOrMove(m, function() {
          this._showTooltipContent(m, C, g, T, i.offsetX, i.offsetY, i.position, i.target, y);
        }), r({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: d.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(i, n, r) {
      var a = this._renderMode === "html", o = Lt(n), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (K(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = ct(l), l.content = Ce(l.content));
      var h = [l], d = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      d && h.push(d), h.push({
        formatter: l.content
      });
      var f = i.positionDefault, v = Ga(h, this._tooltipModel, f ? {
        position: f
      } : null), m = v.get("content"), p = Math.random() + "", g = new Oc();
      this._showOrMove(v, function() {
        var y = ct(v.get("formatterParams") || {});
        this._showTooltipContent(v, m, y, p, i.offsetX, i.offsetY, i.position, n, g);
      }), r({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(i, n, r, a, o, s, l, u, c) {
      if (this._ticket = "", !(!i.get("showContent") || !i.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(i.get("enterable"));
        var d = i.get("formatter");
        l = l || i.get("position");
        var f = n, v = this._getNearestPoint([o, s], r, i.get("trigger"), i.get("borderColor"), i.get("defaultBorderColor", !0)), m = v.color;
        if (d)
          if (K(d)) {
            var p = i.ecModel.get("useUTC"), g = j(r) ? r[0] : r, y = g && g.axisType && g.axisType.indexOf("time") >= 0;
            f = d, y && (f = cb(g.axisValue, f, p)), f = db(f, r, !0);
          } else if (ht(d)) {
            var _ = mt(function(b, w) {
              b === this._ticket && (h.setContent(w, c, i, m, l), this._updatePosition(i, l, o, s, h, r, u));
            }, this);
            this._ticket = a, f = d(r, a, _);
          } else
            f = d;
        h.setContent(f, c, i, m, l), h.show(i, m), this._updatePosition(i, l, o, s, h, r, u);
      }
    }, t.prototype._getNearestPoint = function(i, n, r, a, o) {
      if (r === "axis" || j(n))
        return {
          color: a || o
        };
      if (!j(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(i, n, r, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || i.get("position");
      var h = o.getSize(), d = i.get("align"), f = i.get("verticalAlign"), v = l && l.getBoundingRect().clone();
      if (l && v.applyTransform(l.transform), ht(n) && (n = n([r, a], s, o.el, v, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), j(n))
        r = Me(n[0], u), a = Me(n[1], c);
      else if (Z(n)) {
        var m = n;
        m.width = h[0], m.height = h[1];
        var p = pf(m, {
          width: u,
          height: c
        });
        r = p.x, a = p.y, d = null, f = null;
      } else if (K(n) && l) {
        var g = NB(n, v, h, i.get("borderWidth"));
        r = g[0], a = g[1];
      } else {
        var g = OB(r, a, o, u, c, d ? null : 20, f ? null : 20);
        r = g[0], a = g[1];
      }
      if (d && (r -= S0(d) ? h[0] / 2 : d === "right" ? h[0] : 0), f && (a -= S0(f) ? h[1] / 2 : f === "bottom" ? h[1] : 0), F1(i)) {
        var g = BB(r, a, o, u, c);
        r = g[0], a = g[1];
      }
      o.moveTo(r, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(i, n) {
      var r = this._lastDataByCoordSys, a = this._cbParamsList, o = !!r && r.length === i.length;
      return o && E(r, function(s, l) {
        var u = s.dataByAxis || [], c = i[l] || {}, h = c.dataByAxis || [];
        o = o && u.length === h.length, o && E(u, function(d, f) {
          var v = h[f] || {}, m = d.seriesDataIndices || [], p = v.seriesDataIndices || [];
          o = o && d.value === v.value && d.axisType === v.axisType && d.axisId === v.axisId && m.length === p.length, o && E(m, function(g, y) {
            var _ = p[y];
            o = o && g.seriesIndex === _.seriesIndex && g.dataIndex === _.dataIndex;
          }), a && E(d.seriesDataIndices, function(g) {
            var y = g.seriesIndex, _ = n[y], b = a[y];
            _ && b && b.data !== _.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = i, this._cbParamsList = n, !!o;
    }, t.prototype._hide = function(i) {
      this._lastDataByCoordSys = null, i({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(i, n) {
      nt.node || !n.getDom() || (Zh(this, "_updatePosition"), this._tooltipContent.dispose(), ld("itemTooltip", n));
    }, t.type = "tooltip", t;
  })(Xi)
);
function Ga(e, t, i) {
  var n = t.ecModel, r;
  i ? (r = new Ot(i, n, n), r = new Ot(t.option, r, n)) : r = t;
  for (var a = e.length - 1; a >= 0; a--) {
    var o = e[a];
    o && (o instanceof Ot && (o = o.get("tooltip", !0)), K(o) && (o = {
      formatter: o
    }), o && (r = new Ot(o, r, n)));
  }
  return r;
}
function w0(e, t) {
  return e.dispatchAction || mt(t.dispatchAction, t);
}
function OB(e, t, i, n, r, a, o) {
  var s = i.getSize(), l = s[0], u = s[1];
  return a != null && (e + l + a + 2 > n ? e -= l + a : e += a), o != null && (t + u + o > r ? t -= u + o : t += o), [e, t];
}
function BB(e, t, i, n, r) {
  var a = i.getSize(), o = a[0], s = a[1];
  return e = Math.min(e + o, n) - o, t = Math.min(t + s, r) - s, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function NB(e, t, i, n) {
  var r = i[0], a = i[1], o = Math.ceil(Math.SQRT2 * n) + 8, s = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      s = t.x + u / 2 - r / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      s = t.x + u / 2 - r / 2, l = t.y - a - o;
      break;
    case "bottom":
      s = t.x + u / 2 - r / 2, l = t.y + c + o;
      break;
    case "left":
      s = t.x - r - o, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      s = t.x + u + o, l = t.y + c / 2 - a / 2;
  }
  return [s, l];
}
function S0(e) {
  return e === "center" || e === "middle";
}
function FB(e, t, i) {
  var n = Vd(e).queryOptionMap, r = n.keys()[0];
  if (!(!r || r === "series")) {
    var a = Go(t, r, n.get(r), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = i.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var c = Lt(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: r,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
function $B(e) {
  kf(lB), e.registerComponentModel(xB), e.registerComponentView(RB), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, ce), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, ce);
}
var Vo = E, zB = Z, jl = -1, If = (
  /** @class */
  (function() {
    function e(t) {
      var i = t.mappingMethod, n = t.type, r = this.option = ct(t);
      this.type = n, this.mappingMethod = i, this._normalizeData = WB[i];
      var a = e.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[i], i === "piecewise" ? (Kc(r), VB(r)) : i === "category" ? r.categories ? HB(r) : Kc(r, !0) : (J(i !== "linear" || r.dataExtent), Kc(r));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var i = this._normalizeData(t);
      return this._normalizedToVisual(i, t);
    }, e.prototype.getNormalizer = function() {
      return mt(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return Bt(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, i, n) {
      Z(t) ? E(t, i, n) : i.call(n, t);
    }, e.mapVisual = function(t, i, n) {
      var r, a = j(t) ? [] : Z(t) ? {} : (r = !0, null);
      return e.eachVisual(t, function(o, s) {
        var l = i.call(n, o, s);
        r ? a = l : a[s] = l;
      }), a;
    }, e.retrieveVisuals = function(t) {
      var i = {}, n;
      return t && Vo(e.visualHandlers, function(r, a) {
        t.hasOwnProperty(a) && (i[a] = t[a], n = !0);
      }), n ? i : null;
    }, e.prepareVisualTypes = function(t) {
      if (j(t))
        t = t.slice();
      else if (zB(t)) {
        var i = [];
        Vo(t, function(n, r) {
          i.push(r);
        }), t = i;
      } else
        return [];
      return t.sort(function(n, r) {
        return r === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, i) {
      return i === "color" ? !!(t && t.indexOf(i) === 0) : t === i;
    }, e.findPieceIndex = function(t, i, n) {
      for (var r, a = 1 / 0, o = 0, s = i.length; o < s; o++) {
        var l = i[o].value;
        if (l != null) {
          if (l === t || K(l) && l === t + "")
            return o;
          n && d(l, o);
        }
      }
      for (var o = 0, s = i.length; o < s; o++) {
        var u = i[o], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (Hs(h[1], t, c[1]))
              return o;
          } else if (c[1] === 1 / 0) {
            if (Hs(h[0], c[0], t))
              return o;
          } else if (Hs(h[0], c[0], t) && Hs(h[1], t, c[1]))
            return o;
          n && d(c[0], o), n && d(c[1], o);
        }
      }
      if (n)
        return t === 1 / 0 ? i.length - 1 : t === -1 / 0 ? 0 : r;
      function d(f, v) {
        var m = Math.abs(f - t);
        m < a && (a = m, r = v);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: Xa("color"),
        getColorMapper: function() {
          var t = this.option;
          return mt(t.mappingMethod === "category" ? function(i, n) {
            return !n && (i = this._normalizeData(i)), oo.call(this, i);
          } : function(i, n, r) {
            var a = !!r;
            return !n && (i = this._normalizeData(i)), r = Xu(i, t.parsedVisual, r), a ? r : hr(r, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return hr(Xu(t, this.option.parsedVisual), "rgba");
          },
          category: oo,
          piecewise: function(t, i) {
            var n = cd.call(this, i);
            return n == null && (n = hr(Xu(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: Kn
        }
      },
      colorHue: Vs(function(t, i) {
        return aa(t, i);
      }),
      colorSaturation: Vs(function(t, i) {
        return aa(t, null, i);
      }),
      colorLightness: Vs(function(t, i) {
        return aa(t, null, null, i);
      }),
      colorAlpha: Vs(function(t, i) {
        return VD(t, i);
      }),
      decal: {
        applyVisual: Xa("decal"),
        _normalizedToVisual: {
          linear: null,
          category: oo,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: Xa("opacity"),
        _normalizedToVisual: ud([0, 1])
      },
      liftZ: {
        applyVisual: Xa("liftZ"),
        _normalizedToVisual: {
          linear: Kn,
          category: Kn,
          piecewise: Kn,
          fixed: Kn
        }
      },
      symbol: {
        applyVisual: function(t, i, n) {
          var r = this.mapValueToVisual(t);
          n("symbol", r);
        },
        _normalizedToVisual: {
          linear: C0,
          category: oo,
          piecewise: function(t, i) {
            var n = cd.call(this, i);
            return n == null && (n = C0.call(this, t)), n;
          },
          fixed: Kn
        }
      },
      symbolSize: {
        applyVisual: Xa("symbolSize"),
        _normalizedToVisual: ud([0, 1])
      }
    }, e;
  })()
);
function VB(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, E(t, function(i, n) {
    i.originIndex = n, i.visual != null && (e.hasSpecialVisual = !0);
  });
}
function HB(e) {
  var t = e.categories, i = e.categoryMap = {}, n = e.visual;
  if (Vo(t, function(o, s) {
    i[o] = s;
  }), !j(n)) {
    var r = [];
    Z(n) ? Vo(n, function(o, s) {
      var l = i[s];
      r[l ?? jl] = o;
    }) : r[jl] = n, n = H1(e, r);
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete i[t[a]], t.pop());
}
function Kc(e, t) {
  var i = e.visual, n = [];
  Z(i) ? Vo(i, function(a) {
    n.push(a);
  }) : i != null && n.push(i);
  var r = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !r.hasOwnProperty(e.type) && (n[1] = n[0]), H1(e, n);
}
function Vs(e) {
  return {
    applyVisual: function(t, i, n) {
      var r = this.mapValueToVisual(t);
      n("color", e(i("color"), r));
    },
    _normalizedToVisual: ud([0, 1])
  };
}
function C0(e) {
  var t = this.option.visual;
  return t[Math.round(Po(e, [0, 1], [0, t.length - 1]))] || {};
}
function Xa(e) {
  return function(t, i, n) {
    n(e, this.mapValueToVisual(t));
  };
}
function oo(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== jl ? e % t.length : e];
}
function Kn() {
  return this.option.visual[0];
}
function ud(e) {
  return {
    linear: function(t) {
      return Po(t, e, this.option.visual);
    },
    category: oo,
    piecewise: function(t, i) {
      var n = cd.call(this, i);
      return n == null && (n = Po(t, e, this.option.visual)), n;
    },
    fixed: Kn
  };
}
function cd(e) {
  var t = this.option, i = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = If.findPieceIndex(e, i), r = i[n];
    if (r && r.visual)
      return r.visual[this.type];
  }
}
function H1(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = dt(t, function(i) {
    var n = Wi(i);
    return !n && process.env.NODE_ENV !== "production" && Xe("'" + i + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var WB = {
  linear: function(e) {
    return Po(e, this.option.dataExtent, [0, 1]);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, i = If.findPieceIndex(e, t, !0);
    if (i != null)
      return Po(i, [0, t.length - 1], [0, 1]);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? jl;
  },
  fixed: ce
};
function Hs(e, t, i) {
  return e ? t <= i : t < i;
}
var YB = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, i;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: vt.size.m,
      backgroundColor: vt.color.transparent,
      borderColor: vt.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: vt.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: vt.color.quaternary
      }
    }, t;
  })(wt)
), UB = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      if (this.group.removeAll(), !!i.get("show")) {
        var a = this.group, o = i.getModel("textStyle"), s = i.getModel("subtextStyle"), l = i.get("textAlign"), u = tt(i.get("textBaseline"), i.get("textVerticalAlign")), c = new ti({
          style: yr(o, {
            text: i.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), d = i.get("subtext"), f = new ti({
          style: yr(s, {
            text: d,
            fill: s.getTextColor(),
            y: h.height + i.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), v = i.get("link"), m = i.get("sublink"), p = i.get("triggerEvent", !0);
        c.silent = !v && !p, f.silent = !m && !p, v && c.on("click", function() {
          Hg(v, "_" + i.get("target"));
        }), m && f.on("click", function() {
          Hg(m, "_" + i.get("subtarget"));
        }), Lt(c).eventData = Lt(f).eventData = p ? {
          componentType: "title",
          componentIndex: i.componentIndex
        } : null, a.add(c), d && a.add(f);
        var g = a.getBoundingRect(), y = i.getBoxLayoutParams();
        y.width = g.width, y.height = g.height;
        var _ = vb(i, r), b = pf(y, _.refContainer, i.get("padding"));
        l || (l = i.get("left") || i.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = i.get("top") || i.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), a.x = b.x, a.y = b.y, a.markRedraw();
        var w = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(w), f.setStyle(w), g = a.getBoundingRect();
        var S = b.margin, C = i.getItemStyle(["color", "opacity"]);
        C.fill = i.get("backgroundColor");
        var T = new he({
          shape: {
            x: g.x - S[3],
            y: g.y - S[0],
            width: g.width + S[1] + S[3],
            height: g.height + S[0] + S[2],
            r: i.get("borderRadius")
          },
          style: C,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(T);
      }
    }, t.type = "title", t;
  })(Xi)
);
function GB(e) {
  e.registerComponentModel(YB), e.registerComponentView(UB);
}
var Qe = It();
function XB(e) {
  var t = e.mainData, i = e.datas;
  i || (i = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, W1(t, i, e), E(i, function(n) {
    E(t.TRANSFERABLE_METHODS, function(r) {
      n.wrapMethod(r, me(jB, e));
    });
  }), t.wrapMethod("cloneShallow", me(ZB, e)), E(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, me(qB, e));
  }), J(i[t.dataType] === t);
}
function jB(e, t) {
  if (JB(this)) {
    var i = V({}, Qe(this).datas);
    i[this.dataType] = t, W1(t, i, e);
  } else
    Rf(t, this.dataType, Qe(this).mainData, e);
  return t;
}
function qB(e, t) {
  return e.struct && e.struct.update(), t;
}
function ZB(e, t) {
  return E(Qe(t).datas, function(i, n) {
    i !== t && Rf(i.cloneShallow(), n, t, e);
  }), t;
}
function KB(e) {
  var t = Qe(this).mainData;
  return e == null || t == null ? t : Qe(t).datas[e];
}
function QB() {
  var e = Qe(this).mainData;
  return e == null ? [{
    data: e
  }] : dt(Bt(Qe(e).datas), function(t) {
    return {
      type: t,
      data: Qe(e).datas[t]
    };
  });
}
function JB(e) {
  return Qe(e).mainData === e;
}
function W1(e, t, i) {
  Qe(e).datas = {}, E(t, function(n, r) {
    Rf(n, r, e, i);
  });
}
function Rf(e, t, i, n) {
  Qe(i).datas[t] = e, Qe(e).mainData = i, e.dataType = t, n.struct && (e[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = e), e.getLinkedData = KB, e.getLinkedDataAll = QB;
}
function Xr(e) {
  return "_EC_" + e;
}
var tN = (
  /** @class */
  (function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, i) {
      t = t == null ? "" + i : "" + t;
      var n = this._nodesMap;
      if (n[Xr(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var r = new Qn(t, i);
      return r.hostGraph = this, this.nodes.push(r), n[Xr(t)] = r, r;
    }, e.prototype.getNodeByIndex = function(t) {
      var i = this.data.getRawIndex(t);
      return this.nodes[i];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[Xr(t)];
    }, e.prototype.addEdge = function(t, i, n) {
      var r = this._nodesMap, a = this._edgesMap;
      if (Nt(t) && (t = this.nodes[t]), Nt(i) && (i = this.nodes[i]), t instanceof Qn || (t = r[Xr(t)]), i instanceof Qn || (i = r[Xr(i)]), !(!t || !i)) {
        var o = t.id + "-" + i.id, s = new Y1(t, i, n);
        return s.hostGraph = this, this._directed && (t.outEdges.push(s), i.inEdges.push(s)), t.edges.push(s), t !== i && i.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var i = this.edgeData.getRawIndex(t);
      return this.edges[i];
    }, e.prototype.getEdge = function(t, i) {
      t instanceof Qn && (t = t.id), i instanceof Qn && (i = i.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + i] : n[t + "-" + i] || n[i + "-" + t];
    }, e.prototype.eachNode = function(t, i) {
      for (var n = this.nodes, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.eachEdge = function(t, i) {
      for (var n = this.edges, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.breadthFirstTraverse = function(t, i, n, r) {
      if (i instanceof Qn || (i = this._nodesMap[Xr(i)]), !!i) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!t.call(r, i, null))
          for (var s = [i]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var c = u[o], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (t.call(r, h, l))
                  return;
                s.push(h), h.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, i = this.edgeData, n = this.nodes, r = this.edges, a = 0, o = n.length; a < o; a++)
        n[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        n[t.getRawIndex(a)].dataIndex = a;
      i.filterSelf(function(s) {
        var l = r[i.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = r.length; a < o; a++)
        r[a].dataIndex = -1;
      for (var a = 0, o = i.count(); a < o; a++)
        r[i.getRawIndex(a)].dataIndex = a;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), i = this.nodes, n = this.edges, r = 0; r < i.length; r++)
        t.addNode(i[r].id, i[r].dataIndex);
      for (var r = 0; r < n.length; r++) {
        var a = n[r];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, e;
  })()
), Qn = (
  /** @class */
  (function() {
    function e(t, i) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = i ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, i = 0; i < this.edges.length; i++) {
        var n = this.edges[i];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = ot(), i = ot(), n = 0, r = this.edges.length; n < r; n++) {
        var a = this.edges[n];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var o = [a.node1], s = [a.node2], l = 0; l < o.length; ) {
            var u = o[l];
            l++, i.set(u.dataIndex, !0);
            for (var c = u.inEdges, h = 0, d = c.length, f = void 0, v = void 0; h < d; h++)
              f = c[h], v = f.dataIndex, v >= 0 && !t.hasKey(v) && (t.set(v, !0), o.push(f.node1));
          }
          for (l = 0; l < s.length; ) {
            var m = s[l];
            l++, i.set(m.dataIndex, !0);
            for (var p = m.outEdges, h = 0, g = p.length, y = void 0, _ = void 0; h < g; h++)
              y = p[h], _ = y.dataIndex, _ >= 0 && !t.hasKey(_) && (t.set(_, !0), s.push(y.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
), Y1 = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = i, this.dataIndex = n ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = ot(), i = ot();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], r = [this.node2], a = 0; a < n.length; ) {
        var o = n[a];
        a++, i.set(o.dataIndex, !0);
        for (var s = o.inEdges, l = 0, u = s.length, c = void 0, h = void 0; l < u; l++)
          c = o.inEdges[l], h = c.dataIndex, h >= 0 && !t.hasKey(h) && (t.set(h, !0), n.push(c.node1));
      }
      for (a = 0; a < r.length; ) {
        var d = r[a];
        a++, i.set(d.dataIndex, !0);
        for (var f = d.outEdges, l = 0, u = f.length, v = void 0, m = void 0; l < u; l++)
          v = d.outEdges[l], m = v.dataIndex, m >= 0 && !t.hasKey(m) && (t.set(m, !0), r.push(v.node2));
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
);
function U1(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(i) {
      var n = this[e][t];
      return n.getStore().get(n.getDimensionIndex(i || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, i, n);
    },
    getVisual: function(i) {
      return this[e][t].getItemVisual(this.dataIndex, i);
    },
    setLayout: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, i, n);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
si(Qn, U1("hostGraph", "data"));
si(Y1, U1("hostGraph", "edgeData"));
function eN(e, t, i, n, r) {
  for (var a = new tN(n), o = 0; o < e.length; o++)
    a.addNode(mn(
      // Id, name, dataIndex
      e[o].id,
      e[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
    var c = t[o], h = c.source, d = c.target;
    a.addEdge(h, d, u) && (l.push(c), s.push(mn(ai(c.id, null), h + " > " + d)), u++);
  }
  var f = i.get("coordinateSystem"), v;
  if (f === "cartesian2d" || f === "polar" || f === "matrix")
    v = QR(e, i);
  else {
    var m = yu.get(f), p = m ? m.dimensions || [] : [];
    Pt(p, "value") < 0 && p.concat(["value"]);
    var g = C1(e, {
      coordDimensions: p,
      encodeDefine: i.getEncode()
    }).dimensions;
    v = new ad(g, i), v.initData(e);
  }
  var y = new ad(["value"], i);
  return y.initData(l, s), r && r(v, y), XB({
    mainData: v,
    struct: a,
    structAttr: "graph",
    datas: {
      node: v,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var iN = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  })()
), nN = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t(i) {
      return e.call(this, i) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new iN();
    }, t.prototype.buildPath = function(i, n) {
      var r = n.extent;
      i.moveTo(n.x1, n.y1), i.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (i.lineTo(n.x2 + r, n.y2), i.bezierCurveTo(n.cpx2 + r, n.cpy2, n.cpx1 + r, n.cpy1, n.x1 + r, n.y1)) : (i.lineTo(n.x2, n.y2 + r), i.bezierCurveTo(n.cpx2, n.cpy2 + r, n.cpx1, n.cpy1 + r, n.x1, n.y1 + r)), i.closePath();
    }, t.prototype.highlight = function() {
      Dl(this);
    }, t.prototype.downplay = function() {
      El(this);
    }, t;
  })(Et)
), rN = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i._mainGroup = new oi(), i._focusAdjacencyDisabled = !1, i;
    }
    return t.prototype.init = function(i, n) {
      this._controller = new mB(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(i, n, r) {
      var a = this, o = i.getGraph(), s = this._mainGroup, l = i.layoutInfo, u = l.width, c = l.height, h = i.getData(), d = i.getData("edge"), f = i.get("orient");
      this._model = i, s.removeAll(), s.x = l.x, s.y = l.y, this._updateViewCoordSys(i, r), hB(i, r, s, this._controller, this._controllerHost), o.eachEdge(function(v) {
        var m = new nN(), p = Lt(m);
        p.dataIndex = v.dataIndex, p.seriesIndex = i.seriesIndex, p.dataType = "edge";
        var g = v.getModel(), y = g.getModel("lineStyle"), _ = y.get("curveness"), b = v.node1.getLayout(), w = v.node1.getModel(), S = w.get("localX"), C = w.get("localY"), T = v.node2.getLayout(), k = v.node2.getModel(), M = k.get("localX"), D = k.get("localY"), L = v.getLayout(), P, R, B, F, W, z, N, $;
        m.shape.extent = Math.max(1, L.dy), m.shape.orient = f, f === "vertical" ? (P = (S != null ? S * u : b.x) + L.sy, R = (C != null ? C * c : b.y) + b.dy, B = (M != null ? M * u : T.x) + L.ty, F = D != null ? D * c : T.y, W = P, z = R * (1 - _) + F * _, N = B, $ = R * _ + F * (1 - _)) : (P = (S != null ? S * u : b.x) + b.dx, R = (C != null ? C * c : b.y) + L.sy, B = M != null ? M * u : T.x, F = (D != null ? D * c : T.y) + L.ty, W = P * (1 - _) + B * _, z = R, N = P * _ + B * (1 - _), $ = F), m.setShape({
          x1: P,
          y1: R,
          x2: B,
          y2: F,
          cpx1: W,
          cpy1: z,
          cpx2: N,
          cpy2: $
        }), m.useStyle(y.getItemStyle()), T0(m.style, f, v);
        var X = "" + g.get("value"), U = Og(g, "edgeLabel");
        Rg(m, U, {
          labelFetcher: {
            getFormattedLabel: function(ft, yt, ie, ve, xt, Mt) {
              return i.getFormattedLabel(
                ft,
                yt,
                "edge",
                ve,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                ur(xt, U.normal && U.normal.get("formatter"), X),
                Mt
              );
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: X
        }), m.setTextConfig({
          position: "inside"
        });
        var Q = g.getModel("emphasis");
        wg(m, g, "lineStyle", function(ft) {
          var yt = ft.getItemStyle();
          return T0(yt, f, v), yt;
        }), s.add(m), d.setItemGraphicEl(v.dataIndex, m);
        var it = Q.get("focus");
        bg(m, it === "adjacency" ? v.getAdjacentDataIndices() : it === "trajectory" ? v.getTrajectoryDataIndices() : it, Q.get("blurScope"), Q.get("disabled"));
      }), o.eachNode(function(v) {
        var m = v.getLayout(), p = v.getModel(), g = p.get("localX"), y = p.get("localY"), _ = p.getModel("emphasis"), b = p.get(["itemStyle", "borderRadius"]) || 0, w = new he({
          shape: {
            x: g != null ? g * u : m.x,
            y: y != null ? y * c : m.y,
            width: m.dx,
            height: m.dy,
            r: b
          },
          style: p.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Rg(w, Og(p), {
          labelFetcher: {
            getFormattedLabel: function(C, T) {
              return i.getFormattedLabel(C, T, "node");
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: v.id
        }), w.disableLabelAnimation = !0, w.setStyle("fill", v.getVisual("color")), w.setStyle("decal", v.getVisual("style").decal), wg(w, p), s.add(w), h.setItemGraphicEl(v.dataIndex, w), Lt(w).dataType = "node";
        var S = _.get("focus");
        bg(w, S === "adjacency" ? v.getAdjacentDataIndices() : S === "trajectory" ? v.getTrajectoryDataIndices() : S, _.get("blurScope"), _.get("disabled"));
      }), h.eachItemGraphicEl(function(v, m) {
        var p = h.getItemModel(m);
        p.get("draggable") && (v.drift = function(g, y) {
          a._focusAdjacencyDisabled = !0, this.shape.x += g, this.shape.y += y, this.dirty(), r.dispatchAction({
            type: "dragNode",
            seriesId: i.id,
            dataIndex: h.getRawIndex(m),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, v.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, v.draggable = !0, v.cursor = "move");
      }), !this._data && i.isAnimationEnabled() && s.setClipPath(aN(s.getBoundingRect(), i, function() {
        s.removeClipPath();
      })), this._data = i.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(i, n) {
      var r = i.layoutInfo, a = r.width, o = r.height, s = i.coordinateSystem = new fB(null, {
        api: n,
        ecModel: i.ecModel
      });
      s.zoomLimit = i.get("scaleLimit"), s.setBoundingRect(0, 0, a, o), s.setCenter(i.get("center")), s.setZoom(i.get("zoom")), this._controllerHost.target.attr({
        x: s.x,
        y: s.y,
        scaleX: s.scaleX,
        scaleY: s.scaleY
      });
    }, t.type = "sankey", t;
  })(fn)
);
function T0(e, t, i) {
  switch (e.fill) {
    case "source":
      e.fill = i.node1.getVisual("color"), e.decal = i.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = i.node2.getVisual("color"), e.decal = i.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = i.node1.getVisual("color"), r = i.node2.getVisual("color");
      K(n) && K(r) && (e.fill = new j_(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: r,
        offset: 1
      }]));
  }
}
function aN(e, t, i) {
  var n = new he({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return Z_(n, {
    shape: {
      width: e.width + 20
    }
  }, t, i), n;
}
var oN = (
  /** @class */
  (function(e) {
    Xt(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.getInitialData = function(i, n) {
      var r = i.edges || i.links || [], a = i.data || i.nodes || [], o = i.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        if (o[l].depth != null && o[l].depth >= 0)
          s[o[l].depth] = new Ot(o[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = eN(a, r, this, !0, c);
      return u.data;
      function c(h, d) {
        h.wrapMethod("getItemModel", function(f, v) {
          var m = f.parentModel, p = m.getData().getItemLayout(v);
          if (p) {
            var g = p.depth, y = m.levelModels[g];
            y && (f.parentModel = y);
          }
          return f;
        }), d.wrapMethod("getItemModel", function(f, v) {
          var m = f.parentModel, p = m.getGraph().getEdgeByIndex(v), g = p.node1.getLayout();
          if (g) {
            var y = g.depth, _ = m.levelModels[y];
            _ && (f.parentModel = _);
          }
          return f;
        });
      }
    }, t.prototype.setNodePosition = function(i, n) {
      var r = this.option.data || this.option.nodes, a = r[i];
      a.localX = n[0], a.localY = n[1];
    }, t.prototype.setCenter = function(i) {
      this.option.center = i;
    }, t.prototype.setZoom = function(i) {
      this.option.zoom = i;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(i, n, r) {
      function a(f) {
        return isNaN(f) || f == null;
      }
      if (r === "edge") {
        var o = this.getDataParams(i, r), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return _r("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(i), h = c.getLayout().value, d = this.getDataParams(i, r).data.name;
        return _r("nameValue", {
          name: d != null ? d + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(i, n) {
      var r = e.prototype.getDataParams.call(this, i, n);
      if (r.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(i), o = a.getLayout().value;
        r.value = o;
      }
      return r;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: vt.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: vt.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  })(_n)
);
function sN(e, t) {
  e.eachSeriesByType("sankey", function(i) {
    var n = i.get("nodeWidth"), r = i.get("nodeGap"), a = vb(i, t).refContainer, o = pf(i.getBoxLayoutParams(), a);
    i.layoutInfo = o;
    var s = o.width, l = o.height, u = i.getGraph(), c = u.nodes, h = u.edges;
    uN(c);
    var d = Re(c, function(p) {
      return p.getLayout().value === 0;
    }), f = d.length !== 0 ? 0 : i.get("layoutIterations"), v = i.get("orient"), m = i.get("nodeAlign");
    lN(c, h, n, r, s, l, f, v, m);
  });
}
function lN(e, t, i, n, r, a, o, s, l) {
  cN(e, t, i, r, a, s, l), vN(e, t, a, r, n, o, s), SN(e, s);
}
function uN(e) {
  E(e, function(t) {
    var i = vn(t.outEdges, ql), n = vn(t.inEdges, ql), r = t.getValue() || 0, a = Math.max(i, n, r);
    t.setLayout({
      value: a
    }, !0);
  });
}
function cN(e, t, i, n, r, a, o) {
  for (var s = [], l = [], u = [], c = [], h = 0, d = 0; d < t.length; d++)
    s[d] = 1;
  for (var d = 0; d < e.length; d++)
    l[d] = e[d].inEdges.length, l[d] === 0 && u.push(e[d]);
  for (var f = -1; u.length; ) {
    for (var v = 0; v < u.length; v++) {
      var m = u[v], p = m.hostGraph.data.getRawDataItem(m.dataIndex), g = p.depth != null && p.depth >= 0;
      g && p.depth > f && (f = p.depth), m.setLayout({
        depth: g ? p.depth : h
      }, !0), a === "vertical" ? m.setLayout({
        dy: i
      }, !0) : m.setLayout({
        dx: i
      }, !0);
      for (var y = 0; y < m.outEdges.length; y++) {
        var _ = m.outEdges[y], b = t.indexOf(_);
        s[b] = 0;
        var w = _.node2, S = e.indexOf(w);
        --l[S] === 0 && c.indexOf(w) < 0 && c.push(w);
      }
    }
    ++h, u = c, c = [];
  }
  for (var d = 0; d < s.length; d++)
    if (s[d] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var C = f > h - 1 ? f : h - 1;
  o && o !== "left" && hN(e, o, a, C);
  var T = a === "vertical" ? (r - i) / C : (n - i) / C;
  fN(e, T, a);
}
function G1(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function hN(e, t, i, n) {
  if (t === "right") {
    for (var r = [], a = e, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          r.indexOf(c.node1) < 0 && r.push(c.node1);
        }
      }
      a = r, r = [], ++o;
    }
    E(e, function(h) {
      G1(h) || h.setLayout({
        depth: Math.max(0, n - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && dN(e, n);
}
function dN(e, t) {
  E(e, function(i) {
    !G1(i) && !i.outEdges.length && i.setLayout({
      depth: t
    }, !0);
  });
}
function fN(e, t, i) {
  E(e, function(n) {
    var r = n.getLayout().depth * t;
    i === "vertical" ? n.setLayout({
      y: r
    }, !0) : n.setLayout({
      x: r
    }, !0);
  });
}
function vN(e, t, i, n, r, a, o) {
  var s = pN(e, o);
  gN(s, t, i, n, r, o), Qc(s, r, i, n, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, mN(s, l, o), Qc(s, r, i, n, o), wN(s, l, o), Qc(s, r, i, n, o);
}
function pN(e, t) {
  var i = [], n = t === "vertical" ? "y" : "x", r = zE(e, function(a) {
    return a.getLayout()[n];
  });
  return r.keys.sort(function(a, o) {
    return a - o;
  }), E(r.keys, function(a) {
    i.push(r.buckets.get(a));
  }), i;
}
function gN(e, t, i, n, r, a) {
  var o = 1 / 0;
  E(e, function(s) {
    var l = s.length, u = 0;
    E(s, function(h) {
      u += h.getLayout().value;
    });
    var c = a === "vertical" ? (n - (l - 1) * r) / u : (i - (l - 1) * r) / u;
    c < o && (o = c);
  }), E(e, function(s) {
    E(s, function(l, u) {
      var c = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), E(t, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function Qc(e, t, i, n, r) {
  var a = r === "vertical" ? "x" : "y";
  E(e, function(o) {
    o.sort(function(m, p) {
      return m.getLayout()[a] - p.getLayout()[a];
    });
    for (var s, l, u, c = 0, h = o.length, d = r === "vertical" ? "dx" : "dy", f = 0; f < h; f++)
      l = o[f], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[a] + l.getLayout()[d] + t;
    var v = r === "vertical" ? n : i;
    if (u = c - t - v, u > 0) {
      s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var f = h - 2; f >= 0; --f)
        l = o[f], u = l.getLayout()[a] + l.getLayout()[d] + t - c, u > 0 && (s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function mN(e, t, i) {
  E(e.slice().reverse(), function(n) {
    E(n, function(r) {
      if (r.outEdges.length) {
        var a = vn(r.outEdges, yN, i) / vn(r.outEdges, ql);
        if (isNaN(a)) {
          var o = r.outEdges.length;
          a = o ? vn(r.outEdges, _N, i) / o : 0;
        }
        if (i === "vertical") {
          var s = r.getLayout().x + (a - xn(r, i)) * t;
          r.setLayout({
            x: s
          }, !0);
        } else {
          var l = r.getLayout().y + (a - xn(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function yN(e, t) {
  return xn(e.node2, t) * e.getValue();
}
function _N(e, t) {
  return xn(e.node2, t);
}
function bN(e, t) {
  return xn(e.node1, t) * e.getValue();
}
function xN(e, t) {
  return xn(e.node1, t);
}
function xn(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function ql(e) {
  return e.getValue();
}
function vn(e, t, i) {
  for (var n = 0, r = e.length, a = -1; ++a < r; ) {
    var o = +t(e[a], i);
    isNaN(o) || (n += o);
  }
  return n;
}
function wN(e, t, i) {
  E(e, function(n) {
    E(n, function(r) {
      if (r.inEdges.length) {
        var a = vn(r.inEdges, bN, i) / vn(r.inEdges, ql);
        if (isNaN(a)) {
          var o = r.inEdges.length;
          a = o ? vn(r.inEdges, xN, i) / o : 0;
        }
        if (i === "vertical") {
          var s = r.getLayout().x + (a - xn(r, i)) * t;
          r.setLayout({
            x: s
          }, !0);
        } else {
          var l = r.getLayout().y + (a - xn(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function SN(e, t) {
  var i = t === "vertical" ? "x" : "y";
  E(e, function(n) {
    n.outEdges.sort(function(r, a) {
      return r.node2.getLayout()[i] - a.node2.getLayout()[i];
    }), n.inEdges.sort(function(r, a) {
      return r.node1.getLayout()[i] - a.node1.getLayout()[i];
    });
  }), E(e, function(n) {
    var r = 0, a = 0;
    E(n.outEdges, function(o) {
      o.setLayout({
        sy: r
      }, !0), r += o.getLayout().dy;
    }), E(n.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function CN(e) {
  e.eachSeriesByType("sankey", function(t) {
    var i = t.getGraph(), n = i.nodes, r = i.edges;
    if (n.length) {
      var a = 1 / 0, o = -1 / 0;
      E(n, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), E(n, function(s) {
        var l = new If({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: t.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    r.length && E(r, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function TN(e) {
  e.registerChartView(rN), e.registerSeriesModel(oN), e.registerLayout(sN), e.registerVisual(CN), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, i) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), e.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, i, n) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(r) {
      var a = r.coordinateSystem, o = dB(a, t, r.get("scaleLimit"));
      r.setCenter(o.center), r.setZoom(o.zoom);
    });
  });
}
function M0(e, t, i) {
  var n = Ui.createCanvas(), r = t.getWidth(), a = t.getHeight(), o = n.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = r + "px", o.height = a + "px", n.setAttribute("data-zr-dom-id", e)), n.width = r * i, n.height = a * i, n;
}
var Jc = (function(e) {
  St(t, e);
  function t(i, n, r) {
    var a = e.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    r = r || xl, typeof i == "string" ? o = M0(i, n, r) : Z(i) && (o = i, i = o.id), a.id = i, a.dom = o;
    var s = o.style;
    return s && (Wy(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = n, a.dpr = r, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var i = this.dpr;
    this.domBack = M0("back-" + this.id, this.painter, i), this.ctxBack = this.domBack.getContext("2d"), i !== 1 && this.ctxBack.scale(i, i);
  }, t.prototype.createRepaintRects = function(i, n, r, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new rt(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (o.length === 0) {
          var _ = new rt(0, 0, 0, 0);
          _.copy(y), o.push(_);
        } else {
          for (var b = !1, w = 1 / 0, S = 0, C = 0; C < o.length; ++C) {
            var T = o[C];
            if (T.intersect(y)) {
              var k = new rt(0, 0, 0, 0);
              k.copy(T), k.union(y), o[C] = k, b = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(T);
              var M = y.width * y.height, D = T.width * T.height, L = u.width * u.height, P = L - M - D;
              P < w && (w = P, S = C);
            }
          }
          if (l && (o[S].union(y), b = !0), !b) {
            var _ = new rt(0, 0, 0, 0);
            _.copy(y), o.push(_);
          }
          l || (l = o.length >= s);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var d = i[h];
      if (d) {
        var f = d.shouldBePainted(r, a, !0, !0), v = d.__isRendered && (d.__dirty & Oe || !f) ? d.getPrevPaintRect() : null;
        v && c(v);
        var m = f && (d.__dirty & Oe || !d.__isRendered) ? d.getPaintRect() : null;
        m && c(m);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var d = n[h], f = d && d.shouldBePainted(r, a, !0, !0);
      if (d && (!f || !d.__zr) && d.__isRendered) {
        var v = d.getPrevPaintRect();
        v && c(v);
      }
    }
    var p;
    do {
      p = !1;
      for (var h = 0; h < o.length; ) {
        if (o[h].isZero()) {
          o.splice(h, 1);
          continue;
        }
        for (var g = h + 1; g < o.length; )
          o[h].intersect(o[g]) ? (p = !0, o[h].union(o[g]), o.splice(g, 1)) : g++;
        h++;
      }
    } while (p);
    return this._paintRects = o, o;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(i, n) {
    var r = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = i + "px", o.height = n + "px"), a.width = i * r, a.height = n * r, s && (s.width = i * r, s.height = n * r, r !== 1 && this.ctxBack.scale(r, r));
  }, t.prototype.clear = function(i, n, r) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !i, c = this.lastFrameAlpha, h = this.dpr, d = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / h, l / h));
    var f = this.domBack;
    function v(m, p, g, y) {
      if (o.clearRect(m, p, g, y), n && n !== "transparent") {
        var _ = void 0;
        if (au(n)) {
          var b = n.global || n.__width === g && n.__height === y;
          _ = b && n.__canvasGradient || Jh(o, n, {
            x: 0,
            y: 0,
            width: g,
            height: y
          }), n.__canvasGradient = _, n.__width = g, n.__height = y;
        } else Hk(n) && (n.scaleX = n.scaleX || h, n.scaleY = n.scaleY || h, _ = td(o, n, {
          dirty: function() {
            d.setUnpainted(), d.painter.refresh();
          }
        }));
        o.save(), o.fillStyle = _ || n, o.fillRect(m, p, g, y), o.restore();
      }
      u && (o.save(), o.globalAlpha = c, o.drawImage(f, m, p, g, y), o.restore());
    }
    !r || u ? v(0, 0, s, l) : r.length && E(r, function(m) {
      v(m.x * h, m.y * h, m.width * h, m.height * h);
    });
  }, t;
})(li), k0 = 1e5, jn = 314159, Ws = 0.01, MN = 1e-3;
function kN(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function DN(e, t) {
  var i = document.createElement("div");
  return i.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", i;
}
var EN = (function() {
  function e(t, i, n, r) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = V({}, n || {}), this.dpr = n.devicePixelRatio || xl, this._singleCanvas = a, this.root = t;
    var o = t.style;
    o && (Wy(t), t.innerHTML = ""), this.storage = i;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, h = c.width, d = c.height;
      n.width != null && (h = n.width), n.height != null && (d = n.height), this.dpr = n.devicePixelRatio || 1, c.width = h * this.dpr, c.height = d * this.dpr, this._width = h, this._height = d;
      var f = new Jc(c, this, this.dpr);
      f.__builtin__ = !0, f.initContext(), l[jn] = f, f.zlevel = jn, s.push(jn), this._domRoot = t;
    } else {
      this._width = Rs(t, 0, n), this._height = Rs(t, 1, n);
      var u = this._domRoot = DN(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var i = this.storage.getDisplayList(!0), n = this._prevDisplayList, r = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(i, n, t, this._redrawId);
    for (var a = 0; a < r.length; a++) {
      var o = r[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = i.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var i = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!i) {
      for (var r = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < i; o++) {
        var s = t[o];
        s.__inHover && (n || (n = this._hoverlayer = this.getLayer(k0)), a || (a = n.ctx, a.save()), ar(a, s, r, o === i - 1));
      }
      a && a.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(k0);
  }, e.prototype.paintOne = function(t, i) {
    t1(t, i);
  }, e.prototype._paintList = function(t, i, n, r) {
    if (this._redrawId === r) {
      n = n || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, i, n), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        pl(function() {
          l._paintList(t, i, n, r);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(jn).ctx, i = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, i, n), this.eachBuiltinLayer(function(r) {
      r.virtual && t.drawImage(r.dom, 0, 0, i, n);
    });
  }, e.prototype._doPaintList = function(t, i, n) {
    for (var r = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var c = !0, h = !1, d = function(m) {
      var p = a[m], g = p.ctx, y = o && p.createRepaintRects(t, i, f._width, f._height), _ = n ? p.__startIndex : p.__drawIndex, b = !n && p.incremental && Date.now, w = b && Date.now(), S = p.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
      if (p.__startIndex === p.__endIndex)
        p.clear(!1, S, y);
      else if (_ === p.__startIndex) {
        var C = t[_];
        (!C.incremental || !C.notClear || n) && p.clear(!1, S, y);
      }
      _ === -1 && (console.error("For some unknown reason. drawIndex is -1"), _ = p.__startIndex);
      var T, k = function(P) {
        var R = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: r._width,
          viewHeight: r._height
        };
        for (T = _; T < p.__endIndex; T++) {
          var B = t[T];
          if (B.__inHover && (h = !0), r._doPaintEl(B, p, o, P, R, T === p.__endIndex - 1), b) {
            var F = Date.now() - w;
            if (F > 15)
              break;
          }
        }
        R.prevElClipPaths && g.restore();
      };
      if (y)
        if (y.length === 0)
          T = p.__endIndex;
        else
          for (var M = f.dpr, D = 0; D < y.length; ++D) {
            var L = y[D];
            g.save(), g.beginPath(), g.rect(L.x * M, L.y * M, L.width * M, L.height * M), g.clip(), k(L), g.restore();
          }
      else
        g.save(), k(), g.restore();
      p.__drawIndex = T, p.__drawIndex < p.__endIndex && (c = !1);
    }, f = this, v = 0; v < a.length; v++)
      d(v);
    return nt.wxa && E(this._layers, function(m) {
      m && m.ctx && m.ctx.draw && m.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, e.prototype._doPaintEl = function(t, i, n, r, a, o) {
    var s = i.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!r || l && l.intersect(r)) && (ar(s, t, a, o), t.setPrevPaintRect(l));
    } else
      ar(s, t, a, o);
  }, e.prototype.getLayer = function(t, i) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = jn);
    var n = this._layers[t];
    return n || (n = new Jc("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? Gt(n, this._layerConfig[t], !0) : this._layerConfig[t - Ws] && Gt(n, this._layerConfig[t - Ws], !0), i && (n.virtual = i), this.insertLayer(t, n), n.initContext()), n;
  }, e.prototype.insertLayer = function(t, i) {
    var n = this._layers, r = this._zlevelList, a = r.length, o = this._domRoot, s = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && lr("ZLevel " + t + " has been used already");
      return;
    }
    if (!kN(i)) {
      process.env.NODE_ENV !== "production" && lr("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > r[0]) {
      for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++)
        ;
      s = n[r[l]];
    }
    if (r.splice(l + 1, 0, t), n[t] = i, !i.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(i.dom, u.nextSibling) : o.appendChild(i.dom);
      } else
        o.firstChild ? o.insertBefore(i.dom, o.firstChild) : o.appendChild(i.dom);
    i.painter || (i.painter = this);
  }, e.prototype.eachLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r];
      t.call(i, this._layers[a], a);
    }
  }, e.prototype.eachBuiltinLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], o = this._layers[a];
      o.__builtin__ && t.call(i, o, a);
    }
  }, e.prototype.eachOtherLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], o = this._layers[a];
      o.__builtin__ || t.call(i, o, a);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(h, d) {
      h.__dirty = h.__used = !1;
    });
    function i(h) {
      a && (a.__endIndex !== h && (a.__dirty = !0), a.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var r = t[n];
        if (r.zlevel !== t[n - 1].zlevel || r.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < t.length; l++) {
      var r = t[l], u = r.zlevel, c = void 0;
      s !== u && (s = u, o = 0), r.incremental ? (c = this.getLayer(u + MN, this._needsManuallyCompositing), c.incremental = !0, o = 1) : c = this.getLayer(u + (o > 0 ? Ws : 0), this._needsManuallyCompositing), c.__builtin__ || lr("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, i(l), a = c), r.__dirty & Oe && !r.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    i(l), this.eachBuiltinLayer(function(h, d) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, E(this._layers, function(i) {
      i.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, i) {
    if (i) {
      var n = this._layerConfig;
      n[t] ? Gt(n[t], i, !0) : n[t] = i;
      for (var r = 0; r < this._zlevelList.length; r++) {
        var a = this._zlevelList[r];
        if (a === t || a === t + Ws) {
          var o = this._layers[a];
          Gt(o, n[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var i = this._layers, n = this._zlevelList, r = i[t];
    r && (r.dom.parentNode.removeChild(r.dom), delete i[t], n.splice(Pt(n, t), 1));
  }, e.prototype.resize = function(t, i) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var r = this._opts, a = this.root;
      if (t != null && (r.width = t), i != null && (r.height = i), t = Rs(a, 0, r), i = Rs(a, 1, r), n.style.display = "", this._width !== t || i !== this._height) {
        n.style.width = t + "px", n.style.height = i + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(t, i);
        this.refresh(!0);
      }
      this._width = t, this._height = i;
    } else {
      if (t == null || i == null)
        return;
      this._width = t, this._height = i, this.getLayer(jn).resize(t, i);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var i = this._layers[t];
    i && i.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[jn].dom;
    var i = new Jc("image", this, t.pixelRatio || this.dpr);
    i.initContext(), i.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = i.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var r = i.dom.width, a = i.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? n.drawImage(h.dom, 0, 0, r, a) : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        ar(n, c, o, l === u - 1);
      }
    return i.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
})();
function AN(e) {
  e.registerPainter("canvas", EN);
}
const LN = { class: "chart-container" }, PN = {
  key: 1,
  class: "chart-wrapper"
}, IN = /* @__PURE__ */ jt({
  __name: "SankeyChart",
  props: {
    data: { default: () => ({ nodes: [], links: [] }) },
    title: { default: "" },
    height: { default: "500px" },
    nodeColors: { default: () => ({}) },
    useGradient: { type: Boolean, default: !0 },
    nodeGap: { default: 20 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    kf([$B, GB, TN, AN]);
    const i = e, { isDark: n, colors: r } = re(ne(i, "theme")), a = Ke(null), o = Ke(!0), s = Ke(!1);
    let l = null;
    const u = {
      animation: { duration: 1e3, easing: "cubicOut" },
      margins: { left: "2%", right: "2%", top: "2%", bottom: "2%" },
      node: { width: 70, gap: 20, align: "left", iterations: 64 },
      style: {
        shadowBlur: 4,
        shadowColor: "rgba(139, 92, 246, 0.15)"
      }
    }, c = [
      "#C67DFF",
      // Primary light
      "#8b5cf6",
      // Primary medium
      "#a855f7",
      // Bright purple
      "#7c3aed",
      // Vibrant purple
      "#5d4b93",
      // Primary dark
      "#9333ea"
      // Deep purple
    ], h = () => {
      const _ = i.data.links.filter(
        (C) => C.source && C.target && typeof C.value == "number"
      ), b = Math.max(..._.map((C) => C.value), 1), w = Math.max(1, b * 0.01), S = _.map((C) => ({
        ...C,
        originalValue: C.value,
        value: C.value < b * 0.01 ? w : C.value
      }));
      return {
        nodes: i.data.nodes.filter((C) => C.name),
        links: S
      };
    }, d = (_) => _.map((b, w) => ({
      ...b,
      itemStyle: {
        color: i.nodeColors[b.name] || c[w % c.length],
        borderRadius: 8
      }
    })), f = (_) => (b) => {
      const w = b.dataType === "node", S = r.value.tooltipText, C = n.value ? "#d1d5db" : "#e2e8f0";
      if (w) {
        const L = _.filter((B) => B.target === b.name), P = _.filter((B) => B.source === b.name), R = L.length > 0 ? L.reduce((B, F) => B + (F.originalValue || F.value), 0) : P.reduce((B, F) => B + (F.originalValue || F.value), 0);
        return `<div style="font-weight: 600; margin-bottom: 4px; color: ${S};">${b.name}</div><div style="color: ${C}; font-size: 12px;">Count: ${R.toLocaleString()}</div>`;
      }
      const T = b.data?.source || b.source || "Unknown", k = b.data?.target || b.target || "Unknown", M = b.data?.originalValue || b.data?.value || b.value || 0, D = b.data?.label || `${M.toLocaleString()}`;
      return `<div style="font-weight: 600; margin-bottom: 4px; color: ${S};">${T}  ${k}</div><div style="color: ${C}; font-size: 12px;">Flow: ${D}</div>`;
    }, v = () => {
      if (!(!l || !i.data.nodes?.length || !i.data.links?.length))
        try {
          const { nodes: _, links: b } = h(), w = d(_), S = {
            tooltip: {
              trigger: "item",
              triggerOn: "mousemove",
              formatter: f(b),
              backgroundColor: r.value.tooltipBg,
              borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
              borderWidth: 1,
              borderRadius: 8,
              padding: [10, 14],
              textStyle: {
                color: r.value.tooltipText,
                fontSize: 13,
                fontFamily: "'DM Sans', sans-serif",
                fontWeight: 500
              },
              shadowBlur: 10,
              shadowColor: "rgba(0, 0, 0, 0.3)"
            },
            series: [
              {
                type: "sankey",
                data: w,
                links: b,
                emphasis: { focus: "adjacency" },
                levels: [
                  {
                    depth: 0,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  },
                  {
                    depth: 1,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  }
                ],
                lineStyle: {
                  color: i.useGradient ? "gradient" : "source",
                  curveness: 0.5,
                  opacity: 0.6
                },
                itemStyle: u.style,
                label: {
                  show: !0,
                  position: "inside",
                  color: "#ffffff",
                  fontWeight: 600,
                  fontSize: 12,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (C) => {
                    const T = C.name || "";
                    return T.length > 15 ? `${T.substring(0, 15)}...` : T;
                  }
                },
                edgeLabel: {
                  show: !0,
                  fontSize: 11,
                  color: r.value.textSecondary,
                  fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (C) => {
                    const T = C.data?.originalValue || C.value || 0;
                    return C.data?.label || `${T.toLocaleString()}`;
                  }
                },
                nodeAlign: u.node.align,
                nodeGap: i.nodeGap,
                nodeWidth: u.node.width,
                layoutIterations: u.node.iterations,
                orient: "horizontal",
                draggable: !1,
                ...u.margins
              }
            ],
            backgroundColor: "transparent",
            animation: !0,
            animationDuration: u.animation.duration,
            animationEasing: u.animation.easing
          };
          l.setOption(S);
        } catch (_) {
          console.error("Error setting Sankey chart options:", _), s.value = !0;
        }
    }, m = async () => {
      if (a.value)
        try {
          l = SR(a.value), v(), window.addEventListener("resize", g);
        } catch (_) {
          console.error("Error initializing Sankey chart:", _), s.value = !0;
        } finally {
          o.value = !1;
        }
    }, p = async (_ = 40) => {
      await R0();
      for (let b = 0; b < _; b++) {
        if (a.value?.clientWidth && a.value.clientWidth > 0 && a.value?.clientHeight && a.value.clientHeight > 0)
          return await m();
        await new Promise((w) => setTimeout(w, 50));
      }
      await m(), setTimeout(g, 50);
    }, g = () => l?.resize(), y = () => {
      window.removeEventListener("resize", g), l && (l.dispose(), l = null);
    };
    return hd(() => a.value && p()), Z1(y), sa(() => i.data, v, { deep: !0 }), sa(n, v), t({ isDark: n }), (_, b) => (A(), I("div", LN, [
      s.value ? (A(), I("div", {
        key: 0,
        class: "error-state",
        style: or({ height: e.height })
      }, [...b[0] || (b[0] = [
        Dt('<div class="error-content" data-v-e8598dd9><svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-e8598dd9><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-e8598dd9></path></svg><p class="error-title" data-v-e8598dd9>Chart could not be loaded</p><p class="error-description" data-v-e8598dd9>Please check the data format.</p></div>', 1)
      ])], 4)) : (A(), I("div", PN, [
        Ff(x("div", {
          ref_key: "chartEl",
          ref: a,
          class: "chart-content",
          style: or({ height: e.height })
        }, null, 4), [
          [$f, !o.value]
        ]),
        Ff(x("div", {
          class: "loading-state",
          style: or({ height: e.height })
        }, [...b[1] || (b[1] = [
          Dt('<div class="loading-container" data-v-e8598dd9><div class="sankey-loader" data-v-e8598dd9><div class="flow flow-1" data-v-e8598dd9></div><div class="flow flow-2" data-v-e8598dd9></div><div class="flow flow-3" data-v-e8598dd9></div><div class="flow flow-4" data-v-e8598dd9></div></div><p class="loading-text" data-v-e8598dd9>Loading Sankey diagram...</p></div>', 1)
        ])], 4), [
          [$f, o.value]
        ])
      ]))
    ]));
  }
}), Mr = /* @__PURE__ */ Vt(IN, [["__scopeId", "data-v-e8598dd9"]]);
function Of(e, t) {
  return A(), I("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z"
    })
  ]);
}
function RN(e, t) {
  return A(), I("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z"
    }),
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z"
    })
  ]);
}
const ON = { class: "chart-footer" }, BN = { class: "export-actions" }, NN = { class: "export-buttons" }, FN = ["disabled"], $N = {
  key: 0,
  class: "spinner",
  width: "14",
  height: "14",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2.5",
  "stroke-linecap": "round"
}, zN = {
  key: 1,
  width: "14",
  height: "14",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, VN = ["disabled"], HN = {
  key: 0,
  class: "spinner",
  width: "14",
  height: "14",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2.5",
  "stroke-linecap": "round"
}, WN = {
  key: 1,
  width: "14",
  height: "14",
  viewBox: "0 0 24 24",
  fill: "none",
  stroke: "currentColor",
  "stroke-width": "2",
  "stroke-linecap": "round",
  "stroke-linejoin": "round"
}, YN = /* @__PURE__ */ jt({
  __name: "FooterExport",
  props: {
    formats: { default: () => ["pdf", "csv"] },
    loading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = e, n = t, r = (o) => i.formats.includes(o), a = (o) => {
      i.loading || n("export", o);
    };
    return (o, s) => (A(), I("footer", ON, [
      s[9] || (s[9] = x("div", { class: "footer-divider" }, null, -1)),
      x("div", BN, [
        s[8] || (s[8] = x("span", { class: "export-label" }, "Export", -1)),
        x("div", NN, [
          r("pdf") ? (A(), I("button", {
            key: 0,
            type: "button",
            class: zf(["export-btn", { "is-loading": e.loading }]),
            disabled: e.loading,
            title: "Download PDF",
            onClick: s[0] || (s[0] = (l) => a("pdf"))
          }, [
            e.loading ? (A(), I("svg", $N, [...s[2] || (s[2] = [
              x("circle", {
                cx: "12",
                cy: "12",
                r: "10",
                "stroke-opacity": "0.25"
              }, null, -1),
              x("path", { d: "M12 2a10 10 0 0 1 10 10" }, null, -1)
            ])])) : (A(), I("svg", zN, [...s[3] || (s[3] = [
              Dt('<path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" data-v-672661d4></path><polyline points="14 2 14 8 20 8" data-v-672661d4></polyline><line x1="16" y1="13" x2="8" y2="13" data-v-672661d4></line><line x1="16" y1="17" x2="8" y2="17" data-v-672661d4></line><polyline points="10 9 9 9 8 9" data-v-672661d4></polyline>', 5)
            ])])),
            s[4] || (s[4] = x("span", null, "PDF", -1))
          ], 10, FN)) : q("", !0),
          r("csv") ? (A(), I("button", {
            key: 1,
            type: "button",
            class: zf(["export-btn", { "is-loading": e.loading }]),
            disabled: e.loading,
            title: "Download CSV",
            onClick: s[1] || (s[1] = (l) => a("csv"))
          }, [
            e.loading ? (A(), I("svg", HN, [...s[5] || (s[5] = [
              x("circle", {
                cx: "12",
                cy: "12",
                r: "10",
                "stroke-opacity": "0.25"
              }, null, -1),
              x("path", { d: "M12 2a10 10 0 0 1 10 10" }, null, -1)
            ])])) : (A(), I("svg", WN, [...s[6] || (s[6] = [
              x("path", { d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }, null, -1),
              x("polyline", { points: "14 2 14 8 20 8" }, null, -1),
              x("line", {
                x1: "12",
                y1: "18",
                x2: "12",
                y2: "12"
              }, null, -1),
              x("line", {
                x1: "9",
                y1: "15",
                x2: "15",
                y2: "15"
              }, null, -1)
            ])])),
            s[7] || (s[7] = x("span", null, "CSV", -1))
          ], 10, VN)) : q("", !0)
        ])
      ])
    ]));
  }
}), Fe = /* @__PURE__ */ Vt(YN, [["__scopeId", "data-v-672661d4"]]), UN = { class: "agents-per-day-card" }, GN = {
  key: 0,
  class: "card-body"
}, XN = {
  key: 0,
  class: "chart-section"
}, jN = {
  key: 1,
  class: "empty-state"
}, qN = { class: "empty-state-content" }, ZN = { class: "empty-icon-wrapper" }, KN = {
  key: 1,
  class: "loading-state"
}, QN = /* @__PURE__ */ jt({
  __name: "AgentsPerDay",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, r = e, a = i, o = (d) => {
      a("export", d);
    }, { isDark: s, colors: l } = re(ne(r, "theme")), u = (d) => {
      const f = new Date(d), v = String(f.getDate()).padStart(2, "0"), m = String(f.getMonth() + 1).padStart(2, "0");
      return `${v}-${m}`;
    }, c = G(() => {
      const d = r.data?.agents_by_day || {}, f = Object.keys(d).sort();
      if (f.length === 0)
        return { labels: [], datasets: [] };
      const v = f.map((_) => u(_)), m = /* @__PURE__ */ new Set();
      for (const _ of Object.values(d))
        for (const b of Object.keys(_))
          m.add(b);
      const p = Array.from(m), g = (_) => _, y = p.map((_) => ({
        label: _,
        data: f.map((b) => d[b]?.[_] || 0),
        backgroundColor: `${n[_] || "#94a3b8"}80`,
        borderColor: g(n[_] || "#94a3b8"),
        borderWidth: 1
      }));
      return {
        labels: v,
        datasets: y
      };
    }), h = G(() => r.options ? r.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: l.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: l.value.tooltipBg,
          titleColor: l.value.tooltipText,
          bodyColor: l.value.tooltipText,
          borderColor: s.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          }
        }
      },
      scales: {
        x: {
          stacked: !0,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: l.value.textSecondary,
            padding: 8
          }
        },
        y: {
          stacked: !0,
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: l.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: l.value.textSecondary,
            padding: 8
          }
        }
      }
    });
    return t({ isDark: s }), (d, f) => (A(), I("article", UN, [
      f[3] || (f[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Agents Total Messages per Day"),
          x("p", { class: "card-subtitle" }, "Daily agent interactions (stacked)")
        ])
      ], -1)),
      e.loading ? (A(), I("div", KN, [...f[2] || (f[2] = [
        Dt('<div class="loading-container" data-v-ae77b001><div class="chart-lines-loader" data-v-ae77b001><div class="line line-1" data-v-ae77b001></div><div class="line line-2" data-v-ae77b001></div><div class="line line-3" data-v-ae77b001></div><div class="line line-4" data-v-ae77b001></div><div class="line line-5" data-v-ae77b001></div></div><p class="loading-text" data-v-ae77b001>Loading chart data...</p></div>', 1)
      ])])) : (A(), I("div", GN, [
        c.value.labels && c.value.labels.length ? (A(), I("section", XN, [
          Qt(Iy, {
            data: c.value,
            options: h.value,
            stacked: !0
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: o,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", jN, [
          x("div", qN, [
            x("div", ZN, [
              Qt(Y(Of), { class: "empty-icon" })
            ]),
            f[0] || (f[0] = x("p", { class: "empty-title" }, "No agents data per day", -1)),
            f[1] || (f[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see daily agent interactions.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), JN = /* @__PURE__ */ Vt(QN, [["__scopeId", "data-v-ae77b001"]]), st = (e) => e == null ? "0" : new Intl.NumberFormat("en-US").format(e), D0 = (e, t = "USD") => e == null ? "$0.00" : new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: t,
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(e), tF = { class: "booking-manager-card" }, eF = { class: "card-header" }, iF = { class: "header-content" }, nF = {
  key: 0,
  class: "payment-success-badge"
}, rF = { class: "badge-value" }, aF = {
  key: 0,
  class: "loading-state"
}, oF = {
  key: 1,
  class: "error-state"
}, sF = { class: "error-content" }, lF = { class: "error-description" }, uF = {
  key: 2,
  class: "card-body"
}, cF = { class: "chart-section" }, hF = { class: "chart-wrapper" }, dF = {
  key: 0,
  class: "table-section"
}, fF = { class: "table-wrapper" }, vF = { class: "data-table" }, pF = { class: "table-body" }, gF = { class: "table-cell font-medium" }, mF = { class: "table-cell text-center" }, yF = { class: "table-cell text-center" }, _F = { class: "percentage-text" }, bF = { class: "table-cell text-center" }, xF = { class: "table-cell" }, wF = { class: "badges-container" }, SF = { class: "badge badge-success" }, CF = { class: "badge badge-error" }, TF = { class: "table-cell" }, MF = { class: "badges-container" }, kF = { class: "badge badge-error" }, DF = { class: "badge badge-warning" }, EF = { class: "badge badge-yellow" }, AF = { class: "badge badge-error" }, LF = {
  key: 1,
  class: "empty-state"
}, PF = /* @__PURE__ */ jt({
  __name: "BookingManager",
  props: {
    data: { default: () => ({
      total_booking_initiated: 0,
      total_booking_started: 0,
      total_payment_initiated: 0,
      total_not_found: 0,
      total_cancelled: 0,
      total_no_pending_balance: 0,
      total_errors: 0,
      total_payment_success: 0,
      total_payment_failed: 0,
      booking_manager_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    error: { default: null },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = e, n = t, r = (u) => {
      n("export", u);
    }, a = G(() => i.data?.booking_manager_by_day ? [...i.data.booking_manager_by_day].sort(
      (u, c) => new Date(u.date).getTime() - new Date(c.date).getTime()
    ) : []), o = G(() => {
      const u = i.data, c = u.total_booking_initiated || 0, h = u.total_booking_started || 0, d = u.total_payment_initiated || 0, f = u.total_not_found || 0, v = u.total_cancelled || 0, m = u.total_no_pending_balance || 0, p = u.total_errors || 0, g = u.total_payment_success || 0, y = u.total_payment_failed || 0, _ = Math.max(0, c - h), b = Math.max(0, h - d - f - v - m - p), w = (T, k) => {
        const M = k > 0 ? Math.round(T / k * 100) : 0;
        return `${T.toLocaleString()} (${M}%)`;
      }, S = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Payment Initiated" },
        { name: "Not Found" },
        { name: "Cancelled" },
        { name: "No Pending Balance" },
        { name: "Errors" },
        { name: "Payment Success" },
        { name: "Payment Failed" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], C = [];
      return h > 0 && C.push({
        source: "Initiated",
        target: "Started",
        value: h,
        label: w(h, c)
      }), _ > 0 && C.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: _,
        label: w(_, c)
      }), d > 0 && C.push({
        source: "Started",
        target: "Payment Initiated",
        value: d,
        label: w(d, h)
      }), f > 0 && C.push({
        source: "Started",
        target: "Not Found",
        value: f,
        label: w(f, h)
      }), v > 0 && C.push({
        source: "Started",
        target: "Cancelled",
        value: v,
        label: w(v, h)
      }), m > 0 && C.push({
        source: "Started",
        target: "No Pending Balance",
        value: m,
        label: w(m, h)
      }), p > 0 && C.push({
        source: "Started",
        target: "Errors",
        value: p,
        label: w(p, h)
      }), b > 0 && C.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: b,
        label: w(b, h)
      }), g > 0 && C.push({
        source: "Payment Initiated",
        target: "Payment Success",
        value: g,
        label: w(g, d)
      }), y > 0 && C.push({
        source: "Payment Initiated",
        target: "Payment Failed",
        value: y,
        label: w(y, d)
      }), { nodes: S, links: C };
    }), s = {
      Initiated: "#DBEAFE",
      Started: "#93C5FD",
      "Payment Initiated": "#FED7AA",
      "Not Found": "#FECACA",
      Cancelled: "#FED7AA",
      "No Pending Balance": "#FEF08A",
      Errors: "#FCA5A5",
      "Payment Success": "#86EFAC",
      "Payment Failed": "#FCA5A5",
      "Abandoned (Init)": "#FEE2E2",
      "Abandoned (Start)": "#FEE2E2"
    }, l = (u, c) => !c || c === 0 ? "0%" : `${Math.round(u / c * 100)}%`;
    return (u, c) => (A(), I("article", tF, [
      x("header", eF, [
        x("div", iF, [
          c[1] || (c[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Booking Manager Metrics"),
            x("p", { class: "card-subtitle" }, "Booking manager workflow tracking and analysis")
          ], -1)),
          i.loading ? q("", !0) : (A(), I("div", nF, [
            c[0] || (c[0] = x("p", { class: "badge-label" }, "Payment Success", -1)),
            x("p", rF, O(Y(st)(i.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      i.loading ? (A(), I("div", aF, [...c[2] || (c[2] = [
        Dt('<div class="loading-container" data-v-6e8e43b2><div class="chart-flow-loader" data-v-6e8e43b2><div class="flow-line flow-1" data-v-6e8e43b2></div><div class="flow-line flow-2" data-v-6e8e43b2></div><div class="flow-line flow-3" data-v-6e8e43b2></div><div class="flow-line flow-4" data-v-6e8e43b2></div><div class="flow-line flow-5" data-v-6e8e43b2></div></div><p class="loading-text" data-v-6e8e43b2>Loading booking data...</p></div>', 1)
      ])])) : i.error ? (A(), I("div", oF, [
        x("div", sF, [
          c[3] || (c[3] = x("div", { class: "error-icon-wrapper" }, [
            x("svg", {
              class: "error-icon",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
            }, [
              x("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              })
            ])
          ], -1)),
          c[4] || (c[4] = x("p", { class: "error-title" }, "Error loading data", -1)),
          x("p", lF, O(i.error), 1)
        ])
      ])) : (A(), I("div", uF, [
        x("section", cF, [
          x("div", hF, [
            Qt(Mr, {
              data: o.value,
              "node-colors": s,
              height: "500px",
              "node-gap": 15
            }, null, 8, ["data"])
          ])
        ]),
        a.value.length > 0 ? (A(), I("section", dF, [
          c[6] || (c[6] = x("div", { class: "section-header" }, [
            x("h4", { class: "section-title" }, "Daily Overview")
          ], -1)),
          x("div", fF, [
            x("table", vF, [
              c[5] || (c[5] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Initiated"),
                  x("th", { class: "table-header" }, "Started"),
                  x("th", { class: "table-header" }, "Payment Initiated"),
                  x("th", { class: "table-header" }, "Payment Results"),
                  x("th", { class: "table-header" }, "Outcomes")
                ])
              ], -1)),
              x("tbody", pF, [
                (A(!0), I(Tt, null, Zt(a.value, (h) => (A(), I("tr", {
                  key: h.date,
                  class: "table-row"
                }, [
                  x("td", gF, O(Y(br)(h.date).format("DD/MM/YYYY")), 1),
                  x("td", mF, O(Y(st)(h.booking_initiated_count)), 1),
                  x("td", yF, [
                    rl(O(Y(st)(h.booking_started_count)) + " ", 1),
                    x("span", _F, " (" + O(l(h.booking_started_count, h.booking_initiated_count)) + ") ", 1)
                  ]),
                  x("td", bF, O(Y(st)(h.payment_initiated_count)), 1),
                  x("td", xF, [
                    x("div", wF, [
                      x("span", SF, " Success: " + O(h.payment_success_count ? Y(st)(h.payment_success_count) : "N/A"), 1),
                      x("span", CF, " Failed: " + O(h.payment_failed_count ? Y(st)(h.payment_failed_count) : "N/A"), 1)
                    ])
                  ]),
                  x("td", TF, [
                    x("div", MF, [
                      x("span", kF, " Not Found: " + O(h.not_found_count ? Y(st)(h.not_found_count) : "N/A"), 1),
                      x("span", DF, " Cancelled: " + O(h.cancelled_count ? Y(st)(h.cancelled_count) : "N/A"), 1),
                      x("span", EF, " No Balance: " + O(h.no_pending_balance_count ? Y(st)(h.no_pending_balance_count) : "N/A"), 1),
                      x("span", AF, " Errors: " + O(h.error_count ? Y(st)(h.error_count) : "N/A"), 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: r,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", LF, [...c[7] || (c[7] = [
          Dt('<div class="empty-state-content" data-v-6e8e43b2><div class="empty-icon-wrapper" data-v-6e8e43b2><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-6e8e43b2><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" data-v-6e8e43b2></path></svg></div><p class="empty-title" data-v-6e8e43b2>No booking manager data available</p><p class="empty-description" data-v-6e8e43b2>No booking manager data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), IF = /* @__PURE__ */ Vt(PF, [["__scopeId", "data-v-6e8e43b2"]]), RF = { class: "checkin-metrics-card" }, OF = {
  key: 0,
  class: "loading-state"
}, BF = {
  key: 1,
  class: "card-body"
}, NF = {
  key: 0,
  class: "chart-section"
}, FF = { class: "chart-wrapper" }, $F = {
  key: 1,
  class: "table-section"
}, zF = { class: "table-wrapper" }, VF = { class: "data-table" }, HF = { class: "table-body" }, WF = { class: "table-cell font-medium" }, YF = { class: "table-cell text-center" }, UF = { class: "table-cell text-center" }, GF = { class: "table-cell text-center" }, XF = { class: "table-cell text-center" }, jF = { class: "table-cell text-center" }, qF = { class: "table-cell text-center" }, ZF = { class: "table-cell text-left" }, KF = {
  key: 0,
  class: "failed-steps"
}, QF = { class: "step-name" }, JF = { class: "step-count" }, t4 = {
  key: 1,
  class: "empty-cell"
}, e4 = {
  key: 2,
  class: "empty-state"
}, i4 = {
  __name: "Checkin",
  props: {
    loading: {
      type: Boolean,
      default: !1
    },
    enableExport: {
      type: Boolean,
      default: !1
    },
    exportLoading: {
      type: Boolean,
      default: !1
    },
    checkinData: {
      type: Object,
      default: () => ({
        total_checkin_init: 0,
        total_checkin_initiated: 0,
        total_checkin_init_abandoned: 0,
        total_checkin_started: 0,
        total_checkin_completed: 0,
        total_checkin_closed: 0,
        total_checkin_unrecovered: 0,
        checkin_by_day: []
      })
    },
    failedData: {
      type: Object,
      default: () => ({
        total_checkin_failed: 0,
        failed_by_step_by_day: [],
        unrecovered_by_step: []
      })
    }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = t, n = (p) => {
      i("export", p);
    }, r = e, a = {
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }, o = {
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }, s = Ke([]), l = G(() => r.checkinData ?? a), u = G(() => r.failedData ?? o), c = G(() => {
      const p = {
        // Main flow progression - from blue to purple to green
        "Checkin Init": "#93C5FD",
        // Blue for started state
        "Booking retrive": "#C7D2FE",
        // Light purple
        "Booking retrive success": "#A5B4FC",
        // Medium purple for success
        "Number of Passengers": "#8B8CF6",
        // Medium purple
        Completed: "#A7F3D0",
        // Light green
        "Closed with BP": "#7BE39E",
        // Green for success
        // Abandoned states - progressive yellow/orange
        "Abandoned (Init)": "#FCA5A5",
        // Light red
        "Abandoned (Started)": "#F87171",
        // Medium red
        "Abandoned (Flow)": "#EF4444",
        // Darker red
        "BP Error": "#EF4444",
        // Darker red for boarding pass error
        // Failed states - progressive red intensity
        Unrecovered: "#F87171"
        // Medium red for main unrecovered node
      };
      return (u.value.unrecovered_by_step || []).forEach((y) => {
        const b = y.step_name.replace(/_/g, " ").split(" ").map((S) => S.charAt(0).toUpperCase() + S.slice(1)).join(" "), w = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        p[b] = w[b] || "#DC2626";
      }), p;
    }), h = (p, g) => !g || g === 0 ? "0%" : `${Math.round(p / g * 100)}%`, d = (p, g) => {
      const y = st(p), _ = h(p, g);
      return `${y} (${_})`;
    }, f = (p) => p.reduce((g, y) => g + y.failed_count, 0), v = G(() => {
      const p = [], g = [];
      if (!l.value.total_checkin_initiated)
        return { nodes: p, links: g };
      p.push({ name: "Checkin Init" }), p.push({ name: "Booking retrive" }), p.push({ name: "Booking retrive success" }), p.push({ name: "Number of Passengers" }), p.push({ name: "Completed" }), p.push({ name: "Closed with BP" });
      const y = l.value.total_checkin_initiated, _ = l.value.total_checkin_init, b = l.value.total_checkin_init_abandoned, w = _ - b, S = l.value.total_checkin_started, C = l.value.total_checkin_completed, T = l.value.total_checkin_closed, k = u.value.unrecovered_by_step || [], M = k.reduce((R, B) => R + B.count, 0);
      if (console.log(JSON.stringify(l.value)), _ > 0) {
        const R = Math.round(_ / y * 100);
        g.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: _,
          label: `${_.toLocaleString()} (${R}%)`
        });
      }
      const D = y - _;
      if (D > 0) {
        const R = Math.round(D / y * 100);
        p.push({ name: "Abandoned (Init)" }), g.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: D,
          label: `${D.toLocaleString()} (${R}%)`
        });
      }
      if (b > 0) {
        const R = Math.round(b / y * 100);
        p.push({ name: "Abandoned (Started)" }), g.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: b,
          label: `${b.toLocaleString()} (${R}%)`
        });
      }
      if (w > 0) {
        const R = Math.round(w / y * 100);
        g.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: w,
          label: `${w.toLocaleString()} (${R}%)`
        });
      }
      if (S > 0) {
        const R = Math.round(S / y * 100);
        g.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: S,
          label: `${S.toLocaleString()} (${R}%)`
        });
      }
      if (C > 0) {
        const R = Math.round(C / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Completed",
          value: C,
          label: `${C.toLocaleString()} (${R}%)`
        });
      }
      if (k.length > 0 && M > 0) {
        p.push({ name: "Unrecovered" });
        const R = Math.round(M / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: M,
          label: `${M.toLocaleString()} (${R}%)`
        }), k.forEach((B) => {
          const W = B.step_name.replace(/_/g, " ").split(" ").map((N) => N.charAt(0).toUpperCase() + N.slice(1)).join(" "), z = Math.round(B.count / S * 100);
          p.push({ name: W }), g.push({
            source: "Unrecovered",
            target: W,
            value: B.count,
            label: `${B.count.toLocaleString()} (${z}%)`
          });
        });
      }
      const L = S - (C + M);
      if (L > 0) {
        const R = Math.round(L / S * 100);
        p.push({ name: "Abandoned (Flow)" }), g.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: L,
          label: `${L.toLocaleString()} (${R}%)`
        });
      }
      const P = C - T;
      if (P > 0) {
        const R = Math.round(P / S * 100);
        p.push({ name: "BP Error" }), g.push({
          source: "Completed",
          target: "BP Error",
          value: P,
          label: `${P.toLocaleString()} (${R}%)`
        });
      }
      if (T > 0) {
        const R = Math.round(T / S * 100);
        g.push({
          source: "Completed",
          target: "Closed with BP",
          value: T,
          label: `${T.toLocaleString()} (${R}%)`
        });
      }
      return console.log(JSON.stringify(p)), console.log(JSON.stringify(g)), { nodes: p, links: g };
    }), m = () => {
      const p = l.value.checkin_by_day || [], g = u.value.failed_by_step_by_day || [];
      if (p.length === 0) {
        s.value = [];
        return;
      }
      s.value = [...p].map((y) => {
        const _ = g.find(
          (b) => b.date === y.date
        );
        return {
          ...y,
          failed_steps: _?.steps || []
        };
      }), s.value.sort((y, _) => new Date(y.date) - new Date(_.date));
    };
    return sa(
      [() => r.checkinData, () => r.failedData],
      () => {
        m();
      },
      { deep: !0, immediate: !0 }
    ), (p, g) => (A(), I("article", RF, [
      g[3] || (g[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Check-in Metrics"),
          x("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      r.loading ? (A(), I("div", OF, [...g[0] || (g[0] = [
        Dt('<div class="loading-container" data-v-e1510867><div class="chart-flow-loader" data-v-e1510867><div class="flow-line flow-1" data-v-e1510867></div><div class="flow-line flow-2" data-v-e1510867></div><div class="flow-line flow-3" data-v-e1510867></div><div class="flow-line flow-4" data-v-e1510867></div><div class="flow-line flow-5" data-v-e1510867></div></div><p class="loading-text" data-v-e1510867>Loading check-in data...</p></div>', 1)
      ])])) : (A(), I("div", BF, [
        v.value.nodes.length > 0 ? (A(), I("section", NF, [
          x("div", FF, [
            Qt(Mr, {
              data: v.value,
              height: "500px",
              "node-colors": c.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : q("", !0),
        s.value && s.value.length > 0 ? (A(), I("section", $F, [
          x("div", zF, [
            x("table", VF, [
              g[1] || (g[1] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Checkin Init"),
                  x("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  x("th", { class: "table-header" }, "Number of Passengers"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed with BP (%)"),
                  x("th", { class: "table-header" }, "Failed (%)"),
                  x("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              x("tbody", HF, [
                (A(!0), I(Tt, null, Zt(s.value, (y) => (A(), I("tr", {
                  key: y.date,
                  class: "table-row"
                }, [
                  x("td", WF, O(Y(br)(y.date).format("DD/MM/YYYY")), 1),
                  x("td", YF, O(Y(st)(y.checkin_initiated_count)), 1),
                  x("td", UF, O(d(y.checkin_init_count, y.checkin_initiated_count)), 1),
                  x("td", GF, O(Y(st)(y.checkin_started_count)), 1),
                  x("td", XF, O(d(y.checkin_completed_count, y.checkin_started_count)), 1),
                  x("td", jF, O(d(y.checkin_closed_count, y.checkin_started_count)), 1),
                  x("td", qF, O(d(f(y.failed_steps), y.checkin_started_count)), 1),
                  x("td", ZF, [
                    y.failed_steps && y.failed_steps.length > 0 ? (A(), I("div", KF, [
                      (A(!0), I(Tt, null, Zt(y.failed_steps, (_) => (A(), I("div", {
                        key: _.step_name,
                        class: "failed-step-item"
                      }, [
                        x("span", QF, O(_.step_name.replace(/_/g, " ")) + ":", 1),
                        x("span", JF, O(_.failed_count), 1)
                      ]))), 128))
                    ])) : (A(), I("div", t4, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: n,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", e4, [...g[2] || (g[2] = [
          Dt('<div class="empty-state-content" data-v-e1510867><div class="empty-icon-wrapper" data-v-e1510867><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-e1510867><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-e1510867></path></svg></div><p class="empty-title" data-v-e1510867>No check-in data available</p><p class="empty-description" data-v-e1510867>Try adjusting the date range or check your filters to see check-in performance data.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}, n4 = /* @__PURE__ */ Vt(i4, [["__scopeId", "data-v-e1510867"]]), r4 = { class: "checkin-metrics-card" }, a4 = {
  key: 0,
  class: "loading-state"
}, o4 = {
  key: 1,
  class: "card-body"
}, s4 = {
  key: 0,
  class: "sankey-section"
}, l4 = {
  key: 1,
  class: "table-section"
}, u4 = { class: "table-wrapper" }, c4 = { class: "data-table" }, h4 = { class: "table-body" }, d4 = { class: "table-cell date-cell" }, f4 = { class: "table-cell text-center" }, v4 = { class: "table-cell text-center" }, p4 = { class: "table-cell text-center" }, g4 = { class: "table-cell text-center" }, m4 = { class: "table-cell text-center" }, y4 = { class: "table-cell text-center" }, _4 = { class: "table-cell reasons-cell" }, b4 = {
  key: 0,
  class: "reasons-list"
}, x4 = { class: "reason-name" }, w4 = { class: "reason-count" }, S4 = {
  key: 1,
  class: "no-reasons"
}, C4 = {
  key: 2,
  class: "empty-state"
}, T4 = { class: "empty-state-content" }, M4 = { class: "empty-icon-wrapper" }, k4 = /* @__PURE__ */ jt({
  __name: "CheckinMetrics",
  props: {
    checkinData: { default: () => ({
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }) },
    failedData: { default: () => ({
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }) },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (p) => {
      r("export", p);
    }, { isDark: o } = re(ne(n, "theme")), s = (p) => p == null ? "0" : p.toLocaleString(), l = (p) => {
      const g = new Date(p), y = String(g.getDate()).padStart(2, "0"), _ = String(g.getMonth() + 1).padStart(2, "0"), b = g.getFullYear();
      return `${y}/${_}/${b}`;
    }, u = (p) => p.replace(/_/g, " ").replace(/\b\w/g, (g) => g.toUpperCase()), c = (p, g) => !g || g === 0 ? "0%" : `${Math.round(p / g * 100)}%`, h = (p, g) => {
      const y = p || 0, _ = g || 0, b = s(y), w = c(y, _);
      return `${b} (${w})`;
    }, d = (p) => p ? p.reduce((g, y) => g + y.failed_count, 0) : 0, f = G(() => {
      const p = {
        "Checkin Init": "#93C5FD",
        "Booking retrive": "#C7D2FE",
        "Booking retrive success": "#A5B4FC",
        "Number of Passengers": "#8B8CF6",
        Completed: "#A7F3D0",
        "Closed with BP": "#7BE39E",
        "Abandoned (Init)": "#FCA5A5",
        "Abandoned (Started)": "#F87171",
        "Abandoned (Flow)": "#EF4444",
        "BP Error": "#EF4444",
        Unrecovered: "#F87171"
      };
      return (n.failedData?.unrecovered_by_step || []).forEach((y) => {
        const b = y.step_name.replace(/_/g, " ").split(" ").map((S) => S.charAt(0).toUpperCase() + S.slice(1)).join(" "), w = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        p[b] = w[b] || "#DC2626";
      }), p;
    }), v = G(() => {
      const p = n.checkinData?.checkin_by_day || [], g = n.failedData?.failed_by_step_by_day || [];
      return p.map((_) => {
        const b = g.find((w) => w.date === _.date);
        return {
          ..._,
          failed_steps: b?.steps || []
        };
      }).sort((_, b) => new Date(_.date).getTime() - new Date(b.date).getTime());
    }), m = G(() => {
      const p = [], g = [];
      if (!n.checkinData?.total_checkin_initiated)
        return { nodes: p, links: g };
      p.push({ name: "Checkin Init" }), p.push({ name: "Booking retrive" }), p.push({ name: "Booking retrive success" }), p.push({ name: "Number of Passengers" }), p.push({ name: "Completed" }), p.push({ name: "Closed with BP" });
      const y = n.checkinData.total_checkin_initiated || 0, _ = n.checkinData.total_checkin_init || 0, b = n.checkinData.total_checkin_init_abandoned || 0, w = _ - b, S = n.checkinData.total_checkin_started || 0, C = n.checkinData.total_checkin_completed || 0, T = n.checkinData.total_checkin_closed || 0, k = n.failedData?.unrecovered_by_step || [], M = k.reduce((R, B) => R + B.count, 0);
      if (_ > 0) {
        const R = Math.round(_ / y * 100);
        g.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: _,
          label: `${_.toLocaleString()} (${R}%)`
        });
      }
      const D = y - _;
      if (D > 0) {
        const R = Math.round(D / y * 100);
        p.push({ name: "Abandoned (Init)" }), g.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: D,
          label: `${D.toLocaleString()} (${R}%)`
        });
      }
      if (b > 0) {
        const R = Math.round(b / y * 100);
        p.push({ name: "Abandoned (Started)" }), g.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: b,
          label: `${b.toLocaleString()} (${R}%)`
        });
      }
      if (w > 0) {
        const R = Math.round(w / y * 100);
        g.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: w,
          label: `${w.toLocaleString()} (${R}%)`
        });
      }
      if (S > 0) {
        const R = Math.round(S / y * 100);
        g.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: S,
          label: `${S.toLocaleString()} (${R}%)`
        });
      }
      if (C > 0) {
        const R = Math.round(C / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Completed",
          value: C,
          label: `${C.toLocaleString()} (${R}%)`
        });
      }
      if (k.length > 0 && M > 0) {
        p.push({ name: "Unrecovered" });
        const R = Math.round(M / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: M,
          label: `${M.toLocaleString()} (${R}%)`
        }), k.forEach((B) => {
          const W = B.step_name.replace(/_/g, " ").split(" ").map((N) => N.charAt(0).toUpperCase() + N.slice(1)).join(" "), z = Math.round(B.count / S * 100);
          p.push({ name: W }), g.push({
            source: "Unrecovered",
            target: W,
            value: B.count,
            label: `${B.count.toLocaleString()} (${z}%)`
          });
        });
      }
      const L = S - (C + M);
      if (L > 0) {
        const R = Math.round(L / S * 100);
        p.push({ name: "Abandoned (Flow)" }), g.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: L,
          label: `${L.toLocaleString()} (${R}%)`
        });
      }
      const P = C - T;
      if (P > 0) {
        const R = Math.round(P / S * 100);
        p.push({ name: "BP Error" }), g.push({
          source: "Completed",
          target: "BP Error",
          value: P,
          label: `${P.toLocaleString()} (${R}%)`
        });
      }
      if (T > 0) {
        const R = Math.round(T / S * 100);
        g.push({
          source: "Completed",
          target: "Closed with BP",
          value: T,
          label: `${T.toLocaleString()} (${R}%)`
        });
      }
      return { nodes: p, links: g };
    });
    return t({ isDark: o }), (p, g) => (A(), I("article", r4, [
      g[4] || (g[4] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Check-in Metrics"),
          x("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      e.loading ? (A(), I("div", a4, [...g[0] || (g[0] = [
        Dt('<div class="loading-container" data-v-09223de5><div class="chart-bars-loader" data-v-09223de5><div class="bar bar-1" data-v-09223de5></div><div class="bar bar-2" data-v-09223de5></div><div class="bar bar-3" data-v-09223de5></div><div class="bar bar-4" data-v-09223de5></div><div class="bar bar-5" data-v-09223de5></div></div><p class="loading-text" data-v-09223de5>Loading check-in data...</p></div>', 1)
      ])])) : (A(), I("div", o4, [
        m.value.nodes.length > 0 ? (A(), I("div", s4, [
          Qt(Mr, {
            data: m.value,
            height: "500px",
            "node-colors": f.value,
            "use-gradient": !1,
            "node-gap": 30
          }, null, 8, ["data", "node-colors"])
        ])) : q("", !0),
        v.value && v.value.length > 0 ? (A(), I("div", l4, [
          x("div", u4, [
            x("table", c4, [
              g[1] || (g[1] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Checkin Init"),
                  x("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  x("th", { class: "table-header" }, "Number of Passengers"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed with BP (%)"),
                  x("th", { class: "table-header" }, "Failed (%)"),
                  x("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              x("tbody", h4, [
                (A(!0), I(Tt, null, Zt(v.value, (y) => (A(), I("tr", {
                  key: y.date,
                  class: "table-row"
                }, [
                  x("td", d4, O(l(y.date)), 1),
                  x("td", f4, O(s(y.checkin_initiated_count)), 1),
                  x("td", v4, O(h(y.checkin_init_count, y.checkin_initiated_count)), 1),
                  x("td", p4, O(s(y.checkin_started_count)), 1),
                  x("td", g4, O(h(y.checkin_completed_count, y.checkin_started_count)), 1),
                  x("td", m4, O(h(y.checkin_closed_count, y.checkin_started_count)), 1),
                  x("td", y4, O(h(d(y.failed_steps), y.checkin_started_count)), 1),
                  x("td", _4, [
                    y.failed_steps && y.failed_steps.length > 0 ? (A(), I("div", b4, [
                      (A(!0), I(Tt, null, Zt(y.failed_steps, (_) => (A(), I("div", {
                        key: _.step_name,
                        class: "reason-item"
                      }, [
                        x("span", x4, O(u(_.step_name)) + ":", 1),
                        x("span", w4, O(_.failed_count), 1)
                      ]))), 128))
                    ])) : (A(), I("div", S4, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: a,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("div", C4, [
          x("div", T4, [
            x("div", M4, [
              Qt(Y(Of), { class: "empty-icon" })
            ]),
            g[2] || (g[2] = x("p", { class: "empty-title" }, "No check-in data available", -1)),
            g[3] || (g[3] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see check-in metrics.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), D4 = /* @__PURE__ */ Vt(k4, [["__scopeId", "data-v-09223de5"]]), E4 = { class: "checkin-segments-card" }, A4 = {
  key: 0,
  class: "loading-state"
}, L4 = {
  key: 1,
  class: "card-body"
}, P4 = {
  key: 0,
  class: "table-section"
}, I4 = { class: "table-wrapper" }, R4 = { class: "data-table" }, O4 = { class: "table-body" }, B4 = { class: "table-cell font-medium text-center" }, N4 = { class: "airport-badge" }, F4 = { class: "table-cell text-center" }, $4 = {
  key: 0,
  class: "airport-badge connection"
}, z4 = {
  key: 1,
  class: "empty-connection"
}, V4 = { class: "table-cell text-center" }, H4 = { class: "airport-badge" }, W4 = { class: "table-cell text-center" }, Y4 = {
  key: 0,
  class: "trip-badge roundtrip"
}, U4 = {
  key: 1,
  class: "trip-badge oneway"
}, G4 = { class: "table-cell text-center" }, X4 = { class: "table-cell text-center" }, j4 = { class: "percentage-value" }, q4 = { class: "table-cell text-center" }, Z4 = { class: "percentage-value" }, K4 = { class: "table-cell text-center" }, Q4 = { class: "percentage-value success" }, J4 = {
  key: 1,
  class: "empty-state"
}, t3 = /* @__PURE__ */ jt({
  __name: "checkinSegments",
  props: {
    data: { default: () => [] },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (c) => {
      r("export", c);
    }, { isDark: o } = re(ne(n, "theme")), s = (c, h) => !h || h === 0 || !c ? "0%" : `${Math.round(c / h * 100)}%`, l = (c) => !c || c === "None" ? "-" : String(c).trim().replace(/_[0-9]+$/i, ""), u = (c) => {
      const h = l(c?.departure_airport), d = l(c?.arrival_airport);
      return h === "-" || d === "-" ? !1 : h === d;
    };
    return t({ isDark: o }), (c, h) => (A(), I("article", E4, [
      h[5] || (h[5] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Checkin Segments"),
          x("p", { class: "card-subtitle" }, "Breakdown by flight segment with connection when applicable")
        ])
      ], -1)),
      n.loading ? (A(), I("div", A4, [...h[0] || (h[0] = [
        Dt('<div class="loading-container" data-v-b85af215><div class="chart-flow-loader" data-v-b85af215><div class="flow-line flow-1" data-v-b85af215></div><div class="flow-line flow-2" data-v-b85af215></div><div class="flow-line flow-3" data-v-b85af215></div><div class="flow-line flow-4" data-v-b85af215></div><div class="flow-line flow-5" data-v-b85af215></div></div><p class="loading-text" data-v-b85af215>Loading segment data...</p></div>', 1)
      ])])) : (A(), I("div", L4, [
        n.data.length > 0 ? (A(), I("section", P4, [
          x("div", I4, [
            x("table", R4, [
              h[3] || (h[3] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Departure"),
                  x("th", { class: "table-header" }, "Connection"),
                  x("th", { class: "table-header" }, "Arrival"),
                  x("th", { class: "table-header" }, "Trip"),
                  x("th", { class: "table-header" }, "Init"),
                  x("th", { class: "table-header" }, "Started (%)"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed (%)")
                ])
              ], -1)),
              x("tbody", O4, [
                (A(!0), I(Tt, null, Zt(n.data, (d, f) => (A(), I("tr", {
                  key: f,
                  class: "table-row"
                }, [
                  x("td", B4, [
                    x("span", N4, O(l(d.departure_airport)), 1)
                  ]),
                  x("td", F4, [
                    l(d.conexion_airport) !== "-" ? (A(), I("span", $4, O(l(d.conexion_airport)), 1)) : (A(), I("span", z4, "-"))
                  ]),
                  x("td", V4, [
                    x("span", H4, O(l(d.arrival_airport)), 1)
                  ]),
                  x("td", W4, [
                    u(d) ? (A(), I("span", Y4, [...h[1] || (h[1] = [
                      x("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        x("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                        })
                      ], -1),
                      rl(" Roundtrip ", -1)
                    ])])) : (A(), I("span", U4, [...h[2] || (h[2] = [
                      x("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        x("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M14 5l7 7m0 0l-7 7m7-7H3"
                        })
                      ], -1),
                      rl(" One way ", -1)
                    ])]))
                  ]),
                  x("td", G4, O(Y(st)(d.segment_init_count)), 1),
                  x("td", X4, [
                    x("span", j4, O(s(d.segment_started_count, d.segment_init_count)), 1)
                  ]),
                  x("td", q4, [
                    x("span", Z4, O(s(d.segment_completed_count, d.segment_init_count)), 1)
                  ]),
                  x("td", K4, [
                    x("span", Q4, O(s(d.segment_closed_count, d.segment_init_count)), 1)
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: a,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", J4, [...h[4] || (h[4] = [
          Dt('<div class="empty-state-content" data-v-b85af215><div class="empty-icon-wrapper" data-v-b85af215><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-b85af215><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-b85af215></path></svg></div><p class="empty-title" data-v-b85af215>No segment data available</p><p class="empty-description" data-v-b85af215>No flight segment data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), e3 = /* @__PURE__ */ Vt(t3, [["__scopeId", "data-v-b85af215"]]), i3 = { class: "disruption-metrics-card" }, n3 = { class: "card-header" }, r3 = { class: "header-content" }, a3 = {
  key: 0,
  class: "payment-success-badge"
}, o3 = { class: "badge-value" }, s3 = {
  key: 0,
  class: "loading-state"
}, l3 = {
  key: 1,
  class: "card-body"
}, u3 = { class: "chart-section" }, c3 = { class: "chart-wrapper" }, h3 = {
  key: 1,
  class: "empty-chart"
}, d3 = {
  key: 0,
  class: "table-section"
}, f3 = { class: "table-wrapper" }, v3 = { class: "data-table" }, p3 = { class: "table-body" }, g3 = { class: "table-cell font-medium text-center" }, m3 = { class: "table-cell text-center" }, y3 = { class: "table-cell text-center" }, _3 = { class: "percentage-text" }, b3 = { class: "table-cell text-center" }, x3 = { class: "abandoned-value" }, w3 = { class: "table-cell" }, S3 = { class: "badges-container badges-wrap" }, C3 = { class: "badge badge-vol" }, T3 = { class: "badge badge-confirm" }, M3 = { class: "badge badge-not-confirm" }, k3 = { class: "badge badge-reject" }, D3 = { class: "badge badge-not-paid" }, E3 = { class: "badge badge-success" }, A3 = { class: "table-cell" }, L3 = { class: "badges-container badges-wrap" }, P3 = { class: "badge badge-inv" }, I3 = { class: "badge badge-human" }, R3 = { class: "badge badge-accept" }, O3 = {
  key: 1,
  class: "empty-state"
}, B3 = /* @__PURE__ */ jt({
  __name: "Disruption",
  props: {
    data: { default: () => ({
      total_disruption_conversations: 0,
      total_disruption_initiated: 0,
      total_voluntary: 0,
      total_involuntary: 0,
      total_accepted: 0,
      total_confirmed: 0,
      total_sell_success: 0,
      total_sell_failed: 0,
      total_finished: 0,
      total_payment_success: 0,
      disruption_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = e, n = t, r = (u) => {
      n("export", u);
    }, a = G(() => i.data?.disruption_by_day ? [...i.data.disruption_by_day].sort(
      (u, c) => new Date(u.date).getTime() - new Date(c.date).getTime()
    ) : []), o = (u, c) => !c || c === 0 ? "0%" : `${Math.round(u / c * 100)}%`, s = G(() => {
      const u = i.data, c = u.total_disruption_conversations || 0, h = u.total_disruption_initiated || 0, d = u.total_voluntary || 0, f = u.total_involuntary || 0, v = u.total_accepted || 0, m = u.total_confirmed || 0, p = u.total_sell_success || 0, g = u.total_sell_failed || 0, y = Math.max(0, c - h), _ = Math.max(0, h - d - f), b = Math.max(0, f - v), w = Math.max(0, d - m), S = g, C = Math.max(0, m - p - S), T = (D, L) => {
        const P = L > 0 ? Math.round(D / L * 100) : 0;
        return `${D.toLocaleString()} (${P}%)`;
      }, k = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Voluntary" },
        { name: "Confirmed" },
        { name: "Paid" },
        { name: "Not Paid" },
        { name: "Rejected" },
        { name: "Not Confirmed" },
        { name: "Involuntary" },
        { name: "Accepted" },
        { name: "Redirect to Human" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], M = [];
      return h > 0 && M.push({
        source: "Initiated",
        target: "Started",
        value: h,
        label: T(h, c)
      }), y > 0 && M.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: y,
        label: T(y, c)
      }), d > 0 && M.push({
        source: "Started",
        target: "Voluntary",
        value: d,
        label: T(d, c)
      }), f > 0 && M.push({
        source: "Started",
        target: "Involuntary",
        value: f,
        label: T(f, c)
      }), _ > 0 && M.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: _,
        label: T(_, c)
      }), v > 0 && M.push({
        source: "Involuntary",
        target: "Accepted",
        value: v,
        label: T(v, c)
      }), b > 0 && M.push({
        source: "Involuntary",
        target: "Redirect to Human",
        value: b,
        label: T(b, c)
      }), m > 0 && M.push({
        source: "Voluntary",
        target: "Confirmed",
        value: m,
        label: T(m, c)
      }), w > 0 && M.push({
        source: "Voluntary",
        target: "Not Confirmed",
        value: w,
        label: T(w, c)
      }), p > 0 && M.push({
        source: "Confirmed",
        target: "Paid",
        value: p,
        label: T(p, c)
      }), S > 0 && M.push({
        source: "Confirmed",
        target: "Rejected",
        value: S,
        label: T(S, c)
      }), C > 0 && M.push({
        source: "Confirmed",
        target: "Not Paid",
        value: C,
        label: T(C, c)
      }), { nodes: k, links: M };
    }), l = {
      Initiated: "#E5E7EB",
      Started: "#DBEAFE",
      "Abandoned (Start)": "#FEE2E2",
      Voluntary: "#FED7AA",
      Involuntary: "#E9D5FF",
      "Abandoned (Init)": "#FEE2E2",
      Accepted: "#86EFAC",
      "Redirect to Human": "#FCA5A5",
      Confirmed: "#BFDBFE",
      "Not Confirmed": "#FED7AA",
      Paid: "#86EFAC",
      Rejected: "#FCA5A5",
      "Not Paid": "#FED7AA"
    };
    return (u, c) => (A(), I("article", i3, [
      x("header", n3, [
        x("div", r3, [
          c[1] || (c[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Disruption Metrics"),
            x("p", { class: "card-subtitle" }, "Disruption workflow performance and completion tracking")
          ], -1)),
          i.loading ? q("", !0) : (A(), I("div", a3, [
            c[0] || (c[0] = x("p", { class: "badge-label" }, "Payment Success", -1)),
            x("p", o3, O(Y(st)(i.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      i.loading ? (A(), I("div", s3, [...c[2] || (c[2] = [
        Dt('<div class="loading-container" data-v-e98bf459><div class="chart-bars-loader" data-v-e98bf459><div class="bar bar-1" data-v-e98bf459></div><div class="bar bar-2" data-v-e98bf459></div><div class="bar bar-3" data-v-e98bf459></div><div class="bar bar-4" data-v-e98bf459></div><div class="bar bar-5" data-v-e98bf459></div></div><p class="loading-text" data-v-e98bf459>Loading disruption data...</p></div>', 1)
      ])])) : (A(), I("div", l3, [
        x("section", u3, [
          x("div", c3, [
            s.value.nodes.length > 0 && s.value.links.length > 0 ? (A(), _e(Mr, {
              key: 0,
              data: s.value,
              "node-colors": l,
              height: "500px"
            }, null, 8, ["data"])) : (A(), I("div", h3, [...c[3] || (c[3] = [
              x("p", { class: "empty-chart-text" }, "No disruption data available for visualization", -1)
            ])]))
          ])
        ]),
        a.value && a.value.length > 0 ? (A(), I("section", d3, [
          c[5] || (c[5] = Dt('<div class="section-header" data-v-e98bf459><h4 class="section-title" data-v-e98bf459>Daily Overview</h4></div><div class="legend-container" data-v-e98bf459><p class="legend-title" data-v-e98bf459>Legend</p><div class="legend-items" data-v-e98bf459><div class="legend-group" data-v-e98bf459><span class="legend-label" data-v-e98bf459>Voluntary:</span><span class="badge badge-vol" data-v-e98bf459>VOL</span></div><div class="legend-group" data-v-e98bf459><span class="legend-label" data-v-e98bf459>Involuntary:</span><span class="badge badge-inv" data-v-e98bf459>INV</span></div><div class="legend-note" data-v-e98bf459><span data-v-e98bf459>Vol=Voluntary</span><span data-v-e98bf459></span><span data-v-e98bf459>Inv=Involuntary</span></div></div></div>', 2)),
          x("div", f3, [
            x("table", v3, [
              c[4] || (c[4] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Initiated"),
                  x("th", { class: "table-header" }, "Started"),
                  x("th", { class: "table-header" }, "Abandoned (%)"),
                  x("th", { class: "table-header" }, "Voluntary"),
                  x("th", { class: "table-header" }, "Involuntary")
                ])
              ], -1)),
              x("tbody", p3, [
                (A(!0), I(Tt, null, Zt(a.value, (h) => (A(), I("tr", {
                  key: h.date,
                  class: "table-row"
                }, [
                  x("td", g3, O(Y(br)(h.date).format("DD/MM")), 1),
                  x("td", m3, O(Y(st)(h.disruption_conversations)), 1),
                  x("td", y3, [
                    rl(O(Y(st)(h.disruption_initiated_count)) + " ", 1),
                    x("span", _3, " (" + O(o(h.disruption_initiated_count, h.disruption_conversations)) + ") ", 1)
                  ]),
                  x("td", b3, [
                    x("span", x3, O(Y(st)(h.disruption_initiated_count - h.voluntary_count - h.involuntary_count)) + " (" + O(o(h.disruption_initiated_count - h.voluntary_count - h.involuntary_count, h.disruption_conversations)) + ") ", 1)
                  ]),
                  x("td", w3, [
                    x("div", S3, [
                      x("span", C3, " VOL " + O(Y(st)(h.voluntary_count)) + " (" + O(o(h.voluntary_count, h.disruption_conversations)) + ") ", 1),
                      x("span", T3, " Confirm " + O(Y(st)(h.confirmed_count)) + " (" + O(o(h.confirmed_count, h.disruption_conversations)) + ") ", 1),
                      x("span", M3, " Not Confirm " + O(Y(st)(h.voluntary_count - h.confirmed_count)) + " (" + O(o(h.voluntary_count - h.confirmed_count, h.disruption_conversations)) + ") ", 1),
                      x("span", k3, " Reject " + O(Y(st)(h.sell_failed_count)) + " (" + O(o(h.sell_failed_count, h.disruption_conversations)) + ") ", 1),
                      x("span", D3, " Not Paid " + O(Y(st)(Math.max(0, h.confirmed_count - h.sell_success_count - h.sell_failed_count))) + " (" + O(o(Math.max(0, h.confirmed_count - h.sell_success_count - h.sell_failed_count), h.disruption_conversations)) + ") ", 1),
                      x("span", E3, " Finish " + O(Y(st)(h.sell_success_count)) + " (" + O(o(h.sell_success_count, h.disruption_conversations)) + ") ", 1)
                    ])
                  ]),
                  x("td", A3, [
                    x("div", L3, [
                      x("span", P3, " INV " + O(Y(st)(h.involuntary_count)) + " (" + O(o(h.involuntary_count, h.disruption_conversations)) + ") ", 1),
                      x("span", I3, " Human " + O(Y(st)(h.involuntary_count - h.accepted_count)) + " (" + O(o(h.involuntary_count - h.accepted_count, h.disruption_conversations)) + ") ", 1),
                      x("span", R3, " Accept " + O(Y(st)(h.accepted_count)) + " (" + O(o(h.accepted_count, h.disruption_conversations)) + ") ", 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: r,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", O3, [...c[6] || (c[6] = [
          Dt('<div class="empty-state-content" data-v-e98bf459><div class="empty-icon-wrapper" data-v-e98bf459><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-e98bf459><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" data-v-e98bf459></path></svg></div><p class="empty-title" data-v-e98bf459>No disruption data available</p><p class="empty-description" data-v-e98bf459>No disruption data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), N3 = /* @__PURE__ */ Vt(B3, [["__scopeId", "data-v-e98bf459"]]), F3 = { class: "faq-metrics-card" }, $3 = {
  key: 0,
  class: "card-body"
}, z3 = { class: "kpi-grid" }, V3 = { class: "kpi-card" }, H3 = { class: "kpi-value" }, W3 = { class: "kpi-card" }, Y3 = { class: "kpi-value" }, U3 = { class: "kpi-card" }, G3 = { class: "kpi-value" }, X3 = { class: "kpi-card" }, j3 = { class: "kpi-value" }, q3 = { class: "kpi-card" }, Z3 = { class: "kpi-value" }, K3 = {
  key: 0,
  class: "chart-section"
}, Q3 = {
  key: 1,
  class: "empty-state"
}, J3 = {
  key: 1,
  class: "loading-state"
}, t$ = /* @__PURE__ */ jt({
  __name: "FAQ",
  props: {
    loading: { type: Boolean, default: !1 },
    data: { default: null },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (d) => {
      r("export", d);
    }, { isDark: o, colors: s } = re(ne(n, "theme")), l = Ke({ labels: [], datasets: [] }), u = G(() => n.data ?? {
      total_faq_events: 0,
      total_documents_found: 0,
      total_airline_information_retrieved: 0,
      total_booking_info_retrieved: 0,
      total_flight_status_retrieved: 0,
      faq_by_day: []
    }), c = G(() => ({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12
            },
            color: s.value.textSecondary
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: s.value.tooltipBg,
          titleColor: s.value.tooltipText,
          bodyColor: s.value.textSecondary,
          borderColor: o.value ? "rgba(198, 125, 255, 0.2)" : "rgba(0, 0, 0, 0.1)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'Space Grotesk', sans-serif",
            size: 14,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 13
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: s.value.textSecondary
          }
        },
        y: {
          type: "linear",
          display: !0,
          position: "left",
          beginAtZero: !0,
          grid: {
            color: s.value.gridLines
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: s.value.textSecondary
          }
        }
      },
      interaction: {
        mode: "nearest",
        axis: "x",
        intersect: !1
      }
    })), h = (d) => {
      if (!d) {
        l.value = { labels: [], datasets: [] };
        return;
      }
      const f = d.faq_by_day || [];
      if (f.length > 0) {
        const v = f.map((y) => br(y.date).format("MMM DD")), m = f.map((y) => y.airline_information_retrieved_count || 0), p = f.map((y) => y.flight_status_retrieved_count || 0), g = f.map((y) => y.booking_info_retrieved_count || 0);
        l.value = {
          labels: v,
          datasets: [
            {
              label: "Airline Information",
              data: m,
              borderColor: "#8b5cf6",
              backgroundColor: "rgba(139, 92, 246, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#8b5cf6",
              pointBorderColor: "#7c3aed",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Flight Status",
              data: p,
              borderColor: "#06b6d4",
              backgroundColor: "rgba(6, 182, 212, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#06b6d4",
              pointBorderColor: "#0891b2",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Booking Information",
              data: g,
              borderColor: "#f59e0b",
              backgroundColor: "rgba(245, 158, 11, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#f59e0b",
              pointBorderColor: "#d97706",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            }
          ]
        };
      } else
        l.value = { labels: [], datasets: [] };
    };
    return sa(
      () => n.data,
      (d) => {
        h(d ?? null);
      },
      { deep: !0, immediate: !0 }
    ), t({ isDark: o }), (d, f) => (A(), I("article", F3, [
      f[7] || (f[7] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "FAQ Metrics"),
          x("p", { class: "card-subtitle" }, "Daily FAQ consultation and retrieval metrics")
        ])
      ], -1)),
      n.loading ? (A(), I("div", J3, [...f[6] || (f[6] = [
        Dt('<div class="loading-container" data-v-84c7118a><div class="chart-bars-loader" data-v-84c7118a><div class="bar bar-1" data-v-84c7118a></div><div class="bar bar-2" data-v-84c7118a></div><div class="bar bar-3" data-v-84c7118a></div><div class="bar bar-4" data-v-84c7118a></div><div class="bar bar-5" data-v-84c7118a></div></div><p class="loading-text" data-v-84c7118a>Loading FAQ metrics...</p></div>', 1)
      ])])) : (A(), I("div", $3, [
        x("div", z3, [
          x("div", V3, [
            f[0] || (f[0] = x("span", { class: "kpi-label" }, "Total FAQ", -1)),
            x("span", H3, O(Y(st)(u.value.total_faq_events)), 1)
          ]),
          x("div", W3, [
            f[1] || (f[1] = x("span", { class: "kpi-label" }, "Documents Found", -1)),
            x("span", Y3, O(Y(st)(u.value.total_documents_found)), 1)
          ]),
          x("div", U3, [
            f[2] || (f[2] = x("span", { class: "kpi-label" }, "Airline Info", -1)),
            x("span", G3, O(Y(st)(u.value.total_airline_information_retrieved)), 1)
          ]),
          x("div", X3, [
            f[3] || (f[3] = x("span", { class: "kpi-label" }, "Booking Info", -1)),
            x("span", j3, O(Y(st)(u.value.total_booking_info_retrieved)), 1)
          ]),
          x("div", q3, [
            f[4] || (f[4] = x("span", { class: "kpi-label" }, "Flight Status", -1)),
            x("span", Z3, O(Y(st)(u.value.total_flight_status_retrieved)), 1)
          ])
        ]),
        l.value.labels && l.value.labels.length ? (A(), I("section", K3, [
          Qt(Ad, {
            data: l.value,
            options: c.value
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: a,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", Q3, [...f[5] || (f[5] = [
          Dt('<div class="empty-state-content" data-v-84c7118a><div class="empty-icon-wrapper" data-v-84c7118a><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-84c7118a><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" data-v-84c7118a></path></svg></div><p class="empty-title" data-v-84c7118a>No FAQ data available</p><p class="empty-description" data-v-84c7118a>No FAQ consultation data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), e$ = /* @__PURE__ */ Vt(t$, [["__scopeId", "data-v-84c7118a"]]), i$ = { class: "messages-per-agent-card" }, n$ = {
  key: 0,
  class: "card-body"
}, r$ = {
  key: 0,
  class: "chart-section"
}, a$ = {
  key: 1,
  class: "empty-state"
}, o$ = { class: "empty-state-content" }, s$ = { class: "empty-icon-wrapper" }, l$ = {
  key: 1,
  class: "loading-state"
}, u$ = /* @__PURE__ */ jt({
  __name: "MessagesPerAgent",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, r = e, a = i, o = (h) => {
      a("export", h);
    }, { isDark: s, colors: l } = re(ne(r, "theme")), u = G(() => {
      const h = r.data?.agents_by_day || {}, d = Object.keys(h).sort();
      if (d.length === 0)
        return { labels: [], datasets: [] };
      const f = /* @__PURE__ */ new Set();
      for (const p of Object.values(h))
        for (const g of Object.keys(p))
          f.add(g);
      const m = Array.from(f).map((p) => {
        const g = n[p] || "#94a3b8";
        return {
          label: p.charAt(0).toUpperCase() + p.slice(1).replace(/_/g, " "),
          data: d.map((y) => h[y]?.[p] || 0),
          borderColor: g,
          backgroundColor: `${g}20`,
          pointBackgroundColor: g,
          pointBorderColor: s.value ? "#1a1a1d" : "#ffffff",
          pointBorderWidth: 2,
          pointRadius: 5,
          pointHoverRadius: 7,
          tension: 0.3,
          fill: !1
        };
      });
      return {
        labels: d,
        datasets: m
      };
    }), c = G(() => r.options ? r.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            usePointStyle: !0,
            pointStyle: "circle",
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: l.value.textSecondary
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: l.value.tooltipBg,
          titleColor: l.value.tooltipText,
          bodyColor: l.value.tooltipText,
          borderColor: s.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: l.value.textSecondary
          }
        },
        y: {
          display: !0,
          beginAtZero: !0,
          grid: {
            color: l.value.gridLines
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: l.value.textSecondary
          }
        }
      }
    });
    return t({ isDark: s }), (h, d) => (A(), I("article", i$, [
      d[3] || (d[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Messages per Agent"),
          x("p", { class: "card-subtitle" }, "Agent interaction trends over time")
        ])
      ], -1)),
      e.loading ? (A(), I("div", l$, [...d[2] || (d[2] = [
        Dt('<div class="loading-container" data-v-1b6d19d4><div class="chart-lines-loader" data-v-1b6d19d4><div class="line line-1" data-v-1b6d19d4></div><div class="line line-2" data-v-1b6d19d4></div><div class="line line-3" data-v-1b6d19d4></div><div class="line line-4" data-v-1b6d19d4></div><div class="line line-5" data-v-1b6d19d4></div></div><p class="loading-text" data-v-1b6d19d4>Loading chart data...</p></div>', 1)
      ])])) : (A(), I("div", n$, [
        u.value.labels && u.value.labels.length ? (A(), I("section", r$, [
          Qt(Ad, {
            data: u.value,
            options: c.value
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: o,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", a$, [
          x("div", o$, [
            x("div", s$, [
              Qt(Y(Of), { class: "empty-icon" })
            ]),
            d[0] || (d[0] = x("p", { class: "empty-title" }, "No agent interactions data", -1)),
            d[1] || (d[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), c$ = /* @__PURE__ */ Vt(u$, [["__scopeId", "data-v-1b6d19d4"]]), h$ = { class: "record-locator-card" }, d$ = {
  key: 0,
  class: "loading-state"
}, f$ = {
  key: 1,
  class: "card-body"
}, v$ = {
  key: 0,
  class: "chart-section"
}, p$ = { class: "chart-wrapper" }, g$ = {
  key: 1,
  class: "table-section"
}, m$ = { class: "table-wrapper" }, y$ = { class: "data-table" }, _$ = { class: "table-header-row" }, b$ = {
  key: 0,
  class: "table-header"
}, x$ = {
  key: 1,
  class: "table-header"
}, w$ = { class: "table-body" }, S$ = { class: "table-cell font-medium" }, C$ = { class: "table-cell text-center" }, T$ = { class: "table-cell text-center" }, M$ = { class: "table-cell text-center" }, k$ = { class: "table-cell text-center" }, D$ = { class: "table-cell text-center success-value" }, E$ = { class: "table-cell text-center failed-value" }, A$ = { class: "table-cell text-center warning-value" }, L$ = {
  key: 0,
  class: "table-cell text-center"
}, P$ = {
  key: 1,
  class: "table-cell text-center failed-value"
}, I$ = {
  key: 2,
  class: "empty-state"
}, R$ = /* @__PURE__ */ jt({
  __name: "RecordLocator",
  props: {
    data: { default: () => ({
      total_checkin_initiated: 0,
      total_record_locator_init: 0,
      total_record_locator_started: 0,
      total_record_locator_completed: 0,
      total_record_locator_closed: 0,
      total_record_locator_failed: 0,
      total_record_locator_abandoned: 0,
      total_record_locator_init_abandoned: 0,
      record_locator_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    isAvianca: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (f) => {
      r("export", f);
    }, { isDark: o } = re(ne(n, "theme")), s = G(() => n.data?.record_locator_by_day ? [...n.data.record_locator_by_day].sort(
      (f, v) => new Date(f.date).getTime() - new Date(v.date).getTime()
    ) : []), l = G(() => n.data), u = G(() => ({
      // Main flow progression - from blue to cyan to green
      "Checkin Init": "#93C5FD",
      // Blue for started state
      "Booking retrive": "#67E8F9",
      // Light cyan
      "Checkin Started": "#22D3EE",
      // Medium cyan
      "Checkin Completed": "#A7F3D0",
      // Light green
      "Checkin Closed": "#7BE39E",
      // Green for success
      // Abandoned states - progressive red
      "Abandoned (Init)": "#FCA5A5",
      // Light red
      "Abandoned (Started)": "#F87171",
      // Medium red
      "Abandoned (Flow)": "#EF4444",
      // Darker red
      // Failed states
      "Checkin Failed": "#F87171"
      // Medium red for main failed node
    })), c = (f, v) => !v || v === 0 ? "0%" : `${Math.round(f / v * 100)}%`, h = (f, v) => {
      const m = st(f), p = c(f, v);
      return `${m} (${p})`;
    }, d = G(() => {
      const f = [], v = [];
      if (!l.value.total_checkin_initiated)
        return { nodes: f, links: v };
      f.push({ name: "Checkin Init" }), f.push({ name: "Booking retrive" }), f.push({ name: "Checkin Started" }), f.push({ name: "Checkin Completed" }), f.push({ name: "Checkin Closed" });
      const m = l.value.total_checkin_initiated, p = l.value.total_record_locator_init, g = l.value.total_record_locator_started, y = l.value.total_record_locator_completed, _ = l.value.total_record_locator_closed, b = l.value.total_record_locator_failed, w = l.value.total_record_locator_abandoned, S = l.value.total_record_locator_init_abandoned;
      if (p > 0) {
        const T = Math.round(p / m * 100);
        v.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: p,
          label: `${p.toLocaleString()} (${T}%)`
        });
      }
      const C = m - p;
      if (C > 0) {
        const T = Math.round(C / m * 100);
        f.push({ name: "Abandoned (Init)" }), v.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: C,
          label: `${C.toLocaleString()} (${T}%)`
        });
      }
      if (g > 0) {
        const T = Math.round(g / m * 100);
        v.push({
          source: "Booking retrive",
          target: "Checkin Started",
          value: g,
          label: `${g.toLocaleString()} (${T}%)`
        });
      }
      if (S > 0) {
        const T = Math.round(S / m * 100);
        f.push({ name: "Abandoned (Started)" }), v.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: S,
          label: `${S.toLocaleString()} (${T}%)`
        });
      }
      if (y > 0) {
        const T = Math.round(y / g * 100);
        v.push({
          source: "Checkin Started",
          target: "Checkin Completed",
          value: y,
          label: `${y.toLocaleString()} (${T}%)`
        });
      }
      if (_ > 0) {
        const T = Math.round(_ / g * 100);
        v.push({
          source: "Checkin Completed",
          target: "Checkin Closed",
          value: _,
          label: `${_.toLocaleString()} (${T}%)`
        });
      }
      if (b > 0) {
        const T = Math.round(b / g * 100);
        f.push({ name: "Checkin Failed" }), v.push({
          source: "Checkin Started",
          target: "Checkin Failed",
          value: b,
          label: `${b.toLocaleString()} (${T}%)`
        });
      }
      if (w > 0) {
        const T = Math.round(w / g * 100);
        f.push({ name: "Abandoned (Flow)" }), v.push({
          source: "Checkin Started",
          target: "Abandoned (Flow)",
          value: w,
          label: `${w.toLocaleString()} (${T}%)`
        });
      }
      return { nodes: f, links: v };
    });
    return t({ isDark: o }), (f, v) => (A(), I("article", h$, [
      v[10] || (v[10] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Checkin by Record Locator Metrics"),
          x("p", { class: "card-subtitle" }, "Checkin by record locator retrieval and completion analysis")
        ])
      ], -1)),
      n.loading ? (A(), I("div", d$, [...v[0] || (v[0] = [
        Dt('<div class="loading-container" data-v-25ddc9d2><div class="chart-flow-loader" data-v-25ddc9d2><div class="flow-line flow-1" data-v-25ddc9d2></div><div class="flow-line flow-2" data-v-25ddc9d2></div><div class="flow-line flow-3" data-v-25ddc9d2></div><div class="flow-line flow-4" data-v-25ddc9d2></div><div class="flow-line flow-5" data-v-25ddc9d2></div></div><p class="loading-text" data-v-25ddc9d2>Loading record locator data...</p></div>', 1)
      ])])) : (A(), I("div", f$, [
        d.value.nodes.length > 0 ? (A(), I("section", v$, [
          x("div", p$, [
            Qt(Mr, {
              data: d.value,
              height: "500px",
              "node-colors": u.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : q("", !0),
        s.value && s.value.length > 0 ? (A(), I("section", g$, [
          x("div", m$, [
            x("table", y$, [
              x("thead", null, [
                x("tr", _$, [
                  v[1] || (v[1] = x("th", { class: "table-header" }, "Date", -1)),
                  v[2] || (v[2] = x("th", { class: "table-header" }, "Checkin Init", -1)),
                  v[3] || (v[3] = x("th", { class: "table-header" }, "Booking Retrieve (%)", -1)),
                  v[4] || (v[4] = x("th", { class: "table-header" }, "Checkin Started", -1)),
                  v[5] || (v[5] = x("th", { class: "table-header" }, "Checkin Completed (%)", -1)),
                  v[6] || (v[6] = x("th", { class: "table-header" }, "Checkin Closed (%)", -1)),
                  v[7] || (v[7] = x("th", { class: "table-header" }, "Checkin Failed (%)", -1)),
                  v[8] || (v[8] = x("th", { class: "table-header" }, "Abandoned (%)", -1)),
                  n.isAvianca ? (A(), I("th", b$, "Create Payment")) : q("", !0),
                  n.isAvianca ? (A(), I("th", x$, "Failed Payment")) : q("", !0)
                ])
              ]),
              x("tbody", w$, [
                (A(!0), I(Tt, null, Zt(s.value, (m) => (A(), I("tr", {
                  key: m.date,
                  class: "table-row"
                }, [
                  x("td", S$, O(Y(br)(m.date).format("DD/MM/YYYY")), 1),
                  x("td", C$, O(Y(st)(m.checkin_initiated)), 1),
                  x("td", T$, O(h(m.record_locator_init_count, m.checkin_initiated)), 1),
                  x("td", M$, O(Y(st)(m.record_locator_started_count)), 1),
                  x("td", k$, O(h(m.record_locator_completed_count, m.record_locator_started_count)), 1),
                  x("td", D$, O(h(m.record_locator_closed_count, m.record_locator_started_count)), 1),
                  x("td", E$, O(h(m.record_locator_failed_count, m.record_locator_started_count)), 1),
                  x("td", A$, O(h(m.record_locator_abandoned_count, m.record_locator_started_count)), 1),
                  n.isAvianca ? (A(), I("td", L$, O(Y(st)(m.record_locator_create_payment_count)), 1)) : q("", !0),
                  n.isAvianca ? (A(), I("td", P$, O(Y(st)(m.record_locator_create_payment_failed_count)), 1)) : q("", !0)
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: a,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", I$, [...v[9] || (v[9] = [
          Dt('<div class="empty-state-content" data-v-25ddc9d2><div class="empty-icon-wrapper" data-v-25ddc9d2><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-25ddc9d2><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" data-v-25ddc9d2></path></svg></div><p class="empty-title" data-v-25ddc9d2>No record locator data available</p><p class="empty-description" data-v-25ddc9d2>No record locator data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), O$ = /* @__PURE__ */ Vt(R$, [["__scopeId", "data-v-25ddc9d2"]]), B$ = { class: "seller-metrics-card" }, N$ = { class: "card-header" }, F$ = { class: "header-content" }, $$ = {
  key: 0,
  class: "stats-badge"
}, z$ = { class: "badge-value" }, V$ = {
  key: 0,
  class: "loading-state"
}, H$ = {
  key: 1,
  class: "card-body"
}, W$ = {
  key: 0,
  class: "chart-section"
}, Y$ = { class: "chart-wrapper" }, U$ = {
  key: 1,
  class: "empty-state"
}, G$ = {
  key: 2,
  class: "table-section"
}, X$ = { class: "table-wrapper" }, j$ = { class: "data-table" }, q$ = { class: "table-body" }, Z$ = { class: "table-cell font-medium" }, K$ = { class: "table-cell text-center" }, Q$ = { class: "table-cell text-center" }, J$ = { class: "table-cell text-center" }, tz = { class: "table-cell text-center" }, ez = { class: "table-cell text-center" }, iz = { class: "table-cell text-center success-value" }, nz = { class: "table-cell text-left" }, rz = {
  key: 0,
  class: "failed-reasons"
}, az = { class: "reason-name" }, oz = { class: "reason-count" }, sz = {
  key: 1,
  class: "empty-cell"
}, lz = /* @__PURE__ */ jt({
  __name: "Seller",
  props: {
    sellerData: { default: () => ({
      total_seller_conversations: 0,
      total_sell_started: 0,
      total_sell_get_quote: 0,
      total_sell_booking_created: 0,
      total_sell_success: 0,
      total_value_sell_success: 0,
      seller_by_day: []
    }) },
    failedData: { default: () => ({
      total_sell_failed: 0,
      failed_by_reason_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (m) => {
      r("export", m);
    }, { isDark: o } = re(ne(n, "theme")), s = G(() => {
      if (!n.sellerData?.seller_by_day) return [];
      const m = [...n.sellerData.seller_by_day];
      return n.failedData?.failed_by_reason_by_day && n.failedData.failed_by_reason_by_day.forEach((p) => {
        const g = m.findIndex((y) => y.date === p.date);
        g !== -1 ? m[g] = { ...m[g], reasons: p.reasons } : m.push({
          date: p.date,
          seller_conversations: 0,
          sell_started_count: 0,
          sell_get_quote_count: 0,
          sell_booking_created_count: 0,
          sell_success_count: 0,
          daily_value_sell_success: 0,
          reasons: p.reasons
        });
      }), m.sort((p, g) => new Date(p.date).getTime() - new Date(g.date).getTime());
    }), l = G(() => n.sellerData), u = G(() => n.failedData), c = G(() => {
      const {
        total_seller_conversations: m = 0,
        total_sell_started: p = 0,
        total_sell_booking_created: g = 0,
        total_sell_success: y = 0
      } = l.value, { failed_by_reason_by_day: _ = [] } = u.value;
      if (m === 0) return { nodes: [], links: [] };
      const b = [
        { name: "Sell Initiated", value: m },
        { name: "Sell Started", value: p },
        { name: "Booking Created", value: g },
        { name: "Sell Success", value: y }
      ], w = [], S = m - p;
      if (S > 0) {
        const M = Math.round(S / m * 100);
        b.push({ name: "Abandoned (Init)", value: S }), w.push({
          source: "Sell Initiated",
          target: "Abandoned (Init)",
          value: S,
          label: `${S.toLocaleString()} (${M}%)`
        });
      }
      if (p > 0) {
        const M = Math.round(p / m * 100);
        w.push({
          source: "Sell Initiated",
          target: "Sell Started",
          value: p,
          label: `${p.toLocaleString()} (${M}%)`
        });
      }
      const C = _.reduce((M, D) => (D.reasons && Array.isArray(D.reasons) && D.reasons.forEach((L) => {
        const P = L.reason, R = L.failed_count;
        M[P] = (M[P] || 0) + R;
      }), M), {});
      if (g > 0) {
        const M = Math.round(g / m * 100);
        w.push({
          source: "Sell Started",
          target: "Booking Created",
          value: g,
          label: `${g.toLocaleString()} (${M}%)`
        });
      }
      if (y > 0) {
        const M = Math.round(y / m * 100);
        w.push({
          source: "Booking Created",
          target: "Sell Success",
          value: y,
          label: `${y.toLocaleString()} (${M}%)`
        });
      }
      const T = p - g;
      if (T > 0) {
        const M = Math.round(T / m * 100);
        b.push({ name: "Failed at Booking", value: T }), w.push({
          source: "Sell Started",
          target: "Failed at Booking",
          value: T,
          label: `${T.toLocaleString()} (${M}%)`
        });
      }
      if (Object.keys(C).length > 0) {
        const M = Object.values(C).reduce((L, P) => L + P, 0), D = T - M;
        if (Object.entries(C).filter(([, L]) => L > 0).sort(([, L], [, P]) => P - L).forEach(([L, P]) => {
          const R = Math.round(P / m * 100);
          b.push({ name: `Failed: ${L}`, value: P }), w.push({
            source: "Failed at Booking",
            target: `Failed: ${L}`,
            value: P,
            label: `${P.toLocaleString()} (${R}%)`
          });
        }), D > 0) {
          const L = Math.round(D / m * 100);
          b.push({ name: "Failed: Without Reason", value: D }), w.push({
            source: "Failed at Booking",
            target: "Failed: Without Reason",
            value: D,
            label: `${D.toLocaleString()} (${L}%)`
          });
        }
      }
      const k = g - y;
      if (k > 0) {
        const M = Math.round(k / m * 100);
        b.push({ name: "Failed at Completion", value: k }), w.push({
          source: "Booking Created",
          target: "Failed at Completion",
          value: k,
          label: `${k.toLocaleString()} (${M}%)`
        });
      }
      return { nodes: b, links: w };
    }), h = {
      "Sell Initiated": "#DBEAFE",
      "Abandoned (Init)": "#FEE2E2",
      "Sell Started": "#93C5FD",
      "Get Quote": "#C7D2FE",
      "Booking Created": "#8B8CF6",
      "Sell Success": "#7BE39E",
      "Sell Failed": "#FCA5A5",
      "Failed at Quote": "#FCA5A5",
      "Failed at Booking": "#F87171",
      "Failed at Completion": "#EF4444",
      "Failed: rejected": "#F87171",
      "Failed: payment_processing": "#EF4444",
      "Failed: seat_selection": "#F87171",
      "Failed: booking_validation": "#EF4444",
      "Failed: flight_availability": "#DC2626",
      "Failed: passenger_data": "#F87171",
      "Failed: system_error": "#DC2626",
      "Failed: timeout": "#EF4444",
      "Failed: Without Reason": "#F87171"
    }, d = G(() => h), f = (m, p) => !p || p === 0 ? "0%" : `${Math.round(m / p * 100)}%`, v = (m, p) => {
      const g = st(m), y = f(m, p);
      return `${g} (${y})`;
    };
    return t({ isDark: o }), (m, p) => (A(), I("article", B$, [
      x("header", N$, [
        x("div", F$, [
          p[1] || (p[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Seller Metrics"),
            x("p", { class: "card-subtitle" }, "Sales performance and failure analysis")
          ], -1)),
          n.loading ? q("", !0) : (A(), I("div", $$, [
            p[0] || (p[0] = x("p", { class: "badge-label" }, "Total Sales Value", -1)),
            x("p", z$, O(Y(D0)(n.sellerData.total_value_sell_success)), 1)
          ]))
        ])
      ]),
      n.loading ? (A(), I("div", V$, [...p[2] || (p[2] = [
        Dt('<div class="loading-container" data-v-990ed652><div class="chart-flow-loader" data-v-990ed652><div class="flow-line flow-1" data-v-990ed652></div><div class="flow-line flow-2" data-v-990ed652></div><div class="flow-line flow-3" data-v-990ed652></div><div class="flow-line flow-4" data-v-990ed652></div><div class="flow-line flow-5" data-v-990ed652></div></div><p class="loading-text" data-v-990ed652>Loading sales data...</p></div>', 1)
      ])])) : (A(), I("div", H$, [
        c.value.nodes.length > 0 ? (A(), I("section", W$, [
          x("div", Y$, [
            Qt(Mr, {
              data: c.value,
              "node-colors": d.value,
              title: "",
              height: "320px"
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : (A(), I("section", U$, [...p[3] || (p[3] = [
          Dt('<div class="empty-state-content" data-v-990ed652><div class="empty-icon-wrapper" data-v-990ed652><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-990ed652><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-990ed652></path></svg></div><p class="empty-title" data-v-990ed652>No sales data available</p><p class="empty-description" data-v-990ed652>No sales data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])])),
        s.value && s.value.length > 0 ? (A(), I("section", G$, [
          x("div", X$, [
            x("table", j$, [
              p[4] || (p[4] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Sell Initiated"),
                  x("th", { class: "table-header" }, "Sell Started"),
                  x("th", { class: "table-header" }, "Get Quote"),
                  x("th", { class: "table-header" }, "Booking Created"),
                  x("th", { class: "table-header" }, "Sell Success"),
                  x("th", { class: "table-header" }, "Total Sales Value"),
                  x("th", { class: "table-header" }, "Failed")
                ])
              ], -1)),
              x("tbody", q$, [
                (A(!0), I(Tt, null, Zt(s.value, (g) => (A(), I("tr", {
                  key: g.date,
                  class: "table-row"
                }, [
                  x("td", Z$, O(Y(br)(g.date).format("DD/MM/YYYY")), 1),
                  x("td", K$, O(Y(st)(g.seller_conversations || 0)), 1),
                  x("td", Q$, O(v(g.sell_started_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", J$, O(v(g.sell_get_quote_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", tz, O(v(g.sell_booking_created_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", ez, O(v(g.sell_success_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", iz, O(Y(D0)(g.daily_value_sell_success)), 1),
                  x("td", nz, [
                    g.reasons && g.reasons.length > 0 ? (A(), I("div", rz, [
                      (A(!0), I(Tt, null, Zt(g.reasons, (y) => (A(), I("div", {
                        key: y.reason,
                        class: "failed-reason-item"
                      }, [
                        x("span", az, O(y.reason) + ":", 1),
                        x("span", oz, O(y.failed_count), 1)
                      ]))), 128))
                    ])) : (A(), I("div", sz, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: a,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : q("", !0)
      ]))
    ]));
  }
}), uz = /* @__PURE__ */ Vt(lz, [["__scopeId", "data-v-990ed652"]]), cz = { class: "top-agents-card" }, hz = {
  key: 0,
  class: "card-body"
}, dz = {
  key: 0,
  class: "chart-section"
}, fz = {
  key: 1,
  class: "empty-state"
}, vz = { class: "empty-state-content" }, pz = { class: "empty-icon-wrapper" }, gz = {
  key: 1,
  class: "loading-state"
}, mz = /* @__PURE__ */ jt({
  __name: "TopAgents",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 },
    exportLoading: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, r = e, a = i, o = (h) => {
      a("export", h);
    }, { isDark: s, colors: l } = re(ne(r, "theme")), u = G(() => {
      const d = (r.data?.top_agents || []).filter(
        (p) => p.agent_type?.toLowerCase() !== "triage"
      );
      if (d.length === 0)
        return { labels: [], datasets: [] };
      const f = d.reduce(
        (p, g) => p + (Number(g.conversations) || 0),
        0
      ), v = d.map((p) => {
        const g = p.agent_type?.toLowerCase();
        return n[g] || "#94a3b8";
      }), m = v.map((p) => `${p}80`);
      return {
        labels: d.map((p) => {
          const g = Number(p.conversations) || 0, y = f ? g / f * 100 : 0;
          return `${p.agent_type} - ${g.toLocaleString()} (${y.toFixed(1)}%)`;
        }),
        datasets: [
          {
            data: d.map((p) => p.conversations),
            backgroundColor: m,
            borderColor: v,
            borderWidth: 2
          }
        ]
      };
    }), c = G(() => r.options ? r.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          position: "bottom",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: l.value.textSecondary
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: l.value.tooltipBg,
          titleColor: l.value.tooltipText,
          bodyColor: l.value.tooltipText,
          borderColor: s.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          callbacks: {
            label: (h) => {
              const d = (h.label || "").toString().split(" - ")[0], f = Number(h.parsed) || 0, v = (h.dataset.data || []).reduce(
                (p, g) => p + (Number(g) || 0),
                0
              ), m = v ? f / v * 100 : 0;
              return `${d}: ${f.toLocaleString()} (${m.toFixed(1)}%)`;
            }
          }
        }
      }
    });
    return t({ isDark: s }), (h, d) => (A(), I("article", cz, [
      d[3] || (d[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Top Agents"),
          x("p", { class: "card-subtitle" }, "Interactions by agent (excluding triage)")
        ])
      ], -1)),
      e.loading ? (A(), I("div", gz, [...d[2] || (d[2] = [
        Dt('<div class="loading-container" data-v-d7137caf><div class="chart-lines-loader" data-v-d7137caf><div class="line line-1" data-v-d7137caf></div><div class="line line-2" data-v-d7137caf></div><div class="line line-3" data-v-d7137caf></div><div class="line line-4" data-v-d7137caf></div><div class="line line-5" data-v-d7137caf></div></div><p class="loading-text" data-v-d7137caf>Loading chart data...</p></div>', 1)
      ])])) : (A(), I("div", hz, [
        u.value.labels && u.value.labels.length ? (A(), I("section", dz, [
          Qt(Ry, {
            data: u.value,
            options: c.value
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), _e(Y(Fe), {
            key: 0,
            onExport: o,
            loading: e.exportLoading
          }, null, 8, ["loading"])) : q("", !0)
        ])) : (A(), I("section", fz, [
          x("div", vz, [
            x("div", pz, [
              Qt(Y(RN), { class: "empty-icon" })
            ]),
            d[0] || (d[0] = x("p", { class: "empty-title" }, "No top agents data", -1)),
            d[1] || (d[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), yz = /* @__PURE__ */ Vt(mz, [["__scopeId", "data-v-d7137caf"]]), _z = { class: "nps-daily-card" }, bz = { class: "card-header" }, xz = { class: "header-content" }, wz = {
  key: 0,
  class: "stats-badge"
}, Sz = { class: "badge-value" }, Cz = {
  key: 0,
  class: "loading-state"
}, Tz = {
  key: 1,
  class: "card-body"
}, Mz = { class: "tooltip-content" }, kz = { class: "tooltip-title" }, Dz = { class: "tooltip-stats" }, Ez = { class: "tooltip-stat-row" }, Az = { class: "tooltip-value" }, Lz = { class: "tooltip-stat-row" }, Pz = { class: "tooltip-value" }, Iz = { class: "tooltip-stat-row" }, Rz = { class: "tooltip-value" }, Oz = { class: "tooltip-stat-row" }, Bz = { class: "tooltip-value" }, Nz = { class: "tooltip-stat-row" }, Fz = { class: "tooltip-value" }, $z = { class: "tooltip-stat-row" }, zz = { class: "tooltip-value" }, Vz = {
  key: 2,
  class: "empty-state"
}, E0 = 400, ja = 60, A0 = 90, L0 = 120, Hz = {
  __name: "npsDailyMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: void 0
    },
    enableExport: {
      type: Boolean,
      default: !1
    },
    exportLoading: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = i, r = (p) => {
      n("export", p);
    }, a = e, { isDark: o } = re(ne(a, "theme")), s = G(() => a.data), l = Ke(null), u = Ke({
      visible: !1,
      x: 0,
      y: 0,
      date: "",
      min: "",
      max: "",
      q1: "",
      avg: "",
      q3: "",
      median: ""
    }), c = G(() => {
      if (!s.value || !s.value.nps_by_day) return 800;
      const p = s.value.nps_by_day.length;
      return Math.max(800, ja * 2 + p * L0);
    }), h = (p, g) => {
      const _ = (p - 1) / 9;
      return ja + g - _ * g;
    }, d = (p) => p ? br(p).format("DD-MM-YYYY") : "", f = G(() => {
      if (!s.value || !s.value.nps_by_day || s.value.nps_by_day.length === 0)
        return [];
      const p = [], g = E0 - ja - A0;
      return s.value.nps_by_day.forEach((y, _) => {
        const b = y.min_score || 0, w = y.q1_score || 0, S = y.median_score || 0, C = y.q3_score || 0, T = y.max_score || 0, k = y.average_score || 0;
        p.push({
          label: d(y.date),
          responseCount: y.nps_responses_count || 0,
          isTotal: !1,
          open: w,
          // Q1 as open
          high: T,
          // Max as high
          low: b,
          // Min as low
          close: C,
          // Q3 as close
          median: S,
          average: k,
          openY: h(w, g),
          highY: h(T, g),
          lowY: h(b, g),
          closeY: h(C, g),
          medianY: h(S, g),
          averageY: k > 0 ? h(k, g) : null,
          centerX: ja + (_ + 1) * L0
        });
      }), p;
    }), v = (p, g) => {
      if (!l.value || !g || g.horizontal) return;
      const y = l.value.getBoundingClientRect(), _ = p.clientX, b = p.clientY, w = 140, S = 160, C = 10, T = 15;
      let k = _ - y.left - w / 2, M = b - y.top - S - T;
      k = Math.max(C, Math.min(k, y.width - w - C)), M < C && (M = b - y.top + T), M = Math.max(C, Math.min(M, y.height - S - C)), u.value = {
        visible: !0,
        x: k,
        y: M,
        date: g.label || "",
        min: g.low !== void 0 ? g.low.toFixed(1) : "N/A",
        max: g.high !== void 0 ? g.high.toFixed(1) : "N/A",
        q1: g.open !== void 0 ? g.open.toFixed(1) : "N/A",
        avg: g.average !== void 0 && g.average > 0 ? g.average.toFixed(1) : "N/A",
        q3: g.close !== void 0 ? g.close.toFixed(1) : "N/A",
        median: g.median !== void 0 ? g.median.toFixed(1) : "N/A"
      };
    }, m = () => {
      u.value.visible = !1;
    };
    return t({ isDark: o }), (p, g) => (A(), I("article", _z, [
      x("header", bz, [
        x("div", xz, [
          g[1] || (g[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "NPS Daily Metrics"),
            x("p", { class: "card-subtitle" }, "Daily NPS Distribution")
          ], -1)),
          s.value && s.value.nps_by_day && s.value.nps_by_day.length > 0 ? (A(), I("div", wz, [
            g[0] || (g[0] = x("p", { class: "badge-label" }, "Days", -1)),
            x("p", Sz, O(s.value.nps_by_day.length), 1)
          ])) : q("", !0)
        ])
      ]),
      a.loading ? (A(), I("div", Cz, [...g[2] || (g[2] = [
        Dt('<div class="loading-container" data-v-dcfd2125><div class="chart-flow-loader" data-v-dcfd2125><div class="flow-line flow-1" data-v-dcfd2125></div><div class="flow-line flow-2" data-v-dcfd2125></div><div class="flow-line flow-3" data-v-dcfd2125></div><div class="flow-line flow-4" data-v-dcfd2125></div><div class="flow-line flow-5" data-v-dcfd2125></div></div><p class="loading-text" data-v-dcfd2125>Loading daily NPS data...</p></div>', 1)
      ])])) : s.value && s.value.nps_by_day && s.value.nps_by_day.length > 0 ? (A(), I("div", Tz, [
        x("div", {
          class: "chart-wrapper",
          ref_key: "chartContainerRef",
          ref: l
        }, [
          f.value && f.value.length > 0 ? (A(), _e(Oy, {
            key: 0,
            "candlestick-data": f.value,
            "chart-width": c.value,
            "chart-height": E0,
            "chart-margin": ja,
            "chart-bottom-margin": A0,
            "show-legend": !0,
            rotation: 0,
            "candle-width": 30,
            onCandleHover: v,
            onCandleLeave: m
          }, null, 8, ["candlestick-data", "chart-width"])) : q("", !0),
          u.value.visible ? (A(), I("div", {
            key: 1,
            class: "tooltip-overlay",
            style: or({
              left: `${u.value.x}px`,
              top: `${u.value.y}px`
            })
          }, [
            x("div", Mz, [
              x("div", kz, O(u.value.date), 1),
              g[9] || (g[9] = x("div", { class: "tooltip-divider" }, null, -1)),
              x("div", Dz, [
                x("div", Ez, [
                  g[3] || (g[3] = x("span", { class: "tooltip-label tooltip-min" }, "Min:", -1)),
                  x("span", Az, O(u.value.min), 1)
                ]),
                x("div", Lz, [
                  g[4] || (g[4] = x("span", { class: "tooltip-label tooltip-q1" }, "Q1:", -1)),
                  x("span", Pz, O(u.value.q1), 1)
                ]),
                x("div", Iz, [
                  g[5] || (g[5] = x("span", { class: "tooltip-label tooltip-median" }, "Median:", -1)),
                  x("span", Rz, O(u.value.median), 1)
                ]),
                x("div", Oz, [
                  g[6] || (g[6] = x("span", { class: "tooltip-label tooltip-avg" }, "Avg:", -1)),
                  x("span", Bz, O(u.value.avg), 1)
                ]),
                x("div", Nz, [
                  g[7] || (g[7] = x("span", { class: "tooltip-label tooltip-q3" }, "Q3:", -1)),
                  x("span", Fz, O(u.value.q3), 1)
                ]),
                x("div", $z, [
                  g[8] || (g[8] = x("span", { class: "tooltip-label tooltip-max" }, "Max:", -1)),
                  x("span", zz, O(u.value.max), 1)
                ])
              ])
            ])
          ], 4)) : q("", !0)
        ], 512),
        e.enableExport ? (A(), _e(Y(Fe), {
          key: 0,
          onExport: r,
          loading: e.exportLoading
        }, null, 8, ["loading"])) : q("", !0)
      ])) : (A(), I("div", Vz, [...g[10] || (g[10] = [
        Dt('<div class="empty-state-content" data-v-dcfd2125><div class="empty-icon-wrapper" data-v-dcfd2125><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-dcfd2125><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-dcfd2125></path></svg></div><p class="empty-title" data-v-dcfd2125>No daily NPS data available</p><p class="empty-description" data-v-dcfd2125>No daily NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, X1 = /* @__PURE__ */ Vt(Hz, [["__scopeId", "data-v-dcfd2125"]]), Wz = { class: "nps-overview-card" }, Yz = { class: "card-header" }, Uz = { class: "header-content" }, Gz = {
  key: 0,
  class: "stats-badge"
}, Xz = { class: "badge-value" }, jz = {
  key: 0,
  class: "loading-state"
}, qz = {
  key: 1,
  class: "card-body"
}, Zz = { class: "chart-wrapper" }, Kz = {
  key: 2,
  class: "empty-state"
}, Qz = 500, Jz = 60, tV = 80, eV = {
  __name: "npsOverviewMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: void 0
    },
    enableExport: {
      type: Boolean,
      default: !1
    },
    exportLoading: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = i, r = (u) => {
      n("export", u);
    }, a = e, { isDark: o } = re(ne(a, "theme")), s = G(() => a.data), l = G(() => Math.max(600, window.innerWidth * 0.85));
    return t({ isDark: o }), (u, c) => (A(), I("article", Wz, [
      x("header", Yz, [
        x("div", Uz, [
          c[1] || (c[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "NPS Overview Metrics"),
            x("p", { class: "card-subtitle" }, "Overall NPS Distribution")
          ], -1)),
          s.value && s.value.total_nps_responses > 0 ? (A(), I("div", Gz, [
            c[0] || (c[0] = x("p", { class: "badge-label" }, "Responses", -1)),
            x("p", Xz, O(s.value.total_nps_responses), 1)
          ])) : q("", !0)
        ])
      ]),
      a.loading ? (A(), I("div", jz, [...c[2] || (c[2] = [
        Dt('<div class="loading-container" data-v-65050776><div class="chart-flow-loader" data-v-65050776><div class="flow-line flow-1" data-v-65050776></div><div class="flow-line flow-2" data-v-65050776></div><div class="flow-line flow-3" data-v-65050776></div><div class="flow-line flow-4" data-v-65050776></div><div class="flow-line flow-5" data-v-65050776></div></div><p class="loading-text" data-v-65050776>Loading NPS data...</p></div>', 1)
      ])])) : s.value && s.value.total_nps_responses > 0 ? (A(), I("div", qz, [
        x("div", Zz, [
          Qt(By, {
            histogram: s.value.histogram || [],
            "min-score": s.value.min_score || 0,
            "max-score": s.value.max_score || 0,
            "q1-score": s.value.q1_score || 0,
            "median-score": s.value.median_score || 0,
            "q3-score": s.value.q3_score || 0,
            "average-score": s.value.average_score || 0,
            "chart-width": l.value,
            "chart-height": Qz,
            "chart-margin": Jz,
            "chart-bottom-margin": tV
          }, null, 8, ["histogram", "min-score", "max-score", "q1-score", "median-score", "q3-score", "average-score", "chart-width"])
        ]),
        e.enableExport ? (A(), _e(Y(Fe), {
          key: 0,
          onExport: r,
          loading: e.exportLoading
        }, null, 8, ["loading"])) : q("", !0)
      ])) : (A(), I("div", Kz, [...c[3] || (c[3] = [
        Dt('<div class="empty-state-content" data-v-65050776><div class="empty-icon-wrapper" data-v-65050776><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-65050776><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-65050776></path></svg></div><p class="empty-title" data-v-65050776>No NPS data available</p><p class="empty-description" data-v-65050776>No NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, j1 = /* @__PURE__ */ Vt(eV, [["__scopeId", "data-v-65050776"]]), iV = { class: "nps-metrics-container" }, nV = {
  __name: "npsMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    enableExport: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = t, n = (r) => {
      i("export", r);
    };
    return (r, a) => (A(), I("div", iV, [
      Qt(j1, {
        data: e.data,
        loading: e.loading,
        "enable-export": e.enableExport,
        onExport: n
      }, null, 8, ["data", "loading", "enable-export"]),
      Qt(X1, {
        data: e.data,
        loading: e.loading,
        "enable-export": e.enableExport,
        onExport: n
      }, null, 8, ["data", "loading", "enable-export"])
    ]));
  }
}, rV = /* @__PURE__ */ Vt(nV, [["__scopeId", "data-v-25fe3b80"]]), dV = {
  install(e) {
    e.component("KiutChartBar", Iy), e.component("KiutChartLine", Ad), e.component("KiutPieChart", Ry), e.component("KiutBoxplotChart", jT), e.component("KiutCandlestickChart", Oy), e.component("KiutHistogramChart", By), e.component("KiutSankeyChart", Mr), e.component("KiutAgentsPerDay", JN), e.component("KiutBookingManager", IF), e.component("KiutCheckin", n4), e.component("KiutCheckinMetrics", D4), e.component("KiutCheckinSegments", e3), e.component("KiutDisruption", N3), e.component("KiutFAQ", e$), e.component("KiutMessagesPerAgent", c$), e.component("KiutRecordLocator", O$), e.component("KiutSeller", uz), e.component("KiutTopAgents", yz), e.component("KiutNpsDailyMetrics", X1), e.component("KiutNpsMetrics", rV), e.component("KiutNpsOverviewMetrics", j1);
  }
};
export {
  JN as AgentsPerDay,
  IF as BookingManager,
  jT as BoxplotChart,
  Oy as CandlestickChart,
  Iy as ChartBar,
  Ad as ChartLine,
  n4 as Checkin,
  D4 as CheckinMetrics,
  e3 as CheckinSegments,
  N3 as Disruption,
  e$ as FAQ,
  By as HistogramChart,
  dV as KiutUIPlugin,
  c$ as MessagesPerAgent,
  X1 as NpsDailyMetrics,
  rV as NpsMetrics,
  j1 as NpsOverviewMetrics,
  Ry as PieChart,
  O$ as RecordLocator,
  Mr as SankeyChart,
  uz as Seller,
  yz as TopAgents
};
//# sourceMappingURL=kiut-ui.es.js.map
