import { defineComponent as fe, shallowRef as Uy, h as Od, ref as vi, onMounted as Qf, onUnmounted as Gy, watch as es, toRaw as Id, nextTick as Xy, version as e2, isProxy as jy, computed as X, toRef as _e, createElementBlock as L, openBlock as E, createVNode as de, unref as J, normalizeStyle as Xr, createCommentVNode as ht, createElementVNode as x, toDisplayString as R, Fragment as Rt, renderList as ue, onBeforeUnmount as i2, createStaticVNode as Ht, withDirectives as Gp, vShow as Xp, createTextVNode as mu, createBlock as qy } from "vue";
function Go(e) {
  return e + 0.5 | 0;
}
const Vn = (e, t, i) => Math.max(Math.min(e, i), t);
function js(e) {
  return Vn(Go(e * 2.55), 0, 255);
}
function jn(e) {
  return Vn(Go(e * 255), 0, 255);
}
function vn(e) {
  return Vn(Go(e / 2.55) / 100, 0, 1);
}
function jp(e) {
  return Vn(Go(e * 100), 0, 100);
}
const ei = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Rd = [..."0123456789ABCDEF"], n2 = (e) => Rd[e & 15], r2 = (e) => Rd[(e & 240) >> 4] + Rd[e & 15], il = (e) => (e & 240) >> 4 === (e & 15), a2 = (e) => il(e.r) && il(e.g) && il(e.b) && il(e.a);
function s2(e) {
  var t = e.length, i;
  return e[0] === "#" && (t === 4 || t === 5 ? i = {
    r: 255 & ei[e[1]] * 17,
    g: 255 & ei[e[2]] * 17,
    b: 255 & ei[e[3]] * 17,
    a: t === 5 ? ei[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (i = {
    r: ei[e[1]] << 4 | ei[e[2]],
    g: ei[e[3]] << 4 | ei[e[4]],
    b: ei[e[5]] << 4 | ei[e[6]],
    a: t === 9 ? ei[e[7]] << 4 | ei[e[8]] : 255
  })), i;
}
const o2 = (e, t) => e < 255 ? t(e) : "";
function l2(e) {
  var t = a2(e) ? n2 : r2;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + o2(e.a, t) : void 0;
}
const u2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Zy(e, t, i) {
  const n = t * Math.min(i, 1 - i), r = (a, s = (a + e / 30) % 12) => i - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
  return [r(0), r(8), r(4)];
}
function c2(e, t, i) {
  const n = (r, a = (r + e / 60) % 6) => i - i * t * Math.max(Math.min(a, 4 - a, 1), 0);
  return [n(5), n(3), n(1)];
}
function h2(e, t, i) {
  const n = Zy(e, 1, 0.5);
  let r;
  for (t + i > 1 && (r = 1 / (t + i), t *= r, i *= r), r = 0; r < 3; r++)
    n[r] *= 1 - t - i, n[r] += t;
  return n;
}
function d2(e, t, i, n, r) {
  return e === r ? (t - i) / n + (t < i ? 6 : 0) : t === r ? (i - e) / n + 2 : (e - t) / n + 4;
}
function Jf(e) {
  const i = e.r / 255, n = e.g / 255, r = e.b / 255, a = Math.max(i, n, r), s = Math.min(i, n, r), o = (a + s) / 2;
  let l, u, c;
  return a !== s && (c = a - s, u = o > 0.5 ? c / (2 - a - s) : c / (a + s), l = d2(i, n, r, c, a), l = l * 60 + 0.5), [l | 0, u || 0, o];
}
function tv(e, t, i, n) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, i, n)).map(jn);
}
function ev(e, t, i) {
  return tv(Zy, e, t, i);
}
function f2(e, t, i) {
  return tv(h2, e, t, i);
}
function v2(e, t, i) {
  return tv(c2, e, t, i);
}
function Ky(e) {
  return (e % 360 + 360) % 360;
}
function p2(e) {
  const t = u2.exec(e);
  let i = 255, n;
  if (!t)
    return;
  t[5] !== n && (i = t[6] ? js(+t[5]) : jn(+t[5]));
  const r = Ky(+t[2]), a = +t[3] / 100, s = +t[4] / 100;
  return t[1] === "hwb" ? n = f2(r, a, s) : t[1] === "hsv" ? n = v2(r, a, s) : n = ev(r, a, s), {
    r: n[0],
    g: n[1],
    b: n[2],
    a: i
  };
}
function g2(e, t) {
  var i = Jf(e);
  i[0] = Ky(i[0] + t), i = ev(i), e.r = i[0], e.g = i[1], e.b = i[2];
}
function m2(e) {
  if (!e)
    return;
  const t = Jf(e), i = t[0], n = jp(t[1]), r = jp(t[2]);
  return e.a < 255 ? `hsla(${i}, ${n}%, ${r}%, ${vn(e.a)})` : `hsl(${i}, ${n}%, ${r}%)`;
}
const qp = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Zp = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function _2() {
  const e = {}, t = Object.keys(Zp), i = Object.keys(qp);
  let n, r, a, s, o;
  for (n = 0; n < t.length; n++) {
    for (s = o = t[n], r = 0; r < i.length; r++)
      a = i[r], o = o.replace(a, qp[a]);
    a = parseInt(Zp[s], 16), e[o] = [a >> 16 & 255, a >> 8 & 255, a & 255];
  }
  return e;
}
let nl;
function y2(e) {
  nl || (nl = _2(), nl.transparent = [0, 0, 0, 0]);
  const t = nl[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const b2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function x2(e) {
  const t = b2.exec(e);
  let i = 255, n, r, a;
  if (t) {
    if (t[7] !== n) {
      const s = +t[7];
      i = t[8] ? js(s) : Vn(s * 255, 0, 255);
    }
    return n = +t[1], r = +t[3], a = +t[5], n = 255 & (t[2] ? js(n) : Vn(n, 0, 255)), r = 255 & (t[4] ? js(r) : Vn(r, 0, 255)), a = 255 & (t[6] ? js(a) : Vn(a, 0, 255)), {
      r: n,
      g: r,
      b: a,
      a: i
    };
  }
}
function w2(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${vn(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Qc = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, pa = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function S2(e, t, i) {
  const n = pa(vn(e.r)), r = pa(vn(e.g)), a = pa(vn(e.b));
  return {
    r: jn(Qc(n + i * (pa(vn(t.r)) - n))),
    g: jn(Qc(r + i * (pa(vn(t.g)) - r))),
    b: jn(Qc(a + i * (pa(vn(t.b)) - a))),
    a: e.a + i * (t.a - e.a)
  };
}
function rl(e, t, i) {
  if (e) {
    let n = Jf(e);
    n[t] = Math.max(0, Math.min(n[t] + n[t] * i, t === 0 ? 360 : 1)), n = ev(n), e.r = n[0], e.g = n[1], e.b = n[2];
  }
}
function Qy(e, t) {
  return e && Object.assign(t || {}, e);
}
function Kp(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = jn(e[3]))) : (t = Qy(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = jn(t.a)), t;
}
function M2(e) {
  return e.charAt(0) === "r" ? x2(e) : p2(e);
}
class xo {
  constructor(t) {
    if (t instanceof xo)
      return t;
    const i = typeof t;
    let n;
    i === "object" ? n = Kp(t) : i === "string" && (n = s2(t) || y2(t) || M2(t)), this._rgb = n, this._valid = !!n;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = Qy(this._rgb);
    return t && (t.a = vn(t.a)), t;
  }
  set rgb(t) {
    this._rgb = Kp(t);
  }
  rgbString() {
    return this._valid ? w2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? l2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? m2(this._rgb) : void 0;
  }
  mix(t, i) {
    if (t) {
      const n = this.rgb, r = t.rgb;
      let a;
      const s = i === a ? 0.5 : i, o = 2 * s - 1, l = n.a - r.a, u = ((o * l === -1 ? o : (o + l) / (1 + o * l)) + 1) / 2;
      a = 1 - u, n.r = 255 & u * n.r + a * r.r + 0.5, n.g = 255 & u * n.g + a * r.g + 0.5, n.b = 255 & u * n.b + a * r.b + 0.5, n.a = s * n.a + (1 - s) * r.a, this.rgb = n;
    }
    return this;
  }
  interpolate(t, i) {
    return t && (this._rgb = S2(this._rgb, t._rgb, i)), this;
  }
  clone() {
    return new xo(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = jn(t), this;
  }
  clearer(t) {
    const i = this._rgb;
    return i.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, i = Go(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = i, this;
  }
  opaquer(t) {
    const i = this._rgb;
    return i.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return rl(this._rgb, 2, t), this;
  }
  darken(t) {
    return rl(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return rl(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return rl(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return g2(this._rgb, t), this;
  }
}
function rn() {
}
const k2 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function kt(e) {
  return e == null;
}
function ae(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function vt(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function Ce(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function Ri(e, t) {
  return Ce(e) ? e : t;
}
function ut(e, t) {
  return typeof e > "u" ? t : e;
}
const D2 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, Jy = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function $t(e, t, i) {
  if (e && typeof e.call == "function")
    return e.apply(i, t);
}
function Ct(e, t, i, n) {
  let r, a, s;
  if (ae(e))
    for (a = e.length, r = 0; r < a; r++)
      t.call(i, e[r], r);
  else if (vt(e))
    for (s = Object.keys(e), a = s.length, r = 0; r < a; r++)
      t.call(i, e[s[r]], s[r]);
}
function _u(e, t) {
  let i, n, r, a;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (i = 0, n = e.length; i < n; ++i)
    if (r = e[i], a = t[i], r.datasetIndex !== a.datasetIndex || r.index !== a.index)
      return !1;
  return !0;
}
function yu(e) {
  if (ae(e))
    return e.map(yu);
  if (vt(e)) {
    const t = /* @__PURE__ */ Object.create(null), i = Object.keys(e), n = i.length;
    let r = 0;
    for (; r < n; ++r)
      t[i[r]] = yu(e[i[r]]);
    return t;
  }
  return e;
}
function tb(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function T2(e, t, i, n) {
  if (!tb(e))
    return;
  const r = t[e], a = i[e];
  vt(r) && vt(a) ? wo(r, a, n) : t[e] = yu(a);
}
function wo(e, t, i) {
  const n = ae(t) ? t : [
    t
  ], r = n.length;
  if (!vt(e))
    return e;
  i = i || {};
  const a = i.merger || T2;
  let s;
  for (let o = 0; o < r; ++o) {
    if (s = n[o], !vt(s))
      continue;
    const l = Object.keys(s);
    for (let u = 0, c = l.length; u < c; ++u)
      a(l[u], e, s, i);
  }
  return e;
}
function so(e, t) {
  return wo(e, t, {
    merger: C2
  });
}
function C2(e, t, i) {
  if (!tb(e))
    return;
  const n = t[e], r = i[e];
  vt(n) && vt(r) ? so(n, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = yu(r));
}
const Qp = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function A2(e) {
  const t = e.split("."), i = [];
  let n = "";
  for (const r of t)
    n += r, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n), n = "");
  return i;
}
function P2(e) {
  const t = A2(e);
  return (i) => {
    for (const n of t) {
      if (n === "")
        break;
      i = i && i[n];
    }
    return i;
  };
}
function ra(e, t) {
  return (Qp[t] || (Qp[t] = P2(t)))(e);
}
function iv(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const So = (e) => typeof e < "u", tr = (e) => typeof e == "function", Jp = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const i of e)
    if (!t.has(i))
      return !1;
  return !0;
};
function E2(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const At = Math.PI, Xt = 2 * At, L2 = Xt + At, bu = Number.POSITIVE_INFINITY, O2 = At / 180, ce = At / 2, or = At / 4, tg = At * 2 / 3, eb = Math.log10, Xi = Math.sign;
function oo(e, t, i) {
  return Math.abs(e - t) < i;
}
function eg(e) {
  const t = Math.round(e);
  e = oo(e, t, e / 1e3) ? t : e;
  const i = Math.pow(10, Math.floor(eb(e))), n = e / i;
  return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i;
}
function I2(e) {
  const t = [], i = Math.sqrt(e);
  let n;
  for (n = 1; n < i; n++)
    e % n === 0 && (t.push(n), t.push(e / n));
  return i === (i | 0) && t.push(i), t.sort((r, a) => r - a).pop(), t;
}
function R2(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function Mo(e) {
  return !R2(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function N2(e, t) {
  const i = Math.round(e);
  return i - t <= e && i + t >= e;
}
function F2(e, t, i) {
  let n, r, a;
  for (n = 0, r = e.length; n < r; n++)
    a = e[n][i], isNaN(a) || (t.min = Math.min(t.min, a), t.max = Math.max(t.max, a));
}
function pn(e) {
  return e * (At / 180);
}
function B2(e) {
  return e * (180 / At);
}
function ig(e) {
  if (!Ce(e))
    return;
  let t = 1, i = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, i++;
  return i;
}
function ib(e, t) {
  const i = t.x - e.x, n = t.y - e.y, r = Math.sqrt(i * i + n * n);
  let a = Math.atan2(n, i);
  return a < -0.5 * At && (a += Xt), {
    angle: a,
    distance: r
  };
}
function Nd(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function $2(e, t) {
  return (e - t + L2) % Xt - At;
}
function je(e) {
  return (e % Xt + Xt) % Xt;
}
function ko(e, t, i, n) {
  const r = je(e), a = je(t), s = je(i), o = je(a - r), l = je(s - r), u = je(r - a), c = je(r - s);
  return r === a || r === s || n && a === s || o > l && u < c;
}
function Se(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function z2(e) {
  return Se(e, -32768, 32767);
}
function gn(e, t, i, n = 1e-6) {
  return e >= Math.min(t, i) - n && e <= Math.max(t, i) + n;
}
function nv(e, t, i) {
  i = i || ((s) => e[s] < t);
  let n = e.length - 1, r = 0, a;
  for (; n - r > 1; )
    a = r + n >> 1, i(a) ? r = a : n = a;
  return {
    lo: r,
    hi: n
  };
}
const zr = (e, t, i, n) => nv(e, i, n ? (r) => {
  const a = e[r][t];
  return a < i || a === i && e[r + 1][t] === i;
} : (r) => e[r][t] < i), V2 = (e, t, i) => nv(e, i, (n) => e[n][t] >= i);
function H2(e, t, i) {
  let n = 0, r = e.length;
  for (; n < r && e[n] < t; )
    n++;
  for (; r > n && e[r - 1] > i; )
    r--;
  return n > 0 || r < e.length ? e.slice(n, r) : e;
}
const nb = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function Y2(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), nb.forEach((i) => {
    const n = "_onData" + iv(i), r = e[i];
    Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !1,
      value(...a) {
        const s = r.apply(this, a);
        return e._chartjs.listeners.forEach((o) => {
          typeof o[n] == "function" && o[n](...a);
        }), s;
      }
    });
  });
}
function ng(e, t) {
  const i = e._chartjs;
  if (!i)
    return;
  const n = i.listeners, r = n.indexOf(t);
  r !== -1 && n.splice(r, 1), !(n.length > 0) && (nb.forEach((a) => {
    delete e[a];
  }), delete e._chartjs);
}
function rb(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const ab = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function sb(e, t) {
  let i = [], n = !1;
  return function(...r) {
    i = r, n || (n = !0, ab.call(window, () => {
      n = !1, e.apply(t, i);
    }));
  };
}
function W2(e, t) {
  let i;
  return function(...n) {
    return t ? (clearTimeout(i), i = setTimeout(e, t, n)) : e.apply(this, n), t;
  };
}
const rv = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", xe = (e, t, i) => e === "start" ? t : e === "end" ? i : (t + i) / 2, U2 = (e, t, i, n) => e === (n ? "left" : "right") ? i : e === "center" ? (t + i) / 2 : t;
function G2(e, t, i) {
  const n = t.length;
  let r = 0, a = n;
  if (e._sorted) {
    const { iScale: s, vScale: o, _parsed: l } = e, u = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, c = s.axis, { min: h, max: d, minDefined: f, maxDefined: v } = s.getUserBounds();
    if (f) {
      if (r = Math.min(
        // @ts-expect-error Need to type _parsed
        zr(l, c, h).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? n : zr(t, c, s.getPixelForValue(h)).lo
      ), u) {
        const p = l.slice(0, r + 1).reverse().findIndex((g) => !kt(g[o.axis]));
        r -= Math.max(0, p);
      }
      r = Se(r, 0, n - 1);
    }
    if (v) {
      let p = Math.max(
        // @ts-expect-error Need to type _parsed
        zr(l, s.axis, d, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? 0 : zr(t, c, s.getPixelForValue(d), !0).hi + 1
      );
      if (u) {
        const g = l.slice(p - 1).findIndex((m) => !kt(m[o.axis]));
        p += Math.max(0, g);
      }
      a = Se(p, r, n) - r;
    } else
      a = n - r;
  }
  return {
    start: r,
    count: a
  };
}
function X2(e) {
  const { xScale: t, yScale: i, _scaleRanges: n } = e, r = {
    xmin: t.min,
    xmax: t.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!n)
    return e._scaleRanges = r, !0;
  const a = n.xmin !== t.min || n.xmax !== t.max || n.ymin !== i.min || n.ymax !== i.max;
  return Object.assign(n, r), a;
}
const al = (e) => e === 0 || e === 1, rg = (e, t, i) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Xt / i)), ag = (e, t, i) => Math.pow(2, -10 * e) * Math.sin((e - t) * Xt / i) + 1, lo = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * ce) + 1,
  easeOutSine: (e) => Math.sin(e * ce),
  easeInOutSine: (e) => -0.5 * (Math.cos(At * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => al(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => al(e) ? e : rg(e, 0.075, 0.3),
  easeOutElastic: (e) => al(e) ? e : ag(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return al(e) ? e : e < 0.5 ? 0.5 * rg(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * ag(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - lo.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? lo.easeInBounce(e * 2) * 0.5 : lo.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function av(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function sg(e) {
  return av(e) ? e : new xo(e);
}
function Jc(e) {
  return av(e) ? e : new xo(e).saturate(0.5).darken(0.1).hexString();
}
const j2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], q2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function Z2(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: q2
    },
    numbers: {
      type: "number",
      properties: j2
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function K2(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const og = /* @__PURE__ */ new Map();
function Q2(e, t) {
  t = t || {};
  const i = e + JSON.stringify(t);
  let n = og.get(i);
  return n || (n = new Intl.NumberFormat(e, t), og.set(i, n)), n;
}
function sv(e, t, i) {
  return Q2(t, i).format(e);
}
const J2 = {
  values(e) {
    return ae(e) ? e : "" + e;
  },
  numeric(e, t, i) {
    if (e === 0)
      return "0";
    const n = this.chart.options.locale;
    let r, a = e;
    if (i.length > 1) {
      const u = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (u < 1e-4 || u > 1e15) && (r = "scientific"), a = tM(e, i);
    }
    const s = eb(Math.abs(a)), o = isNaN(s) ? 1 : Math.max(Math.min(-1 * Math.floor(s), 20), 0), l = {
      notation: r,
      minimumFractionDigits: o,
      maximumFractionDigits: o
    };
    return Object.assign(l, this.options.ticks.format), sv(e, n, l);
  }
};
function tM(e, t) {
  let i = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(i) >= 1 && e !== Math.floor(e) && (i = e - Math.floor(e)), i;
}
var ob = {
  formatters: J2
};
function eM(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, i) => i.lineWidth,
      tickColor: (t, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: ob.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const aa = /* @__PURE__ */ Object.create(null), Fd = /* @__PURE__ */ Object.create(null);
function uo(e, t) {
  if (!t)
    return e;
  const i = t.split(".");
  for (let n = 0, r = i.length; n < r; ++n) {
    const a = i[n];
    e = e[a] || (e[a] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function th(e, t, i) {
  return typeof t == "string" ? wo(uo(e, t), i) : wo(uo(e, ""), t);
}
class iM {
  constructor(t, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (n, r) => Jc(r.backgroundColor), this.hoverBorderColor = (n, r) => Jc(r.borderColor), this.hoverColor = (n, r) => Jc(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(i);
  }
  set(t, i) {
    return th(this, t, i);
  }
  get(t) {
    return uo(this, t);
  }
  describe(t, i) {
    return th(Fd, t, i);
  }
  override(t, i) {
    return th(aa, t, i);
  }
  route(t, i, n, r) {
    const a = uo(this, t), s = uo(this, n), o = "_" + i;
    Object.defineProperties(a, {
      [o]: {
        value: a[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const l = this[o], u = s[r];
          return vt(l) ? Object.assign({}, u, l) : ut(l, u);
        },
        set(l) {
          this[o] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((i) => i(this));
  }
}
var ie = /* @__PURE__ */ new iM({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  Z2,
  K2,
  eM
]);
function nM(e) {
  return !e || kt(e.size) || kt(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function lg(e, t, i, n, r) {
  let a = t[r];
  return a || (a = t[r] = e.measureText(r).width, i.push(r)), a > n && (n = a), n;
}
function lr(e, t, i) {
  const n = e.currentDevicePixelRatio, r = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((t - r) * n) / n + r;
}
function ug(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function Bd(e, t, i, n) {
  lb(e, t, i, n, null);
}
function lb(e, t, i, n, r) {
  let a, s, o, l, u, c, h, d;
  const f = t.pointStyle, v = t.rotation, p = t.radius;
  let g = (v || 0) * O2;
  if (f && typeof f == "object" && (a = f.toString(), a === "[object HTMLImageElement]" || a === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(i, n), e.rotate(g), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), e.restore();
    return;
  }
  if (!(isNaN(p) || p <= 0)) {
    switch (e.beginPath(), f) {
      // Default includes circle
      default:
        r ? e.ellipse(i, n, r / 2, p, 0, 0, Xt) : e.arc(i, n, p, 0, Xt), e.closePath();
        break;
      case "triangle":
        c = r ? r / 2 : p, e.moveTo(i + Math.sin(g) * c, n - Math.cos(g) * p), g += tg, e.lineTo(i + Math.sin(g) * c, n - Math.cos(g) * p), g += tg, e.lineTo(i + Math.sin(g) * c, n - Math.cos(g) * p), e.closePath();
        break;
      case "rectRounded":
        u = p * 0.516, l = p - u, s = Math.cos(g + or) * l, h = Math.cos(g + or) * (r ? r / 2 - u : l), o = Math.sin(g + or) * l, d = Math.sin(g + or) * (r ? r / 2 - u : l), e.arc(i - h, n - o, u, g - At, g - ce), e.arc(i + d, n - s, u, g - ce, g), e.arc(i + h, n + o, u, g, g + ce), e.arc(i - d, n + s, u, g + ce, g + At), e.closePath();
        break;
      case "rect":
        if (!v) {
          l = Math.SQRT1_2 * p, c = r ? r / 2 : l, e.rect(i - c, n - l, 2 * c, 2 * l);
          break;
        }
        g += or;
      /* falls through */
      case "rectRot":
        h = Math.cos(g) * (r ? r / 2 : p), s = Math.cos(g) * p, o = Math.sin(g) * p, d = Math.sin(g) * (r ? r / 2 : p), e.moveTo(i - h, n - o), e.lineTo(i + d, n - s), e.lineTo(i + h, n + o), e.lineTo(i - d, n + s), e.closePath();
        break;
      case "crossRot":
        g += or;
      /* falls through */
      case "cross":
        h = Math.cos(g) * (r ? r / 2 : p), s = Math.cos(g) * p, o = Math.sin(g) * p, d = Math.sin(g) * (r ? r / 2 : p), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + d, n - s), e.lineTo(i - d, n + s);
        break;
      case "star":
        h = Math.cos(g) * (r ? r / 2 : p), s = Math.cos(g) * p, o = Math.sin(g) * p, d = Math.sin(g) * (r ? r / 2 : p), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + d, n - s), e.lineTo(i - d, n + s), g += or, h = Math.cos(g) * (r ? r / 2 : p), s = Math.cos(g) * p, o = Math.sin(g) * p, d = Math.sin(g) * (r ? r / 2 : p), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + d, n - s), e.lineTo(i - d, n + s);
        break;
      case "line":
        s = r ? r / 2 : Math.cos(g) * p, o = Math.sin(g) * p, e.moveTo(i - s, n - o), e.lineTo(i + s, n + o);
        break;
      case "dash":
        e.moveTo(i, n), e.lineTo(i + Math.cos(g) * (r ? r / 2 : p), n + Math.sin(g) * p);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function Do(e, t, i) {
  return i = i || 0.5, !t || e && e.x > t.left - i && e.x < t.right + i && e.y > t.top - i && e.y < t.bottom + i;
}
function vc(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function pc(e) {
  e.restore();
}
function rM(e, t, i, n, r) {
  if (!t)
    return e.lineTo(i.x, i.y);
  if (r === "middle") {
    const a = (t.x + i.x) / 2;
    e.lineTo(a, t.y), e.lineTo(a, i.y);
  } else r === "after" != !!n ? e.lineTo(t.x, i.y) : e.lineTo(i.x, t.y);
  e.lineTo(i.x, i.y);
}
function aM(e, t, i, n) {
  if (!t)
    return e.lineTo(i.x, i.y);
  e.bezierCurveTo(n ? t.cp1x : t.cp2x, n ? t.cp1y : t.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y);
}
function sM(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), kt(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function oM(e, t, i, n, r) {
  if (r.strikethrough || r.underline) {
    const a = e.measureText(n), s = t - a.actualBoundingBoxLeft, o = t + a.actualBoundingBoxRight, l = i - a.actualBoundingBoxAscent, u = i + a.actualBoundingBoxDescent, c = r.strikethrough ? (l + u) / 2 : u;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = r.decorationWidth || 2, e.moveTo(s, c), e.lineTo(o, c), e.stroke();
  }
}
function lM(e, t) {
  const i = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = i;
}
function To(e, t, i, n, r, a = {}) {
  const s = ae(t) ? t : [
    t
  ], o = a.strokeWidth > 0 && a.strokeColor !== "";
  let l, u;
  for (e.save(), e.font = r.string, sM(e, a), l = 0; l < s.length; ++l)
    u = s[l], a.backdrop && lM(e, a.backdrop), o && (a.strokeColor && (e.strokeStyle = a.strokeColor), kt(a.strokeWidth) || (e.lineWidth = a.strokeWidth), e.strokeText(u, i, n, a.maxWidth)), e.fillText(u, i, n, a.maxWidth), oM(e, i, n, u, a), n += Number(r.lineHeight);
  e.restore();
}
function xu(e, t) {
  const { x: i, y: n, w: r, h: a, radius: s } = t;
  e.arc(i + s.topLeft, n + s.topLeft, s.topLeft, 1.5 * At, At, !0), e.lineTo(i, n + a - s.bottomLeft), e.arc(i + s.bottomLeft, n + a - s.bottomLeft, s.bottomLeft, At, ce, !0), e.lineTo(i + r - s.bottomRight, n + a), e.arc(i + r - s.bottomRight, n + a - s.bottomRight, s.bottomRight, ce, 0, !0), e.lineTo(i + r, n + s.topRight), e.arc(i + r - s.topRight, n + s.topRight, s.topRight, 0, -ce, !0), e.lineTo(i + s.topLeft, n);
}
const uM = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, cM = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function hM(e, t) {
  const i = ("" + e).match(uM);
  if (!i || i[1] === "normal")
    return t * 1.2;
  switch (e = +i[2], i[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const dM = (e) => +e || 0;
function ov(e, t) {
  const i = {}, n = vt(t), r = n ? Object.keys(t) : t, a = vt(e) ? n ? (s) => ut(e[s], e[t[s]]) : (s) => e[s] : () => e;
  for (const s of r)
    i[s] = dM(a(s));
  return i;
}
function ub(e) {
  return ov(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Ga(e) {
  return ov(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function gi(e) {
  const t = ub(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function Me(e, t) {
  e = e || {}, t = t || ie.font;
  let i = ut(e.size, t.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let n = ut(e.style, t.style);
  n && !("" + n).match(cM) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
  const r = {
    family: ut(e.family, t.family),
    lineHeight: hM(ut(e.lineHeight, t.lineHeight), i),
    size: i,
    style: n,
    weight: ut(e.weight, t.weight),
    string: ""
  };
  return r.string = nM(r), r;
}
function sl(e, t, i, n) {
  let r, a, s;
  for (r = 0, a = e.length; r < a; ++r)
    if (s = e[r], s !== void 0 && s !== void 0)
      return s;
}
function fM(e, t, i) {
  const { min: n, max: r } = e, a = Jy(t, (r - n) / 2), s = (o, l) => i && o === 0 ? 0 : o + l;
  return {
    min: s(n, -Math.abs(a)),
    max: s(r, a)
  };
}
function la(e, t) {
  return Object.assign(Object.create(e), t);
}
function lv(e, t = [
  ""
], i, n, r = () => e[0]) {
  const a = i || e;
  typeof n > "u" && (n = fb("_fallback", e));
  const s = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: a,
    _fallback: n,
    _getTarget: r,
    override: (o) => lv([
      o,
      ...e
    ], t, a, n)
  };
  return new Proxy(s, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, l) {
      return delete o[l], delete o._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(o, l) {
      return hb(o, l, () => xM(l, t, e, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, l) {
      return Reflect.getOwnPropertyDescriptor(o._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(o, l) {
      return hg(o).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(o) {
      return hg(o);
    },
    /**
    * A trap for setting property values.
    */
    set(o, l, u) {
      const c = o._storage || (o._storage = r());
      return o[l] = c[l] = u, delete o._keys, !0;
    }
  });
}
function is(e, t, i, n) {
  const r = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: cb(e, n),
    setContext: (a) => is(e, a, i, n),
    override: (a) => is(e.override(a), t, i, n)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, s) {
      return delete a[s], delete e[s], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, s, o) {
      return hb(a, s, () => pM(a, s, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, s) {
      return a._descriptors.allKeys ? Reflect.has(e, s) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, s);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(a, s) {
      return Reflect.has(e, s);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(a, s, o) {
      return e[s] = o, delete a[s], !0;
    }
  });
}
function cb(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = t.scriptable, _indexable: n = t.indexable, _allKeys: r = t.allKeys } = e;
  return {
    allKeys: r,
    scriptable: i,
    indexable: n,
    isScriptable: tr(i) ? i : () => i,
    isIndexable: tr(n) ? n : () => n
  };
}
const vM = (e, t) => e ? e + iv(t) : t, uv = (e, t) => vt(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function hb(e, t, i) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const n = i();
  return e[t] = n, n;
}
function pM(e, t, i) {
  const { _proxy: n, _context: r, _subProxy: a, _descriptors: s } = e;
  let o = n[t];
  return tr(o) && s.isScriptable(t) && (o = gM(t, o, e, i)), ae(o) && o.length && (o = mM(t, o, e, s.isIndexable)), uv(t, o) && (o = is(o, r, a && a[t], s)), o;
}
function gM(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: s, _stack: o } = i;
  if (o.has(e))
    throw new Error("Recursion detected: " + Array.from(o).join("->") + "->" + e);
  o.add(e);
  let l = t(a, s || n);
  return o.delete(e), uv(e, l) && (l = cv(r._scopes, r, e, l)), l;
}
function mM(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: s, _descriptors: o } = i;
  if (typeof a.index < "u" && n(e))
    return t[a.index % t.length];
  if (vt(t[0])) {
    const l = t, u = r._scopes.filter((c) => c !== l);
    t = [];
    for (const c of l) {
      const h = cv(u, r, e, c);
      t.push(is(h, a, s && s[e], o));
    }
  }
  return t;
}
function db(e, t, i) {
  return tr(e) ? e(t, i) : e;
}
const _M = (e, t) => e === !0 ? t : typeof e == "string" ? ra(t, e) : void 0;
function yM(e, t, i, n, r) {
  for (const a of t) {
    const s = _M(i, a);
    if (s) {
      e.add(s);
      const o = db(s._fallback, i, r);
      if (typeof o < "u" && o !== i && o !== n)
        return o;
    } else if (s === !1 && typeof n < "u" && i !== n)
      return null;
  }
  return !1;
}
function cv(e, t, i, n) {
  const r = t._rootScopes, a = db(t._fallback, i, n), s = [
    ...e,
    ...r
  ], o = /* @__PURE__ */ new Set();
  o.add(n);
  let l = cg(o, s, i, a || i, n);
  return l === null || typeof a < "u" && a !== i && (l = cg(o, s, a, l, n), l === null) ? !1 : lv(Array.from(o), [
    ""
  ], r, a, () => bM(t, i, n));
}
function cg(e, t, i, n, r) {
  for (; i; )
    i = yM(e, t, i, n, r);
  return i;
}
function bM(e, t, i) {
  const n = e._getTarget();
  t in n || (n[t] = {});
  const r = n[t];
  return ae(r) && vt(i) ? i : r || {};
}
function xM(e, t, i, n) {
  let r;
  for (const a of t)
    if (r = fb(vM(a, e), i), typeof r < "u")
      return uv(e, r) ? cv(i, n, e, r) : r;
}
function fb(e, t) {
  for (const i of t) {
    if (!i)
      continue;
    const n = i[e];
    if (typeof n < "u")
      return n;
  }
}
function hg(e) {
  let t = e._keys;
  return t || (t = e._keys = wM(e._scopes)), t;
}
function wM(e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    for (const n of Object.keys(i).filter((r) => !r.startsWith("_")))
      t.add(n);
  return Array.from(t);
}
const SM = Number.EPSILON || 1e-14, ns = (e, t) => t < e.length && !e[t].skip && e[t], vb = (e) => e === "x" ? "y" : "x";
function MM(e, t, i, n) {
  const r = e.skip ? t : e, a = t, s = i.skip ? t : i, o = Nd(a, r), l = Nd(s, a);
  let u = o / (o + l), c = l / (o + l);
  u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c;
  const h = n * u, d = n * c;
  return {
    previous: {
      x: a.x - h * (s.x - r.x),
      y: a.y - h * (s.y - r.y)
    },
    next: {
      x: a.x + d * (s.x - r.x),
      y: a.y + d * (s.y - r.y)
    }
  };
}
function kM(e, t, i) {
  const n = e.length;
  let r, a, s, o, l, u = ns(e, 0);
  for (let c = 0; c < n - 1; ++c)
    if (l = u, u = ns(e, c + 1), !(!l || !u)) {
      if (oo(t[c], 0, SM)) {
        i[c] = i[c + 1] = 0;
        continue;
      }
      r = i[c] / t[c], a = i[c + 1] / t[c], o = Math.pow(r, 2) + Math.pow(a, 2), !(o <= 9) && (s = 3 / Math.sqrt(o), i[c] = r * s * t[c], i[c + 1] = a * s * t[c]);
    }
}
function DM(e, t, i = "x") {
  const n = vb(i), r = e.length;
  let a, s, o, l = ns(e, 0);
  for (let u = 0; u < r; ++u) {
    if (s = o, o = l, l = ns(e, u + 1), !o)
      continue;
    const c = o[i], h = o[n];
    s && (a = (c - s[i]) / 3, o[`cp1${i}`] = c - a, o[`cp1${n}`] = h - a * t[u]), l && (a = (l[i] - c) / 3, o[`cp2${i}`] = c + a, o[`cp2${n}`] = h + a * t[u]);
  }
}
function TM(e, t = "x") {
  const i = vb(t), n = e.length, r = Array(n).fill(0), a = Array(n);
  let s, o, l, u = ns(e, 0);
  for (s = 0; s < n; ++s)
    if (o = l, l = u, u = ns(e, s + 1), !!l) {
      if (u) {
        const c = u[t] - l[t];
        r[s] = c !== 0 ? (u[i] - l[i]) / c : 0;
      }
      a[s] = o ? u ? Xi(r[s - 1]) !== Xi(r[s]) ? 0 : (r[s - 1] + r[s]) / 2 : r[s - 1] : r[s];
    }
  kM(e, r, a), DM(e, a, t);
}
function ol(e, t, i) {
  return Math.max(Math.min(e, i), t);
}
function CM(e, t) {
  let i, n, r, a, s, o = Do(e[0], t);
  for (i = 0, n = e.length; i < n; ++i)
    s = a, a = o, o = i < n - 1 && Do(e[i + 1], t), a && (r = e[i], s && (r.cp1x = ol(r.cp1x, t.left, t.right), r.cp1y = ol(r.cp1y, t.top, t.bottom)), o && (r.cp2x = ol(r.cp2x, t.left, t.right), r.cp2y = ol(r.cp2y, t.top, t.bottom)));
}
function AM(e, t, i, n, r) {
  let a, s, o, l;
  if (t.spanGaps && (e = e.filter((u) => !u.skip)), t.cubicInterpolationMode === "monotone")
    TM(e, r);
  else {
    let u = n ? e[e.length - 1] : e[0];
    for (a = 0, s = e.length; a < s; ++a)
      o = e[a], l = MM(u, o, e[Math.min(a + 1, s - (n ? 0 : 1)) % s], t.tension), o.cp1x = l.previous.x, o.cp1y = l.previous.y, o.cp2x = l.next.x, o.cp2y = l.next.y, u = o;
  }
  t.capBezierPoints && CM(e, i);
}
function hv() {
  return typeof window < "u" && typeof document < "u";
}
function dv(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function wu(e, t, i) {
  let n;
  return typeof e == "string" ? (n = parseInt(e, 10), e.indexOf("%") !== -1 && (n = n / 100 * t.parentNode[i])) : n = e, n;
}
const gc = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function PM(e, t) {
  return gc(e).getPropertyValue(t);
}
const EM = [
  "top",
  "right",
  "bottom",
  "left"
];
function jr(e, t, i) {
  const n = {};
  i = i ? "-" + i : "";
  for (let r = 0; r < 4; r++) {
    const a = EM[r];
    n[a] = parseFloat(e[t + "-" + a + i]) || 0;
  }
  return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
}
const LM = (e, t, i) => (e > 0 || t > 0) && (!i || !i.shadowRoot);
function OM(e, t) {
  const i = e.touches, n = i && i.length ? i[0] : e, { offsetX: r, offsetY: a } = n;
  let s = !1, o, l;
  if (LM(r, a, e.target))
    o = r, l = a;
  else {
    const u = t.getBoundingClientRect();
    o = n.clientX - u.left, l = n.clientY - u.top, s = !0;
  }
  return {
    x: o,
    y: l,
    box: s
  };
}
function Rr(e, t) {
  if ("native" in e)
    return e;
  const { canvas: i, currentDevicePixelRatio: n } = t, r = gc(i), a = r.boxSizing === "border-box", s = jr(r, "padding"), o = jr(r, "border", "width"), { x: l, y: u, box: c } = OM(e, i), h = s.left + (c && o.left), d = s.top + (c && o.top);
  let { width: f, height: v } = t;
  return a && (f -= s.width + o.width, v -= s.height + o.height), {
    x: Math.round((l - h) / f * i.width / n),
    y: Math.round((u - d) / v * i.height / n)
  };
}
function IM(e, t, i) {
  let n, r;
  if (t === void 0 || i === void 0) {
    const a = e && dv(e);
    if (!a)
      t = e.clientWidth, i = e.clientHeight;
    else {
      const s = a.getBoundingClientRect(), o = gc(a), l = jr(o, "border", "width"), u = jr(o, "padding");
      t = s.width - u.width - l.width, i = s.height - u.height - l.height, n = wu(o.maxWidth, a, "clientWidth"), r = wu(o.maxHeight, a, "clientHeight");
    }
  }
  return {
    width: t,
    height: i,
    maxWidth: n || bu,
    maxHeight: r || bu
  };
}
const Hn = (e) => Math.round(e * 10) / 10;
function RM(e, t, i, n) {
  const r = gc(e), a = jr(r, "margin"), s = wu(r.maxWidth, e, "clientWidth") || bu, o = wu(r.maxHeight, e, "clientHeight") || bu, l = IM(e, t, i);
  let { width: u, height: c } = l;
  if (r.boxSizing === "content-box") {
    const d = jr(r, "border", "width"), f = jr(r, "padding");
    u -= f.width + d.width, c -= f.height + d.height;
  }
  return u = Math.max(0, u - a.width), c = Math.max(0, n ? u / n : c - a.height), u = Hn(Math.min(u, s, l.maxWidth)), c = Hn(Math.min(c, o, l.maxHeight)), u && !c && (c = Hn(u / 2)), (t !== void 0 || i !== void 0) && n && l.height && c > l.height && (c = l.height, u = Hn(Math.floor(c * n))), {
    width: u,
    height: c
  };
}
function dg(e, t, i) {
  const n = t || 1, r = Hn(e.height * n), a = Hn(e.width * n);
  e.height = Hn(e.height), e.width = Hn(e.width);
  const s = e.canvas;
  return s.style && (i || !s.style.height && !s.style.width) && (s.style.height = `${e.height}px`, s.style.width = `${e.width}px`), e.currentDevicePixelRatio !== n || s.height !== r || s.width !== a ? (e.currentDevicePixelRatio = n, s.height = r, s.width = a, e.ctx.setTransform(n, 0, 0, n, 0, 0), !0) : !1;
}
const NM = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    hv() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function fg(e, t) {
  const i = PM(e, t), n = i && i.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
function Nr(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: e.y + i * (t.y - e.y)
  };
}
function FM(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: n === "middle" ? i < 0.5 ? e.y : t.y : n === "after" ? i < 1 ? e.y : t.y : i > 0 ? t.y : e.y
  };
}
function BM(e, t, i, n) {
  const r = {
    x: e.cp2x,
    y: e.cp2y
  }, a = {
    x: t.cp1x,
    y: t.cp1y
  }, s = Nr(e, r, i), o = Nr(r, a, i), l = Nr(a, t, i), u = Nr(s, o, i), c = Nr(o, l, i);
  return Nr(u, c, i);
}
const $M = function(e, t) {
  return {
    x(i) {
      return e + e + t - i;
    },
    setWidth(i) {
      t = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, n) {
      return i - n;
    },
    leftForLtr(i, n) {
      return i - n;
    }
  };
}, zM = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function Xa(e, t, i) {
  return e ? $M(t, i) : zM();
}
function pb(e, t) {
  let i, n;
  (t === "ltr" || t === "rtl") && (i = e.canvas.style, n = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", t, "important"), e.prevTextDirection = n);
}
function gb(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function mb(e) {
  return e === "angle" ? {
    between: ko,
    compare: $2,
    normalize: je
  } : {
    between: gn,
    compare: (t, i) => t - i,
    normalize: (t) => t
  };
}
function vg({ start: e, end: t, count: i, loop: n, style: r }) {
  return {
    start: e % i,
    end: t % i,
    loop: n && (t - e + 1) % i === 0,
    style: r
  };
}
function VM(e, t, i) {
  const { property: n, start: r, end: a } = i, { between: s, normalize: o } = mb(n), l = t.length;
  let { start: u, end: c, loop: h } = e, d, f;
  if (h) {
    for (u += l, c += l, d = 0, f = l; d < f && s(o(t[u % l][n]), r, a); ++d)
      u--, c--;
    u %= l, c %= l;
  }
  return c < u && (c += l), {
    start: u,
    end: c,
    loop: h,
    style: e.style
  };
}
function _b(e, t, i) {
  if (!i)
    return [
      e
    ];
  const { property: n, start: r, end: a } = i, s = t.length, { compare: o, between: l, normalize: u } = mb(n), { start: c, end: h, loop: d, style: f } = VM(e, t, i), v = [];
  let p = !1, g = null, m, _, y;
  const b = () => l(r, y, m) && o(r, y) !== 0, w = () => o(a, m) === 0 || l(a, y, m), S = () => p || b(), M = () => !p || w();
  for (let k = c, T = c; k <= h; ++k)
    _ = t[k % s], !_.skip && (m = u(_[n]), m !== y && (p = l(m, r, a), g === null && S() && (g = o(m, r) === 0 ? k : T), g !== null && M() && (v.push(vg({
      start: g,
      end: k,
      loop: d,
      count: s,
      style: f
    })), g = null), T = k, y = m));
  return g !== null && v.push(vg({
    start: g,
    end: h,
    loop: d,
    count: s,
    style: f
  })), v;
}
function yb(e, t) {
  const i = [], n = e.segments;
  for (let r = 0; r < n.length; r++) {
    const a = _b(n[r], e.points, t);
    a.length && i.push(...a);
  }
  return i;
}
function HM(e, t, i, n) {
  let r = 0, a = t - 1;
  if (i && !n)
    for (; r < t && !e[r].skip; )
      r++;
  for (; r < t && e[r].skip; )
    r++;
  for (r %= t, i && (a += r); a > r && e[a % t].skip; )
    a--;
  return a %= t, {
    start: r,
    end: a
  };
}
function YM(e, t, i, n) {
  const r = e.length, a = [];
  let s = t, o = e[t], l;
  for (l = t + 1; l <= i; ++l) {
    const u = e[l % r];
    u.skip || u.stop ? o.skip || (n = !1, a.push({
      start: t % r,
      end: (l - 1) % r,
      loop: n
    }), t = s = u.stop ? l : null) : (s = l, o.skip && (t = l)), o = u;
  }
  return s !== null && a.push({
    start: t % r,
    end: s % r,
    loop: n
  }), a;
}
function WM(e, t) {
  const i = e.points, n = e.options.spanGaps, r = i.length;
  if (!r)
    return [];
  const a = !!e._loop, { start: s, end: o } = HM(i, r, a, n);
  if (n === !0)
    return pg(e, [
      {
        start: s,
        end: o,
        loop: a
      }
    ], i, t);
  const l = o < s ? o + r : o, u = !!e._fullLoop && s === 0 && o === r - 1;
  return pg(e, YM(i, s, l, u), i, t);
}
function pg(e, t, i, n) {
  return !n || !n.setContext || !i ? t : UM(e, t, i, n);
}
function UM(e, t, i, n) {
  const r = e._chart.getContext(), a = gg(e.options), { _datasetIndex: s, options: { spanGaps: o } } = e, l = i.length, u = [];
  let c = a, h = t[0].start, d = h;
  function f(v, p, g, m) {
    const _ = o ? -1 : 1;
    if (v !== p) {
      for (v += l; i[v % l].skip; )
        v -= _;
      for (; i[p % l].skip; )
        p += _;
      v % l !== p % l && (u.push({
        start: v % l,
        end: p % l,
        loop: g,
        style: m
      }), c = m, h = p % l);
    }
  }
  for (const v of t) {
    h = o ? h : v.start;
    let p = i[h % l], g;
    for (d = h + 1; d <= v.end; d++) {
      const m = i[d % l];
      g = gg(n.setContext(la(r, {
        type: "segment",
        p0: p,
        p1: m,
        p0DataIndex: (d - 1) % l,
        p1DataIndex: d % l,
        datasetIndex: s
      }))), GM(g, c) && f(h, d - 1, v.loop, c), p = m, c = g;
    }
    h < d - 1 && f(h, d - 1, v.loop, c);
  }
  return u;
}
function gg(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function GM(e, t) {
  if (!t)
    return !1;
  const i = [], n = function(r, a) {
    return av(a) ? (i.includes(a) || i.push(a), i.indexOf(a)) : a;
  };
  return JSON.stringify(e, n) !== JSON.stringify(t, n);
}
function ll(e, t, i) {
  return e.options.clip ? e[i] : t[i];
}
function XM(e, t) {
  const { xScale: i, yScale: n } = e;
  return i && n ? {
    left: ll(i, t, "left"),
    right: ll(i, t, "right"),
    top: ll(n, t, "top"),
    bottom: ll(n, t, "bottom")
  } : t;
}
function bb(e, t) {
  const i = t._clip;
  if (i.disabled)
    return !1;
  const n = XM(t, e.chartArea);
  return {
    left: i.left === !1 ? 0 : n.left - (i.left === !0 ? 0 : i.left),
    right: i.right === !1 ? e.width : n.right + (i.right === !0 ? 0 : i.right),
    top: i.top === !1 ? 0 : n.top - (i.top === !0 ? 0 : i.top),
    bottom: i.bottom === !1 ? e.height : n.bottom + (i.bottom === !0 ? 0 : i.bottom)
  };
}
let jM = class {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, i, n, r) {
    const a = i.listeners[r], s = i.duration;
    a.forEach((o) => o({
      chart: t,
      initial: i.initial,
      numSteps: s,
      currentStep: Math.min(n - i.start, s)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = ab.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let i = 0;
    this._charts.forEach((n, r) => {
      if (!n.running || !n.items.length)
        return;
      const a = n.items;
      let s = a.length - 1, o = !1, l;
      for (; s >= 0; --s)
        l = a[s], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(t), o = !0) : (a[s] = a[a.length - 1], a.pop());
      o && (r.draw(), this._notify(r, n, t, "progress")), a.length || (n.running = !1, this._notify(r, n, t, "complete"), n.initial = !1), i += a.length;
    }), this._lastDate = t, i === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const i = this._charts;
    let n = i.get(t);
    return n || (n = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(t, n)), n;
  }
  listen(t, i, n) {
    this._getAnims(t).listeners[i].push(n);
  }
  add(t, i) {
    !i || !i.length || this._getAnims(t).items.push(...i);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const i = this._charts.get(t);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((n, r) => Math.max(n, r._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const i = this._charts.get(t);
    return !(!i || !i.running || !i.items.length);
  }
  stop(t) {
    const i = this._charts.get(t);
    if (!i || !i.items.length)
      return;
    const n = i.items;
    let r = n.length - 1;
    for (; r >= 0; --r)
      n[r].cancel();
    i.items = [], this._notify(t, i, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
};
var cn = /* @__PURE__ */ new jM();
const mg = "transparent", qM = {
  boolean(e, t, i) {
    return i > 0.5 ? t : e;
  },
  color(e, t, i) {
    const n = sg(e || mg), r = n.valid && sg(t || mg);
    return r && r.valid ? r.mix(n, i).hexString() : t;
  },
  number(e, t, i) {
    return e + (t - e) * i;
  }
};
let ZM = class {
  constructor(t, i, n, r) {
    const a = i[n];
    r = sl([
      t.to,
      r,
      a,
      t.from
    ]);
    const s = sl([
      t.from,
      a,
      r
    ]);
    this._active = !0, this._fn = t.fn || qM[t.type || typeof s], this._easing = lo[t.easing] || lo.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = i, this._prop = n, this._from = s, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, i, n) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], a = n - this._start, s = this._duration - a;
      this._start = n, this._duration = Math.floor(Math.max(s, t.duration)), this._total += a, this._loop = !!t.loop, this._to = sl([
        t.to,
        i,
        r,
        t.from
      ]), this._from = sl([
        t.from,
        r,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const i = t - this._start, n = this._duration, r = this._prop, a = this._from, s = this._loop, o = this._to;
    let l;
    if (this._active = a !== o && (s || i < n), !this._active) {
      this._target[r] = o, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[r] = a;
      return;
    }
    l = i / n % 2, l = s && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(a, o, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((i, n) => {
      t.push({
        res: i,
        rej: n
      });
    });
  }
  _notify(t) {
    const i = t ? "res" : "rej", n = this._promises || [];
    for (let r = 0; r < n.length; r++)
      n[r][i]();
  }
};
class xb {
  constructor(t, i) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(t) {
    if (!vt(t))
      return;
    const i = Object.keys(ie.animation), n = this._properties;
    Object.getOwnPropertyNames(t).forEach((r) => {
      const a = t[r];
      if (!vt(a))
        return;
      const s = {};
      for (const o of i)
        s[o] = a[o];
      (ae(a.properties) && a.properties || [
        r
      ]).forEach((o) => {
        (o === r || !n.has(o)) && n.set(o, s);
      });
    });
  }
  _animateOptions(t, i) {
    const n = i.options, r = QM(t, n);
    if (!r)
      return [];
    const a = this._createAnimations(r, n);
    return n.$shared && KM(t.options.$animations, n).then(() => {
      t.options = n;
    }, () => {
    }), a;
  }
  _createAnimations(t, i) {
    const n = this._properties, r = [], a = t.$animations || (t.$animations = {}), s = Object.keys(i), o = Date.now();
    let l;
    for (l = s.length - 1; l >= 0; --l) {
      const u = s[l];
      if (u.charAt(0) === "$")
        continue;
      if (u === "options") {
        r.push(...this._animateOptions(t, i));
        continue;
      }
      const c = i[u];
      let h = a[u];
      const d = n.get(u);
      if (h)
        if (d && h.active()) {
          h.update(d, c, o);
          continue;
        } else
          h.cancel();
      if (!d || !d.duration) {
        t[u] = c;
        continue;
      }
      a[u] = h = new ZM(d, t, u, c), r.push(h);
    }
    return r;
  }
  update(t, i) {
    if (this._properties.size === 0) {
      Object.assign(t, i);
      return;
    }
    const n = this._createAnimations(t, i);
    if (n.length)
      return cn.add(this._chart, n), !0;
  }
}
function KM(e, t) {
  const i = [], n = Object.keys(t);
  for (let r = 0; r < n.length; r++) {
    const a = e[n[r]];
    a && a.active() && i.push(a.wait());
  }
  return Promise.all(i);
}
function QM(e, t) {
  if (!t)
    return;
  let i = e.options;
  if (!i) {
    e.options = t;
    return;
  }
  return i.$shared && (e.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function _g(e, t) {
  const i = e && e.options || {}, n = i.reverse, r = i.min === void 0 ? t : 0, a = i.max === void 0 ? t : 0;
  return {
    start: n ? a : r,
    end: n ? r : a
  };
}
function JM(e, t, i) {
  if (i === !1)
    return !1;
  const n = _g(e, i), r = _g(t, i);
  return {
    top: r.end,
    right: n.end,
    bottom: r.start,
    left: n.start
  };
}
function tk(e) {
  let t, i, n, r;
  return vt(e) ? (t = e.top, i = e.right, n = e.bottom, r = e.left) : t = i = n = r = e, {
    top: t,
    right: i,
    bottom: n,
    left: r,
    disabled: e === !1
  };
}
function wb(e, t) {
  const i = [], n = e._getSortedDatasetMetas(t);
  let r, a;
  for (r = 0, a = n.length; r < a; ++r)
    i.push(n[r].index);
  return i;
}
function yg(e, t, i, n = {}) {
  const r = e.keys, a = n.mode === "single";
  let s, o, l, u;
  if (t === null)
    return;
  let c = !1;
  for (s = 0, o = r.length; s < o; ++s) {
    if (l = +r[s], l === i) {
      if (c = !0, n.all)
        continue;
      break;
    }
    u = e.values[l], Ce(u) && (a || t === 0 || Xi(t) === Xi(u)) && (t += u);
  }
  return !c && !n.all ? 0 : t;
}
function ek(e, t) {
  const { iScale: i, vScale: n } = t, r = i.axis === "x" ? "x" : "y", a = n.axis === "x" ? "x" : "y", s = Object.keys(e), o = new Array(s.length);
  let l, u, c;
  for (l = 0, u = s.length; l < u; ++l)
    c = s[l], o[l] = {
      [r]: c,
      [a]: e[c]
    };
  return o;
}
function eh(e, t) {
  const i = e && e.options.stacked;
  return i || i === void 0 && t.stack !== void 0;
}
function ik(e, t, i) {
  return `${e.id}.${t.id}.${i.stack || i.type}`;
}
function nk(e) {
  const { min: t, max: i, minDefined: n, maxDefined: r } = e.getUserBounds();
  return {
    min: n ? t : Number.NEGATIVE_INFINITY,
    max: r ? i : Number.POSITIVE_INFINITY
  };
}
function rk(e, t, i) {
  const n = e[t] || (e[t] = {});
  return n[i] || (n[i] = {});
}
function bg(e, t, i, n) {
  for (const r of t.getMatchingVisibleMetas(n).reverse()) {
    const a = e[r.index];
    if (i && a > 0 || !i && a < 0)
      return r.index;
  }
  return null;
}
function xg(e, t) {
  const { chart: i, _cachedMeta: n } = e, r = i._stacks || (i._stacks = {}), { iScale: a, vScale: s, index: o } = n, l = a.axis, u = s.axis, c = ik(a, s, n), h = t.length;
  let d;
  for (let f = 0; f < h; ++f) {
    const v = t[f], { [l]: p, [u]: g } = v, m = v._stacks || (v._stacks = {});
    d = m[u] = rk(r, c, p), d[o] = g, d._top = bg(d, s, !0, n.type), d._bottom = bg(d, s, !1, n.type);
    const _ = d._visualValues || (d._visualValues = {});
    _[o] = g;
  }
}
function ih(e, t) {
  const i = e.scales;
  return Object.keys(i).filter((n) => i[n].axis === t).shift();
}
function ak(e, t) {
  return la(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function sk(e, t, i) {
  return la(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: t,
    mode: "default",
    type: "data"
  });
}
function ys(e, t) {
  const i = e.controller.index, n = e.vScale && e.vScale.axis;
  if (n) {
    t = t || e._parsed;
    for (const r of t) {
      const a = r._stacks;
      if (!a || a[n] === void 0 || a[n][i] === void 0)
        return;
      delete a[n][i], a[n]._visualValues !== void 0 && a[n]._visualValues[i] !== void 0 && delete a[n]._visualValues[i];
    }
  }
}
const nh = (e) => e === "reset" || e === "none", wg = (e, t) => t ? e : Object.assign({}, e), ok = (e, t, i) => e && !t.hidden && t._stacked && {
  keys: wb(i, !0),
  values: null
};
class mc {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, i) {
    this.chart = t, this._ctx = t.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = eh(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && ys(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, i = this._cachedMeta, n = this.getDataset(), r = (h, d, f, v) => h === "x" ? d : h === "r" ? v : f, a = i.xAxisID = ut(n.xAxisID, ih(t, "x")), s = i.yAxisID = ut(n.yAxisID, ih(t, "y")), o = i.rAxisID = ut(n.rAxisID, ih(t, "r")), l = i.indexAxis, u = i.iAxisID = r(l, a, s, o), c = i.vAxisID = r(l, s, a, o);
    i.xScale = this.getScaleForId(a), i.yScale = this.getScaleForId(s), i.rScale = this.getScaleForId(o), i.iScale = this.getScaleForId(u), i.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const i = this._cachedMeta;
    return t === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && ng(this._data, this), t._stacked && ys(t);
  }
  _dataCheck() {
    const t = this.getDataset(), i = t.data || (t.data = []), n = this._data;
    if (vt(i)) {
      const r = this._cachedMeta;
      this._data = ek(i, r);
    } else if (n !== i) {
      if (n) {
        ng(n, this);
        const r = this._cachedMeta;
        ys(r), r._parsed = [];
      }
      i && Object.isExtensible(i) && Y2(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const i = this._cachedMeta, n = this.getDataset();
    let r = !1;
    this._dataCheck();
    const a = i._stacked;
    i._stacked = eh(i.vScale, i), i.stack !== n.stack && (r = !0, ys(i), i.stack = n.stack), this._resyncElements(t), (r || a !== i._stacked) && (xg(this, i._parsed), i._stacked = eh(i.vScale, i));
  }
  configure() {
    const t = this.chart.config, i = t.datasetScopeKeys(this._type), n = t.getOptionScopes(this.getDataset(), i, !0);
    this.options = t.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, i) {
    const { _cachedMeta: n, _data: r } = this, { iScale: a, _stacked: s } = n, o = a.axis;
    let l = t === 0 && i === r.length ? !0 : n._sorted, u = t > 0 && n._parsed[t - 1], c, h, d;
    if (this._parsing === !1)
      n._parsed = r, n._sorted = !0, d = r;
    else {
      ae(r[t]) ? d = this.parseArrayData(n, r, t, i) : vt(r[t]) ? d = this.parseObjectData(n, r, t, i) : d = this.parsePrimitiveData(n, r, t, i);
      const f = () => h[o] === null || u && h[o] < u[o];
      for (c = 0; c < i; ++c)
        n._parsed[c + t] = h = d[c], l && (f() && (l = !1), u = h);
      n._sorted = l;
    }
    s && xg(this, d);
  }
  parsePrimitiveData(t, i, n, r) {
    const { iScale: a, vScale: s } = t, o = a.axis, l = s.axis, u = a.getLabels(), c = a === s, h = new Array(r);
    let d, f, v;
    for (d = 0, f = r; d < f; ++d)
      v = d + n, h[d] = {
        [o]: c || a.parse(u[v], v),
        [l]: s.parse(i[v], v)
      };
    return h;
  }
  parseArrayData(t, i, n, r) {
    const { xScale: a, yScale: s } = t, o = new Array(r);
    let l, u, c, h;
    for (l = 0, u = r; l < u; ++l)
      c = l + n, h = i[c], o[l] = {
        x: a.parse(h[0], c),
        y: s.parse(h[1], c)
      };
    return o;
  }
  parseObjectData(t, i, n, r) {
    const { xScale: a, yScale: s } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(r);
    let c, h, d, f;
    for (c = 0, h = r; c < h; ++c)
      d = c + n, f = i[d], u[c] = {
        x: a.parse(ra(f, o), d),
        y: s.parse(ra(f, l), d)
      };
    return u;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, i, n) {
    const r = this.chart, a = this._cachedMeta, s = i[t.axis], o = {
      keys: wb(r, !0),
      values: i._stacks[t.axis]._visualValues
    };
    return yg(o, s, a.index, {
      mode: n
    });
  }
  updateRangeFromParsed(t, i, n, r) {
    const a = n[i.axis];
    let s = a === null ? NaN : a;
    const o = r && n._stacks[i.axis];
    r && o && (r.values = o, s = yg(r, a, this._cachedMeta.index)), t.min = Math.min(t.min, s), t.max = Math.max(t.max, s);
  }
  getMinMax(t, i) {
    const n = this._cachedMeta, r = n._parsed, a = n._sorted && t === n.iScale, s = r.length, o = this._getOtherScale(t), l = ok(i, n, this.chart), u = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: h } = nk(o);
    let d, f;
    function v() {
      f = r[d];
      const p = f[o.axis];
      return !Ce(f[t.axis]) || c > p || h < p;
    }
    for (d = 0; d < s && !(!v() && (this.updateRangeFromParsed(u, t, f, l), a)); ++d)
      ;
    if (a) {
      for (d = s - 1; d >= 0; --d)
        if (!v()) {
          this.updateRangeFromParsed(u, t, f, l);
          break;
        }
    }
    return u;
  }
  getAllParsedValues(t) {
    const i = this._cachedMeta._parsed, n = [];
    let r, a, s;
    for (r = 0, a = i.length; r < a; ++r)
      s = i[r][t.axis], Ce(s) && n.push(s);
    return n;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = i.iScale, r = i.vScale, a = this.getParsed(t);
    return {
      label: n ? "" + n.getLabelForValue(a[n.axis]) : "",
      value: r ? "" + r.getLabelForValue(a[r.axis]) : ""
    };
  }
  _update(t) {
    const i = this._cachedMeta;
    this.update(t || "default"), i._clip = tk(ut(this.options.clip, JM(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, i = this.chart, n = this._cachedMeta, r = n.data || [], a = i.chartArea, s = [], o = this._drawStart || 0, l = this._drawCount || r.length - o, u = this.options.drawActiveElementsOnTop;
    let c;
    for (n.dataset && n.dataset.draw(t, a, o, l), c = o; c < o + l; ++c) {
      const h = r[c];
      h.hidden || (h.active && u ? s.push(h) : h.draw(t, a));
    }
    for (c = 0; c < s.length; ++c)
      s[c].draw(t, a);
  }
  getStyle(t, i) {
    const n = i ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(t || 0, n);
  }
  getContext(t, i, n) {
    const r = this.getDataset();
    let a;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const s = this._cachedMeta.data[t];
      a = s.$context || (s.$context = sk(this.getContext(), t, s)), a.parsed = this.getParsed(t), a.raw = r.data[t], a.index = a.dataIndex = t;
    } else
      a = this.$context || (this.$context = ak(this.chart.getContext(), this.index)), a.dataset = r, a.index = a.datasetIndex = this.index;
    return a.active = !!i, a.mode = n, a;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, t);
  }
  _resolveElementOptions(t, i = "default", n) {
    const r = i === "active", a = this._cachedDataOpts, s = t + "-" + i, o = a[s], l = this.enableOptionSharing && So(n);
    if (o)
      return wg(o, l);
    const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, t), h = r ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], d = u.getOptionScopes(this.getDataset(), c), f = Object.keys(ie.elements[t]), v = () => this.getContext(n, r, i), p = u.resolveNamedOptions(d, f, v, h);
    return p.$shared && (p.$shared = l, a[s] = Object.freeze(wg(p, l))), p;
  }
  _resolveAnimations(t, i, n) {
    const r = this.chart, a = this._cachedDataOpts, s = `animation-${i}`, o = a[s];
    if (o)
      return o;
    let l;
    if (r.options.animation !== !1) {
      const c = this.chart.config, h = c.datasetAnimationScopeKeys(this._type, i), d = c.getOptionScopes(this.getDataset(), h);
      l = c.createResolver(d, this.getContext(t, n, i));
    }
    const u = new xb(r, l && l.animations);
    return l && l._cacheable && (a[s] = Object.freeze(u)), u;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, i) {
    return !i || nh(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, i) {
    const n = this.resolveDataElementOptions(t, i), r = this._sharedOptions, a = this.getSharedOptions(n), s = this.includeOptions(i, a) || a !== r;
    return this.updateSharedOptions(a, i, n), {
      sharedOptions: a,
      includeOptions: s
    };
  }
  updateElement(t, i, n, r) {
    nh(r) ? Object.assign(t, n) : this._resolveAnimations(i, r).update(t, n);
  }
  updateSharedOptions(t, i, n) {
    t && !nh(i) && this._resolveAnimations(void 0, i).update(t, n);
  }
  _setStyle(t, i, n, r) {
    t.active = r;
    const a = this.getStyle(i, r);
    this._resolveAnimations(i, n, r).update(t, {
      options: !r && this.getSharedOptions(a) || a
    });
  }
  removeHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !1);
  }
  setHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const i = this._data, n = this._cachedMeta.data;
    for (const [o, l, u] of this._syncList)
      this[o](l, u);
    this._syncList = [];
    const r = n.length, a = i.length, s = Math.min(a, r);
    s && this.parse(0, s), a > r ? this._insertElements(r, a - r, t) : a < r && this._removeElements(a, r - a);
  }
  _insertElements(t, i, n = !0) {
    const r = this._cachedMeta, a = r.data, s = t + i;
    let o;
    const l = (u) => {
      for (u.length += i, o = u.length - 1; o >= s; o--)
        u[o] = u[o - i];
    };
    for (l(a), o = t; o < s; ++o)
      a[o] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(t, i), n && this.updateElements(a, t, i, "reset");
  }
  updateElements(t, i, n, r) {
  }
  _removeElements(t, i) {
    const n = this._cachedMeta;
    if (this._parsing) {
      const r = n._parsed.splice(t, i);
      n._stacked && ys(n, r);
    }
    n.data.splice(t, i);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [i, n, r] = t;
      this[i](n, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, i) {
    i && this._sync([
      "_removeElements",
      t,
      i
    ]);
    const n = arguments.length - 2;
    n && this._sync([
      "_insertElements",
      t,
      n
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function lk(e, t) {
  if (!e._cache.$bar) {
    const i = e.getMatchingVisibleMetas(t);
    let n = [];
    for (let r = 0, a = i.length; r < a; r++)
      n = n.concat(i[r].controller.getAllParsedValues(e));
    e._cache.$bar = rb(n.sort((r, a) => r - a));
  }
  return e._cache.$bar;
}
function uk(e) {
  const t = e.iScale, i = lk(t, e.type);
  let n = t._length, r, a, s, o;
  const l = () => {
    s === 32767 || s === -32768 || (So(o) && (n = Math.min(n, Math.abs(s - o) || n)), o = s);
  };
  for (r = 0, a = i.length; r < a; ++r)
    s = t.getPixelForValue(i[r]), l();
  for (o = void 0, r = 0, a = t.ticks.length; r < a; ++r)
    s = t.getPixelForTick(r), l();
  return n;
}
function ck(e, t, i, n) {
  const r = i.barThickness;
  let a, s;
  return kt(r) ? (a = t.min * i.categoryPercentage, s = i.barPercentage) : (a = r * n, s = 1), {
    chunk: a / n,
    ratio: s,
    start: t.pixels[e] - a / 2
  };
}
function hk(e, t, i, n) {
  const r = t.pixels, a = r[e];
  let s = e > 0 ? r[e - 1] : null, o = e < r.length - 1 ? r[e + 1] : null;
  const l = i.categoryPercentage;
  s === null && (s = a - (o === null ? t.end - t.start : o - a)), o === null && (o = a + a - s);
  const u = a - (a - Math.min(s, o)) / 2 * l;
  return {
    chunk: Math.abs(o - s) / 2 * l / n,
    ratio: i.barPercentage,
    start: u
  };
}
function dk(e, t, i, n) {
  const r = i.parse(e[0], n), a = i.parse(e[1], n), s = Math.min(r, a), o = Math.max(r, a);
  let l = s, u = o;
  Math.abs(s) > Math.abs(o) && (l = o, u = s), t[i.axis] = u, t._custom = {
    barStart: l,
    barEnd: u,
    start: r,
    end: a,
    min: s,
    max: o
  };
}
function Sb(e, t, i, n) {
  return ae(e) ? dk(e, t, i, n) : t[i.axis] = i.parse(e, n), t;
}
function Sg(e, t, i, n) {
  const r = e.iScale, a = e.vScale, s = r.getLabels(), o = r === a, l = [];
  let u, c, h, d;
  for (u = i, c = i + n; u < c; ++u)
    d = t[u], h = {}, h[r.axis] = o || r.parse(s[u], u), l.push(Sb(d, h, a, u));
  return l;
}
function rh(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function fk(e, t, i) {
  return e !== 0 ? Xi(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= i ? 1 : -1);
}
function vk(e) {
  let t, i, n, r, a;
  return e.horizontal ? (t = e.base > e.x, i = "left", n = "right") : (t = e.base < e.y, i = "bottom", n = "top"), t ? (r = "end", a = "start") : (r = "start", a = "end"), {
    start: i,
    end: n,
    reverse: t,
    top: r,
    bottom: a
  };
}
function pk(e, t, i, n) {
  let r = t.borderSkipped;
  const a = {};
  if (!r) {
    e.borderSkipped = a;
    return;
  }
  if (r === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: s, end: o, reverse: l, top: u, bottom: c } = vk(e);
  r === "middle" && i && (e.enableBorderRadius = !0, (i._top || 0) === n ? r = u : (i._bottom || 0) === n ? r = c : (a[Mg(c, s, o, l)] = !0, r = u)), a[Mg(r, s, o, l)] = !0, e.borderSkipped = a;
}
function Mg(e, t, i, n) {
  return n ? (e = gk(e, t, i), e = kg(e, i, t)) : e = kg(e, t, i), e;
}
function gk(e, t, i) {
  return e === t ? i : e === i ? t : e;
}
function kg(e, t, i) {
  return e === "start" ? t : e === "end" ? i : e;
}
function mk(e, { inflateAmount: t }, i) {
  e.inflateAmount = t === "auto" ? i === 1 ? 0.33 : 0 : t;
}
class _k extends mc {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, i, n, r) {
    return Sg(t, i, n, r);
  }
  parseArrayData(t, i, n, r) {
    return Sg(t, i, n, r);
  }
  parseObjectData(t, i, n, r) {
    const { iScale: a, vScale: s } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, u = a.axis === "x" ? o : l, c = s.axis === "x" ? o : l, h = [];
    let d, f, v, p;
    for (d = n, f = n + r; d < f; ++d)
      p = i[d], v = {}, v[a.axis] = a.parse(ra(p, u), d), h.push(Sb(ra(p, c), v, s, d));
    return h;
  }
  updateRangeFromParsed(t, i, n, r) {
    super.updateRangeFromParsed(t, i, n, r);
    const a = n._custom;
    a && i === this._cachedMeta.vScale && (t.min = Math.min(t.min, a.min), t.max = Math.max(t.max, a.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, { iScale: n, vScale: r } = i, a = this.getParsed(t), s = a._custom, o = rh(s) ? "[" + s.start + ", " + s.end + "]" : "" + r.getLabelForValue(a[r.axis]);
    return {
      label: "" + n.getLabelForValue(a[n.axis]),
      value: o
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const i = this._cachedMeta;
    this.updateElements(i.data, 0, i.data.length, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { index: s, _cachedMeta: { vScale: o } } = this, l = o.getBasePixel(), u = o.isHorizontal(), c = this._getRuler(), { sharedOptions: h, includeOptions: d } = this._getSharedOptions(i, r);
    for (let f = i; f < i + n; f++) {
      const v = this.getParsed(f), p = a || kt(v[o.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(f), g = this._calculateBarIndexPixels(f, c), m = (v._stacks || {})[o.axis], _ = {
        horizontal: u,
        base: p.base,
        enableBorderRadius: !m || rh(v._custom) || s === m._top || s === m._bottom,
        x: u ? p.head : g.center,
        y: u ? g.center : p.head,
        height: u ? g.size : Math.abs(p.size),
        width: u ? Math.abs(p.size) : g.size
      };
      d && (_.options = h || this.resolveDataElementOptions(f, t[f].active ? "active" : r));
      const y = _.options || t[f].options;
      pk(_, y, m, s), mk(_, y, c.ratio), this.updateElement(t[f], f, _, r);
    }
  }
  _getStacks(t, i) {
    const { iScale: n } = this._cachedMeta, r = n.getMatchingVisibleMetas(this._type).filter((c) => c.controller.options.grouped), a = n.options.stacked, s = [], o = this._cachedMeta.controller.getParsed(i), l = o && o[n.axis], u = (c) => {
      const h = c._parsed.find((f) => f[n.axis] === l), d = h && h[c.vScale.axis];
      if (kt(d) || isNaN(d))
        return !0;
    };
    for (const c of r)
      if (!(i !== void 0 && u(c)) && ((a === !1 || s.indexOf(c.stack) === -1 || a === void 0 && c.stack === void 0) && s.push(c.stack), c.index === t))
        break;
    return s.length || s.push(void 0), s;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, i = this.chart.options.indexAxis;
    return Object.keys(t).filter((n) => t[n].axis === i).shift();
  }
  _getAxis() {
    const t = {}, i = this.getFirstScaleIdForIndexAxis();
    for (const n of this.chart.data.datasets)
      t[ut(this.chart.options.indexAxis === "x" ? n.xAxisID : n.yAxisID, i)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, i, n) {
    const r = this._getStacks(t, n), a = i !== void 0 ? r.indexOf(i) : -1;
    return a === -1 ? r.length - 1 : a;
  }
  _getRuler() {
    const t = this.options, i = this._cachedMeta, n = i.iScale, r = [];
    let a, s;
    for (a = 0, s = i.data.length; a < s; ++a)
      r.push(n.getPixelForValue(this.getParsed(a)[n.axis], a));
    const o = t.barThickness;
    return {
      min: o || uk(i),
      pixels: r,
      start: n._startPixel,
      end: n._endPixel,
      stackCount: this._getStackCount(),
      scale: n,
      grouped: t.grouped,
      ratio: o ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: i, _stacked: n, index: r }, options: { base: a, minBarLength: s } } = this, o = a || 0, l = this.getParsed(t), u = l._custom, c = rh(u);
    let h = l[i.axis], d = 0, f = n ? this.applyStack(i, l, n) : h, v, p;
    f !== h && (d = f - h, f = h), c && (h = u.barStart, f = u.barEnd - u.barStart, h !== 0 && Xi(h) !== Xi(u.barEnd) && (d = 0), d += h);
    const g = !kt(a) && !c ? a : d;
    let m = i.getPixelForValue(g);
    if (this.chart.getDataVisibility(t) ? v = i.getPixelForValue(d + f) : v = m, p = v - m, Math.abs(p) < s) {
      p = fk(p, i, o) * s, h === o && (m -= p / 2);
      const _ = i.getPixelForDecimal(0), y = i.getPixelForDecimal(1), b = Math.min(_, y), w = Math.max(_, y);
      m = Math.max(Math.min(m, w), b), v = m + p, n && !c && (l._stacks[i.axis]._visualValues[r] = i.getValueForPixel(v) - i.getValueForPixel(m));
    }
    if (m === i.getPixelForValue(o)) {
      const _ = Xi(p) * i.getLineWidthForValue(o) / 2;
      m += _, p -= _;
    }
    return {
      size: p,
      base: m,
      head: v,
      center: v + p / 2
    };
  }
  _calculateBarIndexPixels(t, i) {
    const n = i.scale, r = this.options, a = r.skipNull, s = ut(r.maxBarThickness, 1 / 0);
    let o, l;
    const u = this._getAxisCount();
    if (i.grouped) {
      const c = a ? this._getStackCount(t) : i.stackCount, h = r.barThickness === "flex" ? hk(t, i, r, c * u) : ck(t, i, r, c * u), d = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, f = this._getAxis().indexOf(ut(d, this.getFirstScaleIdForIndexAxis())), v = this._getStackIndex(this.index, this._cachedMeta.stack, a ? t : void 0) + f;
      o = h.start + h.chunk * v + h.chunk / 2, l = Math.min(s, h.chunk * h.ratio);
    } else
      o = n.getPixelForValue(this.getParsed(t)[n.axis], t), l = Math.min(s, i.min * i.ratio);
    return {
      base: o - l / 2,
      head: o + l / 2,
      center: o,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, i = t.vScale, n = t.data, r = n.length;
    let a = 0;
    for (; a < r; ++a)
      this.getParsed(a)[i.axis] !== null && !n[a].hidden && n[a].draw(this._ctx);
  }
}
function yk(e, t, i) {
  let n = 1, r = 1, a = 0, s = 0;
  if (t < Xt) {
    const o = e, l = o + t, u = Math.cos(o), c = Math.sin(o), h = Math.cos(l), d = Math.sin(l), f = (y, b, w) => ko(y, o, l, !0) ? 1 : Math.max(b, b * i, w, w * i), v = (y, b, w) => ko(y, o, l, !0) ? -1 : Math.min(b, b * i, w, w * i), p = f(0, u, h), g = f(ce, c, d), m = v(At, u, h), _ = v(At + ce, c, d);
    n = (p - m) / 2, r = (g - _) / 2, a = -(p + m) / 2, s = -(g + _) / 2;
  }
  return {
    ratioX: n,
    ratioY: r,
    offsetX: a,
    offsetY: s
  };
}
class bk extends mc {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const i = t.data, { labels: { pointStyle: n, textAlign: r, color: a, useBorderRadius: s, borderRadius: o } } = t.legend.options;
            return i.labels.length && i.datasets.length ? i.labels.map((l, u) => {
              const h = t.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: l,
                fillStyle: h.backgroundColor,
                fontColor: a,
                hidden: !t.getDataVisibility(u),
                lineDash: h.borderDash,
                lineDashOffset: h.borderDashOffset,
                lineJoin: h.borderJoinStyle,
                lineWidth: h.borderWidth,
                strokeStyle: h.borderColor,
                textAlign: r,
                pointStyle: n,
                borderRadius: s && (o || h.borderRadius),
                index: u
              };
            }) : [];
          }
        },
        onClick(t, i, n) {
          n.chart.toggleDataVisibility(i.index), n.chart.update();
        }
      }
    }
  };
  constructor(t, i) {
    super(t, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, i) {
    const n = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = n;
    else {
      let a = (l) => +n[l];
      if (vt(n[t])) {
        const { key: l = "value" } = this._parsing;
        a = (u) => +ra(n[u], l);
      }
      let s, o;
      for (s = t, o = t + i; s < o; ++s)
        r._parsed[s] = a(s);
    }
  }
  _getRotation() {
    return pn(this.options.rotation - 90);
  }
  _getCircumference() {
    return pn(this.options.circumference);
  }
  _getRotationExtents() {
    let t = Xt, i = -Xt;
    for (let n = 0; n < this.chart.data.datasets.length; ++n)
      if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
        const r = this.chart.getDatasetMeta(n).controller, a = r._getRotation(), s = r._getCircumference();
        t = Math.min(t, a), i = Math.max(i, a + s);
      }
    return {
      rotation: t,
      circumference: i - t
    };
  }
  update(t) {
    const i = this.chart, { chartArea: n } = i, r = this._cachedMeta, a = r.data, s = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing, o = Math.max((Math.min(n.width, n.height) - s) / 2, 0), l = Math.min(D2(this.options.cutout, o), 1), u = this._getRingWeight(this.index), { circumference: c, rotation: h } = this._getRotationExtents(), { ratioX: d, ratioY: f, offsetX: v, offsetY: p } = yk(h, c, l), g = (n.width - s) / d, m = (n.height - s) / f, _ = Math.max(Math.min(g, m) / 2, 0), y = Jy(this.options.radius, _), b = Math.max(y * l, 0), w = (y - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = v * y, this.offsetY = p * y, r.total = this.calculateTotal(), this.outerRadius = y - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * u, 0), this.updateElements(a, 0, a.length, t);
  }
  _circumference(t, i) {
    const n = this.options, r = this._cachedMeta, a = this._getCircumference();
    return i && n.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * a / Xt);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", s = this.chart, o = s.chartArea, u = s.options.animation, c = (o.left + o.right) / 2, h = (o.top + o.bottom) / 2, d = a && u.animateScale, f = d ? 0 : this.innerRadius, v = d ? 0 : this.outerRadius, { sharedOptions: p, includeOptions: g } = this._getSharedOptions(i, r);
    let m = this._getRotation(), _;
    for (_ = 0; _ < i; ++_)
      m += this._circumference(_, a);
    for (_ = i; _ < i + n; ++_) {
      const y = this._circumference(_, a), b = t[_], w = {
        x: c + this.offsetX,
        y: h + this.offsetY,
        startAngle: m,
        endAngle: m + y,
        circumference: y,
        outerRadius: v,
        innerRadius: f
      };
      g && (w.options = p || this.resolveDataElementOptions(_, b.active ? "active" : r)), m += y, this.updateElement(b, _, w, r);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, i = t.data;
    let n = 0, r;
    for (r = 0; r < i.length; r++) {
      const a = t._parsed[r];
      a !== null && !isNaN(a) && this.chart.getDataVisibility(r) && !i[r].hidden && (n += Math.abs(a));
    }
    return n;
  }
  calculateCircumference(t) {
    const i = this._cachedMeta.total;
    return i > 0 && !isNaN(t) ? Xt * (Math.abs(t) / i) : 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = this.chart, r = n.data.labels || [], a = sv(i._parsed[t], n.options.locale);
    return {
      label: r[t] || "",
      value: a
    };
  }
  getMaxBorderWidth(t) {
    let i = 0;
    const n = this.chart;
    let r, a, s, o, l;
    if (!t) {
      for (r = 0, a = n.data.datasets.length; r < a; ++r)
        if (n.isDatasetVisible(r)) {
          s = n.getDatasetMeta(r), t = s.data, o = s.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (r = 0, a = t.length; r < a; ++r)
      l = o.resolveDataElementOptions(r), l.borderAlign !== "inner" && (i = Math.max(i, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return i;
  }
  getMaxOffset(t) {
    let i = 0;
    for (let n = 0, r = t.length; n < r; ++n) {
      const a = this.resolveDataElementOptions(n);
      i = Math.max(i, a.offset || 0, a.hoverOffset || 0);
    }
    return i;
  }
  _getRingWeightOffset(t) {
    let i = 0;
    for (let n = 0; n < t; ++n)
      this.chart.isDatasetVisible(n) && (i += this._getRingWeight(n));
    return i;
  }
  _getRingWeight(t) {
    return Math.max(ut(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class xk extends mc {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const i = this._cachedMeta, { dataset: n, data: r = [], _dataset: a } = i, s = this.chart._animationsDisabled;
    let { start: o, count: l } = G2(i, r, s);
    this._drawStart = o, this._drawCount = l, X2(i) && (o = 0, l = r.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!a._decimated, n.points = r;
    const u = this.resolveDatasetElementOptions(t);
    this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(n, void 0, {
      animated: !s,
      options: u
    }, t), this.updateElements(r, o, l, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { iScale: s, vScale: o, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: h } = this._getSharedOptions(i, r), d = s.axis, f = o.axis, { spanGaps: v, segment: p } = this.options, g = Mo(v) ? v : Number.POSITIVE_INFINITY, m = this.chart._animationsDisabled || a || r === "none", _ = i + n, y = t.length;
    let b = i > 0 && this.getParsed(i - 1);
    for (let w = 0; w < y; ++w) {
      const S = t[w], M = m ? S : {};
      if (w < i || w >= _) {
        M.skip = !0;
        continue;
      }
      const k = this.getParsed(w), T = kt(k[f]), C = M[d] = s.getPixelForValue(k[d], w), D = M[f] = a || T ? o.getBasePixel() : o.getPixelForValue(l ? this.applyStack(o, k, l) : k[f], w);
      M.skip = isNaN(C) || isNaN(D) || T, M.stop = w > 0 && Math.abs(k[d] - b[d]) > g, p && (M.parsed = k, M.raw = u.data[w]), h && (M.options = c || this.resolveDataElementOptions(w, S.active ? "active" : r)), m || this.updateElement(S, w, M, r), b = k;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, i = t.dataset, n = i.options && i.options.borderWidth || 0, r = t.data || [];
    if (!r.length)
      return n;
    const a = r[0].size(this.resolveDataElementOptions(0)), s = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(n, a, s) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
class wk extends bk {
  static id = "pie";
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
}
function ur() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class fv {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(fv.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return ur();
  }
  parse() {
    return ur();
  }
  format() {
    return ur();
  }
  add() {
    return ur();
  }
  diff() {
    return ur();
  }
  startOf() {
    return ur();
  }
  endOf() {
    return ur();
  }
}
var Sk = {
  _date: fv
};
function Mk(e, t, i, n) {
  const { controller: r, data: a, _sorted: s } = e, o = r._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (o && t === o.axis && t !== "r" && s && a.length) {
    const u = o._reversePixels ? V2 : zr;
    if (n) {
      if (r._sharedOptions) {
        const c = a[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const d = u(a, t, i - h), f = u(a, t, i + h);
          return {
            lo: d.lo,
            hi: f.hi
          };
        }
      }
    } else {
      const c = u(a, t, i);
      if (l) {
        const { vScale: h } = r._cachedMeta, { _parsed: d } = e, f = d.slice(0, c.lo + 1).reverse().findIndex((p) => !kt(p[h.axis]));
        c.lo -= Math.max(0, f);
        const v = d.slice(c.hi).findIndex((p) => !kt(p[h.axis]));
        c.hi += Math.max(0, v);
      }
      return c;
    }
  }
  return {
    lo: 0,
    hi: a.length - 1
  };
}
function _c(e, t, i, n, r) {
  const a = e.getSortedVisibleDatasetMetas(), s = i[t];
  for (let o = 0, l = a.length; o < l; ++o) {
    const { index: u, data: c } = a[o], { lo: h, hi: d } = Mk(a[o], t, s, r);
    for (let f = h; f <= d; ++f) {
      const v = c[f];
      v.skip || n(v, u, f);
    }
  }
}
function kk(e) {
  const t = e.indexOf("x") !== -1, i = e.indexOf("y") !== -1;
  return function(n, r) {
    const a = t ? Math.abs(n.x - r.x) : 0, s = i ? Math.abs(n.y - r.y) : 0;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(s, 2));
  };
}
function ah(e, t, i, n, r) {
  const a = [];
  return !r && !e.isPointInArea(t) || _c(e, i, t, function(o, l, u) {
    !r && !Do(o, e.chartArea, 0) || o.inRange(t.x, t.y, n) && a.push({
      element: o,
      datasetIndex: l,
      index: u
    });
  }, !0), a;
}
function Dk(e, t, i, n) {
  let r = [];
  function a(s, o, l) {
    const { startAngle: u, endAngle: c } = s.getProps([
      "startAngle",
      "endAngle"
    ], n), { angle: h } = ib(s, {
      x: t.x,
      y: t.y
    });
    ko(h, u, c) && r.push({
      element: s,
      datasetIndex: o,
      index: l
    });
  }
  return _c(e, i, t, a), r;
}
function Tk(e, t, i, n, r, a) {
  let s = [];
  const o = kk(i);
  let l = Number.POSITIVE_INFINITY;
  function u(c, h, d) {
    const f = c.inRange(t.x, t.y, r);
    if (n && !f)
      return;
    const v = c.getCenterPoint(r);
    if (!(!!a || e.isPointInArea(v)) && !f)
      return;
    const g = o(t, v);
    g < l ? (s = [
      {
        element: c,
        datasetIndex: h,
        index: d
      }
    ], l = g) : g === l && s.push({
      element: c,
      datasetIndex: h,
      index: d
    });
  }
  return _c(e, i, t, u), s;
}
function sh(e, t, i, n, r, a) {
  return !a && !e.isPointInArea(t) ? [] : i === "r" && !n ? Dk(e, t, i, r) : Tk(e, t, i, n, r, a);
}
function Dg(e, t, i, n, r) {
  const a = [], s = i === "x" ? "inXRange" : "inYRange";
  let o = !1;
  return _c(e, i, t, (l, u, c) => {
    l[s] && l[s](t[i], r) && (a.push({
      element: l,
      datasetIndex: u,
      index: c
    }), o = o || l.inRange(t.x, t.y, r));
  }), n && !o ? [] : a;
}
var Ck = {
  modes: {
    index(e, t, i, n) {
      const r = Rr(t, e), a = i.axis || "x", s = i.includeInvisible || !1, o = i.intersect ? ah(e, r, a, n, s) : sh(e, r, a, !1, n, s), l = [];
      return o.length ? (e.getSortedVisibleDatasetMetas().forEach((u) => {
        const c = o[0].index, h = u.data[c];
        h && !h.skip && l.push({
          element: h,
          datasetIndex: u.index,
          index: c
        });
      }), l) : [];
    },
    dataset(e, t, i, n) {
      const r = Rr(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      let o = i.intersect ? ah(e, r, a, n, s) : sh(e, r, a, !1, n, s);
      if (o.length > 0) {
        const l = o[0].datasetIndex, u = e.getDatasetMeta(l).data;
        o = [];
        for (let c = 0; c < u.length; ++c)
          o.push({
            element: u[c],
            datasetIndex: l,
            index: c
          });
      }
      return o;
    },
    point(e, t, i, n) {
      const r = Rr(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      return ah(e, r, a, n, s);
    },
    nearest(e, t, i, n) {
      const r = Rr(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      return sh(e, r, a, i.intersect, n, s);
    },
    x(e, t, i, n) {
      const r = Rr(t, e);
      return Dg(e, r, "x", i.intersect, n);
    },
    y(e, t, i, n) {
      const r = Rr(t, e);
      return Dg(e, r, "y", i.intersect, n);
    }
  }
};
const Mb = [
  "left",
  "top",
  "right",
  "bottom"
];
function bs(e, t) {
  return e.filter((i) => i.pos === t);
}
function Tg(e, t) {
  return e.filter((i) => Mb.indexOf(i.pos) === -1 && i.box.axis === t);
}
function xs(e, t) {
  return e.sort((i, n) => {
    const r = t ? n : i, a = t ? i : n;
    return r.weight === a.weight ? r.index - a.index : r.weight - a.weight;
  });
}
function Ak(e) {
  const t = [];
  let i, n, r, a, s, o;
  for (i = 0, n = (e || []).length; i < n; ++i)
    r = e[i], { position: a, options: { stack: s, stackWeight: o = 1 } } = r, t.push({
      index: i,
      box: r,
      pos: a,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: s && a + s,
      stackWeight: o
    });
  return t;
}
function Pk(e) {
  const t = {};
  for (const i of e) {
    const { stack: n, pos: r, stackWeight: a } = i;
    if (!n || !Mb.includes(r))
      continue;
    const s = t[n] || (t[n] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    s.count++, s.weight += a;
  }
  return t;
}
function Ek(e, t) {
  const i = Pk(e), { vBoxMaxWidth: n, hBoxMaxHeight: r } = t;
  let a, s, o;
  for (a = 0, s = e.length; a < s; ++a) {
    o = e[a];
    const { fullSize: l } = o.box, u = i[o.stack], c = u && o.stackWeight / u.weight;
    o.horizontal ? (o.width = c ? c * n : l && t.availableWidth, o.height = r) : (o.width = n, o.height = c ? c * r : l && t.availableHeight);
  }
  return i;
}
function Lk(e) {
  const t = Ak(e), i = xs(t.filter((u) => u.box.fullSize), !0), n = xs(bs(t, "left"), !0), r = xs(bs(t, "right")), a = xs(bs(t, "top"), !0), s = xs(bs(t, "bottom")), o = Tg(t, "x"), l = Tg(t, "y");
  return {
    fullSize: i,
    leftAndTop: n.concat(a),
    rightAndBottom: r.concat(l).concat(s).concat(o),
    chartArea: bs(t, "chartArea"),
    vertical: n.concat(r).concat(l),
    horizontal: a.concat(s).concat(o)
  };
}
function Cg(e, t, i, n) {
  return Math.max(e[i], t[i]) + Math.max(e[n], t[n]);
}
function kb(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function Ok(e, t, i, n) {
  const { pos: r, box: a } = i, s = e.maxPadding;
  if (!vt(r)) {
    i.size && (e[r] -= i.size);
    const h = n[i.stack] || {
      size: 0,
      count: 1
    };
    h.size = Math.max(h.size, i.horizontal ? a.height : a.width), i.size = h.size / h.count, e[r] += i.size;
  }
  a.getPadding && kb(s, a.getPadding());
  const o = Math.max(0, t.outerWidth - Cg(s, e, "left", "right")), l = Math.max(0, t.outerHeight - Cg(s, e, "top", "bottom")), u = o !== e.w, c = l !== e.h;
  return e.w = o, e.h = l, i.horizontal ? {
    same: u,
    other: c
  } : {
    same: c,
    other: u
  };
}
function Ik(e) {
  const t = e.maxPadding;
  function i(n) {
    const r = Math.max(t[n] - e[n], 0);
    return e[n] += r, r;
  }
  e.y += i("top"), e.x += i("left"), i("right"), i("bottom");
}
function Rk(e, t) {
  const i = t.maxPadding;
  function n(r) {
    const a = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((s) => {
      a[s] = Math.max(t[s], i[s]);
    }), a;
  }
  return n(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function qs(e, t, i, n) {
  const r = [];
  let a, s, o, l, u, c;
  for (a = 0, s = e.length, u = 0; a < s; ++a) {
    o = e[a], l = o.box, l.update(o.width || t.w, o.height || t.h, Rk(o.horizontal, t));
    const { same: h, other: d } = Ok(t, i, o, n);
    u |= h && r.length, c = c || d, l.fullSize || r.push(o);
  }
  return u && qs(r, t, i, n) || c;
}
function ul(e, t, i, n, r) {
  e.top = i, e.left = t, e.right = t + n, e.bottom = i + r, e.width = n, e.height = r;
}
function Ag(e, t, i, n) {
  const r = i.padding;
  let { x: a, y: s } = t;
  for (const o of e) {
    const l = o.box, u = n[o.stack] || {
      placed: 0,
      weight: 1
    }, c = o.stackWeight / u.weight || 1;
    if (o.horizontal) {
      const h = t.w * c, d = u.size || l.height;
      So(u.start) && (s = u.start), l.fullSize ? ul(l, r.left, s, i.outerWidth - r.right - r.left, d) : ul(l, t.left + u.placed, s, h, d), u.start = s, u.placed += h, s = l.bottom;
    } else {
      const h = t.h * c, d = u.size || l.width;
      So(u.start) && (a = u.start), l.fullSize ? ul(l, a, r.top, d, i.outerHeight - r.bottom - r.top) : ul(l, a, t.top + u.placed, d, h), u.start = a, u.placed += h, a = l.right;
    }
  }
  t.x = a, t.y = s;
}
var fi = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            t.draw(i);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const i = e.boxes ? e.boxes.indexOf(t) : -1;
    i !== -1 && e.boxes.splice(i, 1);
  },
  configure(e, t, i) {
    t.fullSize = i.fullSize, t.position = i.position, t.weight = i.weight;
  },
  update(e, t, i, n) {
    if (!e)
      return;
    const r = gi(e.options.layout.padding), a = Math.max(t - r.width, 0), s = Math.max(i - r.height, 0), o = Lk(e.boxes), l = o.vertical, u = o.horizontal;
    Ct(e.boxes, (p) => {
      typeof p.beforeLayout == "function" && p.beforeLayout();
    });
    const c = l.reduce((p, g) => g.box.options && g.box.options.display === !1 ? p : p + 1, 0) || 1, h = Object.freeze({
      outerWidth: t,
      outerHeight: i,
      padding: r,
      availableWidth: a,
      availableHeight: s,
      vBoxMaxWidth: a / 2 / c,
      hBoxMaxHeight: s / 2
    }), d = Object.assign({}, r);
    kb(d, gi(n));
    const f = Object.assign({
      maxPadding: d,
      w: a,
      h: s,
      x: r.left,
      y: r.top
    }, r), v = Ek(l.concat(u), h);
    qs(o.fullSize, f, h, v), qs(l, f, h, v), qs(u, f, h, v) && qs(l, f, h, v), Ik(f), Ag(o.leftAndTop, f, h, v), f.x += f.w, f.y += f.h, Ag(o.rightAndBottom, f, h, v), e.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, Ct(o.chartArea, (p) => {
      const g = p.box;
      Object.assign(g, e.chartArea), g.update(f.w, f.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Db {
  acquireContext(t, i) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, i, n) {
  }
  removeEventListener(t, i, n) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, i, n, r) {
    return i = Math.max(0, i || t.width), n = n || t.height, {
      width: i,
      height: Math.max(0, r ? Math.floor(i / r) : n)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class Nk extends Db {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const tu = "$chartjs", Fk = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Pg = (e) => e === null || e === "";
function Bk(e, t) {
  const i = e.style, n = e.getAttribute("height"), r = e.getAttribute("width");
  if (e[tu] = {
    initial: {
      height: n,
      width: r,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", Pg(r)) {
    const a = fg(e, "width");
    a !== void 0 && (e.width = a);
  }
  if (Pg(n))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const a = fg(e, "height");
      a !== void 0 && (e.height = a);
    }
  return e;
}
const Tb = NM ? {
  passive: !0
} : !1;
function $k(e, t, i) {
  e && e.addEventListener(t, i, Tb);
}
function zk(e, t, i) {
  e && e.canvas && e.canvas.removeEventListener(t, i, Tb);
}
function Vk(e, t) {
  const i = Fk[e.type] || e.type, { x: n, y: r } = Rr(e, t);
  return {
    type: i,
    chart: t,
    native: e,
    x: n !== void 0 ? n : null,
    y: r !== void 0 ? r : null
  };
}
function Su(e, t) {
  for (const i of e)
    if (i === t || i.contains(t))
      return !0;
}
function Hk(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let s = !1;
    for (const o of a)
      s = s || Su(o.addedNodes, n), s = s && !Su(o.removedNodes, n);
    s && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function Yk(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let s = !1;
    for (const o of a)
      s = s || Su(o.removedNodes, n), s = s && !Su(o.addedNodes, n);
    s && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const Co = /* @__PURE__ */ new Map();
let Eg = 0;
function Cb() {
  const e = window.devicePixelRatio;
  e !== Eg && (Eg = e, Co.forEach((t, i) => {
    i.currentDevicePixelRatio !== e && t();
  }));
}
function Wk(e, t) {
  Co.size || window.addEventListener("resize", Cb), Co.set(e, t);
}
function Uk(e) {
  Co.delete(e), Co.size || window.removeEventListener("resize", Cb);
}
function Gk(e, t, i) {
  const n = e.canvas, r = n && dv(n);
  if (!r)
    return;
  const a = sb((o, l) => {
    const u = r.clientWidth;
    i(o, l), u < r.clientWidth && i();
  }, window), s = new ResizeObserver((o) => {
    const l = o[0], u = l.contentRect.width, c = l.contentRect.height;
    u === 0 && c === 0 || a(u, c);
  });
  return s.observe(r), Wk(e, a), s;
}
function oh(e, t, i) {
  i && i.disconnect(), t === "resize" && Uk(e);
}
function Xk(e, t, i) {
  const n = e.canvas, r = sb((a) => {
    e.ctx !== null && i(Vk(a, e));
  }, e);
  return $k(n, t, r), r;
}
class jk extends Db {
  acquireContext(t, i) {
    const n = t && t.getContext && t.getContext("2d");
    return n && n.canvas === t ? (Bk(t, i), n) : null;
  }
  releaseContext(t) {
    const i = t.canvas;
    if (!i[tu])
      return !1;
    const n = i[tu].initial;
    [
      "height",
      "width"
    ].forEach((a) => {
      const s = n[a];
      kt(s) ? i.removeAttribute(a) : i.setAttribute(a, s);
    });
    const r = n.style || {};
    return Object.keys(r).forEach((a) => {
      i.style[a] = r[a];
    }), i.width = i.width, delete i[tu], !0;
  }
  addEventListener(t, i, n) {
    this.removeEventListener(t, i);
    const r = t.$proxies || (t.$proxies = {}), s = {
      attach: Hk,
      detach: Yk,
      resize: Gk
    }[i] || Xk;
    r[i] = s(t, i, n);
  }
  removeEventListener(t, i) {
    const n = t.$proxies || (t.$proxies = {}), r = n[i];
    if (!r)
      return;
    ({
      attach: oh,
      detach: oh,
      resize: oh
    }[i] || zk)(t, i, r), n[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, i, n, r) {
    return RM(t, i, n, r);
  }
  isAttached(t) {
    const i = t && dv(t);
    return !!(i && i.isConnected);
  }
}
function qk(e) {
  return !hv() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? Nk : jk;
}
let An = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  hasValue() {
    return Mo(this.x) && Mo(this.y);
  }
  getProps(t, i) {
    const n = this.$animations;
    if (!i || !n)
      return this;
    const r = {};
    return t.forEach((a) => {
      r[a] = n[a] && n[a].active() ? n[a]._to : this[a];
    }), r;
  }
};
function Zk(e, t) {
  const i = e.options.ticks, n = Kk(e), r = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? Jk(t) : [], s = a.length, o = a[0], l = a[s - 1], u = [];
  if (s > r)
    return tD(t, u, a, s / r), u;
  const c = Qk(a, t, r);
  if (s > 0) {
    let h, d;
    const f = s > 1 ? Math.round((l - o) / (s - 1)) : null;
    for (cl(t, u, c, kt(f) ? 0 : o - f, o), h = 0, d = s - 1; h < d; h++)
      cl(t, u, c, a[h], a[h + 1]);
    return cl(t, u, c, l, kt(f) ? t.length : l + f), u;
  }
  return cl(t, u, c), u;
}
function Kk(e) {
  const t = e.options.offset, i = e._tickSize(), n = e._length / i + (t ? 0 : 1), r = e._maxLength / i;
  return Math.floor(Math.min(n, r));
}
function Qk(e, t, i) {
  const n = eD(e), r = t.length / i;
  if (!n)
    return Math.max(r, 1);
  const a = I2(n);
  for (let s = 0, o = a.length - 1; s < o; s++) {
    const l = a[s];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function Jk(e) {
  const t = [];
  let i, n;
  for (i = 0, n = e.length; i < n; i++)
    e[i].major && t.push(i);
  return t;
}
function tD(e, t, i, n) {
  let r = 0, a = i[0], s;
  for (n = Math.ceil(n), s = 0; s < e.length; s++)
    s === a && (t.push(e[s]), r++, a = i[r * n]);
}
function cl(e, t, i, n, r) {
  const a = ut(n, 0), s = Math.min(ut(r, e.length), e.length);
  let o = 0, l, u, c;
  for (i = Math.ceil(i), r && (l = r - n, i = l / Math.floor(l / i)), c = a; c < 0; )
    o++, c = Math.round(a + o * i);
  for (u = Math.max(a, 0); u < s; u++)
    u === c && (t.push(e[u]), o++, c = Math.round(a + o * i));
}
function eD(e) {
  const t = e.length;
  let i, n;
  if (t < 2)
    return !1;
  for (n = e[0], i = 1; i < t; ++i)
    if (e[i] - e[i - 1] !== n)
      return !1;
  return n;
}
const iD = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Lg = (e, t, i) => t === "top" || t === "left" ? e[t] + i : e[t] - i, Og = (e, t) => Math.min(t || e, e);
function Ig(e, t) {
  const i = [], n = e.length / t, r = e.length;
  let a = 0;
  for (; a < r; a += n)
    i.push(e[Math.floor(a)]);
  return i;
}
function nD(e, t, i) {
  const n = e.ticks.length, r = Math.min(t, n - 1), a = e._startPixel, s = e._endPixel, o = 1e-6;
  let l = e.getPixelForTick(r), u;
  if (!(i && (n === 1 ? u = Math.max(l - a, s - l) : t === 0 ? u = (e.getPixelForTick(1) - l) / 2 : u = (l - e.getPixelForTick(r - 1)) / 2, l += r < t ? u : -u, l < a - o || l > s + o)))
    return l;
}
function rD(e, t) {
  Ct(e, (i) => {
    const n = i.gc, r = n.length / 2;
    let a;
    if (r > t) {
      for (a = 0; a < r; ++a)
        delete i.data[n[a]];
      n.splice(0, r);
    }
  });
}
function ws(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function Rg(e, t) {
  if (!e.display)
    return 0;
  const i = Me(e.font, t), n = gi(e.padding);
  return (ae(e.text) ? e.text.length : 1) * i.lineHeight + n.height;
}
function aD(e, t) {
  return la(e, {
    scale: t,
    type: "scale"
  });
}
function sD(e, t, i) {
  return la(e, {
    tick: i,
    index: t,
    type: "tick"
  });
}
function oD(e, t, i) {
  let n = rv(e);
  return (i && t !== "right" || !i && t === "right") && (n = iD(n)), n;
}
function lD(e, t, i, n) {
  const { top: r, left: a, bottom: s, right: o, chart: l } = e, { chartArea: u, scales: c } = l;
  let h = 0, d, f, v;
  const p = s - r, g = o - a;
  if (e.isHorizontal()) {
    if (f = xe(n, a, o), vt(i)) {
      const m = Object.keys(i)[0], _ = i[m];
      v = c[m].getPixelForValue(_) + p - t;
    } else i === "center" ? v = (u.bottom + u.top) / 2 + p - t : v = Lg(e, i, t);
    d = o - a;
  } else {
    if (vt(i)) {
      const m = Object.keys(i)[0], _ = i[m];
      f = c[m].getPixelForValue(_) - g + t;
    } else i === "center" ? f = (u.left + u.right) / 2 - g + t : f = Lg(e, i, t);
    v = xe(n, s, r), h = i === "left" ? -ce : ce;
  }
  return {
    titleX: f,
    titleY: v,
    maxWidth: d,
    rotation: h
  };
}
class cs extends An {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, i) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: i, _suggestedMin: n, _suggestedMax: r } = this;
    return t = Ri(t, Number.POSITIVE_INFINITY), i = Ri(i, Number.NEGATIVE_INFINITY), n = Ri(n, Number.POSITIVE_INFINITY), r = Ri(r, Number.NEGATIVE_INFINITY), {
      min: Ri(t, n),
      max: Ri(i, r),
      minDefined: Ce(t),
      maxDefined: Ce(i)
    };
  }
  getMinMax(t) {
    let { min: i, max: n, minDefined: r, maxDefined: a } = this.getUserBounds(), s;
    if (r && a)
      return {
        min: i,
        max: n
      };
    const o = this.getMatchingVisibleMetas();
    for (let l = 0, u = o.length; l < u; ++l)
      s = o[l].controller.getMinMax(this, t), r || (i = Math.min(i, s.min)), a || (n = Math.max(n, s.max));
    return i = a && i > n ? n : i, n = r && i > n ? i : n, {
      min: Ri(i, Ri(n, i)),
      max: Ri(n, Ri(i, n))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    $t(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, i, n) {
    const { beginAtZero: r, grace: a, ticks: s } = this.options, o = s.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = i, this._margins = n = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = fM(this, a, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = o < this.ticks.length;
    this._convertTicksToLabels(l ? Ig(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = Zk(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, i, n;
    this.isHorizontal() ? (i = this.left, n = this.right) : (i = this.top, n = this.bottom, t = !t), this._startPixel = i, this._endPixel = n, this._reversePixels = t, this._length = n - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    $t(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    $t(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    $t(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), $t(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    $t(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const i = this.options.ticks;
    let n, r, a;
    for (n = 0, r = t.length; n < r; n++)
      a = t[n], a.label = $t(i.callback, [
        a.value,
        n,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    $t(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    $t(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, i = t.ticks, n = Og(this.ticks.length, t.ticks.maxTicksLimit), r = i.minRotation || 0, a = i.maxRotation;
    let s = r, o, l, u;
    if (!this._isVisible() || !i.display || r >= a || n <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const c = this._getLabelSizes(), h = c.widest.width, d = c.highest.height, f = Se(this.chart.width - h, 0, this.maxWidth);
    o = t.offset ? this.maxWidth / n : f / (n - 1), h + 6 > o && (o = f / (n - (t.offset ? 0.5 : 1)), l = this.maxHeight - ws(t.grid) - i.padding - Rg(t.title, this.chart.options.font), u = Math.sqrt(h * h + d * d), s = B2(Math.min(Math.asin(Se((c.highest.height + 6) / o, -1, 1)), Math.asin(Se(l / u, -1, 1)) - Math.asin(Se(d / u, -1, 1)))), s = Math.max(r, Math.min(a, s))), this.labelRotation = s;
  }
  afterCalculateLabelRotation() {
    $t(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    $t(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: n, title: r, grid: a } } = this, s = this._isVisible(), o = this.isHorizontal();
    if (s) {
      const l = Rg(r, i.options.font);
      if (o ? (t.width = this.maxWidth, t.height = ws(a) + l) : (t.height = this.maxHeight, t.width = ws(a) + l), n.display && this.ticks.length) {
        const { first: u, last: c, widest: h, highest: d } = this._getLabelSizes(), f = n.padding * 2, v = pn(this.labelRotation), p = Math.cos(v), g = Math.sin(v);
        if (o) {
          const m = n.mirror ? 0 : g * h.width + p * d.height;
          t.height = Math.min(this.maxHeight, t.height + m + f);
        } else {
          const m = n.mirror ? 0 : p * h.width + g * d.height;
          t.width = Math.min(this.maxWidth, t.width + m + f);
        }
        this._calculatePadding(u, c, g, p);
      }
    }
    this._handleMargins(), o ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, i, n, r) {
    const { ticks: { align: a, padding: s }, position: o } = this.options, l = this.labelRotation !== 0, u = o !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);
      let d = 0, f = 0;
      l ? u ? (d = r * t.width, f = n * i.height) : (d = n * t.height, f = r * i.width) : a === "start" ? f = i.width : a === "end" ? d = t.width : a !== "inner" && (d = t.width / 2, f = i.width / 2), this.paddingLeft = Math.max((d - c + s) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - h + s) * this.width / (this.width - h), 0);
    } else {
      let c = i.height / 2, h = t.height / 2;
      a === "start" ? (c = 0, h = t.height) : a === "end" && (c = i.height, h = 0), this.paddingTop = c + s, this.paddingBottom = h + s;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    $t(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: i } = this.options;
    return i === "top" || i === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let i, n;
    for (i = 0, n = t.length; i < n; i++)
      kt(t[i].label) && (t.splice(i, 1), n--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const i = this.options.ticks.sampleSize;
      let n = this.ticks;
      i < n.length && (n = Ig(n, i)), this._labelSizes = t = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, i, n) {
    const { ctx: r, _longestTextCache: a } = this, s = [], o = [], l = Math.floor(i / Og(i, n));
    let u = 0, c = 0, h, d, f, v, p, g, m, _, y, b, w;
    for (h = 0; h < i; h += l) {
      if (v = t[h].label, p = this._resolveTickFontOptions(h), r.font = g = p.string, m = a[g] = a[g] || {
        data: {},
        gc: []
      }, _ = p.lineHeight, y = b = 0, !kt(v) && !ae(v))
        y = lg(r, m.data, m.gc, y, v), b = _;
      else if (ae(v))
        for (d = 0, f = v.length; d < f; ++d)
          w = v[d], !kt(w) && !ae(w) && (y = lg(r, m.data, m.gc, y, w), b += _);
      s.push(y), o.push(b), u = Math.max(y, u), c = Math.max(b, c);
    }
    rD(a, i);
    const S = s.indexOf(u), M = o.indexOf(c), k = (T) => ({
      width: s[T] || 0,
      height: o[T] || 0
    });
    return {
      first: k(0),
      last: k(i - 1),
      widest: k(S),
      highest: k(M),
      widths: s,
      heights: o
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, i) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const i = this._startPixel + t * this._length;
    return z2(this._alignToPixels ? lr(this.chart, i, 0) : i);
  }
  getDecimalForPixel(t) {
    const i = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: i } = this;
    return t < 0 && i < 0 ? i : t > 0 && i > 0 ? t : 0;
  }
  getContext(t) {
    const i = this.ticks || [];
    if (t >= 0 && t < i.length) {
      const n = i[t];
      return n.$context || (n.$context = sD(this.getContext(), t, n));
    }
    return this.$context || (this.$context = aD(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, i = pn(this.labelRotation), n = Math.abs(Math.cos(i)), r = Math.abs(Math.sin(i)), a = this._getLabelSizes(), s = t.autoSkipPadding || 0, o = a ? a.widest.width + s : 0, l = a ? a.highest.height + s : 0;
    return this.isHorizontal() ? l * n > o * r ? o / n : l / r : l * r < o * n ? l / n : o / r;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const i = this.axis, n = this.chart, r = this.options, { grid: a, position: s, border: o } = r, l = a.offset, u = this.isHorizontal(), h = this.ticks.length + (l ? 1 : 0), d = ws(a), f = [], v = o.setContext(this.getContext()), p = v.display ? v.width : 0, g = p / 2, m = function(F) {
      return lr(n, F, p);
    };
    let _, y, b, w, S, M, k, T, C, D, P, O;
    if (s === "top")
      _ = m(this.bottom), M = this.bottom - d, T = _ - g, D = m(t.top) + g, O = t.bottom;
    else if (s === "bottom")
      _ = m(this.top), D = t.top, O = m(t.bottom) - g, M = _ + g, T = this.top + d;
    else if (s === "left")
      _ = m(this.right), S = this.right - d, k = _ - g, C = m(t.left) + g, P = t.right;
    else if (s === "right")
      _ = m(this.left), C = t.left, P = m(t.right) - g, S = _ + g, k = this.left + d;
    else if (i === "x") {
      if (s === "center")
        _ = m((t.top + t.bottom) / 2 + 0.5);
      else if (vt(s)) {
        const F = Object.keys(s)[0], q = s[F];
        _ = m(this.chart.scales[F].getPixelForValue(q));
      }
      D = t.top, O = t.bottom, M = _ + g, T = M + d;
    } else if (i === "y") {
      if (s === "center")
        _ = m((t.left + t.right) / 2);
      else if (vt(s)) {
        const F = Object.keys(s)[0], q = s[F];
        _ = m(this.chart.scales[F].getPixelForValue(q));
      }
      S = _ - g, k = S - d, C = t.left, P = t.right;
    }
    const I = ut(r.ticks.maxTicksLimit, h), N = Math.max(1, Math.ceil(h / I));
    for (y = 0; y < h; y += N) {
      const F = this.getContext(y), q = a.setContext(F), V = o.setContext(F), B = q.lineWidth, $ = q.color, j = V.dash || [], G = V.dashOffset, et = q.tickWidth, at = q.tickColor, wt = q.tickBorderDash || [], Tt = q.tickBorderDashOffset;
      b = nD(this, y, l), b !== void 0 && (w = lr(n, b, B), u ? S = k = C = P = w : M = T = D = O = w, f.push({
        tx1: S,
        ty1: M,
        tx2: k,
        ty2: T,
        x1: C,
        y1: D,
        x2: P,
        y2: O,
        width: B,
        color: $,
        borderDash: j,
        borderDashOffset: G,
        tickWidth: et,
        tickColor: at,
        tickBorderDash: wt,
        tickBorderDashOffset: Tt
      }));
    }
    return this._ticksLength = h, this._borderValue = _, f;
  }
  _computeLabelItems(t) {
    const i = this.axis, n = this.options, { position: r, ticks: a } = n, s = this.isHorizontal(), o = this.ticks, { align: l, crossAlign: u, padding: c, mirror: h } = a, d = ws(n.grid), f = d + c, v = h ? -c : f, p = -pn(this.labelRotation), g = [];
    let m, _, y, b, w, S, M, k, T, C, D, P, O = "middle";
    if (r === "top")
      S = this.bottom - v, M = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      S = this.top + v, M = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const N = this._getYAxisLabelAlignment(d);
      M = N.textAlign, w = N.x;
    } else if (r === "right") {
      const N = this._getYAxisLabelAlignment(d);
      M = N.textAlign, w = N.x;
    } else if (i === "x") {
      if (r === "center")
        S = (t.top + t.bottom) / 2 + f;
      else if (vt(r)) {
        const N = Object.keys(r)[0], F = r[N];
        S = this.chart.scales[N].getPixelForValue(F) + f;
      }
      M = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (r === "center")
        w = (t.left + t.right) / 2 - f;
      else if (vt(r)) {
        const N = Object.keys(r)[0], F = r[N];
        w = this.chart.scales[N].getPixelForValue(F);
      }
      M = this._getYAxisLabelAlignment(d).textAlign;
    }
    i === "y" && (l === "start" ? O = "top" : l === "end" && (O = "bottom"));
    const I = this._getLabelSizes();
    for (m = 0, _ = o.length; m < _; ++m) {
      y = o[m], b = y.label;
      const N = a.setContext(this.getContext(m));
      k = this.getPixelForTick(m) + a.labelOffset, T = this._resolveTickFontOptions(m), C = T.lineHeight, D = ae(b) ? b.length : 1;
      const F = D / 2, q = N.color, V = N.textStrokeColor, B = N.textStrokeWidth;
      let $ = M;
      s ? (w = k, M === "inner" && (m === _ - 1 ? $ = this.options.reverse ? "left" : "right" : m === 0 ? $ = this.options.reverse ? "right" : "left" : $ = "center"), r === "top" ? u === "near" || p !== 0 ? P = -D * C + C / 2 : u === "center" ? P = -I.highest.height / 2 - F * C + C : P = -I.highest.height + C / 2 : u === "near" || p !== 0 ? P = C / 2 : u === "center" ? P = I.highest.height / 2 - F * C : P = I.highest.height - D * C, h && (P *= -1), p !== 0 && !N.showLabelBackdrop && (w += C / 2 * Math.sin(p))) : (S = k, P = (1 - D) * C / 2);
      let j;
      if (N.showLabelBackdrop) {
        const G = gi(N.backdropPadding), et = I.heights[m], at = I.widths[m];
        let wt = P - G.top, Tt = 0 - G.left;
        switch (O) {
          case "middle":
            wt -= et / 2;
            break;
          case "bottom":
            wt -= et;
            break;
        }
        switch (M) {
          case "center":
            Tt -= at / 2;
            break;
          case "right":
            Tt -= at;
            break;
          case "inner":
            m === _ - 1 ? Tt -= at : m > 0 && (Tt -= at / 2);
            break;
        }
        j = {
          left: Tt,
          top: wt,
          width: at + G.width,
          height: et + G.height,
          color: N.backdropColor
        };
      }
      g.push({
        label: b,
        font: T,
        textOffset: P,
        options: {
          rotation: p,
          color: q,
          strokeColor: V,
          strokeWidth: B,
          textAlign: $,
          textBaseline: O,
          translation: [
            w,
            S
          ],
          backdrop: j
        }
      });
    }
    return g;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: i } = this.options;
    if (-pn(this.labelRotation))
      return t === "top" ? "left" : "right";
    let r = "center";
    return i.align === "start" ? r = "left" : i.align === "end" ? r = "right" : i.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(t) {
    const { position: i, ticks: { crossAlign: n, mirror: r, padding: a } } = this.options, s = this._getLabelSizes(), o = t + a, l = s.widest.width;
    let u, c;
    return i === "left" ? r ? (c = this.right + a, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - o, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : i === "right" ? r ? (c = this.left + a, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + o, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", {
      textAlign: u,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: i }, left: n, top: r, width: a, height: s } = this;
    i && (t.save(), t.fillStyle = i, t.fillRect(n, r, a, s), t.restore());
  }
  getLineWidthForValue(t) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const r = this.ticks.findIndex((a) => a.value === t);
    return r >= 0 ? i.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(t) {
    const i = this.options.grid, n = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let a, s;
    const o = (l, u, c) => {
      !c.width || !c.color || (n.save(), n.lineWidth = c.width, n.strokeStyle = c.color, n.setLineDash(c.borderDash || []), n.lineDashOffset = c.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(u.x, u.y), n.stroke(), n.restore());
    };
    if (i.display)
      for (a = 0, s = r.length; a < s; ++a) {
        const l = r[a];
        i.drawOnChartArea && o({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), i.drawTicks && o({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: i, options: { border: n, grid: r } } = this, a = n.setContext(this.getContext()), s = n.display ? a.width : 0;
    if (!s)
      return;
    const o = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let u, c, h, d;
    this.isHorizontal() ? (u = lr(t, this.left, s) - s / 2, c = lr(t, this.right, o) + o / 2, h = d = l) : (h = lr(t, this.top, s) - s / 2, d = lr(t, this.bottom, o) + o / 2, u = c = l), i.save(), i.lineWidth = a.width, i.strokeStyle = a.color, i.beginPath(), i.moveTo(u, h), i.lineTo(c, d), i.stroke(), i.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const n = this.ctx, r = this._computeLabelArea();
    r && vc(n, r);
    const a = this.getLabelItems(t);
    for (const s of a) {
      const o = s.options, l = s.font, u = s.label, c = s.textOffset;
      To(n, u, 0, c, l, o);
    }
    r && pc(n);
  }
  drawTitle() {
    const { ctx: t, options: { position: i, title: n, reverse: r } } = this;
    if (!n.display)
      return;
    const a = Me(n.font), s = gi(n.padding), o = n.align;
    let l = a.lineHeight / 2;
    i === "bottom" || i === "center" || vt(i) ? (l += s.bottom, ae(n.text) && (l += a.lineHeight * (n.text.length - 1))) : l += s.top;
    const { titleX: u, titleY: c, maxWidth: h, rotation: d } = lD(this, l, i, o);
    To(t, n.text, 0, 0, a, {
      color: n.color,
      maxWidth: h,
      rotation: d,
      textAlign: oD(o, i, r),
      textBaseline: "middle",
      translation: [
        u,
        c
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, i = t.ticks && t.ticks.z || 0, n = ut(t.grid && t.grid.z, -1), r = ut(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== cs.prototype.draw ? [
      {
        z: i,
        draw: (a) => {
          this.draw(a);
        }
      }
    ] : [
      {
        z: n,
        draw: (a) => {
          this.drawBackground(), this.drawGrid(a), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (a) => {
          this.drawLabels(a);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const i = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", r = [];
    let a, s;
    for (a = 0, s = i.length; a < s; ++a) {
      const o = i[a];
      o[n] === this.id && (!t || o.type === t) && r.push(o);
    }
    return r;
  }
  _resolveTickFontOptions(t) {
    const i = this.options.ticks.setContext(this.getContext(t));
    return Me(i.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class hl {
  constructor(t, i, n) {
    this.type = t, this.scope = i, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const i = Object.getPrototypeOf(t);
    let n;
    hD(i) && (n = this.register(i));
    const r = this.items, a = t.id, s = this.scope + "." + a;
    if (!a)
      throw new Error("class does not have id: " + t);
    return a in r || (r[a] = t, uD(t, s, n), this.override && ie.override(t.id, t.overrides)), s;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const i = this.items, n = t.id, r = this.scope;
    n in i && delete i[n], r && n in ie[r] && (delete ie[r][n], this.override && delete aa[n]);
  }
}
function uD(e, t, i) {
  const n = wo(/* @__PURE__ */ Object.create(null), [
    i ? ie.get(i) : {},
    ie.get(t),
    e.defaults
  ]);
  ie.set(t, n), e.defaultRoutes && cD(t, e.defaultRoutes), e.descriptors && ie.describe(t, e.descriptors);
}
function cD(e, t) {
  Object.keys(t).forEach((i) => {
    const n = i.split("."), r = n.pop(), a = [
      e
    ].concat(n).join("."), s = t[i].split("."), o = s.pop(), l = s.join(".");
    ie.route(a, r, l, o);
  });
}
function hD(e) {
  return "id" in e && "defaults" in e;
}
class dD {
  constructor() {
    this.controllers = new hl(mc, "datasets", !0), this.elements = new hl(An, "elements"), this.plugins = new hl(Object, "plugins"), this.scales = new hl(cs, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, i, n) {
    [
      ...i
    ].forEach((r) => {
      const a = n || this._getRegistryForType(r);
      n || a.isForType(r) || a === this.plugins && r.id ? this._exec(t, a, r) : Ct(r, (s) => {
        const o = n || this._getRegistryForType(s);
        this._exec(t, o, s);
      });
    });
  }
  _exec(t, i, n) {
    const r = iv(t);
    $t(n["before" + r], [], n), i[t](n), $t(n["after" + r], [], n);
  }
  _getRegistryForType(t) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const n = this._typedRegistries[i];
      if (n.isForType(t))
        return n;
    }
    return this.plugins;
  }
  _get(t, i, n) {
    const r = i.get(t);
    if (r === void 0)
      throw new Error('"' + t + '" is not a registered ' + n + ".");
    return r;
  }
}
var Hi = /* @__PURE__ */ new dD();
class fD {
  constructor() {
    this._init = void 0;
  }
  notify(t, i, n, r) {
    if (i === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")), this._init === void 0)
      return;
    const a = r ? this._descriptors(t).filter(r) : this._descriptors(t), s = this._notify(a, t, i, n);
    return i === "afterDestroy" && (this._notify(a, t, "stop"), this._notify(this._init, t, "uninstall"), this._init = void 0), s;
  }
  _notify(t, i, n, r) {
    r = r || {};
    for (const a of t) {
      const s = a.plugin, o = s[n], l = [
        i,
        r,
        a.options
      ];
      if ($t(o, l, s) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    kt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), i;
  }
  _createDescriptors(t, i) {
    const n = t && t.config, r = ut(n.options && n.options.plugins, {}), a = vD(n);
    return r === !1 && !i ? [] : gD(t, a, r, i);
  }
  _notifyStateChanges(t) {
    const i = this._oldCache || [], n = this._cache, r = (a, s) => a.filter((o) => !s.some((l) => o.plugin.id === l.plugin.id));
    this._notify(r(i, n), t, "stop"), this._notify(r(n, i), t, "start");
  }
}
function vD(e) {
  const t = {}, i = [], n = Object.keys(Hi.plugins.items);
  for (let a = 0; a < n.length; a++)
    i.push(Hi.getPlugin(n[a]));
  const r = e.plugins || [];
  for (let a = 0; a < r.length; a++) {
    const s = r[a];
    i.indexOf(s) === -1 && (i.push(s), t[s.id] = !0);
  }
  return {
    plugins: i,
    localIds: t
  };
}
function pD(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function gD(e, { plugins: t, localIds: i }, n, r) {
  const a = [], s = e.getContext();
  for (const o of t) {
    const l = o.id, u = pD(n[l], r);
    u !== null && a.push({
      plugin: o,
      options: mD(e.config, {
        plugin: o,
        local: i[l]
      }, u, s)
    });
  }
  return a;
}
function mD(e, { plugin: t, local: i }, n, r) {
  const a = e.pluginScopeKeys(t), s = e.getOptionScopes(n, a);
  return i && t.defaults && s.push(t.defaults), e.createResolver(s, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function $d(e, t) {
  const i = ie.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || i.indexAxis || "x";
}
function _D(e, t) {
  let i = e;
  return e === "_index_" ? i = t : e === "_value_" && (i = t === "x" ? "y" : "x"), i;
}
function yD(e, t) {
  return e === t ? "_index_" : "_value_";
}
function Ng(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function bD(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function zd(e, ...t) {
  if (Ng(e))
    return e;
  for (const i of t) {
    const n = i.axis || bD(i.position) || e.length > 1 && Ng(e[0].toLowerCase());
    if (n)
      return n;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function Fg(e, t, i) {
  if (i[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function xD(e, t) {
  if (t.data && t.data.datasets) {
    const i = t.data.datasets.filter((n) => n.xAxisID === e || n.yAxisID === e);
    if (i.length)
      return Fg(e, "x", i[0]) || Fg(e, "y", i[0]);
  }
  return {};
}
function wD(e, t) {
  const i = aa[e.type] || {
    scales: {}
  }, n = t.scales || {}, r = $d(e.type, t), a = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach((s) => {
    const o = n[s];
    if (!vt(o))
      return console.error(`Invalid scale configuration for scale: ${s}`);
    if (o._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${s}`);
    const l = zd(s, o, xD(s, e), ie.scales[o.type]), u = yD(l, r), c = i.scales || {};
    a[s] = so(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      o,
      c[l],
      c[u]
    ]);
  }), e.data.datasets.forEach((s) => {
    const o = s.type || e.type, l = s.indexAxis || $d(o, t), c = (aa[o] || {}).scales || {};
    Object.keys(c).forEach((h) => {
      const d = _D(h, l), f = s[d + "AxisID"] || d;
      a[f] = a[f] || /* @__PURE__ */ Object.create(null), so(a[f], [
        {
          axis: d
        },
        n[f],
        c[h]
      ]);
    });
  }), Object.keys(a).forEach((s) => {
    const o = a[s];
    so(o, [
      ie.scales[o.type],
      ie.scale
    ]);
  }), a;
}
function Ab(e) {
  const t = e.options || (e.options = {});
  t.plugins = ut(t.plugins, {}), t.scales = wD(e, t);
}
function Pb(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function SD(e) {
  return e = e || {}, e.data = Pb(e.data), Ab(e), e;
}
const Bg = /* @__PURE__ */ new Map(), Eb = /* @__PURE__ */ new Set();
function dl(e, t) {
  let i = Bg.get(e);
  return i || (i = t(), Bg.set(e, i), Eb.add(i)), i;
}
const Ss = (e, t, i) => {
  const n = ra(t, i);
  n !== void 0 && e.add(n);
};
class MD {
  constructor(t) {
    this._config = SD(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Pb(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Ab(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return dl(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, i) {
    return dl(`${t}.transition.${i}`, () => [
      [
        `datasets.${t}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, i) {
    return dl(`${t}-${i}`, () => [
      [
        `datasets.${t}.elements.${i}`,
        `datasets.${t}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const i = t.id, n = this.type;
    return dl(`${n}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, i) {
    const n = this._scopeCache;
    let r = n.get(t);
    return (!r || i) && (r = /* @__PURE__ */ new Map(), n.set(t, r)), r;
  }
  getOptionScopes(t, i, n) {
    const { options: r, type: a } = this, s = this._cachedScopes(t, n), o = s.get(i);
    if (o)
      return o;
    const l = /* @__PURE__ */ new Set();
    i.forEach((c) => {
      t && (l.add(t), c.forEach((h) => Ss(l, t, h))), c.forEach((h) => Ss(l, r, h)), c.forEach((h) => Ss(l, aa[a] || {}, h)), c.forEach((h) => Ss(l, ie, h)), c.forEach((h) => Ss(l, Fd, h));
    });
    const u = Array.from(l);
    return u.length === 0 && u.push(/* @__PURE__ */ Object.create(null)), Eb.has(i) && s.set(i, u), u;
  }
  chartOptionScopes() {
    const { options: t, type: i } = this;
    return [
      t,
      aa[i] || {},
      ie.datasets[i] || {},
      {
        type: i
      },
      ie,
      Fd
    ];
  }
  resolveNamedOptions(t, i, n, r = [
    ""
  ]) {
    const a = {
      $shared: !0
    }, { resolver: s, subPrefixes: o } = $g(this._resolverCache, t, r);
    let l = s;
    if (DD(s, i)) {
      a.$shared = !1, n = tr(n) ? n() : n;
      const u = this.createResolver(t, n, o);
      l = is(s, n, u);
    }
    for (const u of i)
      a[u] = l[u];
    return a;
  }
  createResolver(t, i, n = [
    ""
  ], r) {
    const { resolver: a } = $g(this._resolverCache, t, n);
    return vt(i) ? is(a, i, void 0, r) : a;
  }
}
function $g(e, t, i) {
  let n = e.get(t);
  n || (n = /* @__PURE__ */ new Map(), e.set(t, n));
  const r = i.join();
  let a = n.get(r);
  return a || (a = {
    resolver: lv(t, i),
    subPrefixes: i.filter((o) => !o.toLowerCase().includes("hover"))
  }, n.set(r, a)), a;
}
const kD = (e) => vt(e) && Object.getOwnPropertyNames(e).some((t) => tr(e[t]));
function DD(e, t) {
  const { isScriptable: i, isIndexable: n } = cb(e);
  for (const r of t) {
    const a = i(r), s = n(r), o = (s || a) && e[r];
    if (a && (tr(o) || kD(o)) || s && ae(o))
      return !0;
  }
  return !1;
}
var TD = "4.5.1";
const CD = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function zg(e, t) {
  return e === "top" || e === "bottom" || CD.indexOf(e) === -1 && t === "x";
}
function Vg(e, t) {
  return function(i, n) {
    return i[e] === n[e] ? i[t] - n[t] : i[e] - n[e];
  };
}
function Hg(e) {
  const t = e.chart, i = t.options.animation;
  t.notifyPlugins("afterRender"), $t(i && i.onComplete, [
    e
  ], t);
}
function AD(e) {
  const t = e.chart, i = t.options.animation;
  $t(i && i.onProgress, [
    e
  ], t);
}
function Lb(e) {
  return hv() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const eu = {}, Yg = (e) => {
  const t = Lb(e);
  return Object.values(eu).filter((i) => i.canvas === t).pop();
};
function PD(e, t, i) {
  const n = Object.keys(e);
  for (const r of n) {
    const a = +r;
    if (a >= t) {
      const s = e[r];
      delete e[r], (i > 0 || a > t) && (e[a + i] = s);
    }
  }
}
function ED(e, t, i, n) {
  return !i || e.type === "mouseout" ? null : n ? t : e;
}
let hs = class {
  static defaults = ie;
  static instances = eu;
  static overrides = aa;
  static registry = Hi;
  static version = TD;
  static getChart = Yg;
  static register(...t) {
    Hi.add(...t), Wg();
  }
  static unregister(...t) {
    Hi.remove(...t), Wg();
  }
  constructor(t, i) {
    const n = this.config = new MD(i), r = Lb(t), a = Yg(r);
    if (a)
      throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas with ID '" + a.canvas.id + "' can be reused.");
    const s = n.createResolver(n.chartOptionScopes(), this.getContext());
    this.platform = new (n.platform || qk(r))(), this.platform.updateConfig(n);
    const o = this.platform.acquireContext(r, s.aspectRatio), l = o && o.canvas, u = l && l.height, c = l && l.width;
    if (this.id = k2(), this.ctx = o, this.canvas = l, this.width = c, this.height = u, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new fD(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = W2((h) => this.update(h), s.resizeDelay || 0), this._dataChanges = [], eu[this.id] = this, !o || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    cn.listen(this, "complete", Hg), cn.listen(this, "progress", AD), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: i }, width: n, height: r, _aspectRatio: a } = this;
    return kt(t) ? i && a ? a : r ? n / r : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Hi;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : dg(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return ug(this.canvas, this.ctx), this;
  }
  stop() {
    return cn.stop(this), this;
  }
  resize(t, i) {
    cn.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: i
    } : this._resize(t, i);
  }
  _resize(t, i) {
    const n = this.options, r = this.canvas, a = n.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(r, t, i, a), o = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, dg(this, o, !0) && (this.notifyPlugins("resize", {
      size: s
    }), $t(n.onResize, [
      this,
      s
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    Ct(i, (n, r) => {
      n.id = r;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, i = t.scales, n = this.scales, r = Object.keys(n).reduce((s, o) => (s[o] = !1, s), {});
    let a = [];
    i && (a = a.concat(Object.keys(i).map((s) => {
      const o = i[s], l = zd(s, o), u = l === "r", c = l === "x";
      return {
        options: o,
        dposition: u ? "chartArea" : c ? "bottom" : "left",
        dtype: u ? "radialLinear" : c ? "category" : "linear"
      };
    }))), Ct(a, (s) => {
      const o = s.options, l = o.id, u = zd(l, o), c = ut(o.type, s.dtype);
      (o.position === void 0 || zg(o.position, u) !== zg(s.dposition)) && (o.position = s.dposition), r[l] = !0;
      let h = null;
      if (l in n && n[l].type === c)
        h = n[l];
      else {
        const d = Hi.getScale(c);
        h = new d({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), n[h.id] = h;
      }
      h.init(o, t);
    }), Ct(r, (s, o) => {
      s || delete n[o];
    }), Ct(n, (s) => {
      fi.configure(this, s, s.options), fi.addBox(this, s);
    });
  }
  _updateMetasets() {
    const t = this._metasets, i = this.data.datasets.length, n = t.length;
    if (t.sort((r, a) => r.index - a.index), n > i) {
      for (let r = i; r < n; ++r)
        this._destroyDatasetMeta(r);
      t.splice(i, n - i);
    }
    this._sortedMetasets = t.slice(0).sort(Vg("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: i } } = this;
    t.length > i.length && delete this._stacks, t.forEach((n, r) => {
      i.filter((a) => a === n._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const t = [], i = this.data.datasets;
    let n, r;
    for (this._removeUnreferencedMetasets(), n = 0, r = i.length; n < r; n++) {
      const a = i[n];
      let s = this.getDatasetMeta(n);
      const o = a.type || this.config.type;
      if (s.type && s.type !== o && (this._destroyDatasetMeta(n), s = this.getDatasetMeta(n)), s.type = o, s.indexAxis = a.indexAxis || $d(o, this.options), s.order = a.order || 0, s.index = n, s.label = "" + a.label, s.visible = this.isDatasetVisible(n), s.controller)
        s.controller.updateIndex(n), s.controller.linkScales();
      else {
        const l = Hi.getController(o), { datasetElementType: u, dataElementType: c } = ie.datasets[o];
        Object.assign(l, {
          dataElementType: Hi.getElement(c),
          datasetElementType: u && Hi.getElement(u)
        }), s.controller = new l(this, n), t.push(s.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    Ct(this.data.datasets, (t, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const i = this.config;
    i.update();
    const n = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !n.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const a = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let s = 0;
    for (let u = 0, c = this.data.datasets.length; u < c; u++) {
      const { controller: h } = this.getDatasetMeta(u), d = !r && a.indexOf(h) === -1;
      h.buildOrUpdateElements(d), s = Math.max(+h.getMaxOverflow(), s);
    }
    s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), r || Ct(a, (u) => {
      u.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(Vg("z", "_idx"));
    const { _active: o, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : o.length && this._updateHoverStyles(o, o, !0), this.render();
  }
  _updateScales() {
    Ct(this.scales, (t) => {
      fi.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, i = new Set(Object.keys(this._listeners)), n = new Set(t.events);
    (!Jp(i, n) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, i = this._getUniformDataChanges() || [];
    for (const { method: n, start: r, count: a } of i) {
      const s = n === "_removeElements" ? -a : a;
      PD(t, r, s);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, n = (a) => new Set(t.filter((s) => s[0] === a).map((s, o) => o + "," + s.splice(1).join(","))), r = n(0);
    for (let a = 1; a < i; a++)
      if (!Jp(r, n(a)))
        return;
    return Array.from(r).map((a) => a.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    fi.update(this, this.width, this.height, t);
    const i = this.chartArea, n = i.width <= 0 || i.height <= 0;
    this._layers = [], Ct(this.boxes, (r) => {
      n && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, a) => {
      r._idx = a;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this._updateDataset(i, tr(t) ? t({
          datasetIndex: i
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, i) {
    const n = this.getDatasetMeta(t), r = {
      meta: n,
      index: t,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (n.controller._update(i), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (cn.has(this) ? this.attached && !cn.running(this) && cn.start(this) : (this.draw(), Hg({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: n, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(n, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (t = 0; t < i.length && i[t].z <= 0; ++t)
      i[t].draw(this.chartArea);
    for (this._drawDatasets(); t < i.length; ++t)
      i[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const i = this._sortedMetasets, n = [];
    let r, a;
    for (r = 0, a = i.length; r < a; ++r) {
      const s = i[r];
      (!t || s.visible) && n.push(s);
    }
    return n;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let i = t.length - 1; i >= 0; --i)
      this._drawDataset(t[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const i = this.ctx, n = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, r = bb(this, t);
    this.notifyPlugins("beforeDatasetDraw", n) !== !1 && (r && vc(i, r), t.controller.draw(), r && pc(i), n.cancelable = !1, this.notifyPlugins("afterDatasetDraw", n));
  }
  isPointInArea(t) {
    return Do(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, i, n, r) {
    const a = Ck.modes[i];
    return typeof a == "function" ? a(this, t, n, r) : [];
  }
  getDatasetMeta(t) {
    const i = this.data.datasets[t], n = this._metasets;
    let r = n.filter((a) => a && a._dataset === i).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: t,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, n.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = la(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const i = this.data.datasets[t];
    if (!i)
      return !1;
    const n = this.getDatasetMeta(t);
    return typeof n.hidden == "boolean" ? !n.hidden : !i.hidden;
  }
  setDatasetVisibility(t, i) {
    const n = this.getDatasetMeta(t);
    n.hidden = !i;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, i, n) {
    const r = n ? "show" : "hide", a = this.getDatasetMeta(t), s = a.controller._resolveAnimations(void 0, r);
    So(i) ? (a.data[i].hidden = !n, this.update()) : (this.setDatasetVisibility(t, n), s.update(a, {
      visible: n
    }), this.update((o) => o.datasetIndex === t ? r : void 0));
  }
  hide(t, i) {
    this._updateVisibility(t, i, !1);
  }
  show(t, i) {
    this._updateVisibility(t, i, !0);
  }
  _destroyDatasetMeta(t) {
    const i = this._metasets[t];
    i && i.controller && i.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, i;
    for (this.stop(), cn.remove(this), t = 0, i = this.data.datasets.length; t < i; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: i } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), ug(t, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete eu[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, i = this.platform, n = (a, s) => {
      i.addEventListener(this, a, s), t[a] = s;
    }, r = (a, s, o) => {
      a.offsetX = s, a.offsetY = o, this._eventHandler(a);
    };
    Ct(this.options.events, (a) => n(a, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, i = this.platform, n = (l, u) => {
      i.addEventListener(this, l, u), t[l] = u;
    }, r = (l, u) => {
      t[l] && (i.removeEventListener(this, l, u), delete t[l]);
    }, a = (l, u) => {
      this.canvas && this.resize(l, u);
    };
    let s;
    const o = () => {
      r("attach", o), this.attached = !0, this.resize(), n("resize", a), n("detach", s);
    };
    s = () => {
      this.attached = !1, r("resize", a), this._stop(), this._resize(0, 0), n("attach", o);
    }, i.isAttached(this.canvas) ? o() : s();
  }
  unbindEvents() {
    Ct(this._listeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._listeners = {}, Ct(this._responsiveListeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, i, n) {
    const r = n ? "set" : "remove";
    let a, s, o, l;
    for (i === "dataset" && (a = this.getDatasetMeta(t[0].datasetIndex), a.controller["_" + r + "DatasetHoverStyle"]()), o = 0, l = t.length; o < l; ++o) {
      s = t[o];
      const u = s && this.getDatasetMeta(s.datasetIndex).controller;
      u && u[r + "HoverStyle"](s.element, s.datasetIndex, s.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const i = this._active || [], n = t.map(({ datasetIndex: a, index: s }) => {
      const o = this.getDatasetMeta(a);
      if (!o)
        throw new Error("No dataset found at index " + a);
      return {
        datasetIndex: a,
        element: o.data[s],
        index: s
      };
    });
    !_u(n, i) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, i));
  }
  notifyPlugins(t, i, n) {
    return this._plugins.notify(this, t, i, n);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((i) => i.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, i, n) {
    const r = this.options.hover, a = (l, u) => l.filter((c) => !u.some((h) => c.datasetIndex === h.datasetIndex && c.index === h.index)), s = a(i, t), o = n ? t : a(t, i);
    s.length && this.updateHoverStyle(s, r.mode, !1), o.length && r.mode && this.updateHoverStyle(o, r.mode, !0);
  }
  _eventHandler(t, i) {
    const n = {
      event: t,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, r = (s) => (s.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", n, r) === !1)
      return;
    const a = this._handleEvent(t, i, n.inChartArea);
    return n.cancelable = !1, this.notifyPlugins("afterEvent", n, r), (a || n.changed) && this.render(), this;
  }
  _handleEvent(t, i, n) {
    const { _active: r = [], options: a } = this, s = i, o = this._getActiveElements(t, r, n, s), l = E2(t), u = ED(t, this._lastEvent, n, l);
    n && (this._lastEvent = null, $t(a.onHover, [
      t,
      o,
      this
    ], this), l && $t(a.onClick, [
      t,
      o,
      this
    ], this));
    const c = !_u(o, r);
    return (c || i) && (this._active = o, this._updateHoverStyles(o, r, i)), this._lastEvent = u, c;
  }
  _getActiveElements(t, i, n, r) {
    if (t.type === "mouseout")
      return [];
    if (!n)
      return i;
    const a = this.options.hover;
    return this.getElementsAtEventForMode(t, a.mode, a, r);
  }
};
function Wg() {
  return Ct(hs.instances, (e) => e._plugins.invalidate());
}
function LD(e, t, i) {
  const { startAngle: n, x: r, y: a, outerRadius: s, innerRadius: o, options: l } = t, { borderWidth: u, borderJoinStyle: c } = l, h = Math.min(u / s, je(n - i));
  if (e.beginPath(), e.arc(r, a, s - u / 2, n + h / 2, i - h / 2), o > 0) {
    const d = Math.min(u / o, je(n - i));
    e.arc(r, a, o + u / 2, i - d / 2, n + d / 2, !0);
  } else {
    const d = Math.min(u / 2, s * je(n - i));
    if (c === "round")
      e.arc(r, a, d, i - At / 2, n + At / 2, !0);
    else if (c === "bevel") {
      const f = 2 * d * d, v = -f * Math.cos(i + At / 2) + r, p = -f * Math.sin(i + At / 2) + a, g = f * Math.cos(n + At / 2) + r, m = f * Math.sin(n + At / 2) + a;
      e.lineTo(v, p), e.lineTo(g, m);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function OD(e, t, i) {
  const { startAngle: n, pixelMargin: r, x: a, y: s, outerRadius: o, innerRadius: l } = t;
  let u = r / o;
  e.beginPath(), e.arc(a, s, o, n - u, i + u), l > r ? (u = r / l, e.arc(a, s, l, i + u, n - u, !0)) : e.arc(a, s, r, i + ce, n - ce), e.closePath(), e.clip();
}
function ID(e) {
  return ov(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function RD(e, t, i, n) {
  const r = ID(e.options.borderRadius), a = (i - t) / 2, s = Math.min(a, n * t / 2), o = (l) => {
    const u = (i - Math.min(a, l)) * n / 2;
    return Se(l, 0, Math.min(a, u));
  };
  return {
    outerStart: o(r.outerStart),
    outerEnd: o(r.outerEnd),
    innerStart: Se(r.innerStart, 0, s),
    innerEnd: Se(r.innerEnd, 0, s)
  };
}
function ga(e, t, i, n) {
  return {
    x: i + e * Math.cos(t),
    y: n + e * Math.sin(t)
  };
}
function Mu(e, t, i, n, r, a) {
  const { x: s, y: o, startAngle: l, pixelMargin: u, innerRadius: c } = t, h = Math.max(t.outerRadius + n + i - u, 0), d = c > 0 ? c + n + i + u : 0;
  let f = 0;
  const v = r - l;
  if (n) {
    const N = c > 0 ? c - n : 0, F = h > 0 ? h - n : 0, q = (N + F) / 2, V = q !== 0 ? v * q / (q + n) : v;
    f = (v - V) / 2;
  }
  const p = Math.max(1e-3, v * h - i / At) / h, g = (v - p) / 2, m = l + g + f, _ = r - g - f, { outerStart: y, outerEnd: b, innerStart: w, innerEnd: S } = RD(t, d, h, _ - m), M = h - y, k = h - b, T = m + y / M, C = _ - b / k, D = d + w, P = d + S, O = m + w / D, I = _ - S / P;
  if (e.beginPath(), a) {
    const N = (T + C) / 2;
    if (e.arc(s, o, h, T, N), e.arc(s, o, h, N, C), b > 0) {
      const B = ga(k, C, s, o);
      e.arc(B.x, B.y, b, C, _ + ce);
    }
    const F = ga(P, _, s, o);
    if (e.lineTo(F.x, F.y), S > 0) {
      const B = ga(P, I, s, o);
      e.arc(B.x, B.y, S, _ + ce, I + Math.PI);
    }
    const q = (_ - S / d + (m + w / d)) / 2;
    if (e.arc(s, o, d, _ - S / d, q, !0), e.arc(s, o, d, q, m + w / d, !0), w > 0) {
      const B = ga(D, O, s, o);
      e.arc(B.x, B.y, w, O + Math.PI, m - ce);
    }
    const V = ga(M, m, s, o);
    if (e.lineTo(V.x, V.y), y > 0) {
      const B = ga(M, T, s, o);
      e.arc(B.x, B.y, y, m - ce, T);
    }
  } else {
    e.moveTo(s, o);
    const N = Math.cos(T) * h + s, F = Math.sin(T) * h + o;
    e.lineTo(N, F);
    const q = Math.cos(C) * h + s, V = Math.sin(C) * h + o;
    e.lineTo(q, V);
  }
  e.closePath();
}
function ND(e, t, i, n, r) {
  const { fullCircles: a, startAngle: s, circumference: o } = t;
  let l = t.endAngle;
  if (a) {
    Mu(e, t, i, n, l, r);
    for (let u = 0; u < a; ++u)
      e.fill();
    isNaN(o) || (l = s + (o % Xt || Xt));
  }
  return Mu(e, t, i, n, l, r), e.fill(), l;
}
function FD(e, t, i, n, r) {
  const { fullCircles: a, startAngle: s, circumference: o, options: l } = t, { borderWidth: u, borderJoinStyle: c, borderDash: h, borderDashOffset: d, borderRadius: f } = l, v = l.borderAlign === "inner";
  if (!u)
    return;
  e.setLineDash(h || []), e.lineDashOffset = d, v ? (e.lineWidth = u * 2, e.lineJoin = c || "round") : (e.lineWidth = u, e.lineJoin = c || "bevel");
  let p = t.endAngle;
  if (a) {
    Mu(e, t, i, n, p, r);
    for (let g = 0; g < a; ++g)
      e.stroke();
    isNaN(o) || (p = s + (o % Xt || Xt));
  }
  v && OD(e, t, p), l.selfJoin && p - s >= At && f === 0 && c !== "miter" && LD(e, t, p), a || (Mu(e, t, i, n, p, r), e.stroke());
}
class BD extends An {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.getProps([
      "x",
      "y"
    ], n), { angle: a, distance: s } = ib(r, {
      x: t,
      y: i
    }), { startAngle: o, endAngle: l, innerRadius: u, outerRadius: c, circumference: h } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], n), d = (this.options.spacing + this.options.borderWidth) / 2, f = ut(h, l - o), v = ko(a, o, l) && o !== l, p = f >= Xt || v, g = gn(s, u + d, c + d);
    return p && g;
  }
  getCenterPoint(t) {
    const { x: i, y: n, startAngle: r, endAngle: a, innerRadius: s, outerRadius: o } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: u } = this.options, c = (r + a) / 2, h = (s + o + u + l) / 2;
    return {
      x: i + Math.cos(c) * h,
      y: n + Math.sin(c) * h
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: i, circumference: n } = this, r = (i.offset || 0) / 4, a = (i.spacing || 0) / 2, s = i.circular;
    if (this.pixelMargin = i.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = n > Xt ? Math.floor(n / Xt) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const o = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(o) * r, Math.sin(o) * r);
    const l = 1 - Math.sin(Math.min(At, n || 0)), u = r * l;
    t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor, ND(t, this, u, a, s), FD(t, this, u, a, s), t.restore();
  }
}
function Ob(e, t, i = t) {
  e.lineCap = ut(i.borderCapStyle, t.borderCapStyle), e.setLineDash(ut(i.borderDash, t.borderDash)), e.lineDashOffset = ut(i.borderDashOffset, t.borderDashOffset), e.lineJoin = ut(i.borderJoinStyle, t.borderJoinStyle), e.lineWidth = ut(i.borderWidth, t.borderWidth), e.strokeStyle = ut(i.borderColor, t.borderColor);
}
function $D(e, t, i) {
  e.lineTo(i.x, i.y);
}
function zD(e) {
  return e.stepped ? rM : e.tension || e.cubicInterpolationMode === "monotone" ? aM : $D;
}
function Ib(e, t, i = {}) {
  const n = e.length, { start: r = 0, end: a = n - 1 } = i, { start: s, end: o } = t, l = Math.max(r, s), u = Math.min(a, o), c = r < s && a < s || r > o && a > o;
  return {
    count: n,
    start: l,
    loop: t.loop,
    ilen: u < l && !c ? n + u - l : u - l
  };
}
function VD(e, t, i, n) {
  const { points: r, options: a } = t, { count: s, start: o, loop: l, ilen: u } = Ib(r, i, n), c = zD(a);
  let { move: h = !0, reverse: d } = n || {}, f, v, p;
  for (f = 0; f <= u; ++f)
    v = r[(o + (d ? u - f : f)) % s], !v.skip && (h ? (e.moveTo(v.x, v.y), h = !1) : c(e, p, v, d, a.stepped), p = v);
  return l && (v = r[(o + (d ? u : 0)) % s], c(e, p, v, d, a.stepped)), !!l;
}
function HD(e, t, i, n) {
  const r = t.points, { count: a, start: s, ilen: o } = Ib(r, i, n), { move: l = !0, reverse: u } = n || {};
  let c = 0, h = 0, d, f, v, p, g, m;
  const _ = (b) => (s + (u ? o - b : b)) % a, y = () => {
    p !== g && (e.lineTo(c, g), e.lineTo(c, p), e.lineTo(c, m));
  };
  for (l && (f = r[_(0)], e.moveTo(f.x, f.y)), d = 0; d <= o; ++d) {
    if (f = r[_(d)], f.skip)
      continue;
    const b = f.x, w = f.y, S = b | 0;
    S === v ? (w < p ? p = w : w > g && (g = w), c = (h * c + b) / ++h) : (y(), e.lineTo(b, w), v = S, h = 0, p = g = w), m = w;
  }
  y();
}
function Vd(e) {
  const t = e.options, i = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !i ? HD : VD;
}
function YD(e) {
  return e.stepped ? FM : e.tension || e.cubicInterpolationMode === "monotone" ? BM : Nr;
}
function WD(e, t, i, n) {
  let r = t._path;
  r || (r = t._path = new Path2D(), t.path(r, i, n) && r.closePath()), Ob(e, t.options), e.stroke(r);
}
function UD(e, t, i, n) {
  const { segments: r, options: a } = t, s = Vd(t);
  for (const o of r)
    Ob(e, a, o.style), e.beginPath(), s(e, t, o, {
      start: i,
      end: i + n - 1
    }) && e.closePath(), e.stroke();
}
const GD = typeof Path2D == "function";
function XD(e, t, i, n) {
  GD && !t.options.segment ? WD(e, t, i, n) : UD(e, t, i, n);
}
class yc extends An {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, i) {
    const n = this.options;
    if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
      const r = n.spanGaps ? this._loop : this._fullLoop;
      AM(this._points, n, t, r, i), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = WM(this, this.options.segment));
  }
  first() {
    const t = this.segments, i = this.points;
    return t.length && i[t[0].start];
  }
  last() {
    const t = this.segments, i = this.points, n = t.length;
    return n && i[t[n - 1].end];
  }
  interpolate(t, i) {
    const n = this.options, r = t[i], a = this.points, s = yb(this, {
      property: i,
      start: r,
      end: r
    });
    if (!s.length)
      return;
    const o = [], l = YD(n);
    let u, c;
    for (u = 0, c = s.length; u < c; ++u) {
      const { start: h, end: d } = s[u], f = a[h], v = a[d];
      if (f === v) {
        o.push(f);
        continue;
      }
      const p = Math.abs((r - f[i]) / (v[i] - f[i])), g = l(f, v, p, n.stepped);
      g[i] = t[i], o.push(g);
    }
    return o.length === 1 ? o[0] : o;
  }
  pathSegment(t, i, n) {
    return Vd(this)(t, this, i, n);
  }
  path(t, i, n) {
    const r = this.segments, a = Vd(this);
    let s = this._loop;
    i = i || 0, n = n || this.points.length - i;
    for (const o of r)
      s &= a(t, this, o, {
        start: i,
        end: i + n - 1
      });
    return !!s;
  }
  draw(t, i, n, r) {
    const a = this.options || {};
    (this.points || []).length && a.borderWidth && (t.save(), XD(t, this, n, r), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function Ug(e, t, i, n) {
  const r = e.options, { [i]: a } = e.getProps([
    i
  ], n);
  return Math.abs(t - a) < r.radius + r.hitRadius;
}
class jD extends An {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.options, { x: a, y: s } = this.getProps([
      "x",
      "y"
    ], n);
    return Math.pow(t - a, 2) + Math.pow(i - s, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(t, i) {
    return Ug(this, t, "x", i);
  }
  inYRange(t, i) {
    return Ug(this, t, "y", i);
  }
  getCenterPoint(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  size(t) {
    t = t || this.options || {};
    let i = t.radius || 0;
    i = Math.max(i, i && t.hoverRadius || 0);
    const n = i && t.borderWidth || 0;
    return (i + n) * 2;
  }
  draw(t, i) {
    const n = this.options;
    this.skip || n.radius < 0.1 || !Do(this, i, this.size(n) / 2) || (t.strokeStyle = n.borderColor, t.lineWidth = n.borderWidth, t.fillStyle = n.backgroundColor, Bd(t, n, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function Rb(e, t) {
  const { x: i, y: n, base: r, width: a, height: s } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let o, l, u, c, h;
  return e.horizontal ? (h = s / 2, o = Math.min(i, r), l = Math.max(i, r), u = n - h, c = n + h) : (h = a / 2, o = i - h, l = i + h, u = Math.min(n, r), c = Math.max(n, r)), {
    left: o,
    top: u,
    right: l,
    bottom: c
  };
}
function Yn(e, t, i, n) {
  return e ? 0 : Se(t, i, n);
}
function qD(e, t, i) {
  const n = e.options.borderWidth, r = e.borderSkipped, a = ub(n);
  return {
    t: Yn(r.top, a.top, 0, i),
    r: Yn(r.right, a.right, 0, t),
    b: Yn(r.bottom, a.bottom, 0, i),
    l: Yn(r.left, a.left, 0, t)
  };
}
function ZD(e, t, i) {
  const { enableBorderRadius: n } = e.getProps([
    "enableBorderRadius"
  ]), r = e.options.borderRadius, a = Ga(r), s = Math.min(t, i), o = e.borderSkipped, l = n || vt(r);
  return {
    topLeft: Yn(!l || o.top || o.left, a.topLeft, 0, s),
    topRight: Yn(!l || o.top || o.right, a.topRight, 0, s),
    bottomLeft: Yn(!l || o.bottom || o.left, a.bottomLeft, 0, s),
    bottomRight: Yn(!l || o.bottom || o.right, a.bottomRight, 0, s)
  };
}
function KD(e) {
  const t = Rb(e), i = t.right - t.left, n = t.bottom - t.top, r = qD(e, i / 2, n / 2), a = ZD(e, i / 2, n / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: i,
      h: n,
      radius: a
    },
    inner: {
      x: t.left + r.l,
      y: t.top + r.t,
      w: i - r.l - r.r,
      h: n - r.t - r.b,
      radius: {
        topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function lh(e, t, i, n) {
  const r = t === null, a = i === null, o = e && !(r && a) && Rb(e, n);
  return o && (r || gn(t, o.left, o.right)) && (a || gn(i, o.top, o.bottom));
}
function QD(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function JD(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function uh(e, t, i = {}) {
  const n = e.x !== i.x ? -t : 0, r = e.y !== i.y ? -t : 0, a = (e.x + e.w !== i.x + i.w ? t : 0) - n, s = (e.y + e.h !== i.y + i.h ? t : 0) - r;
  return {
    x: e.x + n,
    y: e.y + r,
    w: e.w + a,
    h: e.h + s,
    radius: e.radius
  };
}
class tT extends An {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: i, options: { borderColor: n, backgroundColor: r } } = this, { inner: a, outer: s } = KD(this), o = QD(s.radius) ? xu : JD;
    t.save(), (s.w !== a.w || s.h !== a.h) && (t.beginPath(), o(t, uh(s, i, a)), t.clip(), o(t, uh(a, -i, s)), t.fillStyle = n, t.fill("evenodd")), t.beginPath(), o(t, uh(a, i)), t.fillStyle = r, t.fill(), t.restore();
  }
  inRange(t, i, n) {
    return lh(this, t, i, n);
  }
  inXRange(t, i) {
    return lh(this, t, null, i);
  }
  inYRange(t, i) {
    return lh(this, null, t, i);
  }
  getCenterPoint(t) {
    const { x: i, y: n, base: r, horizontal: a } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: a ? (i + r) / 2 : i,
      y: a ? n : (n + r) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
function eT(e, t, i) {
  const n = e.segments, r = e.points, a = t.points, s = [];
  for (const o of n) {
    let { start: l, end: u } = o;
    u = bc(l, u, r);
    const c = Hd(i, r[l], r[u], o.loop);
    if (!t.segments) {
      s.push({
        source: o,
        target: c,
        start: r[l],
        end: r[u]
      });
      continue;
    }
    const h = yb(t, c);
    for (const d of h) {
      const f = Hd(i, a[d.start], a[d.end], d.loop), v = _b(o, r, f);
      for (const p of v)
        s.push({
          source: p,
          target: d,
          start: {
            [i]: Gg(c, f, "start", Math.max)
          },
          end: {
            [i]: Gg(c, f, "end", Math.min)
          }
        });
    }
  }
  return s;
}
function Hd(e, t, i, n) {
  if (n)
    return;
  let r = t[e], a = i[e];
  return e === "angle" && (r = je(r), a = je(a)), {
    property: e,
    start: r,
    end: a
  };
}
function iT(e, t) {
  const { x: i = null, y: n = null } = e || {}, r = t.points, a = [];
  return t.segments.forEach(({ start: s, end: o }) => {
    o = bc(s, o, r);
    const l = r[s], u = r[o];
    n !== null ? (a.push({
      x: l.x,
      y: n
    }), a.push({
      x: u.x,
      y: n
    })) : i !== null && (a.push({
      x: i,
      y: l.y
    }), a.push({
      x: i,
      y: u.y
    }));
  }), a;
}
function bc(e, t, i) {
  for (; t > e; t--) {
    const n = i[t];
    if (!isNaN(n.x) && !isNaN(n.y))
      break;
  }
  return t;
}
function Gg(e, t, i, n) {
  return e && t ? n(e[i], t[i]) : e ? e[i] : t ? t[i] : 0;
}
function Nb(e, t) {
  let i = [], n = !1;
  return ae(e) ? (n = !0, i = e) : i = iT(e, t), i.length ? new yc({
    points: i,
    options: {
      tension: 0
    },
    _loop: n,
    _fullLoop: n
  }) : null;
}
function Xg(e) {
  return e && e.fill !== !1;
}
function nT(e, t, i) {
  let r = e[t].fill;
  const a = [
    t
  ];
  let s;
  if (!i)
    return r;
  for (; r !== !1 && a.indexOf(r) === -1; ) {
    if (!Ce(r))
      return r;
    if (s = e[r], !s)
      return !1;
    if (s.visible)
      return r;
    a.push(r), r = s.fill;
  }
  return !1;
}
function rT(e, t, i) {
  const n = lT(e);
  if (vt(n))
    return isNaN(n.value) ? !1 : n;
  let r = parseFloat(n);
  return Ce(r) && Math.floor(r) === r ? aT(n[0], t, r, i) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(n) >= 0 && n;
}
function aT(e, t, i, n) {
  return (e === "-" || e === "+") && (i = t + i), i === t || i < 0 || i >= n ? !1 : i;
}
function sT(e, t) {
  let i = null;
  return e === "start" ? i = t.bottom : e === "end" ? i = t.top : vt(e) ? i = t.getPixelForValue(e.value) : t.getBasePixel && (i = t.getBasePixel()), i;
}
function oT(e, t, i) {
  let n;
  return e === "start" ? n = i : e === "end" ? n = t.options.reverse ? t.min : t.max : vt(e) ? n = e.value : n = t.getBaseValue(), n;
}
function lT(e) {
  const t = e.options, i = t.fill;
  let n = ut(i && i.target, i);
  return n === void 0 && (n = !!t.backgroundColor), n === !1 || n === null ? !1 : n === !0 ? "origin" : n;
}
function uT(e) {
  const { scale: t, index: i, line: n } = e, r = [], a = n.segments, s = n.points, o = cT(t, i);
  o.push(Nb({
    x: null,
    y: t.bottom
  }, n));
  for (let l = 0; l < a.length; l++) {
    const u = a[l];
    for (let c = u.start; c <= u.end; c++)
      hT(r, s[c], o);
  }
  return new yc({
    points: r,
    options: {}
  });
}
function cT(e, t) {
  const i = [], n = e.getMatchingVisibleMetas("line");
  for (let r = 0; r < n.length; r++) {
    const a = n[r];
    if (a.index === t)
      break;
    a.hidden || i.unshift(a.dataset);
  }
  return i;
}
function hT(e, t, i) {
  const n = [];
  for (let r = 0; r < i.length; r++) {
    const a = i[r], { first: s, last: o, point: l } = dT(a, t, "x");
    if (!(!l || s && o)) {
      if (s)
        n.unshift(l);
      else if (e.push(l), !o)
        break;
    }
  }
  e.push(...n);
}
function dT(e, t, i) {
  const n = e.interpolate(t, i);
  if (!n)
    return {};
  const r = n[i], a = e.segments, s = e.points;
  let o = !1, l = !1;
  for (let u = 0; u < a.length; u++) {
    const c = a[u], h = s[c.start][i], d = s[c.end][i];
    if (gn(r, h, d)) {
      o = r === h, l = r === d;
      break;
    }
  }
  return {
    first: o,
    last: l,
    point: n
  };
}
class Fb {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, i, n) {
    const { x: r, y: a, radius: s } = this;
    return i = i || {
      start: 0,
      end: Xt
    }, t.arc(r, a, s, i.end, i.start, !0), !n.bounds;
  }
  interpolate(t) {
    const { x: i, y: n, radius: r } = this, a = t.angle;
    return {
      x: i + Math.cos(a) * r,
      y: n + Math.sin(a) * r,
      angle: a
    };
  }
}
function fT(e) {
  const { chart: t, fill: i, line: n } = e;
  if (Ce(i))
    return vT(t, i);
  if (i === "stack")
    return uT(e);
  if (i === "shape")
    return !0;
  const r = pT(e);
  return r instanceof Fb ? r : Nb(r, n);
}
function vT(e, t) {
  const i = e.getDatasetMeta(t);
  return i && e.isDatasetVisible(t) ? i.dataset : null;
}
function pT(e) {
  return (e.scale || {}).getPointPositionForValue ? mT(e) : gT(e);
}
function gT(e) {
  const { scale: t = {}, fill: i } = e, n = sT(i, t);
  if (Ce(n)) {
    const r = t.isHorizontal();
    return {
      x: r ? n : null,
      y: r ? null : n
    };
  }
  return null;
}
function mT(e) {
  const { scale: t, fill: i } = e, n = t.options, r = t.getLabels().length, a = n.reverse ? t.max : t.min, s = oT(i, t, a), o = [];
  if (n.grid.circular) {
    const l = t.getPointPositionForValue(0, a);
    return new Fb({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(s)
    });
  }
  for (let l = 0; l < r; ++l)
    o.push(t.getPointPositionForValue(l, s));
  return o;
}
function ch(e, t, i) {
  const n = fT(t), { chart: r, index: a, line: s, scale: o, axis: l } = t, u = s.options, c = u.fill, h = u.backgroundColor, { above: d = h, below: f = h } = c || {}, v = r.getDatasetMeta(a), p = bb(r, v);
  n && s.points.length && (vc(e, i), _T(e, {
    line: s,
    target: n,
    above: d,
    below: f,
    area: i,
    scale: o,
    axis: l,
    clip: p
  }), pc(e));
}
function _T(e, t) {
  const { line: i, target: n, above: r, below: a, area: s, scale: o, clip: l } = t, u = i._loop ? "angle" : t.axis;
  e.save();
  let c = a;
  a !== r && (u === "x" ? (jg(e, n, s.top), hh(e, {
    line: i,
    target: n,
    color: r,
    scale: o,
    property: u,
    clip: l
  }), e.restore(), e.save(), jg(e, n, s.bottom)) : u === "y" && (qg(e, n, s.left), hh(e, {
    line: i,
    target: n,
    color: a,
    scale: o,
    property: u,
    clip: l
  }), e.restore(), e.save(), qg(e, n, s.right), c = r)), hh(e, {
    line: i,
    target: n,
    color: c,
    scale: o,
    property: u,
    clip: l
  }), e.restore();
}
function jg(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, s = !1;
  e.beginPath();
  for (const o of n) {
    const { start: l, end: u } = o, c = r[l], h = r[bc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(c.x, i), e.lineTo(c.x, c.y)), s = !!t.pathSegment(e, o, {
      move: s
    }), s ? e.closePath() : e.lineTo(h.x, i);
  }
  e.lineTo(t.first().x, i), e.closePath(), e.clip();
}
function qg(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, s = !1;
  e.beginPath();
  for (const o of n) {
    const { start: l, end: u } = o, c = r[l], h = r[bc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(i, c.y), e.lineTo(c.x, c.y)), s = !!t.pathSegment(e, o, {
      move: s
    }), s ? e.closePath() : e.lineTo(i, h.y);
  }
  e.lineTo(i, t.first().y), e.closePath(), e.clip();
}
function hh(e, t) {
  const { line: i, target: n, property: r, color: a, scale: s, clip: o } = t, l = eT(i, n, r);
  for (const { source: u, target: c, start: h, end: d } of l) {
    const { style: { backgroundColor: f = a } = {} } = u, v = n !== !0;
    e.save(), e.fillStyle = f, yT(e, s, o, v && Hd(r, h, d)), e.beginPath();
    const p = !!i.pathSegment(e, u);
    let g;
    if (v) {
      p ? e.closePath() : Zg(e, n, d, r);
      const m = !!n.pathSegment(e, c, {
        move: p,
        reverse: !0
      });
      g = p && m, g || Zg(e, n, h, r);
    }
    e.closePath(), e.fill(g ? "evenodd" : "nonzero"), e.restore();
  }
}
function yT(e, t, i, n) {
  const r = t.chart.chartArea, { property: a, start: s, end: o } = n || {};
  if (a === "x" || a === "y") {
    let l, u, c, h;
    a === "x" ? (l = s, u = r.top, c = o, h = r.bottom) : (l = r.left, u = s, c = r.right, h = o), e.beginPath(), i && (l = Math.max(l, i.left), c = Math.min(c, i.right), u = Math.max(u, i.top), h = Math.min(h, i.bottom)), e.rect(l, u, c - l, h - u), e.clip();
  }
}
function Zg(e, t, i, n) {
  const r = t.interpolate(i, n);
  r && e.lineTo(r.x, r.y);
}
var bT = {
  id: "filler",
  afterDatasetsUpdate(e, t, i) {
    const n = (e.data.datasets || []).length, r = [];
    let a, s, o, l;
    for (s = 0; s < n; ++s)
      a = e.getDatasetMeta(s), o = a.dataset, l = null, o && o.options && o instanceof yc && (l = {
        visible: e.isDatasetVisible(s),
        index: s,
        fill: rT(o, s, n),
        chart: e,
        axis: a.controller.options.indexAxis,
        scale: a.vScale,
        line: o
      }), a.$filler = l, r.push(l);
    for (s = 0; s < n; ++s)
      l = r[s], !(!l || l.fill === !1) && (l.fill = nT(r, s, i.propagate));
  },
  beforeDraw(e, t, i) {
    const n = i.drawTime === "beforeDraw", r = e.getSortedVisibleDatasetMetas(), a = e.chartArea;
    for (let s = r.length - 1; s >= 0; --s) {
      const o = r[s].$filler;
      o && (o.line.updateControlPoints(a, o.axis), n && o.fill && ch(e.ctx, o, a));
    }
  },
  beforeDatasetsDraw(e, t, i) {
    if (i.drawTime !== "beforeDatasetsDraw")
      return;
    const n = e.getSortedVisibleDatasetMetas();
    for (let r = n.length - 1; r >= 0; --r) {
      const a = n[r].$filler;
      Xg(a) && ch(e.ctx, a, e.chartArea);
    }
  },
  beforeDatasetDraw(e, t, i) {
    const n = t.meta.$filler;
    !Xg(n) || i.drawTime !== "beforeDatasetDraw" || ch(e.ctx, n, e.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Kg = (e, t) => {
  let { boxHeight: i = t, boxWidth: n = t } = e;
  return e.usePointStyle && (i = Math.min(i, t), n = e.pointStyleWidth || Math.min(n, t)), {
    boxWidth: n,
    boxHeight: i,
    itemHeight: Math.max(t, i)
  };
}, xT = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class Qg extends An {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i, n) {
    this.maxWidth = t, this.maxHeight = i, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let i = $t(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (i = i.filter((n) => t.filter(n, this.chart.data))), t.sort && (i = i.sort((n, r) => t.sort(n, r, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: t, ctx: i } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const n = t.labels, r = Me(n.font), a = r.size, s = this._computeTitleHeight(), { boxWidth: o, itemHeight: l } = Kg(n, a);
    let u, c;
    i.font = r.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(s, a, o, l) + 10) : (c = this.maxHeight, u = this._fitCols(s, r, o, l) + 10), this.width = Math.min(u, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, i, n, r) {
    const { ctx: a, maxWidth: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [
      0
    ], c = r + o;
    let h = t;
    a.textAlign = "left", a.textBaseline = "middle";
    let d = -1, f = -c;
    return this.legendItems.forEach((v, p) => {
      const g = n + i / 2 + a.measureText(v.text).width;
      (p === 0 || u[u.length - 1] + g + 2 * o > s) && (h += c, u[u.length - (p > 0 ? 0 : 1)] = 0, f += c, d++), l[p] = {
        left: 0,
        top: f,
        row: d,
        width: g,
        height: r
      }, u[u.length - 1] += g + o;
    }), h;
  }
  _fitCols(t, i, n, r) {
    const { ctx: a, maxHeight: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = s - t;
    let h = o, d = 0, f = 0, v = 0, p = 0;
    return this.legendItems.forEach((g, m) => {
      const { itemWidth: _, itemHeight: y } = wT(n, i, a, g, r);
      m > 0 && f + y + 2 * o > c && (h += d + o, u.push({
        width: d,
        height: f
      }), v += d + o, p++, d = f = 0), l[m] = {
        left: v,
        top: f,
        col: p,
        width: _,
        height: y
      }, d = Math.max(d, _), f += y + o;
    }), h += d, u.push({
      width: d,
      height: f
    }), h;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: n, labels: { padding: r }, rtl: a } } = this, s = Xa(a, this.left, this.width);
    if (this.isHorizontal()) {
      let o = 0, l = xe(n, this.left + r, this.right - this.lineWidths[o]);
      for (const u of i)
        o !== u.row && (o = u.row, l = xe(n, this.left + r, this.right - this.lineWidths[o])), u.top += this.top + t + r, u.left = s.leftForLtr(s.x(l), u.width), l += u.width + r;
    } else {
      let o = 0, l = xe(n, this.top + t + r, this.bottom - this.columnSizes[o].height);
      for (const u of i)
        u.col !== o && (o = u.col, l = xe(n, this.top + t + r, this.bottom - this.columnSizes[o].height)), u.top = l, u.left += this.left + r, u.left = s.leftForLtr(s.x(u.left), u.width), l += u.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      vc(t, this), this._draw(), pc(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: i, lineWidths: n, ctx: r } = this, { align: a, labels: s } = t, o = ie.color, l = Xa(t.rtl, this.left, this.width), u = Me(s.font), { padding: c } = s, h = u.size, d = h / 2;
    let f;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = u.string;
    const { boxWidth: v, boxHeight: p, itemHeight: g } = Kg(s, h), m = function(S, M, k) {
      if (isNaN(v) || v <= 0 || isNaN(p) || p < 0)
        return;
      r.save();
      const T = ut(k.lineWidth, 1);
      if (r.fillStyle = ut(k.fillStyle, o), r.lineCap = ut(k.lineCap, "butt"), r.lineDashOffset = ut(k.lineDashOffset, 0), r.lineJoin = ut(k.lineJoin, "miter"), r.lineWidth = T, r.strokeStyle = ut(k.strokeStyle, o), r.setLineDash(ut(k.lineDash, [])), s.usePointStyle) {
        const C = {
          radius: p * Math.SQRT2 / 2,
          pointStyle: k.pointStyle,
          rotation: k.rotation,
          borderWidth: T
        }, D = l.xPlus(S, v / 2), P = M + d;
        lb(r, C, D, P, s.pointStyleWidth && v);
      } else {
        const C = M + Math.max((h - p) / 2, 0), D = l.leftForLtr(S, v), P = Ga(k.borderRadius);
        r.beginPath(), Object.values(P).some((O) => O !== 0) ? xu(r, {
          x: D,
          y: C,
          w: v,
          h: p,
          radius: P
        }) : r.rect(D, C, v, p), r.fill(), T !== 0 && r.stroke();
      }
      r.restore();
    }, _ = function(S, M, k) {
      To(r, k.text, S, M + g / 2, u, {
        strikethrough: k.hidden,
        textAlign: l.textAlign(k.textAlign)
      });
    }, y = this.isHorizontal(), b = this._computeTitleHeight();
    y ? f = {
      x: xe(a, this.left + c, this.right - n[0]),
      y: this.top + c + b,
      line: 0
    } : f = {
      x: this.left + c,
      y: xe(a, this.top + b + c, this.bottom - i[0].height),
      line: 0
    }, pb(this.ctx, t.textDirection);
    const w = g + c;
    this.legendItems.forEach((S, M) => {
      r.strokeStyle = S.fontColor, r.fillStyle = S.fontColor;
      const k = r.measureText(S.text).width, T = l.textAlign(S.textAlign || (S.textAlign = s.textAlign)), C = v + d + k;
      let D = f.x, P = f.y;
      l.setWidth(this.width), y ? M > 0 && D + C + c > this.right && (P = f.y += w, f.line++, D = f.x = xe(a, this.left + c, this.right - n[f.line])) : M > 0 && P + w > this.bottom && (D = f.x = D + i[f.line].width + c, f.line++, P = f.y = xe(a, this.top + b + c, this.bottom - i[f.line].height));
      const O = l.x(D);
      if (m(O, P, S), D = U2(T, D + v + d, y ? D + C : this.right, t.rtl), _(l.x(D), P, S), y)
        f.x += C + c;
      else if (typeof S.text != "string") {
        const I = u.lineHeight;
        f.y += Bb(S, I) + c;
      } else
        f.y += w;
    }), gb(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, i = t.title, n = Me(i.font), r = gi(i.padding);
    if (!i.display)
      return;
    const a = Xa(t.rtl, this.left, this.width), s = this.ctx, o = i.position, l = n.size / 2, u = r.top + l;
    let c, h = this.left, d = this.width;
    if (this.isHorizontal())
      d = Math.max(...this.lineWidths), c = this.top + u, h = xe(t.align, h, this.right - d);
    else {
      const v = this.columnSizes.reduce((p, g) => Math.max(p, g.height), 0);
      c = u + xe(t.align, this.top, this.bottom - v - t.labels.padding - this._computeTitleHeight());
    }
    const f = xe(o, h, h + d);
    s.textAlign = a.textAlign(rv(o)), s.textBaseline = "middle", s.strokeStyle = i.color, s.fillStyle = i.color, s.font = n.string, To(s, i.text, f, c, n);
  }
  _computeTitleHeight() {
    const t = this.options.title, i = Me(t.font), n = gi(t.padding);
    return t.display ? i.lineHeight + n.height : 0;
  }
  _getLegendItemAt(t, i) {
    let n, r, a;
    if (gn(t, this.left, this.right) && gn(i, this.top, this.bottom)) {
      for (a = this.legendHitBoxes, n = 0; n < a.length; ++n)
        if (r = a[n], gn(t, r.left, r.left + r.width) && gn(i, r.top, r.top + r.height))
          return this.legendItems[n];
    }
    return null;
  }
  handleEvent(t) {
    const i = this.options;
    if (!kT(t.type, i))
      return;
    const n = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const r = this._hoveredItem, a = xT(r, n);
      r && !a && $t(i.onLeave, [
        t,
        r,
        this
      ], this), this._hoveredItem = n, n && !a && $t(i.onHover, [
        t,
        n,
        this
      ], this);
    } else n && $t(i.onClick, [
      t,
      n,
      this
    ], this);
  }
}
function wT(e, t, i, n, r) {
  const a = ST(n, e, t, i), s = MT(r, n, t.lineHeight);
  return {
    itemWidth: a,
    itemHeight: s
  };
}
function ST(e, t, i, n) {
  let r = e.text;
  return r && typeof r != "string" && (r = r.reduce((a, s) => a.length > s.length ? a : s)), t + i.size / 2 + n.measureText(r).width;
}
function MT(e, t, i) {
  let n = e;
  return typeof t.text != "string" && (n = Bb(t, i)), n;
}
function Bb(e, t) {
  const i = e.text ? e.text.length : 0;
  return t * i;
}
function kT(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var vv = {
  id: "legend",
  _element: Qg,
  start(e, t, i) {
    const n = e.legend = new Qg({
      ctx: e.ctx,
      options: i,
      chart: e
    });
    fi.configure(e, n, i), fi.addBox(e, n);
  },
  stop(e) {
    fi.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, i) {
    const n = e.legend;
    fi.configure(e, n, i), n.options = i;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, i) {
      const n = t.datasetIndex, r = i.chart;
      r.isDatasetVisible(n) ? (r.hide(n), t.hidden = !0) : (r.show(n), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: i, pointStyle: n, textAlign: r, color: a, useBorderRadius: s, borderRadius: o } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const u = l.controller.getStyle(i ? 0 : void 0), c = gi(u.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: u.backgroundColor,
            fontColor: a,
            hidden: !l.visible,
            lineCap: u.borderCapStyle,
            lineDash: u.borderDash,
            lineDashOffset: u.borderDashOffset,
            lineJoin: u.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: u.borderColor,
            pointStyle: n || u.pointStyle,
            rotation: u.rotation,
            textAlign: r || u.textAlign,
            borderRadius: s && (o || u.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class $b extends An {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i) {
    const n = this.options;
    if (this.left = 0, this.top = 0, !n.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = i;
    const r = ae(n.text) ? n.text.length : 1;
    this._padding = gi(n.padding);
    const a = r * Me(n.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = a : this.width = a;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: i, left: n, bottom: r, right: a, options: s } = this, o = s.align;
    let l = 0, u, c, h;
    return this.isHorizontal() ? (c = xe(o, n, a), h = i + t, u = a - n) : (s.position === "left" ? (c = n + t, h = xe(o, r, i), l = At * -0.5) : (c = a - t, h = xe(o, i, r), l = At * 0.5), u = r - i), {
      titleX: c,
      titleY: h,
      maxWidth: u,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, i = this.options;
    if (!i.display)
      return;
    const n = Me(i.font), a = n.lineHeight / 2 + this._padding.top, { titleX: s, titleY: o, maxWidth: l, rotation: u } = this._drawArgs(a);
    To(t, i.text, 0, 0, n, {
      color: i.color,
      maxWidth: l,
      rotation: u,
      textAlign: rv(i.align),
      textBaseline: "middle",
      translation: [
        s,
        o
      ]
    });
  }
}
function DT(e, t) {
  const i = new $b({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  fi.configure(e, i, t), fi.addBox(e, i), e.titleBlock = i;
}
var zb = {
  id: "title",
  _element: $b,
  start(e, t, i) {
    DT(e, i);
  },
  stop(e) {
    const t = e.titleBlock;
    fi.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, i) {
    const n = e.titleBlock;
    fi.configure(e, n, i), n.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Zs = {
  average(e) {
    if (!e.length)
      return !1;
    let t, i, n = /* @__PURE__ */ new Set(), r = 0, a = 0;
    for (t = 0, i = e.length; t < i; ++t) {
      const o = e[t].element;
      if (o && o.hasValue()) {
        const l = o.tooltipPosition();
        n.add(l.x), r += l.y, ++a;
      }
    }
    return a === 0 || n.size === 0 ? !1 : {
      x: [
        ...n
      ].reduce((o, l) => o + l) / n.size,
      y: r / a
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let i = t.x, n = t.y, r = Number.POSITIVE_INFINITY, a, s, o;
    for (a = 0, s = e.length; a < s; ++a) {
      const l = e[a].element;
      if (l && l.hasValue()) {
        const u = l.getCenterPoint(), c = Nd(t, u);
        c < r && (r = c, o = l);
      }
    }
    if (o) {
      const l = o.tooltipPosition();
      i = l.x, n = l.y;
    }
    return {
      x: i,
      y: n
    };
  }
};
function Vi(e, t) {
  return t && (ae(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function hn(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function TT(e, t) {
  const { element: i, datasetIndex: n, index: r } = t, a = e.getDatasetMeta(n).controller, { label: s, value: o } = a.getLabelAndValue(r);
  return {
    chart: e,
    label: s,
    parsed: a.getParsed(r),
    raw: e.data.datasets[n].data[r],
    formattedValue: o,
    dataset: a.getDataset(),
    dataIndex: r,
    datasetIndex: n,
    element: i
  };
}
function Jg(e, t) {
  const i = e.chart.ctx, { body: n, footer: r, title: a } = e, { boxWidth: s, boxHeight: o } = t, l = Me(t.bodyFont), u = Me(t.titleFont), c = Me(t.footerFont), h = a.length, d = r.length, f = n.length, v = gi(t.padding);
  let p = v.height, g = 0, m = n.reduce((b, w) => b + w.before.length + w.lines.length + w.after.length, 0);
  if (m += e.beforeBody.length + e.afterBody.length, h && (p += h * u.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom), m) {
    const b = t.displayColors ? Math.max(o, l.lineHeight) : l.lineHeight;
    p += f * b + (m - f) * l.lineHeight + (m - 1) * t.bodySpacing;
  }
  d && (p += t.footerMarginTop + d * c.lineHeight + (d - 1) * t.footerSpacing);
  let _ = 0;
  const y = function(b) {
    g = Math.max(g, i.measureText(b).width + _);
  };
  return i.save(), i.font = u.string, Ct(e.title, y), i.font = l.string, Ct(e.beforeBody.concat(e.afterBody), y), _ = t.displayColors ? s + 2 + t.boxPadding : 0, Ct(n, (b) => {
    Ct(b.before, y), Ct(b.lines, y), Ct(b.after, y);
  }), _ = 0, i.font = c.string, Ct(e.footer, y), i.restore(), g += v.width, {
    width: g,
    height: p
  };
}
function CT(e, t) {
  const { y: i, height: n } = t;
  return i < n / 2 ? "top" : i > e.height - n / 2 ? "bottom" : "center";
}
function AT(e, t, i, n) {
  const { x: r, width: a } = n, s = i.caretSize + i.caretPadding;
  if (e === "left" && r + a + s > t.width || e === "right" && r - a - s < 0)
    return !0;
}
function PT(e, t, i, n) {
  const { x: r, width: a } = i, { width: s, chartArea: { left: o, right: l } } = e;
  let u = "center";
  return n === "center" ? u = r <= (o + l) / 2 ? "left" : "right" : r <= a / 2 ? u = "left" : r >= s - a / 2 && (u = "right"), AT(u, e, t, i) && (u = "center"), u;
}
function tm(e, t, i) {
  const n = i.yAlign || t.yAlign || CT(e, i);
  return {
    xAlign: i.xAlign || t.xAlign || PT(e, t, i, n),
    yAlign: n
  };
}
function ET(e, t) {
  let { x: i, width: n } = e;
  return t === "right" ? i -= n : t === "center" && (i -= n / 2), i;
}
function LT(e, t, i) {
  let { y: n, height: r } = e;
  return t === "top" ? n += i : t === "bottom" ? n -= r + i : n -= r / 2, n;
}
function em(e, t, i, n) {
  const { caretSize: r, caretPadding: a, cornerRadius: s } = e, { xAlign: o, yAlign: l } = i, u = r + a, { topLeft: c, topRight: h, bottomLeft: d, bottomRight: f } = Ga(s);
  let v = ET(t, o);
  const p = LT(t, l, u);
  return l === "center" ? o === "left" ? v += u : o === "right" && (v -= u) : o === "left" ? v -= Math.max(c, d) + r : o === "right" && (v += Math.max(h, f) + r), {
    x: Se(v, 0, n.width - t.width),
    y: Se(p, 0, n.height - t.height)
  };
}
function fl(e, t, i) {
  const n = gi(i.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - n.right : e.x + n.left;
}
function im(e) {
  return Vi([], hn(e));
}
function OT(e, t, i) {
  return la(e, {
    tooltip: t,
    tooltipItems: i,
    type: "tooltip"
  });
}
function nm(e, t) {
  const i = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return i ? e.override(i) : e;
}
const Vb = {
  beforeTitle: rn,
  title(e) {
    if (e.length > 0) {
      const t = e[0], i = t.chart.data.labels, n = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (n > 0 && t.dataIndex < n)
        return i[t.dataIndex];
    }
    return "";
  },
  afterTitle: rn,
  beforeBody: rn,
  beforeLabel: rn,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const i = e.formattedValue;
    return kt(i) || (t += i), t;
  },
  labelColor(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: rn,
  afterBody: rn,
  beforeFooter: rn,
  footer: rn,
  afterFooter: rn
};
function Ne(e, t, i, n) {
  const r = e[t].call(i, n);
  return typeof r > "u" ? Vb[t].call(i, n) : r;
}
class rm extends An {
  static positioners = Zs;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const i = this.chart, n = this.options.setContext(this.getContext()), r = n.enabled && i.options.animation && n.animations, a = new xb(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(a)), a;
  }
  getContext() {
    return this.$context || (this.$context = OT(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, i) {
    const { callbacks: n } = i, r = Ne(n, "beforeTitle", this, t), a = Ne(n, "title", this, t), s = Ne(n, "afterTitle", this, t);
    let o = [];
    return o = Vi(o, hn(r)), o = Vi(o, hn(a)), o = Vi(o, hn(s)), o;
  }
  getBeforeBody(t, i) {
    return im(Ne(i.callbacks, "beforeBody", this, t));
  }
  getBody(t, i) {
    const { callbacks: n } = i, r = [];
    return Ct(t, (a) => {
      const s = {
        before: [],
        lines: [],
        after: []
      }, o = nm(n, a);
      Vi(s.before, hn(Ne(o, "beforeLabel", this, a))), Vi(s.lines, Ne(o, "label", this, a)), Vi(s.after, hn(Ne(o, "afterLabel", this, a))), r.push(s);
    }), r;
  }
  getAfterBody(t, i) {
    return im(Ne(i.callbacks, "afterBody", this, t));
  }
  getFooter(t, i) {
    const { callbacks: n } = i, r = Ne(n, "beforeFooter", this, t), a = Ne(n, "footer", this, t), s = Ne(n, "afterFooter", this, t);
    let o = [];
    return o = Vi(o, hn(r)), o = Vi(o, hn(a)), o = Vi(o, hn(s)), o;
  }
  _createItems(t) {
    const i = this._active, n = this.chart.data, r = [], a = [], s = [];
    let o = [], l, u;
    for (l = 0, u = i.length; l < u; ++l)
      o.push(TT(this.chart, i[l]));
    return t.filter && (o = o.filter((c, h, d) => t.filter(c, h, d, n))), t.itemSort && (o = o.sort((c, h) => t.itemSort(c, h, n))), Ct(o, (c) => {
      const h = nm(t.callbacks, c);
      r.push(Ne(h, "labelColor", this, c)), a.push(Ne(h, "labelPointStyle", this, c)), s.push(Ne(h, "labelTextColor", this, c));
    }), this.labelColors = r, this.labelPointStyles = a, this.labelTextColors = s, this.dataPoints = o, o;
  }
  update(t, i) {
    const n = this.options.setContext(this.getContext()), r = this._active;
    let a, s = [];
    if (!r.length)
      this.opacity !== 0 && (a = {
        opacity: 0
      });
    else {
      const o = Zs[n.position].call(this, r, this._eventPosition);
      s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
      const l = this._size = Jg(this, n), u = Object.assign({}, o, l), c = tm(this.chart, n, u), h = em(n, u, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, a = {
        opacity: 1,
        x: h.x,
        y: h.y,
        width: l.width,
        height: l.height,
        caretX: o.x,
        caretY: o.y
      };
    }
    this._tooltipItems = s, this.$context = void 0, a && this._resolveAnimations().update(this, a), t && n.external && n.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(t, i, n, r) {
    const a = this.getCaretPosition(t, n, r);
    i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3);
  }
  getCaretPosition(t, i, n) {
    const { xAlign: r, yAlign: a } = this, { caretSize: s, cornerRadius: o } = n, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: h } = Ga(o), { x: d, y: f } = t, { width: v, height: p } = i;
    let g, m, _, y, b, w;
    return a === "center" ? (b = f + p / 2, r === "left" ? (g = d, m = g - s, y = b + s, w = b - s) : (g = d + v, m = g + s, y = b - s, w = b + s), _ = g) : (r === "left" ? m = d + Math.max(l, c) + s : r === "right" ? m = d + v - Math.max(u, h) - s : m = this.caretX, a === "top" ? (y = f, b = y - s, g = m - s, _ = m + s) : (y = f + p, b = y + s, g = m + s, _ = m - s), w = y), {
      x1: g,
      x2: m,
      x3: _,
      y1: y,
      y2: b,
      y3: w
    };
  }
  drawTitle(t, i, n) {
    const r = this.title, a = r.length;
    let s, o, l;
    if (a) {
      const u = Xa(n.rtl, this.x, this.width);
      for (t.x = fl(this, n.titleAlign, n), i.textAlign = u.textAlign(n.titleAlign), i.textBaseline = "middle", s = Me(n.titleFont), o = n.titleSpacing, i.fillStyle = n.titleColor, i.font = s.string, l = 0; l < a; ++l)
        i.fillText(r[l], u.x(t.x), t.y + s.lineHeight / 2), t.y += s.lineHeight + o, l + 1 === a && (t.y += n.titleMarginBottom - o);
    }
  }
  _drawColorBox(t, i, n, r, a) {
    const s = this.labelColors[n], o = this.labelPointStyles[n], { boxHeight: l, boxWidth: u } = a, c = Me(a.bodyFont), h = fl(this, "left", a), d = r.x(h), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, v = i.y + f;
    if (a.usePointStyle) {
      const p = {
        radius: Math.min(u, l) / 2,
        pointStyle: o.pointStyle,
        rotation: o.rotation,
        borderWidth: 1
      }, g = r.leftForLtr(d, u) + u / 2, m = v + l / 2;
      t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, Bd(t, p, g, m), t.strokeStyle = s.borderColor, t.fillStyle = s.backgroundColor, Bd(t, p, g, m);
    } else {
      t.lineWidth = vt(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, t.strokeStyle = s.borderColor, t.setLineDash(s.borderDash || []), t.lineDashOffset = s.borderDashOffset || 0;
      const p = r.leftForLtr(d, u), g = r.leftForLtr(r.xPlus(d, 1), u - 2), m = Ga(s.borderRadius);
      Object.values(m).some((_) => _ !== 0) ? (t.beginPath(), t.fillStyle = a.multiKeyBackground, xu(t, {
        x: p,
        y: v,
        w: u,
        h: l,
        radius: m
      }), t.fill(), t.stroke(), t.fillStyle = s.backgroundColor, t.beginPath(), xu(t, {
        x: g,
        y: v + 1,
        w: u - 2,
        h: l - 2,
        radius: m
      }), t.fill()) : (t.fillStyle = a.multiKeyBackground, t.fillRect(p, v, u, l), t.strokeRect(p, v, u, l), t.fillStyle = s.backgroundColor, t.fillRect(g, v + 1, u - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[n];
  }
  drawBody(t, i, n) {
    const { body: r } = this, { bodySpacing: a, bodyAlign: s, displayColors: o, boxHeight: l, boxWidth: u, boxPadding: c } = n, h = Me(n.bodyFont);
    let d = h.lineHeight, f = 0;
    const v = Xa(n.rtl, this.x, this.width), p = function(k) {
      i.fillText(k, v.x(t.x + f), t.y + d / 2), t.y += d + a;
    }, g = v.textAlign(s);
    let m, _, y, b, w, S, M;
    for (i.textAlign = s, i.textBaseline = "middle", i.font = h.string, t.x = fl(this, g, n), i.fillStyle = n.bodyColor, Ct(this.beforeBody, p), f = o && g !== "right" ? s === "center" ? u / 2 + c : u + 2 + c : 0, b = 0, S = r.length; b < S; ++b) {
      for (m = r[b], _ = this.labelTextColors[b], i.fillStyle = _, Ct(m.before, p), y = m.lines, o && y.length && (this._drawColorBox(i, t, b, v, n), d = Math.max(h.lineHeight, l)), w = 0, M = y.length; w < M; ++w)
        p(y[w]), d = h.lineHeight;
      Ct(m.after, p);
    }
    f = 0, d = h.lineHeight, Ct(this.afterBody, p), t.y -= a;
  }
  drawFooter(t, i, n) {
    const r = this.footer, a = r.length;
    let s, o;
    if (a) {
      const l = Xa(n.rtl, this.x, this.width);
      for (t.x = fl(this, n.footerAlign, n), t.y += n.footerMarginTop, i.textAlign = l.textAlign(n.footerAlign), i.textBaseline = "middle", s = Me(n.footerFont), i.fillStyle = n.footerColor, i.font = s.string, o = 0; o < a; ++o)
        i.fillText(r[o], l.x(t.x), t.y + s.lineHeight / 2), t.y += s.lineHeight + n.footerSpacing;
    }
  }
  drawBackground(t, i, n, r) {
    const { xAlign: a, yAlign: s } = this, { x: o, y: l } = t, { width: u, height: c } = n, { topLeft: h, topRight: d, bottomLeft: f, bottomRight: v } = Ga(r.cornerRadius);
    i.fillStyle = r.backgroundColor, i.strokeStyle = r.borderColor, i.lineWidth = r.borderWidth, i.beginPath(), i.moveTo(o + h, l), s === "top" && this.drawCaret(t, i, n, r), i.lineTo(o + u - d, l), i.quadraticCurveTo(o + u, l, o + u, l + d), s === "center" && a === "right" && this.drawCaret(t, i, n, r), i.lineTo(o + u, l + c - v), i.quadraticCurveTo(o + u, l + c, o + u - v, l + c), s === "bottom" && this.drawCaret(t, i, n, r), i.lineTo(o + f, l + c), i.quadraticCurveTo(o, l + c, o, l + c - f), s === "center" && a === "left" && this.drawCaret(t, i, n, r), i.lineTo(o, l + h), i.quadraticCurveTo(o, l, o + h, l), i.closePath(), i.fill(), r.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(t) {
    const i = this.chart, n = this.$animations, r = n && n.x, a = n && n.y;
    if (r || a) {
      const s = Zs[t.position].call(this, this._active, this._eventPosition);
      if (!s)
        return;
      const o = this._size = Jg(this, t), l = Object.assign({}, s, this._size), u = tm(i, t, l), c = em(t, l, u, i);
      (r._to !== c.x || a._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = o.width, this.height = o.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const i = this.options.setContext(this.getContext());
    let n = this.opacity;
    if (!n)
      return;
    this._updateAnimationTarget(i);
    const r = {
      width: this.width,
      height: this.height
    }, a = {
      x: this.x,
      y: this.y
    };
    n = Math.abs(n) < 1e-3 ? 0 : n;
    const s = gi(i.padding), o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && o && (t.save(), t.globalAlpha = n, this.drawBackground(a, t, r, i), pb(t, i.textDirection), a.y += s.top, this.drawTitle(a, t, i), this.drawBody(a, t, i), this.drawFooter(a, t, i), gb(t, i.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, i) {
    const n = this._active, r = t.map(({ datasetIndex: o, index: l }) => {
      const u = this.chart.getDatasetMeta(o);
      if (!u)
        throw new Error("Cannot find a dataset at index " + o);
      return {
        datasetIndex: o,
        element: u.data[l],
        index: l
      };
    }), a = !_u(n, r), s = this._positionChanged(r, i);
    (a || s) && (this._active = r, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, i, n = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, a = this._active || [], s = this._getActiveElements(t, a, i, n), o = this._positionChanged(s, t), l = i || !_u(s, a) || o;
    return l && (this._active = s, (r.enabled || r.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, i))), l;
  }
  _getActiveElements(t, i, n, r) {
    const a = this.options;
    if (t.type === "mouseout")
      return [];
    if (!r)
      return i.filter((o) => this.chart.data.datasets[o.datasetIndex] && this.chart.getDatasetMeta(o.datasetIndex).controller.getParsed(o.index) !== void 0);
    const s = this.chart.getElementsAtEventForMode(t, a.mode, a, n);
    return a.reverse && s.reverse(), s;
  }
  _positionChanged(t, i) {
    const { caretX: n, caretY: r, options: a } = this, s = Zs[a.position].call(this, t, i);
    return s !== !1 && (n !== s.x || r !== s.y);
  }
}
var pv = {
  id: "tooltip",
  _element: rm,
  positioners: Zs,
  afterInit(e, t, i) {
    i && (e.tooltip = new rm({
      chart: e,
      options: i
    }));
  },
  beforeUpdate(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  reset(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const i = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const i = t.replay;
      e.tooltip.handleEvent(t.event, i, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Vb
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const IT = (e, t, i, n) => (typeof t == "string" ? (i = e.push(t) - 1, n.unshift({
  index: i,
  label: t
})) : isNaN(t) && (i = null), i);
function RT(e, t, i, n) {
  const r = e.indexOf(t);
  if (r === -1)
    return IT(e, t, i, n);
  const a = e.lastIndexOf(t);
  return r !== a ? i : r;
}
const NT = (e, t) => e === null ? null : Se(Math.round(e), 0, t);
function am(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Hb extends cs {
  static id = "category";
  static defaults = {
    ticks: {
      callback: am
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const i = this._addedLabels;
    if (i.length) {
      const n = this.getLabels();
      for (const { index: r, label: a } of i)
        n[r] === a && n.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, i) {
    if (kt(t))
      return null;
    const n = this.getLabels();
    return i = isFinite(i) && n[i] === t ? i : RT(n, t, ut(i, t), this._addedLabels), NT(i, n.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: i } = this.getUserBounds();
    let { min: n, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (n = 0), i || (r = this.getLabels().length - 1)), this.min = n, this.max = r;
  }
  buildTicks() {
    const t = this.min, i = this.max, n = this.options.offset, r = [];
    let a = this.getLabels();
    a = t === 0 && i === a.length - 1 ? a : a.slice(t, i + 1), this._valueRange = Math.max(a.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
    for (let s = t; s <= i; s++)
      r.push({
        value: s
      });
    return r;
  }
  getLabelForValue(t) {
    return am.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function FT(e, t) {
  const i = [], { bounds: r, step: a, min: s, max: o, precision: l, count: u, maxTicks: c, maxDigits: h, includeBounds: d } = e, f = a || 1, v = c - 1, { min: p, max: g } = t, m = !kt(s), _ = !kt(o), y = !kt(u), b = (g - p) / (h + 1);
  let w = eg((g - p) / v / f) * f, S, M, k, T;
  if (w < 1e-14 && !m && !_)
    return [
      {
        value: p
      },
      {
        value: g
      }
    ];
  T = Math.ceil(g / w) - Math.floor(p / w), T > v && (w = eg(T * w / v / f) * f), kt(l) || (S = Math.pow(10, l), w = Math.ceil(w * S) / S), r === "ticks" ? (M = Math.floor(p / w) * w, k = Math.ceil(g / w) * w) : (M = p, k = g), m && _ && a && N2((o - s) / a, w / 1e3) ? (T = Math.round(Math.min((o - s) / w, c)), w = (o - s) / T, M = s, k = o) : y ? (M = m ? s : M, k = _ ? o : k, T = u - 1, w = (k - M) / T) : (T = (k - M) / w, oo(T, Math.round(T), w / 1e3) ? T = Math.round(T) : T = Math.ceil(T));
  const C = Math.max(ig(w), ig(M));
  S = Math.pow(10, kt(l) ? C : l), M = Math.round(M * S) / S, k = Math.round(k * S) / S;
  let D = 0;
  for (m && (d && M !== s ? (i.push({
    value: s
  }), M < s && D++, oo(Math.round((M + D * w) * S) / S, s, sm(s, b, e)) && D++) : M < s && D++); D < T; ++D) {
    const P = Math.round((M + D * w) * S) / S;
    if (_ && P > o)
      break;
    i.push({
      value: P
    });
  }
  return _ && d && k !== o ? i.length && oo(i[i.length - 1].value, o, sm(o, b, e)) ? i[i.length - 1].value = o : i.push({
    value: o
  }) : (!_ || k === o) && i.push({
    value: k
  }), i;
}
function sm(e, t, { horizontal: i, minRotation: n }) {
  const r = pn(n), a = (i ? Math.sin(r) : Math.cos(r)) || 1e-3, s = 0.75 * t * ("" + e).length;
  return Math.min(t / a, s);
}
class BT extends cs {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, i) {
    return kt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: i, maxDefined: n } = this.getUserBounds();
    let { min: r, max: a } = this;
    const s = (l) => r = i ? r : l, o = (l) => a = n ? a : l;
    if (t) {
      const l = Xi(r), u = Xi(a);
      l < 0 && u < 0 ? o(0) : l > 0 && u > 0 && s(0);
    }
    if (r === a) {
      let l = a === 0 ? 1 : Math.abs(a * 0.05);
      o(a + l), t || s(r - l);
    }
    this.min = r, this.max = a;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: i, stepSize: n } = t, r;
    return n ? (r = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), i = i || 11), i && (r = Math.min(i, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, i = t.ticks;
    let n = this.getTickLimit();
    n = Math.max(2, n);
    const r = {
      maxTicks: n,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, a = this._range || this, s = FT(r, a);
    return t.bounds === "ticks" && F2(s, this, "value"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
  }
  configure() {
    const t = this.ticks;
    let i = this.min, n = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const r = (n - i) / Math.max(t.length - 1, 1) / 2;
      i -= r, n += r;
    }
    this._startValue = i, this._endValue = n, this._valueRange = n - i;
  }
  getLabelForValue(t) {
    return sv(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Yb extends BT {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: ob.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: i } = this.getMinMax(!0);
    this.min = Ce(t) ? t : 0, this.max = Ce(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), i = t ? this.width : this.height, n = pn(this.options.ticks.minRotation), r = (t ? Math.sin(n) : Math.cos(n)) || 1e-3, a = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, a.lineHeight / r));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const xc = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, We = /* @__PURE__ */ Object.keys(xc);
function om(e, t) {
  return e - t;
}
function lm(e, t) {
  if (kt(t))
    return null;
  const i = e._adapter, { parser: n, round: r, isoWeekday: a } = e._parseOpts;
  let s = t;
  return typeof n == "function" && (s = n(s)), Ce(s) || (s = typeof n == "string" ? i.parse(s, n) : i.parse(s)), s === null ? null : (r && (s = r === "week" && (Mo(a) || a === !0) ? i.startOf(s, "isoWeek", a) : i.startOf(s, r)), +s);
}
function um(e, t, i, n) {
  const r = We.length;
  for (let a = We.indexOf(e); a < r - 1; ++a) {
    const s = xc[We[a]], o = s.steps ? s.steps : Number.MAX_SAFE_INTEGER;
    if (s.common && Math.ceil((i - t) / (o * s.size)) <= n)
      return We[a];
  }
  return We[r - 1];
}
function $T(e, t, i, n, r) {
  for (let a = We.length - 1; a >= We.indexOf(i); a--) {
    const s = We[a];
    if (xc[s].common && e._adapter.diff(r, n, s) >= t - 1)
      return s;
  }
  return We[i ? We.indexOf(i) : 0];
}
function zT(e) {
  for (let t = We.indexOf(e) + 1, i = We.length; t < i; ++t)
    if (xc[We[t]].common)
      return We[t];
}
function cm(e, t, i) {
  if (!i)
    e[t] = !0;
  else if (i.length) {
    const { lo: n, hi: r } = nv(i, t), a = i[n] >= t ? i[n] : i[r];
    e[a] = !0;
  }
}
function VT(e, t, i, n) {
  const r = e._adapter, a = +r.startOf(t[0].value, n), s = t[t.length - 1].value;
  let o, l;
  for (o = a; o <= s; o = +r.add(o, 1, n))
    l = i[o], l >= 0 && (t[l].major = !0);
  return t;
}
function hm(e, t, i) {
  const n = [], r = {}, a = t.length;
  let s, o;
  for (s = 0; s < a; ++s)
    o = t[s], r[o] = s, n.push({
      value: o,
      major: !1
    });
  return a === 0 || !i ? n : VT(e, n, r, i);
}
class dm extends cs {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, i = {}) {
    const n = t.time || (t.time = {}), r = this._adapter = new Sk._date(t.adapters.date);
    r.init(i), so(n.displayFormats, r.formats()), this._parseOpts = {
      parser: n.parser,
      round: n.round,
      isoWeekday: n.isoWeekday
    }, super.init(t), this._normalized = i.normalized;
  }
  parse(t, i) {
    return t === void 0 ? null : lm(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, i = this._adapter, n = t.time.unit || "day";
    let { min: r, max: a, minDefined: s, maxDefined: o } = this.getUserBounds();
    function l(u) {
      !s && !isNaN(u.min) && (r = Math.min(r, u.min)), !o && !isNaN(u.max) && (a = Math.max(a, u.max));
    }
    (!s || !o) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), r = Ce(r) && !isNaN(r) ? r : +i.startOf(Date.now(), n), a = Ce(a) && !isNaN(a) ? a : +i.endOf(Date.now(), n) + 1, this.min = Math.min(r, a - 1), this.max = Math.max(r + 1, a);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
    return t.length && (i = t[0], n = t[t.length - 1]), {
      min: i,
      max: n
    };
  }
  buildTicks() {
    const t = this.options, i = t.time, n = t.ticks, r = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const a = this.min, s = this.max, o = H2(r, a, s);
    return this._unit = i.unit || (n.autoSkip ? um(i.minUnit, this.min, this.max, this._getLabelCapacity(a)) : $T(this, o.length, i.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : zT(this._unit), this.initOffsets(r), t.reverse && o.reverse(), hm(this, o, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let i = 0, n = 0, r, a;
    this.options.offset && t.length && (r = this.getDecimalForValue(t[0]), t.length === 1 ? i = 1 - r : i = (this.getDecimalForValue(t[1]) - r) / 2, a = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? n = a : n = (a - this.getDecimalForValue(t[t.length - 2])) / 2);
    const s = t.length < 3 ? 0.5 : 0.25;
    i = Se(i, 0, s), n = Se(n, 0, s), this._offsets = {
      start: i,
      end: n,
      factor: 1 / (i + 1 + n)
    };
  }
  _generate() {
    const t = this._adapter, i = this.min, n = this.max, r = this.options, a = r.time, s = a.unit || um(a.minUnit, i, n, this._getLabelCapacity(i)), o = ut(r.ticks.stepSize, 1), l = s === "week" ? a.isoWeekday : !1, u = Mo(l) || l === !0, c = {};
    let h = i, d, f;
    if (u && (h = +t.startOf(h, "isoWeek", l)), h = +t.startOf(h, u ? "day" : s), t.diff(n, i, s) > 1e5 * o)
      throw new Error(i + " and " + n + " are too far apart with stepSize of " + o + " " + s);
    const v = r.ticks.source === "data" && this.getDataTimestamps();
    for (d = h, f = 0; d < n; d = +t.add(d, o, s), f++)
      cm(c, d, v);
    return (d === n || r.bounds === "ticks" || f === 1) && cm(c, d, v), Object.keys(c).sort(om).map((p) => +p);
  }
  getLabelForValue(t) {
    const i = this._adapter, n = this.options.time;
    return n.tooltipFormat ? i.format(t, n.tooltipFormat) : i.format(t, n.displayFormats.datetime);
  }
  format(t, i) {
    const r = this.options.time.displayFormats, a = this._unit, s = i || r[a];
    return this._adapter.format(t, s);
  }
  _tickFormatFunction(t, i, n, r) {
    const a = this.options, s = a.ticks.callback;
    if (s)
      return $t(s, [
        t,
        i,
        n
      ], this);
    const o = a.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && o[l], h = u && o[u], d = n[i], f = u && h && d && d.major;
    return this._adapter.format(t, r || (f ? h : c));
  }
  generateTickLabels(t) {
    let i, n, r;
    for (i = 0, n = t.length; i < n; ++i)
      r = t[i], r.label = this._tickFormatFunction(r.value, i, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const i = this._offsets, n = this.getDecimalForValue(t);
    return this.getPixelForDecimal((i.start + n) * i.factor);
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return this.min + n * (this.max - this.min);
  }
  _getLabelSize(t) {
    const i = this.options.ticks, n = this.ctx.measureText(t).width, r = pn(this.isHorizontal() ? i.maxRotation : i.minRotation), a = Math.cos(r), s = Math.sin(r), o = this._resolveTickFontOptions(0).size;
    return {
      w: n * a + o * s,
      h: n * s + o * a
    };
  }
  _getLabelCapacity(t) {
    const i = this.options.time, n = i.displayFormats, r = n[i.unit] || n.millisecond, a = this._tickFormatFunction(t, 0, hm(this, [
      t
    ], this._majorUnit), r), s = this._getLabelSize(a), o = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
    return o > 0 ? o : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], i, n;
    if (t.length)
      return t;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (i = 0, n = r.length; i < n; ++i)
      t = t.concat(r[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let i, n;
    if (t.length)
      return t;
    const r = this.getLabels();
    for (i = 0, n = r.length; i < n; ++i)
      t.push(lm(this, r[i]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return rb(t.sort(om));
  }
}
function vl(e, t, i) {
  let n = 0, r = e.length - 1, a, s, o, l;
  i ? (t >= e[n].pos && t <= e[r].pos && ({ lo: n, hi: r } = zr(e, "pos", t)), { pos: a, time: o } = e[n], { pos: s, time: l } = e[r]) : (t >= e[n].time && t <= e[r].time && ({ lo: n, hi: r } = zr(e, "time", t)), { time: a, pos: o } = e[n], { time: s, pos: l } = e[r]);
  const u = s - a;
  return u ? o + (l - o) * (t - a) / u : o;
}
class a7 extends dm {
  static id = "timeseries";
  static defaults = dm.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(t);
    this._minPos = vl(i, this.min), this._tableRange = vl(i, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: i, max: n } = this, r = [], a = [];
    let s, o, l, u, c;
    for (s = 0, o = t.length; s < o; ++s)
      u = t[s], u >= i && u <= n && r.push(u);
    if (r.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: n,
          pos: 1
        }
      ];
    for (s = 0, o = r.length; s < o; ++s)
      c = r[s + 1], l = r[s - 1], u = r[s], Math.round((c + l) / 2) !== u && a.push({
        time: u,
        pos: s / (o - 1)
      });
    return a;
  }
  _generate() {
    const t = this.min, i = this.max;
    let n = super.getDataTimestamps();
    return (!n.includes(t) || !n.length) && n.splice(0, 0, t), (!n.includes(i) || n.length === 1) && n.push(i), n.sort((r, a) => r - a);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const i = this.getDataTimestamps(), n = this.getLabelTimestamps();
    return i.length && n.length ? t = this.normalize(i.concat(n)) : t = i.length ? i : n, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (vl(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return vl(this._table, n * this._tableRange + this._minPos, !0);
  }
}
const Wb = {
  data: {
    type: Object,
    required: !0
  },
  options: {
    type: Object,
    default: () => ({})
  },
  plugins: {
    type: Array,
    default: () => []
  },
  datasetIdKey: {
    type: String,
    default: "label"
  },
  updateMode: {
    type: String,
    default: void 0
  }
}, HT = {
  ariaLabel: {
    type: String
  },
  ariaDescribedby: {
    type: String
  }
}, YT = {
  type: {
    type: String,
    required: !0
  },
  destroyDelay: {
    type: Number,
    default: 0
    // No delay by default
  },
  ...Wb,
  ...HT
}, WT = e2[0] === "2" ? (e, t) => Object.assign(e, {
  attrs: t
}) : (e, t) => Object.assign(e, t);
function ma(e) {
  return jy(e) ? Id(e) : e;
}
function UT(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
  return jy(t) ? new Proxy(e, {}) : e;
}
function GT(e, t) {
  const i = e.options;
  i && t && Object.assign(i, t);
}
function Ub(e, t) {
  e.labels = t;
}
function Gb(e, t, i) {
  const n = [];
  e.datasets = t.map((r) => {
    const a = e.datasets.find((s) => s[i] === r[i]);
    return !a || !r.data || n.includes(a) ? {
      ...r
    } : (n.push(a), Object.assign(a, r), a);
  });
}
function XT(e, t) {
  const i = {
    labels: [],
    datasets: []
  };
  return Ub(i, e.labels), Gb(i, e.datasets, t), i;
}
const jT = fe({
  props: YT,
  setup(e, t) {
    let { expose: i, slots: n } = t;
    const r = vi(null), a = Uy(null);
    i({
      chart: a
    });
    const s = () => {
      if (!r.value) return;
      const { type: u, data: c, options: h, plugins: d, datasetIdKey: f } = e, v = XT(c, f), p = UT(v, c);
      a.value = new hs(r.value, {
        type: u,
        data: p,
        options: {
          ...h
        },
        plugins: d
      });
    }, o = () => {
      const u = Id(a.value);
      u && (e.destroyDelay > 0 ? setTimeout(() => {
        u.destroy(), a.value = null;
      }, e.destroyDelay) : (u.destroy(), a.value = null));
    }, l = (u) => {
      u.update(e.updateMode);
    };
    return Qf(s), Gy(o), es([
      () => e.options,
      () => e.data
    ], (u, c) => {
      let [h, d] = u, [f, v] = c;
      const p = Id(a.value);
      if (!p)
        return;
      let g = !1;
      if (h) {
        const m = ma(h), _ = ma(f);
        m && m !== _ && (GT(p, m), g = !0);
      }
      if (d) {
        const m = ma(d.labels), _ = ma(v.labels), y = ma(d.datasets), b = ma(v.datasets);
        m !== _ && (Ub(p.config.data, m), g = !0), y && y !== b && (Gb(p.config.data, y, e.datasetIdKey), g = !0);
      }
      g && Xy(() => {
        l(p);
      });
    }, {
      deep: !0
    }), () => Od("canvas", {
      role: "img",
      "aria-label": e.ariaLabel,
      "aria-describedby": e.ariaDescribedby,
      ref: r
    }, [
      Od("p", {}, [
        n.default ? n.default() : ""
      ])
    ]);
  }
});
function gv(e, t) {
  return hs.register(t), fe({
    props: Wb,
    setup(i, n) {
      let { expose: r } = n;
      const a = Uy(null), s = (o) => {
        a.value = o?.chart;
      };
      return r({
        chart: a
      }), () => Od(jT, WT({
        ref: s
      }, {
        type: e,
        ...i
      }));
    }
  });
}
const qT = /* @__PURE__ */ gv("bar", _k), ZT = /* @__PURE__ */ gv("line", xk), KT = /* @__PURE__ */ gv("pie", wk), fm = {
  // Backgrounds
  bgPrimary: "#f8f9fa",
  bgSecondary: "#ffffff",
  bgCard: "#ffffff",
  bgCardGradientStart: "#ffffff",
  bgCardGradientEnd: "#fafafa",
  bgTable: "#ffffff",
  bgTableHeader: "#f8fafc",
  bgTableHover: "#f8fafc",
  // Text
  textPrimary: "#1e293b",
  textSecondary: "#64748b",
  textMuted: "#94a3b8",
  // Borders & Lines
  borderColor: "rgba(93, 75, 147, 0.1)",
  borderLight: "rgba(0, 0, 0, 0.05)",
  gridLines: "rgba(148, 163, 184, 0.12)",
  // Shadows
  shadowLight: "rgba(0, 0, 0, 0.05)",
  shadowMedium: "rgba(0, 0, 0, 0.08)",
  shadowHeavy: "rgba(0, 0, 0, 0.1)",
  // Charts specific
  tooltipBg: "rgba(15, 23, 42, 0.95)",
  tooltipText: "#f1f5f9",
  tooltipBorder: "rgba(148, 163, 184, 0.2)",
  // Status colors
  success: "#10b981",
  warning: "#f59e0b",
  danger: "#ef4444",
  info: "#3b82f6",
  // Brand colors
  primaryLight: "#c67dff",
  primaryDefault: "#5d4b93",
  primaryDark: "#4a3a75"
}, vm = {
  // Backgrounds
  bgPrimary: "#000000",
  bgSecondary: "#1a1a1d",
  bgCard: "#1a1a1d",
  bgCardGradientStart: "#1a1a1d",
  bgCardGradientEnd: "#0f0f11",
  bgTable: "#1a1a1d",
  bgTableHeader: "#252528",
  bgTableHover: "#252528",
  // Text
  textPrimary: "#f8f9fa",
  textSecondary: "#9ca3af",
  textMuted: "#6b7280",
  // Borders & Lines
  borderColor: "rgba(198, 125, 255, 0.15)",
  borderLight: "rgba(198, 125, 255, 0.08)",
  gridLines: "rgba(198, 125, 255, 0.12)",
  // Shadows
  shadowLight: "rgba(0, 0, 0, 0.3)",
  shadowMedium: "rgba(0, 0, 0, 0.4)",
  shadowHeavy: "rgba(0, 0, 0, 0.5)",
  // Charts specific
  tooltipBg: "rgba(26, 26, 29, 0.98)",
  tooltipText: "#f8f9fa",
  tooltipBorder: "rgba(198, 125, 255, 0.2)",
  // Status colors
  success: "#10b981",
  warning: "#f59e0b",
  danger: "#ef4444",
  info: "#3b82f6",
  // Brand colors
  primaryLight: "#c67dff",
  primaryDefault: "#5d4b93",
  primaryDark: "#4a3a75"
}, QT = [
  "#C67DFF",
  // Purple light
  "#5D4B93",
  // Purple default
  "#73D1D3",
  // Cyan
  "#1EC383",
  // Green
  "#F496A6",
  // Pink
  "#F3A332",
  // Orange
  "#7D8AFA"
  // Blue
];
function ye(e) {
  const t = vi("light");
  let i = null;
  const n = () => typeof document > "u" ? "light" : document.documentElement.classList.contains("dark") ? "dark" : "light", r = X(() => e?.value ? e.value : t.value), a = X(() => r.value === "dark"), s = X(() => a.value ? vm : fm), o = () => {
    typeof document > "u" || (t.value = n(), i = new MutationObserver((u) => {
      for (const c of u)
        c.attributeName === "class" && (t.value = n());
    }), i.observe(document.documentElement, {
      attributes: !0,
      attributeFilter: ["class"]
    }));
  }, l = () => {
    i && (i.disconnect(), i = null);
  };
  return Qf(() => {
    o();
  }), Gy(() => {
    l();
  }), e && es(e, () => {
  }), {
    isDark: a,
    currentTheme: r,
    colors: s,
    detectedTheme: t,
    // Export color constants for direct access if needed
    lightColors: fm,
    darkColors: vm,
    chartSeriesColors: QT
  };
}
const JT = { class: "chart-container" }, tC = /* @__PURE__ */ fe({
  __name: "ChartBar",
  props: {
    data: {},
    options: {},
    stacked: { type: Boolean },
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    hs.register(
      Hb,
      Yb,
      tT,
      zb,
      pv,
      vv
    );
    const { isDark: n, colors: r } = ye(_e(i, "theme")), a = i.data, s = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, o = X(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          },
          generateLabels: function(l) {
            return l.data.datasets.map((c, h) => ({
              text: s(c.label || ""),
              fillStyle: Array.isArray(c.backgroundColor) ? c.backgroundColor[0] : c.backgroundColor,
              strokeStyle: Array.isArray(c.borderColor) ? c.borderColor[0] : c.borderColor,
              lineWidth: c.borderWidth,
              hidden: !l.isDatasetVisible(h),
              index: h,
              datasetIndex: h
            }));
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(s(l[0].label)) : "";
            },
            label: function(l) {
              let u = String(s(l.dataset.label || ""));
              return u && (u += ": "), l.parsed.y !== null && (u += l.parsed.y), u;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          stacked: i.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            color: r.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              return s(l);
            }
          }
        },
        x: {
          stacked: i.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              const u = this.getLabelForValue(l);
              return s(u);
            }
          }
        }
      },
      elements: {
        bar: {
          borderRadius: 8,
          borderWidth: 0
        }
      }
    });
    return t({ isDark: n }), (l, u) => (E(), L("div", JT, [
      de(J(qT), {
        data: J(a),
        options: o.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), ne = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [n, r] of t)
    i[n] = r;
  return i;
}, Xb = /* @__PURE__ */ ne(tC, [["__scopeId", "data-v-be0a7bf2"]]), eC = { class: "chart-container" }, iC = /* @__PURE__ */ fe({
  __name: "ChartLine",
  props: {
    data: {},
    options: {},
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    hs.register(
      Hb,
      Yb,
      jD,
      yc,
      zb,
      pv,
      vv,
      bT
    );
    const { isDark: n, colors: r } = ye(_e(i, "theme")), a = i.data, s = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, o = X(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(l) {
              return l.data.datasets.map((c, h) => ({
                text: s(c.label || ""),
                fillStyle: c.backgroundColor,
                strokeStyle: c.borderColor,
                lineWidth: c.borderWidth,
                hidden: !l.isDatasetVisible(h),
                index: h,
                datasetIndex: h
              }));
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(s(l[0].label)) : "";
            },
            label: function(l) {
              let u = String(s(l.dataset.label || ""));
              return u && (u += ": "), l.parsed.y !== null && (u += l.parsed.y), u;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: r.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              return s(l);
            }
          }
        },
        x: {
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              const u = this.getLabelForValue(l);
              return s(u);
            }
          }
        }
      },
      elements: {
        line: {
          tension: 0.4,
          borderWidth: 2.5,
          borderCapStyle: "round"
        },
        point: {
          radius: 4,
          hoverRadius: 6,
          borderWidth: 2,
          backgroundColor: n.value ? "#1a1a1d" : "#ffffff",
          hoverBorderWidth: 3
        }
      }
    });
    return t({ isDark: n }), (l, u) => (E(), L("div", eC, [
      de(J(ZT), {
        data: J(a),
        options: o.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), mv = /* @__PURE__ */ ne(iC, [["__scopeId", "data-v-c400b486"]]), nC = { class: "chart-container" }, rC = /* @__PURE__ */ fe({
  __name: "PieChart",
  props: {
    data: {},
    options: {},
    doughnut: { type: Boolean },
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    hs.register(BD, pv, vv);
    const { isDark: n, colors: r } = ye(_e(i, "theme")), a = i.data, s = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, o = X(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      cutout: i.doughnut ? "60%" : 0,
      plugins: {
        legend: {
          display: !0,
          position: "bottom",
          align: "center",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 16,
            boxWidth: 14,
            boxHeight: 14,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(l) {
              const u = l.data;
              return u.labels.length && u.datasets.length ? u.labels.map((c, h) => {
                const d = l.getDatasetMeta(0), f = u.datasets[0], v = f.data[h], p = Array.isArray(f.backgroundColor) ? f.backgroundColor[h] : f.backgroundColor;
                return {
                  text: `${s(c)}: ${v}`,
                  fillStyle: p,
                  hidden: d.data[h]?.hidden || !1,
                  index: h
                };
              }) : [];
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(s(l[0].label)) : "";
            },
            label: function(l) {
              const u = l.label || "", c = l.parsed || 0, h = l.dataset.data.reduce((f, v) => f + v, 0), d = (c / h * 100).toFixed(1);
              return `${s(u)}: ${c} (${d}%)`;
            }
          }
        }
      },
      elements: {
        arc: {
          borderWidth: 2,
          borderColor: n.value ? "#1a1a1d" : "#ffffff",
          hoverOffset: 8
        }
      },
      animation: {
        animateRotate: !0,
        animateScale: !0
      }
    });
    return t({ isDark: n }), (l, u) => (E(), L("div", nC, [
      de(J(KT), {
        data: J(a),
        options: o.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), jb = /* @__PURE__ */ ne(rC, [["__scopeId", "data-v-23a84317"]]), aC = { class: "chart-container" }, sC = ["viewBox"], oC = ["transform"], lC = ["x", "width", "fill", "stroke"], uC = ["fill"], cC = ["x1", "y1", "x2", "y2", "stroke"], hC = ["points", "fill"], dC = ["x1", "y1", "x2", "y2", "stroke"], fC = ["x", "y", "fill"], vC = ["x1", "y1", "x2", "y2", "stroke"], pC = ["points", "fill"], gC = ["transform"], mC = ["y1", "y2"], _C = ["y1", "y2"], yC = ["y1", "y2"], bC = ["y1", "y2"], xC = ["y", "height"], wC = ["y1", "y2"], SC = ["y1", "y2"], MC = ["y1", "y2"], kC = ["y1", "y2"], DC = ["y", "height"], TC = ["cy", "stroke", "onMouseenter"], CC = ["cy", "stroke", "onMouseenter"], AC = ["cy", "stroke", "onMouseenter"], PC = ["cy", "stroke", "onMouseenter"], EC = ["y1", "y2", "onMouseenter"], LC = ["y1", "y2", "onMouseenter"], OC = ["x", "y", "fill"], IC = ["x", "y", "fill"], RC = ["transform"], NC = { transform: "translate(-200, 0)" }, FC = ["stroke"], BC = ["fill"], $C = { transform: "translate(-130, 0)" }, zC = ["stroke"], VC = ["fill"], HC = { transform: "translate(-60, 0)" }, YC = ["stroke"], WC = ["fill"], UC = { transform: "translate(10, 0)" }, GC = ["stroke"], XC = ["fill"], jC = { transform: "translate(80, 0)" }, qC = ["fill"], ZC = { transform: "translate(150, 0)" }, KC = ["fill"], QC = /* @__PURE__ */ fe({
  __name: "BoxplotChart",
  props: {
    boxplotData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    showLegend: { type: Boolean, default: !0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569",
      // Dots
      dotStroke: n.value ? "#1a1a1d" : "#ffffff"
    })), a = vi({
      visible: !1,
      x: 0,
      y: 0,
      text: ""
    }), s = (d) => typeof d == "string" ? d.charAt(0).toUpperCase() + d.slice(1).toLowerCase() : d, o = (d, f) => {
      const v = d.currentTarget.closest("svg");
      if (!v) return;
      const p = v.getBoundingClientRect(), g = v.createSVGPoint();
      g.x = d.clientX - p.left, g.y = d.clientY - p.top, a.value = {
        visible: !0,
        x: g.x,
        y: g.y - 20,
        text: f
      };
    }, l = (d) => {
      if (a.value.visible) {
        const f = d.currentTarget, v = f.getBoundingClientRect(), p = f.createSVGPoint();
        p.x = d.clientX - v.left, p.y = d.clientY - v.top, a.value.x = p.x, a.value.y = p.y - 20;
      }
    }, u = () => {
      a.value.visible = !1;
    }, c = () => {
      a.value.visible = !1;
    }, h = X(() => {
      const d = [], v = i.chartHeight - i.chartMargin - i.chartBottomMargin;
      for (let p = 1; p <= 10; p++) {
        const g = p, m = (g - 1) / 9, _ = i.chartMargin + v - m * v;
        d.push({ value: g, y: _ });
      }
      return d;
    });
    return t({ isDark: n }), (d, f) => (E(), L("div", aC, [
      (E(), L("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full boxplot-svg",
        style: Xr(`min-height: ${e.chartHeight}px;`),
        onMousemove: l,
        onMouseleave: u
      }, [
        a.value.visible ? (E(), L("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -(a.value.text.length * 6 + 10),
            y: -16,
            width: a.value.text.length * 12 + 20,
            height: "24",
            fill: r.value.tooltipBg,
            rx: "6",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, lC),
          x("text", {
            x: "0",
            y: "0",
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "middle"
          }, R(a.value.text), 9, uC)
        ], 8, oC)) : ht("", !0),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, cC),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, hC),
        (E(!0), L(Rt, null, ue(h.value, (v, p) => (E(), L(Rt, { key: p }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: v.y,
            x2: e.chartMargin,
            y2: v.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, dC),
          x("text", {
            x: e.chartMargin - 12,
            y: v.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, R(v.value), 9, fC)
        ], 64))), 128)),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, vC),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, pC),
        (E(!0), L(Rt, null, ue(e.boxplotData, (v, p) => (E(), L(Rt, { key: p }, [
          x("g", {
            transform: `translate(${v.centerX}, 0)`
          }, [
            v.isTotal ? (E(), L(Rt, { key: 0 }, [
              x("line", {
                x1: 0,
                y1: v.minY,
                x2: 0,
                y2: v.q1Y,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, mC),
              x("line", {
                x1: 0,
                y1: v.q3Y,
                x2: 0,
                y2: v.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, _C),
              x("line", {
                x1: -18,
                y1: v.minY,
                x2: 18,
                y2: v.minY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, yC),
              x("line", {
                x1: -18,
                y1: v.maxY,
                x2: 18,
                y2: v.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, bC),
              x("rect", {
                x: -24,
                y: v.q3Y,
                width: "48",
                height: v.q1Y - v.q3Y,
                fill: "#8b5cf6",
                "fill-opacity": "0.15",
                stroke: "#8b5cf6",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, xC)
            ], 64)) : (E(), L(Rt, { key: 1 }, [
              x("line", {
                x1: 0,
                y1: v.minY,
                x2: 0,
                y2: v.q1Y,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, wC),
              x("line", {
                x1: 0,
                y1: v.q3Y,
                x2: 0,
                y2: v.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, SC),
              x("line", {
                x1: -18,
                y1: v.minY,
                x2: 18,
                y2: v.minY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, MC),
              x("line", {
                x1: -18,
                y1: v.maxY,
                x2: 18,
                y2: v.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, kC),
              x("rect", {
                x: -24,
                y: v.q3Y,
                width: "48",
                height: v.q1Y - v.q3Y,
                fill: "#C67DFF",
                "fill-opacity": "0.15",
                stroke: "#C67DFF",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, DC)
            ], 64)),
            x("circle", {
              cx: 0,
              cy: v.minY,
              r: "6",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (g) => o(g, `Min: ${v.min.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, TC),
            x("circle", {
              cx: 0,
              cy: v.q1Y,
              r: "6",
              fill: "#a855f7",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (g) => o(g, `Q1: ${v.q1.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, CC),
            x("circle", {
              cx: 0,
              cy: v.q3Y,
              r: "6",
              fill: "#7c3aed",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (g) => o(g, `Q3: ${v.q3.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, AC),
            x("circle", {
              cx: 0,
              cy: v.maxY,
              r: "6",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (g) => o(g, `Max: ${v.max.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, PC),
            x("line", {
              x1: -24,
              y1: v.medianY,
              x2: 24,
              y2: v.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3.5",
              class: "hover-line",
              onMouseenter: (g) => o(g, `Median: ${v.median.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, EC),
            v.averageY ? (E(), L("line", {
              key: 2,
              x1: -24,
              y1: v.averageY,
              x2: 24,
              y2: v.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (g) => o(g, `Avg: ${v.average.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, LC)) : ht("", !0)
          ], 8, gC),
          x("text", {
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, R(s(v.label)), 9, OC),
          v.responseCount ? (E(), L("text", {
            key: 0,
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: r.value.tickText,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + R(v.responseCount), 9, IC)) : ht("", !0)
        ], 64))), 128)),
        e.showLegend ? (E(), L("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [
          x("g", NC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, FC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, BC)
          ]),
          x("g", $C, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#a855f7",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, zC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, VC)
          ]),
          x("g", HC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#7c3aed",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, YC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, WC)
          ]),
          x("g", UC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, GC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, XC)
          ]),
          x("g", jC, [
            f[0] || (f[0] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, qC)
          ]),
          x("g", ZC, [
            f[1] || (f[1] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, KC)
          ])
        ], 8, RC)) : ht("", !0)
      ], 44, sC))
    ]));
  }
}), JC = /* @__PURE__ */ ne(QC, [["__scopeId", "data-v-520c623f"]]), tA = { class: "chart-container" }, eA = ["viewBox"], iA = ["transform"], nA = ["x", "y", "width", "height", "fill", "stroke"], rA = ["y", "fill"], aA = ["y", "fill"], sA = ["x1", "y1", "x2", "y2", "stroke"], oA = ["points", "fill"], lA = ["x1", "y1", "x2", "y2", "stroke"], uA = ["x1", "y1", "x2", "y2", "stroke"], cA = ["x", "y", "fill"], hA = ["x", "y", "fill", "transform"], dA = ["x1", "y1", "x2", "y2", "stroke"], fA = ["points", "fill"], vA = ["transform"], pA = ["y1", "y2", "stroke", "onMouseenter"], gA = ["x", "y", "width", "height", "fill", "stroke", "onMouseenter"], mA = ["x1", "y1", "x2", "y2", "onMouseenter"], _A = ["x1", "y1", "x2", "y2", "onMouseenter"], yA = ["cy", "stroke", "onMouseenter"], bA = ["cy", "stroke", "onMouseenter"], xA = ["x", "y", "fill"], wA = ["x", "y", "fill"], SA = ["transform"], MA = { transform: "translate(-180, 0)" }, kA = ["stroke"], DA = ["fill"], TA = { transform: "translate(-120, 0)" }, CA = ["fill"], AA = { transform: "translate(-60, 0)" }, PA = ["fill"], EA = { transform: "translate(0, 0)" }, LA = ["stroke"], OA = ["fill"], IA = { transform: "translate(60, 0)" }, RA = ["fill"], NA = { transform: "translate(130, 0)" }, FA = ["fill"], BA = /* @__PURE__ */ fe({
  __name: "CandlestickChart",
  props: {
    candlestickData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    candleWidth: { default: 35 },
    showLegend: { type: Boolean, default: !0 },
    yAxisLabel: { default: "score" },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      tooltipTextSecondary: n.value ? "#d1d5db" : "#e2e8f0",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Grid
      gridLine: n.value ? "#374151" : "#e5e7eb",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569",
      // Dots
      dotStroke: n.value ? "#1a1a1d" : "#ffffff"
    })), a = vi({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), s = (d) => typeof d == "string" ? d.charAt(0).toUpperCase() + d.slice(1).toLowerCase() : d, o = (d, f, v) => {
      const p = d.currentTarget.closest("svg");
      if (!p) return;
      const g = p.getBoundingClientRect(), m = p.createSVGPoint();
      m.x = d.clientX - g.left, m.y = d.clientY - g.top;
      let _ = s(f.label), y = "";
      switch (v) {
        case "body":
          y = `Q1: ${f.q1.toFixed(1)} | Q3: ${f.q3.toFixed(1)}`;
          break;
        case "wick":
          y = `Min: ${f.low.toFixed(1)} | Max: ${f.high.toFixed(1)}`;
          break;
        case "median":
          y = `Median: ${f.median.toFixed(1)}`;
          break;
        case "average":
          y = `Average: ${f.average?.toFixed(1)}`;
          break;
        case "min":
          y = `Min: ${f.low.toFixed(1)}`;
          break;
        case "max":
          y = `Max: ${f.high.toFixed(1)}`;
          break;
      }
      const b = Math.max(180, y.length * 7 + 40), w = 48;
      a.value = {
        visible: !0,
        x: m.x,
        y: m.y - 20,
        title: _,
        text: y,
        width: b,
        height: w
      };
    }, l = (d) => {
      if (a.value.visible) {
        const f = d.currentTarget, v = f.getBoundingClientRect(), p = f.createSVGPoint();
        p.x = d.clientX - v.left, p.y = d.clientY - v.top, a.value.x = p.x, a.value.y = p.y - 20;
      }
    }, u = () => {
      a.value.visible = !1;
    }, c = () => {
      a.value.visible = !1;
    }, h = X(() => {
      const d = [], v = i.chartHeight - i.chartMargin - i.chartBottomMargin;
      for (let p = 1; p <= 10; p++) {
        const g = p, m = (g - 1) / 9, _ = i.chartMargin + v - m * v;
        d.push({ value: g, y: _ });
      }
      return d;
    });
    return t({ isDark: n }), (d, f) => (E(), L("div", tA, [
      (E(), L("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full candlestick-svg",
        style: Xr(`min-height: ${e.chartHeight}px;`),
        onMousemove: l,
        onMouseleave: u
      }, [
        a.value.visible ? (E(), L("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -a.value.width / 2,
            y: -a.value.height - 10,
            width: a.value.width,
            height: a.value.height,
            fill: r.value.tooltipBg,
            rx: "8",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, nA),
          x("text", {
            x: "0",
            y: -a.value.height + 8,
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.title), 9, rA),
          x("text", {
            x: "0",
            y: -a.value.height + 26,
            "text-anchor": "middle",
            fill: r.value.tooltipTextSecondary,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.text), 9, aA)
        ], 8, iA)) : ht("", !0),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, sA),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, oA),
        (E(!0), L(Rt, null, ue(h.value, (v, p) => (E(), L("line", {
          key: `grid-${p}`,
          x1: e.chartMargin,
          y1: v.y,
          x2: e.chartWidth - e.chartMargin,
          y2: v.y,
          stroke: r.value.gridLine,
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, lA))), 128)),
        (E(!0), L(Rt, null, ue(h.value, (v, p) => (E(), L(Rt, { key: p }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: v.y,
            x2: e.chartMargin,
            y2: v.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, uA),
          x("text", {
            x: e.chartMargin - 12,
            y: v.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, R(v.value), 9, cA)
        ], 64))), 128)),
        x("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, R(s(e.yAxisLabel)), 9, hA),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, dA),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, fA),
        (E(!0), L(Rt, null, ue(e.candlestickData, (v, p) => (E(), L(Rt, { key: p }, [
          x("g", {
            transform: `translate(${v.centerX}, 0)`
          }, [
            x("line", {
              x1: 0,
              y1: v.highY,
              x2: 0,
              y2: v.lowY,
              stroke: v.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              class: "hover-line",
              onMouseenter: (g) => o(g, v, "wick"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, pA),
            x("rect", {
              x: -e.candleWidth / 2,
              y: Math.min(v.q1Y, v.q3Y),
              width: e.candleWidth,
              height: Math.abs(v.q3Y - v.q1Y),
              fill: v.isTotal ? "rgba(139, 92, 246, 0.15)" : "rgba(198, 125, 255, 0.15)",
              stroke: v.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              rx: "4",
              class: "hover-rect",
              onMouseenter: (g) => o(g, v, "body"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, gA),
            v.medianY ? (E(), L("line", {
              key: 0,
              x1: -e.candleWidth / 2,
              y1: v.medianY,
              x2: e.candleWidth / 2,
              y2: v.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3",
              class: "hover-line",
              onMouseenter: (g) => o(g, v, "median"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, mA)) : ht("", !0),
            v.averageY ? (E(), L("line", {
              key: 1,
              x1: -e.candleWidth / 2,
              y1: v.averageY,
              x2: e.candleWidth / 2,
              y2: v.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (g) => o(g, v, "average"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, _A)) : ht("", !0),
            x("circle", {
              cx: 0,
              cy: v.lowY,
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (g) => o(g, v, "min"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, yA),
            x("circle", {
              cx: 0,
              cy: v.highY,
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (g) => o(g, v, "max"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, bA)
          ], 8, vA),
          x("text", {
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, R(s(v.label)), 9, xA),
          v.responseCount ? (E(), L("text", {
            key: 0,
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: r.value.tickText,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + R(v.responseCount), 9, wA)) : ht("", !0)
        ], 64))), 128)),
        e.showLegend ? (E(), L("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [
          x("g", MA, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, kA),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, DA)
          ]),
          x("g", TA, [
            f[0] || (f[0] = x("rect", {
              x: "-6",
              y: "-6",
              width: "12",
              height: "12",
              fill: "rgba(198, 125, 255, 0.15)",
              stroke: "#C67DFF",
              "stroke-width": "1.5",
              rx: "2"
            }, null, -1)),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, CA)
          ]),
          x("g", AA, [
            f[1] || (f[1] = x("rect", {
              x: "-6",
              y: "-6",
              width: "12",
              height: "12",
              fill: "rgba(198, 125, 255, 0.15)",
              stroke: "#C67DFF",
              "stroke-width": "1.5",
              rx: "2"
            }, null, -1)),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, PA)
          ]),
          x("g", EA, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, LA),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, OA)
          ]),
          x("g", IA, [
            f[2] || (f[2] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, RA)
          ]),
          x("g", NA, [
            f[3] || (f[3] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, FA)
          ])
        ], 8, SA)) : ht("", !0)
      ], 44, eA))
    ]));
  }
}), qb = /* @__PURE__ */ ne(BA, [["__scopeId", "data-v-0ecc8ae0"]]), $A = { class: "chart-container" }, zA = ["viewBox"], VA = ["transform"], HA = ["x", "y", "width", "height", "fill", "stroke"], YA = ["y", "fill"], WA = ["y", "fill"], UA = ["x1", "y1", "x2", "y2", "stroke"], GA = ["x1", "y1", "x2", "y2", "stroke"], XA = ["points", "fill"], jA = ["x1", "y1", "x2", "y2", "stroke"], qA = ["x", "y", "fill"], ZA = ["x", "y", "fill", "transform"], KA = ["x1", "y1", "x2", "y2", "stroke"], QA = ["points", "fill"], JA = ["x1", "y1", "x2", "y2", "stroke"], tP = ["x", "y", "fill"], eP = ["x", "y", "fill"], iP = ["d"], nP = ["x", "y", "width", "height", "onMouseenter"], rP = ["x1", "y1", "x2", "y2"], aP = ["x", "y"], sP = ["x1", "y1", "x2", "y2"], oP = ["x", "y"], lP = ["x1", "y1", "x2", "y2"], uP = ["x", "y"], cP = ["x1", "y1", "x2", "y2"], hP = ["x", "y"], dP = ["x1", "y1", "x2", "y2"], fP = ["x", "y"], vP = ["x1", "y1", "x2", "y2"], pP = ["x", "y"], gP = ["transform"], mP = { transform: "translate(-220, 0)" }, _P = ["fill"], yP = { transform: "translate(-140, 0)" }, bP = ["fill"], xP = { transform: "translate(-80, 0)" }, wP = ["fill"], SP = { transform: "translate(-20, 0)" }, MP = ["fill"], kP = { transform: "translate(60, 0)" }, DP = ["fill"], TP = { transform: "translate(130, 0)" }, CP = ["fill"], AP = { transform: "translate(180, 0)" }, PP = ["fill"], EP = /* @__PURE__ */ fe({
  __name: "HistogramChart",
  props: {
    histogram: { default: () => [] },
    minScore: { default: 0 },
    maxScore: { default: 0 },
    q1Score: { default: 0 },
    medianScore: { default: 0 },
    q3Score: { default: 0 },
    averageScore: { default: 0 },
    chartWidth: { default: 800 },
    chartHeight: { default: 450 },
    chartMargin: { default: 60 },
    chartBottomMargin: { default: 80 },
    showLegend: { type: Boolean, default: !0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      tooltipTextSecondary: n.value ? "#d1d5db" : "#e2e8f0",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Grid
      gridLine: n.value ? "#374151" : "#e5e7eb",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569"
    })), a = vi({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), s = X(() => i.chartWidth - i.chartMargin * 2), o = X(() => i.chartHeight - i.chartMargin - i.chartBottomMargin), l = X(() => s.value / 10 * 0.6), u = X(() => !i.histogram || i.histogram.length === 0 ? 1 : Math.max(...i.histogram.map((B) => B.count || 0), 1) + 30), c = X(() => {
      if (!i.histogram || i.histogram.length === 0) return 1;
      const V = i.averageScore || 0;
      let B = 0, $ = 0;
      if (i.histogram.forEach((G) => {
        const et = G.count || 0;
        B += et;
        const at = G.score - V;
        $ += et * (at * at);
      }), B === 0) return 1;
      const j = $ / B;
      return Math.sqrt(j) || 1;
    }), h = (V, B, $) => {
      if ($ === 0) return 0;
      const j = 1 / ($ * Math.sqrt(2 * Math.PI)), G = -0.5 * Math.pow((V - B) / $, 2);
      return j * Math.exp(G);
    }, d = X(() => {
      if (!i.histogram || i.histogram.length === 0 || i.averageScore === 0 && c.value === 0) return null;
      const V = i.averageScore, B = c.value, $ = [], j = 100, G = 1, et = 10, at = i.histogram.reduce((Pt, Nt) => Pt + (Nt.count || 0), 0);
      if (at === 0) return null;
      let wt = 0;
      for (let Pt = 0; Pt <= j; Pt++) {
        const Nt = G + (et - G) * (Pt / j), rt = h(Nt, V, B);
        rt > wt && (wt = rt);
      }
      const me = o.value * 0.75 / wt * at * 6e-3, Pe = i.chartMargin;
      for (let Pt = 0; Pt <= j; Pt++) {
        const Nt = G + (et - G) * (Pt / j), ft = h(Nt, V, B) * me, Ii = v(Nt);
        if (Ii !== null) {
          let le = i.chartHeight - i.chartBottomMargin - ft;
          le = Math.max(le, Pe), $.push(`${Pt === 0 ? "M" : "L"} ${Ii} ${le}`);
        }
      }
      return $.join(" ");
    }), f = X(() => {
      if (!i.histogram || i.histogram.length === 0) return [];
      const V = s.value / 10;
      return i.histogram.map((B, $) => {
        const j = i.chartMargin + ($ + 0.5) * V, G = B.count > 0 ? B.count / u.value * o.value : 0, et = i.chartHeight - i.chartBottomMargin - G;
        return {
          score: B.score,
          count: B.count,
          x: j,
          y: et,
          height: G
        };
      });
    }), v = (V) => {
      if (V < 1 || V > 10) return null;
      const B = s.value / 10;
      return i.chartMargin + (V - 0.5) * B;
    }, p = X(() => v(i.minScore)), g = X(() => v(i.maxScore)), m = X(() => v(i.q1Score)), _ = X(() => v(i.medianScore)), y = X(() => v(i.q3Score)), b = X(() => v(i.averageScore)), w = X(() => i.minScore), S = X(() => i.maxScore), M = X(() => i.q1Score), k = X(() => i.medianScore), T = X(() => i.q3Score), C = X(() => i.averageScore), D = X(() => {
      const V = [], B = i.chartMargin - 8, $ = 18;
      m.value !== null && V.push({
        x: m.value,
        y: B,
        value: i.q1Score,
        label: `Q1: ${M.value.toFixed(1)}`,
        color: "#a855f7",
        id: "q1",
        width: 55
      }), _.value !== null && V.push({
        x: _.value,
        y: B - $,
        value: i.medianScore,
        label: `Median: ${k.value.toFixed(1)}`,
        color: "#8b5cf6",
        id: "median",
        width: 90
      }), b.value !== null && V.push({
        x: b.value,
        y: B - $,
        value: i.averageScore,
        label: `Avg: ${C.value.toFixed(1)}`,
        color: "#f97316",
        id: "avg",
        width: 65
      }), y.value !== null && V.push({
        x: y.value,
        y: B,
        value: i.q3Score,
        label: `Q3: ${T.value.toFixed(1)}`,
        color: "#7c3aed",
        id: "q3",
        width: 55
      }), V.sort((et, at) => (et.x || 0) - (at.x || 0));
      const j = [[], [], []];
      V.forEach((et) => {
        if (et.x === null) return;
        let at = -1;
        for (let wt = 0; wt < j.length; wt++) {
          let Tt = !1;
          for (const me of j[wt]) {
            if (me.x === null) continue;
            const Pe = Math.abs(et.x - me.x), Pt = (et.width + me.width) / 2 + 10;
            if (Pe < Pt) {
              Tt = !0;
              break;
            }
          }
          if (!Tt) {
            at = wt;
            break;
          }
        }
        at === -1 && (at = j.length - 1), et.y = B - at * $, j[at].push(et);
      });
      const G = 15;
      return V.forEach((et) => {
        et.y < G && (et.y = G);
      }), V;
    }), P = (V) => D.value.find(($) => $.id === V)?.y || i.chartMargin - 10, O = X(() => {
      const V = [];
      for (let $ = 0; $ <= 5; $++) {
        const j = Math.round(u.value / 5 * $), G = i.chartHeight - i.chartBottomMargin - $ / 5 * o.value;
        V.push({ value: j, y: G });
      }
      return V;
    }), I = (V, B) => {
      const $ = V.currentTarget.closest("svg");
      if (!$) return;
      const j = $.getBoundingClientRect(), G = $.createSVGPoint();
      G.x = V.clientX - j.left, G.y = V.clientY - j.top;
      const et = `Score: ${B.score}`, at = `Count: ${B.count}`, wt = 120, Tt = 48;
      a.value = {
        visible: !0,
        x: G.x,
        y: G.y - 20,
        title: et,
        text: at,
        width: wt,
        height: Tt
      };
    }, N = (V) => {
      if (a.value.visible) {
        const B = V.currentTarget, $ = B.getBoundingClientRect(), j = B.createSVGPoint();
        j.x = V.clientX - $.left, j.y = V.clientY - $.top, a.value.x = j.x, a.value.y = j.y - 20;
      }
    }, F = () => {
      a.value.visible = !1;
    }, q = () => {
      a.value.visible = !1;
    };
    return t({ isDark: n }), (V, B) => (E(), L("div", $A, [
      (E(), L("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full histogram-svg",
        style: Xr(`min-height: ${e.chartHeight}px;`),
        onMousemove: N,
        onMouseleave: F
      }, [
        a.value.visible ? (E(), L("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -a.value.width / 2,
            y: -a.value.height - 10,
            width: a.value.width,
            height: a.value.height,
            fill: r.value.tooltipBg,
            rx: "8",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, HA),
          x("text", {
            x: "0",
            y: -a.value.height + 8,
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.title), 9, YA),
          x("text", {
            x: "0",
            y: -a.value.height + 26,
            "text-anchor": "middle",
            fill: r.value.tooltipTextSecondary,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.text), 9, WA)
        ], 8, VA)) : ht("", !0),
        (E(!0), L(Rt, null, ue(O.value, ($, j) => (E(), L("line", {
          key: `grid-${j}`,
          x1: e.chartMargin,
          y1: $.y,
          x2: e.chartWidth - e.chartMargin,
          y2: $.y,
          stroke: r.value.gridLine,
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, UA))), 128)),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, GA),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, XA),
        (E(!0), L(Rt, null, ue(O.value, ($, j) => (E(), L(Rt, {
          key: `y-tick-${j}`
        }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: $.y,
            x2: e.chartMargin,
            y2: $.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, jA),
          x("text", {
            x: e.chartMargin - 12,
            y: $.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, R($.value), 9, qA)
        ], 64))), 128)),
        x("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, " Count ", 8, ZA),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, KA),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, QA),
        (E(!0), L(Rt, null, ue(f.value, ($, j) => (E(), L(Rt, {
          key: `tick-${j}`
        }, [
          x("line", {
            x1: $.x,
            y1: e.chartHeight - e.chartBottomMargin,
            x2: $.x,
            y2: e.chartHeight - e.chartBottomMargin + 5,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, JA),
          x("text", {
            x: $.x,
            y: e.chartHeight - e.chartBottomMargin + 20,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, R($.score), 9, tP)
        ], 64))), 128)),
        x("text", {
          x: e.chartWidth / 2,
          y: e.chartHeight - e.chartBottomMargin + 40,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Score ", 8, eP),
        d.value ? (E(), L("path", {
          key: 1,
          d: d.value,
          fill: "none",
          stroke: "#8b5cf6",
          "stroke-width": "2.5",
          opacity: "0.7",
          class: "gaussian-curve"
        }, null, 8, iP)) : ht("", !0),
        (E(!0), L(Rt, null, ue(f.value, ($, j) => (E(), L("rect", {
          key: `bar-${j}`,
          x: $.x - l.value / 2,
          y: $.y,
          width: l.value,
          height: $.height,
          fill: "rgba(198, 125, 255, 0.6)",
          stroke: "#C67DFF",
          "stroke-width": "2",
          rx: "4",
          class: "histogram-bar",
          onMouseenter: (G) => I(G, $),
          onMouseleave: q,
          style: { cursor: "pointer" }
        }, null, 40, nP))), 128)),
        p.value ? (E(), L("line", {
          key: 2,
          x1: p.value,
          y1: e.chartMargin,
          x2: p.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#5d4b93",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, rP)) : ht("", !0),
        p.value ? (E(), L("text", {
          key: 3,
          x: p.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#5d4b93",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Min: " + R(w.value.toFixed(1)), 9, aP)) : ht("", !0),
        m.value ? (E(), L("line", {
          key: 4,
          x1: m.value,
          y1: e.chartMargin,
          x2: m.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#a855f7",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, sP)) : ht("", !0),
        m.value ? (E(), L("text", {
          key: 5,
          x: m.value,
          y: P("q1"),
          "text-anchor": "middle",
          fill: "#a855f7",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q1: " + R(M.value.toFixed(1)), 9, oP)) : ht("", !0),
        _.value ? (E(), L("line", {
          key: 6,
          x1: _.value,
          y1: e.chartMargin,
          x2: _.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#8b5cf6",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, lP)) : ht("", !0),
        _.value ? (E(), L("text", {
          key: 7,
          x: _.value,
          y: P("median"),
          "text-anchor": "middle",
          fill: "#8b5cf6",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Median: " + R(k.value.toFixed(1)), 9, uP)) : ht("", !0),
        b.value ? (E(), L("line", {
          key: 8,
          x1: b.value,
          y1: e.chartMargin,
          x2: b.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#f97316",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, cP)) : ht("", !0),
        b.value ? (E(), L("text", {
          key: 9,
          x: b.value,
          y: P("avg"),
          "text-anchor": "middle",
          fill: "#f97316",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Avg: " + R(C.value.toFixed(1)), 9, hP)) : ht("", !0),
        y.value ? (E(), L("line", {
          key: 10,
          x1: y.value,
          y1: e.chartMargin,
          x2: y.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#7c3aed",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, dP)) : ht("", !0),
        y.value ? (E(), L("text", {
          key: 11,
          x: y.value,
          y: P("q3"),
          "text-anchor": "middle",
          fill: "#7c3aed",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q3: " + R(T.value.toFixed(1)), 9, fP)) : ht("", !0),
        g.value ? (E(), L("line", {
          key: 12,
          x1: g.value,
          y1: e.chartMargin,
          x2: g.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#C67DFF",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, vP)) : ht("", !0),
        g.value ? (E(), L("text", {
          key: 13,
          x: g.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#C67DFF",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Max: " + R(S.value.toFixed(1)), 9, pP)) : ht("", !0),
        e.showLegend ? (E(), L("g", {
          key: 14,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 50})`
        }, [
          x("g", mP, [
            B[0] || (B[0] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Gaussian ", 8, _P)
          ]),
          x("g", yP, [
            B[1] || (B[1] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#5d4b93",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, bP)
          ]),
          x("g", xP, [
            B[2] || (B[2] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#a855f7",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, wP)
          ]),
          x("g", SP, [
            B[3] || (B[3] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "3",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, MP)
          ]),
          x("g", kP, [
            B[4] || (B[4] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, DP)
          ]),
          x("g", TP, [
            B[5] || (B[5] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#7c3aed",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, CP)
          ]),
          x("g", AP, [
            B[6] || (B[6] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#C67DFF",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, PP)
          ])
        ], 8, gP)) : ht("", !0)
      ], 44, zA))
    ]));
  }
}), Zb = /* @__PURE__ */ ne(EP, [["__scopeId", "data-v-e67a4773"]]);
var Yd = function(e, t) {
  return Yd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, Yd(e, t);
};
function oe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Yd(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
var LP = /* @__PURE__ */ (function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
})(), OP = /* @__PURE__ */ (function() {
  function e() {
    this.browser = new LP(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
})(), st = new OP();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (st.wxa = !0, st.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? st.worker = !0 : !st.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (st.node = !0, st.svgSupported = !0) : IP(navigator.userAgent, st);
function IP(e, t) {
  var i = t.browser, n = e.match(/Firefox\/([\d.]+)/), r = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), a = e.match(/Edge?\/([\d.]+)/), s = /micromessenger/i.test(e);
  n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1], i.newEdge = +a[1].split(".")[0] > 18), s && (i.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !i.ie && !i.edge, t.pointerEventsSupported = "onpointerdown" in window && (i.edge || i.ie && +i.version >= 11);
  var o = t.domSupported = typeof document < "u";
  if (o) {
    var l = document.documentElement.style;
    t.transform3dSupported = (i.ie && "transition" in l || i.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || i.ie && +i.version >= 9;
  }
}
var _v = 12, RP = "sans-serif", er = _v + "px " + RP, NP = 20, FP = 100, BP = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function $P(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var i = 0; i < e.length; i++) {
    var n = String.fromCharCode(i + 32), r = (e.charCodeAt(i) - NP) / FP;
    t[n] = r;
  }
  return t;
}
var zP = $P(BP), kn = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ (function() {
    var e, t;
    return function(i, n) {
      if (!e) {
        var r = kn.createCanvas();
        e = r && r.getContext("2d");
      }
      if (e)
        return t !== n && (t = e.font = n || er), e.measureText(i);
      i = i || "", n = n || er;
      var a = /((?:\d+)?\.?\d*)px/.exec(n), s = a && +a[1] || _v, o = 0;
      if (n.indexOf("mono") >= 0)
        o = s * i.length;
      else
        for (var l = 0; l < i.length; l++) {
          var u = zP[i[l]];
          o += u == null ? s : u * s;
        }
      return { width: o };
    };
  })(),
  loadImage: function(e, t, i) {
    var n = new Image();
    return n.onload = t, n.onerror = i, n.src = e, n;
  }
}, Kb = fs([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), Qb = fs([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), ds = Object.prototype.toString, wc = Array.prototype, VP = wc.forEach, HP = wc.filter, yv = wc.slice, YP = wc.map, pm = (function() {
}).constructor, pl = pm ? pm.prototype : null, bv = "__proto__", WP = 2311;
function Jb() {
  return WP++;
}
function qr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function pt(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, i = ds.call(e);
  if (i === "[object Array]") {
    if (!co(e)) {
      t = [];
      for (var n = 0, r = e.length; n < r; n++)
        t[n] = pt(e[n]);
    }
  } else if (Qb[i]) {
    if (!co(e)) {
      var a = e.constructor;
      if (a.from)
        t = a.from(e);
      else {
        t = new a(e.length);
        for (var n = 0, r = e.length; n < r; n++)
          t[n] = e[n];
      }
    }
  } else if (!Kb[i] && !co(e) && !rs(e)) {
    t = {};
    for (var s in e)
      e.hasOwnProperty(s) && s !== bv && (t[s] = pt(e[s]));
  }
  return t;
}
function se(e, t, i) {
  if (!Q(t) || !Q(e))
    return i ? pt(t) : e;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== bv) {
      var r = e[n], a = t[n];
      Q(a) && Q(r) && !Z(a) && !Z(r) && !rs(a) && !rs(r) && !gm(a) && !gm(r) && !co(a) && !co(r) ? se(r, a, i) : (i || !(n in e)) && (e[n] = pt(t[n]));
    }
  return e;
}
function Y(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var i in t)
      t.hasOwnProperty(i) && i !== bv && (e[i] = t[i]);
  return e;
}
function Jt(e, t, i) {
  for (var n = qt(t), r = 0, a = n.length; r < a; r++) {
    var s = n[r];
    e[s] == null && (e[s] = t[s]);
  }
  return e;
}
function Vt(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var i = 0, n = e.length; i < n; i++)
      if (e[i] === t)
        return i;
  }
  return -1;
}
function UP(e, t) {
  var i = e.prototype;
  function n() {
  }
  n.prototype = t.prototype, e.prototype = new n();
  for (var r in i)
    i.hasOwnProperty(r) && (e.prototype[r] = i[r]);
  e.prototype.constructor = e, e.superClass = t;
}
function Ai(e, t, i) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), r = 0; r < n.length; r++) {
      var a = n[r];
      a !== "constructor" && e[a] == null && (e[a] = t[a]);
    }
  else
    Jt(e, t);
}
function Ge(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function A(e, t, i) {
  if (e && t)
    if (e.forEach && e.forEach === VP)
      e.forEach(t, i);
    else if (e.length === +e.length)
      for (var n = 0, r = e.length; n < r; n++)
        t.call(i, e[n], n, e);
    else
      for (var a in e)
        e.hasOwnProperty(a) && t.call(i, e[a], a, e);
}
function yt(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return xv(e);
  if (e.map && e.map === YP)
    return e.map(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    n.push(t.call(i, e[r], r, e));
  return n;
}
function fs(e, t, i, n) {
  if (e && t) {
    for (var r = 0, a = e.length; r < a; r++)
      i = t.call(n, i, e[r], r, e);
    return i;
  }
}
function Ze(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return xv(e);
  if (e.filter && e.filter === HP)
    return e.filter(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    t.call(i, e[r], r, e) && n.push(e[r]);
  return n;
}
function qt(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var i in e)
    e.hasOwnProperty(i) && t.push(i);
  return t;
}
function GP(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return function() {
    return e.apply(t, i.concat(yv.call(arguments)));
  };
}
var Dt = pl && mt(pl.bind) ? pl.call.bind(pl.bind) : GP;
function Oe(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return function() {
    return e.apply(this, t.concat(yv.call(arguments)));
  };
}
function Z(e) {
  return Array.isArray ? Array.isArray(e) : ds.call(e) === "[object Array]";
}
function mt(e) {
  return typeof e == "function";
}
function tt(e) {
  return typeof e == "string";
}
function ku(e) {
  return ds.call(e) === "[object String]";
}
function Zt(e) {
  return typeof e == "number";
}
function Q(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function gm(e) {
  return !!Kb[ds.call(e)];
}
function Re(e) {
  return !!Qb[ds.call(e)];
}
function rs(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function Sc(e) {
  return e.colorStops != null;
}
function XP(e) {
  return e.image != null;
}
function jP(e) {
  return ds.call(e) === "[object RegExp]";
}
function t1(e) {
  return e !== e;
}
function ir() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var i = 0, n = e.length; i < n; i++)
    if (e[i] != null)
      return e[i];
}
function nt(e, t) {
  return e ?? t;
}
function Zr(e, t, i) {
  return e ?? t ?? i;
}
function xv(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return yv.apply(e, t);
}
function wv(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function it(e, t) {
  if (!e)
    throw new Error(t);
}
function Ui(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var e1 = "__ec_primitive__";
function Wd(e) {
  e[e1] = !0;
}
function co(e) {
  return e[e1];
}
var qP = (function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var i = this.has(t);
    return i && delete this.data[t], i;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, i) {
    return this.data[t] = i, this;
  }, e.prototype.keys = function() {
    return qt(this.data);
  }, e.prototype.forEach = function(t) {
    var i = this.data;
    for (var n in i)
      i.hasOwnProperty(n) && t(i[n], n);
  }, e;
})(), i1 = typeof Map == "function";
function ZP() {
  return i1 ? /* @__PURE__ */ new Map() : new qP();
}
var KP = (function() {
  function e(t) {
    var i = Z(t);
    this.data = ZP();
    var n = this;
    t instanceof e ? t.each(r) : t && A(t, r);
    function r(a, s) {
      i ? n.set(a, s) : n.set(s, a);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, i) {
    return this.data.set(t, i), i;
  }, e.prototype.each = function(t, i) {
    this.data.forEach(function(n, r) {
      t.call(i, n, r);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return i1 ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
})();
function ct(e) {
  return new KP(e);
}
function QP(e, t) {
  for (var i = new e.constructor(e.length + t.length), n = 0; n < e.length; n++)
    i[n] = e[n];
  for (var r = e.length, n = 0; n < t.length; n++)
    i[n + r] = t[n];
  return i;
}
function Mc(e, t) {
  var i;
  if (Object.create)
    i = Object.create(e);
  else {
    var n = function() {
    };
    n.prototype = e, i = new n();
  }
  return t && Y(i, t), i;
}
function n1(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function ji(e, t) {
  return e.hasOwnProperty(t);
}
function ke() {
}
var JP = 180 / Math.PI;
var Ud = function(e, t) {
  return Ud = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, Ud(e, t);
};
function Lt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Ud(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
function vs(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function tE(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function eE(e) {
  return [e[0], e[1]];
}
function mm(e, t, i) {
  return e[0] = t[0] + i[0], e[1] = t[1] + i[1], e;
}
function iE(e, t, i) {
  return e[0] = t[0] - i[0], e[1] = t[1] - i[1], e;
}
function nE(e) {
  return Math.sqrt(rE(e));
}
function rE(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function dh(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e;
}
function aE(e, t) {
  var i = nE(t);
  return i === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / i, e[1] = t[1] / i), e;
}
function Gd(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var sE = Gd;
function oE(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var ja = oE;
function Qe(e, t, i) {
  var n = t[0], r = t[1];
  return e[0] = i[0] * n + i[2] * r + i[4], e[1] = i[1] * n + i[3] * r + i[5], e;
}
function $a(e, t, i) {
  return e[0] = Math.min(t[0], i[0]), e[1] = Math.min(t[1], i[1]), e;
}
function za(e, t, i) {
  return e[0] = Math.max(t[0], i[0]), e[1] = Math.max(t[1], i[1]), e;
}
var _a = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.target = t, this.topTarget = i && i.topTarget;
  }
  return e;
})(), lE = (function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var i = t.target; i && !i.draggable; )
      i = i.parent || i.__hostTarget;
    i && (this._draggingTarget = i, i.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new _a(i, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var i = this._draggingTarget;
    if (i) {
      var n = t.offsetX, r = t.offsetY, a = n - this._x, s = r - this._y;
      this._x = n, this._y = r, i.drift(a, s, t), this.handler.dispatchToElement(new _a(i, t), "drag", t.event);
      var o = this.handler.findHover(n, r, i).target, l = this._dropTarget;
      this._dropTarget = o, i !== o && (l && o !== l && this.handler.dispatchToElement(new _a(l, t), "dragleave", t.event), o && o !== l && this.handler.dispatchToElement(new _a(o, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var i = this._draggingTarget;
    i && (i.dragging = !1), this.handler.dispatchToElement(new _a(i, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new _a(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
})(), Pi = (function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, i, n, r) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof i == "function" && (r = n, n = i, i = null), !n || !t)
      return this;
    var s = this._$eventProcessor;
    i != null && s && s.normalizeQuery && (i = s.normalizeQuery(i)), a[t] || (a[t] = []);
    for (var o = 0; o < a[t].length; o++)
      if (a[t][o].h === n)
        return this;
    var l = {
      h: n,
      query: i,
      ctx: r || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var i = this._$handlers;
    return !i || !i[t] || !i[t].length;
  }, e.prototype.off = function(t, i) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (i) {
      if (n[t]) {
        for (var r = [], a = 0, s = n[t].length; a < s; a++)
          n[t][a].h !== i && r.push(n[t][a]);
        n[t] = r;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var s = i.length, o = r.length, l = 0; l < o; l++) {
        var u = r[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (s) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, i[0]);
              break;
            case 2:
              u.h.call(u.ctx, i[0], i[1]);
              break;
            default:
              u.h.apply(u.ctx, i);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var s = i.length, o = i[s - 1], l = r.length, u = 0; u < l; u++) {
        var c = r[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (s) {
            case 0:
              c.h.call(o);
              break;
            case 1:
              c.h.call(o, i[0]);
              break;
            case 2:
              c.h.call(o, i[0], i[1]);
              break;
            default:
              c.h.apply(o, i.slice(1, s - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e;
})(), uE = Math.log(2);
function Xd(e, t, i, n, r, a) {
  var s = n + "-" + r, o = e.length;
  if (a.hasOwnProperty(s))
    return a[s];
  if (t === 1) {
    var l = Math.round(Math.log((1 << o) - 1 & ~r) / uE);
    return e[i][l];
  }
  for (var u = n | 1 << i, c = i + 1; n & 1 << c; )
    c++;
  for (var h = 0, d = 0, f = 0; d < o; d++) {
    var v = 1 << d;
    v & r || (h += (f % 2 ? -1 : 1) * e[i][d] * Xd(e, t - 1, c, u, r | v, a), f++);
  }
  return a[s] = h, h;
}
function _m(e, t) {
  var i = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], n = {}, r = Xd(i, 8, 0, 0, 0, n);
  if (r !== 0) {
    for (var a = [], s = 0; s < 8; s++)
      for (var o = 0; o < 8; o++)
        a[o] == null && (a[o] = 0), a[o] += ((s + o) % 2 ? -1 : 1) * Xd(i, 7, s === 0 ? 1 : 0, 1 << s, 1 << o, n) / r * t[s];
    return function(l, u, c) {
      var h = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
    };
  }
}
var Du = "___zrEVENTSAVED", fh = [];
function cE(e, t, i, n, r) {
  return jd(fh, t, n, r, !0) && jd(e, i, fh[0], fh[1]);
}
function hE(e, t) {
  e && i(e), t && i(t);
  function i(n) {
    var r = n[Du];
    r && (r.clearMarkers && r.clearMarkers(), delete n[Du]);
  }
}
function jd(e, t, i, n, r) {
  if (t.getBoundingClientRect && st.domSupported && !r1(t)) {
    var a = t[Du] || (t[Du] = {}), s = dE(t, a), o = fE(s, a, r);
    if (o)
      return o(e, i, n), !0;
  }
  return !1;
}
function dE(e, t) {
  var i = t.markers;
  if (i)
    return i;
  i = t.markers = [];
  for (var n = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
    var s = document.createElement("div"), o = s.style, l = a % 2, u = (a >> 1) % 2;
    o.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      r[u] + ":0",
      n[1 - l] + ":auto",
      r[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(s), i.push(s);
  }
  return t.clearMarkers = function() {
    A(i, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, i;
}
function fE(e, t, i) {
  for (var n = i ? "invTrans" : "trans", r = t[n], a = t.srcCoords, s = [], o = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), h = 2 * u, d = c.left, f = c.top;
    s.push(d, f), l = l && a && d === a[h] && f === a[h + 1], o.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && r ? r : (t.srcCoords = s, t[n] = i ? _m(o, s) : _m(s, o));
}
function r1(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var vE = /([&<>"'])/g, pE = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function ze(e) {
  return e == null ? "" : (e + "").replace(vE, function(t, i) {
    return pE[i];
  });
}
var gE = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, vh = [], mE = st.browser.firefox && +st.browser.version.split(".")[0] < 39;
function qd(e, t, i, n) {
  return i = i || {}, n ? ym(e, t, i) : mE && t.layerX != null && t.layerX !== t.offsetX ? (i.zrX = t.layerX, i.zrY = t.layerY) : t.offsetX != null ? (i.zrX = t.offsetX, i.zrY = t.offsetY) : ym(e, t, i), i;
}
function ym(e, t, i) {
  if (st.domSupported && e.getBoundingClientRect) {
    var n = t.clientX, r = t.clientY;
    if (r1(e)) {
      var a = e.getBoundingClientRect();
      i.zrX = n - a.left, i.zrY = r - a.top;
      return;
    } else if (jd(vh, e, n, r)) {
      i.zrX = vh[0], i.zrY = vh[1];
      return;
    }
  }
  i.zrX = i.zrY = 0;
}
function Sv(e) {
  return e || window.event;
}
function ai(e, t, i) {
  if (t = Sv(t), t.zrX != null)
    return t;
  var n = t.type, r = n && n.indexOf("touch") >= 0;
  if (r) {
    var s = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    s && qd(e, s, t, i);
  } else {
    qd(e, t, t, i);
    var a = _E(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var o = t.button;
  return t.which == null && o !== void 0 && gE.test(t.type) && (t.which = o & 1 ? 1 : o & 2 ? 3 : o & 4 ? 2 : 0), t;
}
function _E(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var i = e.deltaX, n = e.deltaY;
  if (i == null || n == null)
    return t;
  var r = Math.abs(n !== 0 ? n : i), a = n > 0 ? -1 : n < 0 ? 1 : i > 0 ? -1 : 1;
  return 3 * r * a;
}
function yE(e, t, i, n) {
  e.addEventListener(t, i, n);
}
function bE(e, t, i, n) {
  e.removeEventListener(t, i, n);
}
var Tu = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function bm(e) {
  return e.which === 2 || e.which === 3;
}
var xE = (function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, i, n) {
    return this._doTrack(t, i, n), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, i, n) {
    var r = t.touches;
    if (r) {
      for (var a = {
        points: [],
        touches: [],
        target: i,
        event: t
      }, s = 0, o = r.length; s < o; s++) {
        var l = r[s], u = qd(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, e.prototype._recognize = function(t) {
    for (var i in ph)
      if (ph.hasOwnProperty(i)) {
        var n = ph[i](this._track, t);
        if (n)
          return n;
      }
  }, e;
})();
function xm(e) {
  var t = e[1][0] - e[0][0], i = e[1][1] - e[0][1];
  return Math.sqrt(t * t + i * i);
}
function wE(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var ph = {
  pinch: function(e, t) {
    var i = e.length;
    if (i) {
      var n = (e[i - 1] || {}).points, r = (e[i - 2] || {}).points || n;
      if (r && r.length > 1 && n && n.length > 1) {
        var a = xm(n) / xm(r);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var s = wE(n);
        return t.pinchX = s[0], t.pinchY = s[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function qi() {
  return [1, 0, 0, 1, 0, 0];
}
function Mv(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function kv(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function ho(e, t, i) {
  var n = t[0] * i[0] + t[2] * i[1], r = t[1] * i[0] + t[3] * i[1], a = t[0] * i[2] + t[2] * i[3], s = t[1] * i[2] + t[3] * i[3], o = t[0] * i[4] + t[2] * i[5] + t[4], l = t[1] * i[4] + t[3] * i[5] + t[5];
  return e[0] = n, e[1] = r, e[2] = a, e[3] = s, e[4] = o, e[5] = l, e;
}
function Zd(e, t, i) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + i[0], e[5] = t[5] + i[1], e;
}
function Dv(e, t, i, n) {
  n === void 0 && (n = [0, 0]);
  var r = t[0], a = t[2], s = t[4], o = t[1], l = t[3], u = t[5], c = Math.sin(i), h = Math.cos(i);
  return e[0] = r * h + o * c, e[1] = -r * c + o * h, e[2] = a * h + l * c, e[3] = -a * c + h * l, e[4] = h * (s - n[0]) + c * (u - n[1]) + n[0], e[5] = h * (u - n[1]) - c * (s - n[0]) + n[1], e;
}
function SE(e, t, i) {
  var n = i[0], r = i[1];
  return e[0] = t[0] * n, e[1] = t[1] * r, e[2] = t[2] * n, e[3] = t[3] * r, e[4] = t[4] * n, e[5] = t[5] * r, e;
}
function Xo(e, t) {
  var i = t[0], n = t[2], r = t[4], a = t[1], s = t[3], o = t[5], l = i * s - a * n;
  return l ? (l = 1 / l, e[0] = s * l, e[1] = -a * l, e[2] = -n * l, e[3] = i * l, e[4] = (n * o - s * r) * l, e[5] = (a * r - i * o) * l, e) : null;
}
var It = (function() {
  function e(t, i) {
    this.x = t || 0, this.y = i || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, i) {
    return this.x = t, this.y = i, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, i) {
    this.x += t.x * i, this.y += t.y * i;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(i * i + n * n);
  }, e.prototype.distanceSquare = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return i * i + n * n;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var i = this.x, n = this.y;
      return this.x = t[0] * i + t[2] * n + t[4], this.y = t[1] * i + t[3] * n + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, i, n) {
    t.x = i, t.y = n;
  }, e.copy = function(t, i) {
    t.x = i.x, t.y = i.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, i) {
    return t.x * i.x + t.y * i.y;
  }, e.add = function(t, i, n) {
    t.x = i.x + n.x, t.y = i.y + n.y;
  }, e.sub = function(t, i, n) {
    t.x = i.x - n.x, t.y = i.y - n.y;
  }, e.scale = function(t, i, n) {
    t.x = i.x * n, t.y = i.y * n;
  }, e.scaleAndAdd = function(t, i, n, r) {
    t.x = i.x + n.x * r, t.y = i.y + n.y * r;
  }, e.lerp = function(t, i, n, r) {
    var a = 1 - r;
    t.x = a * i.x + r * n.x, t.y = a * i.y + r * n.y;
  }, e;
})(), Vr = Math.min, Va = Math.max, Kd = Math.abs, wm = ["x", "y"], ME = ["width", "height"], cr = new It(), hr = new It(), dr = new It(), fr = new It(), qe = a1(), Ks = qe.minTv, Qd = qe.maxTv, fo = [0, 0], ot = (function() {
  function e(t, i, n, r) {
    e.set(this, t, i, n, r);
  }
  return e.set = function(t, i, n, r, a) {
    return r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), t.x = i, t.y = n, t.width = r, t.height = a, t;
  }, e.prototype.union = function(t) {
    var i = Vr(t.x, this.x), n = Vr(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Va(t.x + t.width, this.x + this.width) - i : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Va(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = i, this.y = n;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var i = this, n = t.width / i.width, r = t.height / i.height, a = qi();
    return Zd(a, a, [-i.x, -i.y]), SE(a, a, [n, r]), Zd(a, a, [t.x, t.y]), a;
  }, e.prototype.intersect = function(t, i, n) {
    return e.intersect(this, t, i, n);
  }, e.intersect = function(t, i, n, r) {
    n && It.set(n, 0, 0);
    var a = r && r.outIntersectRect || null, s = r && r.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !i)
      return !1;
    t instanceof e || (t = e.set(kE, t.x, t.y, t.width, t.height)), i instanceof e || (i = e.set(DE, i.x, i.y, i.width, i.height));
    var o = !!n;
    qe.reset(r, o);
    var l = qe.touchThreshold, u = t.x + l, c = t.x + t.width - l, h = t.y + l, d = t.y + t.height - l, f = i.x + l, v = i.x + i.width - l, p = i.y + l, g = i.y + i.height - l;
    if (u > c || h > d || f > v || p > g)
      return !1;
    var m = !(c < f || v < u || d < p || g < h);
    return (o || a) && (fo[0] = 1 / 0, fo[1] = 0, Sm(u, c, f, v, 0, o, a, s), Sm(h, d, p, g, 1, o, a, s), o && It.copy(n, m ? qe.useDir ? qe.dirMinTv : Ks : Qd)), m;
  }, e.contain = function(t, i, n) {
    return i >= t.x && i <= t.x + t.width && n >= t.y && n <= t.y + t.height;
  }, e.prototype.contain = function(t, i) {
    return e.contain(this, t, i);
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, i) {
    return t.x = i.x, t.y = i.y, t.width = i.width, t.height = i.height, t;
  }, e.applyTransform = function(t, i, n) {
    if (!n) {
      t !== i && e.copy(t, i);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var r = n[0], a = n[3], s = n[4], o = n[5];
      t.x = i.x * r + s, t.y = i.y * a + o, t.width = i.width * r, t.height = i.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    cr.x = dr.x = i.x, cr.y = fr.y = i.y, hr.x = fr.x = i.x + i.width, hr.y = dr.y = i.y + i.height, cr.transform(n), fr.transform(n), hr.transform(n), dr.transform(n), t.x = Vr(cr.x, hr.x, dr.x, fr.x), t.y = Vr(cr.y, hr.y, dr.y, fr.y);
    var l = Va(cr.x, hr.x, dr.x, fr.x), u = Va(cr.y, hr.y, dr.y, fr.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
})(), kE = new ot(0, 0, 0, 0), DE = new ot(0, 0, 0, 0);
function Sm(e, t, i, n, r, a, s, o) {
  var l = Kd(t - i), u = Kd(n - e), c = Vr(l, u), h = wm[r], d = wm[1 - r], f = ME[r];
  t < i || n < e ? l < u ? (a && (Qd[h] = -l), o && (s[h] = t, s[f] = 0)) : (a && (Qd[h] = u), o && (s[h] = e, s[f] = 0)) : (s && (s[h] = Va(e, i), s[f] = Vr(t, n) - s[h]), a && (c < fo[0] || qe.useDir) && (fo[0] = Vr(c, fo[0]), (l < u || !qe.bidirectional) && (Ks[h] = l, Ks[d] = 0, qe.useDir && qe.calcDirMTV()), (l >= u || !qe.bidirectional) && (Ks[h] = -u, Ks[d] = 0, qe.useDir && qe.calcDirMTV())));
}
function a1() {
  var e = 0, t = new It(), i = new It(), n = {
    minTv: new It(),
    maxTv: new It(),
    useDir: !1,
    dirMinTv: new It(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, s) {
      n.touchThreshold = 0, a && a.touchThreshold != null && (n.touchThreshold = Va(0, a.touchThreshold)), n.negativeSize = !1, s && (n.minTv.set(1 / 0, 1 / 0), n.maxTv.set(0, 0), n.useDir = !1, a && a.direction != null && (n.useDir = !0, n.dirMinTv.copy(n.minTv), i.copy(n.minTv), e = a.direction, n.bidirectional = a.bidirectional == null || !!a.bidirectional, n.bidirectional || t.set(Math.cos(e), Math.sin(e))));
    },
    calcDirMTV: function() {
      var a = n.minTv, s = n.dirMinTv, o = a.y * a.y + a.x * a.x, l = Math.sin(e), u = Math.cos(e), c = l * a.y + u * a.x;
      if (r(c)) {
        r(a.x) && r(a.y) && s.set(0, 0);
        return;
      }
      if (i.x = o * u / c, i.y = o * l / c, r(i.x) && r(i.y)) {
        s.set(0, 0);
        return;
      }
      (n.bidirectional || t.dot(i) > 0) && i.len() < s.len() && s.copy(i);
    }
  };
  function r(a) {
    return Kd(a) < 1e-10;
  }
  return n;
}
var s1 = "silent";
function TE(e, t, i) {
  return {
    type: e,
    event: i,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: i.zrX,
    offsetY: i.zrY,
    gestureEvent: i.gestureEvent,
    pinchX: i.pinchX,
    pinchY: i.pinchY,
    pinchScale: i.pinchScale,
    wheelDelta: i.zrDelta,
    zrByTouch: i.zrByTouch,
    which: i.which,
    stop: CE
  };
}
function CE() {
  Tu(this.event);
}
var AE = (function(e) {
  Lt(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.handler = null, i;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
})(Pi), Ms = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.x = t, this.y = i;
  }
  return e;
})(), PE = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], gh = new ot(0, 0, 0, 0), o1 = (function(e) {
  Lt(t, e);
  function t(i, n, r, a, s) {
    var o = e.call(this) || this;
    return o._hovered = new Ms(0, 0), o.storage = i, o.painter = n, o.painterRoot = a, o._pointerSize = s, r = r || new AE(), o.proxy = null, o.setHandlerProxy(r), o._draggingMgr = new lE(o), o;
  }
  return t.prototype.setHandlerProxy = function(i) {
    this.proxy && this.proxy.dispose(), i && (A(PE, function(n) {
      i.on && i.on(n, this[n], this);
    }, this), i.handler = this), this.proxy = i;
  }, t.prototype.mousemove = function(i) {
    var n = i.zrX, r = i.zrY, a = l1(this, n, r), s = this._hovered, o = s.target;
    o && !o.__zr && (s = this.findHover(s.x, s.y), o = s.target);
    var l = this._hovered = a ? new Ms(n, r) : this.findHover(n, r), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), o && u !== o && this.dispatchToElement(s, "mouseout", i), this.dispatchToElement(l, "mousemove", i), u && u !== o && this.dispatchToElement(l, "mouseover", i);
  }, t.prototype.mouseout = function(i) {
    var n = i.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", i), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: i });
  }, t.prototype.resize = function() {
    this._hovered = new Ms(0, 0);
  }, t.prototype.dispatch = function(i, n) {
    var r = this[i];
    r && r.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(i) {
    var n = this.proxy;
    n.setCursor && n.setCursor(i);
  }, t.prototype.dispatchToElement = function(i, n, r) {
    i = i || {};
    var a = i.target;
    if (!(a && a.silent)) {
      for (var s = "on" + n, o = TE(n, i, r); a && (a[s] && (o.cancelBubble = !!a[s].call(a, o)), a.trigger(n, o), a = a.__hostTarget ? a.__hostTarget : a.parent, !o.cancelBubble); )
        ;
      o.cancelBubble || (this.trigger(n, o), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[s] == "function" && l[s].call(l, o), l.trigger && l.trigger(n, o);
      }));
    }
  }, t.prototype.findHover = function(i, n, r) {
    var a = this.storage.getDisplayList(), s = new Ms(i, n);
    if (Mm(a, s, i, n, r), this._pointerSize && !s.target) {
      for (var o = [], l = this._pointerSize, u = l / 2, c = new ot(i - u, n - u, l, l), h = a.length - 1; h >= 0; h--) {
        var d = a[h];
        d !== r && !d.ignore && !d.ignoreCoarsePointer && (!d.parent || !d.parent.ignoreCoarsePointer) && (gh.copy(d.getBoundingRect()), d.transform && gh.applyTransform(d.transform), gh.intersect(c) && o.push(d));
      }
      if (o.length)
        for (var f = 4, v = Math.PI / 12, p = Math.PI * 2, g = 0; g < u; g += f)
          for (var m = 0; m < p; m += v) {
            var _ = i + g * Math.cos(m), y = n + g * Math.sin(m);
            if (Mm(o, s, _, y, r), s.target)
              return s;
          }
    }
    return s;
  }, t.prototype.processGesture = function(i, n) {
    this._gestureMgr || (this._gestureMgr = new xE());
    var r = this._gestureMgr;
    n === "start" && r.clear();
    var a = r.recognize(i, this.findHover(i.zrX, i.zrY, null).target, this.proxy.dom);
    if (n === "end" && r.clear(), a) {
      var s = a.type;
      i.gestureEvent = s;
      var o = new Ms();
      o.target = a.target, this.dispatchToElement(o, s, a.event);
    }
  }, t;
})(Pi);
A(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  o1.prototype[e] = function(t) {
    var i = t.zrX, n = t.zrY, r = l1(this, i, n), a, s;
    if ((e !== "mouseup" || !r) && (a = this.findHover(i, n), s = a.target), e === "mousedown")
      this._downEl = s, this._downPoint = [t.zrX, t.zrY], this._upEl = s;
    else if (e === "mouseup")
      this._upEl = s;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || sE(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, e, t);
  };
});
function EE(e, t, i) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, i)) {
    for (var n = e, r = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var s = n.getClipPath();
        if (s && !s.contain(t, i))
          return !1;
      }
      n.silent && (r = !0);
      var o = n.__hostTarget;
      n = o ? n.ignoreHostSilent ? null : o : n.parent;
    }
    return r ? s1 : !0;
  }
  return !1;
}
function Mm(e, t, i, n, r) {
  for (var a = e.length - 1; a >= 0; a--) {
    var s = e[a], o = void 0;
    if (s !== r && !s.ignore && (o = EE(s, i, n)) && (!t.topTarget && (t.topTarget = s), o !== s1)) {
      t.target = s;
      break;
    }
  }
}
function l1(e, t, i) {
  var n = e.painter;
  return t < 0 || t > n.getWidth() || i < 0 || i > n.getHeight();
}
var u1 = 32, ks = 7;
function LE(e) {
  for (var t = 0; e >= u1; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function km(e, t, i, n) {
  var r = t + 1;
  if (r === i)
    return 1;
  if (n(e[r++], e[t]) < 0) {
    for (; r < i && n(e[r], e[r - 1]) < 0; )
      r++;
    OE(e, t, r);
  } else
    for (; r < i && n(e[r], e[r - 1]) >= 0; )
      r++;
  return r - t;
}
function OE(e, t, i) {
  for (i--; t < i; ) {
    var n = e[t];
    e[t++] = e[i], e[i--] = n;
  }
}
function Dm(e, t, i, n, r) {
  for (n === t && n++; n < i; n++) {
    for (var a = e[n], s = t, o = n, l; s < o; )
      l = s + o >>> 1, r(a, e[l]) < 0 ? o = l : s = l + 1;
    var u = n - s;
    switch (u) {
      case 3:
        e[s + 3] = e[s + 2];
      case 2:
        e[s + 2] = e[s + 1];
      case 1:
        e[s + 1] = e[s];
        break;
      default:
        for (; u > 0; )
          e[s + u] = e[s + u - 1], u--;
    }
    e[s] = a;
  }
}
function mh(e, t, i, n, r, a) {
  var s = 0, o = 0, l = 1;
  if (a(e, t[i + r]) > 0) {
    for (o = n - r; l < o && a(e, t[i + r + l]) > 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o), s += r, l += r;
  } else {
    for (o = r + 1; l < o && a(e, t[i + r - l]) <= 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o);
    var u = s;
    s = r - l, l = r - u;
  }
  for (s++; s < l; ) {
    var c = s + (l - s >>> 1);
    a(e, t[i + c]) > 0 ? s = c + 1 : l = c;
  }
  return l;
}
function _h(e, t, i, n, r, a) {
  var s = 0, o = 0, l = 1;
  if (a(e, t[i + r]) < 0) {
    for (o = r + 1; l < o && a(e, t[i + r - l]) < 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o);
    var u = s;
    s = r - l, l = r - u;
  } else {
    for (o = n - r; l < o && a(e, t[i + r + l]) >= 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o), s += r, l += r;
  }
  for (s++; s < l; ) {
    var c = s + (l - s >>> 1);
    a(e, t[i + c]) < 0 ? l = c : s = c + 1;
  }
  return l;
}
function IE(e, t) {
  var i = ks, n, r, a = 0, s = [];
  n = [], r = [];
  function o(f, v) {
    n[a] = f, r[a] = v, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var f = a - 2;
      if (f >= 1 && r[f - 1] <= r[f] + r[f + 1] || f >= 2 && r[f - 2] <= r[f] + r[f - 1])
        r[f - 1] < r[f + 1] && f--;
      else if (r[f] > r[f + 1])
        break;
      c(f);
    }
  }
  function u() {
    for (; a > 1; ) {
      var f = a - 2;
      f > 0 && r[f - 1] < r[f + 1] && f--, c(f);
    }
  }
  function c(f) {
    var v = n[f], p = r[f], g = n[f + 1], m = r[f + 1];
    r[f] = p + m, f === a - 3 && (n[f + 1] = n[f + 2], r[f + 1] = r[f + 2]), a--;
    var _ = _h(e[g], e, v, p, 0, t);
    v += _, p -= _, p !== 0 && (m = mh(e[v + p - 1], e, g, m, m - 1, t), m !== 0 && (p <= m ? h(v, p, g, m) : d(v, p, g, m)));
  }
  function h(f, v, p, g) {
    var m = 0;
    for (m = 0; m < v; m++)
      s[m] = e[f + m];
    var _ = 0, y = p, b = f;
    if (e[b++] = e[y++], --g === 0) {
      for (m = 0; m < v; m++)
        e[b + m] = s[_ + m];
      return;
    }
    if (v === 1) {
      for (m = 0; m < g; m++)
        e[b + m] = e[y + m];
      e[b + g] = s[_];
      return;
    }
    for (var w = i, S, M, k; ; ) {
      S = 0, M = 0, k = !1;
      do
        if (t(e[y], s[_]) < 0) {
          if (e[b++] = e[y++], M++, S = 0, --g === 0) {
            k = !0;
            break;
          }
        } else if (e[b++] = s[_++], S++, M = 0, --v === 1) {
          k = !0;
          break;
        }
      while ((S | M) < w);
      if (k)
        break;
      do {
        if (S = _h(e[y], s, _, v, 0, t), S !== 0) {
          for (m = 0; m < S; m++)
            e[b + m] = s[_ + m];
          if (b += S, _ += S, v -= S, v <= 1) {
            k = !0;
            break;
          }
        }
        if (e[b++] = e[y++], --g === 0) {
          k = !0;
          break;
        }
        if (M = mh(s[_], e, y, g, 0, t), M !== 0) {
          for (m = 0; m < M; m++)
            e[b + m] = e[y + m];
          if (b += M, y += M, g -= M, g === 0) {
            k = !0;
            break;
          }
        }
        if (e[b++] = s[_++], --v === 1) {
          k = !0;
          break;
        }
        w--;
      } while (S >= ks || M >= ks);
      if (k)
        break;
      w < 0 && (w = 0), w += 2;
    }
    if (i = w, i < 1 && (i = 1), v === 1) {
      for (m = 0; m < g; m++)
        e[b + m] = e[y + m];
      e[b + g] = s[_];
    } else {
      if (v === 0)
        throw new Error();
      for (m = 0; m < v; m++)
        e[b + m] = s[_ + m];
    }
  }
  function d(f, v, p, g) {
    var m = 0;
    for (m = 0; m < g; m++)
      s[m] = e[p + m];
    var _ = f + v - 1, y = g - 1, b = p + g - 1, w = 0, S = 0;
    if (e[b--] = e[_--], --v === 0) {
      for (w = b - (g - 1), m = 0; m < g; m++)
        e[w + m] = s[m];
      return;
    }
    if (g === 1) {
      for (b -= v, _ -= v, S = b + 1, w = _ + 1, m = v - 1; m >= 0; m--)
        e[S + m] = e[w + m];
      e[b] = s[y];
      return;
    }
    for (var M = i; ; ) {
      var k = 0, T = 0, C = !1;
      do
        if (t(s[y], e[_]) < 0) {
          if (e[b--] = e[_--], k++, T = 0, --v === 0) {
            C = !0;
            break;
          }
        } else if (e[b--] = s[y--], T++, k = 0, --g === 1) {
          C = !0;
          break;
        }
      while ((k | T) < M);
      if (C)
        break;
      do {
        if (k = v - _h(s[y], e, f, v, v - 1, t), k !== 0) {
          for (b -= k, _ -= k, v -= k, S = b + 1, w = _ + 1, m = k - 1; m >= 0; m--)
            e[S + m] = e[w + m];
          if (v === 0) {
            C = !0;
            break;
          }
        }
        if (e[b--] = s[y--], --g === 1) {
          C = !0;
          break;
        }
        if (T = g - mh(e[_], s, 0, g, g - 1, t), T !== 0) {
          for (b -= T, y -= T, g -= T, S = b + 1, w = y + 1, m = 0; m < T; m++)
            e[S + m] = s[w + m];
          if (g <= 1) {
            C = !0;
            break;
          }
        }
        if (e[b--] = e[_--], --v === 0) {
          C = !0;
          break;
        }
        M--;
      } while (k >= ks || T >= ks);
      if (C)
        break;
      M < 0 && (M = 0), M += 2;
    }
    if (i = M, i < 1 && (i = 1), g === 1) {
      for (b -= v, _ -= v, S = b + 1, w = _ + 1, m = v - 1; m >= 0; m--)
        e[S + m] = e[w + m];
      e[b] = s[y];
    } else {
      if (g === 0)
        throw new Error();
      for (w = b - (g - 1), m = 0; m < g; m++)
        e[w + m] = s[m];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: o
  };
}
function iu(e, t, i, n) {
  i || (i = 0), n || (n = e.length);
  var r = n - i;
  if (!(r < 2)) {
    var a = 0;
    if (r < u1) {
      a = km(e, i, n, t), Dm(e, i, n, i + a, t);
      return;
    }
    var s = IE(e, t), o = LE(r);
    do {
      if (a = km(e, i, n, t), a < o) {
        var l = r;
        l > o && (l = o), Dm(e, i, i + l, i + a, t), a = l;
      }
      s.pushRun(i, a), s.mergeRuns(), r -= a, i += a;
    } while (r !== 0);
    s.forceMergeRuns();
  }
}
var Ke = 1, Qs = 2, Fa = 4, Tm = !1;
function yh() {
  Tm || (Tm = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function Cm(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var RE = (function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = Cm;
  }
  return e.prototype.traverse = function(t, i) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, i);
  }, e.prototype.getDisplayList = function(t, i) {
    i = i || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(i), n;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var i = this._roots, n = this._displayList, r = 0, a = i.length; r < a; r++)
      this._updateAndAddDisplayable(i[r], null, t);
    n.length = this._displayListLen, iu(n, Cm);
  }, e.prototype._updateAndAddDisplayable = function(t, i, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var r = t.getClipPath(), a = i && i.length, s = 0, o = t.__clipPaths;
      if (!t.ignoreClip && (a || r)) {
        if (o || (o = t.__clipPaths = []), a)
          for (var l = 0; l < i.length; l++)
            o[s++] = i[l];
        for (var u = r, c = t; u; )
          u.parent = c, u.updateTransform(), o[s++] = u, c = u, u = u.getClipPath();
      }
      if (o && (o.length = s), t.childrenRef) {
        for (var h = t.childrenRef(), d = 0; d < h.length; d++) {
          var f = h[d];
          t.__dirty && (f.__dirty |= Ke), this._updateAndAddDisplayable(f, o, n);
        }
        t.__dirty = 0;
      } else {
        var v = t;
        isNaN(v.z) && (yh(), v.z = 0), isNaN(v.z2) && (yh(), v.z2 = 0), isNaN(v.zlevel) && (yh(), v.zlevel = 0), this._displayList[this._displayListLen++] = v;
      }
      var p = t.getDecalElement && t.getDecalElement();
      p && this._updateAndAddDisplayable(p, o, n);
      var g = t.getTextGuideLine();
      g && this._updateAndAddDisplayable(g, o, n);
      var m = t.getTextContent();
      m && this._updateAndAddDisplayable(m, o, n);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var i = 0, n = t.length; i < n; i++)
        this.delRoot(t[i]);
      return;
    }
    var r = Vt(this._roots, t);
    r >= 0 && this._roots.splice(r, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
})(), Cu;
Cu = st.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var vo = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - vo.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? vo.bounceIn(e * 2) * 0.5 : vo.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, gl = Math.pow, qn = Math.sqrt, Au = 1e-8, c1 = 1e-4, Am = qn(3), ml = 1 / 3, Yi = vs(), li = vs(), qa = vs();
function Wn(e) {
  return e > -Au && e < Au;
}
function h1(e) {
  return e > Au || e < -Au;
}
function Le(e, t, i, n, r) {
  var a = 1 - r;
  return a * a * (a * e + 3 * r * t) + r * r * (r * n + 3 * a * i);
}
function Pm(e, t, i, n, r) {
  var a = 1 - r;
  return 3 * (((t - e) * a + 2 * (i - t) * r) * a + (n - i) * r * r);
}
function d1(e, t, i, n, r, a) {
  var s = n + 3 * (t - i) - e, o = 3 * (i - t * 2 + e), l = 3 * (t - e), u = e - r, c = o * o - 3 * s * l, h = o * l - 9 * s * u, d = l * l - 3 * o * u, f = 0;
  if (Wn(c) && Wn(h))
    if (Wn(o))
      a[0] = 0;
    else {
      var v = -l / o;
      v >= 0 && v <= 1 && (a[f++] = v);
    }
  else {
    var p = h * h - 4 * c * d;
    if (Wn(p)) {
      var g = h / c, v = -o / s + g, m = -g / 2;
      v >= 0 && v <= 1 && (a[f++] = v), m >= 0 && m <= 1 && (a[f++] = m);
    } else if (p > 0) {
      var _ = qn(p), y = c * o + 1.5 * s * (-h + _), b = c * o + 1.5 * s * (-h - _);
      y < 0 ? y = -gl(-y, ml) : y = gl(y, ml), b < 0 ? b = -gl(-b, ml) : b = gl(b, ml);
      var v = (-o - (y + b)) / (3 * s);
      v >= 0 && v <= 1 && (a[f++] = v);
    } else {
      var w = (2 * c * o - 3 * s * h) / (2 * qn(c * c * c)), S = Math.acos(w) / 3, M = qn(c), k = Math.cos(S), v = (-o - 2 * M * k) / (3 * s), m = (-o + M * (k + Am * Math.sin(S))) / (3 * s), T = (-o + M * (k - Am * Math.sin(S))) / (3 * s);
      v >= 0 && v <= 1 && (a[f++] = v), m >= 0 && m <= 1 && (a[f++] = m), T >= 0 && T <= 1 && (a[f++] = T);
    }
  }
  return f;
}
function f1(e, t, i, n, r) {
  var a = 6 * i - 12 * t + 6 * e, s = 9 * t + 3 * n - 3 * e - 9 * i, o = 3 * t - 3 * e, l = 0;
  if (Wn(s)) {
    if (h1(a)) {
      var u = -o / a;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = a * a - 4 * s * o;
    if (Wn(c))
      r[0] = -a / (2 * s);
    else if (c > 0) {
      var h = qn(c), u = (-a + h) / (2 * s), d = (-a - h) / (2 * s);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function Pu(e, t, i, n, r, a) {
  var s = (t - e) * r + e, o = (i - t) * r + t, l = (n - i) * r + i, u = (o - s) * r + s, c = (l - o) * r + o, h = (c - u) * r + u;
  a[0] = e, a[1] = s, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n;
}
function NE(e, t, i, n, r, a, s, o, l, u, c) {
  var h, d = 5e-3, f = 1 / 0, v, p, g, m;
  Yi[0] = l, Yi[1] = u;
  for (var _ = 0; _ < 1; _ += 0.05)
    li[0] = Le(e, i, r, s, _), li[1] = Le(t, n, a, o, _), g = ja(Yi, li), g < f && (h = _, f = g);
  f = 1 / 0;
  for (var y = 0; y < 32 && !(d < c1); y++)
    v = h - d, p = h + d, li[0] = Le(e, i, r, s, v), li[1] = Le(t, n, a, o, v), g = ja(li, Yi), v >= 0 && g < f ? (h = v, f = g) : (qa[0] = Le(e, i, r, s, p), qa[1] = Le(t, n, a, o, p), m = ja(qa, Yi), p <= 1 && m < f ? (h = p, f = m) : d *= 0.5);
  return qn(f);
}
function FE(e, t, i, n, r, a, s, o, l) {
  for (var u = e, c = t, h = 0, d = 1 / l, f = 1; f <= l; f++) {
    var v = f * d, p = Le(e, i, r, s, v), g = Le(t, n, a, o, v), m = p - u, _ = g - c;
    h += Math.sqrt(m * m + _ * _), u = p, c = g;
  }
  return h;
}
function Ve(e, t, i, n) {
  var r = 1 - n;
  return r * (r * e + 2 * n * t) + n * n * i;
}
function Em(e, t, i, n) {
  return 2 * ((1 - n) * (t - e) + n * (i - t));
}
function BE(e, t, i, n, r) {
  var a = e - 2 * t + i, s = 2 * (t - e), o = e - n, l = 0;
  if (Wn(a)) {
    if (h1(s)) {
      var u = -o / s;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = s * s - 4 * a * o;
    if (Wn(c)) {
      var u = -s / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u);
    } else if (c > 0) {
      var h = qn(c), u = (-s + h) / (2 * a), d = (-s - h) / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function v1(e, t, i) {
  var n = e + i - 2 * t;
  return n === 0 ? 0.5 : (e - t) / n;
}
function Eu(e, t, i, n, r) {
  var a = (t - e) * n + e, s = (i - t) * n + t, o = (s - a) * n + a;
  r[0] = e, r[1] = a, r[2] = o, r[3] = o, r[4] = s, r[5] = i;
}
function $E(e, t, i, n, r, a, s, o, l) {
  var u, c = 5e-3, h = 1 / 0;
  Yi[0] = s, Yi[1] = o;
  for (var d = 0; d < 1; d += 0.05) {
    li[0] = Ve(e, i, r, d), li[1] = Ve(t, n, a, d);
    var f = ja(Yi, li);
    f < h && (u = d, h = f);
  }
  h = 1 / 0;
  for (var v = 0; v < 32 && !(c < c1); v++) {
    var p = u - c, g = u + c;
    li[0] = Ve(e, i, r, p), li[1] = Ve(t, n, a, p);
    var f = ja(li, Yi);
    if (p >= 0 && f < h)
      u = p, h = f;
    else {
      qa[0] = Ve(e, i, r, g), qa[1] = Ve(t, n, a, g);
      var m = ja(qa, Yi);
      g <= 1 && m < h ? (u = g, h = m) : c *= 0.5;
    }
  }
  return qn(h);
}
function zE(e, t, i, n, r, a, s) {
  for (var o = e, l = t, u = 0, c = 1 / s, h = 1; h <= s; h++) {
    var d = h * c, f = Ve(e, i, r, d), v = Ve(t, n, a, d), p = f - o, g = v - l;
    u += Math.sqrt(p * p + g * g), o = f, l = v;
  }
  return u;
}
var VE = /cubic-bezier\(([0-9,\.e ]+)\)/;
function p1(e) {
  var t = e && VE.exec(e);
  if (t) {
    var i = t[1].split(","), n = +Ui(i[0]), r = +Ui(i[1]), a = +Ui(i[2]), s = +Ui(i[3]);
    if (isNaN(n + r + a + s))
      return;
    var o = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : d1(0, n, a, 1, l, o) && Le(0, r, s, 1, o[0]);
    };
  }
}
var HE = (function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || ke, this.ondestroy = t.ondestroy || ke, this.onrestart = t.onrestart || ke, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, i) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += i;
      return;
    }
    var n = this._life, r = t - this._startTime - this._pausedTime, a = r / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var s = this.easingFunc, o = s ? s(a) : a;
    if (this.onframe(o), a === 1)
      if (this.loop) {
        var l = r % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = mt(t) ? t : vo[t] || p1(t);
  }, e;
})(), g1 = /* @__PURE__ */ (function() {
  function e(t) {
    this.value = t;
  }
  return e;
})(), YE = (function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var i = new g1(t);
    return this.insertEntry(i), i;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var i = t.prev, n = t.next;
    i ? i.next = n : this.head = n, n ? n.prev = i : this.tail = i, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
})(), as = (function() {
  function e(t) {
    this._list = new YE(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, i) {
    var n = this._list, r = this._map, a = null;
    if (r[t] == null) {
      var s = n.len(), o = this._lastRemovedEntry;
      if (s >= this._maxSize && s > 0) {
        var l = n.head;
        n.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      o ? o.value = i : o = new g1(i), o.key = t, n.insertEntry(o), r[t] = o;
    }
    return a;
  }, e.prototype.get = function(t) {
    var i = this._map[t], n = this._list;
    if (i != null)
      return i !== n.tail && (n.remove(i), n.insertEntry(i)), i.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
})(), Lm = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function Zn(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function WE(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function Lu(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function bh(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Zn(parseFloat(t) / 100 * 255) : Zn(parseInt(t, 10));
}
function Kr(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Lu(parseFloat(t) / 100) : Lu(parseFloat(t));
}
function xh(e, t, i) {
  return i < 0 ? i += 1 : i > 1 && (i -= 1), i * 6 < 1 ? e + (t - e) * i * 6 : i * 2 < 1 ? t : i * 3 < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e;
}
function _l(e, t, i) {
  return e + (t - e) * i;
}
function ri(e, t, i, n, r) {
  return e[0] = t, e[1] = i, e[2] = n, e[3] = r, e;
}
function Jd(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var m1 = new as(20), yl = null;
function ya(e, t) {
  yl && Jd(yl, t), yl = m1.put(e, yl || t.slice());
}
function xn(e, t) {
  if (e) {
    t = t || [];
    var i = m1.get(e);
    if (i)
      return Jd(t, i);
    e = e + "";
    var n = e.replace(/ /g, "").toLowerCase();
    if (n in Lm)
      return Jd(t, Lm[n]), ya(e, t), t;
    var r = n.length;
    if (n.charAt(0) === "#") {
      if (r === 4 || r === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          ri(t, 0, 0, 0, 1);
          return;
        }
        return ri(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(n.slice(4), 16) / 15 : 1), ya(e, t), t;
      } else if (r === 7 || r === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          ri(t, 0, 0, 0, 1);
          return;
        }
        return ri(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(n.slice(7), 16) / 255 : 1), ya(e, t), t;
      }
      return;
    }
    var s = n.indexOf("("), o = n.indexOf(")");
    if (s !== -1 && o + 1 === r) {
      var l = n.substr(0, s), u = n.substr(s + 1, o - (s + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? ri(t, +u[0], +u[1], +u[2], 1) : ri(t, 0, 0, 0, 1);
          c = Kr(u.pop());
        case "rgb":
          if (u.length >= 3)
            return ri(t, bh(u[0]), bh(u[1]), bh(u[2]), u.length === 3 ? c : Kr(u[3])), ya(e, t), t;
          ri(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            ri(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = Kr(u[3]), tf(u, t), ya(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            ri(t, 0, 0, 0, 1);
            return;
          }
          return tf(u, t), ya(e, t), t;
        default:
          return;
      }
    }
    ri(t, 0, 0, 0, 1);
  }
}
function tf(e, t) {
  var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = Kr(e[1]), r = Kr(e[2]), a = r <= 0.5 ? r * (n + 1) : r + n - r * n, s = r * 2 - a;
  return t = t || [], ri(t, Zn(xh(s, a, i + 1 / 3) * 255), Zn(xh(s, a, i) * 255), Zn(xh(s, a, i - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function UE(e) {
  if (e) {
    var t = e[0] / 255, i = e[1] / 255, n = e[2] / 255, r = Math.min(t, i, n), a = Math.max(t, i, n), s = a - r, o = (a + r) / 2, l, u;
    if (s === 0)
      l = 0, u = 0;
    else {
      o < 0.5 ? u = s / (a + r) : u = s / (2 - a - r);
      var c = ((a - t) / 6 + s / 2) / s, h = ((a - i) / 6 + s / 2) / s, d = ((a - n) / 6 + s / 2) / s;
      t === a ? l = d - h : i === a ? l = 1 / 3 + c - d : n === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var f = [l * 360, u, o];
    return e[3] != null && f.push(e[3]), f;
  }
}
function Om(e, t) {
  var i = xn(e);
  if (i) {
    for (var n = 0; n < 3; n++)
      i[n] = i[n] * (1 - t) | 0, i[n] > 255 ? i[n] = 255 : i[n] < 0 && (i[n] = 0);
    return Qr(i, i.length === 4 ? "rgba" : "rgb");
  }
}
function wh(e, t, i) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    i = i || [];
    var n = e * (t.length - 1), r = Math.floor(n), a = Math.ceil(n), s = t[r], o = t[a], l = n - r;
    return i[0] = Zn(_l(s[0], o[0], l)), i[1] = Zn(_l(s[1], o[1], l)), i[2] = Zn(_l(s[2], o[2], l)), i[3] = Lu(_l(s[3], o[3], l)), i;
  }
}
function Za(e, t, i, n) {
  var r = xn(e);
  if (e)
    return r = UE(r), t != null && (r[0] = WE(mt(t) ? t(r[0]) : t)), i != null && (r[1] = Kr(mt(i) ? i(r[1]) : i)), n != null && (r[2] = Kr(mt(n) ? n(r[2]) : n)), Qr(tf(r), "rgba");
}
function GE(e, t) {
  var i = xn(e);
  if (i && t != null)
    return i[3] = Lu(t), Qr(i, "rgba");
}
function Qr(e, t) {
  if (!(!e || !e.length)) {
    var i = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (i += "," + e[3]), t + "(" + i + ")";
  }
}
function Ou(e, t) {
  var i = xn(e);
  return i ? (0.299 * i[0] + 0.587 * i[1] + 0.114 * i[2]) * i[3] / 255 + (1 - i[3]) * t : 0;
}
var Im = new as(100);
function Rm(e) {
  if (tt(e)) {
    var t = Im.get(e);
    return t || (t = Om(e, -0.1), Im.put(e, t)), t;
  } else if (Sc(e)) {
    var i = Y({}, e);
    return i.colorStops = yt(e.colorStops, function(n) {
      return {
        offset: n.offset,
        color: Om(n.color, -0.1)
      };
    }), i;
  }
  return e;
}
function XE(e) {
  return e.type === "linear";
}
function jE(e) {
  return e.type === "radial";
}
(function() {
  return st.hasGlobalWindow && mt(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && qr("Base64 isn't natively supported in the current environment."), null;
  };
})();
var ef = Array.prototype.slice;
function dn(e, t, i) {
  return (t - e) * i + e;
}
function Sh(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = dn(t[a], i[a], n);
  return e;
}
function qE(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, s = 0; s < r; s++) {
    e[s] || (e[s] = []);
    for (var o = 0; o < a; o++)
      e[s][o] = dn(t[s][o], i[s][o], n);
  }
  return e;
}
function bl(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = t[a] + i[a] * n;
  return e;
}
function Nm(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, s = 0; s < r; s++) {
    e[s] || (e[s] = []);
    for (var o = 0; o < a; o++)
      e[s][o] = t[s][o] + i[s][o] * n;
  }
  return e;
}
function ZE(e, t) {
  for (var i = e.length, n = t.length, r = i > n ? t : e, a = Math.min(i, n), s = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, o = a; o < Math.max(i, n); o++)
    r.push({
      offset: s.offset,
      color: s.color.slice()
    });
}
function KE(e, t, i) {
  var n = e, r = t;
  if (!(!n.push || !r.push)) {
    var a = n.length, s = r.length;
    if (a !== s) {
      var o = a > s;
      if (o)
        n.length = s;
      else
        for (var l = a; l < s; l++)
          n.push(i === 1 ? r[l] : ef.call(r[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (i === 1)
        isNaN(n[l]) && (n[l] = r[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = r[l][c]);
  }
}
function nu(e) {
  if (Ge(e)) {
    var t = e.length;
    if (Ge(e[0])) {
      for (var i = [], n = 0; n < t; n++)
        i.push(ef.call(e[n]));
      return i;
    }
    return ef.call(e);
  }
  return e;
}
function ru(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function QE(e) {
  return Ge(e && e[0]) ? 2 : 1;
}
var xl = 0, au = 1, _1 = 2, Js = 3, nf = 4, rf = 5, Fm = 6;
function Bm(e) {
  return e === nf || e === rf;
}
function wl(e) {
  return e === au || e === _1;
}
var Ds = [0, 0, 0, 0], JE = (function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, i, n) {
    this._needsSort = !0;
    var r = this.keyframes, a = r.length, s = !1, o = Fm, l = i;
    if (Ge(i)) {
      var u = QE(i);
      o = u, (u === 1 && !Zt(i[0]) || u === 2 && !Zt(i[0][0])) && (s = !0);
    } else if (Zt(i) && !t1(i))
      o = xl;
    else if (tt(i))
      if (!isNaN(+i))
        o = xl;
      else {
        var c = xn(i);
        c && (l = c, o = Js);
      }
    else if (Sc(i)) {
      var h = Y({}, l);
      h.colorStops = yt(i.colorStops, function(f) {
        return {
          offset: f.offset,
          color: xn(f.color)
        };
      }), XE(i) ? o = nf : jE(i) && (o = rf), l = h;
    }
    a === 0 ? this.valType = o : (o !== this.valType || o === Fm) && (s = !0), this.discrete = this.discrete || s;
    var d = {
      time: t,
      value: l,
      rawValue: i,
      percent: 0
    };
    return n && (d.easing = n, d.easingFunc = mt(n) ? n : vo[n] || p1(n)), r.push(d), d;
  }, e.prototype.prepare = function(t, i) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(p, g) {
      return p.time - g.time;
    });
    for (var r = this.valType, a = n.length, s = n[a - 1], o = this.discrete, l = wl(r), u = Bm(r), c = 0; c < a; c++) {
      var h = n[c], d = h.value, f = s.value;
      h.percent = h.time / t, o || (l && c !== a - 1 ? KE(d, f, r) : u && ZE(d.colorStops, f.colorStops));
    }
    if (!o && r !== rf && i && this.needsAnimate() && i.needsAnimate() && r === i.valType && !i._finished) {
      this._additiveTrack = i;
      for (var v = n[0].value, c = 0; c < a; c++)
        r === xl ? n[c].additiveValue = n[c].value - v : r === Js ? n[c].additiveValue = bl([], n[c].value, v, -1) : wl(r) && (n[c].additiveValue = r === au ? bl([], n[c].value, v, -1) : Nm([], n[c].value, v, -1));
    }
  }, e.prototype.step = function(t, i) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, r = n ? "additiveValue" : "value", a = this.valType, s = this.keyframes, o = s.length, l = this.propName, u = a === Js, c, h = this._lastFr, d = Math.min, f, v;
      if (o === 1)
        f = v = s[0];
      else {
        if (i < 0)
          c = 0;
        else if (i < this._lastFrP) {
          var p = d(h + 1, o - 1);
          for (c = p; c >= 0 && !(s[c].percent <= i); c--)
            ;
          c = d(c, o - 2);
        } else {
          for (c = h; c < o && !(s[c].percent > i); c++)
            ;
          c = d(c - 1, o - 2);
        }
        v = s[c + 1], f = s[c];
      }
      if (f && v) {
        this._lastFr = c, this._lastFrP = i;
        var g = v.percent - f.percent, m = g === 0 ? 1 : d((i - f.percent) / g, 1);
        v.easingFunc && (m = v.easingFunc(m));
        var _ = n ? this._additiveValue : u ? Ds : t[l];
        if ((wl(a) || u) && !_ && (_ = this._additiveValue = []), this.discrete)
          t[l] = m < 1 ? f.rawValue : v.rawValue;
        else if (wl(a))
          a === au ? Sh(_, f[r], v[r], m) : qE(_, f[r], v[r], m);
        else if (Bm(a)) {
          var y = f[r], b = v[r], w = a === nf;
          t[l] = {
            type: w ? "linear" : "radial",
            x: dn(y.x, b.x, m),
            y: dn(y.y, b.y, m),
            colorStops: yt(y.colorStops, function(M, k) {
              var T = b.colorStops[k];
              return {
                offset: dn(M.offset, T.offset, m),
                color: ru(Sh([], M.color, T.color, m))
              };
            }),
            global: b.global
          }, w ? (t[l].x2 = dn(y.x2, b.x2, m), t[l].y2 = dn(y.y2, b.y2, m)) : t[l].r = dn(y.r, b.r, m);
        } else if (u)
          Sh(_, f[r], v[r], m), n || (t[l] = ru(_));
        else {
          var S = dn(f[r], v[r], m);
          n ? this._additiveValue = S : t[l] = S;
        }
        n && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var i = this.valType, n = this.propName, r = this._additiveValue;
    i === xl ? t[n] = t[n] + r : i === Js ? (xn(t[n], Ds), bl(Ds, Ds, r, 1), t[n] = ru(Ds)) : i === au ? bl(t[n], t[n], r, 1) : i === _1 && Nm(t[n], t[n], r, 1);
  }, e;
})(), Tv = (function() {
  function e(t, i, n, r) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = i, i && r) {
      qr("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = r, this._allowDiscrete = n;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, i, n) {
    return this.whenWithKeys(t, i, qt(i), n);
  }, e.prototype.whenWithKeys = function(t, i, n, r) {
    for (var a = this._tracks, s = 0; s < n.length; s++) {
      var o = n[s], l = a[o];
      if (!l) {
        l = a[o] = new JE(o);
        var u = void 0, c = this._getAdditiveTrack(o);
        if (c) {
          var h = c.keyframes, d = h[h.length - 1];
          u = d && d.value, c.valType === Js && u && (u = ru(u));
        } else
          u = this._target[o];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, nu(u), r), this._trackKeys.push(o);
      }
      l.addKeyframe(t, nu(i[o]), r);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var i = t.length, n = 0; n < i; n++)
        t[n].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, i = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, i)
      for (var n = 0; n < i.length; n++)
        i[n].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, i = this._trackKeys, n = 0; n < i.length; n++)
      t[i[n]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var i, n = this._additiveAnimators;
    if (n)
      for (var r = 0; r < n.length; r++) {
        var a = n[r].getTrack(t);
        a && (i = a);
      }
    return i;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var i = this, n = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var s = this._trackKeys[a], o = this._tracks[s], l = this._getAdditiveTrack(s), u = o.keyframes, c = u.length;
        if (o.prepare(r, l), o.needsAnimate())
          if (!this._allowDiscrete && o.discrete) {
            var h = u[c - 1];
            h && (i._target[o.propName] = h.rawValue), o.setFinished();
          } else
            n.push(o);
      }
      if (n.length || this._force) {
        var d = new HE({
          life: r,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(f) {
            i._started = 2;
            var v = i._additiveAnimators;
            if (v) {
              for (var p = !1, g = 0; g < v.length; g++)
                if (v[g]._clip) {
                  p = !0;
                  break;
                }
              p || (i._additiveAnimators = null);
            }
            for (var g = 0; g < n.length; g++)
              n[g].step(i._target, f);
            var m = i._onframeCbs;
            if (m)
              for (var g = 0; g < m.length; g++)
                m[g](i._target, f);
          },
          ondestroy: function() {
            i._doneCallback();
          }
        });
        this._clip = d, this.animation && this.animation.addClip(d), t && d.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var i = this._clip;
      t && i.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return yt(this._trackKeys, function(i) {
      return t._tracks[i];
    });
  }, e.prototype.stopTracks = function(t, i) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
      var s = n[t[a]];
      s && !s.isFinished() && (i ? s.step(this._target, 1) : this._started === 1 && s.step(this._target, 0), s.setFinished());
    }
    for (var o = !0, a = 0; a < r.length; a++)
      if (!n[r[a]].isFinished()) {
        o = !1;
        break;
      }
    return o && this._abortedCallback(), o;
  }, e.prototype.saveTo = function(t, i, n) {
    if (t) {
      i = i || this._trackKeys;
      for (var r = 0; r < i.length; r++) {
        var a = i[r], s = this._tracks[a];
        if (!(!s || s.isFinished())) {
          var o = s.keyframes, l = o[n ? 0 : o.length - 1];
          l && (t[a] = nu(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, i) {
    i = i || qt(t);
    for (var n = 0; n < i.length; n++) {
      var r = i[n], a = this._tracks[r];
      if (a) {
        var s = a.keyframes;
        if (s.length > 1) {
          var o = s.pop();
          a.addKeyframe(o.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, e;
})();
function Ha() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var tL = (function(e) {
  Lt(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, i = i || {}, n.stage = i.stage || {}, n;
  }
  return t.prototype.addClip = function(i) {
    i.animation && this.removeClip(i), this._head ? (this._tail.next = i, i.prev = this._tail, i.next = null, this._tail = i) : this._head = this._tail = i, i.animation = this;
  }, t.prototype.addAnimator = function(i) {
    i.animation = this;
    var n = i.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(i) {
    if (i.animation) {
      var n = i.prev, r = i.next;
      n ? n.next = r : this._head = r, r ? r.prev = n : this._tail = n, i.next = i.prev = i.animation = null;
    }
  }, t.prototype.removeAnimator = function(i) {
    var n = i.getClip();
    n && this.removeClip(n), i.animation = null;
  }, t.prototype.update = function(i) {
    for (var n = Ha() - this._pausedTime, r = n - this._time, a = this._head; a; ) {
      var s = a.next, o = a.step(n, r);
      o && (a.ondestroy(), this.removeClip(a)), a = s;
    }
    this._time = n, i || (this.trigger("frame", r), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var i = this;
    this._running = !0;
    function n() {
      i._running && (Cu(n), !i._paused && i.update());
    }
    Cu(n);
  }, t.prototype.start = function() {
    this._running || (this._time = Ha(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = Ha(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += Ha() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var i = this._head; i; ) {
      var n = i.next;
      i.prev = i.next = i.animation = null, i = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(i, n) {
    n = n || {}, this.start();
    var r = new Tv(i, n.loop);
    return this.addAnimator(r), r;
  }, t;
})(Pi), eL = 300, Mh = st.domSupported, kh = (function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], i = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = yt(e, function(r) {
    var a = r.replace("mouse", "pointer");
    return i.hasOwnProperty(a) ? a : r;
  });
  return {
    mouse: e,
    touch: t,
    pointer: n
  };
})(), $m = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, zm = !1;
function af(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function iL(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function Dh(e) {
  e && (e.zrByTouch = !0);
}
function nL(e, t) {
  return ai(e.dom, new rL(e, t), !0);
}
function y1(e, t) {
  for (var i = t, n = !1; i && i.nodeType !== 9 && !(n = i.domBelongToZr || i !== t && i === e.painterRoot); )
    i = i.parentNode;
  return n;
}
var rL = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.stopPropagation = ke, this.stopImmediatePropagation = ke, this.preventDefault = ke, this.type = i.type, this.target = this.currentTarget = t.dom, this.pointerType = i.pointerType, this.clientX = i.clientX, this.clientY = i.clientY;
  }
  return e;
})(), xi = {
  mousedown: function(e) {
    e = ai(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = ai(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = ai(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = ai(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    y1(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    zm = !0, e = ai(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    zm || (e = ai(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = ai(this.dom, e), Dh(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), xi.mousemove.call(this, e), xi.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = ai(this.dom, e), Dh(e), this.handler.processGesture(e, "change"), xi.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = ai(this.dom, e), Dh(e), this.handler.processGesture(e, "end"), xi.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < eL && xi.click.call(this, e);
  },
  pointerdown: function(e) {
    xi.mousedown.call(this, e);
  },
  pointermove: function(e) {
    af(e) || xi.mousemove.call(this, e);
  },
  pointerup: function(e) {
    xi.mouseup.call(this, e);
  },
  pointerout: function(e) {
    af(e) || xi.mouseout.call(this, e);
  }
};
A(["click", "dblclick", "contextmenu"], function(e) {
  xi[e] = function(t) {
    t = ai(this.dom, t), this.trigger(e, t);
  };
});
var sf = {
  pointermove: function(e) {
    af(e) || sf.mousemove.call(this, e);
  },
  pointerup: function(e) {
    sf.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function aL(e, t) {
  var i = t.domHandlers;
  st.pointerEventsSupported ? A(kh.pointer, function(n) {
    su(t, n, function(r) {
      i[n].call(e, r);
    });
  }) : (st.touchEventsSupported && A(kh.touch, function(n) {
    su(t, n, function(r) {
      i[n].call(e, r), iL(t);
    });
  }), A(kh.mouse, function(n) {
    su(t, n, function(r) {
      r = Sv(r), t.touching || i[n].call(e, r);
    });
  }));
}
function sL(e, t) {
  st.pointerEventsSupported ? A($m.pointer, i) : st.touchEventsSupported || A($m.mouse, i);
  function i(n) {
    function r(a) {
      a = Sv(a), y1(e, a.target) || (a = nL(e, a), t.domHandlers[n].call(e, a));
    }
    su(t, n, r, { capture: !0 });
  }
}
function su(e, t, i, n) {
  e.mounted[t] = i, e.listenerOpts[t] = n, yE(e.domTarget, t, i, n);
}
function Th(e) {
  var t = e.mounted;
  for (var i in t)
    t.hasOwnProperty(i) && bE(e.domTarget, i, t[i], e.listenerOpts[i]);
  e.mounted = {};
}
var Vm = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = i;
  }
  return e;
})(), oL = (function(e) {
  Lt(t, e);
  function t(i, n) {
    var r = e.call(this) || this;
    return r.__pointerCapturing = !1, r.dom = i, r.painterRoot = n, r._localHandlerScope = new Vm(i, xi), Mh && (r._globalHandlerScope = new Vm(document, sf)), aL(r, r._localHandlerScope), r;
  }
  return t.prototype.dispose = function() {
    Th(this._localHandlerScope), Mh && Th(this._globalHandlerScope);
  }, t.prototype.setCursor = function(i) {
    this.dom.style && (this.dom.style.cursor = i || "default");
  }, t.prototype.__togglePointerCapture = function(i) {
    if (this.__mayPointerCapture = null, Mh && +this.__pointerCapturing ^ +i) {
      this.__pointerCapturing = i;
      var n = this._globalHandlerScope;
      i ? sL(this, n) : Th(n);
    }
  }, t;
})(Pi), b1 = 1;
st.hasGlobalWindow && (b1 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Iu = b1, of = 0.4, lf = "#333", uf = "#ccc", lL = "#eee", Hm = Mv, Ym = 5e-5;
function vr(e) {
  return e > Ym || e < -Ym;
}
var pr = [], ba = [], Ch = qi(), Ah = Math.abs, Hr = (function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return vr(this.rotation) || vr(this.x) || vr(this.y) || vr(this.scaleX - 1) || vr(this.scaleY - 1) || vr(this.skewX) || vr(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, i = this.needLocalTransform(), n = this.transform;
    if (!(i || t)) {
      n && (Hm(n), this.invTransform = null);
      return;
    }
    n = n || qi(), i ? this.getLocalTransform(n) : Hm(n), t && (i ? ho(n, t, n) : kv(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var i = this.globalScaleRatio;
    if (i != null && i !== 1) {
      this.getGlobalScale(pr);
      var n = pr[0] < 0 ? -1 : 1, r = pr[1] < 0 ? -1 : 1, a = ((pr[0] - n) * i + n) / pr[0] || 0, s = ((pr[1] - r) * i + r) / pr[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= s, t[3] *= s;
    }
    this.invTransform = this.invTransform || qi(), Xo(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, i = []; t; )
      i.push(t), t = t.parent;
    for (; t = i.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var i = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(a), i = Math.sqrt(i), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = i, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, i = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || qi(), ho(ba, t.invTransform, i), i = ba);
      var n = this.originX, r = this.originY;
      (n || r) && (Ch[4] = n, Ch[5] = r, ho(ba, i, Ch), ba[4] -= n, ba[5] -= r, i = ba), this.setLocalTransform(i);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var i = this.transform;
    return t = t || [], i ? (t[0] = Math.sqrt(i[0] * i[0] + i[1] * i[1]), t[1] = Math.sqrt(i[2] * i[2] + i[3] * i[3]), i[0] < 0 && (t[0] = -t[0]), i[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, i) {
    var n = [t, i], r = this.invTransform;
    return r && Qe(n, n, r), n;
  }, e.prototype.transformCoordToGlobal = function(t, i) {
    var n = [t, i], r = this.transform;
    return r && Qe(n, n, r), n;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Ah(t[0] - 1) > 1e-10 && Ah(t[3] - 1) > 1e-10 ? Math.sqrt(Ah(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    cf(this, t);
  }, e.getLocalTransform = function(t, i) {
    i = i || [];
    var n = t.originX || 0, r = t.originY || 0, a = t.scaleX, s = t.scaleY, o = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, h = t.y, d = t.skewX ? Math.tan(t.skewX) : 0, f = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || r || o || l) {
      var v = n + o, p = r + l;
      i[4] = -v * a - d * p * s, i[5] = -p * s - f * v * a;
    } else
      i[4] = i[5] = 0;
    return i[0] = a, i[3] = s, i[1] = f * a, i[2] = d * s, u && Dv(i, i, u), i[4] += n + c, i[5] += r + h, i;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  })(), e;
})(), Ao = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function cf(e, t) {
  for (var i = 0; i < Ao.length; i++) {
    var n = Ao[i];
    e[n] = t[n];
  }
}
function Zi(e) {
  Sl || (Sl = new as(100)), e = e || er;
  var t = Sl.get(e);
  return t || (t = {
    font: e,
    strWidthCache: new as(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: kn.measureText("", e).width,
    asciiCharWidth: kn.measureText("a", e).width
  }, Sl.put(e, t)), t;
}
var Sl;
function uL(e) {
  if (!(Ph >= Wm)) {
    e = e || er;
    for (var t = [], i = +/* @__PURE__ */ new Date(), n = 0; n <= 127; n++)
      t[n] = kn.measureText(String.fromCharCode(n), e).width;
    var r = +/* @__PURE__ */ new Date() - i;
    return r > 16 ? Ph = Wm : r > 2 && Ph++, t;
  }
}
var Ph = 0, Wm = 5;
function x1(e, t) {
  return e.asciiWidthMapTried || (e.asciiWidthMap = uL(e.font), e.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? e.asciiWidthMap != null ? e.asciiWidthMap[t] : e.asciiCharWidth : e.stWideCharWidth;
}
function Ki(e, t) {
  var i = e.strWidthCache, n = i.get(t);
  return n == null && (n = kn.measureText(t, e.font).width, i.put(t, n)), n;
}
function Um(e, t, i, n) {
  var r = Ki(Zi(t), e), a = kc(t), s = ss(0, r, i), o = Jr(0, a, n), l = new ot(s, o, r, a);
  return l;
}
function cL(e, t, i, n) {
  var r = ((e || "") + "").split(`
`), a = r.length;
  if (a === 1)
    return Um(r[0], t, i, n);
  for (var s = new ot(0, 0, 0, 0), o = 0; o < r.length; o++) {
    var l = Um(r[o], t, i, n);
    o === 0 ? s.copy(l) : s.union(l);
  }
  return s;
}
function ss(e, t, i, n) {
  return i === "right" ? n ? e += t : e -= t : i === "center" && (n ? e += t / 2 : e -= t / 2), e;
}
function Jr(e, t, i, n) {
  return i === "middle" ? n ? e += t / 2 : e -= t / 2 : i === "bottom" && (n ? e += t : e -= t), e;
}
function kc(e) {
  return Zi(e).stWideCharWidth;
}
function Po(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function w1(e, t, i) {
  var n = t.position || "inside", r = t.distance != null ? t.distance : 5, a = i.height, s = i.width, o = a / 2, l = i.x, u = i.y, c = "left", h = "top";
  if (n instanceof Array)
    l += Po(n[0], i.width), u += Po(n[1], i.height), c = null, h = null;
  else
    switch (n) {
      case "left":
        l -= r, u += o, c = "right", h = "middle";
        break;
      case "right":
        l += r + s, u += o, h = "middle";
        break;
      case "top":
        l += s / 2, u -= r, c = "center", h = "bottom";
        break;
      case "bottom":
        l += s / 2, u += a + r, c = "center";
        break;
      case "inside":
        l += s / 2, u += o, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += r, u += o, h = "middle";
        break;
      case "insideRight":
        l += s - r, u += o, c = "right", h = "middle";
        break;
      case "insideTop":
        l += s / 2, u += r, c = "center";
        break;
      case "insideBottom":
        l += s / 2, u += a - r, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += r, u += r;
        break;
      case "insideTopRight":
        l += s - r, u += r, c = "right";
        break;
      case "insideBottomLeft":
        l += r, u += a - r, h = "bottom";
        break;
      case "insideBottomRight":
        l += s - r, u += a - r, c = "right", h = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = h, e;
}
var Eh = "__zr_normal__", Lh = Ao.concat(["ignore"]), hL = fs(Ao, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), xa = {}, dL = new ot(0, 0, 0, 0), Ml = [], Dc = (function() {
  function e(t) {
    this.id = Jb(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, i, n) {
    switch (this.draggable) {
      case "horizontal":
        i = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var r = this.transform;
    r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += i, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var i = this._textContent;
    if (i && (!i.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, r = n.local, a = i.innerTransformable, s = void 0, o = void 0, l = !1;
      a.parent = r ? this : null;
      var u = !1;
      a.copyTransform(i);
      var c = n.position != null, h = n.autoOverflowArea, d = void 0;
      if ((h || c) && (d = dL, n.layoutRect ? d.copy(n.layoutRect) : d.copy(this.getBoundingRect()), r || d.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(xa, n, d) : w1(xa, n, d), a.x = xa.x, a.y = xa.y, s = xa.align, o = xa.verticalAlign;
        var f = n.origin;
        if (f && n.rotation != null) {
          var v = void 0, p = void 0;
          f === "center" ? (v = d.width * 0.5, p = d.height * 0.5) : (v = Po(f[0], d.width), p = Po(f[1], d.height)), u = !0, a.originX = -a.x + v + (r ? 0 : d.x), a.originY = -a.y + p + (r ? 0 : d.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var g = n.offset;
      g && (a.x += g[0], a.y += g[1], u || (a.originX = -g[0], a.originY = -g[1]));
      var m = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (h) {
        var _ = m.overflowRect = m.overflowRect || new ot(0, 0, 0, 0);
        a.getLocalTransform(Ml), Xo(Ml, Ml), ot.copy(_, d), _.applyTransform(Ml);
      } else
        m.overflowRect = null;
      var y = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, b = void 0, w = void 0, S = void 0;
      y && this.canBeInsideText() ? (b = n.insideFill, w = n.insideStroke, (b == null || b === "auto") && (b = this.getInsideTextFill()), (w == null || w === "auto") && (w = this.getInsideTextStroke(b), S = !0)) : (b = n.outsideFill, w = n.outsideStroke, (b == null || b === "auto") && (b = this.getOutsideFill()), (w == null || w === "auto") && (w = this.getOutsideStroke(b), S = !0)), b = b || "#000", (b !== m.fill || w !== m.stroke || S !== m.autoStroke || s !== m.align || o !== m.verticalAlign) && (l = !0, m.fill = b, m.stroke = w, m.autoStroke = S, m.align = s, m.verticalAlign = o, i.setDefaultTextStyle(m)), i.__dirty |= Ke, l && i.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? uf : lf;
  }, e.prototype.getOutsideStroke = function(t) {
    var i = this.__zr && this.__zr.getBackgroundColor(), n = typeof i == "string" && xn(i);
    n || (n = [255, 255, 255, 1]);
    for (var r = n[3], a = this.__zr.isDarkMode(), s = 0; s < 3; s++)
      n[s] = n[s] * r + (a ? 0 : 255) * (1 - r);
    return n[3] = 1, Qr(n, "rgba");
  }, e.prototype.traverse = function(t, i) {
  }, e.prototype.attrKV = function(t, i) {
    t === "textConfig" ? this.setTextConfig(i) : t === "textContent" ? this.setTextContent(i) : t === "clipPath" ? this.setClipPath(i) : t === "extra" ? (this.extra = this.extra || {}, Y(this.extra, i)) : this[t] = i;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, i) {
    if (typeof t == "string")
      this.attrKV(t, i);
    else if (Q(t))
      for (var n = t, r = qt(n), a = 0; a < r.length; a++) {
        var s = r[a];
        this.attrKV(s, t[s]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var i = this._normalState, n = 0; n < this.animators.length; n++) {
      var r = this.animators[n], a = r.__fromStateTransition;
      if (!(r.getLoop() || a && a !== Eh)) {
        var s = r.targetName, o = s ? i[s] : i;
        r.saveTo(o);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var i = this._normalState;
    i || (i = this._normalState = {}), t.textConfig && !i.textConfig && (i.textConfig = this.textConfig), this._savePrimaryToNormal(t, i, Lh);
  }, e.prototype._savePrimaryToNormal = function(t, i, n) {
    for (var r = 0; r < n.length; r++) {
      var a = n[r];
      t[a] != null && !(a in i) && (i[a] = this[a]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var i = this.states;
    return i[t] || (i[t] = {}), i[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(Eh, !1, t);
  }, e.prototype.useState = function(t, i, n, r) {
    var a = t === Eh, s = this.hasState();
    if (!(!s && a)) {
      var o = this.currentStates, l = this.stateTransition;
      if (!(Vt(o, t) >= 0 && (i || o.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          qr("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || r);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, i, !n && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, d = this._textGuide;
        return h && h.useState(t, i, n, c), d && d.useState(t, i, n, c), a ? (this.currentStates = [], this._normalState = {}) : i ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Ke), u;
      }
    }
  }, e.prototype.useStates = function(t, i, n) {
    if (!t.length)
      this.clearStates();
    else {
      var r = [], a = this.currentStates, s = t.length, o = s === a.length;
      if (o) {
        for (var l = 0; l < s; l++)
          if (t[l] !== a[l]) {
            o = !1;
            break;
          }
      }
      if (o)
        return;
      for (var l = 0; l < s; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && r.push(c);
      }
      var h = r[s - 1], d = !!(h && h.hoverLayer || n);
      d && this._toggleHoverLayerFlag(!0);
      var f = this._mergeStates(r), v = this.stateTransition;
      this.saveCurrentToNormalState(f), this._applyStateObj(t.join(","), f, this._normalState, !1, !i && !this.__inHover && v && v.duration > 0, v);
      var p = this._textContent, g = this._textGuide;
      p && p.useStates(t, i, d), g && g.useStates(t, i, d), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !d && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Ke);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var i = t.__hostTarget;
      t = i ? t.ignoreHostSilent ? null : i : t.parent;
    }
    return !1;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var i = this.animators[t];
      i.targetName && i.changeTarget(this[i.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var i = Vt(this.currentStates, t);
    if (i >= 0) {
      var n = this.currentStates.slice();
      n.splice(i, 1), this.useStates(n);
    }
  }, e.prototype.replaceState = function(t, i, n) {
    var r = this.currentStates.slice(), a = Vt(r, t), s = Vt(r, i) >= 0;
    a >= 0 ? s ? r.splice(a, 1) : r[a] = i : n && !s && r.push(i), this.useStates(r);
  }, e.prototype.toggleState = function(t, i) {
    i ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var i = {}, n, r = 0; r < t.length; r++) {
      var a = t[r];
      Y(i, a), a.textConfig && (n = n || {}, Y(n, a.textConfig));
    }
    return n && (i.textConfig = n), i;
  }, e.prototype._applyStateObj = function(t, i, n, r, a, s) {
    var o = !(i && r);
    i && i.textConfig ? (this.textConfig = Y({}, r ? this.textConfig : n.textConfig), Y(this.textConfig, i.textConfig)) : o && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < Lh.length; c++) {
      var h = Lh[c], d = a && hL[h];
      i && i[h] != null ? d ? (u = !0, l[h] = i[h]) : this[h] = i[h] : o && n[h] != null && (d ? (u = !0, l[h] = n[h]) : this[h] = n[h]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], v = f.targetName;
        f.getLoop() || f.__changeFinalValue(v ? (i || n)[v] : i || n);
      }
    u && this._transitionState(t, l, s);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var i = this.__zr;
    i && t.addSelfToZr(i), t.__zr = i, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var i = this._textContent;
    if (i !== t) {
      if (i && i !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new Hr(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), Y(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= Ke;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var i = this._textContent, n = this._textGuide;
    i && (i.__inHover = t), n && (n.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.addAnimator(i[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.removeAnimator(i[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, i, n) {
    var r = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !r) {
      qr('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new Tv(r, i, n);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, e.prototype.addAnimator = function(t, i) {
    var n = this.__zr, r = this;
    t.during(function() {
      r.updateDuringAnimation(i);
    }).done(function() {
      var a = r.animators, s = Vt(a, t);
      s >= 0 && a.splice(s, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, i) {
    for (var n = this.animators, r = n.length, a = [], s = 0; s < r; s++) {
      var o = n[s];
      !t || t === o.scope ? o.stop(i) : a.push(o);
    }
    return this.animators = a, this;
  }, e.prototype.animateTo = function(t, i, n) {
    Oh(this, t, i, n);
  }, e.prototype.animateFrom = function(t, i, n) {
    Oh(this, t, i, n, !0);
  }, e.prototype._transitionState = function(t, i, n, r) {
    for (var a = Oh(this, i, n, r), s = 0; s < a.length; s++)
      a[s].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = Ke;
    var i = {};
    function n(a, s, o) {
      i[a + s + o] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + s + "', '" + o + "' instead"), i[a + s + o] = !0);
    }
    function r(a, s, o, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(a, o, l), !this[s]) {
            var c = this[s] = [];
            u(this, c);
          }
          return this[s];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(a, o, l), this[o] = c[0], this[l] = c[1], this[s] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[o];
          },
          set: function(d) {
            c[o] = d;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(d) {
            c[l] = d;
          }
        });
      }
    }
    Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
  })(), e;
})();
Ai(Dc, Pi);
Ai(Dc, Hr);
function Oh(e, t, i, n, r) {
  i = i || {};
  var a = [];
  S1(e, "", e, t, i, n, a, r);
  var s = a.length, o = !1, l = i.done, u = i.aborted, c = function() {
    o = !0, s--, s <= 0 && (o ? l && l() : u && u());
  }, h = function() {
    s--, s <= 0 && (o ? l && l() : u && u());
  };
  s || l && l(), a.length > 0 && i.during && a[0].during(function(v, p) {
    i.during(p);
  });
  for (var d = 0; d < a.length; d++) {
    var f = a[d];
    c && f.done(c), h && f.aborted(h), i.force && f.duration(i.duration), f.start(i.easing);
  }
  return a;
}
function Ih(e, t, i) {
  for (var n = 0; n < i; n++)
    e[n] = t[n];
}
function fL(e) {
  return Ge(e[0]);
}
function vL(e, t, i) {
  if (Ge(t[i]))
    if (Ge(e[i]) || (e[i] = []), Re(t[i])) {
      var n = t[i].length;
      e[i].length !== n && (e[i] = new t[i].constructor(n), Ih(e[i], t[i], n));
    } else {
      var r = t[i], a = e[i], s = r.length;
      if (fL(r))
        for (var o = r[0].length, l = 0; l < s; l++)
          a[l] ? Ih(a[l], r[l], o) : a[l] = Array.prototype.slice.call(r[l]);
      else
        Ih(a, r, s);
      a.length = r.length;
    }
  else
    e[i] = t[i];
}
function pL(e, t) {
  return e === t || Ge(e) && Ge(t) && gL(e, t);
}
function gL(e, t) {
  var i = e.length;
  if (i !== t.length)
    return !1;
  for (var n = 0; n < i; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function S1(e, t, i, n, r, a, s, o) {
  for (var l = qt(n), u = r.duration, c = r.delay, h = r.additive, d = r.setToFinal, f = !Q(a), v = e.animators, p = [], g = 0; g < l.length; g++) {
    var m = l[g], _ = n[m];
    if (_ != null && i[m] != null && (f || a[m]))
      if (Q(_) && !Ge(_) && !Sc(_)) {
        if (t) {
          o || (i[m] = _, e.updateDuringAnimation(t));
          continue;
        }
        S1(e, m, i[m], _, r, a && a[m], s, o);
      } else
        p.push(m);
    else o || (i[m] = _, e.updateDuringAnimation(t), p.push(m));
  }
  var y = p.length;
  if (!h && y)
    for (var b = 0; b < v.length; b++) {
      var w = v[b];
      if (w.targetName === t) {
        var S = w.stopTracks(p);
        if (S) {
          var M = Vt(v, w);
          v.splice(M, 1);
        }
      }
    }
  if (r.force || (p = Ze(p, function(D) {
    return !pL(n[D], i[D]);
  }), y = p.length), y > 0 || r.force && !s.length) {
    var k = void 0, T = void 0, C = void 0;
    if (o) {
      T = {}, d && (k = {});
      for (var b = 0; b < y; b++) {
        var m = p[b];
        T[m] = i[m], d ? k[m] = n[m] : i[m] = n[m];
      }
    } else if (d) {
      C = {};
      for (var b = 0; b < y; b++) {
        var m = p[b];
        C[m] = nu(i[m]), vL(i, n, m);
      }
    }
    var w = new Tv(i, !1, !1, h ? Ze(v, function(P) {
      return P.targetName === t;
    }) : null);
    w.targetName = t, r.scope && (w.scope = r.scope), d && k && w.whenWithKeys(0, k, p), C && w.whenWithKeys(0, C, p), w.whenWithKeys(u ?? 500, o ? T : n, p).delay(c || 0), e.addAnimator(w, t), s.push(w);
  }
}
var Di = (function(e) {
  Lt(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(i) {
    return this._children[i];
  }, t.prototype.childOfName = function(i) {
    for (var n = this._children, r = 0; r < n.length; r++)
      if (n[r].name === i)
        return n[r];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(i) {
    if (i && (i !== this && i.parent !== this && (this._children.push(i), this._doAdd(i)), process.env.NODE_ENV !== "production" && i.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(i, n) {
    if (i && i !== this && i.parent !== this && n && n.parent === this) {
      var r = this._children, a = r.indexOf(n);
      a >= 0 && (r.splice(a, 0, i), this._doAdd(i));
    }
    return this;
  }, t.prototype.replace = function(i, n) {
    var r = Vt(this._children, i);
    return r >= 0 && this.replaceAt(n, r), this;
  }, t.prototype.replaceAt = function(i, n) {
    var r = this._children, a = r[n];
    if (i && i !== this && i.parent !== this && i !== a) {
      r[n] = i, a.parent = null;
      var s = this.__zr;
      s && a.removeSelfFromZr(s), this._doAdd(i);
    }
    return this;
  }, t.prototype._doAdd = function(i) {
    i.parent && i.parent.remove(i), i.parent = this;
    var n = this.__zr;
    n && n !== i.__zr && i.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(i) {
    var n = this.__zr, r = this._children, a = Vt(r, i);
    return a < 0 ? this : (r.splice(a, 1), i.parent = null, n && i.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var i = this._children, n = this.__zr, r = 0; r < i.length; r++) {
      var a = i[r];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return i.length = 0, this;
  }, t.prototype.eachChild = function(i, n) {
    for (var r = this._children, a = 0; a < r.length; a++) {
      var s = r[a];
      i.call(n, s, a);
    }
    return this;
  }, t.prototype.traverse = function(i, n) {
    for (var r = 0; r < this._children.length; r++) {
      var a = this._children[r], s = i.call(n, a);
      a.isGroup && !s && a.traverse(i, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.addSelfToZr(i);
    }
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.removeSelfFromZr(i);
    }
  }, t.prototype.getBoundingRect = function(i) {
    for (var n = new ot(0, 0, 0, 0), r = i || this._children, a = [], s = null, o = 0; o < r.length; o++) {
      var l = r[o];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (ot.applyTransform(n, u, c), s = s || n.clone(), s.union(n)) : (s = s || u.clone(), s.union(u));
      }
    }
    return s || n;
  }, t;
})(Dc);
Di.prototype.type = "group";
var to = {}, M1 = {};
function mL(e) {
  delete M1[e];
}
function _L(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return Ou(e, 1) < of;
  if (e.colorStops) {
    for (var t = e.colorStops, i = 0, n = t.length, r = 0; r < n; r++)
      i += Ou(t[r].color, 1);
    return i /= n, i < of;
  }
  return !1;
}
var yL = (function() {
  function e(t, i, n) {
    var r = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = i, this.id = t;
    var a = new RE(), s = n.renderer || "canvas";
    if (to[s] || (s = qt(to)[0]), process.env.NODE_ENV !== "production" && !to[s])
      throw new Error("Renderer '" + s + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var o = new to[s](i, a, n, t), l = n.ssr || o.ssrOnly;
    this.storage = a, this.painter = o;
    var u = !st.node && !st.worker && !l ? new oL(o.getViewportRoot(), o.root) : null, c = n.useCoarsePointer, h = c == null || c === "auto" ? st.touchEventsSupported : !!c, d = 44, f;
    h && (f = nt(n.pointerSize, d)), this.handler = new o1(a, o, u, o.root, f), this.animation = new tL({
      stage: {
        update: l ? null : function() {
          return r._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, i) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, i), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = _L(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var i, n = Ha();
    this._needsRefresh && (i = !0, this.refreshImmediately(t)), this._needsRefreshHover && (i = !0, this.refreshHoverImmediately());
    var r = Ha();
    i ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: r - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, i) {
    if (!this._disposed)
      return this.handler.findHover(t, i);
  }, e.prototype.on = function(t, i, n) {
    return this._disposed || this.handler.on(t, i, n), this;
  }, e.prototype.off = function(t, i) {
    this._disposed || this.handler.off(t, i);
  }, e.prototype.trigger = function(t, i) {
    this._disposed || this.handler.trigger(t, i);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), i = 0; i < t.length; i++)
        t[i] instanceof Di && t[i].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, mL(this.id));
  }, e;
})();
function Gm(e, t) {
  var i = new yL(Jb(), e, t);
  return M1[i.id] = i, i;
}
function bL(e, t) {
  to[e] = t;
}
var Xm = 1e-4, k1 = 20;
function xL(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
var Eo = Math.min, Si = Math.max, mn = Math.abs;
function Lo(e, t, i, n) {
  var r = t[0], a = t[1], s = i[0], o = i[1], l = a - r, u = o - s;
  if (l === 0)
    return u === 0 ? s : (s + o) / 2;
  if (l > 0) {
    if (e <= r)
      return s;
    if (e >= a)
      return o;
  } else {
    if (e >= r)
      return s;
    if (e <= a)
      return o;
  }
  return (e - r) / l * u + s;
}
var He = wL;
function wL(e, t, i) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return SL(e, t, i);
}
function SL(e, t, i) {
  return tt(e) ? xL(e).match(/%$/) ? parseFloat(e) / 100 * t + (i || 0) : parseFloat(e) : e == null ? NaN : +e;
}
function ML(e, t, i) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), k1), e = (+e).toFixed(t), i ? e : +e;
}
function jm(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, i = 0; i < 15; i++, t *= 10)
      if (Math.round(e * t) / t === e)
        return i;
  }
  return kL(e);
}
function kL(e) {
  var t = e.toString().toLowerCase(), i = t.indexOf("e"), n = i > 0 ? +t.slice(i + 1) : 0, r = i > 0 ? i : t.length, a = t.indexOf("."), s = a < 0 ? 0 : r - 1 - a;
  return Math.max(0, s - n);
}
function DL(e, t) {
  var i = Math.max(jm(e), jm(t)), n = e + t;
  return i > k1 ? n : ML(n, i);
}
function D1(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function Ru(e) {
  return e > -Xm && e < Xm;
}
var TL = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Tc(e) {
  if (e instanceof Date)
    return e;
  if (tt(e)) {
    var t = TL.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var i = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (i -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, i, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function Nu(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !tt(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function T1(e) {
  return !isNaN(Nu(e));
}
function C1() {
  return Math.round(Math.random() * 9);
}
function A1(e, t) {
  return t === 0 ? e : A1(t, e % t);
}
function qm(e, t) {
  return e == null ? t : t == null ? e : e * t / A1(e, t);
}
var CL = "[ECharts] ", Zm = {}, AL = typeof console < "u" && console.warn && console.log;
function Cc(e, t, i) {
  if (AL) {
    if (i) {
      if (Zm[t])
        return;
      Zm[t] = !0;
    }
    console[e](CL + t);
  }
}
function PL(e, t) {
  Cc("log", e, t);
}
function ui(e, t) {
  Cc("warn", e, t);
}
function Kt(e, t) {
  Cc("error", e, t);
}
function Dn(e) {
  process.env.NODE_ENV !== "production" && Cc("warn", "DEPRECATED: " + e, !0);
}
function ge(e, t, i) {
  process.env.NODE_ENV !== "production" && Dn((i ? "[" + i + "]" : "") + (e + " is deprecated; use " + t + " instead."));
}
function Fu() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var i = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(r) {
      return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : t1(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : mt(r) ? "function () { ... }" : jP(r) ? r + "" : null;
    };
    i = yt(e, function(r) {
      if (tt(r))
        return r;
      var a = n(r);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(r, function(s, o) {
            var l = n(o);
            return l ?? o;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return i;
}
function Ye(e) {
  throw new Error(e);
}
var P1 = "series\0", EL = "\0_ec_\0";
function Ie(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function Km(e, t, i) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var n = 0, r = i.length; n < r; n++) {
      var a = i[n];
      !e.emphasis[t].hasOwnProperty(a) && e[t].hasOwnProperty(a) && (e.emphasis[t][a] = e[t][a]);
    }
  }
}
var Qm = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function jo(e) {
  return Q(e) && !Z(e) && !(e instanceof Date) ? e.value : e;
}
function LL(e) {
  return Q(e) && !(e instanceof Array);
}
function OL(e, t, i) {
  var n = i === "normalMerge", r = i === "replaceMerge", a = i === "replaceAll";
  e = e || [], t = (t || []).slice();
  var s = ct();
  A(t, function(l, u) {
    if (!Q(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !t0(l.id) && Jm(l.id), l.name != null && !t0(l.name) && Jm(l.name));
  });
  var o = IL(e, s, i);
  return (n || r) && RL(o, e, s, t), n && NL(o, t), n || r ? FL(o, t, r) : a && BL(o, t), $L(o), o;
}
function IL(e, t, i) {
  var n = [];
  if (i === "replaceAll")
    return n;
  for (var r = 0; r < e.length; r++) {
    var a = e[r];
    a && a.id != null && t.set(a.id, r), n.push({
      existing: i === "replaceMerge" || os(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function RL(e, t, i, n) {
  A(n, function(r, a) {
    if (!(!r || r.id == null)) {
      var s = po(r.id), o = i.get(s);
      if (o != null) {
        var l = e[o];
        it(!l.newOption, 'Duplicated option on id "' + s + '".'), l.newOption = r, l.existing = t[o], n[a] = null;
      }
    }
  });
}
function NL(e, t) {
  A(t, function(i, n) {
    if (!(!i || i.name == null))
      for (var r = 0; r < e.length; r++) {
        var a = e[r].existing;
        if (!e[r].newOption && a && (a.id == null || i.id == null) && !os(i) && !os(a) && E1("name", a, i)) {
          e[r].newOption = i, t[n] = null;
          return;
        }
      }
  });
}
function FL(e, t, i) {
  A(t, function(n) {
    if (n) {
      for (
        var r, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (r = e[a]) && (r.newOption || os(r.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        r.existing && n.id != null && !E1("id", n, r.existing));
      )
        a++;
      r ? (r.newOption = n, r.brandNew = i) : e.push({
        newOption: n,
        brandNew: i,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function BL(e, t) {
  A(t, function(i) {
    e.push({
      newOption: i,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function $L(e) {
  var t = ct();
  A(e, function(i) {
    var n = i.existing;
    n && t.set(n.id, i);
  }), A(e, function(i) {
    var n = i.newOption;
    it(!n || n.id == null || !t.get(n.id) || t.get(n.id) === i, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, i), !i.keyInfo && (i.keyInfo = {});
  }), A(e, function(i, n) {
    var r = i.existing, a = i.newOption, s = i.keyInfo;
    if (Q(a)) {
      if (s.name = a.name != null ? po(a.name) : r ? r.name : P1 + n, r)
        s.id = po(r.id);
      else if (a.id != null)
        s.id = po(a.id);
      else {
        var o = 0;
        do
          s.id = "\0" + s.name + "\0" + o++;
        while (t.get(s.id));
      }
      t.set(s.id, i);
    }
  });
}
function E1(e, t, i) {
  var n = ki(t[e], null), r = ki(i[e], null);
  return n != null && r != null && n === r;
}
function po(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return ki(e, "");
}
function ki(e, t) {
  return e == null ? t : tt(e) ? e : Zt(e) || ku(e) ? e + "" : t;
}
function Jm(e) {
  process.env.NODE_ENV !== "production" && ui("`" + e + "` is invalid id or name. Must be a string or number.");
}
function t0(e) {
  return ku(e) || T1(e);
}
function L1(e) {
  var t = e.name;
  return !!(t && t.indexOf(P1));
}
function os(e) {
  return e && e.id != null && po(e.id).indexOf(EL) === 0;
}
function zL(e, t, i) {
  A(e, function(n) {
    var r = n.newOption;
    Q(r) && (n.keyInfo.mainType = t, n.keyInfo.subType = VL(t, r, n.existing, i));
  });
}
function VL(e, t, i, n) {
  var r = t.type ? t.type : i ? i.subType : n.determineSubType(e, t);
  return r;
}
function qo(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return Z(t.dataIndex) ? yt(t.dataIndex, function(i) {
      return e.indexOfRawIndex(i);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return Z(t.name) ? yt(t.name, function(i) {
      return e.indexOfName(i);
    }) : e.indexOfName(t.name);
}
function Gt() {
  var e = "__ec_inner_" + HL++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var HL = C1();
function Rh(e, t, i) {
  var n = Cv(t, i), r = n.mainTypeSpecified, a = n.queryOptionMap, s = n.others, o = s, l = i ? i.defaultMainType : null;
  return !r && l && a.set(l, {}), a.each(function(u, c) {
    var h = Zo(e, c, u, {
      useDefault: l === c,
      enableAll: i && i.enableAll != null ? i.enableAll : !0,
      enableNone: i && i.enableNone != null ? i.enableNone : !0
    });
    o[c + "Models"] = h.models, o[c + "Model"] = h.models[0];
  }), o;
}
function Cv(e, t) {
  var i;
  if (tt(e)) {
    var n = {};
    n[e + "Index"] = 0, i = n;
  } else
    i = e;
  var r = ct(), a = {}, s = !1;
  return A(i, function(o, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = o;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || t && t.includeMainTypes && Vt(t.includeMainTypes, c) < 0)) {
      s = s || !!c;
      var d = r.get(c) || r.set(c, {});
      d[h] = o;
    }
  }), {
    mainTypeSpecified: s,
    queryOptionMap: r,
    others: a
  };
}
var zn = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
};
function Zo(e, t, i, n) {
  n = n || zn;
  var r = i.index, a = i.id, s = i.name, o = {
    models: null,
    specified: r != null || a != null || s != null
  };
  if (!o.specified) {
    var l = void 0;
    return o.models = n.useDefault && (l = e.getComponent(t)) ? [l] : [], o;
  }
  if (r === "none" || r === !1) {
    if (n.enableNone)
      return o.models = [], o;
    process.env.NODE_ENV !== "production" && Kt('`"none"` or `false` is not a valid value on index option.'), r = -1;
  }
  return r === "all" && (n.enableAll ? r = a = s = null : (process.env.NODE_ENV !== "production" && Kt('`"all"` is not a valid value on index option.'), r = -1)), o.models = e.queryComponents({
    mainType: t,
    index: r,
    id: a,
    name: s
  }), o;
}
function O1(e, t, i) {
  e.setAttribute ? e.setAttribute(t, i) : e[t] = i;
}
function YL(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function WL(e) {
  return e === "auto" ? st.domSupported ? "html" : "richText" : e || "html";
}
function UL(e, t) {
  var i = ct(), n = [];
  return A(e, function(r) {
    var a = t(r);
    (i.get(a) || (n.push(a), i.set(a, []))).push(r);
  }), {
    keys: n,
    buckets: i
  };
}
var GL = ".", gr = "___EC__COMPONENT__CONTAINER___", I1 = "___EC__EXTENDED_CLASS___";
function Gi(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var i = e.split(GL);
    t.main = i[0] || "", t.sub = i[1] || "";
  }
  return t;
}
function XL(e) {
  it(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function jL(e) {
  return !!(e && e[I1]);
}
function Av(e, t) {
  e.$constructor = e, e.extend = function(i) {
    process.env.NODE_ENV !== "production" && A(t, function(a) {
      i[a] || console.warn("Method `" + a + "` should be implemented" + (i.type ? " in " + i.type : "") + ".");
    });
    var n = this, r;
    return qL(n) ? r = /** @class */
    (function(a) {
      oe(s, a);
      function s() {
        return a.apply(this, arguments) || this;
      }
      return s;
    })(n) : (r = function() {
      (i.$constructor || n).apply(this, arguments);
    }, UP(r, this)), Y(r.prototype, i), r[I1] = !0, r.extend = this.extend, r.superCall = QL, r.superApply = JL, r.superClass = n, r;
  };
}
function qL(e) {
  return mt(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function R1(e, t) {
  e.extend = t.extend;
}
var ZL = Math.round(Math.random() * 10);
function KL(e) {
  var t = ["__\0is_clz", ZL++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && it(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(i) {
    return !!(i && i[t]);
  };
}
function QL(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(e, i);
}
function JL(e, t, i) {
  return this.superClass.prototype[t].apply(e, i);
}
function Pv(e) {
  var t = {};
  e.registerClass = function(n) {
    var r = n.type || n.prototype.type;
    if (r) {
      XL(r), n.prototype.type = r;
      var a = Gi(r);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = n;
      else if (a.sub !== gr) {
        var s = i(a);
        s[a.sub] = n;
      }
    }
    return n;
  }, e.getClass = function(n, r, a) {
    var s = t[n];
    if (s && s[gr] && (s = r ? s[r] : null), a && !s)
      throw new Error(r ? "Component " + n + "." + (r || "") + " is used but not imported." : n + ".type should be specified.");
    return s;
  }, e.getClassesByMainType = function(n) {
    var r = Gi(n), a = [], s = t[r.main];
    return s && s[gr] ? A(s, function(o, l) {
      l !== gr && a.push(o);
    }) : a.push(s), a;
  }, e.hasClass = function(n) {
    var r = Gi(n);
    return !!t[r.main];
  }, e.getAllClassMainTypes = function() {
    var n = [];
    return A(t, function(r, a) {
      n.push(a);
    }), n;
  }, e.hasSubTypes = function(n) {
    var r = Gi(n), a = t[r.main];
    return a && a[gr];
  };
  function i(n) {
    var r = t[n.main];
    return (!r || !r[gr]) && (r = t[n.main] = {}, r[gr] = !0), r;
  }
}
function Oo(e, t) {
  for (var i = 0; i < e.length; i++)
    e[i][1] || (e[i][1] = e[i][0]);
  return t = t || !1, function(n, r, a) {
    for (var s = {}, o = 0; o < e.length; o++) {
      var l = e[o][1];
      if (!(r && Vt(r, l) >= 0 || a && Vt(a, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (s[e[o][0]] = u);
      }
    }
    return s;
  };
}
var tO = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], eO = Oo(tO), iO = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, i) {
      return eO(this, t, i);
    }, e;
  })()
), hf = new as(50);
function nO(e) {
  if (typeof e == "string") {
    var t = hf.get(e);
    return t && t.image;
  } else
    return e;
}
function N1(e, t, i, n, r) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !i)
        return t;
      var a = hf.get(e), s = { hostEl: i, cb: n, cbPayload: r };
      return a ? (t = a.image, !Ac(t) && a.pending.push(s)) : (t = kn.loadImage(e, e0, e0), t.__zrImageSrc = e, hf.put(e, t.__cachedImgObj = {
        image: t,
        pending: [s]
      })), t;
    } else
      return e;
  else return t;
}
function e0() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var i = e.pending[t], n = i.cb;
    n && n(this, i.cbPayload), i.hostEl.dirty();
  }
  e.pending.length = 0;
}
function Ac(e) {
  return e && e.width && e.height;
}
var Nh = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function rO(e, t, i, n, r, a) {
  if (!i) {
    e.text = "", e.isTruncated = !1;
    return;
  }
  var s = (t + "").split(`
`);
  a = F1(i, n, r, a);
  for (var o = !1, l = {}, u = 0, c = s.length; u < c; u++)
    B1(l, s[u], a), s[u] = l.textLine, o = o || l.isTruncated;
  e.text = s.join(`
`), e.isTruncated = o;
}
function F1(e, t, i, n) {
  n = n || {};
  var r = Y({}, n);
  i = nt(i, "..."), r.maxIterations = nt(n.maxIterations, 2);
  var a = r.minChar = nt(n.minChar, 0), s = r.fontMeasureInfo = Zi(t), o = s.asciiCharWidth;
  r.placeholder = nt(n.placeholder, "");
  for (var l = e = Math.max(0, e - 1), u = 0; u < a && l >= o; u++)
    l -= o;
  var c = Ki(s, i);
  return c > l && (i = "", c = 0), l = e - c, r.ellipsis = i, r.ellipsisWidth = c, r.contentWidth = l, r.containerWidth = e, r;
}
function B1(e, t, i) {
  var n = i.containerWidth, r = i.contentWidth, a = i.fontMeasureInfo;
  if (!n) {
    e.textLine = "", e.isTruncated = !1;
    return;
  }
  var s = Ki(a, t);
  if (s <= n) {
    e.textLine = t, e.isTruncated = !1;
    return;
  }
  for (var o = 0; ; o++) {
    if (s <= r || o >= i.maxIterations) {
      t += i.ellipsis;
      break;
    }
    var l = o === 0 ? aO(t, r, a) : s > 0 ? Math.floor(t.length * r / s) : 0;
    t = t.substr(0, l), s = Ki(a, t);
  }
  t === "" && (t = i.placeholder), e.textLine = t, e.isTruncated = !0;
}
function aO(e, t, i) {
  for (var n = 0, r = 0, a = e.length; r < a && n < t; r++)
    n += x1(i, e.charCodeAt(r));
  return r;
}
function sO(e, t, i, n) {
  var r = Ev(e), a = t.overflow, s = t.padding, o = s ? s[1] + s[3] : 0, l = s ? s[0] + s[2] : 0, u = t.font, c = a === "truncate", h = kc(u), d = nt(t.lineHeight, h), f = t.lineOverflow === "truncate", v = !1, p = t.width;
  p == null && i != null && (p = i - o);
  var g = t.height;
  g == null && n != null && (g = n - l);
  var m;
  p != null && (a === "break" || a === "breakAll") ? m = r ? $1(r, t.font, p, a === "breakAll", 0).lines : [] : m = r ? r.split(`
`) : [];
  var _ = m.length * d;
  if (g == null && (g = _), _ > g && f) {
    var y = Math.floor(g / d);
    v = v || m.length > y, m = m.slice(0, y), _ = m.length * d;
  }
  if (r && c && p != null)
    for (var b = F1(p, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), w = {}, S = 0; S < m.length; S++)
      B1(w, m[S], b), m[S] = w.textLine, v = v || w.isTruncated;
  for (var M = g, k = 0, T = Zi(u), S = 0; S < m.length; S++)
    k = Math.max(Ki(T, m[S]), k);
  p == null && (p = k);
  var C = p;
  return M += l, C += o, {
    lines: m,
    height: g,
    outerWidth: C,
    outerHeight: M,
    lineHeight: d,
    calculatedLineHeight: h,
    contentWidth: k,
    contentHeight: _,
    width: p,
    isTruncated: v
  };
}
var oO = /* @__PURE__ */ (function() {
  function e() {
  }
  return e;
})(), i0 = /* @__PURE__ */ (function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
})(), lO = /* @__PURE__ */ (function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return e;
})();
function uO(e, t, i, n, r) {
  var a = new lO(), s = Ev(e);
  if (!s)
    return a;
  var o = t.padding, l = o ? o[1] + o[3] : 0, u = o ? o[0] + o[2] : 0, c = t.width;
  c == null && i != null && (c = i - l);
  var h = t.height;
  h == null && n != null && (h = n - u);
  for (var d = t.overflow, f = (d === "break" || d === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: d === "breakAll" } : null, v = Nh.lastIndex = 0, p; (p = Nh.exec(s)) != null; ) {
    var g = p.index;
    g > v && Fh(a, s.substring(v, g), t, f), Fh(a, p[2], t, f, p[1]), v = Nh.lastIndex;
  }
  v < s.length && Fh(a, s.substring(v, s.length), t, f);
  var m = [], _ = 0, y = 0, b = d === "truncate", w = t.lineOverflow === "truncate", S = {};
  function M(Tt, me, Pe) {
    Tt.width = me, Tt.lineHeight = Pe, _ += Pe, y = Math.max(y, me);
  }
  t: for (var k = 0; k < a.lines.length; k++) {
    for (var T = a.lines[k], C = 0, D = 0, P = 0; P < T.tokens.length; P++) {
      var O = T.tokens[P], I = O.styleName && t.rich[O.styleName] || {}, N = O.textPadding = I.padding, F = N ? N[1] + N[3] : 0, q = O.font = I.font || t.font;
      O.contentHeight = kc(q);
      var V = nt(I.height, O.contentHeight);
      if (O.innerHeight = V, N && (V += N[0] + N[2]), O.height = V, O.lineHeight = Zr(I.lineHeight, t.lineHeight, V), O.align = I && I.align || r, O.verticalAlign = I && I.verticalAlign || "middle", w && h != null && _ + O.lineHeight > h) {
        var B = a.lines.length;
        P > 0 ? (T.tokens = T.tokens.slice(0, P), M(T, D, C), a.lines = a.lines.slice(0, k + 1)) : a.lines = a.lines.slice(0, k), a.isTruncated = a.isTruncated || a.lines.length < B;
        break t;
      }
      var $ = I.width, j = $ == null || $ === "auto";
      if (typeof $ == "string" && $.charAt($.length - 1) === "%")
        O.percentWidth = $, m.push(O), O.contentWidth = Ki(Zi(q), O.text);
      else {
        if (j) {
          var G = I.backgroundColor, et = G && G.image;
          et && (et = nO(et), Ac(et) && (O.width = Math.max(O.width, et.width * V / et.height)));
        }
        var at = b && c != null ? c - D : null;
        at != null && at < O.width ? !j || at < F ? (O.text = "", O.width = O.contentWidth = 0) : (rO(S, O.text, at - F, q, t.ellipsis, { minChar: t.truncateMinChar }), O.text = S.text, a.isTruncated = a.isTruncated || S.isTruncated, O.width = O.contentWidth = Ki(Zi(q), O.text)) : O.contentWidth = Ki(Zi(q), O.text);
      }
      O.width += F, D += O.width, I && (C = Math.max(C, O.lineHeight));
    }
    M(T, D, C);
  }
  a.outerWidth = a.width = nt(c, y), a.outerHeight = a.height = nt(h, _), a.contentHeight = _, a.contentWidth = y, a.outerWidth += l, a.outerHeight += u;
  for (var k = 0; k < m.length; k++) {
    var O = m[k], wt = O.percentWidth;
    O.width = parseInt(wt, 10) / 100 * a.width;
  }
  return a;
}
function Fh(e, t, i, n, r) {
  var a = t === "", s = r && i.rich[r] || {}, o = e.lines, l = s.font || i.font, u = !1, c, h;
  if (n) {
    var d = s.padding, f = d ? d[1] + d[3] : 0;
    if (s.width != null && s.width !== "auto") {
      var v = Po(s.width, n.width) + f;
      o.length > 0 && v + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = v;
    } else {
      var p = $1(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = p.accumWidth + f, h = p.linesWidths, c = p.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var g = Zi(l), m = 0; m < c.length; m++) {
    var _ = c[m], y = new oO();
    if (y.styleName = r, y.text = _, y.isLineHolder = !_ && !a, typeof s.width == "number" ? y.width = s.width : y.width = h ? h[m] : Ki(g, _), !m && !u) {
      var b = (o[o.length - 1] || (o[0] = new i0())).tokens, w = b.length;
      w === 1 && b[0].isLineHolder ? b[0] = y : (_ || !w || a) && b.push(y);
    } else
      o.push(new i0([y]));
  }
}
function cO(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var hO = fs(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function dO(e) {
  return cO(e) ? !!hO[e] : !0;
}
function $1(e, t, i, n, r) {
  for (var a = [], s = [], o = "", l = "", u = 0, c = 0, h = Zi(t), d = 0; d < e.length; d++) {
    var f = e.charAt(d);
    if (f === `
`) {
      l && (o += l, c += u), a.push(o), s.push(c), o = "", l = "", u = 0, c = 0;
      continue;
    }
    var v = x1(h, f.charCodeAt(0)), p = n ? !1 : !dO(f);
    if (a.length ? c + v > i : r + c + v > i) {
      c ? (o || l) && (p ? (o || (o = l, l = "", u = 0, c = u), a.push(o), s.push(c - u), l += f, u += v, o = "", c = u) : (l && (o += l, l = "", u = 0), a.push(o), s.push(c), o = f, c = v)) : p ? (a.push(l), s.push(u), l = f, u = v) : (a.push(f), s.push(v));
      continue;
    }
    c += v, p ? (l += f, u += v) : (l && (o += l, l = "", u = 0), o += f);
  }
  return l && (o += l), o && (a.push(o), s.push(c)), a.length === 1 && (c += r), {
    accumWidth: c,
    lines: a,
    linesWidths: s
  };
}
function n0(e, t, i, n, r, a) {
  if (e.baseX = i, e.baseY = n, e.outerWidth = e.outerHeight = null, !!t) {
    var s = t.width * 2, o = t.height * 2;
    ot.set(r0, ss(i, s, r), Jr(n, o, a), s, o), ot.intersect(t, r0, null, a0);
    var l = a0.outIntersectRect;
    e.outerWidth = l.width, e.outerHeight = l.height, e.baseX = ss(l.x, l.width, r, !0), e.baseY = Jr(l.y, l.height, a, !0);
  }
}
var r0 = new ot(0, 0, 0, 0), a0 = { outIntersectRect: {}, clamp: !0 };
function Ev(e) {
  return e != null ? e += "" : e = "";
}
function fO(e) {
  var t = Ev(e.text), i = e.font, n = Ki(Zi(i), t), r = kc(i);
  return df(e, n, r, null);
}
function df(e, t, i, n) {
  var r = new ot(ss(e.x || 0, t, e.textAlign), Jr(e.y || 0, i, e.textBaseline), t, i), a = n ?? (z1(e) ? e.lineWidth : 0);
  return a > 0 && (r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a), r;
}
function z1(e) {
  var t = e.stroke;
  return t != null && t !== "none" && e.lineWidth > 0;
}
var ff = "__zr_style_" + Math.round(Math.random() * 10), ta = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, Pc = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
ta[ff] = !0;
var s0 = ["z", "z2", "invisible"], vO = ["invisible"], Ko = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype._init = function(i) {
    for (var n = qt(i), r = 0; r < n.length; r++) {
      var a = n[r];
      a === "style" ? this.useStyle(i[a]) : e.prototype.attrKV.call(this, a, i[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(i, n, r, a) {
    var s = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && pO(this, i, n) || s && !s[0] && !s[3])
      return !1;
    if (r && this.__clipPaths && this.__clipPaths.length) {
      for (var o = 0; o < this.__clipPaths.length; ++o)
        if (this.__clipPaths[o].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(i, n) {
    return this.rectContain(i, n);
  }, t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.rectContain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    return a.contain(r[0], r[1]);
  }, t.prototype.getPaintRect = function() {
    var i = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, r = this.getBoundingRect(), a = this.style, s = a.shadowBlur || 0, o = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      i = this._paintRect || (this._paintRect = new ot(0, 0, 0, 0)), n ? ot.applyTransform(i, r, n) : i.copy(r), (s || o || l) && (i.width += s * 2 + Math.abs(o), i.height += s * 2 + Math.abs(l), i.x = Math.min(i.x, i.x + o - s), i.y = Math.min(i.y, i.y + l - s));
      var u = this.dirtyRectTolerance;
      i.isZero() || (i.x = Math.floor(i.x - u), i.y = Math.floor(i.y - u), i.width = Math.ceil(i.width + 1 + u * 2), i.height = Math.ceil(i.height + 1 + u * 2));
    }
    return i;
  }, t.prototype.setPrevPaintRect = function(i) {
    i ? (this._prevPaintRect = this._prevPaintRect || new ot(0, 0, 0, 0), this._prevPaintRect.copy(i)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(i) {
    return this.animate("style", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i !== "style" ? e.prototype.attrKV.call(this, i, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(i, n) {
    return typeof i == "string" ? this.style[i] = n : Y(this.style, i), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(i) {
    i || this.markRedraw(), this.__dirty |= Qs, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & Qs);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~Qs;
  }, t.prototype.createStyle = function(i) {
    return Mc(ta, i);
  }, t.prototype.useStyle = function(i) {
    i[ff] || (i = this.createStyle(i)), this.__inHover ? this.__hoverStyle = i : this.style = i, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(i) {
    return i[ff];
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(i, n, s0);
  }, t.prototype._applyStateObj = function(i, n, r, a, s, o) {
    e.prototype._applyStateObj.call(this, i, n, r, a, s, o);
    var l = !(n && a), u;
    if (n && n.style ? s ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, n.style)) : l && (u = r.style), u)
      if (s) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = qt(c), d = 0; d < h.length; d++) {
            var f = h[d];
            f in u && (u[f] = u[f], this.style[f] = c[f]);
          }
        for (var v = qt(u), d = 0; d < v.length; d++) {
          var f = v[d];
          this.style[f] = this.style[f];
        }
        this._transitionState(i, {
          style: u
        }, o, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var p = this.__inHover ? vO : s0, d = 0; d < p.length; d++) {
      var f = p[d];
      n && n[f] != null ? this[f] = n[f] : l && r[f] != null && (this[f] = r[f]);
    }
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var s = i[a];
      s.style && (r = r || {}, this._mergeStyle(r, s.style));
    }
    return r && (n.style = r), n;
  }, t.prototype._mergeStyle = function(i, n) {
    return Y(i, n), i;
  }, t.prototype.getAnimationStyleProps = function() {
    return Pc;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "displayable", i.invisible = !1, i.z = 0, i.z2 = 0, i.zlevel = 0, i.culling = !1, i.cursor = "pointer", i.rectHover = !1, i.incremental = !1, i._rect = null, i.dirtyRectTolerance = 0, i.__dirty = Ke | Qs;
  })(), t;
})(Dc), Bh = new ot(0, 0, 0, 0), $h = new ot(0, 0, 0, 0);
function pO(e, t, i) {
  return Bh.copy(e.getBoundingRect()), e.transform && Bh.applyTransform(e.transform), $h.width = t, $h.height = i, !Bh.intersect($h);
}
var ci = Math.min, hi = Math.max, zh = Math.sin, Vh = Math.cos, mr = Math.PI * 2, kl = vs(), Dl = vs(), Tl = vs();
function o0(e, t, i, n, r, a) {
  r[0] = ci(e, i), r[1] = ci(t, n), a[0] = hi(e, i), a[1] = hi(t, n);
}
var l0 = [], u0 = [];
function gO(e, t, i, n, r, a, s, o, l, u) {
  var c = f1, h = Le, d = c(e, i, r, s, l0);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var f = 0; f < d; f++) {
    var v = h(e, i, r, s, l0[f]);
    l[0] = ci(v, l[0]), u[0] = hi(v, u[0]);
  }
  d = c(t, n, a, o, u0);
  for (var f = 0; f < d; f++) {
    var p = h(t, n, a, o, u0[f]);
    l[1] = ci(p, l[1]), u[1] = hi(p, u[1]);
  }
  l[0] = ci(e, l[0]), u[0] = hi(e, u[0]), l[0] = ci(s, l[0]), u[0] = hi(s, u[0]), l[1] = ci(t, l[1]), u[1] = hi(t, u[1]), l[1] = ci(o, l[1]), u[1] = hi(o, u[1]);
}
function mO(e, t, i, n, r, a, s, o) {
  var l = v1, u = Ve, c = hi(ci(l(e, i, r), 1), 0), h = hi(ci(l(t, n, a), 1), 0), d = u(e, i, r, c), f = u(t, n, a, h);
  s[0] = ci(e, r, d), s[1] = ci(t, a, f), o[0] = hi(e, r, d), o[1] = hi(t, a, f);
}
function _O(e, t, i, n, r, a, s, o, l) {
  var u = $a, c = za, h = Math.abs(r - a);
  if (h % mr < 1e-4 && h > 1e-4) {
    o[0] = e - i, o[1] = t - n, l[0] = e + i, l[1] = t + n;
    return;
  }
  if (kl[0] = Vh(r) * i + e, kl[1] = zh(r) * n + t, Dl[0] = Vh(a) * i + e, Dl[1] = zh(a) * n + t, u(o, kl, Dl), c(l, kl, Dl), r = r % mr, r < 0 && (r = r + mr), a = a % mr, a < 0 && (a = a + mr), r > a && !s ? a += mr : r < a && s && (r += mr), s) {
    var d = a;
    a = r, r = d;
  }
  for (var f = 0; f < a; f += Math.PI / 2)
    f > r && (Tl[0] = Vh(f) * i + e, Tl[1] = zh(f) * n + t, u(o, Tl, o), c(l, Tl, l));
}
var Mt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, _r = [], yr = [], Ni = [], On = [], Fi = [], Bi = [], Hh = Math.min, Yh = Math.max, br = Math.cos, xr = Math.sin, an = Math.abs, vf = Math.PI, Bn = vf * 2, Wh = typeof Float32Array < "u", Ts = [];
function Uh(e) {
  var t = Math.round(e / vf * 1e8) / 1e8;
  return t % 2 * vf;
}
function yO(e, t) {
  var i = Uh(e[0]);
  i < 0 && (i += Bn);
  var n = i - e[0], r = e[1];
  r += n, !t && r - i >= Bn ? r = i + Bn : t && i - r >= Bn ? r = i - Bn : !t && i > r ? r = i + (Bn - Uh(i - r)) : t && i < r && (r = i - (Bn - Uh(r - i))), e[0] = i, e[1] = r;
}
var ls = (function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, i, n) {
    n = n || 0, n > 0 && (this._ux = an(n / Iu / t) || 0, this._uy = an(n / Iu / i) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, i) {
    return this._drawPendingPt(), this.addData(Mt.M, t, i), this._ctx && this._ctx.moveTo(t, i), this._x0 = t, this._y0 = i, this._xi = t, this._yi = i, this;
  }, e.prototype.lineTo = function(t, i) {
    var n = an(t - this._xi), r = an(i - this._yi), a = n > this._ux || r > this._uy;
    if (this.addData(Mt.L, t, i), this._ctx && a && this._ctx.lineTo(t, i), a)
      this._xi = t, this._yi = i, this._pendingPtDist = 0;
    else {
      var s = n * n + r * r;
      s > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = i, this._pendingPtDist = s);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, i, n, r, a, s) {
    return this._drawPendingPt(), this.addData(Mt.C, t, i, n, r, a, s), this._ctx && this._ctx.bezierCurveTo(t, i, n, r, a, s), this._xi = a, this._yi = s, this;
  }, e.prototype.quadraticCurveTo = function(t, i, n, r) {
    return this._drawPendingPt(), this.addData(Mt.Q, t, i, n, r), this._ctx && this._ctx.quadraticCurveTo(t, i, n, r), this._xi = n, this._yi = r, this;
  }, e.prototype.arc = function(t, i, n, r, a, s) {
    this._drawPendingPt(), Ts[0] = r, Ts[1] = a, yO(Ts, s), r = Ts[0], a = Ts[1];
    var o = a - r;
    return this.addData(Mt.A, t, i, n, n, r, o, 0, s ? 0 : 1), this._ctx && this._ctx.arc(t, i, n, r, a, s), this._xi = br(a) * n + t, this._yi = xr(a) * n + i, this;
  }, e.prototype.arcTo = function(t, i, n, r, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, i, n, r, a), this;
  }, e.prototype.rect = function(t, i, n, r) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, i, n, r), this.addData(Mt.R, t, i, n, r), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Mt.Z);
    var t = this._ctx, i = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = i, this._yi = n, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    if (this._saveData) {
      var i = t.length;
      !(this.data && this.data.length === i) && Wh && (this.data = new Float32Array(i));
      for (var n = 0; n < i; n++)
        this.data[n] = t[n];
      this._len = i;
    }
  }, e.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var i = t.length, n = 0, r = this._len, a = 0; a < i; a++)
        n += t[a].len();
      var s = this.data;
      if (Wh && (s instanceof Float32Array || !s) && (this.data = new Float32Array(r + n), r > 0 && s))
        for (var o = 0; o < r; o++)
          this.data[o] = s[o];
      for (var a = 0; a < i; a++)
        for (var l = t[a].data, o = 0; o < l.length; o++)
          this.data[r++] = l[o];
      this._len = r;
    }
  }, e.prototype.addData = function(t, i, n, r, a, s, o, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], i = 0; i < this._len; i++)
        t[i] = this.data[i];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, Wh && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    Ni[0] = Ni[1] = Fi[0] = Fi[1] = Number.MAX_VALUE, On[0] = On[1] = Bi[0] = Bi[1] = -Number.MAX_VALUE;
    var t = this.data, i = 0, n = 0, r = 0, a = 0, s;
    for (s = 0; s < this._len; ) {
      var o = t[s++], l = s === 1;
      switch (l && (i = t[s], n = t[s + 1], r = i, a = n), o) {
        case Mt.M:
          i = r = t[s++], n = a = t[s++], Fi[0] = r, Fi[1] = a, Bi[0] = r, Bi[1] = a;
          break;
        case Mt.L:
          o0(i, n, t[s], t[s + 1], Fi, Bi), i = t[s++], n = t[s++];
          break;
        case Mt.C:
          gO(i, n, t[s++], t[s++], t[s++], t[s++], t[s], t[s + 1], Fi, Bi), i = t[s++], n = t[s++];
          break;
        case Mt.Q:
          mO(i, n, t[s++], t[s++], t[s], t[s + 1], Fi, Bi), i = t[s++], n = t[s++];
          break;
        case Mt.A:
          var u = t[s++], c = t[s++], h = t[s++], d = t[s++], f = t[s++], v = t[s++] + f;
          s += 1;
          var p = !t[s++];
          l && (r = br(f) * h + u, a = xr(f) * d + c), _O(u, c, h, d, f, v, p, Fi, Bi), i = br(v) * h + u, n = xr(v) * d + c;
          break;
        case Mt.R:
          r = i = t[s++], a = n = t[s++];
          var g = t[s++], m = t[s++];
          o0(r, a, r + g, a + m, Fi, Bi);
          break;
        case Mt.Z:
          i = r, n = a;
          break;
      }
      $a(Ni, Ni, Fi), za(On, On, Bi);
    }
    return s === 0 && (Ni[0] = Ni[1] = On[0] = On[1] = 0), new ot(Ni[0], Ni[1], On[0] - Ni[0], On[1] - Ni[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, i = this._len, n = this._ux, r = this._uy, a = 0, s = 0, o = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, d = 0; d < i; ) {
      var f = t[d++], v = d === 1;
      v && (a = t[d], s = t[d + 1], o = a, l = s);
      var p = -1;
      switch (f) {
        case Mt.M:
          a = o = t[d++], s = l = t[d++];
          break;
        case Mt.L: {
          var g = t[d++], m = t[d++], _ = g - a, y = m - s;
          (an(_) > n || an(y) > r || d === i - 1) && (p = Math.sqrt(_ * _ + y * y), a = g, s = m);
          break;
        }
        case Mt.C: {
          var b = t[d++], w = t[d++], g = t[d++], m = t[d++], S = t[d++], M = t[d++];
          p = FE(a, s, b, w, g, m, S, M, 10), a = S, s = M;
          break;
        }
        case Mt.Q: {
          var b = t[d++], w = t[d++], g = t[d++], m = t[d++];
          p = zE(a, s, b, w, g, m, 10), a = g, s = m;
          break;
        }
        case Mt.A:
          var k = t[d++], T = t[d++], C = t[d++], D = t[d++], P = t[d++], O = t[d++], I = O + P;
          d += 1, v && (o = br(P) * C + k, l = xr(P) * D + T), p = Yh(C, D) * Hh(Bn, Math.abs(O)), a = br(I) * C + k, s = xr(I) * D + T;
          break;
        case Mt.R: {
          o = a = t[d++], l = s = t[d++];
          var N = t[d++], F = t[d++];
          p = N * 2 + F * 2;
          break;
        }
        case Mt.Z: {
          var _ = o - a, y = l - s;
          p = Math.sqrt(_ * _ + y * y), a = o, s = l;
          break;
        }
      }
      p >= 0 && (u[h++] = p, c += p);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, i) {
    var n = this.data, r = this._ux, a = this._uy, s = this._len, o, l, u, c, h, d, f = i < 1, v, p, g = 0, m = 0, _, y = 0, b, w;
    if (!(f && (this._pathSegLen || this._calculateLength(), v = this._pathSegLen, p = this._pathLen, _ = i * p, !_)))
      t: for (var S = 0; S < s; ) {
        var M = n[S++], k = S === 1;
        switch (k && (u = n[S], c = n[S + 1], o = u, l = c), M !== Mt.L && y > 0 && (t.lineTo(b, w), y = 0), M) {
          case Mt.M:
            o = u = n[S++], l = c = n[S++], t.moveTo(u, c);
            break;
          case Mt.L: {
            h = n[S++], d = n[S++];
            var T = an(h - u), C = an(d - c);
            if (T > r || C > a) {
              if (f) {
                var D = v[m++];
                if (g + D > _) {
                  var P = (_ - g) / D;
                  t.lineTo(u * (1 - P) + h * P, c * (1 - P) + d * P);
                  break t;
                }
                g += D;
              }
              t.lineTo(h, d), u = h, c = d, y = 0;
            } else {
              var O = T * T + C * C;
              O > y && (b = h, w = d, y = O);
            }
            break;
          }
          case Mt.C: {
            var I = n[S++], N = n[S++], F = n[S++], q = n[S++], V = n[S++], B = n[S++];
            if (f) {
              var D = v[m++];
              if (g + D > _) {
                var P = (_ - g) / D;
                Pu(u, I, F, V, P, _r), Pu(c, N, q, B, P, yr), t.bezierCurveTo(_r[1], yr[1], _r[2], yr[2], _r[3], yr[3]);
                break t;
              }
              g += D;
            }
            t.bezierCurveTo(I, N, F, q, V, B), u = V, c = B;
            break;
          }
          case Mt.Q: {
            var I = n[S++], N = n[S++], F = n[S++], q = n[S++];
            if (f) {
              var D = v[m++];
              if (g + D > _) {
                var P = (_ - g) / D;
                Eu(u, I, F, P, _r), Eu(c, N, q, P, yr), t.quadraticCurveTo(_r[1], yr[1], _r[2], yr[2]);
                break t;
              }
              g += D;
            }
            t.quadraticCurveTo(I, N, F, q), u = F, c = q;
            break;
          }
          case Mt.A:
            var $ = n[S++], j = n[S++], G = n[S++], et = n[S++], at = n[S++], wt = n[S++], Tt = n[S++], me = !n[S++], Pe = G > et ? G : et, Pt = an(G - et) > 1e-3, Nt = at + wt, rt = !1;
            if (f) {
              var D = v[m++];
              g + D > _ && (Nt = at + wt * (_ - g) / D, rt = !0), g += D;
            }
            if (Pt && t.ellipse ? t.ellipse($, j, G, et, Tt, at, Nt, me) : t.arc($, j, Pe, at, Nt, me), rt)
              break t;
            k && (o = br(at) * G + $, l = xr(at) * et + j), u = br(Nt) * G + $, c = xr(Nt) * et + j;
            break;
          case Mt.R:
            o = u = n[S], l = c = n[S + 1], h = n[S++], d = n[S++];
            var ft = n[S++], Ii = n[S++];
            if (f) {
              var D = v[m++];
              if (g + D > _) {
                var le = _ - g;
                t.moveTo(h, d), t.lineTo(h + Hh(le, ft), d), le -= ft, le > 0 && t.lineTo(h + ft, d + Hh(le, Ii)), le -= Ii, le > 0 && t.lineTo(h + Yh(ft - le, 0), d + Ii), le -= ft, le > 0 && t.lineTo(h, d + Yh(Ii - le, 0));
                break t;
              }
              g += D;
            }
            t.rect(h, d, ft, Ii);
            break;
          case Mt.Z:
            if (f) {
              var D = v[m++];
              if (g + D > _) {
                var P = (_ - g) / D;
                t.lineTo(u * (1 - P) + o * P, c * (1 - P) + l * P);
                break t;
              }
              g += D;
            }
            t.closePath(), u = o, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), i = this.data;
    return t.data = i.slice ? i.slice() : Array.prototype.slice.call(i), t._len = this._len, t;
  }, e.prototype.canSave = function() {
    return !!this._saveData;
  }, e.CMD = Mt, e.initDefaultProps = (function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  })(), e;
})();
function wa(e, t, i, n, r, a, s) {
  if (r === 0)
    return !1;
  var o = r, l = 0, u = e;
  if (s > t + o && s > n + o || s < t - o && s < n - o || a > e + o && a > i + o || a < e - o && a < i - o)
    return !1;
  if (e !== i)
    l = (t - n) / (e - i), u = (e * n - i * t) / (e - i);
  else
    return Math.abs(a - e) <= o / 2;
  var c = l * a - s + u, h = c * c / (l * l + 1);
  return h <= o / 2 * o / 2;
}
function bO(e, t, i, n, r, a, s, o, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > t + h && c > n + h && c > a + h && c > o + h || c < t - h && c < n - h && c < a - h && c < o - h || u > e + h && u > i + h && u > r + h && u > s + h || u < e - h && u < i - h && u < r - h && u < s - h)
    return !1;
  var d = NE(e, t, i, n, r, a, s, o, u, c);
  return d <= h / 2;
}
function xO(e, t, i, n, r, a, s, o, l) {
  if (s === 0)
    return !1;
  var u = s;
  if (l > t + u && l > n + u && l > a + u || l < t - u && l < n - u && l < a - u || o > e + u && o > i + u && o > r + u || o < e - u && o < i - u && o < r - u)
    return !1;
  var c = $E(e, t, i, n, r, a, o, l);
  return c <= u / 2;
}
var c0 = Math.PI * 2;
function Cl(e) {
  return e %= c0, e < 0 && (e += c0), e;
}
var Cs = Math.PI * 2;
function wO(e, t, i, n, r, a, s, o, l) {
  if (s === 0)
    return !1;
  var u = s;
  o -= e, l -= t;
  var c = Math.sqrt(o * o + l * l);
  if (c - u > i || c + u < i)
    return !1;
  if (Math.abs(n - r) % Cs < 1e-4)
    return !0;
  if (a) {
    var h = n;
    n = Cl(r), r = Cl(h);
  } else
    n = Cl(n), r = Cl(r);
  n > r && (r += Cs);
  var d = Math.atan2(l, o);
  return d < 0 && (d += Cs), d >= n && d <= r || d + Cs >= n && d + Cs <= r;
}
function wr(e, t, i, n, r, a) {
  if (a > t && a > n || a < t && a < n || n === t)
    return 0;
  var s = (a - t) / (n - t), o = n < t ? 1 : -1;
  (s === 1 || s === 0) && (o = n < t ? 0.5 : -0.5);
  var l = s * (i - e) + e;
  return l === r ? 1 / 0 : l > r ? o : 0;
}
var In = ls.CMD, Sr = Math.PI * 2, SO = 1e-4;
function MO(e, t) {
  return Math.abs(e - t) < SO;
}
var Ee = [-1, -1, -1], oi = [-1, -1];
function kO() {
  var e = oi[0];
  oi[0] = oi[1], oi[1] = e;
}
function DO(e, t, i, n, r, a, s, o, l, u) {
  if (u > t && u > n && u > a && u > o || u < t && u < n && u < a && u < o)
    return 0;
  var c = d1(t, n, a, o, u, Ee);
  if (c === 0)
    return 0;
  for (var h = 0, d = -1, f = void 0, v = void 0, p = 0; p < c; p++) {
    var g = Ee[p], m = g === 0 || g === 1 ? 0.5 : 1, _ = Le(e, i, r, s, g);
    _ < l || (d < 0 && (d = f1(t, n, a, o, oi), oi[1] < oi[0] && d > 1 && kO(), f = Le(t, n, a, o, oi[0]), d > 1 && (v = Le(t, n, a, o, oi[1]))), d === 2 ? g < oi[0] ? h += f < t ? m : -m : g < oi[1] ? h += v < f ? m : -m : h += o < v ? m : -m : g < oi[0] ? h += f < t ? m : -m : h += o < f ? m : -m);
  }
  return h;
}
function TO(e, t, i, n, r, a, s, o) {
  if (o > t && o > n && o > a || o < t && o < n && o < a)
    return 0;
  var l = BE(t, n, a, o, Ee);
  if (l === 0)
    return 0;
  var u = v1(t, n, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = Ve(t, n, a, u), d = 0; d < l; d++) {
      var f = Ee[d] === 0 || Ee[d] === 1 ? 0.5 : 1, v = Ve(e, i, r, Ee[d]);
      v < s || (Ee[d] < u ? c += h < t ? f : -f : c += a < h ? f : -f);
    }
    return c;
  } else {
    var f = Ee[0] === 0 || Ee[0] === 1 ? 0.5 : 1, v = Ve(e, i, r, Ee[0]);
    return v < s ? 0 : a < t ? f : -f;
  }
}
function CO(e, t, i, n, r, a, s, o) {
  if (o -= t, o > i || o < -i)
    return 0;
  var l = Math.sqrt(i * i - o * o);
  Ee[0] = -l, Ee[1] = l;
  var u = Math.abs(n - r);
  if (u < 1e-4)
    return 0;
  if (u >= Sr - 1e-4) {
    n = 0, r = Sr;
    var c = a ? 1 : -1;
    return s >= Ee[0] + e && s <= Ee[1] + e ? c : 0;
  }
  if (n > r) {
    var h = n;
    n = r, r = h;
  }
  n < 0 && (n += Sr, r += Sr);
  for (var d = 0, f = 0; f < 2; f++) {
    var v = Ee[f];
    if (v + e > s) {
      var p = Math.atan2(o, v), c = a ? 1 : -1;
      p < 0 && (p = Sr + p), (p >= n && p <= r || p + Sr >= n && p + Sr <= r) && (p > Math.PI / 2 && p < Math.PI * 1.5 && (c = -c), d += c);
    }
  }
  return d;
}
function V1(e, t, i, n, r) {
  for (var a = e.data, s = e.len(), o = 0, l = 0, u = 0, c = 0, h = 0, d, f, v = 0; v < s; ) {
    var p = a[v++], g = v === 1;
    switch (p === In.M && v > 1 && (i || (o += wr(l, u, c, h, n, r))), g && (l = a[v], u = a[v + 1], c = l, h = u), p) {
      case In.M:
        c = a[v++], h = a[v++], l = c, u = h;
        break;
      case In.L:
        if (i) {
          if (wa(l, u, a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += wr(l, u, a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case In.C:
        if (i) {
          if (bO(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += DO(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case In.Q:
        if (i) {
          if (xO(l, u, a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += TO(l, u, a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case In.A:
        var m = a[v++], _ = a[v++], y = a[v++], b = a[v++], w = a[v++], S = a[v++];
        v += 1;
        var M = !!(1 - a[v++]);
        d = Math.cos(w) * y + m, f = Math.sin(w) * b + _, g ? (c = d, h = f) : o += wr(l, u, d, f, n, r);
        var k = (n - m) * b / y + m;
        if (i) {
          if (wO(m, _, b, w, w + S, M, t, k, r))
            return !0;
        } else
          o += CO(m, _, b, w, w + S, M, k, r);
        l = Math.cos(w + S) * y + m, u = Math.sin(w + S) * b + _;
        break;
      case In.R:
        c = l = a[v++], h = u = a[v++];
        var T = a[v++], C = a[v++];
        if (d = c + T, f = h + C, i) {
          if (wa(c, h, d, h, t, n, r) || wa(d, h, d, f, t, n, r) || wa(d, f, c, f, t, n, r) || wa(c, f, c, h, t, n, r))
            return !0;
        } else
          o += wr(d, h, d, f, n, r), o += wr(c, f, c, h, n, r);
        break;
      case In.Z:
        if (i) {
          if (wa(l, u, c, h, t, n, r))
            return !0;
        } else
          o += wr(l, u, c, h, n, r);
        l = c, u = h;
        break;
    }
  }
  return !i && !MO(u, h) && (o += wr(l, u, c, h, n, r) || 0), o !== 0;
}
function AO(e, t, i) {
  return V1(e, 0, !1, t, i);
}
function PO(e, t, i, n) {
  return V1(e, t, !0, i, n);
}
var H1 = Jt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, ta), EO = {
  style: Jt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, Pc.style)
}, Gh = Ao.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), Bt = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.update = function() {
    var i = this;
    e.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var r = this._decalEl = this._decalEl || new t();
      r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
        i.buildPath(l, i.shape);
      }), r.silent = !0;
      var a = r.style;
      for (var s in n)
        a[s] !== n[s] && (a[s] = n[s]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var o = 0; o < Gh.length; ++o)
        r[Gh[o]] = this[Gh[o]];
      r.__dirty |= Ke;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(i) {
    var n = qt(i);
    this.shape = this.getDefaultShape();
    var r = this.getDefaultStyle();
    r && this.useStyle(r);
    for (var a = 0; a < n.length; a++) {
      var s = n[a], o = i[s];
      s === "style" ? this.style ? Y(this.style, o) : this.useStyle(o) : s === "shape" ? Y(this.shape, o) : e.prototype.attrKV.call(this, s, o);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var i = this.style.fill;
    if (i !== "none") {
      if (tt(i)) {
        var n = Ou(i, 0);
        return n > 0.5 ? lf : n > 0.2 ? lL : uf;
      } else if (i)
        return uf;
    }
    return lf;
  }, t.prototype.getInsideTextStroke = function(i) {
    var n = this.style.fill;
    if (tt(n)) {
      var r = this.__zr, a = !!(r && r.isDarkMode()), s = Ou(i, 0) < of;
      if (a === s)
        return n;
    }
  }, t.prototype.buildPath = function(i, n, r) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~Fa;
  }, t.prototype.getUpdatedPathProxy = function(i) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, i), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new ls(!1);
  }, t.prototype.hasStroke = function() {
    var i = this.style, n = i.stroke;
    return !(n == null || n === "none" || !(i.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var i = this._rect, n = this.style, r = !i;
    if (r) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var s = this.path;
      (a || this.__dirty & Fa) && (s.beginPath(), this.buildPath(s, this.shape, !1), this.pathUpdated()), i = s.getBoundingRect();
    }
    if (this._rect = i, this.hasStroke() && this.path && this.path.len() > 0) {
      var o = this._rectStroke || (this._rectStroke = i.clone());
      if (this.__dirty || r) {
        o.copy(i);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (o.width += u / l, o.height += u / l, o.x -= u / l / 2, o.y -= u / l / 2);
      }
      return o;
    }
    return i;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect(), s = this.style;
    if (i = r[0], n = r[1], a.contain(i, n)) {
      var o = this.path;
      if (this.hasStroke()) {
        var l = s.lineWidth, u = s.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), PO(o, l / u, i, n)))
          return !0;
      }
      if (this.hasFill())
        return AO(o, i, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= Fa, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(i) {
    return this.animate("shape", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : i === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i === "shape" ? this.setShape(n) : e.prototype.attrKV.call(this, i, n);
  }, t.prototype.setShape = function(i, n) {
    var r = this.shape;
    return r || (r = this.shape = {}), typeof i == "string" ? r[i] = n : Y(r, i), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & Fa);
  }, t.prototype.createStyle = function(i) {
    return Mc(H1, i);
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.shape && !n.shape && (n.shape = Y({}, this.shape));
  }, t.prototype._applyStateObj = function(i, n, r, a, s, o) {
    e.prototype._applyStateObj.call(this, i, n, r, a, s, o);
    var l = !(n && a), u;
    if (n && n.shape ? s ? a ? u = n.shape : (u = Y({}, r.shape), Y(u, n.shape)) : (u = Y({}, a ? this.shape : r.shape), Y(u, n.shape)) : l && (u = r.shape), u)
      if (s) {
        this.shape = Y({}, this.shape);
        for (var c = {}, h = qt(u), d = 0; d < h.length; d++) {
          var f = h[d];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(i, {
          shape: c
        }, o);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var s = i[a];
      s.shape && (r = r || {}, this._mergeStyle(r, s.shape));
    }
    return r && (n.shape = r), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return EO;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(i) {
    var n = (function(a) {
      Lt(s, a);
      function s(o) {
        var l = a.call(this, o) || this;
        return i.init && i.init.call(l, o), l;
      }
      return s.prototype.getDefaultStyle = function() {
        return pt(i.style);
      }, s.prototype.getDefaultShape = function() {
        return pt(i.shape);
      }, s;
    })(t);
    for (var r in i)
      typeof i[r] == "function" && (n.prototype[r] = i[r]);
    return n;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "path", i.strokeContainThreshold = 5, i.segmentIgnoreThreshold = 0, i.subPixelOptimize = !1, i.autoBatch = !1, i.__dirty = Ke | Qs | Fa;
  })(), t;
})(Ko), LO = Jt({
  strokeFirst: !0,
  font: er,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, H1), Bu = (function(e) {
  Lt(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return z1(this.style);
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(i) {
    return Mc(LO, i);
  }, t.prototype.setBoundingRect = function(i) {
    this._rect = i;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = fO(this.style)), this._rect;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.dirtyRectTolerance = 10;
  })(), t;
})(Ko);
Bu.prototype.type = "tspan";
var OO = Jt({
  x: 0,
  y: 0
}, ta), IO = {
  style: Jt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, Pc.style)
};
function RO(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var ua = (function(e) {
  Lt(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(i) {
    return Mc(OO, i);
  }, t.prototype._getSize = function(i) {
    var n = this.style, r = n[i];
    if (r != null)
      return r;
    var a = RO(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var s = i === "width" ? "height" : "width", o = n[s];
    return o == null ? a[i] : a[i] / a[s] * o;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return IO;
  }, t.prototype.getBoundingRect = function() {
    var i = this.style;
    return this._rect || (this._rect = new ot(i.x || 0, i.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
})(Ko);
ua.prototype.type = "image";
function NO(e, t) {
  var i = t.x, n = t.y, r = t.width, a = t.height, s = t.r, o, l, u, c;
  r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), typeof s == "number" ? o = l = u = c = s : s instanceof Array ? s.length === 1 ? o = l = u = c = s[0] : s.length === 2 ? (o = u = s[0], l = c = s[1]) : s.length === 3 ? (o = s[0], l = c = s[1], u = s[2]) : (o = s[0], l = s[1], u = s[2], c = s[3]) : o = l = u = c = 0;
  var h;
  o + l > r && (h = o + l, o *= r / h, l *= r / h), u + c > r && (h = u + c, u *= r / h, c *= r / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), o + c > a && (h = o + c, o *= a / h, c *= a / h), e.moveTo(i + o, n), e.lineTo(i + r - l, n), l !== 0 && e.arc(i + r - l, n + l, l, -Math.PI / 2, 0), e.lineTo(i + r, n + a - u), u !== 0 && e.arc(i + r - u, n + a - u, u, 0, Math.PI / 2), e.lineTo(i + c, n + a), c !== 0 && e.arc(i + c, n + a - c, c, Math.PI / 2, Math.PI), e.lineTo(i, n + o), o !== 0 && e.arc(i + o, n + o, o, Math.PI, Math.PI * 1.5);
}
var Ya = Math.round;
function Y1(e, t, i) {
  if (t) {
    var n = t.x1, r = t.x2, a = t.y1, s = t.y2;
    e.x1 = n, e.x2 = r, e.y1 = a, e.y2 = s;
    var o = i && i.lineWidth;
    return o && (Ya(n * 2) === Ya(r * 2) && (e.x1 = e.x2 = Yr(n, o, !0)), Ya(a * 2) === Ya(s * 2) && (e.y1 = e.y2 = Yr(a, o, !0))), e;
  }
}
function W1(e, t, i) {
  if (t) {
    var n = t.x, r = t.y, a = t.width, s = t.height;
    e.x = n, e.y = r, e.width = a, e.height = s;
    var o = i && i.lineWidth;
    return o && (e.x = Yr(n, o, !0), e.y = Yr(r, o, !0), e.width = Math.max(Yr(n + a, o, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max(Yr(r + s, o, !1) - e.y, s === 0 ? 0 : 1)), e;
  }
}
function Yr(e, t, i) {
  if (!t)
    return e;
  var n = Ya(e * 2);
  return (n + Ya(t)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
}
var FO = /* @__PURE__ */ (function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
})(), BO = {}, De = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new FO();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, s, o;
    if (this.subPixelOptimize) {
      var l = W1(BO, n, this.style);
      r = l.x, a = l.y, s = l.width, o = l.height, l.r = n.r, n = l;
    } else
      r = n.x, a = n.y, s = n.width, o = n.height;
    n.r ? NO(i, n) : i.rect(r, a, s, o);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
})(Bt);
De.prototype.type = "rect";
var h0 = {
  fill: "#000"
}, d0 = 2, $i = {}, $O = {
  style: Jt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, Pc.style)
}, mi = (function(e) {
  Lt(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = h0, n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var i = this.innerTransformable;
    i ? (i.updateTransform(), i.transform && (this.transform = i.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(i) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(i) : e.prototype.getLocalTransform.call(this, i);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, WO(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = i;
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var i = new ot(0, 0, 0, 0), n = this._children, r = [], a = null, s = 0; s < n.length; s++) {
        var o = n[s], l = o.getBoundingRect(), u = o.getLocalTransform(r);
        u ? (i.copy(l), i.applyTransform(u), a = a || i.clone(), a.union(i)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || i;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(i) {
    this._defaultStyle = i || h0;
  }, t.prototype.setTextContent = function(i) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(i, n) {
    if (!n)
      return i;
    var r = n.rich, a = i.rich || r && {};
    return Y(i, n), r && a ? (this._mergeRich(a, r), i.rich = a) : a && (i.rich = a), i;
  }, t.prototype._mergeRich = function(i, n) {
    for (var r = qt(n), a = 0; a < r.length; a++) {
      var s = r[a];
      i[s] = i[s] || {}, Y(i[s], n[s]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return $O;
  }, t.prototype._getOrCreateChild = function(i) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof i)) && (n = new i()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var i = this.style, n = i.font || er, r = i.padding, a = this._defaultStyle, s = i.x || 0, o = i.y || 0, l = i.align || a.align || "left", u = i.verticalAlign || a.verticalAlign || "top";
    n0($i, a.overflowRect, s, o, l, u), s = $i.baseX, o = $i.baseY;
    var c = y0(i), h = sO(c, i, $i.outerWidth, $i.outerHeight), d = Xh(i), f = !!i.backgroundColor, v = h.outerHeight, p = h.outerWidth, g = h.lines, m = h.lineHeight;
    this.isTruncated = !!h.isTruncated;
    var _ = s, y = Jr(o, h.contentHeight, u);
    if (d || r) {
      var b = ss(s, p, l), w = Jr(o, v, u);
      d && this._renderBackground(i, i, b, w, p, v);
    }
    y += m / 2, r && (_ = _0(s, l, r), u === "top" ? y += r[0] : u === "bottom" && (y -= r[2]));
    for (var S = 0, M = !1, k = !1, T = m0("fill" in i ? i.fill : (k = !0, a.fill)), C = g0("stroke" in i ? i.stroke : !f && (!a.autoStroke || k) ? (S = d0, M = !0, a.stroke) : null), D = i.textShadowBlur > 0, P = 0; P < g.length; P++) {
      var O = this._getOrCreateChild(Bu), I = O.createStyle();
      O.useStyle(I), I.text = g[P], I.x = _, I.y = y, I.textAlign = l, I.textBaseline = "middle", I.opacity = i.opacity, I.strokeFirst = !0, D && (I.shadowBlur = i.textShadowBlur || 0, I.shadowColor = i.textShadowColor || "transparent", I.shadowOffsetX = i.textShadowOffsetX || 0, I.shadowOffsetY = i.textShadowOffsetY || 0), I.stroke = C, I.fill = T, C && (I.lineWidth = i.lineWidth || S, I.lineDash = i.lineDash, I.lineDashOffset = i.lineDashOffset || 0), I.font = n, v0(I, i), y += m, O.setBoundingRect(df(I, h.contentWidth, h.calculatedLineHeight, M ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var i = this.style, n = this._defaultStyle, r = i.align || n.align, a = i.verticalAlign || n.verticalAlign, s = i.x || 0, o = i.y || 0;
    n0($i, n.overflowRect, s, o, r, a), s = $i.baseX, o = $i.baseY;
    var l = y0(i), u = uO(l, i, $i.outerWidth, $i.outerHeight, r), c = u.width, h = u.outerWidth, d = u.outerHeight, f = i.padding;
    this.isTruncated = !!u.isTruncated;
    var v = ss(s, h, r), p = Jr(o, d, a), g = v, m = p;
    f && (g += f[3], m += f[0]);
    var _ = g + c;
    Xh(i) && this._renderBackground(i, i, v, p, h, d);
    for (var y = !!i.backgroundColor, b = 0; b < u.lines.length; b++) {
      for (var w = u.lines[b], S = w.tokens, M = S.length, k = w.lineHeight, T = w.width, C = 0, D = g, P = _, O = M - 1, I = void 0; C < M && (I = S[C], !I.align || I.align === "left"); )
        this._placeToken(I, i, k, m, D, "left", y), T -= I.width, D += I.width, C++;
      for (; O >= 0 && (I = S[O], I.align === "right"); )
        this._placeToken(I, i, k, m, P, "right", y), T -= I.width, P -= I.width, O--;
      for (D += (c - (D - g) - (_ - P) - T) / 2; C <= O; )
        I = S[C], this._placeToken(I, i, k, m, D + I.width / 2, "center", y), D += I.width, C++;
      m += k;
    }
  }, t.prototype._placeToken = function(i, n, r, a, s, o, l) {
    var u = n.rich[i.styleName] || {};
    u.text = i.text;
    var c = i.verticalAlign, h = a + r / 2;
    c === "top" ? h = a + i.height / 2 : c === "bottom" && (h = a + r - i.height / 2);
    var d = !i.isLineHolder && Xh(u);
    d && this._renderBackground(u, n, o === "right" ? s - i.width : o === "center" ? s - i.width / 2 : s, h - i.height / 2, i.width, i.height);
    var f = !!u.backgroundColor, v = i.textPadding;
    v && (s = _0(s, o, v), h -= i.height / 2 - v[0] - i.innerHeight / 2);
    var p = this._getOrCreateChild(Bu), g = p.createStyle();
    p.useStyle(g);
    var m = this._defaultStyle, _ = !1, y = 0, b = !1, w = m0("fill" in u ? u.fill : "fill" in n ? n.fill : (_ = !0, m.fill)), S = g0("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !f && !l && (!m.autoStroke || _) ? (y = d0, b = !0, m.stroke) : null), M = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    g.text = i.text, g.x = s, g.y = h, M && (g.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, g.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", g.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, g.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), g.textAlign = o, g.textBaseline = "middle", g.font = i.font || er, g.opacity = Zr(u.opacity, n.opacity, 1), v0(g, u), S && (g.lineWidth = Zr(u.lineWidth, n.lineWidth, y), g.lineDash = nt(u.lineDash, n.lineDash), g.lineDashOffset = n.lineDashOffset || 0, g.stroke = S), w && (g.fill = w), p.setBoundingRect(df(g, i.contentWidth, i.contentHeight, b ? 0 : null));
  }, t.prototype._renderBackground = function(i, n, r, a, s, o) {
    var l = i.backgroundColor, u = i.borderWidth, c = i.borderColor, h = l && l.image, d = l && !h, f = i.borderRadius, v = this, p, g;
    if (d || i.lineHeight || u && c) {
      p = this._getOrCreateChild(De), p.useStyle(p.createStyle()), p.style.fill = null;
      var m = p.shape;
      m.x = r, m.y = a, m.width = s, m.height = o, m.r = f, p.dirtyShape();
    }
    if (d) {
      var _ = p.style;
      _.fill = l || null, _.fillOpacity = nt(i.fillOpacity, 1);
    } else if (h) {
      g = this._getOrCreateChild(ua), g.onload = function() {
        v.dirtyStyle();
      };
      var y = g.style;
      y.image = l.image, y.x = r, y.y = a, y.width = s, y.height = o;
    }
    if (u && c) {
      var _ = p.style;
      _.lineWidth = u, _.stroke = c, _.strokeOpacity = nt(i.strokeOpacity, 1), _.lineDash = i.borderDash, _.lineDashOffset = i.borderDashOffset || 0, p.strokeContainThreshold = 0, p.hasFill() && p.hasStroke() && (_.strokeFirst = !0, _.lineWidth *= 2);
    }
    var b = (p || g).style;
    b.shadowBlur = i.shadowBlur || 0, b.shadowColor = i.shadowColor || "transparent", b.shadowOffsetX = i.shadowOffsetX || 0, b.shadowOffsetY = i.shadowOffsetY || 0, b.opacity = Zr(i.opacity, n.opacity, 1);
  }, t.makeFont = function(i) {
    var n = "";
    return YO(i) && (n = [
      i.fontStyle,
      i.fontWeight,
      HO(i.fontSize),
      i.fontFamily || "sans-serif"
    ].join(" ")), n && Ui(n) || i.textFont || i.font;
  }, t;
})(Ko), zO = { left: !0, right: 1, center: 1 }, VO = { top: 1, bottom: 1, middle: 1 }, f0 = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function HO(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? _v + "px" : e + "px";
}
function v0(e, t) {
  for (var i = 0; i < f0.length; i++) {
    var n = f0[i], r = t[n];
    r != null && (e[n] = r);
  }
}
function YO(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function WO(e) {
  return p0(e), A(e.rich, p0), e;
}
function p0(e) {
  if (e) {
    e.font = mi.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || zO[t] ? t : "left";
    var i = e.verticalAlign;
    i === "center" && (i = "middle"), e.verticalAlign = i == null || VO[i] ? i : "top";
    var n = e.padding;
    n && (e.padding = wv(e.padding));
  }
}
function g0(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function m0(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function _0(e, t, i) {
  return t === "right" ? e - i[1] : t === "center" ? e + i[3] / 2 - i[1] / 2 : e + i[3];
}
function y0(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function Xh(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
var zt = Gt(), UO = function(e, t, i, n) {
  if (n) {
    var r = zt(n);
    r.dataIndex = i, r.dataType = t, r.seriesIndex = e, r.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var s = zt(a);
      s.seriesIndex = e, s.dataIndex = i, s.dataType = t, s.ssrType = "chart";
    });
  }
}, b0 = 1, x0 = {}, U1 = Gt(), Lv = Gt(), G1 = 0, Ov = 1, Iv = 2, nr = ["emphasis", "blur", "select"], w0 = ["normal", "emphasis", "blur", "select"], GO = 10, XO = 9, ea = "highlight", ou = "downplay", $u = "select", pf = "unselect", zu = "toggleSelect", Rv = "selectchanged";
function Sa(e) {
  return e != null && e !== "none";
}
function Ec(e, t, i) {
  e.onHoverStateChange && (e.hoverState || 0) !== i && e.onHoverStateChange(t), e.hoverState = i;
}
function X1(e) {
  Ec(e, "emphasis", Iv);
}
function j1(e) {
  e.hoverState === Iv && Ec(e, "normal", G1);
}
function Nv(e) {
  Ec(e, "blur", Ov);
}
function q1(e) {
  e.hoverState === Ov && Ec(e, "normal", G1);
}
function jO(e) {
  e.selected = !0;
}
function qO(e) {
  e.selected = !1;
}
function S0(e, t, i) {
  t(e, i);
}
function Pn(e, t, i) {
  S0(e, t, i), e.isGroup && e.traverse(function(n) {
    S0(n, t, i);
  });
}
function ZO(e, t, i, n) {
  for (var r = e.style, a = {}, s = 0; s < t.length; s++) {
    var o = t[s], l = r[o];
    a[o] = l ?? (n && n[o]);
  }
  for (var s = 0; s < e.animators.length; s++) {
    var u = e.animators[s];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(i) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function KO(e, t, i, n) {
  var r = i && Vt(i, "select") >= 0, a = !1;
  if (e instanceof Bt) {
    var s = U1(e), o = r && s.selectFill || s.normalFill, l = r && s.selectStroke || s.normalStroke;
    if (Sa(o) || Sa(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = Y({}, n), u = Y({}, u), u.fill = o) : !Sa(u.fill) && Sa(o) ? (a = !0, n = Y({}, n), u = Y({}, u), u.fill = Rm(o)) : !Sa(u.stroke) && Sa(l) && (a || (n = Y({}, n), u = Y({}, u)), u.stroke = Rm(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = Y({}, n));
    var c = e.z2EmphasisLift;
    n.z2 = e.z2 + (c ?? GO);
  }
  return n;
}
function QO(e, t, i) {
  if (i && i.z2 == null) {
    i = Y({}, i);
    var n = e.z2SelectLift;
    i.z2 = e.z2 + (n ?? XO);
  }
  return i;
}
function JO(e, t, i) {
  var n = Vt(e.currentStates, t) >= 0, r = e.style.opacity, a = n ? null : ZO(e, ["opacity"], t, {
    opacity: 1
  });
  i = i || {};
  var s = i.style || {};
  return s.opacity == null && (i = Y({}, i), s = Y({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? r : a.opacity * 0.1
  }, s), i.style = s), i;
}
function jh(e, t) {
  var i = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return KO(this, e, t, i);
    if (e === "blur")
      return JO(this, e, i);
    if (e === "select")
      return QO(this, e, i);
  }
  return i;
}
function tI(e) {
  e.stateProxy = jh;
  var t = e.getTextContent(), i = e.getTextGuideLine();
  t && (t.stateProxy = jh), i && (i.stateProxy = jh);
}
function M0(e, t) {
  !J1(e, t) && !e.__highByOuter && Pn(e, X1);
}
function k0(e, t) {
  !J1(e, t) && !e.__highByOuter && Pn(e, j1);
}
function Vu(e, t) {
  e.__highByOuter |= 1 << (t || 0), Pn(e, X1);
}
function Hu(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && Pn(e, j1);
}
function eI(e) {
  Pn(e, Nv);
}
function Z1(e) {
  Pn(e, q1);
}
function K1(e) {
  Pn(e, jO);
}
function Q1(e) {
  Pn(e, qO);
}
function J1(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function tx(e) {
  var t = e.getModel(), i = [], n = [];
  t.eachComponent(function(r, a) {
    var s = Lv(a), o = r === "series", l = o ? e.getViewOfSeriesModel(a) : e.getViewOfComponentModel(a);
    !o && n.push(l), s.isBlured && (l.group.traverse(function(u) {
      q1(u);
    }), o && i.push(a)), s.isBlured = !1;
  }), A(n, function(r) {
    r && r.toggleBlurSeries && r.toggleBlurSeries(i, !1, t);
  });
}
function gf(e, t, i, n) {
  var r = n.getModel();
  i = i || "coordinateSystem";
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var d = u.getItemGraphicEl(c[h]);
      d && Z1(d);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var s = r.getSeriesByIndex(e), o = s.coordinateSystem;
    o && o.master && (o = o.master);
    var l = [];
    r.eachSeries(function(u) {
      var c = s === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var d = h && o ? h === o : c;
      if (!// Not blur other series if blurScope series
      (i === "series" && !c || i === "coordinateSystem" && !d || t === "series" && c)) {
        var f = n.getViewOfSeriesModel(u);
        if (f.group.traverse(function(g) {
          g.__highByOuter && c && t === "self" || Nv(g);
        }), Ge(t))
          a(u.getData(), t);
        else if (Q(t))
          for (var v = qt(t), p = 0; p < v.length; p++)
            a(u.getData(v[p]), t[v[p]]);
        l.push(u), Lv(u).isBlured = !0;
      }
    }), r.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = n.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, r);
      }
    });
  }
}
function mf(e, t, i) {
  if (!(e == null || t == null)) {
    var n = i.getModel().getComponent(e, t);
    if (n) {
      Lv(n).isBlured = !0;
      var r = i.getViewOfComponentModel(n);
      !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
        Nv(a);
      });
    }
  }
}
function iI(e, t, i) {
  var n = e.seriesIndex, r = e.getData(t.dataType);
  if (!r) {
    process.env.NODE_ENV !== "production" && Kt("Unknown dataType " + t.dataType);
    return;
  }
  var a = qo(r, t);
  a = (Z(a) ? a[0] : a) || 0;
  var s = r.getItemGraphicEl(a);
  if (!s)
    for (var o = r.count(), l = 0; !s && l < o; )
      s = r.getItemGraphicEl(l++);
  if (s) {
    var u = zt(s);
    gf(n, u.focus, u.blurScope, i);
  } else {
    var c = e.get(["emphasis", "focus"]), h = e.get(["emphasis", "blurScope"]);
    c != null && gf(n, c, h, i);
  }
}
function Fv(e, t, i, n) {
  var r = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || i == null)
    return r;
  var a = n.getModel().getComponent(e, t);
  if (!a)
    return r;
  var s = n.getViewOfComponentModel(a);
  if (!s || !s.findHighDownDispatchers)
    return r;
  for (var o = s.findHighDownDispatchers(i), l, u = 0; u < o.length; u++)
    if (process.env.NODE_ENV !== "production" && !us(o[u]) && Kt("param should be highDownDispatcher"), zt(o[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: o
  };
}
function nI(e, t, i) {
  process.env.NODE_ENV !== "production" && !us(e) && Kt("param should be highDownDispatcher");
  var n = zt(e), r = Fv(n.componentMainType, n.componentIndex, n.componentHighDownName, i), a = r.dispatchers, s = r.focusSelf;
  a ? (s && mf(n.componentMainType, n.componentIndex, i), A(a, function(o) {
    return M0(o, t);
  })) : (gf(n.seriesIndex, n.focus, n.blurScope, i), n.focus === "self" && mf(n.componentMainType, n.componentIndex, i), M0(e, t));
}
function rI(e, t, i) {
  process.env.NODE_ENV !== "production" && !us(e) && Kt("param should be highDownDispatcher"), tx(i);
  var n = zt(e), r = Fv(n.componentMainType, n.componentIndex, n.componentHighDownName, i).dispatchers;
  r ? A(r, function(a) {
    return k0(a, t);
  }) : k0(e, t);
}
function aI(e, t, i) {
  if (_f(t)) {
    var n = t.dataType, r = e.getData(n), a = qo(r, t);
    Z(a) || (a = [a]), e[t.type === zu ? "toggleSelect" : t.type === $u ? "select" : "unselect"](a, n);
  }
}
function D0(e) {
  var t = e.getAllData();
  A(t, function(i) {
    var n = i.data, r = i.type;
    n.eachItemGraphicEl(function(a, s) {
      e.isSelected(s, r) ? K1(a) : Q1(a);
    });
  });
}
function sI(e) {
  var t = [];
  return e.eachSeries(function(i) {
    var n = i.getAllData();
    A(n, function(r) {
      r.data;
      var a = r.type, s = i.getSelectedDataIndices();
      if (s.length > 0) {
        var o = {
          dataIndex: s,
          seriesIndex: i.seriesIndex
        };
        a != null && (o.dataType = a), t.push(o);
      }
    });
  }), t;
}
function oI(e, t, i) {
  ex(e, !0), Pn(e, tI), uI(e, t, i);
}
function lI(e) {
  ex(e, !1);
}
function T0(e, t, i, n) {
  n ? lI(e) : oI(e, t, i);
}
function uI(e, t, i) {
  var n = zt(e);
  t != null ? (n.focus = t, n.blurScope = i) : n.focus && (n.focus = null);
}
var C0 = ["emphasis", "blur", "select"], cI = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function A0(e, t, i, n) {
  i = i || "itemStyle";
  for (var r = 0; r < C0.length; r++) {
    var a = C0[r], s = t.getModel([a, i]), o = e.ensureState(a);
    o.style = n ? n(s) : s[cI[i]]();
  }
}
function ex(e, t) {
  var i = t === !1, n = e;
  e.highDownSilentOnTouch && (n.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!i || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !i);
}
function us(e) {
  return !!(e && e.__highDownDispatcher);
}
function hI(e) {
  var t = x0[e];
  return t == null && b0 <= 32 && (t = x0[e] = b0++), t;
}
function _f(e) {
  var t = e.type;
  return t === $u || t === pf || t === zu;
}
function P0(e) {
  var t = e.type;
  return t === ea || t === ou;
}
function dI(e) {
  var t = U1(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var i = e.states.select || {};
  t.selectFill = i.style && i.style.fill || null, t.selectStroke = i.style && i.style.stroke || null;
}
var Ma = ls.CMD, fI = [[], [], []], E0 = Math.sqrt, vI = Math.atan2;
function pI(e, t) {
  if (t) {
    var i = e.data, n = e.len(), r, a, s, o, l, u, c = Ma.M, h = Ma.C, d = Ma.L, f = Ma.R, v = Ma.A, p = Ma.Q;
    for (s = 0, o = 0; s < n; ) {
      switch (r = i[s++], o = s, a = 0, r) {
        case c:
          a = 1;
          break;
        case d:
          a = 1;
          break;
        case h:
          a = 3;
          break;
        case p:
          a = 2;
          break;
        case v:
          var g = t[4], m = t[5], _ = E0(t[0] * t[0] + t[1] * t[1]), y = E0(t[2] * t[2] + t[3] * t[3]), b = vI(-t[1] / y, t[0] / _);
          i[s] *= _, i[s++] += g, i[s] *= y, i[s++] += m, i[s++] *= _, i[s++] *= y, i[s++] += b, i[s++] += b, s += 2, o = s;
          break;
        case f:
          u[0] = i[s++], u[1] = i[s++], Qe(u, u, t), i[o++] = u[0], i[o++] = u[1], u[0] += i[s++], u[1] += i[s++], Qe(u, u, t), i[o++] = u[0], i[o++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var w = fI[l];
        w[0] = i[s++], w[1] = i[s++], Qe(w, w, t), i[o++] = w[0], i[o++] = w[1];
      }
    }
    e.increaseVersion();
  }
}
var qh = Math.sqrt, Al = Math.sin, Pl = Math.cos, As = Math.PI;
function L0(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function yf(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (L0(e) * L0(t));
}
function O0(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos(yf(e, t));
}
function I0(e, t, i, n, r, a, s, o, l, u, c) {
  var h = l * (As / 180), d = Pl(h) * (e - i) / 2 + Al(h) * (t - n) / 2, f = -1 * Al(h) * (e - i) / 2 + Pl(h) * (t - n) / 2, v = d * d / (s * s) + f * f / (o * o);
  v > 1 && (s *= qh(v), o *= qh(v));
  var p = (r === a ? -1 : 1) * qh((s * s * (o * o) - s * s * (f * f) - o * o * (d * d)) / (s * s * (f * f) + o * o * (d * d))) || 0, g = p * s * f / o, m = p * -o * d / s, _ = (e + i) / 2 + Pl(h) * g - Al(h) * m, y = (t + n) / 2 + Al(h) * g + Pl(h) * m, b = O0([1, 0], [(d - g) / s, (f - m) / o]), w = [(d - g) / s, (f - m) / o], S = [(-1 * d - g) / s, (-1 * f - m) / o], M = O0(w, S);
  if (yf(w, S) <= -1 && (M = As), yf(w, S) >= 1 && (M = 0), M < 0) {
    var k = Math.round(M / As * 1e6) / 1e6;
    M = As * 2 + k % 2 * As;
  }
  c.addData(u, _, y, s, o, b, M, h, a);
}
var gI = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, mI = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function _I(e) {
  var t = new ls();
  if (!e)
    return t;
  var i = 0, n = 0, r = i, a = n, s, o = ls.CMD, l = e.match(gI);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), d = void 0, f = c.match(mI) || [], v = f.length, p = 0; p < v; p++)
      f[p] = parseFloat(f[p]);
    for (var g = 0; g < v; ) {
      var m = void 0, _ = void 0, y = void 0, b = void 0, w = void 0, S = void 0, M = void 0, k = i, T = n, C = void 0, D = void 0;
      switch (h) {
        case "l":
          i += f[g++], n += f[g++], d = o.L, t.addData(d, i, n);
          break;
        case "L":
          i = f[g++], n = f[g++], d = o.L, t.addData(d, i, n);
          break;
        case "m":
          i += f[g++], n += f[g++], d = o.M, t.addData(d, i, n), r = i, a = n, h = "l";
          break;
        case "M":
          i = f[g++], n = f[g++], d = o.M, t.addData(d, i, n), r = i, a = n, h = "L";
          break;
        case "h":
          i += f[g++], d = o.L, t.addData(d, i, n);
          break;
        case "H":
          i = f[g++], d = o.L, t.addData(d, i, n);
          break;
        case "v":
          n += f[g++], d = o.L, t.addData(d, i, n);
          break;
        case "V":
          n = f[g++], d = o.L, t.addData(d, i, n);
          break;
        case "C":
          d = o.C, t.addData(d, f[g++], f[g++], f[g++], f[g++], f[g++], f[g++]), i = f[g - 2], n = f[g - 1];
          break;
        case "c":
          d = o.C, t.addData(d, f[g++] + i, f[g++] + n, f[g++] + i, f[g++] + n, f[g++] + i, f[g++] + n), i += f[g - 2], n += f[g - 1];
          break;
        case "S":
          m = i, _ = n, C = t.len(), D = t.data, s === o.C && (m += i - D[C - 4], _ += n - D[C - 3]), d = o.C, k = f[g++], T = f[g++], i = f[g++], n = f[g++], t.addData(d, m, _, k, T, i, n);
          break;
        case "s":
          m = i, _ = n, C = t.len(), D = t.data, s === o.C && (m += i - D[C - 4], _ += n - D[C - 3]), d = o.C, k = i + f[g++], T = n + f[g++], i += f[g++], n += f[g++], t.addData(d, m, _, k, T, i, n);
          break;
        case "Q":
          k = f[g++], T = f[g++], i = f[g++], n = f[g++], d = o.Q, t.addData(d, k, T, i, n);
          break;
        case "q":
          k = f[g++] + i, T = f[g++] + n, i += f[g++], n += f[g++], d = o.Q, t.addData(d, k, T, i, n);
          break;
        case "T":
          m = i, _ = n, C = t.len(), D = t.data, s === o.Q && (m += i - D[C - 4], _ += n - D[C - 3]), i = f[g++], n = f[g++], d = o.Q, t.addData(d, m, _, i, n);
          break;
        case "t":
          m = i, _ = n, C = t.len(), D = t.data, s === o.Q && (m += i - D[C - 4], _ += n - D[C - 3]), i += f[g++], n += f[g++], d = o.Q, t.addData(d, m, _, i, n);
          break;
        case "A":
          y = f[g++], b = f[g++], w = f[g++], S = f[g++], M = f[g++], k = i, T = n, i = f[g++], n = f[g++], d = o.A, I0(k, T, i, n, S, M, y, b, w, d, t);
          break;
        case "a":
          y = f[g++], b = f[g++], w = f[g++], S = f[g++], M = f[g++], k = i, T = n, i += f[g++], n += f[g++], d = o.A, I0(k, T, i, n, S, M, y, b, w, d, t);
          break;
      }
    }
    (h === "z" || h === "Z") && (d = o.Z, t.addData(d), i = r, n = a), s = d;
  }
  return t.toStatic(), t;
}
var ix = (function(e) {
  Lt(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(i) {
  }, t;
})(Bt);
function nx(e) {
  return e.setData != null;
}
function rx(e, t) {
  var i = _I(e), n = Y({}, t);
  return n.buildPath = function(r) {
    var a = nx(r);
    if (a && r.canSave()) {
      r.appendPath(i);
      var s = r.getContext();
      s && r.rebuildPath(s, 1);
    } else {
      var s = a ? r.getContext() : r;
      s && i.rebuildPath(s, 1);
    }
  }, n.applyTransform = function(r) {
    pI(i, r), this.dirtyShape();
  }, n;
}
function yI(e, t) {
  return new ix(rx(e, t));
}
function bI(e, t) {
  var i = rx(e, t), n = (function(r) {
    Lt(a, r);
    function a(s) {
      var o = r.call(this, s) || this;
      return o.applyTransform = i.applyTransform, o.buildPath = i.buildPath, o;
    }
    return a;
  })(ix);
  return n;
}
function xI(e, t) {
  for (var i = [], n = e.length, r = 0; r < n; r++) {
    var a = e[r];
    i.push(a.getUpdatedPathProxy(!0));
  }
  var s = new Bt(t);
  return s.createPathProxy(), s.buildPath = function(o) {
    if (nx(o)) {
      o.appendPath(i);
      var l = o.getContext();
      l && o.rebuildPath(l, 1);
    }
  }, s;
}
var wI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
})(), Lc = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new wI();
  }, t.prototype.buildPath = function(i, n) {
    i.moveTo(n.cx + n.r, n.cy), i.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
})(Bt);
Lc.prototype.type = "circle";
var SI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
})(), Bv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new SI();
  }, t.prototype.buildPath = function(i, n) {
    var r = 0.5522848, a = n.cx, s = n.cy, o = n.rx, l = n.ry, u = o * r, c = l * r;
    i.moveTo(a - o, s), i.bezierCurveTo(a - o, s - c, a - u, s - l, a, s - l), i.bezierCurveTo(a + u, s - l, a + o, s - c, a + o, s), i.bezierCurveTo(a + o, s + c, a + u, s + l, a, s + l), i.bezierCurveTo(a - u, s + l, a - o, s + c, a - o, s), i.closePath();
  }, t;
})(Bt);
Bv.prototype.type = "ellipse";
var ax = Math.PI, Zh = ax * 2, Mr = Math.sin, ka = Math.cos, MI = Math.acos, be = Math.atan2, R0 = Math.abs, go = Math.sqrt, eo = Math.max, zi = Math.min, bi = 1e-4;
function kI(e, t, i, n, r, a, s, o) {
  var l = i - e, u = n - t, c = s - r, h = o - a, d = h * l - c * u;
  if (!(d * d < bi))
    return d = (c * (t - a) - h * (e - r)) / d, [e + d * l, t + d * u];
}
function El(e, t, i, n, r, a, s) {
  var o = e - i, l = t - n, u = (s ? a : -a) / go(o * o + l * l), c = u * l, h = -u * o, d = e + c, f = t + h, v = i + c, p = n + h, g = (d + v) / 2, m = (f + p) / 2, _ = v - d, y = p - f, b = _ * _ + y * y, w = r - a, S = d * p - v * f, M = (y < 0 ? -1 : 1) * go(eo(0, w * w * b - S * S)), k = (S * y - _ * M) / b, T = (-S * _ - y * M) / b, C = (S * y + _ * M) / b, D = (-S * _ + y * M) / b, P = k - g, O = T - m, I = C - g, N = D - m;
  return P * P + O * O > I * I + N * N && (k = C, T = D), {
    cx: k,
    cy: T,
    x0: -c,
    y0: -h,
    x1: k * (r / w - 1),
    y1: T * (r / w - 1)
  };
}
function DI(e) {
  var t;
  if (Z(e)) {
    var i = e.length;
    if (!i)
      return e;
    i === 1 ? t = [e[0], e[0], 0, 0] : i === 2 ? t = [e[0], e[0], e[1], e[1]] : i === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function TI(e, t) {
  var i, n = eo(t.r, 0), r = eo(t.r0 || 0, 0), a = n > 0, s = r > 0;
  if (!(!a && !s)) {
    if (a || (n = r, r = 0), r > n) {
      var o = n;
      n = r, r = o;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, h = t.cy, d = !!t.clockwise, f = R0(u - l), v = f > Zh && f % Zh;
      if (v > bi && (f = v), !(n > bi))
        e.moveTo(c, h);
      else if (f > Zh - bi)
        e.moveTo(c + n * ka(l), h + n * Mr(l)), e.arc(c, h, n, l, u, !d), r > bi && (e.moveTo(c + r * ka(u), h + r * Mr(u)), e.arc(c, h, r, u, l, d));
      else {
        var p = void 0, g = void 0, m = void 0, _ = void 0, y = void 0, b = void 0, w = void 0, S = void 0, M = void 0, k = void 0, T = void 0, C = void 0, D = void 0, P = void 0, O = void 0, I = void 0, N = n * ka(l), F = n * Mr(l), q = r * ka(u), V = r * Mr(u), B = f > bi;
        if (B) {
          var $ = t.cornerRadius;
          $ && (i = DI($), p = i[0], g = i[1], m = i[2], _ = i[3]);
          var j = R0(n - r) / 2;
          if (y = zi(j, m), b = zi(j, _), w = zi(j, p), S = zi(j, g), T = M = eo(y, b), C = k = eo(w, S), (M > bi || k > bi) && (D = n * ka(u), P = n * Mr(u), O = r * ka(l), I = r * Mr(l), f < ax)) {
            var G = kI(N, F, O, I, D, P, q, V);
            if (G) {
              var et = N - G[0], at = F - G[1], wt = D - G[0], Tt = P - G[1], me = 1 / Mr(MI((et * wt + at * Tt) / (go(et * et + at * at) * go(wt * wt + Tt * Tt))) / 2), Pe = go(G[0] * G[0] + G[1] * G[1]);
              T = zi(M, (n - Pe) / (me + 1)), C = zi(k, (r - Pe) / (me - 1));
            }
          }
        }
        if (!B)
          e.moveTo(c + N, h + F);
        else if (T > bi) {
          var Pt = zi(m, T), Nt = zi(_, T), rt = El(O, I, N, F, n, Pt, d), ft = El(D, P, q, V, n, Nt, d);
          e.moveTo(c + rt.cx + rt.x0, h + rt.cy + rt.y0), T < M && Pt === Nt ? e.arc(c + rt.cx, h + rt.cy, T, be(rt.y0, rt.x0), be(ft.y0, ft.x0), !d) : (Pt > 0 && e.arc(c + rt.cx, h + rt.cy, Pt, be(rt.y0, rt.x0), be(rt.y1, rt.x1), !d), e.arc(c, h, n, be(rt.cy + rt.y1, rt.cx + rt.x1), be(ft.cy + ft.y1, ft.cx + ft.x1), !d), Nt > 0 && e.arc(c + ft.cx, h + ft.cy, Nt, be(ft.y1, ft.x1), be(ft.y0, ft.x0), !d));
        } else
          e.moveTo(c + N, h + F), e.arc(c, h, n, l, u, !d);
        if (!(r > bi) || !B)
          e.lineTo(c + q, h + V);
        else if (C > bi) {
          var Pt = zi(p, C), Nt = zi(g, C), rt = El(q, V, D, P, r, -Nt, d), ft = El(N, F, O, I, r, -Pt, d);
          e.lineTo(c + rt.cx + rt.x0, h + rt.cy + rt.y0), C < k && Pt === Nt ? e.arc(c + rt.cx, h + rt.cy, C, be(rt.y0, rt.x0), be(ft.y0, ft.x0), !d) : (Nt > 0 && e.arc(c + rt.cx, h + rt.cy, Nt, be(rt.y0, rt.x0), be(rt.y1, rt.x1), !d), e.arc(c, h, r, be(rt.cy + rt.y1, rt.cx + rt.x1), be(ft.cy + ft.y1, ft.cx + ft.x1), d), Pt > 0 && e.arc(c + ft.cx, h + ft.cy, Pt, be(ft.y1, ft.x1), be(ft.y0, ft.x0), !d));
        } else
          e.lineTo(c + q, h + V), e.arc(c, h, r, u, l, d);
      }
      e.closePath();
    }
  }
}
var CI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
})(), $v = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new CI();
  }, t.prototype.buildPath = function(i, n) {
    TI(i, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
})(Bt);
$v.prototype.type = "sector";
var AI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
})(), zv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new AI();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, s = Math.PI * 2;
    i.moveTo(r + n.r, a), i.arc(r, a, n.r, 0, s, !1), i.moveTo(r + n.r0, a), i.arc(r, a, n.r0, 0, s, !0);
  }, t;
})(Bt);
zv.prototype.type = "ring";
function PI(e, t, i, n) {
  var r = [], a = [], s = [], o = [], l, u, c, h;
  if (n) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var d = 0, f = e.length; d < f; d++)
      $a(c, c, e[d]), za(h, h, e[d]);
    $a(c, c, n[0]), za(h, h, n[1]);
  }
  for (var d = 0, f = e.length; d < f; d++) {
    var v = e[d];
    if (i)
      l = e[d ? d - 1 : f - 1], u = e[(d + 1) % f];
    else if (d === 0 || d === f - 1) {
      r.push(eE(e[d]));
      continue;
    } else
      l = e[d - 1], u = e[d + 1];
    iE(a, u, l), dh(a, a, t);
    var p = Gd(v, l), g = Gd(v, u), m = p + g;
    m !== 0 && (p /= m, g /= m), dh(s, a, -p), dh(o, a, g);
    var _ = mm([], v, s), y = mm([], v, o);
    n && (za(_, _, c), $a(_, _, h), za(y, y, c), $a(y, y, h)), r.push(_), r.push(y);
  }
  return i && r.push(r.shift()), r;
}
function sx(e, t, i) {
  var n = t.smooth, r = t.points;
  if (r && r.length >= 2) {
    if (n) {
      var a = PI(r, n, i, t.smoothConstraint);
      e.moveTo(r[0][0], r[0][1]);
      for (var s = r.length, o = 0; o < (i ? s : s - 1); o++) {
        var l = a[o * 2], u = a[o * 2 + 1], c = r[(o + 1) % s];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(r[0][0], r[0][1]);
      for (var o = 1, h = r.length; o < h; o++)
        e.lineTo(r[o][0], r[o][1]);
    }
    i && e.closePath();
  }
}
var EI = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), Vv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new EI();
  }, t.prototype.buildPath = function(i, n) {
    sx(i, n, !0);
  }, t;
})(Bt);
Vv.prototype.type = "polygon";
var LI = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), Hv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new LI();
  }, t.prototype.buildPath = function(i, n) {
    sx(i, n, !1);
  }, t;
})(Bt);
Hv.prototype.type = "polyline";
var OI = {}, II = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
})(), ps = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new II();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, s, o;
    if (this.subPixelOptimize) {
      var l = Y1(OI, n, this.style);
      r = l.x1, a = l.y1, s = l.x2, o = l.y2;
    } else
      r = n.x1, a = n.y1, s = n.x2, o = n.y2;
    var u = n.percent;
    u !== 0 && (i.moveTo(r, a), u < 1 && (s = r * (1 - u) + s * u, o = a * (1 - u) + o * u), i.lineTo(s, o));
  }, t.prototype.pointAt = function(i) {
    var n = this.shape;
    return [
      n.x1 * (1 - i) + n.x2 * i,
      n.y1 * (1 - i) + n.y2 * i
    ];
  }, t;
})(Bt);
ps.prototype.type = "line";
var Fe = [], RI = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
})();
function N0(e, t, i) {
  var n = e.cpx2, r = e.cpy2;
  return n != null || r != null ? [
    (i ? Pm : Le)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (i ? Pm : Le)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (i ? Em : Ve)(e.x1, e.cpx1, e.x2, t),
    (i ? Em : Ve)(e.y1, e.cpy1, e.y2, t)
  ];
}
var Yv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new RI();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.x1, a = n.y1, s = n.x2, o = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, h = n.cpy2, d = n.percent;
    d !== 0 && (i.moveTo(r, a), c == null || h == null ? (d < 1 && (Eu(r, l, s, d, Fe), l = Fe[1], s = Fe[2], Eu(a, u, o, d, Fe), u = Fe[1], o = Fe[2]), i.quadraticCurveTo(l, u, s, o)) : (d < 1 && (Pu(r, l, c, s, d, Fe), l = Fe[1], c = Fe[2], s = Fe[3], Pu(a, u, h, o, d, Fe), u = Fe[1], h = Fe[2], o = Fe[3]), i.bezierCurveTo(l, u, c, h, s, o)));
  }, t.prototype.pointAt = function(i) {
    return N0(this.shape, i, !1);
  }, t.prototype.tangentAt = function(i) {
    var n = N0(this.shape, i, !0);
    return aE(n, n);
  }, t;
})(Bt);
Yv.prototype.type = "bezier-curve";
var NI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
})(), Oc = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new NI();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, s = Math.max(n.r, 0), o = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(o), h = Math.sin(o);
    i.moveTo(c * s + r, h * s + a), i.arc(r, a, s, o, l, !u);
  }, t;
})(Bt);
Oc.prototype.type = "arc";
var FI = (function(e) {
  Lt(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.type = "compound", i;
  }
  return t.prototype._updatePathDirty = function() {
    for (var i = this.shape.paths, n = this.shapeChanged(), r = 0; r < i.length; r++)
      n = n || i[r].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var i = this.shape.paths || [], n = this.getGlobalScale(), r = 0; r < i.length; r++)
      i[r].path || i[r].createPathProxy(), i[r].path.setScale(n[0], n[1], i[r].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(i, n) {
    for (var r = n.paths || [], a = 0; a < r.length; a++)
      r[a].buildPath(i, r[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var i = this.shape.paths || [], n = 0; n < i.length; n++)
      i[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), Bt.prototype.getBoundingRect.call(this);
  }, t;
})(Bt), ox = (function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, i) {
    this.colorStops.push({
      offset: t,
      color: i
    });
  }, e;
})(), lx = (function(e) {
  Lt(t, e);
  function t(i, n, r, a, s, o) {
    var l = e.call(this, s) || this;
    return l.x = i ?? 0, l.y = n ?? 0, l.x2 = r ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = o || !1, l;
  }
  return t;
})(ox), BI = (function(e) {
  Lt(t, e);
  function t(i, n, r, a, s) {
    var o = e.call(this, a) || this;
    return o.x = i ?? 0.5, o.y = n ?? 0.5, o.r = r ?? 0.5, o.type = "radial", o.global = s || !1, o;
  }
  return t;
})(ox), Kh = Math.min, $I = Math.max, Ll = Math.abs, kr = [0, 0], Dr = [0, 0], pe = a1(), Ol = pe.minTv, Il = pe.maxTv, ux = (function() {
  function e(t, i) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new It();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new It();
    t && this.fromBoundingRect(t, i);
  }
  return e.prototype.fromBoundingRect = function(t, i) {
    var n = this._corners, r = this._axes, a = t.x, s = t.y, o = a + t.width, l = s + t.height;
    if (n[0].set(a, s), n[1].set(o, s), n[2].set(o, l), n[3].set(a, l), i)
      for (var u = 0; u < 4; u++)
        n[u].transform(i);
    It.sub(r[0], n[1], n[0]), It.sub(r[1], n[3], n[0]), r[0].normalize(), r[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = r[u].dot(n[0]);
  }, e.prototype.intersect = function(t, i, n) {
    var r = !0, a = !i;
    return i && It.set(i, 0, 0), pe.reset(n, !a), !this._intersectCheckOneSide(this, t, a, 1) && (r = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (r = !1, a) || !a && !pe.negativeSize && It.copy(i, r ? pe.useDir ? pe.dirMinTv : Ol : Il), r;
  }, e.prototype._intersectCheckOneSide = function(t, i, n, r) {
    for (var a = !0, s = 0; s < 2; s++) {
      var o = t._axes[s];
      if (t._getProjMinMaxOnAxis(s, t._corners, kr), t._getProjMinMaxOnAxis(s, i._corners, Dr), pe.negativeSize || kr[1] < Dr[0] || kr[0] > Dr[1]) {
        if (a = !1, pe.negativeSize || n)
          return a;
        var l = Ll(Dr[0] - kr[1]), u = Ll(kr[0] - Dr[1]);
        Kh(l, u) > Il.len() && (l < u ? It.scale(Il, o, -l * r) : It.scale(Il, o, u * r));
      } else if (!n) {
        var l = Ll(Dr[0] - kr[1]), u = Ll(kr[0] - Dr[1]);
        (pe.useDir || Kh(l, u) < Ol.len()) && ((l < u || !pe.bidirectional) && (It.scale(Ol, o, l * r), pe.useDir && pe.calcDirMTV()), (l >= u || !pe.bidirectional) && (It.scale(Ol, o, -u * r), pe.useDir && pe.calcDirMTV()));
      }
    }
    return a;
  }, e.prototype._getProjMinMaxOnAxis = function(t, i, n) {
    for (var r = this._axes[t], a = this._origin, s = i[0].dot(r) + a[t], o = s, l = s, u = 1; u < i.length; u++) {
      var c = i[u].dot(r) + a[t];
      o = Kh(c, o), l = $I(c, l);
    }
    n[0] = o + pe.touchThreshold, n[1] = l - pe.touchThreshold, pe.negativeSize = n[1] < n[0];
  }, e;
})(), zI = [], VI = (function(e) {
  Lt(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.notClear = !0, i.incremental = !0, i._displayables = [], i._temporaryDisplayables = [], i._cursor = 0, i;
  }
  return t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(i, n) {
    n ? this._temporaryDisplayables.push(i) : this._displayables.push(i), this.markRedraw();
  }, t.prototype.addDisplayables = function(i, n) {
    n = n || !1;
    for (var r = 0; r < i.length; r++)
      this.addDisplayable(i[r], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(i) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      i && i(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      i && i(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var n = this._displayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var n = this._temporaryDisplayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var i = new ot(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var r = this._displayables[n], a = r.getBoundingRect().clone();
        r.needLocalTransform() && a.applyTransform(r.getLocalTransform(zI)), i.union(a);
      }
      this._rect = i;
    }
    return this._rect;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    if (a.contain(r[0], r[1]))
      for (var s = 0; s < this._displayables.length; s++) {
        var o = this._displayables[s];
        if (o.contain(i, n))
          return !0;
      }
    return !1;
  }, t;
})(Ko);
Gt();
function HI(e, t, i, n, r) {
  var a;
  if (t && t.ecModel) {
    var s = t.ecModel.getUpdatePayload();
    a = s && s.animation;
  }
  var o = t && t.isAnimationEnabled(), l = e === "update";
  if (o) {
    var u = void 0, c = void 0, h = void 0;
    n ? (u = nt(n.duration, 200), c = nt(n.easing, "cubicOut"), h = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), mt(h) && (h = h(i, r)), mt(u) && (u = u(i));
    var d = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return d;
  } else
    return null;
}
function Wv(e, t, i, n, r, a, s) {
  var o = !1, l;
  mt(r) ? (s = a, a = r, r = null) : Q(r) && (a = r.cb, s = r.during, o = r.isFrom, l = r.removeOpt, r = r.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = HI(e, n, r, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, r) : null);
  if (c && c.duration > 0) {
    var h = c.duration, d = c.delay, f = c.easing, v = {
      duration: h,
      delay: d || 0,
      easing: f,
      done: a,
      force: !!a || !!s,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: s
    };
    o ? t.animateFrom(i, v) : t.animateTo(i, v);
  } else
    t.stopAnimation(), !o && t.attr(i), s && s(1), a && a();
}
function Uv(e, t, i, n, r, a) {
  Wv("update", e, t, i, n, r, a);
}
function cx(e, t, i, n, r, a) {
  Wv("enter", e, t, i, n, r, a);
}
function mo(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var i = e.animators[t];
    if (i.scope === "leave")
      return !0;
  }
  return !1;
}
function hx(e, t, i, n, r, a) {
  mo(e) || Wv("leave", e, t, i, n, r, a);
}
function F0(e, t, i, n) {
  e.removeTextContent(), e.removeTextGuideLine(), hx(e, {
    style: {
      opacity: 0
    }
  }, t, i, n);
}
function YI(e, t, i) {
  function n() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(r) {
    r.isGroup || F0(r, t, i, n);
  }) : F0(e, t, i, n);
}
var bf = {}, WI = ["x", "y"], UI = ["width", "height"];
function GI(e) {
  return Bt.extend(e);
}
var XI = bI;
function jI(e, t) {
  return XI(e, t);
}
function Ei(e, t) {
  bf[e] = t;
}
function qI(e) {
  if (bf.hasOwnProperty(e))
    return bf[e];
}
function Gv(e, t, i, n) {
  var r = yI(e, t);
  return i && (n === "center" && (i = fx(i, r.getBoundingRect())), vx(r, i)), r;
}
function dx(e, t, i) {
  var n = new ua({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(r) {
      if (i === "center") {
        var a = {
          width: r.width,
          height: r.height
        };
        n.setStyle(fx(t, a));
      }
    }
  });
  return n;
}
function fx(e, t) {
  var i = t.width / t.height, n = e.height * i, r;
  n <= e.width ? r = e.height : (n = e.width, r = n / i);
  var a = e.x + e.width / 2, s = e.y + e.height / 2;
  return {
    x: a - n / 2,
    y: s - r / 2,
    width: n,
    height: r
  };
}
var ZI = xI;
function vx(e, t) {
  if (e.applyTransform) {
    var i = e.getBoundingRect(), n = i.calculateTransform(t);
    e.applyTransform(n);
  }
}
function Xv(e, t) {
  return Y1(e, e, {
    lineWidth: t
  }), e;
}
function KI(e, t) {
  return W1(e, e, t), e;
}
var QI = Yr;
function JI(e, t) {
  for (var i = Mv([]); e && e !== t; )
    ho(i, e.getLocalTransform(), i), e = e.parent;
  return i;
}
function jv(e, t, i) {
  return t && !Ge(t) && (t = Hr.getLocalTransform(t)), i && (t = Xo([], t)), Qe([], e, t);
}
function tR(e, t, i) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : mn(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : mn(2 * t[4] / t[2]), a = [e === "left" ? -n : e === "right" ? n : 0, e === "top" ? -r : e === "bottom" ? r : 0];
  return a = jv(a, t, i), mn(a[0]) > mn(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function B0(e) {
  return !e.isGroup;
}
function eR(e) {
  return e.shape != null;
}
function iR(e, t, i) {
  if (!e || !t)
    return;
  function n(s) {
    var o = {};
    return s.traverse(function(l) {
      B0(l) && l.anid && (o[l.anid] = l);
    }), o;
  }
  function r(s) {
    var o = {
      x: s.x,
      y: s.y,
      rotation: s.rotation
    };
    return eR(s) && (o.shape = pt(s.shape)), o;
  }
  var a = n(e);
  t.traverse(function(s) {
    if (B0(s) && s.anid) {
      var o = a[s.anid];
      if (o) {
        var l = r(s);
        s.attr(r(o)), Uv(s, l, i, zt(s).dataIndex);
      }
    }
  });
}
function nR(e, t) {
  return yt(e, function(i) {
    var n = i[0];
    n = Si(n, t.x), n = Eo(n, t.x + t.width);
    var r = i[1];
    return r = Si(r, t.y), r = Eo(r, t.y + t.height), [n, r];
  });
}
function rR(e, t) {
  var i = Si(e.x, t.x), n = Eo(e.x + e.width, t.x + t.width), r = Si(e.y, t.y), a = Eo(e.y + e.height, t.y + t.height);
  if (n >= i && a >= r)
    return {
      x: i,
      y: r,
      width: n - i,
      height: a - r
    };
}
function px(e, t, i) {
  var n = Y({
    rectHover: !0
  }, t), r = n.style = {
    strokeNoScale: !0
  };
  if (i = i || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (r.image = e.slice(8), Jt(r, i), new ua(n)) : Gv(e.replace("path://", ""), n, i, "center");
}
function aR(e, t, i, n, r) {
  for (var a = 0, s = r[r.length - 1]; a < r.length; a++) {
    var o = r[a];
    if (gx(e, t, i, n, o[0], o[1], s[0], s[1]))
      return !0;
    s = o;
  }
}
function gx(e, t, i, n, r, a, s, o) {
  var l = i - e, u = n - t, c = s - r, h = o - a, d = Qh(c, h, l, u);
  if (sR(d))
    return !1;
  var f = e - r, v = t - a, p = Qh(f, v, l, u) / d;
  if (p < 0 || p > 1)
    return !1;
  var g = Qh(f, v, c, h) / d;
  return !(g < 0 || g > 1);
}
function Qh(e, t, i, n) {
  return e * n - i * t;
}
function sR(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function xf(e, t, i, n, r) {
  return t == null || (Zt(t) ? Ft[0] = Ft[1] = Ft[2] = Ft[3] = t : (process.env.NODE_ENV !== "production" && it(t.length === 4), Ft[0] = t[0], Ft[1] = t[1], Ft[2] = t[2], Ft[3] = t[3]), n && (Ft[0] = Si(0, Ft[0]), Ft[1] = Si(0, Ft[1]), Ft[2] = Si(0, Ft[2]), Ft[3] = Si(0, Ft[3])), i && (Ft[0] = -Ft[0], Ft[1] = -Ft[1], Ft[2] = -Ft[2], Ft[3] = -Ft[3]), $0(e, Ft, "x", "width", 3, 1, r && r[0] || 0), $0(e, Ft, "y", "height", 0, 2, r && r[1] || 0)), e;
}
var Ft = [0, 0, 0, 0];
function $0(e, t, i, n, r, a, s) {
  var o = t[a] + t[r], l = e[n];
  e[n] += o, s = Si(0, Eo(s, l)), e[n] < s ? (e[n] = s, e[i] += t[r] >= 0 ? -t[r] : t[a] >= 0 ? l + t[a] : mn(o) > 1e-8 ? (l - s) * t[r] / o : 0) : e[i] -= t[r];
}
function qv(e) {
  var t = e.itemTooltipOption, i = e.componentModel, n = e.itemName, r = tt(t) ? {
    formatter: t
  } : t, a = i.mainType, s = i.componentIndex, o = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  o[a + "Index"] = s;
  var l = e.formatterParamsExtra;
  l && A(qt(l), function(c) {
    ji(o, c) || (o[c] = l[c], o.$vars.push(c));
  });
  var u = zt(e.el);
  u.componentMainType = a, u.componentIndex = s, u.tooltipConfig = {
    name: n,
    option: Jt({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: o
    }, r)
  };
}
function wf(e, t) {
  var i;
  e.isGroup && (i = t(e)), i || e.traverse(t);
}
function mx(e, t) {
  if (e)
    if (Z(e))
      for (var i = 0; i < e.length; i++)
        wf(e[i], t);
    else
      wf(e, t);
}
function Zv(e) {
  return !e || mn(e[1]) < Rl && mn(e[2]) < Rl || mn(e[0]) < Rl && mn(e[3]) < Rl;
}
var Rl = 1e-5;
function Io(e, t) {
  return e ? ot.copy(e, t) : t.clone();
}
function Kv(e, t) {
  return t ? kv(e || qi(), t) : void 0;
}
function Ro(e) {
  return {
    z: e.get("z") || 0,
    zlevel: e.get("zlevel") || 0
  };
}
function oR(e) {
  var t = -1 / 0, i = 1 / 0;
  wf(e, function(a) {
    n(a), n(a.getTextContent()), n(a.getTextGuideLine());
  });
  function n(a) {
    if (!(!a || a.isGroup)) {
      var s = a.currentStates;
      if (s.length)
        for (var o = 0; o < s.length; o++)
          r(a.states[s[o]]);
      r(a);
    }
  }
  function r(a) {
    if (a) {
      var s = a.z2;
      s > t && (t = s), s < i && (i = s);
    }
  }
  return i > t && (i = t = 0), {
    min: i,
    max: t
  };
}
function _x(e, t, i) {
  yx(e, t, i, -1 / 0);
}
function yx(e, t, i, n) {
  if (e.ignoreModelZ)
    return n;
  var r = e.getTextContent(), a = e.getTextGuideLine(), s = e.isGroup;
  if (s)
    for (var o = e.childrenRef(), l = 0; l < o.length; l++)
      n = Si(yx(o[l], t, i, n), n);
  else
    e.z = t, e.zlevel = i, n = Si(e.z2 || 0, n);
  if (r && (r.z = t, r.zlevel = i, isFinite(n) && (r.z2 = n + 2)), a) {
    var u = e.textGuideLineConfig;
    a.z = t, a.zlevel = i, isFinite(n) && (a.z2 = n + (u && u.showAbove ? 1 : -1));
  }
  return n;
}
Ei("circle", Lc);
Ei("ellipse", Bv);
Ei("sector", $v);
Ei("ring", zv);
Ei("polygon", Vv);
Ei("polyline", Hv);
Ei("rect", De);
Ei("line", ps);
Ei("bezierCurve", Yv);
Ei("arc", Oc);
const lR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Oc,
  BezierCurve: Yv,
  BoundingRect: ot,
  Circle: Lc,
  CompoundPath: FI,
  Ellipse: Bv,
  Group: Di,
  Image: ua,
  IncrementalDisplayable: VI,
  Line: ps,
  LinearGradient: lx,
  OrientedBoundingRect: ux,
  Path: Bt,
  Point: It,
  Polygon: Vv,
  Polyline: Hv,
  RadialGradient: BI,
  Rect: De,
  Ring: zv,
  Sector: $v,
  Text: mi,
  WH: UI,
  XY: WI,
  applyTransform: jv,
  calcZ2Range: oR,
  clipPointsByRect: nR,
  clipRectByRect: rR,
  createIcon: px,
  ensureCopyRect: Io,
  ensureCopyTransform: Kv,
  expandOrShrinkRect: xf,
  extendPath: jI,
  extendShape: GI,
  getShapeClass: qI,
  getTransform: JI,
  groupTransition: iR,
  initProps: cx,
  isBoundingRectAxisAligned: Zv,
  isElementRemoved: mo,
  lineLineIntersect: gx,
  linePolygonIntersect: aR,
  makeImage: dx,
  makePath: Gv,
  mergePath: ZI,
  registerShape: Ei,
  removeElement: hx,
  removeElementWithFadeOut: YI,
  resizePath: vx,
  retrieveZInfo: Ro,
  setTooltipConfig: qv,
  subPixelOptimize: QI,
  subPixelOptimizeLine: Xv,
  subPixelOptimizeRect: KI,
  transformDirection: tR,
  traverseElements: mx,
  traverseUpdateZ: _x,
  updateProps: Uv
}, Symbol.toStringTag, { value: "Module" }));
var Ic = {};
function uR(e, t) {
  for (var i = 0; i < nr.length; i++) {
    var n = nr[i], r = t[n], a = e.ensureState(n);
    a.style = a.style || {}, a.style.text = r;
  }
  var s = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(s, !0);
}
function z0(e, t, i) {
  var n = e.labelFetcher, r = e.labelDataIndex, a = e.labelDimIndex, s = t.normal, o;
  n && (o = n.getFormattedLabel(r, "normal", null, a, s && s.get("formatter"), i != null ? {
    interpolatedValue: i
  } : null)), o == null && (o = mt(e.defaultText) ? e.defaultText(r, e, i) : e.defaultText);
  for (var l = {
    normal: o
  }, u = 0; u < nr.length; u++) {
    var c = nr[u], h = t[c];
    l[c] = nt(n ? n.getFormattedLabel(r, c, null, a, h && h.get("formatter")) : null, o);
  }
  return l;
}
function V0(e, t, i, n) {
  i = i || Ic;
  for (var r = e instanceof mi, a = !1, s = 0; s < w0.length; s++) {
    var o = t[w0[s]];
    if (o && o.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = r ? e : e.getTextContent();
  if (a) {
    r || (l || (l = new mi(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = z0(i, t), c = t.normal, h = !!c.getShallow("show"), d = sa(c, n, i, !1, !r);
    d.text = u.normal, r || e.setTextConfig(Y0(c, i, !1));
    for (var s = 0; s < nr.length; s++) {
      var f = nr[s], o = t[f];
      if (o) {
        var v = l.ensureState(f), p = !!nt(o.getShallow("show"), h);
        if (p !== h && (v.ignore = !p), v.style = sa(o, n, i, !0, !r), v.style.text = u[f], !r) {
          var g = e.ensureState(f);
          g.textConfig = Y0(o, i, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (d.x = l.style.x), l.style.y != null && (d.y = l.style.y), l.ignore = !h, l.useStyle(d), l.dirty(), i.enableTextSetter && (fR(l).setLabelText = function(m) {
      var _ = z0(i, t, m);
      uR(l, _);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function H0(e, t) {
  t = t || "label";
  for (var i = {
    normal: e.getModel(t)
  }, n = 0; n < nr.length; n++) {
    var r = nr[n];
    i[r] = e.getModel([r, t]);
  }
  return i;
}
function sa(e, t, i, n, r) {
  var a = {};
  return cR(a, e, i, n, r), t && Y(a, t), a;
}
function Y0(e, t, i) {
  t = t || {};
  var n = {}, r, a = e.getShallow("rotate"), s = nt(e.getShallow("distance"), i ? null : 5), o = e.getShallow("offset");
  return r = e.getShallow("position") || (i ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (n.position = r), o != null && (n.offset = o), a != null && (a *= Math.PI / 180, n.rotation = a), s != null && (n.distance = s), n.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (n.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (n.layoutRect = t.layoutRect), n;
}
function cR(e, t, i, n, r) {
  i = i || Ic;
  var a = t.ecModel, s = a && a.option.textStyle, o = hR(t), l;
  if (o) {
    l = {};
    var u = "richInheritPlainLabel", c = nt(t.get(u), a ? a.get(u) : void 0);
    for (var h in o)
      if (o.hasOwnProperty(h)) {
        var d = t.getModel(["rich", h]);
        X0(l[h] = {}, d, s, t, c, i, n, r, !1, !0);
      }
  }
  l && (e.rich = l);
  var f = t.get("overflow");
  f && (e.overflow = f);
  var v = t.get("lineOverflow");
  v && (e.lineOverflow = v);
  var p = e, g = t.get("minMargin");
  if (g != null)
    g = Zt(g) ? g / 2 : 0, p.margin = [g, g, g, g], p.__marginType = Wa.minMargin;
  else {
    var m = t.get("textMargin");
    m != null && (p.margin = wv(m), p.__marginType = Wa.textMargin);
  }
  X0(e, t, s, null, null, i, n, r, !0, !1);
}
function hR(e) {
  for (var t; e && e !== e.ecModel; ) {
    var i = (e.option || Ic).rich;
    if (i) {
      t = t || {};
      for (var n = qt(i), r = 0; r < n.length; r++) {
        var a = n[r];
        t[a] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var W0 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], U0 = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], G0 = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function X0(e, t, i, n, r, a, s, o, l, u) {
  i = !s && i || Ic;
  var c = a && a.inheritColor, h = t.getShallow("color"), d = t.getShallow("textBorderColor"), f = nt(t.getShallow("opacity"), i.opacity);
  (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && ge("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), (d === "inherit" || d === "auto") && (process.env.NODE_ENV !== "production" && d === "auto" && ge("color: 'auto'", "color: 'inherit'"), c ? d = c : d = null), o || (h = h || i.color, d = d || i.textBorderColor), h != null && (e.fill = h), d != null && (e.stroke = d);
  var v = nt(t.getShallow("textBorderWidth"), i.textBorderWidth);
  v != null && (e.lineWidth = v);
  var p = nt(t.getShallow("textBorderType"), i.textBorderType);
  p != null && (e.lineDash = p);
  var g = nt(t.getShallow("textBorderDashOffset"), i.textBorderDashOffset);
  g != null && (e.lineDashOffset = g), !s && f == null && !u && (f = a && a.defaultOpacity), f != null && (e.opacity = f), !s && !o && e.fill == null && a.inheritColor && (e.fill = a.inheritColor);
  for (var m = 0; m < W0.length; m++) {
    var _ = W0[m], y = r !== !1 && n ? Zr(t.getShallow(_), n.getShallow(_), i[_]) : nt(t.getShallow(_), i[_]);
    y != null && (e[_] = y);
  }
  for (var m = 0; m < U0.length; m++) {
    var _ = U0[m], y = t.getShallow(_);
    y != null && (e[_] = y);
  }
  if (e.verticalAlign == null) {
    var b = t.getShallow("baseline");
    b != null && (e.verticalAlign = b);
  }
  if (!l || !a.disableBox) {
    for (var m = 0; m < G0.length; m++) {
      var _ = G0[m], y = t.getShallow(_);
      y != null && (e[_] = y);
    }
    var w = t.getShallow("borderType");
    w != null && (e.borderDash = w), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && ge("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = c), (e.borderColor === "auto" || e.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && ge("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = c);
  }
}
function dR(e, t) {
  var i = t && t.getModel("textStyle");
  return Ui([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || i && i.getShallow("fontStyle") || "",
    e.fontWeight || i && i.getShallow("fontWeight") || "",
    (e.fontSize || i && i.getShallow("fontSize") || 12) + "px",
    e.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var fR = Gt(), Wa = {
  minMargin: 1,
  textMargin: 2
}, vR = ["textStyle", "color"], Jh = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], td = new mi(), pR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var i = this.ecModel;
      return this.getShallow("color") || (!t && i ? i.get(vR) : null);
    }, e.prototype.getFont = function() {
      return dR({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var i = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < Jh.length; n++)
        i[Jh[n]] = this.getShallow(Jh[n]);
      return td.useStyle(i), td.update(), td.getBoundingRect();
    }, e;
  })()
), bx = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], gR = Oo(bx), mR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return gR(this, t);
    }, e;
  })()
), xx = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], _R = Oo(xx), yR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, i) {
      return _R(this, t, i);
    }, e;
  })()
), jt = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.parentModel = i, this.ecModel = n, this.option = t;
    }
    return e.prototype.init = function(t, i, n) {
    }, e.prototype.mergeOption = function(t, i) {
      se(this.option, t, !0);
    }, e.prototype.get = function(t, i) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !i && this.parentModel);
    }, e.prototype.getShallow = function(t, i) {
      var n = this.option, r = n == null ? n : n[t];
      if (r == null && !i) {
        var a = this.parentModel;
        a && (r = a.getShallow(t));
      }
      return r;
    }, e.prototype.getModel = function(t, i) {
      var n = t != null, r = n ? this.parsePath(t) : null, a = n ? this._doGet(r) : this.option;
      return i = i || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new e(a, i, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(pt(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!st.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, i) {
      var n = this.option;
      if (!t)
        return n;
      for (var r = 0; r < t.length && !(t[r] && (n = n && typeof n == "object" ? n[t[r]] : null, n == null)); r++)
        ;
      return n == null && i && (n = i._doGet(this.resolveParentPath(t), i.parentModel)), n;
    }, e;
  })()
);
Av(jt);
KL(jt);
Ai(jt, mR);
Ai(jt, yR);
Ai(jt, iO);
Ai(jt, pR);
var bR = Math.round(Math.random() * 10);
function Rc(e) {
  return [e || "", bR++].join("_");
}
function xR(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(i, n) {
    var r = Gi(i);
    t[r.main] = n;
  }, e.determineSubType = function(i, n) {
    var r = n.type;
    if (!r) {
      var a = Gi(i).main;
      e.hasSubTypes(i) && t[a] && (r = t[a](n));
    }
    return r;
  };
}
function wR(e, t) {
  e.topologicalTravel = function(a, s, o, l) {
    if (!a.length)
      return;
    var u = i(s), c = u.graph, h = u.noEntryList, d = {};
    for (A(a, function(_) {
      d[_] = !0;
    }); h.length; ) {
      var f = h.pop(), v = c[f], p = !!d[f];
      p && (o.call(l, f, v.originalDeps.slice()), delete d[f]), A(v.successor, p ? m : g);
    }
    A(d, function() {
      var _ = "";
      throw process.env.NODE_ENV !== "production" && (_ = Fu("Circular dependency may exists: ", d, a, s)), new Error(_);
    });
    function g(_) {
      c[_].entryCount--, c[_].entryCount === 0 && h.push(_);
    }
    function m(_) {
      d[_] = !0, g(_);
    }
  };
  function i(a) {
    var s = {}, o = [];
    return A(a, function(l) {
      var u = n(s, l), c = u.originalDeps = t(l), h = r(c, a);
      u.entryCount = h.length, u.entryCount === 0 && o.push(l), A(h, function(d) {
        Vt(u.predecessor, d) < 0 && u.predecessor.push(d);
        var f = n(s, d);
        Vt(f.successor, d) < 0 && f.successor.push(l);
      });
    }), {
      graph: s,
      noEntryList: o
    };
  }
  function n(a, s) {
    return a[s] || (a[s] = {
      predecessor: [],
      successor: []
    }), a[s];
  }
  function r(a, s) {
    var o = [];
    return A(a, function(l) {
      Vt(s, l) >= 0 && o.push(l);
    }), o;
  }
}
const SR = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, MR = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var Yu = "ZH", Qv = "EN", Ka = Qv, lu = {}, Jv = {}, Sx = st.domSupported ? (function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Ka).toUpperCase()
  );
  return e.indexOf(Yu) > -1 ? Yu : Ka;
})() : Ka;
function Mx(e, t) {
  e = e.toUpperCase(), Jv[e] = new jt(t), lu[e] = t;
}
function kR(e) {
  if (tt(e)) {
    var t = lu[e.toUpperCase()] || {};
    return e === Yu || e === Qv ? pt(t) : se(pt(t), pt(lu[Ka]), !1);
  } else
    return se(pt(e), pt(lu[Ka]), !1);
}
function DR(e) {
  return Jv[e];
}
function TR() {
  return Jv[Ka];
}
Mx(Qv, SR);
Mx(Yu, MR);
function Rn(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function kx(e, t, i, n) {
  var r = Tc(e), a = r[CR(i)](), s = r[AR(i)]() + 1, o = Math.floor((s - 1) / 3) + 1, l = r[PR(i)](), u = r["get" + (i ? "UTC" : "") + "Day"](), c = r[ER(i)](), h = (c - 1) % 12 + 1, d = r[LR(i)](), f = r[OR(i)](), v = r[IR(i)](), p = c >= 12 ? "pm" : "am", g = p.toUpperCase(), m = n instanceof jt ? n : DR(Sx) || TR(), _ = m.getModel("time"), y = _.get("month"), b = _.get("monthAbbr"), w = _.get("dayOfWeek"), S = _.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, p + "").replace(/{A}/g, g + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, Rn(a % 100 + "", 2)).replace(/{Q}/g, o + "").replace(/{MMMM}/g, y[s - 1]).replace(/{MMM}/g, b[s - 1]).replace(/{MM}/g, Rn(s, 2)).replace(/{M}/g, s + "").replace(/{dd}/g, Rn(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, w[u]).replace(/{ee}/g, S[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Rn(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Rn(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Rn(d, 2)).replace(/{m}/g, d + "").replace(/{ss}/g, Rn(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, Rn(v, 3)).replace(/{S}/g, v + "");
}
function CR(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function AR(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function PR(e) {
  return e ? "getUTCDate" : "getDate";
}
function ER(e) {
  return e ? "getUTCHours" : "getHours";
}
function LR(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function OR(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function IR(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function RR(e) {
  if (!T1(e))
    return tt(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function Dx(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(i, n) {
    return n.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var tp = wv;
function Sf(e, t, i) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function r(c) {
    return c && Ui(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var s = t === "time", o = e instanceof Date;
  if (s || o) {
    var l = s ? Tc(e) : e;
    if (isNaN(+l)) {
      if (o)
        return "-";
    } else return kx(l, n, i);
  }
  if (t === "ordinal")
    return ku(e) ? r(e) : Zt(e) && a(e) ? e + "" : "-";
  var u = Nu(e);
  return a(u) ? RR(u) : ku(e) ? r(e) : typeof e == "boolean" ? e + "" : "-";
}
var j0 = ["a", "b", "c", "d", "e", "f", "g"], ed = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function Tx(e, t, i) {
  Z(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
    var s = j0[a];
    e = e.replace(ed(s), ed(s, 0));
  }
  for (var o = 0; o < n; o++)
    for (var l = 0; l < r.length; l++) {
      var u = t[o][r[l]];
      e = e.replace(ed(j0[l], o), i ? ze(u) : u);
    }
  return e;
}
function NR(e, t) {
  var i = tt(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, n = i.color, r = i.type;
  t = i.extraCssText;
  var a = i.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + ze(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + ze(n) + ";" + (t || "") + '"></span>';
  var s = i.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + s + "|}  ",
    style: r === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function No(e, t) {
  return t = t || "transparent", tt(e) ? e : Q(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function q0(e, t) {
  if (t === "_blank" || t === "blank") {
    var i = window.open();
    i.opener = null, i.location.href = e;
  } else
    window.open(e, t);
}
var id = {}, nd = {}, Nc = (
  /** @class */
  (function() {
    function e() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return e.prototype.create = function(t, i) {
      this._nonSeriesBoxMasterList = n(id, !0), this._normalMasterList = n(nd, !1);
      function n(r, a) {
        var s = [];
        return A(r, function(o, l) {
          var u = o.create(t, i);
          s = s.concat(u || []), process.env.NODE_ENV !== "production" && a && A(u, function(c) {
            return it(!c.update);
          });
        }), s;
      }
    }, e.prototype.update = function(t, i) {
      A(this._normalMasterList, function(n) {
        n.update && n.update(t, i);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, e.register = function(t, i) {
      if (t === "matrix" || t === "calendar") {
        id[t] = i;
        return;
      }
      nd[t] = i;
    }, e.get = function(t) {
      return nd[t] || id[t];
    }, e;
  })()
), Z0 = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
}, FR = ct();
function BR(e) {
  var t = e.getShallow("coord", !0), i = Z0.coord;
  if (t == null) {
    var n = FR.get(e.type);
    n && n.getCoord2 && (i = Z0.coord2, t = n.getCoord2(e));
  }
  return {
    coord: t,
    from: i
  };
}
var uu = A, $R = ["left", "right", "top", "bottom", "width", "height"], Nl = [["width", "left", "right"], ["height", "top", "bottom"]];
function Cx(e, t, i, n, r) {
  var a = 0, s = 0;
  n == null && (n = 1 / 0), r == null && (r = 1 / 0);
  var o = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = t.childAt(u + 1), d = h && h.getBoundingRect(), f, v;
    if (e === "horizontal") {
      var p = c.width + (d ? -d.x + c.x : 0);
      f = a + p, f > n || l.newline ? (a = 0, f = p, s += o + i, o = c.height) : o = Math.max(o, c.height);
    } else {
      var g = c.height + (d ? -d.y + c.y : 0);
      v = s + g, v > r || l.newline ? (a += o + i, s = 0, v = g, o = c.width) : o = Math.max(o, c.width);
    }
    l.newline || (l.x = a, l.y = s, l.markRedraw(), e === "horizontal" ? a = f + i : s = v + i);
  });
}
Oe(Cx, "vertical");
Oe(Cx, "horizontal");
function zR(e, t) {
  return {
    left: e.getShallow("left", t),
    top: e.getShallow("top", t),
    right: e.getShallow("right", t),
    bottom: e.getShallow("bottom", t),
    width: e.getShallow("width", t),
    height: e.getShallow("height", t)
  };
}
function ep(e, t, i) {
  i = tp(i || 0);
  var n = t.width, r = t.height, a = He(e.left, n), s = He(e.top, r), o = He(e.right, n), l = He(e.bottom, r), u = He(e.width, n), c = He(e.height, r), h = i[2] + i[0], d = i[1] + i[3], f = e.aspect;
  switch (isNaN(u) && (u = n - o - d - a), isNaN(c) && (c = r - l - h - s), f != null && (isNaN(u) && isNaN(c) && (f > n / r ? u = n * 0.8 : c = r * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(a) && (a = n - o - u - d), isNaN(s) && (s = r - l - c - h), e.left || e.right) {
    case "center":
      a = n / 2 - u / 2 - i[3];
      break;
    case "right":
      a = n - u - d;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      s = r / 2 - c / 2 - i[0];
      break;
    case "bottom":
      s = r - c - h;
      break;
  }
  a = a || 0, s = s || 0, isNaN(u) && (u = n - d - a - (o || 0)), isNaN(c) && (c = r - h - s - (l || 0));
  var v = new ot((t.x || 0) + a + i[3], (t.y || 0) + s + i[0], u, c);
  return v.margin = i, v;
}
var rd = {
  rect: 1
};
function Ax(e, t, i) {
  var n, r, a, s = e.boxCoordinateSystem, o;
  if (s) {
    var l = BR(e), u = l.coord, c = l.from;
    if (s.dataToLayout) {
      a = rd.rect, o = c;
      var h = s.dataToLayout(u);
      n = h.contentRect || h.rect;
    } else
      process.env.NODE_ENV !== "production" && Kt(e.type + "[" + e.componentIndex + "]" + (" layout based on " + s.type + " is not supported."));
  }
  return a == null && (a = rd.rect), a === rd.rect && (n || (n = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), r = [n.x + n.width / 2, n.y + n.height / 2]), {
    type: a,
    refContainer: n,
    refPoint: r,
    boxCoordFrom: o
  };
}
function Wu(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return Q(t) ? t : t ? {
    type: t
  } : null;
}
function Uu(e, t, i) {
  var n = i && i.ignoreSize;
  !Z(n) && (n = [n, n]);
  var r = s(Nl[0], 0), a = s(Nl[1], 1);
  l(Nl[0], e, r), l(Nl[1], e, a);
  function s(u, c) {
    var h = {}, d = 0, f = {}, v = 0, p = 2;
    if (uu(u, function(_) {
      f[_] = e[_];
    }), uu(u, function(_) {
      ji(t, _) && (h[_] = f[_] = t[_]), o(h, _) && d++, o(f, _) && v++;
    }), n[c])
      return o(t, u[1]) ? f[u[2]] = null : o(t, u[2]) && (f[u[1]] = null), f;
    if (v === p || !d)
      return f;
    if (d >= p)
      return h;
    for (var g = 0; g < u.length; g++) {
      var m = u[g];
      if (!ji(h, m) && ji(e, m)) {
        h[m] = e[m];
        break;
      }
    }
    return h;
  }
  function o(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, h) {
    uu(u, function(d) {
      c[d] = h[d];
    });
  }
}
function Px(e) {
  return VR({}, e);
}
function VR(e, t) {
  return t && e && uu($R, function(i) {
    ji(t, i) && (e[i] = t[i]);
  }), e;
}
var HR = Gt(), Et = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i, n, r) {
      var a = e.call(this, i, n, r) || this;
      return a.uid = Rc("ec_cpt_model"), a;
    }
    return t.prototype.init = function(i, n, r) {
      this.mergeDefaultAndTheme(i, r);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = Wu(this), a = r ? Px(i) : {}, s = n.getTheme();
      se(i, s.get(this.mainType)), se(i, this.getDefaultOption()), r && Uu(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      se(this.option, i, !0);
      var r = Wu(this);
      r && Uu(this.option, i, r);
    }, t.prototype.optionUpdated = function(i, n) {
    }, t.prototype.getDefaultOption = function() {
      var i = this.constructor;
      if (!jL(i))
        return i.defaultOption;
      var n = HR(this);
      if (!n.defaultOption) {
        for (var r = [], a = i; a; ) {
          var s = a.prototype.defaultOption;
          s && r.push(s), a = a.superClass;
        }
        for (var o = {}, l = r.length - 1; l >= 0; l--)
          o = se(o, r[l], !0);
        n.defaultOption = o;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(i, n) {
      var r = i + "Index", a = i + "Id";
      return Zo(this.ecModel, i, {
        index: this.get(r, !0),
        id: this.get(a, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      return zR(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(i) {
      this.option.zlevel = i;
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "component", i.id = "", i.name = "", i.mainType = "", i.subType = "", i.componentIndex = 0;
    })(), t;
  })(jt)
);
R1(Et, jt);
Pv(Et);
xR(Et);
wR(Et, YR);
function YR(e) {
  var t = [];
  return A(Et.getClassesByMainType(e), function(i) {
    t = t.concat(i.dependencies || i.prototype.dependencies || []);
  }), t = yt(t, function(i) {
    return Gi(i).main;
  }), e !== "dataset" && Vt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var St = {
  color: {},
  darkColor: {},
  size: {}
}, Qt = St.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
Y(Qt, {
  primary: Qt.neutral80,
  secondary: Qt.neutral70,
  tertiary: Qt.neutral60,
  quaternary: Qt.neutral50,
  disabled: Qt.neutral20,
  border: Qt.neutral30,
  borderTint: Qt.neutral20,
  borderShade: Qt.neutral40,
  background: Qt.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: Qt.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: Qt.neutral70,
  axisLineTint: Qt.neutral40,
  axisTick: Qt.neutral70,
  axisTickMinor: Qt.neutral60,
  axisLabel: Qt.neutral70,
  axisSplitLine: Qt.neutral15,
  axisMinorSplitLine: Qt.neutral05
});
for (var Tr in Qt)
  if (Qt.hasOwnProperty(Tr)) {
    var K0 = Qt[Tr];
    Tr === "theme" ? St.darkColor.theme = Qt.theme.slice() : Tr === "highlight" ? St.darkColor.highlight = "rgba(255,231,130,0.4)" : Tr.indexOf("accent") === 0 ? St.darkColor[Tr] = Za(K0, null, function(e) {
      return e * 0.5;
    }, function(e) {
      return Math.min(1, 1.3 - e);
    }) : St.darkColor[Tr] = Za(K0, null, function(e) {
      return e * 0.9;
    }, function(e) {
      return 1 - Math.pow(e, 1.5);
    });
  }
St.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var Ex = "";
typeof navigator < "u" && (Ex = navigator.platform || "");
var Da = "rgba(0, 0, 0, 0.2)", Lx = St.color.theme[0], WR = Za(Lx, null, null, 0.9);
const UR = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: St.color.theme,
  gradientColor: [WR, Lx],
  aria: {
    decal: {
      decals: [{
        color: Da,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Da,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Da,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Da,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Da,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Da,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: Ex.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Mf = ct(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Je = "original", Ae = "arrayRows", Li = "objectRows", tn = "keyedColumns", wn = "typedArray", Ox = "unknown", Qi = "column", ca = "row", Xe = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, Ix = Gt();
function GR(e) {
  Ix(e).datasetMap = ct();
}
function XR(e, t, i) {
  var n = {}, r = Rx(t);
  if (!r || !e)
    return n;
  var a = [], s = [], o = t.ecModel, l = Ix(o).datasetMap, u = r.uid + "_" + i.seriesLayoutBy, c, h;
  e = e.slice(), A(e, function(p, g) {
    var m = Q(p) ? p : e[g] = {
      name: p
    };
    m.type === "ordinal" && c == null && (c = g, h = v(m)), n[m.name] = [];
  });
  var d = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  A(e, function(p, g) {
    var m = p.name, _ = v(p);
    if (c == null) {
      var y = d.valueWayDim;
      f(n[m], y, _), f(s, y, _), d.valueWayDim += _;
    } else if (c === g)
      f(n[m], 0, _), f(a, 0, _);
    else {
      var y = d.categoryWayDim;
      f(n[m], y, _), f(s, y, _), d.categoryWayDim += _;
    }
  });
  function f(p, g, m) {
    for (var _ = 0; _ < m; _++)
      p.push(g + _);
  }
  function v(p) {
    var g = p.dimsDef;
    return g ? g.length : 1;
  }
  return a.length && (n.itemName = a), s.length && (n.seriesName = s), n;
}
function Rx(e) {
  var t = e.get("data", !0);
  if (!t)
    return Zo(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, zn).models[0];
}
function jR(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : Zo(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, zn).models;
}
function Nx(e, t) {
  return qR(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function qR(e, t, i, n, r, a) {
  var s, o = 5;
  if (Re(e))
    return Xe.Not;
  var l, u;
  if (n) {
    var c = n[a];
    Q(c) ? (l = c.name, u = c.type) : tt(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Xe.Must : Xe.Not;
  if (t === Ae) {
    var h = e;
    if (i === ca) {
      for (var d = h[a], f = 0; f < (d || []).length && f < o; f++)
        if ((s = b(d[r + f])) != null)
          return s;
    } else
      for (var f = 0; f < h.length && f < o; f++) {
        var v = h[r + f];
        if (v && (s = b(v[a])) != null)
          return s;
      }
  } else if (t === Li) {
    var p = e;
    if (!l)
      return Xe.Not;
    for (var f = 0; f < p.length && f < o; f++) {
      var g = p[f];
      if (g && (s = b(g[l])) != null)
        return s;
    }
  } else if (t === tn) {
    var m = e;
    if (!l)
      return Xe.Not;
    var d = m[l];
    if (!d || Re(d))
      return Xe.Not;
    for (var f = 0; f < d.length && f < o; f++)
      if ((s = b(d[f])) != null)
        return s;
  } else if (t === Je)
    for (var _ = e, f = 0; f < _.length && f < o; f++) {
      var g = _[f], y = jo(g);
      if (!Z(y))
        return Xe.Not;
      if ((s = b(y[a])) != null)
        return s;
    }
  function b(w) {
    var S = tt(w);
    if (w != null && Number.isFinite(Number(w)) && w !== "")
      return S ? Xe.Might : Xe.Not;
    if (S && w !== "-")
      return Xe.Must;
  }
  return Xe.Not;
}
var ZR = ct();
function KR(e, t, i) {
  var n = ZR.get(t);
  if (!n)
    return i;
  var r = n(e);
  if (!r)
    return i;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < r.length; a++)
      it(os(r[a]));
  return i.concat(r);
}
var Q0 = Gt();
Gt();
var ip = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, i, n) {
      var r = Ie(this.get("color", !0)), a = this.get("colorLayer", !0);
      return JR(this, Q0, r, a, t, i, n);
    }, e.prototype.clearColorPalette = function() {
      t5(this, Q0);
    }, e;
  })()
);
function QR(e, t) {
  for (var i = e.length, n = 0; n < i; n++)
    if (e[n].length > t)
      return e[n];
  return e[i - 1];
}
function JR(e, t, i, n, r, a, s) {
  a = a || e;
  var o = t(a), l = o.paletteIdx || 0, u = o.paletteNameMap = o.paletteNameMap || {};
  if (u.hasOwnProperty(r))
    return u[r];
  var c = s == null || !n ? i : QR(n, s);
  if (c = c || i, !(!c || !c.length)) {
    var h = c[l];
    return r && (u[r] = h), o.paletteIdx = (l + 1) % c.length, h;
  }
}
function t5(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var Fl, Ps, J0, ad = "\0_ec_inner", t_ = 1, e5 = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, i5 = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Gu = {};
function n5(e) {
  A(e, function(t, i) {
    if (!Et.hasClass(i)) {
      var n = e5[i];
      n && !Gu[n] && (Kt("Component " + i + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), Gu[n] = !0);
    }
  });
}
var np = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(i, n, r, a, s, o) {
      a = a || {}, this.option = null, this._theme = new jt(a), this._locale = new jt(s), this._optionManager = o;
    }, t.prototype.setOption = function(i, n, r) {
      process.env.NODE_ENV !== "production" && (it(i != null, "option is null/undefined"), it(i[ad] !== t_, "please use chart.getOption()"));
      var a = n_(n);
      this._optionManager.setOption(i, r, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(i, n) {
      return this._resetOption(i, n_(n));
    }, t.prototype._resetOption = function(i, n) {
      var r = !1, a = this._optionManager;
      if (!i || i === "recreate") {
        var s = a.mountOption(i === "recreate");
        process.env.NODE_ENV !== "production" && n5(s), !this.option || i === "recreate" ? J0(this, s) : (this.restoreData(), this._mergeOption(s, n)), r = !0;
      }
      if ((i === "timeline" || i === "media") && this.restoreData(), !i || i === "recreate" || i === "timeline") {
        var o = a.getTimelineOption(this);
        o && (r = !0, this._mergeOption(o, n));
      }
      if (!i || i === "recreate" || i === "media") {
        var l = a.getMediaOption(this);
        l.length && A(l, function(u) {
          r = !0, this._mergeOption(u, n);
        }, this);
      }
      return r;
    }, t.prototype.mergeOption = function(i) {
      this._mergeOption(i, null);
    }, t.prototype._mergeOption = function(i, n) {
      var r = this.option, a = this._componentsMap, s = this._componentsCount, o = [], l = ct(), u = n && n.replaceMergeMainTypeMap;
      GR(this), A(i, function(h, d) {
        h != null && (Et.hasClass(d) ? d && (o.push(d), l.set(d, !0)) : r[d] = r[d] == null ? pt(h) : se(r[d], h, !0));
      }), u && u.each(function(h, d) {
        Et.hasClass(d) && !l.get(d) && (o.push(d), l.set(d, !0));
      }), Et.topologicalTravel(o, Et.getAllClassMainTypes(), c, this);
      function c(h) {
        var d = KR(this, h, Ie(i[h])), f = a.get(h), v = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          f ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), p = OL(f, d, v);
        zL(p, h, Et), r[h] = null, a.set(h, null), s.set(h, 0);
        var g = [], m = [], _ = 0, y, b;
        A(p, function(w, S) {
          var M = w.existing, k = w.newOption;
          if (!k)
            M && (M.mergeOption({}, this), M.optionUpdated({}, !1));
          else {
            var T = h === "series", C = Et.getClass(
              h,
              w.keyInfo.subType,
              !T
              // Give a more detailed warn later if series don't exists
            );
            if (!C) {
              if (process.env.NODE_ENV !== "production") {
                var D = w.keyInfo.subType, P = i5[D];
                Gu[D] || (Gu[D] = !0, Kt(P ? "Series " + D + ` is used but not imported.
import { ` + P + ` } from 'echarts/charts';
echarts.use([` + P + "]);" : "Unknown series " + D));
              }
              return;
            }
            if (h === "tooltip") {
              if (y) {
                process.env.NODE_ENV !== "production" && (b || (ui("Currently only one tooltip component is allowed."), b = !0));
                return;
              }
              y = !0;
            }
            if (M && M.constructor === C)
              M.name = w.keyInfo.name, M.mergeOption(k, this), M.optionUpdated(k, !1);
            else {
              var O = Y({
                componentIndex: S
              }, w.keyInfo);
              M = new C(k, this, this, O), Y(M, O), w.brandNew && (M.__requireNewView = !0), M.init(k, this, this), M.optionUpdated(null, !0);
            }
          }
          M ? (g.push(M.option), m.push(M), _++) : (g.push(void 0), m.push(void 0));
        }, this), r[h] = g, a.set(h, m), s.set(h, _), h === "series" && Fl(this);
      }
      this._seriesIndices || Fl(this);
    }, t.prototype.getOption = function() {
      var i = pt(this.option);
      return A(i, function(n, r) {
        if (Et.hasClass(r)) {
          for (var a = Ie(n), s = a.length, o = !1, l = s - 1; l >= 0; l--)
            a[l] && !os(a[l]) ? o = !0 : (a[l] = null, !o && s--);
          a.length = s, i[r] = a;
        }
      }), delete i[ad], i;
    }, t.prototype.setTheme = function(i) {
      this._theme = new jt(i), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(i) {
      this._payload = i;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(i, n) {
      var r = this._componentsMap.get(i);
      if (r) {
        var a = r[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var s = 0; s < r.length; s++)
            if (r[s])
              return r[s];
        }
      }
    }, t.prototype.queryComponents = function(i) {
      var n = i.mainType;
      if (!n)
        return [];
      var r = i.index, a = i.id, s = i.name, o = this._componentsMap.get(n);
      if (!o || !o.length)
        return [];
      var l;
      return r != null ? (l = [], A(Ie(r), function(u) {
        o[u] && l.push(o[u]);
      })) : a != null ? l = e_("id", a, o) : s != null ? l = e_("name", s, o) : l = Ze(o, function(u) {
        return !!u;
      }), i_(l, i);
    }, t.prototype.findComponents = function(i) {
      var n = i.query, r = i.mainType, a = o(n), s = a ? this.queryComponents(a) : Ze(this._componentsMap.get(r), function(u) {
        return !!u;
      });
      return l(i_(s, i));
      function o(u) {
        var c = r + "Index", h = r + "Id", d = r + "Name";
        return u && (u[c] != null || u[h] != null || u[d] != null) ? {
          mainType: r,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[d]
        } : null;
      }
      function l(u) {
        return i.filter ? Ze(u, i.filter) : u;
      }
    }, t.prototype.eachComponent = function(i, n, r) {
      var a = this._componentsMap;
      if (mt(i)) {
        var s = n, o = i;
        a.each(function(h, d) {
          for (var f = 0; h && f < h.length; f++) {
            var v = h[f];
            v && o.call(s, d, v, v.componentIndex);
          }
        });
      } else
        for (var l = tt(i) ? a.get(i) : Q(i) ? this.findComponents(i) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(r, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(i) {
      var n = ki(i, null);
      return Ze(this._componentsMap.get("series"), function(r) {
        return !!r && n != null && r.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(i) {
      return this._componentsMap.get("series")[i];
    }, t.prototype.getSeriesByType = function(i) {
      return Ze(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === i;
      });
    }, t.prototype.getSeries = function() {
      return Ze(this._componentsMap.get("series"), function(i) {
        return !!i;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(i, n) {
      Ps(this), A(this._seriesIndices, function(r) {
        var a = this._componentsMap.get("series")[r];
        i.call(n, a, r);
      }, this);
    }, t.prototype.eachRawSeries = function(i, n) {
      A(this._componentsMap.get("series"), function(r) {
        r && i.call(n, r, r.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(i, n, r) {
      Ps(this), A(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        s.subType === i && n.call(r, s, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(i, n, r) {
      return A(this.getSeriesByType(i), n, r);
    }, t.prototype.isSeriesFiltered = function(i) {
      return Ps(this), this._seriesIndicesMap.get(i.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(i, n) {
      Ps(this);
      var r = [];
      A(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        i.call(n, s, a) && r.push(a);
      }, this), this._seriesIndices = r, this._seriesIndicesMap = ct(r);
    }, t.prototype.restoreData = function(i) {
      Fl(this);
      var n = this._componentsMap, r = [];
      n.each(function(a, s) {
        Et.hasClass(s) && r.push(s);
      }), Et.topologicalTravel(r, Et.getAllClassMainTypes(), function(a) {
        A(n.get(a), function(s) {
          s && (a !== "series" || !r5(s, i)) && s.restoreData();
        });
      });
    }, t.internalField = (function() {
      Fl = function(i) {
        var n = i._seriesIndices = [];
        A(i._componentsMap.get("series"), function(r) {
          r && n.push(r.componentIndex);
        }), i._seriesIndicesMap = ct(n);
      }, Ps = function(i) {
        if (process.env.NODE_ENV !== "production" && !i._seriesIndices)
          throw new Error("Option should contains series.");
      }, J0 = function(i, n) {
        i.option = {}, i.option[ad] = t_, i._componentsMap = ct({
          series: []
        }), i._componentsCount = ct();
        var r = n.aria;
        Q(r) && r.enabled == null && (r.enabled = !0), a5(n, i._theme.option), se(n, UR, !1), i._mergeOption(n, null);
      };
    })(), t;
  })(jt)
);
function r5(e, t) {
  if (t) {
    var i = t.seriesIndex, n = t.seriesId, r = t.seriesName;
    return i != null && e.componentIndex !== i || n != null && e.id !== n || r != null && e.name !== r;
  }
}
function a5(e, t) {
  var i = e.color && !e.colorLayer;
  A(t, function(n, r) {
    r === "colorLayer" && i || r === "color" && e.color || Et.hasClass(r) || (typeof n == "object" ? e[r] = e[r] ? se(e[r], n, !1) : pt(n) : e[r] == null && (e[r] = n));
  });
}
function e_(e, t, i) {
  if (Z(t)) {
    var n = ct();
    return A(t, function(a) {
      if (a != null) {
        var s = ki(a, null);
        s != null && n.set(a, !0);
      }
    }), Ze(i, function(a) {
      return a && n.get(a[e]);
    });
  } else {
    var r = ki(t, null);
    return Ze(i, function(a) {
      return a && r != null && a[e] === r;
    });
  }
}
function i_(e, t) {
  return t.hasOwnProperty("subType") ? Ze(e, function(i) {
    return i && i.subType === t.subType;
  }) : e;
}
function n_(e) {
  var t = ct();
  return e && A(Ie(e.replaceMerge), function(i) {
    process.env.NODE_ENV !== "production" && it(Et.hasClass(i), '"' + i + '" is not valid component main type in "replaceMerge"'), t.set(i, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
Ai(np, ip);
var s5 = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], Fx = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      A(s5, function(i) {
        this[i] = Dt(t[i], t);
      }, this);
    }
    return e;
  })()
), o5 = /^(min|max)?(.+)$/, l5 = (
  /** @class */
  (function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, i, n) {
      t && (A(Ie(t.series), function(s) {
        s && s.data && Re(s.data) && Wd(s.data);
      }), A(Ie(t.dataset), function(s) {
        s && s.source && Re(s.source) && Wd(s.source);
      })), t = pt(t);
      var r = this._optionBackup, a = u5(t, i, !r);
      this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, e.prototype.mountOption = function(t) {
      var i = this._optionBackup;
      return this._timelineOptions = i.timelineOptions, this._mediaList = i.mediaList, this._mediaDefault = i.mediaDefault, this._currentMediaIndices = [], pt(t ? i.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var i, n = this._timelineOptions;
      if (n.length) {
        var r = t.getComponent("timeline");
        r && (i = pt(
          // FIXME:TS as TimelineModel or quivlant interface
          n[r.getCurrentIndex()]
        ));
      }
      return i;
    }, e.prototype.getMediaOption = function(t) {
      var i = this._api.getWidth(), n = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, s = [], o = [];
      if (!r.length && !a)
        return o;
      for (var l = 0, u = r.length; l < u; l++)
        c5(r[l].query, i, n) && s.push(l);
      return !s.length && a && (s = [-1]), s.length && !d5(s, this._currentMediaIndices) && (o = yt(s, function(c) {
        return pt(c === -1 ? a.option : r[c].option);
      })), this._currentMediaIndices = s, o;
    }, e;
  })()
);
function u5(e, t, i) {
  var n = [], r, a, s = e.baseOption, o = e.timeline, l = e.options, u = e.media, c = !!e.media, h = !!(l || o || s && s.timeline);
  s ? (a = s, a.timeline || (a.timeline = o)) : ((h || c) && (e.options = e.media = null), a = e), c && (Z(u) ? A(u, function(f) {
    process.env.NODE_ENV !== "production" && f && !f.option && Q(f.query) && Q(f.query.option) && Kt("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), f && f.option && (f.query ? n.push(f) : r || (r = f));
  }) : process.env.NODE_ENV !== "production" && Kt("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), d(a), A(l, function(f) {
    return d(f);
  }), A(n, function(f) {
    return d(f.option);
  });
  function d(f) {
    A(t, function(v) {
      v(f, i);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: r,
    mediaList: n
  };
}
function c5(e, t, i) {
  var n = {
    width: t,
    height: i,
    aspectratio: t / i
    // lower case for convenience.
  }, r = !0;
  return A(e, function(a, s) {
    var o = s.match(o5);
    if (!(!o || !o[1] || !o[2])) {
      var l = o[1], u = o[2].toLowerCase();
      h5(n[u], a, l) || (r = !1);
    }
  }), r;
}
function h5(e, t, i) {
  return i === "min" ? e >= t : i === "max" ? e <= t : e === t;
}
function d5(e, t) {
  return e.join(",") === t.join(",");
}
var ii = A, Fo = Q, r_ = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function sd(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0, n = r_.length; i < n; i++) {
      var r = r_[i], a = t.normal, s = t.emphasis;
      a && a[r] && (process.env.NODE_ENV !== "production" && ge("itemStyle.normal." + r, r), e[r] = e[r] || {}, e[r].normal ? se(e[r].normal, a[r]) : e[r].normal = a[r], a[r] = null), s && s[r] && (process.env.NODE_ENV !== "production" && ge("itemStyle.emphasis." + r, "emphasis." + r), e[r] = e[r] || {}, e[r].emphasis ? se(e[r].emphasis, s[r]) : e[r].emphasis = s[r], s[r] = null);
    }
}
function we(e, t, i) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var n = e[t].normal, r = e[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && Dn("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), i ? (e[t].normal = e[t].emphasis = null, Jt(e[t], n)) : e[t] = n), r && (process.env.NODE_ENV !== "production" && Dn(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = r, r.focus && (e.emphasis.focus = r.focus), r.blurScope && (e.emphasis.blurScope = r.blurScope));
  }
}
function io(e) {
  we(e, "itemStyle"), we(e, "lineStyle"), we(e, "areaStyle"), we(e, "label"), we(e, "labelLine"), we(e, "upperLabel"), we(e, "edgeLabel");
}
function ee(e, t) {
  var i = Fo(e) && e[t], n = Fo(i) && i.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && Dn("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var r = 0, a = Qm.length; r < a; r++) {
      var s = Qm[r];
      n.hasOwnProperty(s) && (i[s] = n[s]);
    }
  }
}
function si(e) {
  e && (io(e), ee(e, "label"), e.emphasis && ee(e.emphasis, "label"));
}
function f5(e) {
  if (Fo(e)) {
    sd(e), io(e), ee(e, "label"), ee(e, "upperLabel"), ee(e, "edgeLabel"), e.emphasis && (ee(e.emphasis, "label"), ee(e.emphasis, "upperLabel"), ee(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (sd(t), si(t));
    var i = e.markLine;
    i && (sd(i), si(i));
    var n = e.markArea;
    n && si(n);
    var r = e.data;
    if (e.type === "graph") {
      r = r || e.nodes;
      var a = e.links || e.edges;
      if (a && !Re(a))
        for (var s = 0; s < a.length; s++)
          si(a[s]);
      A(e.categories, function(u) {
        io(u);
      });
    }
    if (r && !Re(r))
      for (var s = 0; s < r.length; s++)
        si(r[s]);
    if (t = e.markPoint, t && t.data)
      for (var o = t.data, s = 0; s < o.length; s++)
        si(o[s]);
    if (i = e.markLine, i && i.data)
      for (var l = i.data, s = 0; s < l.length; s++)
        Z(l[s]) ? (si(l[s][0]), si(l[s][1])) : si(l[s]);
    e.type === "gauge" ? (ee(e, "axisLabel"), ee(e, "title"), ee(e, "detail")) : e.type === "treemap" ? (we(e.breadcrumb, "itemStyle"), A(e.levels, function(u) {
      io(u);
    })) : e.type === "tree" && io(e.leaves);
  }
}
function sn(e) {
  return Z(e) ? e : e ? [e] : [];
}
function a_(e) {
  return (Z(e) ? e[0] : e) || {};
}
function v5(e, t) {
  ii(sn(e.series), function(n) {
    Fo(n) && f5(n);
  });
  var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), ii(i, function(n) {
    ii(sn(e[n]), function(r) {
      r && (ee(r, "axisLabel"), ee(r.axisPointer, "label"));
    });
  }), ii(sn(e.parallel), function(n) {
    var r = n && n.parallelAxisDefault;
    ee(r, "axisLabel"), ee(r && r.axisPointer, "label");
  }), ii(sn(e.calendar), function(n) {
    we(n, "itemStyle"), ee(n, "dayLabel"), ee(n, "monthLabel"), ee(n, "yearLabel");
  }), ii(sn(e.radar), function(n) {
    ee(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && Dn("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && Dn("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && ii(n.indicator, function(r) {
      r.text && ge("text", "name", "radar.indicator");
    });
  }), ii(sn(e.geo), function(n) {
    Fo(n) && (si(n), ii(sn(n.regions), function(r) {
      si(r);
    }));
  }), ii(sn(e.timeline), function(n) {
    si(n), we(n, "label"), we(n, "itemStyle"), we(n, "controlStyle", !0);
    var r = n.data;
    Z(r) && A(r, function(a) {
      Q(a) && (we(a, "label"), we(a, "itemStyle"));
    });
  }), ii(sn(e.toolbox), function(n) {
    we(n, "iconStyle"), ii(n.feature, function(r) {
      we(r, "iconStyle");
    });
  }), ee(a_(e.axisPointer), "label"), ee(a_(e.tooltip).axisPointer, "label");
}
function p5(e, t) {
  for (var i = t.split(","), n = e, r = 0; r < i.length && (n = n && n[i[r]], n != null); r++)
    ;
  return n;
}
function g5(e, t, i, n) {
  for (var r = t.split(","), a = e, s, o = 0; o < r.length - 1; o++)
    s = r[o], a[s] == null && (a[s] = {}), a = a[s];
  a[r[o]] == null && (a[r[o]] = i);
}
function s_(e) {
  e && A(m5, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var m5 = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], _5 = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], od = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Es(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0; i < od.length; i++) {
      var n = od[i][1], r = od[i][0];
      t[n] != null && (t[r] = t[n], process.env.NODE_ENV !== "production" && ge(n, r));
    }
}
function o_(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && ge("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function l_(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && ge("downplay", "blur", "sunburst"));
}
function y5(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && ge("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function Bx(e, t) {
  if (e)
    for (var i = 0; i < e.length; i++)
      t(e[i]), e[i] && Bx(e[i].children, t);
}
function $x(e, t) {
  v5(e, t), e.series = Ie(e.series), A(e.series, function(i) {
    if (Q(i)) {
      var n = i.type;
      if (n === "line")
        i.clipOverflow != null && (i.clip = i.clipOverflow, process.env.NODE_ENV !== "production" && ge("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        i.clockWise != null && (i.clockwise = i.clockWise, process.env.NODE_ENV !== "production" && ge("clockWise", "clockwise")), o_(i.label);
        var r = i.data;
        if (r && !Re(r))
          for (var a = 0; a < r.length; a++)
            o_(r[a]);
        i.hoverOffset != null && (i.emphasis = i.emphasis || {}, (i.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && ge("hoverOffset", "emphasis.scaleSize"), i.emphasis.scaleSize = i.hoverOffset));
      } else if (n === "gauge") {
        var s = p5(i, "pointer.color");
        s != null && g5(i, "itemStyle.color", s);
      } else if (n === "bar") {
        Es(i), Es(i.backgroundStyle), Es(i.emphasis);
        var r = i.data;
        if (r && !Re(r))
          for (var a = 0; a < r.length; a++)
            typeof r[a] == "object" && (Es(r[a]), Es(r[a] && r[a].emphasis));
      } else if (n === "sunburst") {
        var o = i.highlightPolicy;
        o && (i.emphasis = i.emphasis || {}, i.emphasis.focus || (i.emphasis.focus = o, process.env.NODE_ENV !== "production" && ge("highlightPolicy", "emphasis.focus", "sunburst"))), l_(i), Bx(i.data, l_);
      } else n === "graph" || n === "sankey" ? y5(i) : n === "map" && (i.mapType && !i.map && (process.env.NODE_ENV !== "production" && ge("mapType", "map", "map"), i.map = i.mapType), i.mapLocation && (process.env.NODE_ENV !== "production" && Dn("`mapLocation` is not used anymore."), Jt(i, i.mapLocation)));
      i.hoverAnimation != null && (i.emphasis = i.emphasis || {}, i.emphasis && i.emphasis.scale == null && (process.env.NODE_ENV !== "production" && ge("hoverAnimation", "emphasis.scale"), i.emphasis.scale = i.hoverAnimation)), s_(i);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), A(_5, function(i) {
    var n = e[i];
    n && (Z(n) || (n = [n]), A(n, function(r) {
      s_(r);
    }));
  });
}
function b5(e) {
  var t = ct();
  e.eachSeries(function(i) {
    var n = i.get("stack");
    if (n) {
      var r = t.get(n) || t.set(n, []), a = i.getData(), s = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: i
      };
      if (!s.stackedDimension || !(s.isStackedByIndex || s.stackedByDimension))
        return;
      r.push(s);
    }
  }), t.each(function(i) {
    if (i.length !== 0) {
      var n = i[0].seriesModel, r = n.get("stackOrder") || "seriesAsc";
      r === "seriesDesc" && i.reverse(), A(i, function(a, s) {
        a.data.setCalculationInfo("stackedOnSeries", s > 0 ? i[s - 1].seriesModel : null);
      }), x5(i);
    }
  });
}
function x5(e) {
  A(e, function(t, i) {
    var n = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], s = t.data, o = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    s.modify(a, function(u, c, h) {
      var d = s.get(t.stackedDimension, h);
      if (isNaN(d))
        return r;
      var f, v;
      o ? v = s.getRawIndex(h) : f = s.get(t.stackedByDimension, h);
      for (var p = NaN, g = i - 1; g >= 0; g--) {
        var m = e[g];
        if (o || (v = m.data.rawIndexOf(m.stackedByDimension, f)), v >= 0) {
          var _ = m.data.getByRawIndex(m.stackResultDimension, v);
          if (l === "all" || l === "positive" && _ > 0 || l === "negative" && _ < 0 || l === "samesign" && d >= 0 && _ > 0 || l === "samesign" && d <= 0 && _ < 0) {
            d = DL(d, _), p = _;
            break;
          }
        }
      }
      return n[0] = d, n[1] = p, n;
    });
  });
}
var Fc = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === tn ? {} : []), this.sourceFormat = t.sourceFormat || Ox, this.seriesLayoutBy = t.seriesLayoutBy || Qi, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var i = this.dimensionsDefine = t.dimensionsDefine;
      if (i)
        for (var n = 0; n < i.length; n++) {
          var r = i[n];
          r.type == null && Nx(this, n) === Xe.Must && (r.type = "ordinal");
        }
    }
    return e;
  })()
);
function rp(e) {
  return e instanceof Fc;
}
function kf(e, t, i) {
  i = i || zx(e);
  var n = t.seriesLayoutBy, r = S5(e, i, n, t.sourceHeader, t.dimensions), a = new Fc({
    data: e,
    sourceFormat: i,
    seriesLayoutBy: n,
    dimensionsDefine: r.dimensionsDefine,
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount,
    metaRawOption: pt(t)
  });
  return a;
}
function ap(e) {
  return new Fc({
    data: e,
    sourceFormat: Re(e) ? wn : Je
  });
}
function w5(e) {
  return new Fc({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: pt(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function zx(e) {
  var t = Ox;
  if (Re(e))
    t = wn;
  else if (Z(e)) {
    e.length === 0 && (t = Ae);
    for (var i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      if (r != null) {
        if (Z(r) || Re(r)) {
          t = Ae;
          break;
        } else if (Q(r)) {
          t = Li;
          break;
        }
      }
    }
  } else if (Q(e)) {
    for (var a in e)
      if (ji(e, a) && Ge(e[a])) {
        t = tn;
        break;
      }
  }
  return t;
}
function S5(e, t, i, n, r) {
  var a, s;
  if (!e)
    return {
      dimensionsDefine: u_(r),
      startIndex: s,
      dimensionsDetectedCount: a
    };
  if (t === Ae) {
    var o = e;
    n === "auto" || n == null ? c_(function(u) {
      u != null && u !== "-" && (tt(u) ? s == null && (s = 1) : s = 0);
    }, i, o, 10) : s = Zt(n) ? n : n ? 1 : 0, !r && s === 1 && (r = [], c_(function(u, c) {
      r[c] = u != null ? u + "" : "";
    }, i, o, 1 / 0)), a = r ? r.length : i === ca ? o.length : o[0] ? o[0].length : null;
  } else if (t === Li)
    r || (r = M5(e));
  else if (t === tn)
    r || (r = [], A(e, function(u, c) {
      r.push(c);
    }));
  else if (t === Je) {
    var l = jo(e[0]);
    a = Z(l) && l.length || 1;
  } else t === wn && process.env.NODE_ENV !== "production" && it(!!r, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: s,
    dimensionsDefine: u_(r),
    dimensionsDetectedCount: a
  };
}
function M5(e) {
  for (var t = 0, i; t < e.length && !(i = e[t++]); )
    ;
  if (i)
    return qt(i);
}
function u_(e) {
  if (e) {
    var t = ct();
    return yt(e, function(i, n) {
      i = Q(i) ? i : {
        name: i
      };
      var r = {
        name: i.name,
        displayName: i.displayName,
        type: i.type
      };
      if (r.name == null)
        return r;
      r.name += "", r.displayName == null && (r.displayName = r.name);
      var a = t.get(r.name);
      return a ? r.name += "-" + a.count++ : t.set(r.name, {
        count: 1
      }), r;
    });
  }
}
function c_(e, t, i, n) {
  if (t === ca)
    for (var r = 0; r < i.length && r < n; r++)
      e(i[r] ? i[r][0] : null, r);
  else
    for (var a = i[0] || [], r = 0; r < a.length && r < n; r++)
      e(a[r], r);
}
function Vx(e) {
  var t = e.sourceFormat;
  return t === Li || t === tn;
}
var Cr, Ar, Pr, Er, h_, d_, Hx = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = rp(t) ? t : ap(t);
      this._source = n;
      var r = this._data = n.data, a = n.sourceFormat, s = n.seriesLayoutBy;
      if (a === wn) {
        if (process.env.NODE_ENV !== "production" && i == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = i, this._data = r;
      }
      if (process.env.NODE_ENV !== "production") {
        var o = k5[Xu(a, s)];
        o && o(r, n.dimensionsDefine);
      }
      d_(this, r, n);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, i) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    })(), e.internalField = (function() {
      var t;
      d_ = function(s, o, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, d = l.dimensionsDefine, f = h_[Xu(u, c)];
        if (process.env.NODE_ENV !== "production" && it(f, "Invalide sourceFormat: " + u), Y(s, f), u === wn)
          s.getItem = i, s.count = r, s.fillStorage = n;
        else {
          var v = Yx(u, c);
          s.getItem = Dt(v, null, o, h, d);
          var p = Wx(u, c);
          s.count = Dt(p, null, o, h, d);
        }
      };
      var i = function(s, o) {
        s = s - this._offset, o = o || [];
        for (var l = this._data, u = this._dimSize, c = u * s, h = 0; h < u; h++)
          o[h] = l[c + h];
        return o;
      }, n = function(s, o, l, u) {
        for (var c = this._data, h = this._dimSize, d = 0; d < h; d++) {
          for (var f = u[d], v = f[0] == null ? 1 / 0 : f[0], p = f[1] == null ? -1 / 0 : f[1], g = o - s, m = l[d], _ = 0; _ < g; _++) {
            var y = c[_ * h + d];
            m[s + _] = y, y < v && (v = y), y > p && (p = y);
          }
          f[0] = v, f[1] = p;
        }
      }, r = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      h_ = (t = {}, t[Ae + "_" + Qi] = {
        pure: !0,
        appendData: a
      }, t[Ae + "_" + ca] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[Li] = {
        pure: !0,
        appendData: a
      }, t[tn] = {
        pure: !0,
        appendData: function(s) {
          var o = this._data;
          A(s, function(l, u) {
            for (var c = o[u] || (o[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, t[Je] = {
        appendData: a
      }, t[wn] = {
        persistent: !1,
        pure: !0,
        appendData: function(s) {
          process.env.NODE_ENV !== "production" && it(Re(s), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = s;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(s) {
        for (var o = 0; o < s.length; o++)
          this._data.push(s[o]);
      }
    })(), e;
  })()
), Bl = function(e) {
  Z(e) || Kt("series.data or dataset.source must be an array.");
}, k5 = (Cr = {}, Cr[Ae + "_" + Qi] = Bl, Cr[Ae + "_" + ca] = Bl, Cr[Li] = Bl, Cr[tn] = function(e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i].name;
    n == null && Kt("dimension name must not be null/undefined.");
  }
}, Cr[Je] = Bl, Cr), f_ = function(e, t, i, n) {
  return e[n];
}, D5 = (Ar = {}, Ar[Ae + "_" + Qi] = function(e, t, i, n) {
  return e[n + t];
}, Ar[Ae + "_" + ca] = function(e, t, i, n, r) {
  n += t;
  for (var a = r || [], s = e, o = 0; o < s.length; o++) {
    var l = s[o];
    a[o] = l ? l[n] : null;
  }
  return a;
}, Ar[Li] = f_, Ar[tn] = function(e, t, i, n, r) {
  for (var a = r || [], s = 0; s < i.length; s++) {
    var o = i[s].name, l = o != null ? e[o] : null;
    a[s] = l ? l[n] : null;
  }
  return a;
}, Ar[Je] = f_, Ar);
function Yx(e, t) {
  var i = D5[Xu(e, t)];
  return process.env.NODE_ENV !== "production" && it(i, 'Do not support get item on "' + e + '", "' + t + '".'), i;
}
var v_ = function(e, t, i) {
  return e.length;
}, T5 = (Pr = {}, Pr[Ae + "_" + Qi] = function(e, t, i) {
  return Math.max(0, e.length - t);
}, Pr[Ae + "_" + ca] = function(e, t, i) {
  var n = e[0];
  return n ? Math.max(0, n.length - t) : 0;
}, Pr[Li] = v_, Pr[tn] = function(e, t, i) {
  var n = i[0].name, r = n != null ? e[n] : null;
  return r ? r.length : 0;
}, Pr[Je] = v_, Pr);
function Wx(e, t) {
  var i = T5[Xu(e, t)];
  return process.env.NODE_ENV !== "production" && it(i, 'Do not support count on "' + e + '", "' + t + '".'), i;
}
var ld = function(e, t, i) {
  return e[t];
}, C5 = (Er = {}, Er[Ae] = ld, Er[Li] = function(e, t, i) {
  return e[i];
}, Er[tn] = ld, Er[Je] = function(e, t, i) {
  var n = jo(e);
  return n instanceof Array ? n[t] : n;
}, Er[wn] = ld, Er);
function Ux(e) {
  var t = C5[e];
  return process.env.NODE_ENV !== "production" && it(t, 'Do not support get value on "' + e + '".'), t;
}
function Xu(e, t) {
  return e === Ae ? e + "_" + t : e;
}
function ju(e, t, i) {
  if (e) {
    var n = e.getRawDataItem(t);
    if (n != null) {
      var r = e.getStore(), a = r.getSource().sourceFormat;
      if (i != null) {
        var s = e.getDimensionIndex(i), o = r.getDimensionProperty(s);
        return Ux(a)(n, s, o);
      } else {
        var l = n;
        return a === Je && (l = jo(n)), l;
      }
    }
  }
}
var A5 = /\{@(.+?)\}/g, P5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, i) {
      var n = this.getData(i), r = this.getRawValue(t, i), a = n.getRawIndex(t), s = n.getName(t), o = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, d = h === "series", f = n.userOutput && n.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: d ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: d ? this.id : null,
        seriesName: d ? this.name : null,
        name: s,
        dataIndex: a,
        data: o,
        dataType: i,
        value: r,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, i, n, r, a, s) {
      i = i || "normal";
      var o = this.getData(n), l = this.getDataParams(t, n);
      if (s && (l.value = s.interpolatedValue), r != null && Z(l.value) && (l.value = l.value[r]), !a) {
        var u = o.getItemModel(t);
        a = u.get(i === "normal" ? ["label", "formatter"] : [i, "label", "formatter"]);
      }
      if (mt(a))
        return l.status = i, l.dimensionIndex = r, a(l);
      if (tt(a)) {
        var c = Tx(a, l);
        return c.replace(A5, function(h, d) {
          var f = d.length, v = d;
          v.charAt(0) === "[" && v.charAt(f - 1) === "]" && (v = +v.slice(1, f - 1), process.env.NODE_ENV !== "production" && isNaN(v) && Kt("Invalide label formatter: @" + d + ", only support @[0], @[1], @[2], ..."));
          var p = ju(o, t, v);
          if (s && Z(s.interpolatedValue)) {
            var g = o.getDimensionIndex(v);
            g >= 0 && (p = s.interpolatedValue[g]);
          }
          return p != null ? p + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, i) {
      return ju(this.getData(i), t);
    }, e.prototype.formatTooltip = function(t, i, n) {
    }, e;
  })()
);
function p_(e) {
  var t, i;
  return Q(e) ? e.type ? i = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + Fu(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: i
  };
}
function _o(e) {
  return new E5(e);
}
var E5 = (
  /** @class */
  (function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var i = this._upstream, n = t && t.skip;
      if (this._dirty && i) {
        var r = this.context;
        r.data = r.outputData = i.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var s = c(this._modBy), o = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (s !== l || o !== u) && (a = "reset");
      function c(_) {
        return !(_ >= 1) && (_ = 1), _;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = !1, h = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var d = t && t.step;
      if (i ? (process.env.NODE_ENV !== "production" && it(i._outputDueEnd != null), this._dueEnd = i._outputDueEnd) : (process.env.NODE_ENV !== "production" && it(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var f = this._dueIndex, v = Math.min(d != null ? this._dueIndex + d : 1 / 0, this._dueEnd);
        if (!n && (h || f < v)) {
          var p = this._progress;
          if (Z(p))
            for (var g = 0; g < p.length; g++)
              this._doProgress(p[g], f, v, l, u);
          else
            this._doProgress(p, f, v, l, u);
        }
        this._dueIndex = v;
        var m = this._settedOutputEnd != null ? this._settedOutputEnd : v;
        process.env.NODE_ENV !== "production" && it(m >= this._outputDueEnd), this._outputDueEnd = m;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, i, n, r, a) {
      g_.reset(i, n, r, a), this._callingProgress = t, this._callingProgress({
        start: i,
        end: n,
        count: n - i,
        next: g_.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var i, n;
      !t && this._reset && (i = this._reset(this.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), Z(i) && !i.length && (i = null)), this._progress = i, this._modBy = this._modDataCount = null;
      var r = this._downstream;
      return r && r.dirty(), n;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && it(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  })()
), g_ = /* @__PURE__ */ (function() {
  var e, t, i, n, r, a = {
    reset: function(l, u, c, h) {
      t = l, e = u, i = c, n = h, r = Math.ceil(n / i), a.next = i > 1 && n > 0 ? o : s;
    }
  };
  return a;
  function s() {
    return t < e ? t++ : null;
  }
  function o() {
    var l = t % r * i + Math.ceil(t / r), u = t >= e ? null : l < n ? l : t;
    return t++, u;
  }
})();
function cu(e, t) {
  var i = t && t.type;
  return i === "ordinal" ? e : (i === "time" && !Zt(e) && e != null && e !== "-" && (e = +Tc(e)), e == null || e === "" ? NaN : Number(e));
}
ct({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +Tc(e);
  },
  trim: function(e) {
    return tt(e) ? Ui(e) : e;
  }
});
var L5 = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, i == null && (i = n ? "min" : "max"), this._incomparable = i === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, i) {
      var n = Zt(t) ? t : Nu(t), r = Zt(i) ? i : Nu(i), a = isNaN(n), s = isNaN(r);
      if (a && (n = this._incomparable), s && (r = this._incomparable), a && s) {
        var o = tt(t), l = tt(i);
        o && (n = l ? t : 0), l && (r = o ? i : 0);
      }
      return n < r ? this._resultLT : n > r ? -this._resultLT : 0;
    }, e;
  })()
), O5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, i) {
    }, e.prototype.retrieveValueFromItem = function(t, i) {
    }, e.prototype.convertValue = function(t, i) {
      return cu(t, i);
    }, e;
  })()
);
function I5(e, t) {
  var i = new O5(), n = e.data, r = i.sourceFormat = e.sourceFormat, a = e.startIndex, s = "";
  e.seriesLayoutBy !== Qi && (process.env.NODE_ENV !== "production" && (s = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), Ye(s));
  var o = [], l = {}, u = e.dimensionsDefine;
  if (u)
    A(u, function(p, g) {
      var m = p.name, _ = {
        index: g,
        name: m,
        displayName: p.displayName
      };
      if (o.push(_), m != null) {
        var y = "";
        ji(l, m) && (process.env.NODE_ENV !== "production" && (y = 'dimension name "' + m + '" duplicated.'), Ye(y)), l[m] = _;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      o.push({
        index: c
      });
  var h = Yx(r, Qi);
  t.__isBuiltIn && (i.getRawDataItem = function(p) {
    return h(n, a, o, p);
  }, i.getRawData = Dt(R5, null, e)), i.cloneRawData = Dt(N5, null, e);
  var d = Wx(r, Qi);
  i.count = Dt(d, null, n, a, o);
  var f = Ux(r);
  i.retrieveValue = function(p, g) {
    var m = h(n, a, o, p);
    return v(m, g);
  };
  var v = i.retrieveValueFromItem = function(p, g) {
    if (p != null) {
      var m = o[g];
      if (m)
        return f(p, g, m.name);
    }
  };
  return i.getDimensionInfo = Dt(F5, null, o, l), i.cloneAllDimensionInfo = Dt(B5, null, o), i;
}
function R5(e) {
  var t = e.sourceFormat;
  if (!sp(t)) {
    var i = "";
    process.env.NODE_ENV !== "production" && (i = "`getRawData` is not supported in source format " + t), Ye(i);
  }
  return e.data;
}
function N5(e) {
  var t = e.sourceFormat, i = e.data;
  if (!sp(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), Ye(n);
  }
  if (t === Ae) {
    for (var r = [], a = 0, s = i.length; a < s; a++)
      r.push(i[a].slice());
    return r;
  } else if (t === Li) {
    for (var r = [], a = 0, s = i.length; a < s; a++)
      r.push(Y({}, i[a]));
    return r;
  }
}
function F5(e, t, i) {
  if (i != null) {
    if (Zt(i) || !isNaN(i) && !ji(t, i))
      return e[i];
    if (ji(t, i))
      return t[i];
  }
}
function B5(e) {
  return pt(e);
}
var Gx = ct();
function $5(e) {
  e = pt(e);
  var t = e.type, i = "";
  t || (process.env.NODE_ENV !== "production" && (i = "Must have a `type` when `registerTransform`."), Ye(i));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (i = 'Name must include namespace like "ns:regression".'), Ye(i));
  var r = !1;
  n[0] === "echarts" && (t = n[1], r = !0), e.__isBuiltIn = r, Gx.set(t, e);
}
function z5(e, t, i) {
  var n = Ie(e), r = n.length, a = "";
  r || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), Ye(a));
  for (var s = 0, o = r; s < o; s++) {
    var l = n[s];
    t = V5(l, t, i, r === 1 ? null : s), s !== o - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function V5(e, t, i, n) {
  var r = "";
  t.length || (process.env.NODE_ENV !== "production" && (r = "Must have at least one upstream dataset."), Ye(r)), Q(e) || (process.env.NODE_ENV !== "production" && (r = "transform declaration must be an object rather than " + typeof e + "."), Ye(r));
  var a = e.type, s = Gx.get(a);
  s || (process.env.NODE_ENV !== "production" && (r = 'Can not find transform on type "' + a + '".'), Ye(r));
  var o = yt(t, function(c) {
    return I5(c, s);
  }), l = Ie(s.transform({
    upstream: o[0],
    upstreamList: o,
    config: pt(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = yt(l, function(c) {
      var h = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + i.datasetIndex + h + " ===", "- transform result data:", Fu(c.data), "- transform result dimensions:", Fu(c.dimensions)].join(`
`);
    }).join(`
`);
    PL(u);
  }
  return yt(l, function(c, h) {
    var d = "";
    Q(c) || (process.env.NODE_ENV !== "production" && (d = "A transform should not return some empty results."), Ye(d)), c.data || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be not be null or undefined"), Ye(d));
    var f = zx(c.data);
    sp(f) || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be array rows or object rows."), Ye(d));
    var v, p = t[0];
    if (p && h === 0 && !c.dimensions) {
      var g = p.startIndex;
      g && (c.data = p.data.slice(0, g).concat(c.data)), v = {
        seriesLayoutBy: Qi,
        sourceHeader: g,
        dimensions: p.metaRawOption.dimensions
      };
    } else
      v = {
        seriesLayoutBy: Qi,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return kf(c.data, v, null);
  });
}
function sp(e) {
  return e === Ae || e === Li;
}
var Bc = "undefined", H5 = typeof Uint32Array === Bc ? Array : Uint32Array, Y5 = typeof Uint16Array === Bc ? Array : Uint16Array, Xx = typeof Int32Array === Bc ? Array : Int32Array, m_ = typeof Float64Array === Bc ? Array : Float64Array, jx = {
  float: m_,
  int: Xx,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: m_
}, ud;
function Ta(e) {
  return e > 65535 ? H5 : Y5;
}
function Ca() {
  return [1 / 0, -1 / 0];
}
function W5(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function __(e, t, i, n, r) {
  var a = jx[i || "float"];
  if (r) {
    var s = e[t], o = s && s.length;
    if (o !== n) {
      for (var l = new a(n), u = 0; u < o; u++)
        l[u] = s[u];
      e[t] = l;
    }
  } else
    e[t] = new a(n);
}
var Df = (
  /** @class */
  (function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = ct();
    }
    return e.prototype.initData = function(t, i, n) {
      process.env.NODE_ENV !== "production" && it(mt(t.getItem) && mt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var r = t.getSource(), a = this.defaultDimValueGetter = ud[r.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var s = Vx(r);
      this._dimensions = yt(i, function(o) {
        return process.env.NODE_ENV !== "production" && s && it(o.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: o.type,
          property: o.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, i) {
      var n = this._calcDimNameToIdx, r = this._dimensions, a = n.get(t);
      if (a != null) {
        if (r[a].type === i)
          return a;
      } else
        a = r.length;
      return r[a] = {
        type: i
      }, n.set(t, a), this._chunks[a] = new jx[i || "float"](this._rawCount), this._rawExtent[a] = Ca(), a;
    }, e.prototype.collectOrdinalMeta = function(t, i) {
      var n = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, s = r.ordinalOffset || 0, o = n.length;
      s === 0 && (a[t] = Ca());
      for (var l = a[t], u = s; u < o; u++) {
        var c = n[u] = i.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      r.ordinalMeta = i, r.ordinalOffset = o, r.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var i = this._dimensions[t], n = i.ordinalMeta;
      return n;
    }, e.prototype.getDimensionProperty = function(t) {
      var i = this._dimensions[t];
      return i && i.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && it(!this._indices, "appendData can only be called on raw data.");
      var i = this._provider, n = this.count();
      i.appendData(t);
      var r = i.count();
      return i.persistent || (r += n), n < r && this._initDataFromProvider(n, r, !0), [n, r];
    }, e.prototype.appendValues = function(t, i) {
      for (var n = this._chunks, r = this._dimensions, a = r.length, s = this._rawExtent, o = this.count(), l = o + Math.max(t.length, i || 0), u = 0; u < a; u++) {
        var c = r[u];
        __(n, u, c.type, l, !0);
      }
      for (var h = [], d = o; d < l; d++)
        for (var f = d - o, v = 0; v < a; v++) {
          var c = r[v], p = ud.arrayRows.call(this, t[f] || h, c.property, f, v);
          n[v][d] = p;
          var g = s[v];
          p < g[0] && (g[0] = p), p > g[1] && (g[1] = p);
        }
      return this._rawCount = this._count = l, {
        start: o,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, i, n) {
      for (var r = this._provider, a = this._chunks, s = this._dimensions, o = s.length, l = this._rawExtent, u = yt(s, function(_) {
        return _.property;
      }), c = 0; c < o; c++) {
        var h = s[c];
        l[c] || (l[c] = Ca()), __(a, c, h.type, i, n);
      }
      if (r.fillStorage)
        r.fillStorage(t, i, a, l);
      else
        for (var d = [], f = t; f < i; f++) {
          d = r.getItem(f, d);
          for (var v = 0; v < o; v++) {
            var p = a[v], g = this._dimValueGetter(d, u[v], f, v);
            p[f] = g;
            var m = l[v];
            g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
          }
        }
      !r.persistent && r.clean && r.clean(), this._rawCount = this._count = i, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, i) {
      if (!(i >= 0 && i < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(i)] : NaN;
    }, e.prototype.getValues = function(t, i) {
      var n = [], r = [];
      if (i == null) {
        i = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          r.push(a);
      } else
        r = t;
      for (var a = 0, s = r.length; a < s; a++)
        n.push(this.get(r[a], i));
      return n;
    }, e.prototype.getByRawIndex = function(t, i) {
      if (!(i >= 0 && i < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[i] : NaN;
    }, e.prototype.getSum = function(t) {
      var i = this._chunks[t], n = 0;
      if (i)
        for (var r = 0, a = this.count(); r < a; r++) {
          var s = this.get(t, r);
          isNaN(s) || (n += s);
        }
      return n;
    }, e.prototype.getMedian = function(t) {
      var i = [];
      this.each([t], function(a) {
        isNaN(a) || i.push(a);
      });
      var n = i.sort(function(a, s) {
        return a - s;
      }), r = this.count();
      return r === 0 ? 0 : r % 2 === 1 ? n[(r - 1) / 2] : (n[r / 2] + n[r / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var i = this._indices, n = i[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var r = 0, a = this._count - 1; r <= a; ) {
        var s = (r + a) / 2 | 0;
        if (i[s] < t)
          r = s + 1;
        else if (i[s] > t)
          a = s - 1;
        else
          return s;
      }
      return -1;
    }, e.prototype.getIndices = function() {
      var t, i = this._indices;
      if (i) {
        var n = i.constructor, r = this._count;
        if (n === Array) {
          t = new n(r);
          for (var a = 0; a < r; a++)
            t[a] = i[a];
        } else
          t = new n(i.buffer, 0, r);
      } else {
        var n = Ta(this._rawCount);
        t = new n(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, e.prototype.filter = function(t, i) {
      if (!this._count)
        return this;
      for (var n = this.clone(), r = n.count(), a = Ta(n._rawCount), s = new a(r), o = [], l = t.length, u = 0, c = t[0], h = n._chunks, d = 0; d < r; d++) {
        var f = void 0, v = n.getRawIndex(d);
        if (l === 0)
          f = i(d);
        else if (l === 1) {
          var p = h[c][v];
          f = i(p, d);
        } else {
          for (var g = 0; g < l; g++)
            o[g] = h[t[g]][v];
          o[g] = d, f = i.apply(null, o);
        }
        f && (s[u++] = v);
      }
      return u < r && (n._indices = s), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.selectRange = function(t) {
      var i = this.clone(), n = i._count;
      if (!n)
        return this;
      var r = qt(t), a = r.length;
      if (!a)
        return this;
      var s = i.count(), o = Ta(i._rawCount), l = new o(s), u = 0, c = r[0], h = t[c][0], d = t[c][1], f = i._chunks, v = !1;
      if (!i._indices) {
        var p = 0;
        if (a === 1) {
          for (var g = f[r[0]], m = 0; m < n; m++) {
            var _ = g[m];
            (_ >= h && _ <= d || isNaN(_)) && (l[u++] = p), p++;
          }
          v = !0;
        } else if (a === 2) {
          for (var g = f[r[0]], y = f[r[1]], b = t[r[1]][0], w = t[r[1]][1], m = 0; m < n; m++) {
            var _ = g[m], S = y[m];
            (_ >= h && _ <= d || isNaN(_)) && (S >= b && S <= w || isNaN(S)) && (l[u++] = p), p++;
          }
          v = !0;
        }
      }
      if (!v)
        if (a === 1)
          for (var m = 0; m < s; m++) {
            var M = i.getRawIndex(m), _ = f[r[0]][M];
            (_ >= h && _ <= d || isNaN(_)) && (l[u++] = M);
          }
        else
          for (var m = 0; m < s; m++) {
            for (var k = !0, M = i.getRawIndex(m), T = 0; T < a; T++) {
              var C = r[T], _ = f[C][M];
              (_ < t[C][0] || _ > t[C][1]) && (k = !1);
            }
            k && (l[u++] = i.getRawIndex(m));
          }
      return u < s && (i._indices = l), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, e.prototype.map = function(t, i) {
      var n = this.clone(t);
      return this._updateDims(n, t, i), n;
    }, e.prototype.modify = function(t, i) {
      this._updateDims(this, t, i);
    }, e.prototype._updateDims = function(t, i, n) {
      for (var r = t._chunks, a = [], s = i.length, o = t.count(), l = [], u = t._rawExtent, c = 0; c < i.length; c++)
        u[i[c]] = Ca();
      for (var h = 0; h < o; h++) {
        for (var d = t.getRawIndex(h), f = 0; f < s; f++)
          l[f] = r[i[f]][d];
        l[s] = h;
        var v = n && n.apply(null, l);
        if (v != null) {
          typeof v != "object" && (a[0] = v, v = a);
          for (var c = 0; c < v.length; c++) {
            var p = i[c], g = v[c], m = u[p], _ = r[p];
            _ && (_[d] = g), g < m[0] && (m[0] = g), g > m[1] && (m[1] = g);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = this.clone([t], !0), r = n._chunks, a = r[t], s = this.count(), o = 0, l = Math.floor(1 / i), u = this.getRawIndex(0), c, h, d, f = new (Ta(this._rawCount))(Math.min((Math.ceil(s / l) + 2) * 2, s));
      f[o++] = u;
      for (var v = 1; v < s - 1; v += l) {
        for (var p = Math.min(v + l, s - 1), g = Math.min(v + l * 2, s), m = (g + p) / 2, _ = 0, y = p; y < g; y++) {
          var b = this.getRawIndex(y), w = a[b];
          isNaN(w) || (_ += w);
        }
        _ /= g - p;
        var S = v, M = Math.min(v + l, s), k = v - 1, T = a[u];
        c = -1, d = S;
        for (var C = -1, D = 0, y = S; y < M; y++) {
          var b = this.getRawIndex(y), w = a[b];
          if (isNaN(w)) {
            D++, C < 0 && (C = b);
            continue;
          }
          h = Math.abs((k - m) * (w - T) - (k - y) * (_ - T)), h > c && (c = h, d = b);
        }
        D > 0 && D < M - S && (f[o++] = Math.min(C, d), d = Math.max(C, d)), f[o++] = d, u = d;
      }
      return f[o++] = this.getRawIndex(s - 1), n._count = o, n._indices = f, n.getRawIndex = this._getRawIdx, n;
    }, e.prototype.minmaxDownSample = function(t, i) {
      for (var n = this.clone([t], !0), r = n._chunks, a = Math.floor(1 / i), s = r[t], o = this.count(), l = new (Ta(this._rawCount))(Math.ceil(o / a) * 2), u = 0, c = 0; c < o; c += a) {
        var h = c, d = s[this.getRawIndex(h)], f = c, v = s[this.getRawIndex(f)], p = a;
        c + a > o && (p = o - c);
        for (var g = 0; g < p; g++) {
          var m = this.getRawIndex(c + g), _ = s[m];
          _ < d && (d = _, h = c + g), _ > v && (v = _, f = c + g);
        }
        var y = this.getRawIndex(h), b = this.getRawIndex(f);
        h < f ? (l[u++] = y, l[u++] = b) : (l[u++] = b, l[u++] = y);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, e.prototype.downSample = function(t, i, n, r) {
      for (var a = this.clone([t], !0), s = a._chunks, o = [], l = Math.floor(1 / i), u = s[t], c = this.count(), h = a._rawExtent[t] = Ca(), d = new (Ta(this._rawCount))(Math.ceil(c / l)), f = 0, v = 0; v < c; v += l) {
        l > c - v && (l = c - v, o.length = l);
        for (var p = 0; p < l; p++) {
          var g = this.getRawIndex(v + p);
          o[p] = u[g];
        }
        var m = n(o), _ = this.getRawIndex(Math.min(v + r(o, m) || 0, c - 1));
        u[_] = m, m < h[0] && (h[0] = m), m > h[1] && (h[1] = m), d[f++] = _;
      }
      return a._count = f, a._indices = d, a._updateGetRawIdx(), a;
    }, e.prototype.each = function(t, i) {
      if (this._count)
        for (var n = t.length, r = this._chunks, a = 0, s = this.count(); a < s; a++) {
          var o = this.getRawIndex(a);
          switch (n) {
            case 0:
              i(a);
              break;
            case 1:
              i(r[t[0]][o], a);
              break;
            case 2:
              i(r[t[0]][o], r[t[1]][o], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = r[t[l]][o];
              u[l] = a, i.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var i = this._chunks[t], n = Ca();
      if (!i)
        return n;
      var r = this.count(), a = !this._indices, s;
      if (a)
        return this._rawExtent[t].slice();
      if (s = this._extent[t], s)
        return s.slice();
      s = n;
      for (var o = s[0], l = s[1], u = 0; u < r; u++) {
        var c = this.getRawIndex(u), h = i[c];
        h < o && (o = h), h > l && (l = h);
      }
      return s = [o, l], this._extent[t] = s, s;
    }, e.prototype.getRawDataItem = function(t) {
      var i = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(i);
      for (var n = [], r = this._chunks, a = 0; a < r.length; a++)
        n.push(r[a][i]);
      return n;
    }, e.prototype.clone = function(t, i) {
      var n = new e(), r = this._chunks, a = t && fs(t, function(o, l) {
        return o[l] = !0, o;
      }, {});
      if (a)
        for (var s = 0; s < r.length; s++)
          n._chunks[s] = a[s] ? W5(r[s]) : r[s];
      else
        n._chunks = r;
      return this._copyCommonProps(n), i || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = pt(this._extent), t._rawExtent = pt(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, i = void 0;
        if (t === Array) {
          var n = this._indices.length;
          i = new t(n);
          for (var r = 0; r < n; r++)
            i[r] = this._indices[r];
        } else
          i = new t(this._indices);
        return i;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = (function() {
      function t(i, n, r, a) {
        return cu(i[a], this._dimensions[a]);
      }
      ud = {
        arrayRows: t,
        objectRows: function(i, n, r, a) {
          return cu(i[n], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(i, n, r, a) {
          var s = i && (i.value == null ? i : i.value);
          return cu(s instanceof Array ? s[a] : s, this._dimensions[a]);
        },
        typedArray: function(i, n, r, a) {
          return i[a];
        }
      };
    })(), e;
  })()
), U5 = (
  /** @class */
  (function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, i) {
      this._sourceList = t, this._upstreamSignList = i, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, i = this._getUpstreamSourceManagers(), n = !!i.length, r, a;
      if (Ls(t)) {
        var s = t, o = void 0, l = void 0, u = void 0;
        if (n) {
          var c = i[0];
          c.prepareSource(), u = c.getSource(), o = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          o = s.get("data", !0), l = Re(o) ? wn : Je, a = [];
        var h = this._getSourceMetaRawOption() || {}, d = u && u.metaRawOption || {}, f = nt(h.seriesLayoutBy, d.seriesLayoutBy) || null, v = nt(h.sourceHeader, d.sourceHeader), p = nt(h.dimensions, d.dimensions), g = f !== d.seriesLayoutBy || !!v != !!d.sourceHeader || p;
        r = g ? [kf(o, {
          seriesLayoutBy: f,
          sourceHeader: v,
          dimensions: p
        }, l)] : [];
      } else {
        var m = t;
        if (n) {
          var _ = this._applyTransform(i);
          r = _.sourceList, a = _.upstreamSignList;
        } else {
          var y = m.get("source", !0);
          r = [kf(y, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && it(r && a), this._setLocalSource(r, a);
    }, e.prototype._applyTransform = function(t) {
      var i = this._sourceHost, n = i.get("transform", !0), r = i.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && it(r != null || n != null), r != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), y_(a));
      }
      var s, o = [], l = [];
      return A(t, function(u) {
        u.prepareSource();
        var c = u.getSource(r || 0), h = "";
        r != null && !c && (process.env.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + r), y_(h)), o.push(c), l.push(u._getVersionSign());
      }), n ? s = z5(n, o, {
        datasetIndex: i.componentIndex
      }) : r != null && (s = [w5(o[0])]), {
        sourceList: s,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), i = 0; i < t.length; i++) {
        var n = t[i];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[i] !== n._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var i = this._sourceList[t];
      if (!i) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return i;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && it(Ls(this._sourceHost), "Can only call getDataStore on series source manager.");
      var i = t.makeStoreSchema();
      return this._innerGetDataStore(i.dimensions, t.source, i.hash);
    }, e.prototype._innerGetDataStore = function(t, i, n) {
      var r = 0, a = this._storeList, s = a[r];
      s || (s = a[r] = {});
      var o = s[n];
      if (!o) {
        var l = this._getUpstreamSourceManagers()[0];
        Ls(this._sourceHost) && l ? o = l._innerGetDataStore(t, i, n) : (o = new Df(), o.initData(new Hx(i, t.length), t)), s[n] = o;
      }
      return o;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (Ls(t)) {
        var i = Rx(t);
        return i ? [i.getSourceManager()] : [];
      } else
        return yt(jR(t), function(n) {
          return n.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, i, n, r;
      if (Ls(t))
        i = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), r = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        i = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), r = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: i,
        sourceHeader: n,
        dimensions: r
      };
    }, e;
  })()
);
function Ls(e) {
  return e.mainType === "series";
}
function y_(e) {
  throw new Error(e);
}
var G5 = "line-height:1";
function qx(e) {
  var t = e.lineHeight;
  return t == null ? G5 : "line-height:" + ze(t + "") + "px";
}
function Zx(e, t) {
  var i = e.color || St.color.tertiary, n = e.fontSize || 12, r = e.fontWeight || "400", a = e.color || St.color.secondary, s = e.fontSize || 14, o = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + ze(n + "") + "px;color:" + ze(i) + ";font-weight:" + ze(r + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + ze(s + "") + "px;color:" + ze(a) + ";font-weight:" + ze(o + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: i,
      fontWeight: r
    },
    valueStyle: {
      fontSize: s,
      fill: a,
      fontWeight: o
    }
  };
}
var X5 = [0, 10, 20, 30], j5 = ["", `
`, `

`, `


`];
function oa(e, t) {
  return t.type = e, t;
}
function Tf(e) {
  return e.type === "section";
}
function Kx(e) {
  return Tf(e) ? q5 : Z5;
}
function Qx(e) {
  if (Tf(e)) {
    var t = 0, i = e.blocks.length, n = i > 1 || i > 0 && !e.noHeader;
    return A(e.blocks, function(r) {
      var a = Qx(r);
      a >= t && (t = a + +(n && // 0 always can not be readable gap level.
      (!a || Tf(r) && !r.noHeader)));
    }), t;
  }
  return 0;
}
function q5(e, t, i, n) {
  var r = t.noHeader, a = K5(Qx(t)), s = [], o = t.blocks || [];
  it(!o || Z(o)), o = o || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    o = o.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (ji(u, l)) {
      var c = new L5(u[l], null);
      o.sort(function(p, g) {
        return c.evaluate(p.sortParam, g.sortParam);
      });
    } else l === "seriesDesc" && o.reverse();
  }
  A(o, function(p, g) {
    var m = t.valueFormatter, _ = Kx(p)(
      // Inherit valueFormatter
      m ? Y(Y({}, e), {
        valueFormatter: m
      }) : e,
      p,
      g > 0 ? a.html : 0,
      n
    );
    _ != null && s.push(_);
  });
  var h = e.renderMode === "richText" ? s.join(a.richText) : Cf(n, s.join(""), r ? i : a.html);
  if (r)
    return h;
  var d = Sf(t.header, "ordinal", e.useUTC), f = Zx(n, e.renderMode).nameStyle, v = qx(n);
  return e.renderMode === "richText" ? Jx(e, d, f) + a.richText + h : Cf(n, '<div style="' + f + ";" + v + ';">' + ze(d) + "</div>" + h, i);
}
function Z5(e, t, i, n) {
  var r = e.renderMode, a = t.noName, s = t.noValue, o = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(b) {
    return b = Z(b) ? b : [b], yt(b, function(w, S) {
      return Sf(w, Z(f) ? f[S] : f, u);
    });
  };
  if (!(a && s)) {
    var h = o ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || St.color.secondary, r), d = a ? "" : Sf(l, "ordinal", u), f = t.valueType, v = s ? [] : c(t.value, t.dataIndex), p = !o || !a, g = !o && a, m = Zx(n, r), _ = m.nameStyle, y = m.valueStyle;
    return r === "richText" ? (o ? "" : h) + (a ? "" : Jx(e, d, _)) + (s ? "" : tN(e, v, p, g, y)) : Cf(n, (o ? "" : h) + (a ? "" : Q5(d, !o, _)) + (s ? "" : J5(v, p, g, y)), i);
  }
}
function b_(e, t, i, n, r, a) {
  if (e) {
    var s = Kx(e), o = {
      useUTC: r,
      renderMode: i,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return s(o, e, 0, a);
  }
}
function K5(e) {
  return {
    html: X5[e],
    richText: j5[e]
  };
}
function Cf(e, t, i) {
  var n = '<div style="clear:both"></div>', r = "margin: " + i + "px 0 0", a = qx(e);
  return '<div style="' + r + ";" + a + ';">' + t + n + "</div>";
}
function Q5(e, t, i) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + i + ";" + n + '">' + ze(e) + "</span>";
}
function J5(e, t, i, n) {
  var r = i ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
  return e = Z(e) ? e : [e], '<span style="' + a + ";" + n + '">' + yt(e, function(s) {
    return ze(s);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function Jx(e, t, i) {
  return e.markupStyleCreator.wrapRichTextStyle(t, i);
}
function tN(e, t, i, n, r) {
  var a = [r], s = n ? 10 : 20;
  return i && a.push({
    padding: [0, 0, 0, s],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(Z(t) ? t.join("  ") : t, a);
}
function eN(e, t) {
  var i = e.getData().getItemVisual(t, "style"), n = i[e.visualDrawType];
  return No(n);
}
function tw(e, t) {
  var i = e.get("padding");
  return i ?? (t === "richText" ? [8, 10] : 10);
}
var cd = (
  /** @class */
  (function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = C1();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, i, n) {
      var r = n === "richText" ? this._generateStyleName() : null, a = NR({
        color: i,
        type: t,
        renderMode: n,
        markerId: r
      });
      return tt(a) ? a : (process.env.NODE_ENV !== "production" && it(r), this.richTextStyles[r] = a.style, a.content);
    }, e.prototype.wrapRichTextStyle = function(t, i) {
      var n = {};
      Z(i) ? A(i, function(a) {
        return Y(n, a);
      }) : Y(n, i);
      var r = this._generateStyleName();
      return this.richTextStyles[r] = n, "{" + r + "|" + t + "}";
    }, e;
  })()
);
function iN(e) {
  var t = e.series, i = e.dataIndex, n = e.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), s = a.length, o = t.getRawValue(i), l = Z(o), u = eN(t, i), c, h, d, f;
  if (s > 1 || l && !s) {
    var v = nN(o, t, i, a, u);
    c = v.inlineValues, h = v.inlineValueTypes, d = v.blocks, f = v.inlineValues[0];
  } else if (s) {
    var p = r.getDimensionInfo(a[0]);
    f = c = ju(r, i, a[0]), h = p.type;
  } else
    f = c = l ? o[0] : o;
  var g = L1(t), m = g && t.name || "", _ = r.getName(i), y = n ? m : _;
  return oa("section", {
    header: m,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !g,
    sortParam: f,
    blocks: [oa("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: y,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !Ui(y),
      value: c,
      valueType: h,
      dataIndex: i
    })].concat(d || [])
  });
}
function nN(e, t, i, n, r) {
  var a = t.getData(), s = fs(e, function(h, d, f) {
    var v = a.getDimensionInfo(f);
    return h = h || v && v.tooltip !== !1 && v.displayName != null;
  }, !1), o = [], l = [], u = [];
  n.length ? A(n, function(h) {
    c(ju(a, i, h), h);
  }) : A(e, c);
  function c(h, d) {
    var f = a.getDimensionInfo(d);
    !f || f.otherDims.tooltip === !1 || (s ? u.push(oa("nameValue", {
      markerType: "subItem",
      markerColor: r,
      name: f.displayName,
      value: h,
      valueType: f.type
    })) : (o.push(h), l.push(f.type)));
  }
  return {
    inlineValues: o,
    inlineValueTypes: l,
    blocks: u
  };
}
var Nn = Gt();
function $l(e, t) {
  return e.getName(t) || e.getId(t);
}
var rN = "__universalTransitionEnabled", rr = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i._selectedDataIndicesMap = {}, i;
    }
    return t.prototype.init = function(i, n, r) {
      this.seriesIndex = this.componentIndex, this.dataTask = _o({
        count: sN,
        reset: oN
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(i, r);
      var a = Nn(this).sourceManager = new U5(this);
      a.prepareSource();
      var s = this.getInitialData(i, r);
      w_(s, this), this.dataTask.context.data = s, process.env.NODE_ENV !== "production" && it(s, "getInitialData returned invalid data."), Nn(this).dataBeforeProcessed = s, x_(this), this._initSelectedMapFromData(s);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = Wu(this), a = r ? Px(i) : {}, s = this.subType;
      Et.hasClass(s) && (s += "Series"), se(i, n.getTheme().get(this.subType)), se(i, this.getDefaultOption()), Km(i, "label", ["show"]), this.fillDataTextStyle(i.data), r && Uu(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      i = se(this.option, i, !0), this.fillDataTextStyle(i.data);
      var r = Wu(this);
      r && Uu(this.option, i, r);
      var a = Nn(this).sourceManager;
      a.dirty(), a.prepareSource();
      var s = this.getInitialData(i, n);
      w_(s, this), this.dataTask.dirty(), this.dataTask.context.data = s, Nn(this).dataBeforeProcessed = s, x_(this), this._initSelectedMapFromData(s);
    }, t.prototype.fillDataTextStyle = function(i) {
      if (i && !Re(i))
        for (var n = ["show"], r = 0; r < i.length; r++)
          i[r] && i[r].label && Km(i[r], "label", n);
    }, t.prototype.getInitialData = function(i, n) {
    }, t.prototype.appendData = function(i) {
      var n = this.getRawData();
      n.appendData(i.data);
    }, t.prototype.getData = function(i) {
      var n = Af(this);
      if (n) {
        var r = n.context.data;
        return i == null || !r.getLinkedData ? r : r.getLinkedData(i);
      } else
        return Nn(this).data;
    }, t.prototype.getAllData = function() {
      var i = this.getData();
      return i && i.getLinkedDataAll ? i.getLinkedDataAll() : [{
        data: i
      }];
    }, t.prototype.setData = function(i) {
      var n = Af(this);
      if (n) {
        var r = n.context;
        r.outputData = i, n !== this.dataTask && (r.data = i);
      }
      Nn(this).data = i;
    }, t.prototype.getEncode = function() {
      var i = this.get("encode", !0);
      if (i)
        return ct(i);
    }, t.prototype.getSourceManager = function() {
      return Nn(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return Nn(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var i = this.get("colorBy");
      return i || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var i = this.coordinateSystem;
      return i && i.getBaseAxis && i.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(i, n, r, a) {
      var s = this.getData(), o = this.coordinateSystem, l = o && o.getAxis(i);
      if (!o || !l)
        return [];
      var u = l.dataToCoord(r);
      a == null && (a = 1 / 0);
      var c = [], h = 1 / 0, d = -1, f = 0;
      return s.each(n, function(v, p) {
        var g = l.dataToCoord(v), m = u - g, _ = Math.abs(m);
        _ <= a && ((_ < h || _ === h && m >= 0 && d < 0) && (h = _, d = m, f = 0), m === d && (c[f++] = p));
      }), c.length = f, c;
    }, t.prototype.formatTooltip = function(i, n, r) {
      return iN({
        series: this,
        dataIndex: i,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var i = this.ecModel;
      if (st.node && !(i && i.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(i, n, r) {
      var a = this.ecModel, s = ip.prototype.getColorFromPalette.call(this, i, n, r);
      return s || (s = a.getColorFromPalette(i, n, r)), s;
    }, t.prototype.coordDimToDataDim = function(i) {
      return this.getRawData().mapDimensionsAll(i);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(i, n) {
      this._innerSelect(this.getData(n), i);
    }, t.prototype.unselect = function(i, n) {
      var r = this.option.selectedMap;
      if (r) {
        var a = this.option.selectedMode, s = this.getData(n);
        if (a === "series" || r === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var o = 0; o < i.length; o++) {
          var l = i[o], u = $l(s, l);
          r[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(i, n) {
      for (var r = [], a = 0; a < i.length; a++)
        r[0] = i[a], this.isSelected(i[a], n) ? this.unselect(r, n) : this.select(r, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var i = this._selectedDataIndicesMap, n = qt(i), r = [], a = 0; a < n.length; a++) {
        var s = i[n[a]];
        s >= 0 && r.push(s);
      }
      return r;
    }, t.prototype.isSelected = function(i, n) {
      var r = this.option.selectedMap;
      if (!r)
        return !1;
      var a = this.getData(n);
      return (r === "all" || r[$l(a, i)]) && !a.getItemModel(i).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[rN])
        return !0;
      var i = this.option.universalTransition;
      return i ? i === !0 ? !0 : i && i.enabled : !1;
    }, t.prototype._innerSelect = function(i, n) {
      var r, a, s = this.option, o = s.selectedMode, l = n.length;
      if (!(!o || !l)) {
        if (o === "series")
          s.selectedMap = "all";
        else if (o === "multiple") {
          Q(s.selectedMap) || (s.selectedMap = {});
          for (var u = s.selectedMap, c = 0; c < l; c++) {
            var h = n[c], d = $l(i, h);
            u[d] = !0, this._selectedDataIndicesMap[d] = i.getRawIndex(h);
          }
        } else if (o === "single" || o === !0) {
          var f = n[l - 1], d = $l(i, f);
          s.selectedMap = (r = {}, r[d] = !0, r), this._selectedDataIndicesMap = (a = {}, a[d] = i.getRawIndex(f), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(i) {
      if (!this.option.selectedMap) {
        var n = [];
        i.hasItemOption && i.each(function(r) {
          var a = i.getRawDataItem(r);
          a && a.selected && n.push(r);
        }), n.length > 0 && this._innerSelect(i, n);
      }
    }, t.registerClass = function(i) {
      return Et.registerClass(i);
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "series.__base__", i.seriesIndex = 0, i.ignoreStyleOnData = !1, i.hasSymbolVisual = !1, i.defaultSymbol = "circle", i.visualStyleAccessPath = "itemStyle", i.visualDrawType = "fill";
    })(), t;
  })(Et)
);
Ai(rr, P5);
Ai(rr, ip);
R1(rr, Et);
function x_(e) {
  var t = e.name;
  L1(e) || (e.name = aN(e) || t);
}
function aN(e) {
  var t = e.getRawData(), i = t.mapDimensionsAll("seriesName"), n = [];
  return A(i, function(r) {
    var a = t.getDimensionInfo(r);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function sN(e) {
  return e.model.getRawData().count();
}
function oN(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), lN;
}
function lN(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function w_(e, t) {
  A(QP(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(i) {
    e.wrapMethod(i, Oe(uN, t));
  });
}
function uN(e, t) {
  var i = Af(e);
  return i && i.setOutputEnd((t || this).count()), t;
}
function Af(e) {
  var t = (e.ecModel || {}).scheduler, i = t && t.getPipeline(e.uid);
  if (i) {
    var n = i.currentTask;
    if (n) {
      var r = n.agentStubMap;
      r && (n = r.get(e.uid));
    }
    return n;
  }
}
var Tn = (
  /** @class */
  (function() {
    function e() {
      this.group = new Di(), this.uid = Rc("viewComponent");
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
    }, e.prototype.updateLayout = function(t, i, n, r) {
    }, e.prototype.updateVisual = function(t, i, n, r) {
    }, e.prototype.toggleBlurSeries = function(t, i, n) {
    }, e.prototype.eachRendered = function(t) {
      var i = this.group;
      i && i.traverse(t);
    }, e;
  })()
);
Av(Tn);
Pv(Tn);
function cN() {
  var e = Gt();
  return function(t) {
    var i = e(t), n = t.pipelineContext, r = !!i.large, a = !!i.progressiveRender, s = i.large = !!(n && n.large), o = i.progressiveRender = !!(n && n.progressiveRender);
    return (r !== s || a !== o) && "reset";
  };
}
var ew = Gt(), hN = cN(), Kn = (
  /** @class */
  (function() {
    function e() {
      this.group = new Di(), this.uid = Rc("viewChart"), this.renderTask = _o({
        plan: dN,
        reset: fN
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Kt("Unknown dataType " + r.dataType);
        return;
      }
      M_(a, r, "emphasis");
    }, e.prototype.downplay = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Kt("Unknown dataType " + r.dataType);
        return;
      }
      M_(a, r, "normal");
    }, e.prototype.remove = function(t, i) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateLayout = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateVisual = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.eachRendered = function(t) {
      mx(this.group, t);
    }, e.markUpdateMethod = function(t, i) {
      ew(t).updateMethod = i;
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.type = "chart";
    })(), e;
  })()
);
function S_(e, t, i) {
  e && us(e) && (t === "emphasis" ? Vu : Hu)(e, i);
}
function M_(e, t, i) {
  var n = qo(e, t), r = t && t.highlightKey != null ? hI(t.highlightKey) : null;
  n != null ? A(Ie(n), function(a) {
    S_(e.getItemGraphicEl(a), i, r);
  }) : e.eachItemGraphicEl(function(a) {
    S_(a, i, r);
  });
}
Av(Kn, ["dispose"]);
Pv(Kn);
function dN(e) {
  return hN(e.model);
}
function fN(e) {
  var t = e.model, i = e.ecModel, n = e.api, r = e.payload, a = t.pipelineContext.progressiveRender, s = e.view, o = r && ew(r).updateMethod, l = a ? "incrementalPrepareRender" : o && s[o] ? o : "render";
  return l !== "render" && s[l](t, i, n, r), vN[l];
}
var vN = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, qu = "\0__throttleOriginMethod", k_ = "\0__throttleRate", D_ = "\0__throttleType";
function iw(e, t, i) {
  var n, r = 0, a = 0, s = null, o, l, u, c;
  t = t || 0;
  function h() {
    a = (/* @__PURE__ */ new Date()).getTime(), s = null, e.apply(l, u || []);
  }
  var d = function() {
    for (var f = [], v = 0; v < arguments.length; v++)
      f[v] = arguments[v];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
    var p = c || t, g = c || i;
    c = null, o = n - (g ? r : a) - p, clearTimeout(s), g ? s = setTimeout(h, p) : o >= 0 ? h() : s = setTimeout(h, -o), r = n;
  };
  return d.clear = function() {
    s && (clearTimeout(s), s = null);
  }, d.debounceNextCall = function(f) {
    c = f;
  }, d;
}
function nw(e, t, i, n) {
  var r = e[t];
  if (r) {
    var a = r[qu] || r, s = r[D_], o = r[k_];
    if (o !== i || s !== n) {
      if (i == null || !n)
        return e[t] = a;
      r = e[t] = iw(a, i, n === "debounce"), r[qu] = a, r[D_] = n, r[k_] = i;
    }
    return r;
  }
}
function Pf(e, t) {
  var i = e[t];
  i && i[qu] && (i.clear && i.clear(), e[t] = i[qu]);
}
var T_ = Gt(), C_ = {
  itemStyle: Oo(xx, !0),
  lineStyle: Oo(bx, !0)
}, pN = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function rw(e, t) {
  var i = e.visualStyleMapper || C_[t];
  return i || (console.warn("Unknown style type '" + t + "'."), C_.itemStyle);
}
function aw(e, t) {
  var i = e.visualDrawType || pN[t];
  return i || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var gN = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = e.getModel(n), a = rw(e, n), s = a(r), o = r.getShallow("decal");
    o && (i.setVisual("decal", o), o.dirty = !0);
    var l = aw(e, n), u = s[l], c = mt(u) ? u : null, h = s.fill === "auto" || s.stroke === "auto";
    if (!s[l] || c || h) {
      var d = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      s[l] || (s[l] = d, i.setVisual("colorFromPalette", !0)), s.fill = s.fill === "auto" || mt(s.fill) ? d : s.fill, s.stroke = s.stroke === "auto" || mt(s.stroke) ? d : s.stroke;
    }
    if (i.setVisual("style", s), i.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return i.setVisual("colorFromPalette", !1), {
        dataEach: function(f, v) {
          var p = e.getDataParams(v), g = Y({}, s);
          g[l] = c(p), f.setItemVisual(v, "style", g);
        }
      };
  }
}, Os = new jt(), mN = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = rw(e, n), a = i.getVisual("drawType");
      return {
        dataEach: i.hasItemOption ? function(s, o) {
          var l = s.getRawDataItem(o);
          if (l && l[n]) {
            Os.option = l[n];
            var u = r(Os), c = s.ensureUniqueItemVisual(o, "style");
            Y(c, u), Os.option.decal && (s.setItemVisual(o, "decal", Os.option.decal), Os.option.decal.dirty = !0), a in u && s.setItemVisual(o, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, _N = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = ct();
    e.eachSeries(function(i) {
      var n = i.getColorBy();
      if (!i.isColorBySeries()) {
        var r = i.type + "-" + n, a = t.get(r);
        a || (a = {}, t.set(r, a)), T_(i).scope = a;
      }
    }), e.eachSeries(function(i) {
      if (!(i.isColorBySeries() || e.isSeriesFiltered(i))) {
        var n = i.getRawData(), r = {}, a = i.getData(), s = T_(i).scope, o = i.visualStyleAccessPath || "itemStyle", l = aw(i, o);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          r[c] = u;
        }), n.each(function(u) {
          var c = r[u], h = a.getItemVisual(c, "colorFromPalette");
          if (h) {
            var d = a.ensureUniqueItemVisual(c, "style"), f = n.getName(u) || u + "", v = n.count();
            d[l] = i.getColorFromPalette(f, s, v);
          }
        });
      }
    });
  }
}, zl = Math.PI;
function yN(e, t) {
  t = t || {}, Jt(t, {
    text: "loading",
    textColor: St.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: St.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var i = new Di(), n = new De({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  i.add(n);
  var r = new mi({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new De({
    style: {
      fill: "none"
    },
    textContent: r,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  i.add(a);
  var s;
  return t.showSpinner && (s = new Oc({
    shape: {
      startAngle: -zl / 2,
      endAngle: -zl / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), s.animateShape(!0).when(1e3, {
    endAngle: zl * 3 / 2
  }).start("circularInOut"), s.animateShape(!0).when(1e3, {
    startAngle: zl * 3 / 2
  }).delay(300).start("circularInOut"), i.add(s)), i.resize = function() {
    var o = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && o ? 10 : 0) - o) / 2 - (t.showSpinner && o ? 0 : 5 + o / 2) + (t.showSpinner ? 0 : o / 2) + (o ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && s.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, i.resize(), i;
}
var sw = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this._stageTaskMap = ct(), this.ecInstance = t, this.api = i, n = this._dataProcessorHandlers = n.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = n.concat(r);
    }
    return e.prototype.restoreData = function(t, i) {
      t.restoreData(i), this._stageTaskMap.each(function(n) {
        var r = n.overallTask;
        r && r.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, i) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), r = n.context, a = !i && n.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > n.blockIndex, s = a ? n.step : null, o = r && r.modDataCount, l = o != null ? Math.ceil(o / s) : null;
        return {
          step: s,
          modBy: l,
          modDataCount: o
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, i) {
      var n = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), s = n.progressiveEnabled && i.incrementalPrepareRender && a >= n.threshold, o = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = n.context = {
        progressiveRender: s,
        modDataCount: l,
        large: o
      };
    }, e.prototype.restorePipelines = function(t) {
      var i = this, n = i._pipelineMap = ct();
      t.eachSeries(function(r) {
        var a = r.getProgressive(), s = r.uid;
        n.set(s, {
          id: s,
          head: null,
          tail: null,
          threshold: r.getProgressiveThreshold(),
          progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), i._pipe(r, r.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, i = this.api.getModel(), n = this.api;
      A(this._allHandlers, function(r) {
        var a = t.get(r.uid) || t.set(r.uid, {}), s = "";
        process.env.NODE_ENV !== "production" && (s = '"reset" and "overallReset" must not be both specified.'), it(!(r.reset && r.overallReset), s), r.reset && this._createSeriesStageTask(r, a, i, n), r.overallReset && this._createOverallStageTask(r, a, i, n);
      }, this);
    }, e.prototype.prepareView = function(t, i, n, r) {
      var a = t.renderTask, s = a.context;
      s.model = i, s.ecModel = n, s.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(i, a);
    }, e.prototype.performDataProcessorTasks = function(t, i) {
      this._performStageTasks(this._dataProcessorHandlers, t, i, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, i, n) {
      this._performStageTasks(this._visualHandlers, t, i, n);
    }, e.prototype._performStageTasks = function(t, i, n, r) {
      r = r || {};
      var a = !1, s = this;
      A(t, function(l, u) {
        if (!(r.visualType && r.visualType !== l.visualType)) {
          var c = s._stageTaskMap.get(l.uid), h = c.seriesTaskMap, d = c.overallTask;
          if (d) {
            var f, v = d.agentStubMap;
            v.each(function(g) {
              o(r, g) && (g.dirty(), f = !0);
            }), f && d.dirty(), s.updatePayload(d, n);
            var p = s.getPerformArgs(d, r.block);
            v.each(function(g) {
              g.perform(p);
            }), d.perform(p) && (a = !0);
          } else h && h.each(function(g, m) {
            o(r, g) && g.dirty();
            var _ = s.getPerformArgs(g, r.block);
            _.skip = !l.performRawSeries && i.isSeriesFiltered(g.context.model), s.updatePayload(g, n), g.perform(_) && (a = !0);
          });
        }
      });
      function o(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var i;
      t.eachSeries(function(n) {
        i = n.dataTask.perform() || i;
      }), this.unfinished = i || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var i = t.tail;
        do {
          if (i.__block) {
            t.blockIndex = i.__idxInPipeline;
            break;
          }
          i = i.getUpstream();
        } while (i);
      });
    }, e.prototype.updatePayload = function(t, i) {
      i !== "remain" && (t.context.payload = i);
    }, e.prototype._createSeriesStageTask = function(t, i, n, r) {
      var a = this, s = i.seriesTaskMap, o = i.seriesTaskMap = ct(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, r).each(c);
      function c(h) {
        var d = h.uid, f = o.set(d, s && s.get(d) || _o({
          plan: MN,
          reset: kN,
          count: TN
        }));
        f.context = {
          model: h,
          ecModel: n,
          api: r,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(h, f);
      }
    }, e.prototype._createOverallStageTask = function(t, i, n, r) {
      var a = this, s = i.overallTask = i.overallTask || _o({
        reset: bN
      });
      s.context = {
        ecModel: n,
        api: r,
        overallReset: t.overallReset,
        scheduler: a
      };
      var o = s.agentStubMap, l = s.agentStubMap = ct(), u = t.seriesType, c = t.getTargetSeries, h = !0, d = !1, f = "";
      process.env.NODE_ENV !== "production" && (f = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), it(!t.createOnAllSeries, f), u ? n.eachRawSeriesByType(u, v) : c ? c(n, r).each(v) : (h = !1, A(n.getSeries(), v));
      function v(p) {
        var g = p.uid, m = l.set(g, o && o.get(g) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (d = !0, _o({
          reset: xN,
          onDirty: SN
        })));
        m.context = {
          model: p,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, m.agent = s, m.__block = h, a._pipe(p, m);
      }
      d && s.dirty();
    }, e.prototype._pipe = function(t, i) {
      var n = t.uid, r = this._pipelineMap.get(n);
      !r.head && (r.head = i), r.tail && r.tail.pipe(i), r.tail = i, i.__idxInPipeline = r.count++, i.__pipeline = r;
    }, e.wrapStageHandler = function(t, i) {
      return mt(t) && (t = {
        overallReset: t,
        seriesType: CN(t)
      }), t.uid = Rc("stageHandler"), i && (t.visualType = i), t;
    }, e;
  })()
);
function bN(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function xN(e) {
  return e.overallProgress && wN;
}
function wN() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function SN() {
  this.agent && this.agent.dirty();
}
function MN(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function kN(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = Ie(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? yt(t, function(i, n) {
    return ow(n);
  }) : DN;
}
var DN = ow(0);
function ow(e) {
  return function(t, i) {
    var n = i.data, r = i.resetDefines[e];
    if (r && r.dataEach)
      for (var a = t.start; a < t.end; a++)
        r.dataEach(n, a);
    else r && r.progress && r.progress(t, n);
  };
}
function TN(e) {
  return e.data.count();
}
function CN(e) {
  Zu = null;
  try {
    e(Bo, lw);
  } catch {
  }
  return Zu;
}
var Bo = {}, lw = {}, Zu;
uw(Bo, np);
uw(lw, Fx);
Bo.eachSeriesByType = Bo.eachRawSeriesByType = function(e) {
  Zu = e;
};
Bo.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (Zu = e.subType);
};
function uw(e, t) {
  for (var i in t.prototype)
    e[i] = ke;
}
var W = St.darkColor, AN = W.background, Is = function() {
  return {
    axisLine: {
      lineStyle: {
        color: W.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: W.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [W.backgroundTint, W.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: W.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: W.axisLabel
    },
    axisName: {}
  };
}, A_ = {
  label: {
    color: W.secondary
  },
  itemStyle: {
    borderColor: W.borderTint
  },
  dividerLineStyle: {
    color: W.border
  }
}, cw = {
  darkMode: !0,
  color: W.theme,
  backgroundColor: AN,
  axisPointer: {
    lineStyle: {
      color: W.border
    },
    crossStyle: {
      color: W.borderShade
    },
    label: {
      color: W.tertiary
    }
  },
  legend: {
    textStyle: {
      color: W.secondary
    },
    pageTextStyle: {
      color: W.tertiary
    }
  },
  textStyle: {
    color: W.secondary
  },
  title: {
    textStyle: {
      color: W.primary
    },
    subtextStyle: {
      color: W.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: W.accent50
    }
  },
  tooltip: {
    backgroundColor: W.neutral20,
    defaultBorderColor: W.border,
    textStyle: {
      color: W.tertiary
    }
  },
  dataZoom: {
    borderColor: W.accent10,
    textStyle: {
      color: W.tertiary
    },
    brushStyle: {
      color: W.backgroundTint
    },
    handleStyle: {
      color: W.neutral00,
      borderColor: W.accent20
    },
    moveHandleStyle: {
      color: W.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: W.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: W.accent30
      },
      areaStyle: {
        color: W.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: W.accent50
      },
      areaStyle: {
        color: W.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: W.secondary
    },
    handleStyle: {
      borderColor: W.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: W.accent10
    },
    label: {
      color: W.tertiary
    },
    controlStyle: {
      color: W.accent30,
      borderColor: W.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: W.neutral00,
      borderColor: W.neutral20
    },
    dayLabel: {
      color: W.tertiary
    },
    monthLabel: {
      color: W.secondary
    },
    yearLabel: {
      color: W.secondary
    }
  },
  matrix: {
    x: A_,
    y: A_,
    backgroundColor: {
      borderColor: W.axisLine
    },
    body: {
      itemStyle: {
        borderColor: W.borderTint
      }
    }
  },
  timeAxis: Is(),
  logAxis: Is(),
  valueAxis: Is(),
  categoryAxis: Is(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: W.theme
  },
  gauge: {
    title: {
      color: W.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, W.neutral05]]
      }
    },
    axisLabel: {
      color: W.axisLabel
    },
    detail: {
      color: W.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: W.background
    }
  },
  radar: (function() {
    var e = Is();
    return e.axisName = {
      color: W.axisLabel
    }, e.axisLine.lineStyle.color = W.neutral20, e;
  })(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: W.neutral20,
        textStyle: {
          color: W.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: W.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: W.background
    }
  },
  map: {
    itemStyle: {
      borderColor: W.border,
      areaColor: W.neutral10
    },
    label: {
      color: W.tertiary
    },
    emphasis: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    },
    select: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: W.border,
      areaColor: W.neutral10
    },
    emphasis: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    },
    select: {
      label: {
        color: W.primary
      },
      itemStyle: {
        color: W.highlight
      }
    }
  }
};
cw.categoryAxis.splitLine.show = !1;
var PN = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var i = {}, n = {}, r = {};
      if (tt(t)) {
        var a = Gi(t);
        i.mainType = a.main || null, i.subType = a.sub || null;
      } else {
        var s = ["Index", "Name", "Id"], o = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        A(t, function(l, u) {
          for (var c = !1, h = 0; h < s.length; h++) {
            var d = s[h], f = u.lastIndexOf(d);
            if (f > 0 && f === u.length - d.length) {
              var v = u.slice(0, f);
              v !== "data" && (i.mainType = v, i[d.toLowerCase()] = l, c = !0);
            }
          }
          o.hasOwnProperty(u) && (n[u] = l, c = !0), c || (r[u] = l);
        });
      }
      return {
        cptQuery: i,
        dataQuery: n,
        otherQuery: r
      };
    }, e.prototype.filter = function(t, i) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var r = n.targetEl, a = n.packedEvent, s = n.model, o = n.view;
      if (!s || !o)
        return !0;
      var l = i.cptQuery, u = i.dataQuery;
      return c(l, s, "mainType") && c(l, s, "subType") && c(l, s, "index", "componentIndex") && c(l, s, "name") && c(l, s, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!o.filterForExposedEvent || o.filterForExposedEvent(t, i.otherQuery, r, a));
      function c(h, d, f, v) {
        return h[f] == null || d[v || f] === h[f];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  })()
), Ef = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], P_ = Ef.concat(["symbolKeepAspect"]), EN = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData();
    if (e.legendIcon && i.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var n = {}, r = {}, a = !1, s = 0; s < Ef.length; s++) {
      var o = Ef[s], l = e.get(o);
      mt(l) ? (a = !0, r[o] = l) : n[o] = l;
    }
    if (n.symbol = n.symbol || e.defaultSymbol, i.setVisual(Y({
      legendIcon: e.legendIcon || n.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(e))
      return;
    var u = qt(r);
    function c(h, d) {
      for (var f = e.getRawValue(d), v = e.getDataParams(d), p = 0; p < u.length; p++) {
        var g = u[p];
        h.setItemVisual(d, g, r[g](f, v));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, LN = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var i = e.getData();
    function n(r, a) {
      for (var s = r.getItemModel(a), o = 0; o < P_.length; o++) {
        var l = P_[o], u = s.getShallow(l, !0);
        u != null && r.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: i.hasItemOption ? n : null
    };
  }
};
function ON(e, t, i) {
  switch (i) {
    case "color":
      var n = e.getItemVisual(t, "style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, i);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + i);
  }
}
function IN(e, t) {
  switch (t) {
    case "color":
      var i = e.getVisual("style");
      return i[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Aa(e, t, i, n, r) {
  var a = e + t;
  i.isSilent(a) || (process.env.NODE_ENV !== "production" && Dn("event " + a + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(s) {
    for (var o = s.seriesIndex, l = s.option.selectedMap, u = r.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === o) {
        var h = s.getData(), d = qo(h, r.fromActionPayload);
        i.trigger(a, {
          type: a,
          seriesId: s.id,
          name: Z(d) ? h.getName(d[0]) : h.getName(d),
          selected: tt(l) ? l : Y({}, l)
        });
      }
  }));
}
function RN(e, t, i) {
  e.on("selectchanged", function(n) {
    var r = i.getModel();
    n.isFromClick ? (Aa("map", "selectchanged", t, r, n), Aa("pie", "selectchanged", t, r, n)) : n.fromAction === "select" ? (Aa("map", "selected", t, r, n), Aa("pie", "selected", t, r, n)) : n.fromAction === "unselect" && (Aa("map", "unselected", t, r, n), Aa("pie", "unselected", t, r, n));
  });
}
function no(e, t, i) {
  for (var n; e && !(t(e) && (n = e, i)); )
    e = e.__hostTarget || e.parent;
  return n;
}
var NN = Math.round(Math.random() * 9), FN = typeof Object.defineProperty == "function", BN = (function() {
  function e() {
    this._id = "__ec_inner_" + NN++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, i) {
    var n = this._guard(t);
    return FN ? Object.defineProperty(n, this._id, {
      value: i,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = i, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
})(), $N = Bt.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n + a), e.lineTo(i - r, n + a), e.closePath();
  }
}), zN = Bt.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n), e.lineTo(i, n + a), e.lineTo(i - r, n), e.closePath();
  }
}), VN = Bt.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.x, n = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), s = r / 2, o = s * s / (a - s), l = n - a + s + o, u = Math.asin(o / s), c = Math.cos(u) * s, h = Math.sin(u), d = Math.cos(u), f = s * 0.6, v = s * 0.7;
    e.moveTo(i - c, l + o), e.arc(i, l, s, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(i + c - h * f, l + o + d * f, i, n - v, i, n), e.bezierCurveTo(i, n - v, i - c + h * f, l + o + d * f, i - c, l + o), e.closePath();
  }
}), HN = Bt.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.height, n = t.width, r = t.x, a = t.y, s = n / 3 * 2;
    e.moveTo(r, a), e.lineTo(r + s, a + i), e.lineTo(r, a + i / 4 * 3), e.lineTo(r - s, a + i), e.lineTo(r, a), e.closePath();
  }
}), YN = {
  line: ps,
  rect: De,
  roundRect: De,
  square: De,
  circle: Lc,
  diamond: zN,
  pin: VN,
  arrow: HN,
  triangle: $N
}, WN = {
  line: function(e, t, i, n, r) {
    r.x1 = e, r.y1 = t + n / 2, r.x2 = e + i, r.y2 = t + n / 2;
  },
  rect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n;
  },
  roundRect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n, r.r = Math.min(i, n) / 4;
  },
  square: function(e, t, i, n, r) {
    var a = Math.min(i, n);
    r.x = e, r.y = t, r.width = a, r.height = a;
  },
  circle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.r = Math.min(i, n) / 2;
  },
  diamond: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  },
  pin: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  arrow: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  triangle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  }
}, Lf = {};
A(YN, function(e, t) {
  Lf[t] = new e();
});
var UN = Bt.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, i) {
    var n = w1(e, t, i), r = this.shape;
    return r && r.symbolType === "pin" && t.position === "inside" && (n.y = i.y + i.height * 0.4), n;
  },
  buildPath: function(e, t, i) {
    var n = t.symbolType;
    if (n !== "none") {
      var r = Lf[n];
      r || (n = "rect", r = Lf[n]), WN[n](t.x, t.y, t.width, t.height, r.shape), r.buildPath(e, r.shape, i);
    }
  }
});
function GN(e, t) {
  if (this.type !== "image") {
    var i = this.style;
    this.__isEmptyBrush ? (i.stroke = e, i.fill = t || St.color.neutral00, i.lineWidth = 2) : this.shape.symbolType === "line" ? i.stroke = e : i.fill = e, this.markRedraw();
  }
}
function hw(e, t, i, n, r, a, s) {
  var o = e.indexOf("empty") === 0;
  o && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = dx(e.slice(8), new ot(t, i, n, r), s ? "center" : "cover") : e.indexOf("path://") === 0 ? l = Gv(e.slice(7), {}, new ot(t, i, n, r), s ? "center" : "cover") : l = new UN({
    shape: {
      symbolType: e,
      x: t,
      y: i,
      width: n,
      height: r
    }
  }), l.__isEmptyBrush = o, l.setColor = GN, a && l.setColor(a), l;
}
function XN(e, t) {
  if (e != null)
    return Z(e) || (e = [e, e]), [He(e[0], t[0]) || 0, He(nt(e[1], e[0]), t[1]) || 0];
}
function Wr(e) {
  return isFinite(e);
}
function jN(e, t, i) {
  var n = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, s = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, s = s * i.height + i.y), n = Wr(n) ? n : 0, r = Wr(r) ? r : 1, a = Wr(a) ? a : 0, s = Wr(s) ? s : 0;
  var o = e.createLinearGradient(n, a, r, s);
  return o;
}
function qN(e, t, i) {
  var n = i.width, r = i.height, a = Math.min(n, r), s = t.x == null ? 0.5 : t.x, o = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (s = s * n + i.x, o = o * r + i.y, l = l * a), s = Wr(s) ? s : 0.5, o = Wr(o) ? o : 0.5, l = l >= 0 && Wr(l) ? l : 0.5;
  var u = e.createRadialGradient(s, o, 0, s, o, l);
  return u;
}
function Of(e, t, i) {
  for (var n = t.type === "radial" ? qN(e, t, i) : jN(e, t, i), r = t.colorStops, a = 0; a < r.length; a++)
    n.addColorStop(r[a].offset, r[a].color);
  return n;
}
function ZN(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var i = 0; i < e.length; i++)
    if (e[i] !== t[i])
      return !0;
  return !1;
}
function Vl(e) {
  return parseInt(e, 10);
}
function Hl(e, t, i) {
  var n = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], s = ["paddingRight", "paddingBottom"][t];
  if (i[n] != null && i[n] !== "auto")
    return parseFloat(i[n]);
  var o = document.defaultView.getComputedStyle(e);
  return (e[r] || Vl(o[n]) || Vl(e.style[n])) - (Vl(o[a]) || 0) - (Vl(o[s]) || 0) | 0;
}
function KN(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : Zt(e) ? [e] : Z(e) ? e : null;
}
function dw(e) {
  var t = e.style, i = t.lineDash && t.lineWidth > 0 && KN(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (i) {
    var r = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    r && r !== 1 && (i = yt(i, function(a) {
      return a / r;
    }), n /= r);
  }
  return [i, n];
}
var QN = new ls(!0);
function Ku(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function E_(e) {
  return typeof e == "string" && e !== "none";
}
function Qu(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function L_(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = i;
  } else
    e.fill();
}
function O_(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = i;
  } else
    e.stroke();
}
function If(e, t, i) {
  var n = N1(t.image, t.__image, i);
  if (Ac(n)) {
    var r = e.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && r && r.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * JP), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
    }
    return r;
  }
}
function JN(e, t, i, n) {
  var r, a = Ku(i), s = Qu(i), o = i.strokePercent, l = o < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || QN, h = t.__dirty;
  if (!n) {
    var d = i.fill, f = i.stroke, v = s && !!d.colorStops, p = a && !!f.colorStops, g = s && !!d.image, m = a && !!f.image, _ = void 0, y = void 0, b = void 0, w = void 0, S = void 0;
    (v || p) && (S = t.getBoundingRect()), v && (_ = h ? Of(e, d, S) : t.__canvasFillGradient, t.__canvasFillGradient = _), p && (y = h ? Of(e, f, S) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = y), g && (b = h || !t.__canvasFillPattern ? If(e, d, t) : t.__canvasFillPattern, t.__canvasFillPattern = b), m && (w = h || !t.__canvasStrokePattern ? If(e, f, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = w), v ? e.fillStyle = _ : g && (b ? e.fillStyle = b : s = !1), p ? e.strokeStyle = y : m && (w ? e.strokeStyle = w : a = !1);
  }
  var M = t.getGlobalScale();
  c.setScale(M[0], M[1], t.segmentIgnoreThreshold);
  var k, T;
  e.setLineDash && i.lineDash && (r = dw(t), k = r[0], T = r[1]);
  var C = !0;
  (u || h & Fa) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), C = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), C && c.rebuildPath(e, l ? o : 1), k && (e.setLineDash(k), e.lineDashOffset = T), n || (i.strokeFirst ? (a && O_(e, i), s && L_(e, i)) : (s && L_(e, i), a && O_(e, i))), k && e.setLineDash([]);
}
function tF(e, t, i) {
  var n = t.__image = N1(i.image, t.__image, t, t.onload);
  if (!(!n || !Ac(n))) {
    var r = i.x || 0, a = i.y || 0, s = t.getWidth(), o = t.getHeight(), l = n.width / n.height;
    if (s == null && o != null ? s = o * l : o == null && s != null ? o = s / l : s == null && o == null && (s = n.width, o = n.height), i.sWidth && i.sHeight) {
      var u = i.sx || 0, c = i.sy || 0;
      e.drawImage(n, u, c, i.sWidth, i.sHeight, r, a, s, o);
    } else if (i.sx && i.sy) {
      var u = i.sx, c = i.sy, h = s - u, d = o - c;
      e.drawImage(n, u, c, h, d, r, a, s, o);
    } else
      e.drawImage(n, r, a, s, o);
  }
}
function eF(e, t, i) {
  var n, r = i.text;
  if (r != null && (r += ""), r) {
    e.font = i.font || er, e.textAlign = i.textAlign, e.textBaseline = i.textBaseline;
    var a = void 0, s = void 0;
    e.setLineDash && i.lineDash && (n = dw(t), a = n[0], s = n[1]), a && (e.setLineDash(a), e.lineDashOffset = s), i.strokeFirst ? (Ku(i) && e.strokeText(r, i.x, i.y), Qu(i) && e.fillText(r, i.x, i.y)) : (Qu(i) && e.fillText(r, i.x, i.y), Ku(i) && e.strokeText(r, i.x, i.y)), a && e.setLineDash([]);
  }
}
var I_ = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], R_ = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function fw(e, t, i, n, r) {
  var a = !1;
  if (!n && (i = i || {}, t === i))
    return !1;
  if (n || t.opacity !== i.opacity) {
    Ue(e, r), a = !0;
    var s = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(s) ? ta.opacity : s;
  }
  (n || t.blend !== i.blend) && (a || (Ue(e, r), a = !0), e.globalCompositeOperation = t.blend || ta.blend);
  for (var o = 0; o < I_.length; o++) {
    var l = I_[o];
    (n || t[l] !== i[l]) && (a || (Ue(e, r), a = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== i.shadowColor) && (a || (Ue(e, r), a = !0), e.shadowColor = t.shadowColor || ta.shadowColor), a;
}
function N_(e, t, i, n, r) {
  var a = $o(t, r.inHover), s = n ? null : i && $o(i, r.inHover) || {};
  if (a === s)
    return !1;
  var o = fw(e, a, s, n, r);
  if ((n || a.fill !== s.fill) && (o || (Ue(e, r), o = !0), E_(a.fill) && (e.fillStyle = a.fill)), (n || a.stroke !== s.stroke) && (o || (Ue(e, r), o = !0), E_(a.stroke) && (e.strokeStyle = a.stroke)), (n || a.opacity !== s.opacity) && (o || (Ue(e, r), o = !0), e.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (o || (Ue(e, r), o = !0), e.lineWidth = u);
  }
  for (var c = 0; c < R_.length; c++) {
    var h = R_[c], d = h[0];
    (n || a[d] !== s[d]) && (o || (Ue(e, r), o = !0), e[d] = a[d] || h[1]);
  }
  return o;
}
function iF(e, t, i, n, r) {
  return fw(e, $o(t, r.inHover), i && $o(i, r.inHover), n, r);
}
function vw(e, t) {
  var i = t.transform, n = e.dpr || 1;
  i ? e.setTransform(n * i[0], n * i[1], n * i[2], n * i[3], n * i[4], n * i[5]) : e.setTransform(n, 0, 0, n, 0, 0);
}
function nF(e, t, i) {
  for (var n = !1, r = 0; r < e.length; r++) {
    var a = e[r];
    n = n || a.isZeroArea(), vw(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  i.allClipped = n;
}
function rF(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var F_ = 1, B_ = 2, $_ = 3, z_ = 4;
function aF(e) {
  var t = Qu(e), i = Ku(e);
  return !(e.lineDash || !(+t ^ +i) || t && typeof e.fill != "string" || i && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function Ue(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function $o(e, t) {
  return t && e.__hoverStyle || e.style;
}
function pw(e, t) {
  Ur(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Ur(e, t, i, n) {
  var r = t.transform;
  if (!t.shouldBePainted(i.viewWidth, i.viewHeight, !1, !1)) {
    t.__dirty &= ~Ke, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, s = i.prevElClipPaths, o = !1, l = !1;
  if ((!s || ZN(a, s)) && (s && s.length && (Ue(e, i), e.restore(), l = o = !0, i.prevElClipPaths = null, i.allClipped = !1, i.prevEl = null), a && a.length && (Ue(e, i), e.save(), nF(a, e, i), o = !0), i.prevElClipPaths = a), i.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = i.prevEl;
  u || (l = o = !0);
  var c = t instanceof Bt && t.autoBatch && aF(t.style);
  o || rF(r, u.transform) ? (Ue(e, i), vw(e, t)) : c || Ue(e, i);
  var h = $o(t, i.inHover);
  t instanceof Bt ? (i.lastDrawType !== F_ && (l = !0, i.lastDrawType = F_), N_(e, t, u, l, i), (!c || !i.batchFill && !i.batchStroke) && e.beginPath(), JN(e, t, h, c), c && (i.batchFill = h.fill || "", i.batchStroke = h.stroke || "")) : t instanceof Bu ? (i.lastDrawType !== $_ && (l = !0, i.lastDrawType = $_), N_(e, t, u, l, i), eF(e, t, h)) : t instanceof ua ? (i.lastDrawType !== B_ && (l = !0, i.lastDrawType = B_), iF(e, t, u, l, i), tF(e, t, h)) : t.getTemporalDisplayables && (i.lastDrawType !== z_ && (l = !0, i.lastDrawType = z_), sF(e, t, i)), c && n && Ue(e, i), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), i.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function sF(e, t, i) {
  var n = t.getDisplayables(), r = t.getTemporalDisplayables();
  e.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: i.viewWidth,
    viewHeight: i.viewHeight,
    inHover: i.inHover
  }, s, o;
  for (s = t.getCursor(), o = n.length; s < o; s++) {
    var l = n[s];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ur(e, l, a, s === o - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = r.length; u < c; u++) {
    var l = r[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ur(e, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var hd = new BN(), V_ = new as(100), H_ = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Y_(e, t) {
  if (e === "none")
    return null;
  var i = t.getDevicePixelRatio(), n = t.getZr(), r = n.painter.type === "svg";
  e.dirty && hd.delete(e);
  var a = hd.get(e);
  if (a)
    return a;
  var s = Jt(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  s.backgroundColor === "none" && (s.backgroundColor = null);
  var o = {
    repeat: "repeat"
  };
  return l(o), o.rotation = s.rotation, o.scaleX = o.scaleY = r ? 1 : 1 / i, hd.set(e, o), e.dirty = !1, o;
  function l(u) {
    for (var c = [i], h = !0, d = 0; d < H_.length; ++d) {
      var f = s[H_[d]];
      if (f != null && !Z(f) && !tt(f) && !Zt(f) && typeof f != "boolean") {
        h = !1;
        break;
      }
      c.push(f);
    }
    var v;
    if (h) {
      v = c.join(",") + (r ? "-svg" : "");
      var p = V_.get(v);
      p && (r ? u.svgElement = p : u.image = p);
    }
    var g = mw(s.dashArrayX), m = oF(s.dashArrayY), _ = gw(s.symbol), y = lF(g), b = _w(m), w = !r && kn.createCanvas(), S = r && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, M = T(), k;
    w && (w.width = M.width * i, w.height = M.height * i, k = w.getContext("2d")), C(), h && V_.put(v, w || S), u.image = w, u.svgElement = S, u.svgWidth = M.width, u.svgHeight = M.height;
    function T() {
      for (var D = 1, P = 0, O = y.length; P < O; ++P)
        D = qm(D, y[P]);
      for (var I = 1, P = 0, O = _.length; P < O; ++P)
        I = qm(I, _[P].length);
      D *= I;
      var N = b * y.length * _.length;
      if (process.env.NODE_ENV !== "production") {
        var F = function(q) {
          console.warn("Calculated decal size is greater than " + q + " due to decal option settings so " + q + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + q + " to be larger to avoid incontinuity.");
        };
        D > s.maxTileWidth && F("maxTileWidth"), N > s.maxTileHeight && F("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(D, s.maxTileWidth)),
        height: Math.max(1, Math.min(N, s.maxTileHeight))
      };
    }
    function C() {
      k && (k.clearRect(0, 0, w.width, w.height), s.backgroundColor && (k.fillStyle = s.backgroundColor, k.fillRect(0, 0, w.width, w.height)));
      for (var D = 0, P = 0; P < m.length; ++P)
        D += m[P];
      if (D <= 0)
        return;
      for (var O = -b, I = 0, N = 0, F = 0; O < M.height; ) {
        if (I % 2 === 0) {
          for (var q = N / 2 % _.length, V = 0, B = 0, $ = 0; V < M.width * 2; ) {
            for (var j = 0, P = 0; P < g[F].length; ++P)
              j += g[F][P];
            if (j <= 0)
              break;
            if (B % 2 === 0) {
              var G = (1 - s.symbolSize) * 0.5, et = V + g[F][B] * G, at = O + m[I] * G, wt = g[F][B] * s.symbolSize, Tt = m[I] * s.symbolSize, me = $ / 2 % _[q].length;
              Pe(et, at, wt, Tt, _[q][me]);
            }
            V += g[F][B], ++$, ++B, B === g[F].length && (B = 0);
          }
          ++F, F === g.length && (F = 0);
        }
        O += m[I], ++N, ++I, I === m.length && (I = 0);
      }
      function Pe(Pt, Nt, rt, ft, Ii) {
        var le = r ? 1 : i, Wp = hw(Ii, Pt * le, Nt * le, rt * le, ft * le, s.color, s.symbolKeepAspect);
        if (r) {
          var Up = n.painter.renderOneToVNode(Wp);
          Up && S.children.push(Up);
        } else
          pw(k, Wp);
      }
    }
  }
}
function gw(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (tt(e))
    return [[e]];
  for (var t = !0, i = 0; i < e.length; ++i)
    if (!tt(e[i])) {
      t = !1;
      break;
    }
  if (t)
    return gw([e]);
  for (var n = [], i = 0; i < e.length; ++i)
    tt(e[i]) ? n.push([e[i]]) : n.push(e[i]);
  return n;
}
function mw(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if (Zt(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var i = !0, n = 0; n < e.length; ++n)
    if (!Zt(e[n])) {
      i = !1;
      break;
    }
  if (i)
    return mw([e]);
  for (var r = [], n = 0; n < e.length; ++n)
    if (Zt(e[n])) {
      var t = Math.ceil(e[n]);
      r.push([t, t]);
    } else {
      var t = yt(e[n], function(o) {
        return Math.ceil(o);
      });
      t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
    }
  return r;
}
function oF(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if (Zt(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var i = yt(e, function(n) {
    return Math.ceil(n);
  });
  return e.length % 2 ? i.concat(i) : i;
}
function lF(e) {
  return yt(e, function(t) {
    return _w(t);
  });
}
function _w(e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += e[i];
  return e.length % 2 === 1 ? t * 2 : t;
}
function uF(e, t) {
  e.eachRawSeries(function(i) {
    if (!e.isSeriesFiltered(i)) {
      var n = i.getData();
      n.hasItemVisual() && n.each(function(s) {
        var o = n.getItemVisual(s, "decal");
        if (o) {
          var l = n.ensureUniqueItemVisual(s, "style");
          l.decal = Y_(o, t);
        }
      });
      var r = n.getVisual("decal");
      if (r) {
        var a = n.getVisual("style");
        a.decal = Y_(r, t);
      }
    }
  });
}
var wi = new Pi(), Ju = {};
function cF(e, t) {
  process.env.NODE_ENV !== "production" && Ju[e] && Kt("Already has an implementation of " + e + "."), Ju[e] = t;
}
function hF(e) {
  return process.env.NODE_ENV !== "production" && (Ju[e] || Kt("Implementation of " + e + " doesn't exists.")), Ju[e];
}
var dF = 1, fF = 800, vF = 900, pF = 1e3, gF = 2e3, mF = 5e3, yw = 1e3, _F = 1100, op = 2e3, bw = 3e3, yF = 4e3, $c = 4500, bF = 4600, xF = 5e3, wF = 6e3, xw = 7e3, SF = {
  PROCESSOR: {
    FILTER: pF,
    SERIES_FILTER: fF,
    STATISTIC: mF
  },
  VISUAL: {
    LAYOUT: yw,
    PROGRESSIVE_LAYOUT: _F,
    GLOBAL: op,
    CHART: bw,
    POST_CHART_LAYOUT: bF,
    COMPONENT: yF,
    BRUSH: xF,
    CHART_ITEM: $c,
    ARIA: wF,
    DECAL: xw
  }
}, re = "__flagInMainProcess", Yl = "__mainProcessVersion", ve = "__pendingUpdate", dd = "__needsUpdateStatus", W_ = /^[a-zA-Z0-9_]+$/, fd = "__connectUpdateStatus", U_ = 0, MF = 1, kF = 2;
function ww(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    if (this.isDisposed()) {
      Be(this.id);
      return;
    }
    return Mw(this, e, t);
  };
}
function Sw(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    return Mw(this, e, t);
  };
}
function Mw(e, t, i) {
  return i[0] = i[0] && i[0].toLowerCase(), Pi.prototype[t].apply(e, i);
}
var kw = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  })(Pi)
), Dw = kw.prototype;
Dw.on = Sw("on");
Dw.off = Sw("off");
var Lr, vd, Wl, on, Ul, pd, gd, Pa, Ea, G_, X_, md, j_, Gl, q_, Tw, ni, Z_, La, Cw = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i, n, r) {
      var a = e.call(this, new PN()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, a._dom = i;
      var s = "canvas", o = "auto", l = !1;
      if (a[Yl] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          st.hasGlobalWindow ? window : global
        );
        u && (s = nt(u.__ECHARTS__DEFAULT__RENDERER__, s), o = nt(u.__ECHARTS__DEFAULT__COARSE_POINTER, o), l = nt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      r.ssr;
      var c = a._zr = Gm(i, {
        renderer: r.renderer || s,
        devicePixelRatio: r.devicePixelRatio,
        width: r.width,
        height: r.height,
        ssr: r.ssr,
        useDirtyRect: nt(r.useDirtyRect, l),
        useCoarsePointer: nt(r.useCoarsePointer, o),
        pointerSize: r.pointerSize
      });
      a._ssr = r.ssr, a._throttledZrFlush = iw(Dt(c.flush, c), 17), a._updateTheme(n), a._locale = kR(r.locale || Sx), a._coordSysMgr = new Nc();
      var h = a._api = q_(a);
      function d(f, v) {
        return f.__prio - v.__prio;
      }
      return iu(ic, d), iu(Nf, d), a._scheduler = new sw(a, h, Nf, ic), a._messageCenter = new kw(), a._initEvents(), a.resize = Dt(a.resize, a), c.animation.on("frame", a._onframe, a), G_(c, a), X_(c, a), Wd(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        Z_(this);
        var i = this._scheduler;
        if (this[ve]) {
          var n = this[ve].silent;
          this[re] = !0, La(this);
          try {
            Lr(this), on.update.call(this, null, this[ve].updateParams);
          } catch (l) {
            throw this[re] = !1, this[ve] = null, l;
          }
          this._zr.flush(), this[re] = !1, this[ve] = null, Pa.call(this, n), Ea.call(this, n);
        } else if (i.unfinished) {
          var r = dF, a = this._model, s = this._api;
          i.unfinished = !1;
          do {
            var o = +/* @__PURE__ */ new Date();
            i.performSeriesTasks(a), i.performDataProcessorTasks(a), pd(this, a), i.performVisualTasks(a), Gl(this, this._model, s, "remain", {}), r -= +/* @__PURE__ */ new Date() - o;
          } while (r > 0 && i.unfinished);
          i.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(i, n, r) {
      if (this[re]) {
        process.env.NODE_ENV !== "production" && Kt("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Be(this.id);
        return;
      }
      var a, s, o;
      if (Q(n) && (r = n.lazyUpdate, a = n.silent, s = n.replaceMerge, o = n.transition, n = n.notMerge), this[re] = !0, La(this), !this._model || n) {
        var l = new l5(this._api), u = this._theme, c = this._model = new np();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(i, {
        replaceMerge: s
      }, Ff);
      var h = {
        seriesTransition: o,
        optionChanged: !0
      };
      if (r)
        this[ve] = {
          silent: a,
          updateParams: h
        }, this[re] = !1, this.getZr().wakeUp();
      else {
        try {
          Lr(this), on.update.call(this, null, h);
        } catch (d) {
          throw this[ve] = null, this[re] = !1, d;
        }
        this._ssr || this._zr.flush(), this[ve] = null, this[re] = !1, Pa.call(this, a), Ea.call(this, a);
      }
    }, t.prototype.setTheme = function(i, n) {
      if (this[re]) {
        process.env.NODE_ENV !== "production" && Kt("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Be(this.id);
        return;
      }
      var r = this._model;
      if (r) {
        var a = n && n.silent, s = null;
        this[ve] && (a == null && (a = this[ve].silent), s = this[ve].updateParams, this[ve] = null), this[re] = !0, La(this);
        try {
          this._updateTheme(i), r.setTheme(this._theme), Lr(this), on.update.call(this, {
            type: "setTheme"
          }, s);
        } catch (o) {
          throw this[re] = !1, o;
        }
        this[re] = !1, Pa.call(this, a), Ea.call(this, a);
      }
    }, t.prototype._updateTheme = function(i) {
      tt(i) && (i = Aw[i]), i && (i = pt(i), i && $x(i, !0), this._theme = i);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || st.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(i) {
      return process.env.NODE_ENV !== "production" && ge("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(i);
    }, t.prototype.renderToCanvas = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: i.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: i.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: i.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var i = this._zr, n = i.storage.getDisplayList();
      return A(n, function(r) {
        r.stopAnimation(null, !0);
      }), i.painter.toDataURL();
    }, t.prototype.getDataURL = function(i) {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      i = i || {};
      var n = i.excludeComponents, r = this._model, a = [], s = this;
      A(n, function(l) {
        r.eachComponent({
          mainType: l
        }, function(u) {
          var c = s._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var o = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(i).toDataURL("image/" + (i && i.type || "png"));
      return A(a, function(l) {
        l.group.ignore = !1;
      }), o;
    }, t.prototype.getConnectedDataURL = function(i) {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      var n = i.type === "svg", r = this.group, a = Math.min, s = Math.max, o = 1 / 0;
      if (K_[r]) {
        var l = o, u = o, c = -o, h = -o, d = [], f = i && i.pixelRatio || this.getDevicePixelRatio();
        A(yo, function(y, b) {
          if (y.group === r) {
            var w = n ? y.getZr().painter.getSvgDom().innerHTML : y.renderToCanvas(pt(i)), S = y.getDom().getBoundingClientRect();
            l = a(S.left, l), u = a(S.top, u), c = s(S.right, c), h = s(S.bottom, h), d.push({
              dom: w,
              left: S.left,
              top: S.top
            });
          }
        }), l *= f, u *= f, c *= f, h *= f;
        var v = c - l, p = h - u, g = kn.createCanvas(), m = Gm(g, {
          renderer: n ? "svg" : "canvas"
        });
        if (m.resize({
          width: v,
          height: p
        }), n) {
          var _ = "";
          return A(d, function(y) {
            var b = y.left - l, w = y.top - u;
            _ += '<g transform="translate(' + b + "," + w + ')">' + y.dom + "</g>";
          }), m.painter.getSvgRoot().innerHTML = _, i.connectedBackgroundColor && m.painter.setBackgroundColor(i.connectedBackgroundColor), m.refreshImmediately(), m.painter.toDataURL();
        } else
          return i.connectedBackgroundColor && m.add(new De({
            shape: {
              x: 0,
              y: 0,
              width: v,
              height: p
            },
            style: {
              fill: i.connectedBackgroundColor
            }
          })), A(d, function(y) {
            var b = new ua({
              style: {
                x: y.left * f - l,
                y: y.top * f - u,
                image: y.dom
              }
            });
            m.add(b);
          }), m.refreshImmediately(), g.toDataURL("image/" + (i && i.type || "png"));
      } else
        return this.getDataURL(i);
    }, t.prototype.convertToPixel = function(i, n, r) {
      return Ul(this, "convertToPixel", i, n, r);
    }, t.prototype.convertToLayout = function(i, n, r) {
      return Ul(this, "convertToLayout", i, n, r);
    }, t.prototype.convertFromPixel = function(i, n, r) {
      return Ul(this, "convertFromPixel", i, n, r);
    }, t.prototype.containPixel = function(i, n) {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      var r = this._model, a, s = Rh(r, i);
      return A(s, function(o, l) {
        l.indexOf("Models") >= 0 && A(o, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? a = a || h.containPoint(n, u) : process.env.NODE_ENV !== "production" && ui(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && ui(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(i, n) {
      var r = this._model, a = Rh(r, i, {
        defaultMainType: "series"
      }), s = a.seriesModel;
      process.env.NODE_ENV !== "production" && (s || ui("There is no specified series model"));
      var o = s.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? o.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? ON(o, l, n) : IN(o, n);
    }, t.prototype.getViewOfComponentModel = function(i) {
      return this._componentsMap[i.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(i) {
      return this._chartsMap[i.__viewId];
    }, t.prototype._initEvents = function() {
      var i = this;
      A(DF, function(r) {
        var a = function(s) {
          var o = i.getModel(), l = s.target, u, c = r === "globalout";
          if (c ? u = {} : l && no(l, function(p) {
            var g = zt(p);
            if (g && g.dataIndex != null) {
              var m = g.dataModel || o.getSeriesByIndex(g.seriesIndex);
              return u = m && m.getDataParams(g.dataIndex, g.dataType, l) || {}, !0;
            } else if (g.eventData)
              return u = Y({}, g.eventData), !0;
          }, !0), u) {
            var h = u.componentType, d = u.componentIndex;
            (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", d = u.seriesIndex);
            var f = h && d != null && o.getComponent(h, d), v = f && i[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(f && v) && ui("model or view can not be found by params"), u.event = s, u.type = r, i._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: f,
              view: v
            }, i.trigger(r, u);
          }
        };
        a.zrEventfulCallAtLast = !0, i._zr.on(r, a, i);
      });
      var n = this._messageCenter;
      A(Rf, function(r, a) {
        n.on(a, function(s) {
          i.trigger(a, s);
        });
      }), RN(n, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      this._disposed = !0;
      var i = this.getDom();
      i && O1(this.getDom(), up, "");
      var n = this, r = n._api, a = n._model;
      A(n._componentsViews, function(s) {
        s.dispose(a, r);
      }), A(n._chartsViews, function(s) {
        s.dispose(a, r);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete yo[n.id];
    }, t.prototype.resize = function(i) {
      if (this[re]) {
        process.env.NODE_ENV !== "production" && Kt("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Be(this.id);
        return;
      }
      this._zr.resize(i);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var r = n.resetOption("media"), a = i && i.silent;
        this[ve] && (a == null && (a = this[ve].silent), r = !0, this[ve] = null), this[re] = !0, La(this);
        try {
          r && Lr(this), on.update.call(this, {
            type: "resize",
            animation: Y({
              // Disable animation
              duration: 0
            }, i && i.animation)
          });
        } catch (s) {
          throw this[re] = !1, s;
        }
        this[re] = !1, Pa.call(this, a), Ea.call(this, a);
      }
    }, t.prototype.showLoading = function(i, n) {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      if (Q(i) && (n = i, i = ""), i = i || "default", this.hideLoading(), !Bf[i]) {
        process.env.NODE_ENV !== "production" && ui("Loading effects " + i + " not exists.");
        return;
      }
      var r = Bf[i](this._api, n), a = this._zr;
      this._loadingFX = r, a.add(r);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(i) {
      var n = Y({}, i);
      return n.type = ec[i.type], n;
    }, t.prototype.dispatchAction = function(i, n) {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      if (Q(n) || (n = {
        silent: !!n
      }), !!tc[i.type] && this._model) {
        if (this[re]) {
          this._pendingActions.push(i);
          return;
        }
        var r = n.silent;
        gd.call(this, i, r);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && st.browser.weChat && this._throttledZrFlush(), Pa.call(this, r), Ea.call(this, r);
      }
    }, t.prototype.updateLabelLayout = function() {
      wi.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(i) {
      if (this._disposed) {
        Be(this.id);
        return;
      }
      var n = i.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && it(i.data && a), a.appendData(i), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = (function() {
      Lr = function(h) {
        var d = h._scheduler;
        d.restorePipelines(h._model), d.prepareStageTasks(), vd(h, !0), vd(h, !1), d.plan();
      }, vd = function(h, d) {
        for (var f = h._model, v = h._scheduler, p = d ? h._componentsViews : h._chartsViews, g = d ? h._componentsMap : h._chartsMap, m = h._zr, _ = h._api, y = 0; y < p.length; y++)
          p[y].__alive = !1;
        d ? f.eachComponent(function(S, M) {
          S !== "series" && b(M);
        }) : f.eachSeries(b);
        function b(S) {
          var M = S.__requireNewView;
          S.__requireNewView = !1;
          var k = "_ec_" + S.id + "_" + S.type, T = !M && g[k];
          if (!T) {
            var C = Gi(S.type), D = d ? Tn.getClass(C.main, C.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Kn.getClass(C.sub)
            );
            process.env.NODE_ENV !== "production" && it(D, C.sub + " does not exist."), T = new D(), T.init(f, _), g[k] = T, p.push(T), m.add(T.group);
          }
          S.__viewId = T.__id = k, T.__alive = !0, T.__model = S, T.group.__ecComponentInfo = {
            mainType: S.mainType,
            index: S.componentIndex
          }, !d && v.prepareView(T, S, f, _);
        }
        for (var y = 0; y < p.length; ) {
          var w = p[y];
          w.__alive ? y++ : (!d && w.renderTask.dispose(), m.remove(w.group), w.dispose(f, _), p.splice(y, 1), g[w.__id] === w && delete g[w.__id], w.__id = w.group.__ecComponentInfo = null);
        }
      }, Wl = function(h, d, f, v, p) {
        var g = h._model;
        if (g.setUpdatePayload(f), !v) {
          A([].concat(h._componentsViews).concat(h._chartsViews), w);
          return;
        }
        var m = {};
        m[v + "Id"] = f[v + "Id"], m[v + "Index"] = f[v + "Index"], m[v + "Name"] = f[v + "Name"];
        var _ = {
          mainType: v,
          query: m
        };
        p && (_.subType = p);
        var y = f.excludeSeriesId, b;
        y != null && (b = ct(), A(Ie(y), function(S) {
          var M = ki(S, null);
          M != null && b.set(M, !0);
        })), g && g.eachComponent(_, function(S) {
          var M = b && b.get(S.id) != null;
          if (!M)
            if (P0(f))
              if (S instanceof rr)
                f.type === ea && !f.notBlur && !S.get(["emphasis", "disabled"]) && iI(S, f, h._api);
              else {
                var k = Fv(S.mainType, S.componentIndex, f.name, h._api), T = k.focusSelf, C = k.dispatchers;
                f.type === ea && T && !f.notBlur && mf(S.mainType, S.componentIndex, h._api), C && A(C, function(D) {
                  f.type === ea ? Vu(D) : Hu(D);
                });
              }
            else _f(f) && S instanceof rr && (aI(S, f, h._api), D0(S), ni(h));
        }, h), g && g.eachComponent(_, function(S) {
          var M = b && b.get(S.id) != null;
          M || w(h[v === "series" ? "_chartsMap" : "_componentsMap"][S.__viewId]);
        }, h);
        function w(S) {
          S && S.__alive && S[d] && S[d](S.__model, g, h._api, f);
        }
      }, on = {
        prepareAndUpdate: function(h) {
          Lr(this), on.update.call(this, h, h && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, d) {
          var f = this._model, v = this._api, p = this._zr, g = this._coordSysMgr, m = this._scheduler;
          if (f) {
            f.setUpdatePayload(h), m.restoreData(f, h), m.performSeriesTasks(f), g.create(f, v), m.performDataProcessorTasks(f, h), pd(this, f), g.update(f, v), n(f), m.performVisualTasks(f, h);
            var _ = f.get("backgroundColor") || "transparent";
            p.setBackgroundColor(_);
            var y = f.get("darkMode");
            y != null && y !== "auto" && p.setDarkMode(y), md(this, f, v, h, d), wi.trigger("afterupdate", f, v);
          }
        },
        updateTransform: function(h) {
          var d = this, f = this._model, v = this._api;
          if (f) {
            f.setUpdatePayload(h);
            var p = [];
            f.eachComponent(function(m, _) {
              if (m !== "series") {
                var y = d.getViewOfComponentModel(_);
                if (y && y.__alive)
                  if (y.updateTransform) {
                    var b = y.updateTransform(_, f, v, h);
                    b && b.update && p.push(y);
                  } else
                    p.push(y);
              }
            });
            var g = ct();
            f.eachSeries(function(m) {
              var _ = d._chartsMap[m.__viewId];
              if (_.updateTransform) {
                var y = _.updateTransform(m, f, v, h);
                y && y.update && g.set(m.uid, 1);
              } else
                g.set(m.uid, 1);
            }), n(f), this._scheduler.performVisualTasks(f, h, {
              setDirty: !0,
              dirtyMap: g
            }), Gl(this, f, v, h, {}, g), wi.trigger("afterupdate", f, v);
          }
        },
        updateView: function(h) {
          var d = this._model;
          d && (d.setUpdatePayload(h), Kn.markUpdateMethod(h, "updateView"), n(d), this._scheduler.performVisualTasks(d, h, {
            setDirty: !0
          }), md(this, d, this._api, h, {}), wi.trigger("afterupdate", d, this._api));
        },
        updateVisual: function(h) {
          var d = this, f = this._model;
          f && (f.setUpdatePayload(h), f.eachSeries(function(v) {
            v.getData().clearAllVisual();
          }), Kn.markUpdateMethod(h, "updateVisual"), n(f), this._scheduler.performVisualTasks(f, h, {
            visualType: "visual",
            setDirty: !0
          }), f.eachComponent(function(v, p) {
            if (v !== "series") {
              var g = d.getViewOfComponentModel(p);
              g && g.__alive && g.updateVisual(p, f, d._api, h);
            }
          }), f.eachSeries(function(v) {
            var p = d._chartsMap[v.__viewId];
            p.updateVisual(v, f, d._api, h);
          }), wi.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(h) {
          on.update.call(this, h);
        }
      };
      function i(h, d, f, v, p) {
        if (h._disposed) {
          Be(h.id);
          return;
        }
        for (var g = h._model, m = h._coordSysMgr.getCoordinateSystems(), _, y = Rh(g, f), b = 0; b < m.length; b++) {
          var w = m[b];
          if (w[d] && (_ = w[d](g, y, v, p)) != null)
            return _;
        }
        process.env.NODE_ENV !== "production" && ui("No coordinate system that supports " + d + " found by the given finder.");
      }
      Ul = i, pd = function(h, d) {
        var f = h._chartsMap, v = h._scheduler;
        d.eachSeries(function(p) {
          v.updateStreamModes(p, f[p.__viewId]);
        });
      }, gd = function(h, d) {
        var f = this, v = this.getModel(), p = h.type, g = h.escapeConnect, m = tc[p], _ = (m.update || "update").split(":"), y = _.pop(), b = _[0] != null && Gi(_[0]);
        this[re] = !0, La(this);
        var w = [h], S = !1;
        h.batch && (S = !0, w = yt(h.batch, function(F) {
          return F = Jt(Y({}, F), h), F.batch = null, F;
        }));
        var M = [], k, T = [], C = m.nonRefinedEventType, D = _f(h), P = P0(h);
        if (P && tx(this._api), A(w, function(F) {
          var q = m.action(F, v, f._api);
          if (m.refineEvent ? T.push(q) : k = q, k = k || Y({}, F), k.type = C, M.push(k), P) {
            var V = Cv(h), B = V.queryOptionMap, $ = V.mainTypeSpecified, j = $ ? B.keys()[0] : "series";
            Wl(f, y, F, j), ni(f);
          } else D ? (Wl(f, y, F, "series"), ni(f)) : b && Wl(f, y, F, b.main, b.sub);
        }), y !== "none" && !P && !D && !b)
          try {
            this[ve] ? (Lr(this), on.update.call(this, h), this[ve] = null) : on[y].call(this, h);
          } catch (F) {
            throw this[re] = !1, F;
          }
        if (S ? k = {
          type: C,
          escapeConnect: g,
          batch: M
        } : k = M[0], this[re] = !1, !d) {
          var O = void 0;
          if (m.refineEvent) {
            var I = m.refineEvent(T, h, v, this._api).eventContent;
            it(Q(I)), O = Jt({
              type: m.refinedEventType
            }, I), O.fromAction = h.type, O.fromActionPayload = h, O.escapeConnect = !0;
          }
          var N = this._messageCenter;
          N.trigger(k.type, k), O && N.trigger(O.type, O);
        }
      }, Pa = function(h) {
        for (var d = this._pendingActions; d.length; ) {
          var f = d.shift();
          gd.call(this, f, h);
        }
      }, Ea = function(h) {
        !h && this.trigger("updated");
      }, G_ = function(h, d) {
        h.on("rendered", function(f) {
          d.trigger("rendered", f), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !d[ve] && !d._scheduler.unfinished && !d._pendingActions.length && d.trigger("finished");
        });
      }, X_ = function(h, d) {
        h.on("mouseover", function(f) {
          var v = f.target, p = no(v, us);
          p && (nI(p, f, d._api), ni(d));
        }).on("mouseout", function(f) {
          var v = f.target, p = no(v, us);
          p && (rI(p, f, d._api), ni(d));
        }).on("click", function(f) {
          var v = f.target, p = no(v, function(_) {
            return zt(_).dataIndex != null;
          }, !0);
          if (p) {
            var g = p.selected ? "unselect" : "select", m = zt(p);
            d._api.dispatchAction({
              type: g,
              dataType: m.dataType,
              dataIndexInside: m.dataIndex,
              seriesIndex: m.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function n(h) {
        h.clearColorPalette(), h.eachSeries(function(d) {
          d.clearColorPalette();
        });
      }
      function r(h) {
        var d = [], f = [], v = !1;
        if (h.eachComponent(function(_, y) {
          var b = y.get("zlevel") || 0, w = y.get("z") || 0, S = y.getZLevelKey();
          v = v || !!S, (_ === "series" ? f : d).push({
            zlevel: b,
            z: w,
            idx: y.componentIndex,
            type: _,
            key: S
          });
        }), v) {
          var p = d.concat(f), g, m;
          iu(p, function(_, y) {
            return _.zlevel === y.zlevel ? _.z - y.z : _.zlevel - y.zlevel;
          }), A(p, function(_) {
            var y = h.getComponent(_.type, _.idx), b = _.zlevel, w = _.key;
            g != null && (b = Math.max(g, b)), w ? (b === g && w !== m && b++, m = w) : m && (b === g && b++, m = ""), g = b, y.setZLevel(b);
          });
        }
      }
      md = function(h, d, f, v, p) {
        r(d), j_(h, d, f, v, p), A(h._chartsViews, function(g) {
          g.__alive = !1;
        }), Gl(h, d, f, v, p), A(h._chartsViews, function(g) {
          g.__alive || g.remove(d, f);
        });
      }, j_ = function(h, d, f, v, p, g) {
        A(g || h._componentsViews, function(m) {
          var _ = m.__model;
          u(_, m), m.render(_, d, f, v), l(_, m), c(_, m);
        });
      }, Gl = function(h, d, f, v, p, g) {
        var m = h._scheduler;
        p = Y(p || {}, {
          updatedSeries: d.getSeries()
        }), wi.trigger("series:beforeupdate", d, f, p);
        var _ = !1;
        d.eachSeries(function(y) {
          var b = h._chartsMap[y.__viewId];
          b.__alive = !0;
          var w = b.renderTask;
          m.updatePayload(w, v), u(y, b), g && g.get(y.uid) && w.dirty(), w.perform(m.getPerformArgs(w)) && (_ = !0), b.group.silent = !!y.get("silent"), o(y, b), D0(y);
        }), m.unfinished = _ || m.unfinished, wi.trigger("series:layoutlabels", d, f, p), wi.trigger("series:transition", d, f, p), d.eachSeries(function(y) {
          var b = h._chartsMap[y.__viewId];
          l(y, b), c(y, b);
        }), s(h, d), wi.trigger("series:afterupdate", d, f, p);
      }, ni = function(h) {
        h[dd] = !0, h.getZr().wakeUp();
      }, La = function(h) {
        h[Yl] = (h[Yl] + 1) % 1e3;
      }, Z_ = function(h) {
        h[dd] && (h.getZr().storage.traverse(function(d) {
          mo(d) || a(d);
        }), h[dd] = !1);
      };
      function a(h) {
        for (var d = [], f = h.currentStates, v = 0; v < f.length; v++) {
          var p = f[v];
          p === "emphasis" || p === "blur" || p === "select" || d.push(p);
        }
        h.selected && h.states.select && d.push("select"), h.hoverState === Iv && h.states.emphasis ? d.push("emphasis") : h.hoverState === Ov && h.states.blur && d.push("blur"), h.useStates(d);
      }
      function s(h, d) {
        var f = h._zr, v = f.storage, p = 0;
        v.traverse(function(g) {
          g.isGroup || p++;
        }), p > d.get("hoverLayerThreshold") && !st.node && !st.worker && d.eachSeries(function(g) {
          if (!g.preventUsingHoverLayer) {
            var m = h._chartsMap[g.__viewId];
            m.__alive && m.eachRendered(function(_) {
              _.states.emphasis && (_.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(h, d) {
        var f = h.get("blendMode") || null;
        d.eachRendered(function(v) {
          v.isGroup || (v.style.blend = f);
        });
      }
      function l(h, d) {
        if (!h.preventAutoZ) {
          var f = Ro(h);
          d.eachRendered(function(v) {
            return _x(v, f.z, f.zlevel), !0;
          });
        }
      }
      function u(h, d) {
        d.eachRendered(function(f) {
          if (!mo(f)) {
            var v = f.getTextContent(), p = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), p && p.stateTransition && (p.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(h, d) {
        var f = h.getModel("stateAnimation"), v = h.isAnimationEnabled(), p = f.get("duration"), g = p > 0 ? {
          duration: p,
          delay: f.get("delay"),
          easing: f.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        d.eachRendered(function(m) {
          if (m.states && m.states.emphasis) {
            if (mo(m))
              return;
            if (m instanceof Bt && dI(m), m.__dirty) {
              var _ = m.prevStates;
              _ && m.useStates(_);
            }
            if (v) {
              m.stateTransition = g;
              var y = m.getTextContent(), b = m.getTextGuideLine();
              y && (y.stateTransition = g), b && (b.stateTransition = g);
            }
            m.__dirty && a(m);
          }
        });
      }
      q_ = function(h) {
        return new /** @class */
        ((function(d) {
          oe(f, d);
          function f() {
            return d !== null && d.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(v) {
            for (; v; ) {
              var p = v.__ecComponentInfo;
              if (p != null)
                return h._model.getComponent(p.mainType, p.index);
              v = v.parent;
            }
          }, f.prototype.enterEmphasis = function(v, p) {
            Vu(v, p), ni(h);
          }, f.prototype.leaveEmphasis = function(v, p) {
            Hu(v, p), ni(h);
          }, f.prototype.enterBlur = function(v) {
            eI(v), ni(h);
          }, f.prototype.leaveBlur = function(v) {
            Z1(v), ni(h);
          }, f.prototype.enterSelect = function(v) {
            K1(v), ni(h);
          }, f.prototype.leaveSelect = function(v) {
            Q1(v), ni(h);
          }, f.prototype.getModel = function() {
            return h.getModel();
          }, f.prototype.getViewOfComponentModel = function(v) {
            return h.getViewOfComponentModel(v);
          }, f.prototype.getViewOfSeriesModel = function(v) {
            return h.getViewOfSeriesModel(v);
          }, f.prototype.getMainProcessVersion = function() {
            return h[Yl];
          }, f;
        })(Fx))(h);
      }, Tw = function(h) {
        function d(f, v) {
          for (var p = 0; p < f.length; p++) {
            var g = f[p];
            g[fd] = v;
          }
        }
        A(ec, function(f, v) {
          h._messageCenter.on(v, function(p) {
            if (K_[h.group] && h[fd] !== U_) {
              if (p && p.escapeConnect)
                return;
              var g = h.makeActionFromEvent(p), m = [];
              A(yo, function(_) {
                _ !== h && _.group === h.group && m.push(_);
              }), d(m, U_), A(m, function(_) {
                _[fd] !== MF && _.dispatchAction(g);
              }), d(m, kF);
            }
          });
        });
      };
    })(), t;
  })(Pi)
), lp = Cw.prototype;
lp.on = ww("on");
lp.off = ww("off");
lp.one = function(e, t, i) {
  var n = this;
  Dn("ECharts#one is deprecated.");
  function r() {
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    t && t.apply && t.apply(this, a), n.off(e, r);
  }
  this.on.call(this, e, r, i);
};
var DF = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function Be(e) {
  process.env.NODE_ENV !== "production" && ui("Instance " + e + " has been disposed");
}
var tc = {}, ec = {}, Rf = {}, Nf = [], Ff = [], ic = [], Aw = {}, Bf = {}, yo = {}, K_ = {}, TF = +/* @__PURE__ */ new Date() - 0, up = "_echarts_instance_";
function CF(e, t, i) {
  {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var n = AF(e);
    if (n)
      return process.env.NODE_ENV !== "production" && ui("There is a chart instance already initialized on the dom."), n;
    process.env.NODE_ENV !== "production" && rs(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && !i || !e.clientHeight && !i) && ui("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var r = new Cw(e, t, i);
  return r.id = "ec_" + TF++, yo[r.id] = r, O1(e, up, r.id), Tw(r), wi.trigger("afterinit", r), r;
}
function AF(e) {
  return yo[YL(e, up)];
}
function Pw(e, t) {
  Aw[e] = t;
}
function Ew(e) {
  Vt(Ff, e) < 0 && Ff.push(e);
}
function Lw(e, t) {
  hp(Nf, e, t, gF);
}
function PF(e) {
  cp("afterinit", e);
}
function EF(e) {
  cp("afterupdate", e);
}
function cp(e, t) {
  wi.on(e, t);
}
function ha(e, t, i) {
  var n, r, a, s, o;
  mt(t) && (i = t, t = ""), Q(e) ? (n = e.type, r = e.event, s = e.update, o = e.publishNonRefinedEvent, i || (i = e.action), a = e.refineEvent) : (n = e, r = t);
  function l(c) {
    return c.toLowerCase();
  }
  r = l(r || n);
  var u = a ? l(n) : r;
  tc[n] || (it(W_.test(n) && W_.test(r)), a && it(r !== n), tc[n] = {
    actionType: n,
    refinedEventType: r,
    nonRefinedEventType: u,
    update: s,
    action: i,
    refineEvent: a
  }, Rf[r] = 1, a && o && (Rf[u] = 1), process.env.NODE_ENV !== "production" && ec[u] && Kt(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), ec[u] = n);
}
function LF(e, t) {
  Nc.register(e, t);
}
function OF(e, t) {
  hp(ic, e, t, yw, "layout");
}
function da(e, t) {
  hp(ic, e, t, bw, "visual");
}
var Q_ = [];
function hp(e, t, i, n, r) {
  if ((mt(t) || Q(t)) && (i = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    A(e, function(s) {
      it(s.__raw !== i);
    });
  }
  if (!(Vt(Q_, i) >= 0)) {
    Q_.push(i);
    var a = sw.wrapStageHandler(i, r);
    a.__prio = t, a.__raw = i, e.push(a);
  }
}
function Ow(e, t) {
  Bf[e] = t;
}
function IF(e, t, i) {
  var n = hF("registerMap");
  n && n(e, t, i);
}
var RF = $5;
da(op, gN);
da($c, mN);
da($c, _N);
da(op, EN);
da($c, LN);
da(xw, uF);
Ew($x);
Lw(vF, b5);
Ow("default", yN);
ha({
  type: ea,
  event: ea,
  update: ea
}, ke);
ha({
  type: ou,
  event: ou,
  update: ou
}, ke);
ha({
  type: $u,
  event: Rv,
  update: $u,
  action: ke,
  refineEvent: dp,
  publishNonRefinedEvent: !0
});
ha({
  type: pf,
  event: Rv,
  update: pf,
  action: ke,
  refineEvent: dp,
  publishNonRefinedEvent: !0
});
ha({
  type: zu,
  event: Rv,
  update: zu,
  action: ke,
  refineEvent: dp,
  publishNonRefinedEvent: !0
});
function dp(e, t, i, n) {
  return {
    eventContent: {
      selected: sI(i),
      isFromClick: t.isFromClick || !1
    }
  };
}
Pw("default", {});
Pw("dark", cw);
function Rs(e) {
  return e == null ? 0 : e.length || 1;
}
function J_(e) {
  return e;
}
var NF = (
  /** @class */
  (function() {
    function e(t, i, n, r, a, s) {
      this._old = t, this._new = i, this._oldKeyGetter = n || J_, this._newKeyGetter = r || J_, this.context = a, this._diffModeMultiple = s === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, i = this._new, n = {}, r = new Array(t.length), a = new Array(i.length);
      this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(i, n, a, "_newKeyGetter");
      for (var s = 0; s < t.length; s++) {
        var o = r[s], l = n[o], u = Rs(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[o] = l[0]), this._update && this._update(c, s);
        } else u === 1 ? (n[o] = null, this._update && this._update(l, s)) : this._remove && this._remove(s);
      }
      this._performRestAdd(a, n);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, i = this._new, n = {}, r = {}, a = [], s = [];
      this._initIndexMap(t, n, a, "_oldKeyGetter"), this._initIndexMap(i, r, s, "_newKeyGetter");
      for (var o = 0; o < a.length; o++) {
        var l = a[o], u = n[l], c = r[l], h = Rs(u), d = Rs(c);
        if (h > 1 && d === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), r[l] = null;
        else if (h === 1 && d > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), r[l] = null;
        else if (h === 1 && d === 1)
          this._update && this._update(c, u), r[l] = null;
        else if (h > 1 && d > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), r[l] = null;
        else if (h > 1)
          for (var f = 0; f < h; f++)
            this._remove && this._remove(u[f]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(s, r);
    }, e.prototype._performRestAdd = function(t, i) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n], a = i[r], s = Rs(a);
        if (s > 1)
          for (var o = 0; o < s; o++)
            this._add && this._add(a[o]);
        else s === 1 && this._add && this._add(a);
        i[r] = null;
      }
    }, e.prototype._initIndexMap = function(t, i, n, r) {
      for (var a = this._diffModeMultiple, s = 0; s < t.length; s++) {
        var o = "_ec_" + this[r](t[s], s);
        if (a || (n[s] = o), !!i) {
          var l = i[o], u = Rs(l);
          u === 0 ? (i[o] = s, a && n.push(o)) : u === 1 ? i[o] = [l, s] : l.push(s);
        }
      }
    }, e;
  })()
), FF = (
  /** @class */
  (function() {
    function e(t, i) {
      this._encode = t, this._schema = i;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  })()
);
function BF(e, t) {
  var i = {}, n = i.encode = {}, r = ct(), a = [], s = [], o = {};
  A(e.dimensions, function(d) {
    var f = e.getDimensionInfo(d), v = f.coordDim;
    if (v) {
      process.env.NODE_ENV !== "production" && it(Mf.get(v) == null);
      var p = f.coordDimIndex;
      _d(n, v)[p] = d, f.isExtraCoord || (r.set(v, 1), zF(f.type) && (a[0] = d), _d(o, v)[p] = e.getDimensionIndex(f.name)), f.defaultTooltip && s.push(d);
    }
    Mf.each(function(g, m) {
      var _ = _d(n, m), y = f.otherDims[m];
      y != null && y !== !1 && (_[y] = f.name);
    });
  });
  var l = [], u = {};
  r.each(function(d, f) {
    var v = n[f];
    u[f] = v[0], l = l.concat(v);
  }), i.dataDimsOnCoord = l, i.dataDimIndicesOnCoord = yt(l, function(d) {
    return e.getDimensionInfo(d).storeDimIndex;
  }), i.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (a = c.slice());
  var h = n.tooltip;
  return h && h.length ? s = h.slice() : s.length || (s = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = s, i.userOutput = new FF(o, t), i;
}
function _d(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function $F(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function zF(e) {
  return !(e === "ordinal" || e === "time");
}
var hu = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.otherDims = {}, t != null && Y(this, t);
    }
    return e;
  })()
), VF = Gt(), HF = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, Iw = (
  /** @class */
  (function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = Fw(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return nt(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var i = this.source.dimensionsDefine;
      if (i)
        return i[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, i = Vx(this.source), n = !Bw(t), r = "", a = [], s = 0, o = 0; s < t; s++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[o];
        if (h && h.storeDimIndex === s)
          l = i ? h.name : null, u = h.type, c = h.ordinalMeta, o++;
        else {
          var d = this.getSourceDimension(s);
          d && (l = i ? d.name : null, u = d.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), i && l != null && (!h || !h.isCalculationCoord) && (r += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += HF[u] || "f", c && (r += c.uid), r += "$";
      }
      var f = this.source, v = [f.seriesLayoutBy, f.startIndex, r].join("$$");
      return {
        dimensions: a,
        hash: v
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], i = 0, n = 0; i < this._fullDimCount; i++) {
        var r = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === i)
          a.isCalculationCoord || (r = a.name), n++;
        else {
          var s = this.getSourceDimension(i);
          s && (r = s.name);
        }
        t.push(r);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  })()
);
function Rw(e) {
  return e instanceof Iw;
}
function Nw(e) {
  for (var t = ct(), i = 0; i < (e || []).length; i++) {
    var n = e[i], r = Q(n) ? n.name : n;
    r != null && t.get(r) == null && t.set(r, i);
  }
  return t;
}
function Fw(e) {
  var t = VF(e);
  return t.dimNameMap || (t.dimNameMap = Nw(e.dimensionsDefine));
}
function Bw(e) {
  return e > 30;
}
var Ns = Q, Fn = yt, YF = typeof Int32Array > "u" ? Array : Int32Array, WF = "e\0\0", ty = -1, UF = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], GF = ["_approximateExtent"], ey, Xl, Fs, Oa, yd, Bs, bd, $f = (
  /** @class */
  (function() {
    function e(t, i) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var n, r = !1;
      Rw(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = !0, n = t), n = n || ["x", "y"];
      for (var a = {}, s = [], o = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var h = n[c], d = tt(h) ? new hu({
          name: h
        }) : h instanceof hu ? h : new hu(h), f = d.name;
        d.type = d.type || "float", d.coordDim || (d.coordDim = f, d.coordDimIndex = 0);
        var v = d.otherDims = d.otherDims || {};
        s.push(f), a[f] = d, u[f] != null && (l = !0), d.createInvertedIndices && (o[f] = []);
        var p = c;
        Zt(d.storeDimIndex) && (p = d.storeDimIndex), v.itemName === 0 && (this._nameDimIdx = p), v.itemId === 0 && (this._idDimIdx = p), process.env.NODE_ENV !== "production" && it(r || d.storeDimIndex >= 0), r && (d.storeDimIndex = c);
      }
      if (this.dimensions = s, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = i, this._invertedIndicesMap = o, this._dimOmitted) {
        var g = this._dimIdxToName = ct();
        A(s, function(m) {
          g.set(a[m].storeDimIndex, m);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i == null)
        return t;
      if (i = t, !this._dimOmitted)
        return this.dimensions[i];
      var n = this._dimIdxToName.get(i);
      if (n != null)
        return n;
      var r = this._schema.getSourceDimension(i);
      if (r)
        return r.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i != null)
        return i;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if (Zt(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var i = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && i == null)
        throw new Error("Unknown dimension " + t);
      return i;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var i = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return i.hasOwnProperty(n) ? i[n] : void 0;
      } : function(n) {
        return i[n];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, i) {
      var n = this._dimSummary;
      if (i == null)
        return n.encodeFirstDimNotExtra[t];
      var r = n.encode[t];
      return r ? r[i] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var i = this._dimSummary, n = i.encode[t];
      return (n || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, i, n) {
      var r = this, a;
      if (t instanceof Df && (a = t), !a) {
        var s = this.dimensions, o = rp(t) || Ge(t) ? new Hx(t, s.length) : t;
        a = new Df();
        var l = Fn(s, function(u) {
          return {
            type: r._dimInfos[u].type,
            property: u
          };
        });
        a.initData(o, l, n);
      }
      this._store = a, this._nameList = (i || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = BF(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var i = this._store.appendData(t);
      this._doInit(i[0], i[1]);
    }, e.prototype.appendValues = function(t, i) {
      var n = this._store.appendValues(t, i && i.length), r = n.start, a = n.end, s = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), i)
        for (var o = r; o < a; o++) {
          var l = o - r;
          this._nameList[o] = i[l], s && bd(this, o);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, i = this.dimensions, n = 0; n < i.length; n++) {
        var r = this._dimInfos[i[n]];
        r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== wn && !t.fillStorage;
    }, e.prototype._doInit = function(t, i) {
      if (!(t >= i)) {
        var n = this._store, r = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, s = this._idList, o = r.getSource().sourceFormat, l = o === Je;
        if (l && !r.pure)
          for (var u = [], c = t; c < i; c++) {
            var h = r.getItem(c, u);
            if (!this.hasItemOption && LL(h) && (this.hasItemOption = !0), h) {
              var d = h.name;
              a[c] == null && d != null && (a[c] = ki(d, null));
              var f = h.id;
              s[c] == null && f != null && (s[c] = ki(f, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < i; c++)
            bd(this, c);
        ey(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, i) {
      i = this.getDimension(i), this._approximateExtent[i] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, i) {
      Ns(t) ? Y(this._calculationInfo, t) : this._calculationInfo[t] = i;
    }, e.prototype.getName = function(t) {
      var i = this.getRawIndex(t), n = this._nameList[i];
      return n == null && this._nameDimIdx != null && (n = Fs(this, this._nameDimIdx, i)), n == null && (n = ""), n;
    }, e.prototype._getCategory = function(t, i) {
      var n = this._store.get(t, i), r = this._store.getOrdinalMeta(t);
      return r ? r.categories[n] : n;
    }, e.prototype.getId = function(t) {
      return Xl(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.get(r.storeDimIndex, i);
    }, e.prototype.getByRawIndex = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.getByRawIndex(r.storeDimIndex, i);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, i) {
      var n = this, r = this._store;
      return Z(t) ? r.getValues(Fn(t, function(a) {
        return n._getStoreDimIndex(a);
      }), i) : r.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var i = this._dimSummary.dataDimIndicesOnCoord, n = 0, r = i.length; n < r; n++)
        if (isNaN(this._store.get(i[n], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var i = 0, n = this._store.count(); i < n; i++)
        if (this.getName(i) === t)
          return i;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, i) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var r = n && n[i];
      return r == null || isNaN(r) ? ty : r;
    }, e.prototype.each = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []);
      var r = n || this, a = Fn(Oa(t), this._getStoreDimIndex, this);
      this._store.each(a, r ? Dt(i, r) : i);
    }, e.prototype.filterSelf = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []);
      var r = n || this, a = Fn(Oa(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, r ? Dt(i, r) : i), this;
    }, e.prototype.selectRange = function(t) {
      var i = this, n = {}, r = qt(t);
      return A(r, function(a) {
        var s = i._getStoreDimIndex(a);
        n[s] = t[a];
      }), this._store = this._store.selectRange(n), this;
    }, e.prototype.mapArray = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []), n = n || this;
      var r = [];
      return this.each(t, function() {
        r.push(i && i.apply(this, arguments));
      }, n), r;
    }, e.prototype.map = function(t, i, n, r) {
      var a = n || r || this, s = Fn(Oa(t), this._getStoreDimIndex, this), o = Bs(this);
      return o._store = this._store.map(s, a ? Dt(i, a) : i), o;
    }, e.prototype.modify = function(t, i, n, r) {
      var a = this, s = n || r || this;
      process.env.NODE_ENV !== "production" && A(Oa(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var o = Fn(Oa(t), this._getStoreDimIndex, this);
      this._store.modify(o, s ? Dt(i, s) : i);
    }, e.prototype.downSample = function(t, i, n, r) {
      var a = Bs(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), i, n, r), a;
    }, e.prototype.minmaxDownSample = function(t, i) {
      var n = Bs(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = Bs(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var i = this.hostModel, n = this.getRawDataItem(t);
      return new jt(n, i, i && i.ecModel);
    }, e.prototype.diff = function(t) {
      var i = this;
      return new NF(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return Xl(t, n);
      }, function(n) {
        return Xl(i, n);
      });
    }, e.prototype.getVisual = function(t) {
      var i = this._visual;
      return i && i[t];
    }, e.prototype.setVisual = function(t, i) {
      this._visual = this._visual || {}, Ns(t) ? Y(this._visual, t) : this._visual[t] = i;
    }, e.prototype.getItemVisual = function(t, i) {
      var n = this._itemVisuals[t], r = n && n[i];
      return r ?? this.getVisual(i);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, i) {
      var n = this._itemVisuals, r = n[t];
      r || (r = n[t] = {});
      var a = r[i];
      return a == null && (a = this.getVisual(i), Z(a) ? a = a.slice() : Ns(a) && (a = Y({}, a)), r[i] = a), a;
    }, e.prototype.setItemVisual = function(t, i, n) {
      var r = this._itemVisuals[t] || {};
      this._itemVisuals[t] = r, Ns(i) ? Y(r, i) : r[i] = n;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, i) {
      Ns(t) ? Y(this._layout, t) : this._layout[t] = i;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, i, n) {
      this._itemLayouts[t] = n ? Y(this._itemLayouts[t] || {}, i) : i;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, i) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      UO(n, this.dataType, t, i), this._graphicEls[t] = i;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, i) {
      A(this._graphicEls, function(n, r) {
        n && t && t.call(i, n, r);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : Fn(this.dimensions, this._getDimInfo, this), this.hostModel)), yd(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, i) {
      var n = this[t];
      mt(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var r = n.apply(this, arguments);
        return i.apply(this, [r].concat(xv(arguments)));
      });
    }, e.internalField = (function() {
      ey = function(t) {
        var i = t._invertedIndicesMap;
        A(i, function(n, r) {
          var a = t._dimInfos[r], s = a.ordinalMeta, o = t._store;
          if (s) {
            n = i[r] = new YF(s.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = ty;
            for (var l = 0; l < o.count(); l++)
              n[o.get(a.storeDimIndex, l)] = l;
          }
        });
      }, Fs = function(t, i, n) {
        return ki(t._getCategory(i, n), null);
      }, Xl = function(t, i) {
        var n = t._idList[i];
        return n == null && t._idDimIdx != null && (n = Fs(t, t._idDimIdx, i)), n == null && (n = WF + i), n;
      }, Oa = function(t) {
        return Z(t) || (t = t != null ? [t] : []), t;
      }, Bs = function(t) {
        var i = new e(t._schema ? t._schema : Fn(t.dimensions, t._getDimInfo, t), t.hostModel);
        return yd(i, t), i;
      }, yd = function(t, i) {
        A(UF.concat(i.__wrappedMethods || []), function(n) {
          i.hasOwnProperty(n) && (t[n] = i[n]);
        }), t.__wrappedMethods = i.__wrappedMethods, A(GF, function(n) {
          t[n] = pt(i[n]);
        }), t._calculationInfo = Y({}, i._calculationInfo);
      }, bd = function(t, i) {
        var n = t._nameList, r = t._idList, a = t._nameDimIdx, s = t._idDimIdx, o = n[i], l = r[i];
        if (o == null && a != null && (n[i] = o = Fs(t, a, i)), l == null && s != null && (r[i] = l = Fs(t, s, i)), l == null && o != null) {
          var u = t._nameRepeatCount, c = u[o] = (u[o] || 0) + 1;
          l = o, c > 1 && (l += "__ec__" + c), r[i] = l;
        }
      };
    })(), e;
  })()
);
function $w(e, t) {
  rp(e) || (e = ap(e)), t = t || {};
  var i = t.coordDimensions || [], n = t.dimensionsDefine || e.dimensionsDefine || [], r = ct(), a = [], s = jF(e, i, n, t.dimensionsCount), o = t.canOmitUnusedDimensions && Bw(s), l = n === e.dimensionsDefine, u = l ? Fw(e) : Nw(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, s));
  for (var h = ct(c), d = new Xx(s), f = 0; f < d.length; f++)
    d[f] = -1;
  function v(T) {
    var C = d[T];
    if (C < 0) {
      var D = n[T], P = Q(D) ? D : {
        name: D
      }, O = new hu(), I = P.name;
      I != null && u.get(I) != null && (O.name = O.displayName = I), P.type != null && (O.type = P.type), P.displayName != null && (O.displayName = P.displayName);
      var N = a.length;
      return d[T] = N, O.storeDimIndex = T, a.push(O), O;
    }
    return a[C];
  }
  if (!o)
    for (var f = 0; f < s; f++)
      v(f);
  h.each(function(T, C) {
    var D = Ie(T).slice();
    if (D.length === 1 && !tt(D[0]) && D[0] < 0) {
      h.set(C, !1);
      return;
    }
    var P = h.set(C, []);
    A(D, function(O, I) {
      var N = tt(O) ? u.get(O) : O;
      N != null && N < s && (P[I] = N, g(v(N), C, I));
    });
  });
  var p = 0;
  A(i, function(T) {
    var C, D, P, O;
    if (tt(T))
      C = T, O = {};
    else {
      O = T, C = O.name;
      var I = O.ordinalMeta;
      O.ordinalMeta = null, O = Y({}, O), O.ordinalMeta = I, D = O.dimsDef, P = O.otherDims, O.name = O.coordDim = O.coordDimIndex = O.dimsDef = O.otherDims = null;
    }
    var N = h.get(C);
    if (N !== !1) {
      if (N = Ie(N), !N.length)
        for (var F = 0; F < (D && D.length || 1); F++) {
          for (; p < s && v(p).coordDim != null; )
            p++;
          p < s && N.push(p++);
        }
      A(N, function(q, V) {
        var B = v(q);
        if (l && O.type != null && (B.type = O.type), g(Jt(B, O), C, V), B.name == null && D) {
          var $ = D[V];
          !Q($) && ($ = {
            name: $
          }), B.name = B.displayName = $.name, B.defaultTooltip = $.defaultTooltip;
        }
        P && Jt(B.otherDims, P);
      });
    }
  });
  function g(T, C, D) {
    Mf.get(C) != null ? T.otherDims[C] = D : (T.coordDim = C, T.coordDimIndex = D, r.set(C, !0));
  }
  var m = t.generateCoord, _ = t.generateCoordCount, y = _ != null;
  _ = m ? _ || 1 : 0;
  var b = m || "value";
  function w(T) {
    T.name == null && (T.name = T.coordDim);
  }
  if (o)
    A(a, function(T) {
      w(T);
    }), a.sort(function(T, C) {
      return T.storeDimIndex - C.storeDimIndex;
    });
  else
    for (var S = 0; S < s; S++) {
      var M = v(S), k = M.coordDim;
      k == null && (M.coordDim = qF(b, r, y), M.coordDimIndex = 0, (!m || _ <= 0) && (M.isExtraCoord = !0), _--), w(M), M.type == null && (Nx(e, S) === Xe.Must || M.isExtraCoord && (M.otherDims.itemName != null || M.otherDims.seriesName != null)) && (M.type = "ordinal");
    }
  return XF(a), new Iw({
    source: e,
    dimensions: a,
    fullDimensionCount: s,
    dimensionOmitted: o
  });
}
function XF(e) {
  for (var t = ct(), i = 0; i < e.length; i++) {
    var n = e[i], r = n.name, a = t.get(r) || 0;
    a > 0 && (n.name = r + (a - 1)), a++, t.set(r, a);
  }
}
function jF(e, t, i, n) {
  var r = Math.max(e.dimensionsDetectedCount || 1, t.length, i.length, n || 0);
  return A(t, function(a) {
    var s;
    Q(a) && (s = a.dimsDef) && (r = Math.max(r, s.length));
  }), r;
}
function qF(e, t, i) {
  if (i || t.hasKey(e)) {
    for (var n = 0; t.hasKey(e + n); )
      n++;
    e += n;
  }
  return t.set(e, !0), e;
}
var ZF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = ct(), this.categoryAxisMap = ct(), this.coordSysName = t;
    }
    return e;
  })()
);
function KF(e) {
  var t = e.get("coordinateSystem"), i = new ZF(t), n = QF[t];
  if (n)
    return n(e, i, i.axisMap, i.categoryAxisMap), i;
}
var QF = {
  cartesian2d: function(e, t, i, n) {
    var r = e.getReferringComponents("xAxis", zn).models[0], a = e.getReferringComponents("yAxis", zn).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error('xAxis "' + ir(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + ir(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], i.set("x", r), i.set("y", a), Ia(r) && (n.set("x", r), t.firstCategoryDimIndex = 0), Ia(a) && (n.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, i, n) {
    var r = e.getReferringComponents("singleAxis", zn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], i.set("single", r), Ia(r) && (n.set("single", r), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, i, n) {
    var r = e.getReferringComponents("polar", zn).models[0], a = r.findAxisModel("radiusAxis"), s = r.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!s)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", s), Ia(a) && (n.set("radius", a), t.firstCategoryDimIndex = 0), Ia(s) && (n.set("angle", s), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, i, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, i, n) {
    var r = e.ecModel, a = r.getComponent("parallel", e.get("parallelIndex")), s = t.coordSysDims = a.dimensions.slice();
    A(a.parallelAxisIndex, function(o, l) {
      var u = r.getComponent("parallelAxis", o), c = s[l];
      i.set(c, u), Ia(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(e, t, i, n) {
    var r = e.getReferringComponents("matrix", zn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = r.getDimensionModel("x"), s = r.getDimensionModel("y");
    i.set("x", a), i.set("y", s), n.set("x", a), n.set("y", s);
  }
};
function Ia(e) {
  return e.get("type") === "category";
}
function JF(e, t, i) {
  i = i || {};
  var n = i.byIndex, r = i.stackedCoordDimension, a, s, o;
  tB(t) ? a = t : (s = t.schema, a = s.dimensions, o = t.store);
  var l = !!(e && e.get("stack")), u, c, h, d;
  if (A(a, function(_, y) {
    tt(_) && (a[y] = _ = {
      name: _
    }), l && !_.isExtraCoord && (!n && !u && _.ordinalMeta && (u = _), !c && _.type !== "ordinal" && _.type !== "time" && (!r || r === _.coordDim) && (c = _));
  }), c && !n && !u && (n = !0), c) {
    h = "__\0ecstackresult_" + e.id, d = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var f = c.coordDim, v = c.type, p = 0;
    A(a, function(_) {
      _.coordDim === f && p++;
    });
    var g = {
      name: h,
      coordDim: f,
      coordDimIndex: p,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, m = {
      name: d,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: d,
      coordDimIndex: p + 1,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    s ? (o && (g.storeDimIndex = o.ensureCalculationDimension(d, v), m.storeDimIndex = o.ensureCalculationDimension(h, v)), s.appendCalculationDimension(g), s.appendCalculationDimension(m)) : (a.push(g), a.push(m));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: d,
    stackResultDimension: h
  };
}
function tB(e) {
  return !Rw(e.schema);
}
function eB(e, t) {
  var i = e.get("coordinateSystem"), n = Nc.get(i), r;
  return t && t.coordSysDims && (r = yt(t.coordSysDims, function(a) {
    var s = {
      name: a
    }, o = t.axisMap.get(a);
    if (o) {
      var l = o.get("type");
      s.type = $F(l);
    }
    return s;
  })), r || (r = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), r;
}
function iB(e, t, i) {
  var n, r;
  return i && A(e, function(a, s) {
    var o = a.coordDim, l = i.categoryAxisMap.get(o);
    l && (n == null && (n = s), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (r = !0);
  }), !r && n != null && (e[n].otherDims.itemName = 0), n;
}
function nB(e, t, i) {
  i = i || {};
  var n = t.getSourceManager(), r, a = !1;
  e ? (a = !0, r = ap(e)) : (r = n.getSource(), a = r.sourceFormat === Je);
  var s = KF(t), o = eB(t, s), l = i.useEncodeDefaulter, u = mt(l) ? l : l ? Oe(XR, o, t) : null, c = {
    coordDimensions: o,
    generateCoord: i.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, h = $w(r, c), d = iB(h.dimensions, i.createInvertedIndices, s), f = a ? null : n.getSharedDataStore(h), v = JF(t, {
    schema: h,
    store: f
  }), p = new $f(h, t);
  p.setCalculationInfo(v);
  var g = d != null && rB(r) ? function(m, _, y, b) {
    return b === d ? y : this.defaultDimValueGetter(m, _, y, b);
  } : null;
  return p.hasItemOption = !1, p.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? r : f,
    null,
    g
  ), p;
}
function rB(e) {
  if (e.sourceFormat === Je) {
    var t = aB(e.data || []);
    return !Z(jo(t));
  }
}
function aB(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
function zw(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function sB(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function oB(e) {
  return e.type === "category" && sB(e.getLabelModel()) === 0;
}
function nc(e) {
  return e === "middle" || e === "center";
}
var iy = [], lB = {
  registerPreprocessor: Ew,
  registerProcessor: Lw,
  registerPostInit: PF,
  registerPostUpdate: EF,
  registerUpdateLifecycle: cp,
  registerAction: ha,
  registerCoordinateSystem: LF,
  registerLayout: OF,
  registerVisual: da,
  registerTransform: RF,
  registerLoading: Ow,
  registerMap: IF,
  registerImpl: cF,
  PRIORITY: SF,
  ComponentModel: Et,
  ComponentView: Tn,
  SeriesModel: rr,
  ChartView: Kn,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    Et.registerClass(e);
  },
  registerComponentView: function(e) {
    Tn.registerClass(e);
  },
  registerSeriesModel: function(e) {
    rr.registerClass(e);
  },
  registerChartView: function(e) {
    Kn.registerClass(e);
  },
  registerCustomSeries: function(e, t) {
  },
  registerSubTypeDefaulter: function(e, t) {
    Et.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    bL(e, t);
  }
};
function fp(e) {
  if (Z(e)) {
    A(e, function(t) {
      fp(t);
    });
    return;
  }
  Vt(iy, e) >= 0 || (iy.push(e), mt(e) && (e = {
    install: e
  }), e.install(lB));
}
Gt();
Gt();
var ny = {
  estimate: 1,
  determine: 2
};
function uB(e) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: e
  };
}
var ry = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], cB = 1, rc = 2, Vw = cB | rc;
function ac(e, t, i) {
  i = i || Vw, t ? e.dirty |= i : e.dirty &= ~i;
}
function Hw(e, t) {
  return t = t || Vw, e.dirty == null || !!(e.dirty & t);
}
function ar(e) {
  if (e)
    return Hw(e) && hB(e, e.label, e), e;
}
function hB(e, t, i) {
  var n = t.getComputedTransform();
  e.transform = Kv(e.transform, n);
  var r = e.localRect = Io(e.localRect, t.getBoundingRect()), a = t.style, s = a.margin, o = i && i.marginForce, l = i && i.minMarginForce, u = i && i.marginDefault, c = a.__marginType;
  c == null && u && (s = u, c = Wa.textMargin);
  for (var h = 0; h < 4; h++)
    xd[h] = c === Wa.minMargin && l && l[h] != null ? l[h] : o && o[h] != null ? o[h] : s ? s[h] : 0;
  c === Wa.textMargin && xf(r, xd, !1, !1);
  var d = e.rect = Io(e.rect, r);
  return n && d.applyTransform(n), c === Wa.minMargin && xf(d, xd, !1, !1), e.axisAligned = Zv(n), (e.label = e.label || {}).ignore = t.ignore, ac(e, !1), ac(e, !0, rc), e;
}
var xd = [0, 0, 0, 0];
function dB(e, t, i) {
  return e.transform = Kv(e.transform, i), e.localRect = Io(e.localRect, t), e.rect = Io(e.rect, t), i && e.rect.applyTransform(i), e.axisAligned = Zv(i), e.obb = void 0, (e.label = e.label || {}).ignore = !1, e;
}
function fB(e, t) {
  if (e) {
    e.label.x += t.x, e.label.y += t.y, e.label.markRedraw();
    var i = e.transform;
    i && (i[4] += t.x, i[5] += t.y);
    var n = e.rect;
    n && (n.x += t.x, n.y += t.y);
    var r = e.obb;
    r && r.fromBoundingRect(e.localRect, i);
  }
}
function ay(e, t) {
  for (var i = 0; i < ry.length; i++) {
    var n = ry[i];
    e[n] == null && (e[n] = t[n]);
  }
  return ar(e);
}
function sy(e) {
  var t = e.obb;
  return (!t || Hw(e, rc)) && (e.obb = t = t || new ux(), t.fromBoundingRect(e.localRect, e.transform), ac(e, !1, rc)), t;
}
function vB(e) {
  var t = [];
  e.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function i(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var n = 0; n < e.length; n++) {
    var r = ar(e[n]);
    if (!r.label.ignore) {
      for (var a = r.label, s = r.labelLine, o = !1, l = 0; l < t.length; l++)
        if (vp(r, t[l], null, {
          touchThreshold: 0.05
        })) {
          o = !0;
          break;
        }
      o ? (i(a), s && i(s)) : t.push(r);
    }
  }
}
function vp(e, t, i, n) {
  return !e || !t || e.label && e.label.ignore || t.label && t.label.ignore || !e.rect.intersect(t.rect, i, n) ? !1 : e.axisAligned && t.axisAligned ? !0 : sy(e).intersect(sy(t), i, n);
}
var pB = null;
function gB() {
  return pB;
}
var mB = "expandAxisBreak", Un = Math.PI, _B = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], yB = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], sc = Gt(), Yw = Gt(), bB = (
  /** @class */
  (function() {
    function e(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return e.prototype.ensureRecord = function(t) {
      var i = t.axis.dim, n = t.componentIndex, r = this.recordMap, a = r[i] || (r[i] = []);
      return a[n] || (a[n] = {
        ready: {}
      });
    }, e;
  })()
);
function xB(e, t, i, n) {
  var r = i.axis, a = t.ensureRecord(i), s = [], o, l = pp(e.axisName) && nc(e.nameLocation);
  A(n, function(v) {
    var p = ar(v);
    if (!(!p || p.label.ignore)) {
      s.push(p);
      var g = a.transGroup;
      l && (g.transform ? Xo($s, g.transform) : Mv($s), p.transform && ho($s, $s, p.transform), ot.copy(jl, p.localRect), jl.applyTransform($s), o ? o.union(jl) : ot.copy(o = new ot(0, 0, 0, 0), jl));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (s.sort(function(v, p) {
    return Math.abs(v.label[u] - c) - Math.abs(p.label[u] - c);
  }), l && o) {
    var h = r.getExtent(), d = Math.min(h[0], h[1]), f = Math.max(h[0], h[1]) - d;
    o.union(new ot(d, 0, f, 1));
  }
  a.stOccupiedRect = o, a.labelInfoList = s;
}
var $s = qi(), jl = new ot(0, 0, 0, 0), wB = function(e, t, i, n, r, a) {
  if (nc(e.nameLocation)) {
    var s = a.stOccupiedRect;
    s && Ww(dB({}, s, a.transGroup.transform), n, r);
  } else
    SB(a.labelInfoList, a.dirVec, n, r);
};
function Ww(e, t, i) {
  var n = new It();
  vp(e, t, n, {
    direction: Math.atan2(i.y, i.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && fB(t, n);
}
function SB(e, t, i, n) {
  for (var r = It.dot(n, t) >= 0, a = 0, s = e.length; a < s; a++) {
    var o = e[r ? a : s - 1 - a];
    o.label.ignore || Ww(o, i, n);
  }
}
var ia = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this.group = new Di(), this._axisModel = t, this._api = i, this._local = {}, this._shared = r || new bB(wB), this._resetCfgDetermined(n);
    }
    return e.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var i = this._shared.ensureRecord(this._axisModel).ready;
        it(!i.axisLine && !i.axisTickLabelDetermine), i.axisName = i.axisTickLabelEstimate = !1;
      }
      var n = this._cfg.raw;
      n.position = t.position, n.labelOffset = t.labelOffset, this._resetCfgDetermined(n);
    }, e.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, e.prototype._resetCfgDetermined = function(t) {
      var i = this._axisModel, n = i.getDefaultOption ? i.getDefaultOption() : {}, r = nt(t.axisName, i.get("name")), a = i.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = nt(t.defaultNameMoveOverlap, !0));
      var s = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: nt(t.nameDirection, 1),
        tickDirection: nt(t.tickDirection, 1),
        labelDirection: nt(t.labelDirection, 1),
        labelOffset: nt(t.labelOffset, 0),
        silent: nt(t.silent, !0),
        axisName: r,
        nameLocation: Zr(i.get("nameLocation"), n.nameLocation, "end"),
        shouldNameMoveOverlap: pp(r) && a,
        optionHideOverlap: i.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: i.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (it(s.position != null), it(s.rotation != null)), this._cfg = s;
      var o = new Di({
        x: s.position[0],
        y: s.position[1],
        rotation: s.rotation
      });
      o.updateTransform(), this._transformGroup = o;
      var l = this._shared.ensureRecord(i);
      l.transGroup = this._transformGroup, l.dirVec = new It(Math.cos(-s.rotation), Math.sin(-s.rotation));
    }, e.prototype.build = function(t, i) {
      var n = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), A(MB, function(r) {
        t[r] && kB[r](n._cfg, n._local, n._shared, n._axisModel, n.group, n._transformGroup, n._api, i || {});
      }), this;
    }, e.innerTextLayout = function(t, i, n) {
      var r = D1(i - t), a, s;
      return Ru(r) ? (s = n > 0 ? "top" : "bottom", a = "center") : Ru(r - Un) ? (s = n > 0 ? "bottom" : "top", a = "center") : (s = "middle", r > 0 && r < Un ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: r,
        textAlign: a,
        textVerticalAlign: s
      };
    }, e.makeAxisEventDataBase = function(t) {
      var i = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return i[t.mainType + "Index"] = t.componentIndex, i;
    }, e.isLabelSilent = function(t) {
      var i = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || i && i.show);
    }, e;
  })()
), MB = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], kB = {
  axisLine: function(e, t, i, n, r, a, s) {
    if (process.env.NODE_ENV !== "production") {
      var o = i.ensureRecord(n).ready;
      it(!o.axisLine), o.axisLine = !0;
    }
    var l = n.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, e.raw.axisLineAutoShow != null && (l = !!e.raw.axisLineAutoShow)), !!l) {
      var u = n.axis.getExtent(), c = a.transform, h = [u[0], 0], d = [u[1], 0], f = h[0] > d[0];
      c && (Qe(h, h, c), Qe(d, d, c));
      var v = Y({
        lineCap: "round"
      }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), p = {
        strokeContainThreshold: e.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: v
      };
      if (n.get(["axisLine", "breakLine"]) && n.axis.scale.hasBreaks())
        gB().buildAxisBreakLine(n, r, a, p);
      else {
        var g = new ps(Y({
          shape: {
            x1: h[0],
            y1: h[1],
            x2: d[0],
            y2: d[1]
          }
        }, p));
        Xv(g.shape, g.style.lineWidth), g.anid = "line", r.add(g);
      }
      var m = n.get(["axisLine", "symbol"]);
      if (m != null) {
        var _ = n.get(["axisLine", "symbolSize"]);
        tt(m) && (m = [m, m]), (tt(_) || Zt(_)) && (_ = [_, _]);
        var y = XN(n.get(["axisLine", "symbolOffset"]) || 0, _), b = _[0], w = _[1];
        A([{
          rotate: e.rotation + Math.PI / 2,
          offset: y[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: y[1],
          r: Math.sqrt((h[0] - d[0]) * (h[0] - d[0]) + (h[1] - d[1]) * (h[1] - d[1]))
        }], function(S, M) {
          if (m[M] !== "none" && m[M] != null) {
            var k = hw(m[M], -b / 2, -w / 2, b, w, v.stroke, !0), T = S.r + S.offset, C = f ? d : h;
            k.attr({
              rotation: S.rotate,
              x: C[0] + T * Math.cos(e.rotation),
              y: C[1] - T * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(k);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(e, t, i, n, r, a, s, o) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      it(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = ly(t, r, o);
    u && oy(e, t, i, n, r, a, s, ny.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(e, t, i, n, r, a, s, o) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = ly(t, r, o);
    u && oy(e, t, i, n, r, a, s, ny.determine);
    var c = AB(e, r, a, n);
    CB(e, t.labelLayoutList, c), PB(e, r, a, n, e.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(e, t, i, n, r, a, s, o) {
    var l = i.ensureRecord(n);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      it(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (r.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = e.axisName;
    if (pp(c)) {
      var h = e.nameLocation, d = e.nameDirection, f = n.getModel("nameTextStyle"), v = n.get("nameGap") || 0, p = n.axis.getExtent(), g = n.axis.inverse ? -1 : 1, m = new It(0, 0), _ = new It(0, 0);
      h === "start" ? (m.x = p[0] - g * v, _.x = -g) : h === "end" ? (m.x = p[1] + g * v, _.x = g) : (m.x = (p[0] + p[1]) / 2, m.y = e.labelOffset + d * v, _.y = d);
      var y = qi();
      _.transform(Dv(y, y, e.rotation));
      var b = n.get("nameRotate");
      b != null && (b = b * Un / 180);
      var w, S;
      nc(h) ? w = ia.innerTextLayout(
        e.rotation,
        b ?? e.rotation,
        // Adapt to axis.
        d
      ) : (w = DB(e.rotation, h, b || 0, p), S = e.raw.axisNameAvailableWidth, S != null && (S = Math.abs(S / Math.sin(w.rotation)), !isFinite(S) && (S = null)));
      var M = f.getFont(), k = n.get("nameTruncate", !0) || {}, T = k.ellipsis, C = ir(e.raw.nameTruncateMaxWidth, k.maxWidth, S), D = o.nameMarginLevel || 0, P = new mi({
        x: m.x,
        y: m.y,
        rotation: w.rotation,
        silent: ia.isLabelSilent(n),
        style: sa(f, {
          text: c,
          font: M,
          overflow: "truncate",
          width: C,
          ellipsis: T,
          fill: f.getTextColor() || n.get(["axisLine", "lineStyle", "color"]),
          align: f.get("align") || w.textAlign,
          verticalAlign: f.get("verticalAlign") || w.textVerticalAlign
        }),
        z2: 1
      });
      if (qv({
        el: P,
        componentModel: n,
        itemName: c
      }), P.__fullText = c, P.anid = "name", n.get("triggerEvent")) {
        var O = ia.makeAxisEventDataBase(n);
        O.targetType = "axisName", O.name = c, zt(P).eventData = O;
      }
      a.add(P), P.updateTransform(), t.nameEl = P;
      var I = l.nameLayout = ar({
        label: P,
        priority: P.z2,
        defaultAttr: {
          ignore: P.ignore
        },
        marginDefault: nc(h) ? _B[D] : yB[D]
      });
      if (l.nameLocation = h, r.add(P), P.decomposeTransform(), e.shouldNameMoveOverlap && I) {
        var N = i.ensureRecord(n);
        process.env.NODE_ENV !== "production" && it(N.labelInfoList), i.resolveAxisNameOverlap(e, i, n, I, _, N);
      }
    }
  }
};
function oy(e, t, i, n, r, a, s, o) {
  Gw(t) || EB(e, t, r, o, n, s);
  var l = t.labelLayoutList;
  LB(e, n, l, a), e.rotation;
  var u = e.optionHideOverlap;
  TB(n, l, u), u && vB(
    // Filter the already ignored labels by the previous overlap resolving methods.
    Ze(l, function(c) {
      return c && !c.label.ignore;
    })
  ), xB(e, i, n, l);
}
function DB(e, t, i, n) {
  var r = D1(i - e), a, s, o = n[0] > n[1], l = t === "start" && !o || t !== "start" && o;
  return Ru(r - Un / 2) ? (s = l ? "bottom" : "top", a = "center") : Ru(r - Un * 1.5) ? (s = l ? "top" : "bottom", a = "center") : (s = "middle", r < Un * 1.5 && r > Un / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: r,
    textAlign: a,
    textVerticalAlign: s
  };
}
function TB(e, t, i) {
  if (oB(e.axis))
    return;
  function n(o, l, u) {
    var c = ar(t[l]), h = ar(t[u]);
    if (!(!c || !h)) {
      if (o === !1 || c.suggestIgnore) {
        ro(c.label);
        return;
      }
      if (h.suggestIgnore) {
        ro(h.label);
        return;
      }
      var d = 0.1;
      if (!i) {
        var f = [0, 0, 0, 0];
        c = ay({
          marginForce: f
        }, c), h = ay({
          marginForce: f
        }, h);
      }
      vp(c, h, null, {
        touchThreshold: d
      }) && ro(o ? h.label : c.label);
    }
  }
  var r = e.get(["axisLabel", "showMinLabel"]), a = e.get(["axisLabel", "showMaxLabel"]), s = t.length;
  n(r, 0, 1), n(a, s - 1, s - 2);
}
function CB(e, t, i) {
  e.showMinorTicks || A(t, function(n) {
    if (n && n.label.ignore)
      for (var r = 0; r < i.length; r++) {
        var a = i[r], s = Yw(a), o = sc(n.label);
        if (s.tickValue != null && !s.onBand && s.tickValue === o.tickValue) {
          ro(a);
          return;
        }
      }
  });
}
function ro(e) {
  e && (e.ignore = !0);
}
function Uw(e, t, i, n, r) {
  for (var a = [], s = [], o = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    s[0] = u, s[1] = 0, o[0] = u, o[1] = i, t && (Qe(s, s, t), Qe(o, o, t));
    var c = new ps({
      shape: {
        x1: s[0],
        y1: s[1],
        x2: o[0],
        y2: o[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Xv(c.shape, c.style.lineWidth), c.anid = r + "_" + e[l].tickValue, a.push(c);
    var h = Yw(c);
    h.onBand = !!e[l].onBand, h.tickValue = e[l].tickValue;
  }
  return a;
}
function AB(e, t, i, n) {
  var r = n.axis, a = n.getModel("axisTick"), s = a.get("show");
  if (s === "auto" && (s = !0, e.raw.axisTickAutoShow != null && (s = !!e.raw.axisTickAutoShow)), !s || r.scale.isBlank())
    return [];
  for (var o = a.getModel("lineStyle"), l = e.tickDirection * a.get("length"), u = r.getTicksCoords(), c = Uw(u, i.transform, l, Jt(o.getLineStyle(), {
    stroke: n.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), h = 0; h < c.length; h++)
    t.add(c[h]);
  return c;
}
function PB(e, t, i, n, r) {
  var a = n.axis, s = n.getModel("minorTick");
  if (!(!e.showMinorTicks || a.scale.isBlank())) {
    var o = a.getMinorTicksCoords();
    if (o.length)
      for (var l = s.getModel("lineStyle"), u = r * s.get("length"), c = Jt(l.getLineStyle(), Jt(n.getModel("axisTick").getLineStyle(), {
        stroke: n.get(["axisLine", "lineStyle", "color"])
      })), h = 0; h < o.length; h++)
        for (var d = Uw(o[h], i.transform, u, c, "minorticks_" + h), f = 0; f < d.length; f++)
          t.add(d[f]);
  }
}
function ly(e, t, i) {
  if (Gw(e)) {
    var n = e.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && it(e.labelGroup && n);
    var r = n.out.noPxChangeTryDetermine;
    if (i.noPxChange) {
      for (var a = !0, s = 0; s < r.length; s++)
        a = a && r[s]();
      if (a)
        return !1;
    }
    r.length && (t.remove(e.labelGroup), zf(e, null, null, null));
  }
  return !0;
}
function EB(e, t, i, n, r, a) {
  var s = r.axis, o = ir(e.raw.axisLabelShow, r.get(["axisLabel", "show"])), l = new Di();
  i.add(l);
  var u = uB(n);
  if (!o || s.scale.isBlank()) {
    zf(t, [], l, u);
    return;
  }
  var c = r.getModel("axisLabel"), h = s.getViewLabels(u), d = (ir(e.raw.labelRotate, c.get("rotate")) || 0) * Un / 180, f = ia.innerTextLayout(e.rotation, d, e.labelDirection), v = r.getCategories && r.getCategories(!0), p = [], g = r.get("triggerEvent"), m = 1 / 0, _ = -1 / 0;
  A(h, function(b, w) {
    var S, M = s.scale.type === "ordinal" ? s.scale.getRawOrdinalNumber(b.tickValue) : b.tickValue, k = b.formattedLabel, T = b.rawLabel, C = c;
    if (v && v[M]) {
      var D = v[M];
      Q(D) && D.textStyle && (C = new jt(D.textStyle, c, r.ecModel));
    }
    var P = C.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), O = C.getShallow("align", !0) || f.textAlign, I = nt(C.getShallow("alignMinLabel", !0), O), N = nt(C.getShallow("alignMaxLabel", !0), O), F = C.getShallow("verticalAlign", !0) || C.getShallow("baseline", !0) || f.textVerticalAlign, q = nt(C.getShallow("verticalAlignMinLabel", !0), F), V = nt(C.getShallow("verticalAlignMaxLabel", !0), F), B = 10 + (((S = b.time) === null || S === void 0 ? void 0 : S.level) || 0);
    m = Math.min(m, B), _ = Math.max(_, B);
    var $ = new mi({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: ia.isLabelSilent(r),
      z2: B,
      style: sa(C, {
        text: k,
        align: w === 0 ? I : w === h.length - 1 ? N : O,
        verticalAlign: w === 0 ? q : w === h.length - 1 ? V : F,
        fill: mt(P) ? P(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          s.type === "category" ? T : s.type === "value" ? M + "" : M,
          w
        ) : P
      })
    });
    $.anid = "label_" + M;
    var j = sc($);
    if (j.break = b.break, j.tickValue = M, j.layoutRotation = f.rotation, qv({
      el: $,
      componentModel: r,
      itemName: k,
      formatterParamsExtra: {
        isTruncated: function() {
          return $.isTruncated;
        },
        value: T,
        tickIndex: w
      }
    }), g) {
      var G = ia.makeAxisEventDataBase(r);
      G.targetType = "axisLabel", G.value = T, G.tickIndex = w, b.break && (G.break = {
        // type: labelItem.break.type,
        start: b.break.parsedBreak.vmin,
        end: b.break.parsedBreak.vmax
      }), s.type === "category" && (G.dataIndex = M), zt($).eventData = G, b.break && IB(r, a, $, b.break);
    }
    p.push($), l.add($);
  });
  var y = yt(p, function(b) {
    return {
      label: b,
      priority: sc(b).break ? b.z2 + (_ - m + 1) : b.z2,
      defaultAttr: {
        ignore: b.ignore
      }
    };
  });
  zf(t, y, l, u);
}
function Gw(e) {
  return !!e.labelLayoutList;
}
function zf(e, t, i, n) {
  e.labelLayoutList = t, e.labelGroup = i, e.axisLabelsCreationContext = n;
}
function LB(e, t, i, n) {
  var r = t.get(["axisLabel", "margin"]);
  A(i, function(a, s) {
    var o = ar(a);
    if (o) {
      var l = o.label, u = sc(l);
      o.suggestIgnore = l.ignore, l.ignore = !1, cf(ln, OB), ln.x = t.axis.dataToCoord(u.tickValue), ln.y = e.labelOffset + e.labelDirection * r, ln.rotation = u.layoutRotation, n.add(ln), ln.updateTransform(), n.remove(ln), ln.decomposeTransform(), cf(l, ln), l.markRedraw(), ac(o, !0), ar(o);
    }
  });
}
var ln = new De(), OB = new De();
function pp(e) {
  return !!e;
}
function IB(e, t, i, n) {
  i.on("click", function(r) {
    var a = {
      type: mB,
      breaks: [{
        start: n.parsedBreak.breakOption.start,
        end: n.parsedBreak.breakOption.end
      }]
    };
    a[e.axis.dim + "AxisIndex"] = e.componentIndex, t.dispatchAction(a);
  });
}
function uy(e, t, i) {
  i = i || {};
  var n = t.axis, r = {}, a = n.getAxesOnZeroOf()[0], s = n.position, o = a ? "onZero" : s, l = n.dim, u = [e.x, e.x + e.width, e.y, e.y + e.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, h = t.get("offset") || 0, d = l === "x" ? [u[2] - h, u[3] + h] : [u[0] - h, u[1] + h];
  if (a) {
    var f = a.toGlobalCoord(a.dataToCoord(0));
    d[c.onZero] = Math.max(Math.min(f, d[1]), d[0]);
  }
  r.position = [l === "y" ? d[c[o]] : u[0], l === "x" ? d[c[o]] : u[3]], r.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  r.labelDirection = r.tickDirection = r.nameDirection = v[s], r.labelOffset = a ? d[c[s]] - d[c.onZero] : 0, t.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), ir(i.labelInside, t.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
  var p = t.get(["axisLabel", "rotate"]);
  return r.labelRotate = o === "top" ? -p : p, r.z2 = 1, r;
}
function RB(e, t) {
  var i = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return NB(i, e, t), i.seriesInvolved && BB(i, e), i;
}
function NB(e, t, i) {
  var n = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", !0) || [], s = [];
  A(i.getCoordinateSystems(), function(o) {
    if (!o.axisPointerEnabled)
      return;
    var l = zo(o.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = o;
    var c = o.model, h = c.getModel("tooltip", n);
    if (A(o.getAxes(), Oe(p, !1, null)), o.getTooltipAxes && n && h.get("show")) {
      var d = h.get("trigger") === "axis", f = h.get(["axisPointer", "type"]) === "cross", v = o.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (d || f) && A(v.baseAxes, Oe(p, f ? "cross" : !0, d)), f && A(v.otherAxes, Oe(p, "cross", !1));
    }
    function p(g, m, _) {
      var y = _.model.getModel("axisPointer", r), b = y.get("show");
      if (!(!b || b === "auto" && !g && !Vf(y))) {
        m == null && (m = y.get("triggerTooltip")), y = g ? FB(_, h, r, t, g, m) : y;
        var w = y.get("snap"), S = y.get("triggerEmphasis"), M = zo(_.model), k = m || w || _.type === "category", T = e.axesInfo[M] = {
          key: M,
          axis: _,
          coordSys: o,
          axisPointerModel: y,
          triggerTooltip: m,
          triggerEmphasis: S,
          involveSeries: k,
          snap: w,
          useHandle: Vf(y),
          seriesModels: [],
          linkGroup: null
        };
        u[M] = T, e.seriesInvolved = e.seriesInvolved || k;
        var C = $B(a, _);
        if (C != null) {
          var D = s[C] || (s[C] = {
            axesInfo: {}
          });
          D.axesInfo[M] = T, D.mapper = a[C].mapper, T.linkGroup = D;
        }
      }
    }
  });
}
function FB(e, t, i, n, r, a) {
  var s = t.getModel("axisPointer"), o = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  A(o, function(d) {
    l[d] = pt(s.get(d));
  }), l.snap = e.type !== "category" && !!a, s.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), r === "cross") {
    var c = s.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var h = l.lineStyle = s.get("crossStyle");
      h && Jt(u, h.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new jt(l, i, n));
}
function BB(e, t) {
  t.eachSeries(function(i) {
    var n = i.coordinateSystem, r = i.get(["tooltip", "trigger"], !0), a = i.get(["tooltip", "show"], !0);
    !n || !n.model || r === "none" || r === !1 || r === "item" || a === !1 || i.get(["axisPointer", "show"], !0) === !1 || A(e.coordSysAxesInfo[zo(n.model)], function(s) {
      var o = s.axis;
      n.getAxis(o.dim) === o && (s.seriesModels.push(i), s.seriesDataCount == null && (s.seriesDataCount = 0), s.seriesDataCount += i.getData().count());
    });
  });
}
function $B(e, t) {
  for (var i = t.model, n = t.dim, r = 0; r < e.length; r++) {
    var a = e[r] || {};
    if (wd(a[n + "AxisId"], i.id) || wd(a[n + "AxisIndex"], i.componentIndex) || wd(a[n + "AxisName"], i.name))
      return r;
  }
}
function wd(e, t) {
  return e === "all" || Z(e) && Vt(e, t) >= 0 || e === t;
}
function zB(e) {
  var t = gp(e);
  if (t) {
    var i = t.axisPointerModel, n = t.axis.scale, r = i.option, a = i.get("status"), s = i.get("value");
    s != null && (s = n.parse(s));
    var o = Vf(i);
    a == null && (r.status = o ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (s == null || s > l[1]) && (s = l[1]), s < l[0] && (s = l[0]), r.value = s, o && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function gp(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[zo(e)];
}
function VB(e) {
  var t = gp(e);
  return t && t.axisPointerModel;
}
function Vf(e) {
  return !!e.get(["handle", "show"]);
}
function zo(e) {
  return e.type + "||" + e.id;
}
var Sd = {}, HB = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r, a) {
      this.axisPointerClass && zB(i), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(i, r, !0);
    }, t.prototype.updateAxisPointer = function(i, n, r, a) {
      this._doUpdateAxisPointerClass(i, r, !1);
    }, t.prototype.remove = function(i, n) {
      var r = this._axisPointer;
      r && r.remove(n);
    }, t.prototype.dispose = function(i, n) {
      this._disposeAxisPointer(n), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(i, n, r) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var s = VB(i);
        s ? (this._axisPointer || (this._axisPointer = new a())).render(i, s, n, r) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(i) {
      this._axisPointer && this._axisPointer.dispose(i), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(i, n) {
      if (process.env.NODE_ENV !== "production" && Sd[i])
        throw new Error("axisPointer " + i + " exists");
      Sd[i] = n;
    }, t.getAxisPointerClass = function(i) {
      return i && Sd[i];
    }, t.type = "axis", t;
  })(Tn)
), $r = Gt(), cy = pt, Md = Dt, YB = (
  /** @class */
  (function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, i, n, r) {
      var a = i.get("value"), s = i.get("status");
      if (this._axisModel = t, this._axisPointerModel = i, this._api = n, !(!r && this._lastValue === a && this._lastStatus === s)) {
        this._lastValue = a, this._lastStatus = s;
        var o = this._group, l = this._handle;
        if (!s || s === "hide") {
          o && o.hide(), l && l.hide();
          return;
        }
        o && o.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, i, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(t, i);
        if (!o)
          o = this._group = new Di(), this.createPointerEl(o, u, t, i), this.createLabelEl(o, u, t, i), n.getZr().add(o);
        else {
          var d = Oe(hy, i, h);
          this.updatePointerEl(o, u, d), this.updateLabelEl(o, u, d, i);
        }
        fy(o, i, !0), this._renderHandle(a);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, i) {
      var n = i.get("animation"), r = t.axis, a = r.type === "category", s = i.get("snap");
      if (!s && !a)
        return !1;
      if (n === "auto" || n == null) {
        var o = this.animationThreshold;
        if (a && r.getBandWidth() > o)
          return !0;
        if (s) {
          var l = gp(t).seriesDataCount, u = r.getExtent();
          return Math.abs(u[0] - u[1]) / l > o;
        }
        return !1;
      }
      return n === !0;
    }, e.prototype.makeElOption = function(t, i, n, r, a) {
    }, e.prototype.createPointerEl = function(t, i, n, r) {
      var a = i.pointer;
      if (a) {
        var s = $r(t).pointerEl = new lR[a.type](cy(i.pointer));
        t.add(s);
      }
    }, e.prototype.createLabelEl = function(t, i, n, r) {
      if (i.label) {
        var a = $r(t).labelEl = new mi(cy(i.label));
        t.add(a), dy(a, r);
      }
    }, e.prototype.updatePointerEl = function(t, i, n) {
      var r = $r(t).pointerEl;
      r && i.pointer && (r.setStyle(i.pointer.style), n(r, {
        shape: i.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, i, n, r) {
      var a = $r(t).labelEl;
      a && (a.setStyle(i.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: i.label.x,
        y: i.label.y
      }), dy(a, r));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var i = this._axisPointerModel, n = this._api.getZr(), r = this._handle, a = i.getModel("handle"), s = i.get("status");
        if (!a.get("show") || !s || s === "hide") {
          r && n.remove(r), this._handle = null;
          return;
        }
        var o;
        this._handle || (o = !0, r = this._handle = px(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Tu(u.event);
          },
          onmousedown: Md(this._onHandleDragMove, this, 0, 0),
          drift: Md(this._onHandleDragMove, this),
          ondragend: Md(this._onHandleDragEnd, this)
        }), n.add(r)), fy(r, i, !1), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        Z(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, nw(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o);
      }
    }, e.prototype._moveHandleToValue = function(t, i) {
      hy(this._axisPointerModel, !i && this._moveAnimation, this._handle, kd(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, i) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var r = this.updateHandleTransform(kd(n), [t, i], this._axisModel, this._axisPointerModel);
        this._payloadInfo = r, n.stopAnimation(), n.attr(kd(r)), $r(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var i = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: i.cursorPoint[0],
          y: i.cursorPoint[1],
          tooltipOption: i.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var i = this._axisPointerModel.get("value");
        this._moveHandleToValue(i), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var i = t.getZr(), n = this._group, r = this._handle;
      i && n && (this._lastGraphicKey = null, n && i.remove(n), r && i.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), Pf(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, i, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: i[n],
        height: i[1 - n]
      };
    }, e;
  })()
);
function hy(e, t, i, n) {
  Xw($r(i).lastProp, n) || ($r(i).lastProp = n, t ? Uv(i, n, e) : (i.stopAnimation(), i.attr(n)));
}
function Xw(e, t) {
  if (Q(e) && Q(t)) {
    var i = !0;
    return A(t, function(n, r) {
      i = i && Xw(e[r], n);
    }), !!i;
  } else
    return e === t;
}
function dy(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function kd(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function fy(e, t, i) {
  var n = t.get("z"), r = t.get("zlevel");
  e && e.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), r != null && (a.zlevel = r), a.silent = i);
  });
}
function WB(e) {
  var t = e.get("type"), i = e.getModel(t + "Style"), n;
  return t === "line" ? (n = i.getLineStyle(), n.fill = null) : t === "shadow" && (n = i.getAreaStyle(), n.stroke = null), n;
}
function UB(e, t, i, n, r) {
  var a = i.get("value"), s = jw(a, t.axis, t.ecModel, i.get("seriesDataIndices"), {
    precision: i.get(["label", "precision"]),
    formatter: i.get(["label", "formatter"])
  }), o = i.getModel("label"), l = tp(o.get("padding") || 0), u = o.getFont(), c = cL(s, u), h = r.position, d = c.width + l[1] + l[3], f = c.height + l[0] + l[2], v = r.align;
  v === "right" && (h[0] -= d), v === "center" && (h[0] -= d / 2);
  var p = r.verticalAlign;
  p === "bottom" && (h[1] -= f), p === "middle" && (h[1] -= f / 2), GB(h, d, f, n);
  var g = o.get("backgroundColor");
  (!g || g === "auto") && (g = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: sa(o, {
      text: s,
      font: u,
      fill: o.getTextColor(),
      padding: l,
      backgroundColor: g
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function GB(e, t, i, n) {
  var r = n.getWidth(), a = n.getHeight();
  e[0] = Math.min(e[0] + t, r) - t, e[1] = Math.min(e[1] + i, a) - i, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function jw(e, t, i, n, r) {
  e = t.scale.parse(e);
  var a = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: r.precision
  }), s = r.formatter;
  if (s) {
    var o = {
      value: zw(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    A(n, function(l) {
      var u = i.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && o.seriesData.push(h);
    }), tt(s) ? a = s.replace("{value}", a) : mt(s) && (a = s(o));
  }
  return a;
}
function qw(e, t, i) {
  var n = qi();
  return Dv(n, n, i.rotation), Zd(n, n, i.position), jv([e.dataToCoord(t), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
}
function XB(e, t, i, n, r, a) {
  var s = ia.innerTextLayout(i.rotation, 0, i.labelDirection);
  i.labelMargin = r.get(["label", "margin"]), UB(t, n, r, a, {
    position: qw(n.axis, e, i),
    align: s.textAlign,
    verticalAlign: s.textVerticalAlign
  });
}
function jB(e, t, i) {
  return i = i || 0, {
    x1: e[i],
    y1: e[1 - i],
    x2: t[i],
    y2: t[1 - i]
  };
}
function qB(e, t, i) {
  return i = i || 0, {
    x: e[i],
    y: e[1 - i],
    width: t[i],
    height: t[1 - i]
  };
}
var ZB = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(i, n, r, a, s) {
      var o = r.axis, l = o.grid, u = a.get("type"), c = vy(l, o).getOtherAxis(o).getGlobalExtent(), h = o.toGlobalCoord(o.dataToCoord(n, !0));
      if (u && u !== "none") {
        var d = WB(a), f = KB[u](o, h, c);
        f.style = d, i.graphicKey = f.type, i.pointer = f;
      }
      var v = uy(l.getRect(), r);
      XB(n, i, v, r, a, s);
    }, t.prototype.getHandleTransform = function(i, n, r) {
      var a = uy(n.axis.grid.getRect(), n, {
        labelInside: !1
      });
      a.labelMargin = r.get(["handle", "margin"]);
      var s = qw(n.axis, i, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(i, n, r, a) {
      var s = r.axis, o = s.grid, l = s.getGlobalExtent(!0), u = vy(o, s).getOtherAxis(s).getGlobalExtent(), c = s.dim === "x" ? 0 : 1, h = [i.x, i.y];
      h[c] += n[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var d = (u[1] + u[0]) / 2, f = [d, d];
      f[c] = h[c];
      var v = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: i.rotation,
        cursorPoint: f,
        tooltipOption: v[c]
      };
    }, t;
  })(YB)
);
function vy(e, t) {
  var i = {};
  return i[t.dim + "AxisIndex"] = t.index, e.getCartesian(i);
}
var KB = {
  line: function(e, t, i) {
    var n = jB([t, i[0]], [t, i[1]], py(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, i) {
    var n = Math.max(1, e.getBandWidth()), r = i[1] - i[0];
    return {
      type: "Rect",
      shape: qB([t - n / 2, i[0]], [n, r], py(e))
    };
  }
};
function py(e) {
  return e.dim === "x" ? 0 : 1;
}
var QB = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: St.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: St.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: St.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: St.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: St.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  })(Et)
), _n = Gt(), JB = A;
function Zw(e, t, i) {
  if (!st.node) {
    var n = t.getZr();
    _n(n).records || (_n(n).records = {}), t3(n, t);
    var r = _n(n).records[e] || (_n(n).records[e] = {});
    r.handler = i;
  }
}
function t3(e, t) {
  if (_n(e).initialized)
    return;
  _n(e).initialized = !0, i("click", Oe(gy, "click")), i("mousemove", Oe(gy, "mousemove")), i("globalout", i3);
  function i(n, r) {
    e.on(n, function(a) {
      var s = n3(t);
      JB(_n(e).records, function(o) {
        o && r(o, a, s.dispatchAction);
      }), e3(s.pendings, t);
    });
  }
}
function e3(e, t) {
  var i = e.showTip.length, n = e.hideTip.length, r;
  i ? r = e.showTip[i - 1] : n && (r = e.hideTip[n - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
}
function i3(e, t, i) {
  e.handler("leave", null, i);
}
function gy(e, t, i, n) {
  t.handler(e, i, n);
}
function n3(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, i = function(n) {
    var r = t[n.type];
    r ? r.push(n) : (n.dispatchAction = i, e.dispatchAction(n));
  };
  return {
    dispatchAction: i,
    pendings: t
  };
}
function Hf(e, t) {
  if (!st.node) {
    var i = t.getZr(), n = (_n(i).records || {})[e];
    n && (_n(i).records[e] = null);
  }
}
var r3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      var a = n.getComponent("tooltip"), s = i.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      Zw("axisPointer", r, function(o, l, u) {
        s !== "none" && (o === "leave" || s.indexOf(o) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: o,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(i, n) {
      Hf("axisPointer", n);
    }, t.prototype.dispose = function(i, n) {
      Hf("axisPointer", n);
    }, t.type = "axisPointer", t;
  })(Tn)
);
function Kw(e, t) {
  var i = [], n = e.seriesIndex, r;
  if (n == null || !(r = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = r.getData(), s = qo(a, e);
  if (s == null || s < 0 || Z(s))
    return {
      point: []
    };
  var o = a.getItemGraphicEl(s), l = r.coordinateSystem;
  if (r.getTooltipPosition)
    i = r.getTooltipPosition(s) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, d = u.dim, f = h === "x" || h === "radius" ? 1 : 0, v = a.mapDimension(d), p = [];
      p[f] = a.get(v, s), p[1 - f] = a.get(a.getCalculationInfo("stackResultDimension"), s), i = l.dataToPoint(p) || [];
    } else
      i = l.dataToPoint(a.getValues(yt(l.dimensions, function(m) {
        return a.mapDimension(m);
      }), s)) || [];
  else if (o) {
    var g = o.getBoundingRect().clone();
    g.applyTransform(o.transform), i = [g.x + g.width / 2, g.y + g.height / 2];
  }
  return {
    point: i,
    el: o
  };
}
var my = Gt();
function a3(e, t, i) {
  var n = e.currTrigger, r = [e.x, e.y], a = e, s = e.dispatchAction || Dt(i.dispatchAction, i), o = t.getComponent("axisPointer").coordSysAxesInfo;
  if (o) {
    du(r) && (r = Kw({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = du(r), u = a.axesInfo, c = o.axesInfo, h = n === "leave" || du(r), d = {}, f = {}, v = {
      list: [],
      map: {}
    }, p = {
      showPointer: Oe(o3, f),
      showTooltip: Oe(l3, v)
    };
    A(o.coordSysMap, function(m, _) {
      var y = l || m.containPoint(r);
      A(o.coordSysAxesInfo[_], function(b, w) {
        var S = b.axis, M = d3(u, b);
        if (!h && y && (!u || M)) {
          var k = M && M.value;
          k == null && !l && (k = S.pointToData(r)), k != null && _y(b, k, p, !1, d);
        }
      });
    });
    var g = {};
    return A(c, function(m, _) {
      var y = m.linkGroup;
      y && !f[_] && A(y.axesInfo, function(b, w) {
        var S = f[w];
        if (b !== m && S) {
          var M = S.value;
          y.mapper && (M = m.axis.scale.parse(y.mapper(M, yy(b), yy(m)))), g[m.key] = M;
        }
      });
    }), A(g, function(m, _) {
      _y(c[_], m, p, !0, d);
    }), u3(f, c, d), c3(v, r, e, s), h3(c, s, i), d;
  }
}
function _y(e, t, i, n, r) {
  var a = e.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!e.involveSeries) {
      i.showPointer(e, t);
      return;
    }
    var s = s3(t, e), o = s.payloadBatch, l = s.snapToValue;
    o[0] && r.seriesIndex == null && Y(r, o[0]), !n && e.snap && a.containData(l) && l != null && (t = l), i.showPointer(e, t, o), i.showTooltip(e, s, l);
  }
}
function s3(e, t) {
  var i = t.axis, n = i.dim, r = e, a = [], s = Number.MAX_VALUE, o = -1;
  return A(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), h, d;
    if (l.getAxisTooltipData) {
      var f = l.getAxisTooltipData(c, e, i);
      d = f.dataIndices, h = f.nestestValue;
    } else {
      if (d = l.indicesOfNearest(
        n,
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        i.type === "category" ? 0.5 : null
      ), !d.length)
        return;
      h = l.getData().get(c[0], d[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var v = e - h, p = Math.abs(v);
      p <= s && ((p < s || v >= 0 && o < 0) && (s = p, o = v, r = h, a.length = 0), A(d, function(g) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: g,
          dataIndex: l.getData().getRawIndex(g)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: r
  };
}
function o3(e, t, i, n) {
  e[t.key] = {
    value: i,
    payloadBatch: n
  };
}
function l3(e, t, i, n) {
  var r = i.payloadBatch, a = t.axis, s = a.model, o = t.axisPointerModel;
  if (!(!t.triggerTooltip || !r.length)) {
    var l = t.coordSys.model, u = zo(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: s.componentIndex,
      axisType: s.type,
      axisId: s.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: o.get(["label", "precision"]),
        formatter: o.get(["label", "formatter"])
      },
      seriesDataIndices: r.slice()
    });
  }
}
function u3(e, t, i) {
  var n = i.axesInfo = [];
  A(t, function(r, a) {
    var s = r.axisPointerModel.option, o = e[a];
    o ? (!r.useHandle && (s.status = "show"), s.value = o.value, s.seriesDataIndices = (o.payloadBatch || []).slice()) : !r.useHandle && (s.status = "hide"), s.status === "show" && n.push({
      axisDim: r.axis.dim,
      axisIndex: r.axis.model.componentIndex,
      value: s.value
    });
  });
}
function c3(e, t, i, n) {
  if (du(t) || !e.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var r = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: i.tooltipOption,
    position: i.position,
    dataIndexInside: r.dataIndexInside,
    dataIndex: r.dataIndex,
    seriesIndex: r.seriesIndex,
    dataByCoordSys: e.list
  });
}
function h3(e, t, i) {
  var n = i.getZr(), r = "axisPointerLastHighlights", a = my(n)[r] || {}, s = my(n)[r] = {};
  A(e, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && A(h.seriesDataIndices, function(d) {
      var f = d.seriesIndex + " | " + d.dataIndex;
      s[f] = d;
    });
  });
  var o = [], l = [];
  A(a, function(u, c) {
    !s[c] && l.push(u);
  }), A(s, function(u, c) {
    !a[c] && o.push(u);
  }), l.length && i.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), o.length && i.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: o
  });
}
function d3(e, t) {
  for (var i = 0; i < (e || []).length; i++) {
    var n = e[i];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function yy(e) {
  var t = e.axis.model, i = {}, n = i.axisDim = e.axis.dim;
  return i.axisIndex = i[n + "AxisIndex"] = t.componentIndex, i.axisName = i[n + "AxisName"] = t.name, i.axisId = i[n + "AxisId"] = t.id, i;
}
function du(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function f3(e) {
  HB.registerAxisPointerClass("CartesianAxisPointer", ZB), e.registerComponentModel(QB), e.registerComponentView(r3), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var i = t.axisPointer.link;
      i && !Z(i) && (t.axisPointer.link = [i]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, i) {
    t.getComponent("axisPointer").coordSysAxesInfo = RB(t, i);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, a3);
}
function v3(e, t, i) {
  var n = e.target;
  n.x += t, n.y += i, n.dirty();
}
function p3(e, t, i, n) {
  var r = e.target, a = e.zoomLimit, s = e.zoom = e.zoom || 1;
  s *= t, s = mp(s, a);
  var o = s / e.zoom;
  e.zoom = s, Qw(r, i, n, o), r.dirty();
}
function g3(e, t, i, n, r, a) {
  var s = new ot(0, 0, 0, 0);
  n.enable(e.get("roam"), {
    api: t,
    zInfo: {
      component: e
    },
    triggerInfo: {
      roamTrigger: e.get("roamTrigger"),
      isInSelf: function(u, c, h) {
        return s.copy(i.getBoundingRect()), s.applyTransform(i.getComputedTransform()), s.contain(c, h);
      },
      isInClip: function(u, c, h) {
        return !0;
      }
    }
  }), r.zoomLimit = e.get("scaleLimit");
  var o = e.coordinateSystem;
  r.zoom = o ? o.getZoom() : 1;
  var l = e.subType + "Roam";
  n.off("pan").off("zoom").on("pan", function(u) {
    v3(r, u.dx, u.dy), t.dispatchAction({
      seriesId: e.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    p3(r, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: e.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function by(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function m3(e, t, i) {
  var n = e.getZoom(), r = e.getCenter(), a = t.zoom, s = e.projectedToPoint ? e.projectedToPoint(r) : e.dataToPoint(r);
  return t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, e.setCenter(by(e, s))), a != null && (a = mp(n * a, i) / n, Qw(e, t.originX, t.originY, a), e.updateTransform(), e.setCenter(by(e, s)), e.setZoom(a * n)), {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
function Qw(e, t, i, n) {
  e.x -= (t - e.x) * (n - 1), e.y -= (i - e.y) * (n - 1), e.scaleX *= n, e.scaleY *= n;
}
function mp(e, t) {
  if (t) {
    var i = t.min || 0, n = t.max || 1 / 0;
    e = Math.max(Math.min(n, e), i);
  }
  return e;
}
var xy = Qe, _3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i, n) {
      var r = e.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Hr(), r._rawTransformable = new Hr(), r.name = i, r._opt = n, r;
    }
    return t.prototype.setBoundingRect = function(i, n, r, a) {
      return this._rect = new ot(i, n, r, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(i, n, r, a) {
      this._transformTo(i, n, r, a), this._viewRect = new ot(i, n, r, a);
    }, t.prototype._transformTo = function(i, n, r, a) {
      var s = this.getBoundingRect(), o = this._rawTransformable;
      o.transform = s.calculateTransform(new ot(i, n, r, a));
      var l = o.parent;
      o.parent = null, o.decomposeTransform(), o.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(i) {
      var n = this._opt;
      n && n.api && n.ecModel && n.ecModel.getShallow("legacyViewCoordSysCenterBase") && i && (i = [He(i[0], n.api.getWidth()), He(i[1], n.api.getWidth())]), this._centerOption = pt(i), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(i) {
      this._zoom = mp(i || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var i = this.getBoundingRect(), n = i.x + i.width / 2, r = i.y + i.height / 2;
      return [n, r];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var i = this._centerOption, n = this._rect;
      i && n && (this._center = [He(i[0], n.width, n.x), He(i[1], n.height, n.y)]);
      var r = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, s = this.getDefaultCenter(), o = this.getCenter(), l = this.getZoom();
      o = Qe([], o, r), s = Qe([], s, r), a.originX = o[0], a.originY = o[1], a.x = s[0] - o[0], a.y = s[1] - o[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var i = this._roamTransformable, n = this._rawTransformable;
      n.parent = i, i.updateTransform(), n.updateTransform(), kv(this.transform || (this.transform = []), n.transform || qi()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], Xo(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var i = this._rawTransformable, n = this._roamTransformable, r = new Hr();
      return r.transform = n.transform, r.decomposeTransform(), {
        roam: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        },
        raw: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var i = this.getBoundingRect().clone();
      return i.applyTransform(this.transform), i;
    }, t.prototype.dataToPoint = function(i, n, r) {
      var a = n ? this._rawTransform : this.transform;
      return r = r || [], a ? xy(r, i, a) : tE(r, i);
    }, t.prototype.pointToData = function(i, n, r) {
      r = r || [];
      var a = this.invTransform;
      return a ? xy(r, i, a) : (r[0] = i[0], r[1] = i[1], r);
    }, t.prototype.convertToPixel = function(i, n, r) {
      var a = wy(n);
      return a === this ? a.dataToPoint(r) : null;
    }, t.prototype.convertFromPixel = function(i, n, r) {
      var a = wy(n);
      return a === this ? a.pointToData(r) : null;
    }, t.prototype.containPoint = function(i) {
      return this.getViewRectAfterRoam().contain(i[0], i[1]);
    }, t.dimensions = ["x", "y"], t;
  })(Hr)
);
function wy(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var y3 = Gt();
function Sy(e, t) {
  return !!y3(e)[t];
}
ha({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, ke);
var b3 = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function x3(e, t, i) {
  var n = t.getComponentByElement(e.topTarget);
  if (!n || n === i || b3.hasOwnProperty(n.mainType))
    return !1;
  var r = n.coordinateSystem;
  if (!r || r.model === i)
    return !1;
  var a = Ro(n), s = Ro(i);
  return !((a.zlevel - s.zlevel || a.z - s.z) <= 0);
}
var w3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i) {
      var n = e.call(this) || this;
      n._zr = i;
      var r = Dt(n._mousedownHandler, n), a = Dt(n._mousemoveHandler, n), s = Dt(n._mouseupHandler, n), o = Dt(n._mousewheelHandler, n), l = Dt(n._pinchHandler, n);
      return n.enable = function(u, c) {
        var h = c.zInfo, d = Ro(h.component), f = d.z, v = d.zlevel, p = {
          component: h.component,
          z: f,
          zlevel: v,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: nt(h.z2, -1 / 0)
        }, g = Y({}, c.triggerInfo);
        this._opt = Jt(Y({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: p,
          triggerInfo: g
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && (Vs(i, "mousedown", r, p), Vs(i, "mousemove", a, p), Vs(i, "mouseup", s, p)), (u === !0 || u === "scale" || u === "zoom") && (Vs(i, "mousewheel", o, p), Vs(i, "pinch", l, p)));
      }, n.disable = function() {
        this._enabled = !1, Hs(i, "mousedown", r), Hs(i, "mousemove", a), Hs(i, "mouseup", s), Hs(i, "mousewheel", o), Hs(i, "pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(i, n, r) {
      var a = this._opt, s = a.zInfoParsed;
      if (x3(i, a.api, s.component))
        return !1;
      var o = a.triggerInfo, l = o.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = o.isInSelf(i, n, r)), u && o.isInClip && !o.isInClip(i, n, r) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(i, n, r, a) {
      var s = i.target;
      if (!s && this._checkPointer(i, n, r))
        return "grab";
      if (a)
        return s && s.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(i) {
      if (!(bm(i) || zs(i))) {
        for (var n = i.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var r = i.offsetX, a = i.offsetY;
        this._checkPointer(i, r, a) && (this._x = r, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(i) {
      var n = this._zr;
      if (!(i.gestureEvent === "pinch" || Sy(n, "globalPan") || zs(i))) {
        var r = i.offsetX, a = i.offsetY;
        if (!this._dragging || !fu("moveOnMouseMove", i, this._opt)) {
          var s = this._decideCursorStyle(i, r, a, !1);
          s && n.setCursorStyle(s);
          return;
        }
        n.setCursorStyle("grabbing");
        var o = this._x, l = this._y, u = r - o, c = a - l;
        this._x = r, this._y = a, this._opt.preventDefaultMouseMove && Tu(i.event), i.__ecRoamConsumed = !0, My(this, "pan", "moveOnMouseMove", i, {
          dx: u,
          dy: c,
          oldX: o,
          oldY: l,
          newX: r,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(i) {
      if (!zs(i)) {
        var n = this._zr;
        if (!bm(i)) {
          this._dragging = !1;
          var r = this._decideCursorStyle(i, i.offsetX, i.offsetY, !0);
          r && n.setCursorStyle(r);
        }
      }
    }, t.prototype._mousewheelHandler = function(i) {
      if (!zs(i)) {
        var n = fu("zoomOnMouseWheel", i, this._opt), r = fu("moveOnMouseWheel", i, this._opt), a = i.wheelDelta, s = Math.abs(a), o = i.offsetX, l = i.offsetY;
        if (!(a === 0 || !n && !r)) {
          if (n) {
            var u = s > 3 ? 1.4 : s > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", i, {
              scale: c,
              originX: o,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (r) {
            var h = Math.abs(a), d = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", i, {
              scrollDelta: d,
              originX: o,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(i) {
      if (!(Sy(this._zr, "globalPan") || zs(i))) {
        var n = i.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, i, {
          scale: n,
          originX: i.pinchX,
          originY: i.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(i, n, r, a, s) {
      i._checkPointer(a, s.originX, s.originY) && (Tu(a.event), a.__ecRoamConsumed = !0, My(i, n, r, a, s));
    }, t;
  })(Pi)
);
function zs(e) {
  return e.__ecRoamConsumed;
}
var S3 = Gt();
function zc(e) {
  var t = S3(e);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function Vs(e, t, i, n) {
  for (var r = zc(e), a = r.roam, s = a[t] = a[t] || [], o = 0; o < s.length; o++) {
    var l = s[o].zInfoParsed;
    if ((l.zlevel - n.zlevel || l.z - n.z || l.z2 - n.z2) <= 0)
      break;
  }
  s.splice(o, 0, {
    listener: i,
    zInfoParsed: n
  }), M3(e, t);
}
function Hs(e, t, i) {
  for (var n = zc(e), r = n.roam[t] || [], a = 0; a < r.length; a++)
    if (r[a].listener === i) {
      r.splice(a, 1), r.length || k3(e, t);
      return;
    }
}
function M3(e, t) {
  var i = zc(e);
  i.uniform[t] || e.on(t, i.uniform[t] = function(n) {
    var r = i.roam[t];
    if (r)
      for (var a = 0; a < r.length; a++)
        r[a].listener(n);
  });
}
function k3(e, t) {
  var i = zc(e), n = i.uniform;
  n[t] && (e.off(t, n[t]), n[t] = null);
}
function My(e, t, i, n, r) {
  r.isAvailableBehavior = Dt(fu, null, i, n), e.trigger(t, r);
}
function fu(e, t, i) {
  var n = i[e];
  return !e || n && (!tt(n) || t.event[n + "Key"]);
}
var D3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: St.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: St.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: St.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: St.color.tertiary,
        fontSize: 14
      }
    }, t;
  })(Et)
);
function Jw(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function tS(e) {
  if (st.domSupported) {
    for (var t = document.documentElement.style, i = 0, n = e.length; i < n; i++)
      if (e[i] in t)
        return e[i];
  }
}
var eS = tS(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), T3 = tS(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function iS(e, t) {
  if (!e)
    return t;
  t = Dx(t, !0);
  var i = e.indexOf(t);
  return e = i === -1 ? t : "-" + e.slice(0, i) + "-" + t, e.toLowerCase();
}
function C3(e, t) {
  var i = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return i ? i[t] : null;
}
var A3 = iS(T3, "transition"), _p = iS(eS, "transform"), P3 = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (st.transform3dSupported ? "will-change:transform;" : "");
function E3(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function L3(e, t, i) {
  if (!tt(i) || i === "inside")
    return "";
  var n = e.get("backgroundColor"), r = e.get("borderWidth");
  t = No(t);
  var a = E3(i), s = Math.max(Math.round(r) * 1.5, 6), o = "", l = _p + ":", u;
  Vt(["left", "right"], a) > -1 ? (o += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (o += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = s + r, d = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), f = Math.round(((d - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (d - h) / 2) * 100) / 100;
  o += ";" + a + ":-" + f + "px";
  var v = t + " solid " + r + "px;", p = ["position:absolute;width:" + s + "px;height:" + s + "px;z-index:-1;", o + ";" + l + ";", "border-bottom:" + v, "border-right:" + v, "background-color:" + n + ";"];
  return '<div style="' + p.join("") + '"></div>';
}
function O3(e, t, i) {
  var n = "cubic-bezier(0.23,1,0.32,1)", r = "", a = "";
  return i && (r = " " + e / 2 + "s " + n, a = "opacity" + r + ",visibility" + r), t || (r = " " + e + "s " + n, a += (a.length ? "," : "") + (st.transformSupported ? "" + _p + r : ",left" + r + ",top" + r)), A3 + ":" + a;
}
function ky(e, t, i) {
  var n = e.toFixed(0) + "px", r = t.toFixed(0) + "px";
  if (!st.transformSupported)
    return i ? "top:" + r + ";left:" + n + ";" : [["top", r], ["left", n]];
  var a = st.transform3dSupported, s = "translate" + (a ? "3d" : "") + "(" + n + "," + r + (a ? ",0" : "") + ")";
  return i ? "top:0;left:0;" + _p + ":" + s + ";" : [["top", 0], ["left", 0], [eS, s]];
}
function I3(e) {
  var t = [], i = e.get("fontSize"), n = e.getTextColor();
  n && t.push("color:" + n), t.push("font:" + e.getFont());
  var r = nt(e.get("lineHeight"), Math.round(i * 3 / 2));
  i && t.push("line-height:" + r + "px");
  var a = e.get("textShadowColor"), s = e.get("textShadowBlur") || 0, o = e.get("textShadowOffsetX") || 0, l = e.get("textShadowOffsetY") || 0;
  return a && s && t.push("text-shadow:" + o + "px " + l + "px " + s + "px " + a), A(["decoration", "align"], function(u) {
    var c = e.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function R3(e, t, i, n) {
  var r = [], a = e.get("transitionDuration"), s = e.get("backgroundColor"), o = e.get("shadowBlur"), l = e.get("shadowColor"), u = e.get("shadowOffsetX"), c = e.get("shadowOffsetY"), h = e.getModel("textStyle"), d = tw(e, "html"), f = u + "px " + c + "px " + o + "px " + l;
  return r.push("box-shadow:" + f), t && a > 0 && r.push(O3(a, i, n)), s && r.push("background-color:" + s), A(["width", "color", "radius"], function(v) {
    var p = "border-" + v, g = Dx(p), m = e.get(g);
    m != null && r.push(p + ":" + m + (v === "color" ? "" : "px"));
  }), r.push(I3(h)), d != null && r.push("padding:" + tp(d).join("px ") + "px"), r.join(";") + ";";
}
function Dy(e, t, i, n, r) {
  var a = t && t.painter;
  if (i) {
    var s = a && a.getViewportRoot();
    s && cE(e, s, i, n, r);
  } else {
    e[0] = n, e[1] = r;
    var o = a && a.getViewportRootOffset();
    o && (e[0] += o.offsetLeft, e[1] += o.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var N3 = (
  /** @class */
  (function() {
    function e(t, i) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, st.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var r = this._zr = t.getZr(), a = i.appendTo, s = a && (tt(a) ? document.querySelector(a) : rs(a) ? a : mt(a) && a(t.getDom()));
      Dy(this._styleCoord, r, s, t.getWidth() / 2, t.getHeight() / 2), (s || t.getDom()).appendChild(n), this._api = t, this._container = s;
      var o = this;
      n.onmouseenter = function() {
        o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !o._enterable) {
          var u = r.handler, c = r.painter.getViewportRoot();
          ai(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        o._inContent = !1, o._enterable && o._show && o.hideLater(o._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var i = this._api.getDom(), n = C3(i, "position"), r = i.style;
        r.position !== "absolute" && n !== "absolute" && (r.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, i) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, r = n.style, a = this._styleCoord;
      n.innerHTML ? r.cssText = P3 + R3(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + ky(a[0], a[1], !0) + ("border-color:" + No(i) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var s = this.el;
      if (t == null) {
        s.innerHTML = "";
        return;
      }
      var o = "";
      if (tt(a) && n.get("trigger") === "item" && !Jw(n) && (o = L3(n, r, a)), tt(t))
        s.innerHTML = t + o;
      else if (t) {
        s.innerHTML = "", Z(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          rs(t[l]) && t[l].parentNode !== s && s.appendChild(t[l]);
        if (o && s.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = o, s.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, e.prototype.moveTo = function(t, i) {
      if (this.el) {
        var n = this._styleCoord;
        if (Dy(n, this._zr, this._container, t, i), n[0] != null && n[1] != null) {
          var r = this.el.style, a = ky(n[0], n[1]);
          A(a, function(s) {
            r[s[0]] = s[1];
          });
        }
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, i = this.el.style;
      this._enableDisplayTransition ? (i.visibility = "hidden", i.opacity = "0") : i.display = "none", st.transform3dSupported && (i.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Dt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      hE(t && t.painter && t.painter.getViewportRoot(), this._container);
      var i = this.el;
      if (i) {
        i.onmouseenter = i.onmousemove = i.onmouseleave = null;
        var n = i.parentNode;
        n && n.removeChild(i);
      }
      this.el = this._container = null;
    }, e;
  })()
), F3 = (
  /** @class */
  (function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), Cy(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var i = t.get("alwaysShowContent");
      i && this._moveIfResized(), this._alwaysShowContent = i;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var s = this;
      Q(t) && Ye(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var o = n.getModel("textStyle");
      this.el = new mi({
        style: {
          rich: i.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: r,
          textShadowColor: o.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: tw(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), A(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        s.el.style[u] = n.get(u);
      }), A(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        s.el.style[u] = o.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, i = this.el.getBoundingRect(), n = Ty(t.style);
      return [i.width + n.left + n.right, i.height + n.top + n.bottom];
    }, e.prototype.moveTo = function(t, i) {
      var n = this.el;
      if (n) {
        var r = this._styleCoord;
        Cy(r, this._zr, t, i), t = r[0], i = r[1];
        var a = n.style, s = $n(a.borderWidth || 0), o = Ty(a);
        n.x = t + s + o.left, n.y = i + s + o.top, n.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Dt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  })()
);
function $n(e) {
  return Math.max(0, e);
}
function Ty(e) {
  var t = $n(e.shadowBlur || 0), i = $n(e.shadowOffsetX || 0), n = $n(e.shadowOffsetY || 0);
  return {
    left: $n(t - i),
    right: $n(t + i),
    top: $n(t - n),
    bottom: $n(t + n)
  };
}
function Cy(e, t, i, n) {
  e[0] = i, e[1] = n, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var B3 = new De({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), $3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.init = function(i, n) {
      if (!(st.node || !n.getDom())) {
        var r = i.getComponent("tooltip"), a = this._renderMode = WL(r.get("renderMode"));
        this._tooltipContent = a === "richText" ? new F3(n) : new N3(n, {
          appendTo: r.get("appendToBody", !0) ? "body" : r.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(i, n, r) {
      if (!(st.node || !r.getDom())) {
        this.group.removeAll(), this._tooltipModel = i, this._ecModel = n, this._api = r;
        var a = this._tooltipContent;
        a.update(i), a.setEnterable(i.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && i.get("transitionDuration") ? nw(this, "_updatePosition", 50, "fixRate") : Pf(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var i = this._tooltipModel, n = i.get("triggerOn");
      Zw("itemTooltip", this._api, Dt(function(r, a, s) {
        n !== "none" && (n.indexOf(r) >= 0 ? this._tryShow(a, s) : r === "leave" && this._hide(s));
      }, this));
    }, t.prototype._keepShow = function() {
      var i = this._tooltipModel, n = this._ecModel, r = this._api, a = i.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var s = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !r.isDisposed() && s.manuallyShowTip(i, n, r, {
            x: s._lastX,
            y: s._lastY,
            dataByCoordSys: s._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(i, n, r, a) {
      if (!(a.from === this.uid || st.node || !r.getDom())) {
        var s = Ay(a, r);
        this._ticket = "";
        var o = a.dataByCoordSys, l = Y3(a, n, r);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, s);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = B3;
          c.x = a.x, c.y = a.y, c.update(), zt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, s);
        } else if (o)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: o,
            tooltipOption: a.tooltipOption
          }, s);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(i, n, r, a))
            return;
          var h = Kw(a, n), d = h.point[0], f = h.point[1];
          d != null && f != null && this._tryShow({
            offsetX: d,
            offsetY: f,
            target: h.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, s);
        } else a.x != null && a.y != null && (r.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: r.getZr().findHover(a.x, a.y).target
        }, s));
      }
    }, t.prototype.manuallyHideTip = function(i, n, r, a) {
      var s = this._tooltipContent;
      this._tooltipModel && s.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(Ay(a, r));
    }, t.prototype._manuallyAxisShowTip = function(i, n, r, a) {
      var s = a.seriesIndex, o = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(s == null || o == null || l == null)) {
        var u = n.getSeriesByIndex(s);
        if (u) {
          var c = u.getData(), h = Ys([c.getItemModel(o), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return r.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: s,
              dataIndex: o,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(i, n) {
      var r = i.target, a = this._tooltipModel;
      if (a) {
        this._lastX = i.offsetX, this._lastY = i.offsetY;
        var s = i.dataByCoordSys;
        if (s && s.length)
          this._showAxisTooltip(s, i);
        else if (r) {
          var o = zt(r);
          if (o.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          no(r, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (zt(c).dataIndex != null ? l = c : zt(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(i, l, n) : u ? this._showComponentItemTooltip(i, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(i, n) {
      var r = i.get("showDelay");
      n = Dt(n, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(n, r) : n();
    }, t.prototype._showAxisTooltip = function(i, n) {
      var r = this._ecModel, a = this._tooltipModel, s = [n.offsetX, n.offsetY], o = Ys([n.tooltipOption], a), l = this._renderMode, u = [], c = oa("section", {
        blocks: [],
        noHeader: !0
      }), h = [], d = new cd();
      A(i, function(_) {
        A(_.dataByAxis, function(y) {
          var b = r.getComponent(y.axisDim + "Axis", y.axisIndex), w = y.value;
          if (!(!b || w == null)) {
            var S = jw(w, b.axis, r, y.seriesDataIndices, y.valueLabelOpt), M = oa("section", {
              header: S,
              noHeader: !Ui(S),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(M), A(y.seriesDataIndices, function(k) {
              var T = r.getSeriesByIndex(k.seriesIndex), C = k.dataIndexInside, D = T.getDataParams(C);
              if (!(D.dataIndex < 0)) {
                D.axisDim = y.axisDim, D.axisIndex = y.axisIndex, D.axisType = y.axisType, D.axisId = y.axisId, D.axisValue = zw(b.axis, {
                  value: w
                }), D.axisValueLabel = S, D.marker = d.makeTooltipMarker("item", No(D.color), l);
                var P = p_(T.formatTooltip(C, !0, null)), O = P.frag;
                if (O) {
                  var I = Ys([T], a).get("valueFormatter");
                  M.blocks.push(I ? Y({
                    valueFormatter: I
                  }, O) : O);
                }
                P.text && h.push(P.text), u.push(D);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var f = n.position, v = o.get("order"), p = b_(c, d, l, v, r.get("useUTC"), o.get("textStyle"));
      p && h.unshift(p);
      var g = l === "richText" ? `

` : "<br/>", m = h.join(g);
      this._showOrMove(o, function() {
        this._updateContentNotChangedOnAxis(i, u) ? this._updatePosition(o, f, s[0], s[1], this._tooltipContent, u) : this._showTooltipContent(o, m, u, Math.random() + "", s[0], s[1], f, null, d);
      });
    }, t.prototype._showSeriesItemTooltip = function(i, n, r) {
      var a = this._ecModel, s = zt(n), o = s.seriesIndex, l = a.getSeriesByIndex(o), u = s.dataModel || l, c = s.dataIndex, h = s.dataType, d = u.getData(h), f = this._renderMode, v = i.positionDefault, p = Ys([d.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, v ? {
        position: v
      } : null), g = p.get("trigger");
      if (!(g != null && g !== "item")) {
        var m = u.getDataParams(c, h), _ = new cd();
        m.marker = _.makeTooltipMarker("item", No(m.color), f);
        var y = p_(u.formatTooltip(c, !1, h)), b = p.get("order"), w = p.get("valueFormatter"), S = y.frag, M = S ? b_(w ? Y({
          valueFormatter: w
        }, S) : S, _, f, b, a.get("useUTC"), p.get("textStyle")) : y.text, k = "item_" + u.name + "_" + c;
        this._showOrMove(p, function() {
          this._showTooltipContent(p, M, m, k, i.offsetX, i.offsetY, i.position, i.target, _);
        }), r({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: d.getRawIndex(c),
          seriesIndex: o,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(i, n, r) {
      var a = this._renderMode === "html", s = zt(n), o = s.tooltipConfig, l = o.option || {}, u = l.encodeHTMLContent;
      if (tt(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = pt(l), l.content = ze(l.content));
      var h = [l], d = this._ecModel.getComponent(s.componentMainType, s.componentIndex);
      d && h.push(d), h.push({
        formatter: l.content
      });
      var f = i.positionDefault, v = Ys(h, this._tooltipModel, f ? {
        position: f
      } : null), p = v.get("content"), g = Math.random() + "", m = new cd();
      this._showOrMove(v, function() {
        var _ = pt(v.get("formatterParams") || {});
        this._showTooltipContent(v, p, _, g, i.offsetX, i.offsetY, i.position, n, m);
      }), r({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(i, n, r, a, s, o, l, u, c) {
      if (this._ticket = "", !(!i.get("showContent") || !i.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(i.get("enterable"));
        var d = i.get("formatter");
        l = l || i.get("position");
        var f = n, v = this._getNearestPoint([s, o], r, i.get("trigger"), i.get("borderColor"), i.get("defaultBorderColor", !0)), p = v.color;
        if (d)
          if (tt(d)) {
            var g = i.ecModel.get("useUTC"), m = Z(r) ? r[0] : r, _ = m && m.axisType && m.axisType.indexOf("time") >= 0;
            f = d, _ && (f = kx(m.axisValue, f, g)), f = Tx(f, r, !0);
          } else if (mt(d)) {
            var y = Dt(function(b, w) {
              b === this._ticket && (h.setContent(w, c, i, p, l), this._updatePosition(i, l, s, o, h, r, u));
            }, this);
            this._ticket = a, f = d(r, a, y);
          } else
            f = d;
        h.setContent(f, c, i, p, l), h.show(i, p), this._updatePosition(i, l, s, o, h, r, u);
      }
    }, t.prototype._getNearestPoint = function(i, n, r, a, s) {
      if (r === "axis" || Z(n))
        return {
          color: a || s
        };
      if (!Z(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(i, n, r, a, s, o, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || i.get("position");
      var h = s.getSize(), d = i.get("align"), f = i.get("verticalAlign"), v = l && l.getBoundingRect().clone();
      if (l && v.applyTransform(l.transform), mt(n) && (n = n([r, a], o, s.el, v, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), Z(n))
        r = He(n[0], u), a = He(n[1], c);
      else if (Q(n)) {
        var p = n;
        p.width = h[0], p.height = h[1];
        var g = ep(p, {
          width: u,
          height: c
        });
        r = g.x, a = g.y, d = null, f = null;
      } else if (tt(n) && l) {
        var m = H3(n, v, h, i.get("borderWidth"));
        r = m[0], a = m[1];
      } else {
        var m = z3(r, a, s, u, c, d ? null : 20, f ? null : 20);
        r = m[0], a = m[1];
      }
      if (d && (r -= Py(d) ? h[0] / 2 : d === "right" ? h[0] : 0), f && (a -= Py(f) ? h[1] / 2 : f === "bottom" ? h[1] : 0), Jw(i)) {
        var m = V3(r, a, s, u, c);
        r = m[0], a = m[1];
      }
      s.moveTo(r, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(i, n) {
      var r = this._lastDataByCoordSys, a = this._cbParamsList, s = !!r && r.length === i.length;
      return s && A(r, function(o, l) {
        var u = o.dataByAxis || [], c = i[l] || {}, h = c.dataByAxis || [];
        s = s && u.length === h.length, s && A(u, function(d, f) {
          var v = h[f] || {}, p = d.seriesDataIndices || [], g = v.seriesDataIndices || [];
          s = s && d.value === v.value && d.axisType === v.axisType && d.axisId === v.axisId && p.length === g.length, s && A(p, function(m, _) {
            var y = g[_];
            s = s && m.seriesIndex === y.seriesIndex && m.dataIndex === y.dataIndex;
          }), a && A(d.seriesDataIndices, function(m) {
            var _ = m.seriesIndex, y = n[_], b = a[_];
            y && b && b.data !== y.data && (s = !1);
          });
        });
      }), this._lastDataByCoordSys = i, this._cbParamsList = n, !!s;
    }, t.prototype._hide = function(i) {
      this._lastDataByCoordSys = null, i({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(i, n) {
      st.node || !n.getDom() || (Pf(this, "_updatePosition"), this._tooltipContent.dispose(), Hf("itemTooltip", n));
    }, t.type = "tooltip", t;
  })(Tn)
);
function Ys(e, t, i) {
  var n = t.ecModel, r;
  i ? (r = new jt(i, n, n), r = new jt(t.option, r, n)) : r = t;
  for (var a = e.length - 1; a >= 0; a--) {
    var s = e[a];
    s && (s instanceof jt && (s = s.get("tooltip", !0)), tt(s) && (s = {
      formatter: s
    }), s && (r = new jt(s, r, n)));
  }
  return r;
}
function Ay(e, t) {
  return e.dispatchAction || Dt(t.dispatchAction, t);
}
function z3(e, t, i, n, r, a, s) {
  var o = i.getSize(), l = o[0], u = o[1];
  return a != null && (e + l + a + 2 > n ? e -= l + a : e += a), s != null && (t + u + s > r ? t -= u + s : t += s), [e, t];
}
function V3(e, t, i, n, r) {
  var a = i.getSize(), s = a[0], o = a[1];
  return e = Math.min(e + s, n) - s, t = Math.min(t + o, r) - o, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function H3(e, t, i, n) {
  var r = i[0], a = i[1], s = Math.ceil(Math.SQRT2 * n) + 8, o = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      o = t.x + u / 2 - r / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      o = t.x + u / 2 - r / 2, l = t.y - a - s;
      break;
    case "bottom":
      o = t.x + u / 2 - r / 2, l = t.y + c + s;
      break;
    case "left":
      o = t.x - r - s, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      o = t.x + u + s, l = t.y + c / 2 - a / 2;
  }
  return [o, l];
}
function Py(e) {
  return e === "center" || e === "middle";
}
function Y3(e, t, i) {
  var n = Cv(e).queryOptionMap, r = n.keys()[0];
  if (!(!r || r === "series")) {
    var a = Zo(t, r, n.get(r), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), s = a.models[0];
    if (s) {
      var o = i.getViewOfComponentModel(s), l;
      if (o.group.traverse(function(u) {
        var c = zt(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: r,
          componentIndex: s.componentIndex,
          el: l
        };
    }
  }
}
function W3(e) {
  fp(f3), e.registerComponentModel(D3), e.registerComponentView($3), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, ke), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, ke);
}
var Vo = A, U3 = Q, oc = -1, yp = (
  /** @class */
  (function() {
    function e(t) {
      var i = t.mappingMethod, n = t.type, r = this.option = pt(t);
      this.type = n, this.mappingMethod = i, this._normalizeData = j3[i];
      var a = e.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[i], i === "piecewise" ? (Dd(r), G3(r)) : i === "category" ? r.categories ? X3(r) : Dd(r, !0) : (it(i !== "linear" || r.dataExtent), Dd(r));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var i = this._normalizeData(t);
      return this._normalizedToVisual(i, t);
    }, e.prototype.getNormalizer = function() {
      return Dt(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return qt(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, i, n) {
      Q(t) ? A(t, i, n) : i.call(n, t);
    }, e.mapVisual = function(t, i, n) {
      var r, a = Z(t) ? [] : Q(t) ? {} : (r = !0, null);
      return e.eachVisual(t, function(s, o) {
        var l = i.call(n, s, o);
        r ? a = l : a[o] = l;
      }), a;
    }, e.retrieveVisuals = function(t) {
      var i = {}, n;
      return t && Vo(e.visualHandlers, function(r, a) {
        t.hasOwnProperty(a) && (i[a] = t[a], n = !0);
      }), n ? i : null;
    }, e.prepareVisualTypes = function(t) {
      if (Z(t))
        t = t.slice();
      else if (U3(t)) {
        var i = [];
        Vo(t, function(n, r) {
          i.push(r);
        }), t = i;
      } else
        return [];
      return t.sort(function(n, r) {
        return r === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, i) {
      return i === "color" ? !!(t && t.indexOf(i) === 0) : t === i;
    }, e.findPieceIndex = function(t, i, n) {
      for (var r, a = 1 / 0, s = 0, o = i.length; s < o; s++) {
        var l = i[s].value;
        if (l != null) {
          if (l === t || tt(l) && l === t + "")
            return s;
          n && d(l, s);
        }
      }
      for (var s = 0, o = i.length; s < o; s++) {
        var u = i[s], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (Zl(h[1], t, c[1]))
              return s;
          } else if (c[1] === 1 / 0) {
            if (Zl(h[0], c[0], t))
              return s;
          } else if (Zl(h[0], c[0], t) && Zl(h[1], t, c[1]))
            return s;
          n && d(c[0], s), n && d(c[1], s);
        }
      }
      if (n)
        return t === 1 / 0 ? i.length - 1 : t === -1 / 0 ? 0 : r;
      function d(f, v) {
        var p = Math.abs(f - t);
        p < a && (a = p, r = v);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: Ws("color"),
        getColorMapper: function() {
          var t = this.option;
          return Dt(t.mappingMethod === "category" ? function(i, n) {
            return !n && (i = this._normalizeData(i)), ao.call(this, i);
          } : function(i, n, r) {
            var a = !!r;
            return !n && (i = this._normalizeData(i)), r = wh(i, t.parsedVisual, r), a ? r : Qr(r, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return Qr(wh(t, this.option.parsedVisual), "rgba");
          },
          category: ao,
          piecewise: function(t, i) {
            var n = Wf.call(this, i);
            return n == null && (n = Qr(wh(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: Fr
        }
      },
      colorHue: ql(function(t, i) {
        return Za(t, i);
      }),
      colorSaturation: ql(function(t, i) {
        return Za(t, null, i);
      }),
      colorLightness: ql(function(t, i) {
        return Za(t, null, null, i);
      }),
      colorAlpha: ql(function(t, i) {
        return GE(t, i);
      }),
      decal: {
        applyVisual: Ws("decal"),
        _normalizedToVisual: {
          linear: null,
          category: ao,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: Ws("opacity"),
        _normalizedToVisual: Yf([0, 1])
      },
      liftZ: {
        applyVisual: Ws("liftZ"),
        _normalizedToVisual: {
          linear: Fr,
          category: Fr,
          piecewise: Fr,
          fixed: Fr
        }
      },
      symbol: {
        applyVisual: function(t, i, n) {
          var r = this.mapValueToVisual(t);
          n("symbol", r);
        },
        _normalizedToVisual: {
          linear: Ey,
          category: ao,
          piecewise: function(t, i) {
            var n = Wf.call(this, i);
            return n == null && (n = Ey.call(this, t)), n;
          },
          fixed: Fr
        }
      },
      symbolSize: {
        applyVisual: Ws("symbolSize"),
        _normalizedToVisual: Yf([0, 1])
      }
    }, e;
  })()
);
function G3(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, A(t, function(i, n) {
    i.originIndex = n, i.visual != null && (e.hasSpecialVisual = !0);
  });
}
function X3(e) {
  var t = e.categories, i = e.categoryMap = {}, n = e.visual;
  if (Vo(t, function(s, o) {
    i[s] = o;
  }), !Z(n)) {
    var r = [];
    Q(n) ? Vo(n, function(s, o) {
      var l = i[o];
      r[l ?? oc] = s;
    }) : r[oc] = n, n = nS(e, r);
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete i[t[a]], t.pop());
}
function Dd(e, t) {
  var i = e.visual, n = [];
  Q(i) ? Vo(i, function(a) {
    n.push(a);
  }) : i != null && n.push(i);
  var r = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !r.hasOwnProperty(e.type) && (n[1] = n[0]), nS(e, n);
}
function ql(e) {
  return {
    applyVisual: function(t, i, n) {
      var r = this.mapValueToVisual(t);
      n("color", e(i("color"), r));
    },
    _normalizedToVisual: Yf([0, 1])
  };
}
function Ey(e) {
  var t = this.option.visual;
  return t[Math.round(Lo(e, [0, 1], [0, t.length - 1]))] || {};
}
function Ws(e) {
  return function(t, i, n) {
    n(e, this.mapValueToVisual(t));
  };
}
function ao(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== oc ? e % t.length : e];
}
function Fr() {
  return this.option.visual[0];
}
function Yf(e) {
  return {
    linear: function(t) {
      return Lo(t, e, this.option.visual);
    },
    category: ao,
    piecewise: function(t, i) {
      var n = Wf.call(this, i);
      return n == null && (n = Lo(t, e, this.option.visual)), n;
    },
    fixed: Fr
  };
}
function Wf(e) {
  var t = this.option, i = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = yp.findPieceIndex(e, i), r = i[n];
    if (r && r.visual)
      return r.visual[this.type];
  }
}
function nS(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = yt(t, function(i) {
    var n = xn(i);
    return !n && process.env.NODE_ENV !== "production" && ui("'" + i + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var j3 = {
  linear: function(e) {
    return Lo(e, this.option.dataExtent, [0, 1]);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, i = yp.findPieceIndex(e, t, !0);
    if (i != null)
      return Lo(i, [0, t.length - 1], [0, 1]);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? oc;
  },
  fixed: ke
};
function Zl(e, t, i) {
  return e ? t <= i : t < i;
}
var q3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, i;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: St.size.m,
      backgroundColor: St.color.transparent,
      borderColor: St.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: St.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: St.color.quaternary
      }
    }, t;
  })(Et)
), Z3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      if (this.group.removeAll(), !!i.get("show")) {
        var a = this.group, s = i.getModel("textStyle"), o = i.getModel("subtextStyle"), l = i.get("textAlign"), u = nt(i.get("textBaseline"), i.get("textVerticalAlign")), c = new mi({
          style: sa(s, {
            text: i.get("text"),
            fill: s.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), d = i.get("subtext"), f = new mi({
          style: sa(o, {
            text: d,
            fill: o.getTextColor(),
            y: h.height + i.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), v = i.get("link"), p = i.get("sublink"), g = i.get("triggerEvent", !0);
        c.silent = !v && !g, f.silent = !p && !g, v && c.on("click", function() {
          q0(v, "_" + i.get("target"));
        }), p && f.on("click", function() {
          q0(p, "_" + i.get("subtarget"));
        }), zt(c).eventData = zt(f).eventData = g ? {
          componentType: "title",
          componentIndex: i.componentIndex
        } : null, a.add(c), d && a.add(f);
        var m = a.getBoundingRect(), _ = i.getBoxLayoutParams();
        _.width = m.width, _.height = m.height;
        var y = Ax(i, r), b = ep(_, y.refContainer, i.get("padding"));
        l || (l = i.get("left") || i.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = i.get("top") || i.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), a.x = b.x, a.y = b.y, a.markRedraw();
        var w = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(w), f.setStyle(w), m = a.getBoundingRect();
        var S = b.margin, M = i.getItemStyle(["color", "opacity"]);
        M.fill = i.get("backgroundColor");
        var k = new De({
          shape: {
            x: m.x - S[3],
            y: m.y - S[0],
            width: m.width + S[1] + S[3],
            height: m.height + S[0] + S[2],
            r: i.get("borderRadius")
          },
          style: M,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(k);
      }
    }, t.type = "title", t;
  })(Tn)
);
function K3(e) {
  e.registerComponentModel(q3), e.registerComponentView(Z3);
}
var pi = Gt();
function Q3(e) {
  var t = e.mainData, i = e.datas;
  i || (i = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, rS(t, i, e), A(i, function(n) {
    A(t.TRANSFERABLE_METHODS, function(r) {
      n.wrapMethod(r, Oe(J3, e));
    });
  }), t.wrapMethod("cloneShallow", Oe(e4, e)), A(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, Oe(t4, e));
  }), it(i[t.dataType] === t);
}
function J3(e, t) {
  if (r4(this)) {
    var i = Y({}, pi(this).datas);
    i[this.dataType] = t, rS(t, i, e);
  } else
    bp(t, this.dataType, pi(this).mainData, e);
  return t;
}
function t4(e, t) {
  return e.struct && e.struct.update(), t;
}
function e4(e, t) {
  return A(pi(t).datas, function(i, n) {
    i !== t && bp(i.cloneShallow(), n, t, e);
  }), t;
}
function i4(e) {
  var t = pi(this).mainData;
  return e == null || t == null ? t : pi(t).datas[e];
}
function n4() {
  var e = pi(this).mainData;
  return e == null ? [{
    data: e
  }] : yt(qt(pi(e).datas), function(t) {
    return {
      type: t,
      data: pi(e).datas[t]
    };
  });
}
function r4(e) {
  return pi(e).mainData === e;
}
function rS(e, t, i) {
  pi(e).datas = {}, A(t, function(n, r) {
    bp(n, r, e, i);
  });
}
function bp(e, t, i, n) {
  pi(i).datas[t] = e, pi(e).mainData = i, e.dataType = t, n.struct && (e[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = e), e.getLinkedData = i4, e.getLinkedDataAll = n4;
}
function Ra(e) {
  return "_EC_" + e;
}
var a4 = (
  /** @class */
  (function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, i) {
      t = t == null ? "" + i : "" + t;
      var n = this._nodesMap;
      if (n[Ra(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var r = new Br(t, i);
      return r.hostGraph = this, this.nodes.push(r), n[Ra(t)] = r, r;
    }, e.prototype.getNodeByIndex = function(t) {
      var i = this.data.getRawIndex(t);
      return this.nodes[i];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[Ra(t)];
    }, e.prototype.addEdge = function(t, i, n) {
      var r = this._nodesMap, a = this._edgesMap;
      if (Zt(t) && (t = this.nodes[t]), Zt(i) && (i = this.nodes[i]), t instanceof Br || (t = r[Ra(t)]), i instanceof Br || (i = r[Ra(i)]), !(!t || !i)) {
        var s = t.id + "-" + i.id, o = new aS(t, i, n);
        return o.hostGraph = this, this._directed && (t.outEdges.push(o), i.inEdges.push(o)), t.edges.push(o), t !== i && i.edges.push(o), this.edges.push(o), a[s] = o, o;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var i = this.edgeData.getRawIndex(t);
      return this.edges[i];
    }, e.prototype.getEdge = function(t, i) {
      t instanceof Br && (t = t.id), i instanceof Br && (i = i.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + i] : n[t + "-" + i] || n[i + "-" + t];
    }, e.prototype.eachNode = function(t, i) {
      for (var n = this.nodes, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.eachEdge = function(t, i) {
      for (var n = this.edges, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.breadthFirstTraverse = function(t, i, n, r) {
      if (i instanceof Br || (i = this._nodesMap[Ra(i)]), !!i) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++)
          this.nodes[s].__visited = !1;
        if (!t.call(r, i, null))
          for (var o = [i]; o.length; )
            for (var l = o.shift(), u = l[a], s = 0; s < u.length; s++) {
              var c = u[s], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (t.call(r, h, l))
                  return;
                o.push(h), h.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, i = this.edgeData, n = this.nodes, r = this.edges, a = 0, s = n.length; a < s; a++)
        n[a].dataIndex = -1;
      for (var a = 0, s = t.count(); a < s; a++)
        n[t.getRawIndex(a)].dataIndex = a;
      i.filterSelf(function(o) {
        var l = r[i.getRawIndex(o)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, s = r.length; a < s; a++)
        r[a].dataIndex = -1;
      for (var a = 0, s = i.count(); a < s; a++)
        r[i.getRawIndex(a)].dataIndex = a;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), i = this.nodes, n = this.edges, r = 0; r < i.length; r++)
        t.addNode(i[r].id, i[r].dataIndex);
      for (var r = 0; r < n.length; r++) {
        var a = n[r];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, e;
  })()
), Br = (
  /** @class */
  (function() {
    function e(t, i) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = i ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, i = 0; i < this.edges.length; i++) {
        var n = this.edges[i];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = ct(), i = ct(), n = 0, r = this.edges.length; n < r; n++) {
        var a = this.edges[n];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var s = [a.node1], o = [a.node2], l = 0; l < s.length; ) {
            var u = s[l];
            l++, i.set(u.dataIndex, !0);
            for (var c = u.inEdges, h = 0, d = c.length, f = void 0, v = void 0; h < d; h++)
              f = c[h], v = f.dataIndex, v >= 0 && !t.hasKey(v) && (t.set(v, !0), s.push(f.node1));
          }
          for (l = 0; l < o.length; ) {
            var p = o[l];
            l++, i.set(p.dataIndex, !0);
            for (var g = p.outEdges, h = 0, m = g.length, _ = void 0, y = void 0; h < m; h++)
              _ = g[h], y = _.dataIndex, y >= 0 && !t.hasKey(y) && (t.set(y, !0), o.push(_.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
), aS = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = i, this.dataIndex = n ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = ct(), i = ct();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], r = [this.node2], a = 0; a < n.length; ) {
        var s = n[a];
        a++, i.set(s.dataIndex, !0);
        for (var o = s.inEdges, l = 0, u = o.length, c = void 0, h = void 0; l < u; l++)
          c = s.inEdges[l], h = c.dataIndex, h >= 0 && !t.hasKey(h) && (t.set(h, !0), n.push(c.node1));
      }
      for (a = 0; a < r.length; ) {
        var d = r[a];
        a++, i.set(d.dataIndex, !0);
        for (var f = d.outEdges, l = 0, u = f.length, v = void 0, p = void 0; l < u; l++)
          v = d.outEdges[l], p = v.dataIndex, p >= 0 && !t.hasKey(p) && (t.set(p, !0), r.push(v.node2));
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
);
function sS(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(i) {
      var n = this[e][t];
      return n.getStore().get(n.getDimensionIndex(i || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, i, n);
    },
    getVisual: function(i) {
      return this[e][t].getItemVisual(this.dataIndex, i);
    },
    setLayout: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, i, n);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
Ai(Br, sS("hostGraph", "data"));
Ai(aS, sS("hostGraph", "edgeData"));
function s4(e, t, i, n, r) {
  for (var a = new a4(n), s = 0; s < e.length; s++)
    a.addNode(ir(
      // Id, name, dataIndex
      e[s].id,
      e[s].name,
      s
    ), s);
  for (var o = [], l = [], u = 0, s = 0; s < t.length; s++) {
    var c = t[s], h = c.source, d = c.target;
    a.addEdge(h, d, u) && (l.push(c), o.push(ir(ki(c.id, null), h + " > " + d)), u++);
  }
  var f = i.get("coordinateSystem"), v;
  if (f === "cartesian2d" || f === "polar" || f === "matrix")
    v = nB(e, i);
  else {
    var p = Nc.get(f), g = p ? p.dimensions || [] : [];
    Vt(g, "value") < 0 && g.concat(["value"]);
    var m = $w(e, {
      coordDimensions: g,
      encodeDefine: i.getEncode()
    }).dimensions;
    v = new $f(m, i), v.initData(e);
  }
  var _ = new $f(["value"], i);
  return _.initData(l, o), r && r(v, _), Q3({
    mainData: v,
    struct: a,
    structAttr: "graph",
    datas: {
      node: v,
      edge: _
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var o4 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  })()
), l4 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i) {
      return e.call(this, i) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new o4();
    }, t.prototype.buildPath = function(i, n) {
      var r = n.extent;
      i.moveTo(n.x1, n.y1), i.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (i.lineTo(n.x2 + r, n.y2), i.bezierCurveTo(n.cpx2 + r, n.cpy2, n.cpx1 + r, n.cpy1, n.x1 + r, n.y1)) : (i.lineTo(n.x2, n.y2 + r), i.bezierCurveTo(n.cpx2, n.cpy2 + r, n.cpx1, n.cpy1 + r, n.x1, n.y1 + r)), i.closePath();
    }, t.prototype.highlight = function() {
      Vu(this);
    }, t.prototype.downplay = function() {
      Hu(this);
    }, t;
  })(Bt)
), u4 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i._mainGroup = new Di(), i._focusAdjacencyDisabled = !1, i;
    }
    return t.prototype.init = function(i, n) {
      this._controller = new w3(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(i, n, r) {
      var a = this, s = i.getGraph(), o = this._mainGroup, l = i.layoutInfo, u = l.width, c = l.height, h = i.getData(), d = i.getData("edge"), f = i.get("orient");
      this._model = i, o.removeAll(), o.x = l.x, o.y = l.y, this._updateViewCoordSys(i, r), g3(i, r, o, this._controller, this._controllerHost), s.eachEdge(function(v) {
        var p = new l4(), g = zt(p);
        g.dataIndex = v.dataIndex, g.seriesIndex = i.seriesIndex, g.dataType = "edge";
        var m = v.getModel(), _ = m.getModel("lineStyle"), y = _.get("curveness"), b = v.node1.getLayout(), w = v.node1.getModel(), S = w.get("localX"), M = w.get("localY"), k = v.node2.getLayout(), T = v.node2.getModel(), C = T.get("localX"), D = T.get("localY"), P = v.getLayout(), O, I, N, F, q, V, B, $;
        p.shape.extent = Math.max(1, P.dy), p.shape.orient = f, f === "vertical" ? (O = (S != null ? S * u : b.x) + P.sy, I = (M != null ? M * c : b.y) + b.dy, N = (C != null ? C * u : k.x) + P.ty, F = D != null ? D * c : k.y, q = O, V = I * (1 - y) + F * y, B = N, $ = I * y + F * (1 - y)) : (O = (S != null ? S * u : b.x) + b.dx, I = (M != null ? M * c : b.y) + P.sy, N = C != null ? C * u : k.x, F = (D != null ? D * c : k.y) + P.ty, q = O * (1 - y) + N * y, V = I, B = O * y + N * (1 - y), $ = F), p.setShape({
          x1: O,
          y1: I,
          x2: N,
          y2: F,
          cpx1: q,
          cpy1: V,
          cpx2: B,
          cpy2: $
        }), p.useStyle(_.getItemStyle()), Ly(p.style, f, v);
        var j = "" + m.get("value"), G = H0(m, "edgeLabel");
        V0(p, G, {
          labelFetcher: {
            getFormattedLabel: function(wt, Tt, me, Pe, Pt, Nt) {
              return i.getFormattedLabel(
                wt,
                Tt,
                "edge",
                Pe,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Zr(Pt, G.normal && G.normal.get("formatter"), j),
                Nt
              );
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: j
        }), p.setTextConfig({
          position: "inside"
        });
        var et = m.getModel("emphasis");
        A0(p, m, "lineStyle", function(wt) {
          var Tt = wt.getItemStyle();
          return Ly(Tt, f, v), Tt;
        }), o.add(p), d.setItemGraphicEl(v.dataIndex, p);
        var at = et.get("focus");
        T0(p, at === "adjacency" ? v.getAdjacentDataIndices() : at === "trajectory" ? v.getTrajectoryDataIndices() : at, et.get("blurScope"), et.get("disabled"));
      }), s.eachNode(function(v) {
        var p = v.getLayout(), g = v.getModel(), m = g.get("localX"), _ = g.get("localY"), y = g.getModel("emphasis"), b = g.get(["itemStyle", "borderRadius"]) || 0, w = new De({
          shape: {
            x: m != null ? m * u : p.x,
            y: _ != null ? _ * c : p.y,
            width: p.dx,
            height: p.dy,
            r: b
          },
          style: g.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        V0(w, H0(g), {
          labelFetcher: {
            getFormattedLabel: function(M, k) {
              return i.getFormattedLabel(M, k, "node");
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: v.id
        }), w.disableLabelAnimation = !0, w.setStyle("fill", v.getVisual("color")), w.setStyle("decal", v.getVisual("style").decal), A0(w, g), o.add(w), h.setItemGraphicEl(v.dataIndex, w), zt(w).dataType = "node";
        var S = y.get("focus");
        T0(w, S === "adjacency" ? v.getAdjacentDataIndices() : S === "trajectory" ? v.getTrajectoryDataIndices() : S, y.get("blurScope"), y.get("disabled"));
      }), h.eachItemGraphicEl(function(v, p) {
        var g = h.getItemModel(p);
        g.get("draggable") && (v.drift = function(m, _) {
          a._focusAdjacencyDisabled = !0, this.shape.x += m, this.shape.y += _, this.dirty(), r.dispatchAction({
            type: "dragNode",
            seriesId: i.id,
            dataIndex: h.getRawIndex(p),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, v.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, v.draggable = !0, v.cursor = "move");
      }), !this._data && i.isAnimationEnabled() && o.setClipPath(c4(o.getBoundingRect(), i, function() {
        o.removeClipPath();
      })), this._data = i.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(i, n) {
      var r = i.layoutInfo, a = r.width, s = r.height, o = i.coordinateSystem = new _3(null, {
        api: n,
        ecModel: i.ecModel
      });
      o.zoomLimit = i.get("scaleLimit"), o.setBoundingRect(0, 0, a, s), o.setCenter(i.get("center")), o.setZoom(i.get("zoom")), this._controllerHost.target.attr({
        x: o.x,
        y: o.y,
        scaleX: o.scaleX,
        scaleY: o.scaleY
      });
    }, t.type = "sankey", t;
  })(Kn)
);
function Ly(e, t, i) {
  switch (e.fill) {
    case "source":
      e.fill = i.node1.getVisual("color"), e.decal = i.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = i.node2.getVisual("color"), e.decal = i.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = i.node1.getVisual("color"), r = i.node2.getVisual("color");
      tt(n) && tt(r) && (e.fill = new lx(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: r,
        offset: 1
      }]));
  }
}
function c4(e, t, i) {
  var n = new De({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return cx(n, {
    shape: {
      width: e.width + 20
    }
  }, t, i), n;
}
var h4 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.getInitialData = function(i, n) {
      var r = i.edges || i.links || [], a = i.data || i.nodes || [], s = i.levels || [];
      this.levelModels = [];
      for (var o = this.levelModels, l = 0; l < s.length; l++)
        if (s[l].depth != null && s[l].depth >= 0)
          o[s[l].depth] = new jt(s[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = s4(a, r, this, !0, c);
      return u.data;
      function c(h, d) {
        h.wrapMethod("getItemModel", function(f, v) {
          var p = f.parentModel, g = p.getData().getItemLayout(v);
          if (g) {
            var m = g.depth, _ = p.levelModels[m];
            _ && (f.parentModel = _);
          }
          return f;
        }), d.wrapMethod("getItemModel", function(f, v) {
          var p = f.parentModel, g = p.getGraph().getEdgeByIndex(v), m = g.node1.getLayout();
          if (m) {
            var _ = m.depth, y = p.levelModels[_];
            y && (f.parentModel = y);
          }
          return f;
        });
      }
    }, t.prototype.setNodePosition = function(i, n) {
      var r = this.option.data || this.option.nodes, a = r[i];
      a.localX = n[0], a.localY = n[1];
    }, t.prototype.setCenter = function(i) {
      this.option.center = i;
    }, t.prototype.setZoom = function(i) {
      this.option.zoom = i;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(i, n, r) {
      function a(f) {
        return isNaN(f) || f == null;
      }
      if (r === "edge") {
        var s = this.getDataParams(i, r), o = s.data, l = s.value, u = o.source + " -- " + o.target;
        return oa("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(i), h = c.getLayout().value, d = this.getDataParams(i, r).data.name;
        return oa("nameValue", {
          name: d != null ? d + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(i, n) {
      var r = e.prototype.getDataParams.call(this, i, n);
      if (r.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(i), s = a.getLayout().value;
        r.value = s;
      }
      return r;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: St.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: St.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  })(rr)
);
function d4(e, t) {
  e.eachSeriesByType("sankey", function(i) {
    var n = i.get("nodeWidth"), r = i.get("nodeGap"), a = Ax(i, t).refContainer, s = ep(i.getBoxLayoutParams(), a);
    i.layoutInfo = s;
    var o = s.width, l = s.height, u = i.getGraph(), c = u.nodes, h = u.edges;
    v4(c);
    var d = Ze(c, function(g) {
      return g.getLayout().value === 0;
    }), f = d.length !== 0 ? 0 : i.get("layoutIterations"), v = i.get("orient"), p = i.get("nodeAlign");
    f4(c, h, n, r, o, l, f, v, p);
  });
}
function f4(e, t, i, n, r, a, s, o, l) {
  p4(e, t, i, r, a, o, l), y4(e, t, a, r, n, s, o), C4(e, o);
}
function v4(e) {
  A(e, function(t) {
    var i = Qn(t.outEdges, lc), n = Qn(t.inEdges, lc), r = t.getValue() || 0, a = Math.max(i, n, r);
    t.setLayout({
      value: a
    }, !0);
  });
}
function p4(e, t, i, n, r, a, s) {
  for (var o = [], l = [], u = [], c = [], h = 0, d = 0; d < t.length; d++)
    o[d] = 1;
  for (var d = 0; d < e.length; d++)
    l[d] = e[d].inEdges.length, l[d] === 0 && u.push(e[d]);
  for (var f = -1; u.length; ) {
    for (var v = 0; v < u.length; v++) {
      var p = u[v], g = p.hostGraph.data.getRawDataItem(p.dataIndex), m = g.depth != null && g.depth >= 0;
      m && g.depth > f && (f = g.depth), p.setLayout({
        depth: m ? g.depth : h
      }, !0), a === "vertical" ? p.setLayout({
        dy: i
      }, !0) : p.setLayout({
        dx: i
      }, !0);
      for (var _ = 0; _ < p.outEdges.length; _++) {
        var y = p.outEdges[_], b = t.indexOf(y);
        o[b] = 0;
        var w = y.node2, S = e.indexOf(w);
        --l[S] === 0 && c.indexOf(w) < 0 && c.push(w);
      }
    }
    ++h, u = c, c = [];
  }
  for (var d = 0; d < o.length; d++)
    if (o[d] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var M = f > h - 1 ? f : h - 1;
  s && s !== "left" && g4(e, s, a, M);
  var k = a === "vertical" ? (r - i) / M : (n - i) / M;
  _4(e, k, a);
}
function oS(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function g4(e, t, i, n) {
  if (t === "right") {
    for (var r = [], a = e, s = 0; a.length; ) {
      for (var o = 0; o < a.length; o++) {
        var l = a[o];
        l.setLayout({
          skNodeHeight: s
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          r.indexOf(c.node1) < 0 && r.push(c.node1);
        }
      }
      a = r, r = [], ++s;
    }
    A(e, function(h) {
      oS(h) || h.setLayout({
        depth: Math.max(0, n - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && m4(e, n);
}
function m4(e, t) {
  A(e, function(i) {
    !oS(i) && !i.outEdges.length && i.setLayout({
      depth: t
    }, !0);
  });
}
function _4(e, t, i) {
  A(e, function(n) {
    var r = n.getLayout().depth * t;
    i === "vertical" ? n.setLayout({
      y: r
    }, !0) : n.setLayout({
      x: r
    }, !0);
  });
}
function y4(e, t, i, n, r, a, s) {
  var o = b4(e, s);
  x4(o, t, i, n, r, s), Td(o, r, i, n, s);
  for (var l = 1; a > 0; a--)
    l *= 0.99, w4(o, l, s), Td(o, r, i, n, s), T4(o, l, s), Td(o, r, i, n, s);
}
function b4(e, t) {
  var i = [], n = t === "vertical" ? "y" : "x", r = UL(e, function(a) {
    return a.getLayout()[n];
  });
  return r.keys.sort(function(a, s) {
    return a - s;
  }), A(r.keys, function(a) {
    i.push(r.buckets.get(a));
  }), i;
}
function x4(e, t, i, n, r, a) {
  var s = 1 / 0;
  A(e, function(o) {
    var l = o.length, u = 0;
    A(o, function(h) {
      u += h.getLayout().value;
    });
    var c = a === "vertical" ? (n - (l - 1) * r) / u : (i - (l - 1) * r) / u;
    c < s && (s = c);
  }), A(e, function(o) {
    A(o, function(l, u) {
      var c = l.getLayout().value * s;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), A(t, function(o) {
    var l = +o.getValue() * s;
    o.setLayout({
      dy: l
    }, !0);
  });
}
function Td(e, t, i, n, r) {
  var a = r === "vertical" ? "x" : "y";
  A(e, function(s) {
    s.sort(function(p, g) {
      return p.getLayout()[a] - g.getLayout()[a];
    });
    for (var o, l, u, c = 0, h = s.length, d = r === "vertical" ? "dx" : "dy", f = 0; f < h; f++)
      l = s[f], u = c - l.getLayout()[a], u > 0 && (o = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({
        x: o
      }, !0) : l.setLayout({
        y: o
      }, !0)), c = l.getLayout()[a] + l.getLayout()[d] + t;
    var v = r === "vertical" ? n : i;
    if (u = c - t - v, u > 0) {
      o = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
        x: o
      }, !0) : l.setLayout({
        y: o
      }, !0), c = o;
      for (var f = h - 2; f >= 0; --f)
        l = s[f], u = l.getLayout()[a] + l.getLayout()[d] + t - c, u > 0 && (o = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
          x: o
        }, !0) : l.setLayout({
          y: o
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function w4(e, t, i) {
  A(e.slice().reverse(), function(n) {
    A(n, function(r) {
      if (r.outEdges.length) {
        var a = Qn(r.outEdges, S4, i) / Qn(r.outEdges, lc);
        if (isNaN(a)) {
          var s = r.outEdges.length;
          a = s ? Qn(r.outEdges, M4, i) / s : 0;
        }
        if (i === "vertical") {
          var o = r.getLayout().x + (a - sr(r, i)) * t;
          r.setLayout({
            x: o
          }, !0);
        } else {
          var l = r.getLayout().y + (a - sr(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function S4(e, t) {
  return sr(e.node2, t) * e.getValue();
}
function M4(e, t) {
  return sr(e.node2, t);
}
function k4(e, t) {
  return sr(e.node1, t) * e.getValue();
}
function D4(e, t) {
  return sr(e.node1, t);
}
function sr(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function lc(e) {
  return e.getValue();
}
function Qn(e, t, i) {
  for (var n = 0, r = e.length, a = -1; ++a < r; ) {
    var s = +t(e[a], i);
    isNaN(s) || (n += s);
  }
  return n;
}
function T4(e, t, i) {
  A(e, function(n) {
    A(n, function(r) {
      if (r.inEdges.length) {
        var a = Qn(r.inEdges, k4, i) / Qn(r.inEdges, lc);
        if (isNaN(a)) {
          var s = r.inEdges.length;
          a = s ? Qn(r.inEdges, D4, i) / s : 0;
        }
        if (i === "vertical") {
          var o = r.getLayout().x + (a - sr(r, i)) * t;
          r.setLayout({
            x: o
          }, !0);
        } else {
          var l = r.getLayout().y + (a - sr(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function C4(e, t) {
  var i = t === "vertical" ? "x" : "y";
  A(e, function(n) {
    n.outEdges.sort(function(r, a) {
      return r.node2.getLayout()[i] - a.node2.getLayout()[i];
    }), n.inEdges.sort(function(r, a) {
      return r.node1.getLayout()[i] - a.node1.getLayout()[i];
    });
  }), A(e, function(n) {
    var r = 0, a = 0;
    A(n.outEdges, function(s) {
      s.setLayout({
        sy: r
      }, !0), r += s.getLayout().dy;
    }), A(n.inEdges, function(s) {
      s.setLayout({
        ty: a
      }, !0), a += s.getLayout().dy;
    });
  });
}
function A4(e) {
  e.eachSeriesByType("sankey", function(t) {
    var i = t.getGraph(), n = i.nodes, r = i.edges;
    if (n.length) {
      var a = 1 / 0, s = -1 / 0;
      A(n, function(o) {
        var l = o.getLayout().value;
        l < a && (a = l), l > s && (s = l);
      }), A(n, function(o) {
        var l = new yp({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, s],
          visual: t.get("color")
        }), u = l.mapValueToVisual(o.getLayout().value), c = o.getModel().get(["itemStyle", "color"]);
        c != null ? (o.setVisual("color", c), o.setVisual("style", {
          fill: c
        })) : (o.setVisual("color", u), o.setVisual("style", {
          fill: u
        }));
      });
    }
    r.length && A(r, function(o) {
      var l = o.getModel().get("lineStyle");
      o.setVisual("style", l);
    });
  });
}
function P4(e) {
  e.registerChartView(u4), e.registerSeriesModel(h4), e.registerLayout(d4), e.registerVisual(A4), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, i) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), e.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, i, n) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(r) {
      var a = r.coordinateSystem, s = m3(a, t, r.get("scaleLimit"));
      r.setCenter(s.center), r.setZoom(s.zoom);
    });
  });
}
function Oy(e, t, i) {
  var n = kn.createCanvas(), r = t.getWidth(), a = t.getHeight(), s = n.style;
  return s && (s.position = "absolute", s.left = "0", s.top = "0", s.width = r + "px", s.height = a + "px", n.setAttribute("data-zr-dom-id", e)), n.width = r * i, n.height = a * i, n;
}
var Cd = (function(e) {
  Lt(t, e);
  function t(i, n, r) {
    var a = e.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var s;
    r = r || Iu, typeof i == "string" ? s = Oy(i, n, r) : Q(i) && (s = i, i = s.id), a.id = i, a.dom = s;
    var o = s.style;
    return o && (n1(s), s.onselectstart = function() {
      return !1;
    }, o.padding = "0", o.margin = "0", o.borderWidth = "0"), a.painter = n, a.dpr = r, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var i = this.dpr;
    this.domBack = Oy("back-" + this.id, this.painter, i), this.ctxBack = this.domBack.getContext("2d"), i !== 1 && this.ctxBack.scale(i, i);
  }, t.prototype.createRepaintRects = function(i, n, r, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var s = [], o = this.maxRepaintRectCount, l = !1, u = new ot(0, 0, 0, 0);
    function c(_) {
      if (!(!_.isFinite() || _.isZero()))
        if (s.length === 0) {
          var y = new ot(0, 0, 0, 0);
          y.copy(_), s.push(y);
        } else {
          for (var b = !1, w = 1 / 0, S = 0, M = 0; M < s.length; ++M) {
            var k = s[M];
            if (k.intersect(_)) {
              var T = new ot(0, 0, 0, 0);
              T.copy(k), T.union(_), s[M] = T, b = !0;
              break;
            } else if (l) {
              u.copy(_), u.union(k);
              var C = _.width * _.height, D = k.width * k.height, P = u.width * u.height, O = P - C - D;
              O < w && (w = O, S = M);
            }
          }
          if (l && (s[S].union(_), b = !0), !b) {
            var y = new ot(0, 0, 0, 0);
            y.copy(_), s.push(y);
          }
          l || (l = s.length >= o);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var d = i[h];
      if (d) {
        var f = d.shouldBePainted(r, a, !0, !0), v = d.__isRendered && (d.__dirty & Ke || !f) ? d.getPrevPaintRect() : null;
        v && c(v);
        var p = f && (d.__dirty & Ke || !d.__isRendered) ? d.getPaintRect() : null;
        p && c(p);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var d = n[h], f = d && d.shouldBePainted(r, a, !0, !0);
      if (d && (!f || !d.__zr) && d.__isRendered) {
        var v = d.getPrevPaintRect();
        v && c(v);
      }
    }
    var g;
    do {
      g = !1;
      for (var h = 0; h < s.length; ) {
        if (s[h].isZero()) {
          s.splice(h, 1);
          continue;
        }
        for (var m = h + 1; m < s.length; )
          s[h].intersect(s[m]) ? (g = !0, s[h].union(s[m]), s.splice(m, 1)) : m++;
        h++;
      }
    } while (g);
    return this._paintRects = s, s;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(i, n) {
    var r = this.dpr, a = this.dom, s = a.style, o = this.domBack;
    s && (s.width = i + "px", s.height = n + "px"), a.width = i * r, a.height = n * r, o && (o.width = i * r, o.height = n * r, r !== 1 && this.ctxBack.scale(r, r));
  }, t.prototype.clear = function(i, n, r) {
    var a = this.dom, s = this.ctx, o = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !i, c = this.lastFrameAlpha, h = this.dpr, d = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, o / h, l / h));
    var f = this.domBack;
    function v(p, g, m, _) {
      if (s.clearRect(p, g, m, _), n && n !== "transparent") {
        var y = void 0;
        if (Sc(n)) {
          var b = n.global || n.__width === m && n.__height === _;
          y = b && n.__canvasGradient || Of(s, n, {
            x: 0,
            y: 0,
            width: m,
            height: _
          }), n.__canvasGradient = y, n.__width = m, n.__height = _;
        } else XP(n) && (n.scaleX = n.scaleX || h, n.scaleY = n.scaleY || h, y = If(s, n, {
          dirty: function() {
            d.setUnpainted(), d.painter.refresh();
          }
        }));
        s.save(), s.fillStyle = y || n, s.fillRect(p, g, m, _), s.restore();
      }
      u && (s.save(), s.globalAlpha = c, s.drawImage(f, p, g, m, _), s.restore());
    }
    !r || u ? v(0, 0, o, l) : r.length && A(r, function(p) {
      v(p.x * h, p.y * h, p.width * h, p.height * h);
    });
  }, t;
})(Pi), Iy = 1e5, Or = 314159, Kl = 0.01, E4 = 1e-3;
function L4(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function O4(e, t) {
  var i = document.createElement("div");
  return i.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", i;
}
var I4 = (function() {
  function e(t, i, n, r) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = Y({}, n || {}), this.dpr = n.devicePixelRatio || Iu, this._singleCanvas = a, this.root = t;
    var s = t.style;
    s && (n1(t), t.innerHTML = ""), this.storage = i;
    var o = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, h = c.width, d = c.height;
      n.width != null && (h = n.width), n.height != null && (d = n.height), this.dpr = n.devicePixelRatio || 1, c.width = h * this.dpr, c.height = d * this.dpr, this._width = h, this._height = d;
      var f = new Cd(c, this, this.dpr);
      f.__builtin__ = !0, f.initContext(), l[Or] = f, f.zlevel = Or, o.push(Or), this._domRoot = t;
    } else {
      this._width = Hl(t, 0, n), this._height = Hl(t, 1, n);
      var u = this._domRoot = O4(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var i = this.storage.getDisplayList(!0), n = this._prevDisplayList, r = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(i, n, t, this._redrawId);
    for (var a = 0; a < r.length; a++) {
      var s = r[a], o = this._layers[s];
      if (!o.__builtin__ && o.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        o.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = i.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var i = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!i) {
      for (var r = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, s = 0; s < i; s++) {
        var o = t[s];
        o.__inHover && (n || (n = this._hoverlayer = this.getLayer(Iy)), a || (a = n.ctx, a.save()), Ur(a, o, r, s === i - 1));
      }
      a && a.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(Iy);
  }, e.prototype.paintOne = function(t, i) {
    pw(t, i);
  }, e.prototype._paintList = function(t, i, n, r) {
    if (this._redrawId === r) {
      n = n || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, i, n), s = a.finished, o = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), o && this._paintHoverList(t), s)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        Cu(function() {
          l._paintList(t, i, n, r);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(Or).ctx, i = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, i, n), this.eachBuiltinLayer(function(r) {
      r.virtual && t.drawImage(r.dom, 0, 0, i, n);
    });
  }, e.prototype._doPaintList = function(t, i, n) {
    for (var r = this, a = [], s = this._opts.useDirtyRect, o = 0; o < this._zlevelList.length; o++) {
      var l = this._zlevelList[o], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var c = !0, h = !1, d = function(p) {
      var g = a[p], m = g.ctx, _ = s && g.createRepaintRects(t, i, f._width, f._height), y = n ? g.__startIndex : g.__drawIndex, b = !n && g.incremental && Date.now, w = b && Date.now(), S = g.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
      if (g.__startIndex === g.__endIndex)
        g.clear(!1, S, _);
      else if (y === g.__startIndex) {
        var M = t[y];
        (!M.incremental || !M.notClear || n) && g.clear(!1, S, _);
      }
      y === -1 && (console.error("For some unknown reason. drawIndex is -1"), y = g.__startIndex);
      var k, T = function(O) {
        var I = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: r._width,
          viewHeight: r._height
        };
        for (k = y; k < g.__endIndex; k++) {
          var N = t[k];
          if (N.__inHover && (h = !0), r._doPaintEl(N, g, s, O, I, k === g.__endIndex - 1), b) {
            var F = Date.now() - w;
            if (F > 15)
              break;
          }
        }
        I.prevElClipPaths && m.restore();
      };
      if (_)
        if (_.length === 0)
          k = g.__endIndex;
        else
          for (var C = f.dpr, D = 0; D < _.length; ++D) {
            var P = _[D];
            m.save(), m.beginPath(), m.rect(P.x * C, P.y * C, P.width * C, P.height * C), m.clip(), T(P), m.restore();
          }
      else
        m.save(), T(), m.restore();
      g.__drawIndex = k, g.__drawIndex < g.__endIndex && (c = !1);
    }, f = this, v = 0; v < a.length; v++)
      d(v);
    return st.wxa && A(this._layers, function(p) {
      p && p.ctx && p.ctx.draw && p.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, e.prototype._doPaintEl = function(t, i, n, r, a, s) {
    var o = i.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!r || l && l.intersect(r)) && (Ur(o, t, a, s), t.setPrevPaintRect(l));
    } else
      Ur(o, t, a, s);
  }, e.prototype.getLayer = function(t, i) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Or);
    var n = this._layers[t];
    return n || (n = new Cd("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? se(n, this._layerConfig[t], !0) : this._layerConfig[t - Kl] && se(n, this._layerConfig[t - Kl], !0), i && (n.virtual = i), this.insertLayer(t, n), n.initContext()), n;
  }, e.prototype.insertLayer = function(t, i) {
    var n = this._layers, r = this._zlevelList, a = r.length, s = this._domRoot, o = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && qr("ZLevel " + t + " has been used already");
      return;
    }
    if (!L4(i)) {
      process.env.NODE_ENV !== "production" && qr("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > r[0]) {
      for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++)
        ;
      o = n[r[l]];
    }
    if (r.splice(l + 1, 0, t), n[t] = i, !i.virtual)
      if (o) {
        var u = o.dom;
        u.nextSibling ? s.insertBefore(i.dom, u.nextSibling) : s.appendChild(i.dom);
      } else
        s.firstChild ? s.insertBefore(i.dom, s.firstChild) : s.appendChild(i.dom);
    i.painter || (i.painter = this);
  }, e.prototype.eachLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r];
      t.call(i, this._layers[a], a);
    }
  }, e.prototype.eachBuiltinLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], s = this._layers[a];
      s.__builtin__ && t.call(i, s, a);
    }
  }, e.prototype.eachOtherLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], s = this._layers[a];
      s.__builtin__ || t.call(i, s, a);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(h, d) {
      h.__dirty = h.__used = !1;
    });
    function i(h) {
      a && (a.__endIndex !== h && (a.__dirty = !0), a.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var r = t[n];
        if (r.zlevel !== t[n - 1].zlevel || r.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, s = 0, o, l;
    for (l = 0; l < t.length; l++) {
      var r = t[l], u = r.zlevel, c = void 0;
      o !== u && (o = u, s = 0), r.incremental ? (c = this.getLayer(u + E4, this._needsManuallyCompositing), c.incremental = !0, s = 1) : c = this.getLayer(u + (s > 0 ? Kl : 0), this._needsManuallyCompositing), c.__builtin__ || qr("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, i(l), a = c), r.__dirty & Ke && !r.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    i(l), this.eachBuiltinLayer(function(h, d) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, A(this._layers, function(i) {
      i.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, i) {
    if (i) {
      var n = this._layerConfig;
      n[t] ? se(n[t], i, !0) : n[t] = i;
      for (var r = 0; r < this._zlevelList.length; r++) {
        var a = this._zlevelList[r];
        if (a === t || a === t + Kl) {
          var s = this._layers[a];
          se(s, n[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var i = this._layers, n = this._zlevelList, r = i[t];
    r && (r.dom.parentNode.removeChild(r.dom), delete i[t], n.splice(Vt(n, t), 1));
  }, e.prototype.resize = function(t, i) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var r = this._opts, a = this.root;
      if (t != null && (r.width = t), i != null && (r.height = i), t = Hl(a, 0, r), i = Hl(a, 1, r), n.style.display = "", this._width !== t || i !== this._height) {
        n.style.width = t + "px", n.style.height = i + "px";
        for (var s in this._layers)
          this._layers.hasOwnProperty(s) && this._layers[s].resize(t, i);
        this.refresh(!0);
      }
      this._width = t, this._height = i;
    } else {
      if (t == null || i == null)
        return;
      this._width = t, this._height = i, this.getLayer(Or).resize(t, i);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var i = this._layers[t];
    i && i.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Or].dom;
    var i = new Cd("image", this, t.pixelRatio || this.dpr);
    i.initContext(), i.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = i.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var r = i.dom.width, a = i.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? n.drawImage(h.dom, 0, 0, r, a) : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
      });
    } else
      for (var s = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, o = this.storage.getDisplayList(!0), l = 0, u = o.length; l < u; l++) {
        var c = o[l];
        Ur(n, c, s, l === u - 1);
      }
    return i.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
})();
function R4(e) {
  e.registerPainter("canvas", I4);
}
const N4 = { class: "chart-container" }, F4 = {
  key: 1,
  class: "chart-wrapper"
}, B4 = /* @__PURE__ */ fe({
  __name: "SankeyChart",
  props: {
    data: { default: () => ({ nodes: [], links: [] }) },
    title: { default: "" },
    height: { default: "500px" },
    nodeColors: { default: () => ({}) },
    useGradient: { type: Boolean, default: !0 },
    nodeGap: { default: 20 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    fp([W3, K3, P4, R4]);
    const i = e, { isDark: n, colors: r } = ye(_e(i, "theme")), a = vi(null), s = vi(!0), o = vi(!1);
    let l = null;
    const u = {
      animation: { duration: 1e3, easing: "cubicOut" },
      margins: { left: "2%", right: "2%", top: "2%", bottom: "2%" },
      node: { width: 70, gap: 20, align: "left", iterations: 64 },
      style: {
        shadowBlur: 4,
        shadowColor: "rgba(139, 92, 246, 0.15)"
      }
    }, c = [
      "#C67DFF",
      // Primary light
      "#8b5cf6",
      // Primary medium
      "#a855f7",
      // Bright purple
      "#7c3aed",
      // Vibrant purple
      "#5d4b93",
      // Primary dark
      "#9333ea"
      // Deep purple
    ], h = () => {
      const y = i.data.links.filter(
        (M) => M.source && M.target && typeof M.value == "number"
      ), b = Math.max(...y.map((M) => M.value), 1), w = Math.max(1, b * 0.01), S = y.map((M) => ({
        ...M,
        originalValue: M.value,
        value: M.value < b * 0.01 ? w : M.value
      }));
      return {
        nodes: i.data.nodes.filter((M) => M.name),
        links: S
      };
    }, d = (y) => y.map((b, w) => ({
      ...b,
      itemStyle: {
        color: i.nodeColors[b.name] || c[w % c.length],
        borderRadius: 8
      }
    })), f = (y) => (b) => {
      const w = b.dataType === "node", S = r.value.tooltipText, M = n.value ? "#d1d5db" : "#e2e8f0";
      if (w) {
        const P = y.filter((N) => N.target === b.name), O = y.filter((N) => N.source === b.name), I = P.length > 0 ? P.reduce((N, F) => N + (F.originalValue || F.value), 0) : O.reduce((N, F) => N + (F.originalValue || F.value), 0);
        return `<div style="font-weight: 600; margin-bottom: 4px; color: ${S};">${b.name}</div><div style="color: ${M}; font-size: 12px;">Count: ${I.toLocaleString()}</div>`;
      }
      const k = b.data?.source || b.source || "Unknown", T = b.data?.target || b.target || "Unknown", C = b.data?.originalValue || b.data?.value || b.value || 0, D = b.data?.label || `${C.toLocaleString()}`;
      return `<div style="font-weight: 600; margin-bottom: 4px; color: ${S};">${k}  ${T}</div><div style="color: ${M}; font-size: 12px;">Flow: ${D}</div>`;
    }, v = () => {
      if (!(!l || !i.data.nodes?.length || !i.data.links?.length))
        try {
          const { nodes: y, links: b } = h(), w = d(y), S = {
            tooltip: {
              trigger: "item",
              triggerOn: "mousemove",
              formatter: f(b),
              backgroundColor: r.value.tooltipBg,
              borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
              borderWidth: 1,
              borderRadius: 8,
              padding: [10, 14],
              textStyle: {
                color: r.value.tooltipText,
                fontSize: 13,
                fontFamily: "'DM Sans', sans-serif",
                fontWeight: 500
              },
              shadowBlur: 10,
              shadowColor: "rgba(0, 0, 0, 0.3)"
            },
            series: [
              {
                type: "sankey",
                data: w,
                links: b,
                emphasis: { focus: "adjacency" },
                levels: [
                  {
                    depth: 0,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  },
                  {
                    depth: 1,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  }
                ],
                lineStyle: {
                  color: i.useGradient ? "gradient" : "source",
                  curveness: 0.5,
                  opacity: 0.6
                },
                itemStyle: u.style,
                label: {
                  show: !0,
                  position: "inside",
                  color: "#ffffff",
                  fontWeight: 600,
                  fontSize: 12,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (M) => {
                    const k = M.name || "";
                    return k.length > 15 ? `${k.substring(0, 15)}...` : k;
                  }
                },
                edgeLabel: {
                  show: !0,
                  fontSize: 11,
                  color: r.value.textSecondary,
                  fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (M) => {
                    const k = M.data?.originalValue || M.value || 0;
                    return M.data?.label || `${k.toLocaleString()}`;
                  }
                },
                nodeAlign: u.node.align,
                nodeGap: i.nodeGap,
                nodeWidth: u.node.width,
                layoutIterations: u.node.iterations,
                orient: "horizontal",
                draggable: !1,
                ...u.margins
              }
            ],
            backgroundColor: "transparent",
            animation: !0,
            animationDuration: u.animation.duration,
            animationEasing: u.animation.easing
          };
          l.setOption(S);
        } catch (y) {
          console.error("Error setting Sankey chart options:", y), o.value = !0;
        }
    }, p = async () => {
      if (a.value)
        try {
          l = CF(a.value), v(), window.addEventListener("resize", m);
        } catch (y) {
          console.error("Error initializing Sankey chart:", y), o.value = !0;
        } finally {
          s.value = !1;
        }
    }, g = async (y = 40) => {
      await Xy();
      for (let b = 0; b < y; b++) {
        if (a.value?.clientWidth && a.value.clientWidth > 0 && a.value?.clientHeight && a.value.clientHeight > 0)
          return await p();
        await new Promise((w) => setTimeout(w, 50));
      }
      await p(), setTimeout(m, 50);
    }, m = () => l?.resize(), _ = () => {
      window.removeEventListener("resize", m), l && (l.dispose(), l = null);
    };
    return Qf(() => a.value && g()), i2(_), es(() => i.data, v, { deep: !0 }), es(n, v), t({ isDark: n }), (y, b) => (E(), L("div", N4, [
      o.value ? (E(), L("div", {
        key: 0,
        class: "error-state",
        style: Xr({ height: e.height })
      }, [...b[0] || (b[0] = [
        Ht('<div class="error-content" data-v-e8598dd9><svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-e8598dd9><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-e8598dd9></path></svg><p class="error-title" data-v-e8598dd9>Chart could not be loaded</p><p class="error-description" data-v-e8598dd9>Please check the data format.</p></div>', 1)
      ])], 4)) : (E(), L("div", F4, [
        Gp(x("div", {
          ref_key: "chartEl",
          ref: a,
          class: "chart-content",
          style: Xr({ height: e.height })
        }, null, 4), [
          [Xp, !s.value]
        ]),
        Gp(x("div", {
          class: "loading-state",
          style: Xr({ height: e.height })
        }, [...b[1] || (b[1] = [
          Ht('<div class="loading-container" data-v-e8598dd9><div class="sankey-loader" data-v-e8598dd9><div class="flow flow-1" data-v-e8598dd9></div><div class="flow flow-2" data-v-e8598dd9></div><div class="flow flow-3" data-v-e8598dd9></div><div class="flow flow-4" data-v-e8598dd9></div></div><p class="loading-text" data-v-e8598dd9>Loading Sankey diagram...</p></div>', 1)
        ])], 4), [
          [Xp, s.value]
        ])
      ]))
    ]));
  }
}), fa = /* @__PURE__ */ ne(B4, [["__scopeId", "data-v-e8598dd9"]]);
function xp(e, t) {
  return E(), L("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z"
    })
  ]);
}
function $4(e, t) {
  return E(), L("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z"
    }),
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z"
    })
  ]);
}
const z4 = { class: "agents-per-day-card" }, V4 = {
  key: 0,
  class: "card-body"
}, H4 = {
  key: 0,
  class: "chart-section"
}, Y4 = {
  key: 1,
  class: "empty-state"
}, W4 = { class: "empty-state-content" }, U4 = { class: "empty-icon-wrapper" }, G4 = {
  key: 1,
  class: "loading-state"
}, X4 = /* @__PURE__ */ fe({
  __name: "AgentsPerDay",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, n = e, { isDark: r, colors: a } = ye(_e(n, "theme")), s = (u) => {
      const c = new Date(u), h = String(c.getDate()).padStart(2, "0"), d = String(c.getMonth() + 1).padStart(2, "0");
      return `${h}-${d}`;
    }, o = X(() => {
      const u = n.data?.agents_by_day || {}, c = Object.keys(u).sort();
      if (c.length === 0)
        return { labels: [], datasets: [] };
      const h = c.map((g) => s(g)), d = /* @__PURE__ */ new Set();
      for (const g of Object.values(u))
        for (const m of Object.keys(g))
          d.add(m);
      const f = Array.from(d), v = (g) => g, p = f.map((g) => ({
        label: g,
        data: c.map((m) => u[m]?.[g] || 0),
        backgroundColor: `${i[g] || "#94a3b8"}80`,
        borderColor: v(i[g] || "#94a3b8"),
        borderWidth: 1
      }));
      return {
        labels: h,
        datasets: p
      };
    }), l = X(() => n.options ? n.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: a.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: a.value.tooltipBg,
          titleColor: a.value.tooltipText,
          bodyColor: a.value.tooltipText,
          borderColor: r.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          }
        }
      },
      scales: {
        x: {
          stacked: !0,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: a.value.textSecondary,
            padding: 8
          }
        },
        y: {
          stacked: !0,
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: a.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: a.value.textSecondary,
            padding: 8
          }
        }
      }
    });
    return t({ isDark: r }), (u, c) => (E(), L("article", z4, [
      c[3] || (c[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Agents Total Messages per Day"),
          x("p", { class: "card-subtitle" }, "Daily agent interactions (stacked)")
        ])
      ], -1)),
      e.loading ? (E(), L("div", G4, [...c[2] || (c[2] = [
        Ht('<div class="loading-container" data-v-3f759d36><div class="chart-lines-loader" data-v-3f759d36><div class="line line-1" data-v-3f759d36></div><div class="line line-2" data-v-3f759d36></div><div class="line line-3" data-v-3f759d36></div><div class="line line-4" data-v-3f759d36></div><div class="line line-5" data-v-3f759d36></div></div><p class="loading-text" data-v-3f759d36>Loading chart data...</p></div>', 1)
      ])])) : (E(), L("div", V4, [
        o.value.labels && o.value.labels.length ? (E(), L("section", H4, [
          de(Xb, {
            data: o.value,
            options: l.value,
            stacked: !0
          }, null, 8, ["data", "options"])
        ])) : (E(), L("section", Y4, [
          x("div", W4, [
            x("div", U4, [
              de(J(xp), { class: "empty-icon" })
            ]),
            c[0] || (c[0] = x("p", { class: "empty-title" }, "No agents data per day", -1)),
            c[1] || (c[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see daily agent interactions.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), j4 = /* @__PURE__ */ ne(X4, [["__scopeId", "data-v-3f759d36"]]);
var lS;
function H() {
  return lS.apply(null, arguments);
}
function q4(e) {
  lS = e;
}
function Ti(e) {
  return e instanceof Array || Object.prototype.toString.call(e) === "[object Array]";
}
function na(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Object]";
}
function bt(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function wp(e) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(e).length === 0;
  var t;
  for (t in e)
    if (bt(e, t))
      return !1;
  return !0;
}
function $e(e) {
  return e === void 0;
}
function Cn(e) {
  return typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]";
}
function Qo(e) {
  return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
}
function uS(e, t) {
  var i = [], n, r = e.length;
  for (n = 0; n < r; ++n)
    i.push(t(e[n], n));
  return i;
}
function Gn(e, t) {
  for (var i in t)
    bt(t, i) && (e[i] = t[i]);
  return bt(t, "toString") && (e.toString = t.toString), bt(t, "valueOf") && (e.valueOf = t.valueOf), e;
}
function en(e, t, i, n) {
  return LS(e, t, i, n, !0).utc();
}
function Z4() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function lt(e) {
  return e._pf == null && (e._pf = Z4()), e._pf;
}
var Uf;
Array.prototype.some ? Uf = Array.prototype.some : Uf = function(e) {
  var t = Object(this), i = t.length >>> 0, n;
  for (n = 0; n < i; n++)
    if (n in t && e.call(this, t[n], n, t))
      return !0;
  return !1;
};
function Sp(e) {
  var t = null, i = !1, n = e._d && !isNaN(e._d.getTime());
  if (n && (t = lt(e), i = Uf.call(t.parsedDateParts, function(r) {
    return r != null;
  }), n = t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && i), e._strict && (n = n && t.charsLeftOver === 0 && t.unusedTokens.length === 0 && t.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(e))
    e._isValid = n;
  else
    return n;
  return e._isValid;
}
function Vc(e) {
  var t = en(NaN);
  return e != null ? Gn(lt(t), e) : lt(t).userInvalidated = !0, t;
}
var Ry = H.momentProperties = [], Ad = !1;
function Mp(e, t) {
  var i, n, r, a = Ry.length;
  if ($e(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), $e(t._i) || (e._i = t._i), $e(t._f) || (e._f = t._f), $e(t._l) || (e._l = t._l), $e(t._strict) || (e._strict = t._strict), $e(t._tzm) || (e._tzm = t._tzm), $e(t._isUTC) || (e._isUTC = t._isUTC), $e(t._offset) || (e._offset = t._offset), $e(t._pf) || (e._pf = lt(t)), $e(t._locale) || (e._locale = t._locale), a > 0)
    for (i = 0; i < a; i++)
      n = Ry[i], r = t[n], $e(r) || (e[n] = r);
  return e;
}
function Jo(e) {
  Mp(this, e), this._d = new Date(e._d != null ? e._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Ad === !1 && (Ad = !0, H.updateOffset(this), Ad = !1);
}
function Ci(e) {
  return e instanceof Jo || e != null && e._isAMomentObject != null;
}
function cS(e) {
  H.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + e);
}
function _i(e, t) {
  var i = !0;
  return Gn(function() {
    if (H.deprecationHandler != null && H.deprecationHandler(null, e), i) {
      var n = [], r, a, s, o = arguments.length;
      for (a = 0; a < o; a++) {
        if (r = "", typeof arguments[a] == "object") {
          r += `
[` + a + "] ";
          for (s in arguments[0])
            bt(arguments[0], s) && (r += s + ": " + arguments[0][s] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[a];
        n.push(r);
      }
      cS(
        e + `
Arguments: ` + Array.prototype.slice.call(n).join("") + `
` + new Error().stack
      ), i = !1;
    }
    return t.apply(this, arguments);
  }, t);
}
var Ny = {};
function hS(e, t) {
  H.deprecationHandler != null && H.deprecationHandler(e, t), Ny[e] || (cS(t), Ny[e] = !0);
}
H.suppressDeprecationWarnings = !1;
H.deprecationHandler = null;
function nn(e) {
  return typeof Function < "u" && e instanceof Function || Object.prototype.toString.call(e) === "[object Function]";
}
function K4(e) {
  var t, i;
  for (i in e)
    bt(e, i) && (t = e[i], nn(t) ? this[i] = t : this["_" + i] = t);
  this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function Gf(e, t) {
  var i = Gn({}, e), n;
  for (n in t)
    bt(t, n) && (na(e[n]) && na(t[n]) ? (i[n] = {}, Gn(i[n], e[n]), Gn(i[n], t[n])) : t[n] != null ? i[n] = t[n] : delete i[n]);
  for (n in e)
    bt(e, n) && !bt(t, n) && na(e[n]) && (i[n] = Gn({}, i[n]));
  return i;
}
function kp(e) {
  e != null && this.set(e);
}
var Xf;
Object.keys ? Xf = Object.keys : Xf = function(e) {
  var t, i = [];
  for (t in e)
    bt(e, t) && i.push(t);
  return i;
};
var Q4 = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function J4(e, t, i) {
  var n = this._calendar[e] || this._calendar.sameElse;
  return nn(n) ? n.call(t, i) : n;
}
function Ji(e, t, i) {
  var n = "" + Math.abs(e), r = t - n.length, a = e >= 0;
  return (a ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + n;
}
var Dp = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Ql = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Pd = {}, Qa = {};
function K(e, t, i, n) {
  var r = n;
  typeof n == "string" && (r = function() {
    return this[n]();
  }), e && (Qa[e] = r), t && (Qa[t[0]] = function() {
    return Ji(r.apply(this, arguments), t[1], t[2]);
  }), i && (Qa[i] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      e
    );
  });
}
function t$(e) {
  return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "");
}
function e$(e) {
  var t = e.match(Dp), i, n;
  for (i = 0, n = t.length; i < n; i++)
    Qa[t[i]] ? t[i] = Qa[t[i]] : t[i] = t$(t[i]);
  return function(r) {
    var a = "", s;
    for (s = 0; s < n; s++)
      a += nn(t[s]) ? t[s].call(r, e) : t[s];
    return a;
  };
}
function vu(e, t) {
  return e.isValid() ? (t = dS(t, e.localeData()), Pd[t] = Pd[t] || e$(t), Pd[t](e)) : e.localeData().invalidDate();
}
function dS(e, t) {
  var i = 5;
  function n(r) {
    return t.longDateFormat(r) || r;
  }
  for (Ql.lastIndex = 0; i >= 0 && Ql.test(e); )
    e = e.replace(
      Ql,
      n
    ), Ql.lastIndex = 0, i -= 1;
  return e;
}
var i$ = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function n$(e) {
  var t = this._longDateFormat[e], i = this._longDateFormat[e.toUpperCase()];
  return t || !i ? t : (this._longDateFormat[e] = i.match(Dp).map(function(n) {
    return n === "MMMM" || n === "MM" || n === "DD" || n === "dddd" ? n.slice(1) : n;
  }).join(""), this._longDateFormat[e]);
}
var r$ = "Invalid date";
function a$() {
  return this._invalidDate;
}
var s$ = "%d", o$ = /\d{1,2}/;
function l$(e) {
  return this._ordinal.replace("%d", e);
}
var u$ = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function c$(e, t, i, n) {
  var r = this._relativeTime[i];
  return nn(r) ? r(e, t, i, n) : r.replace(/%d/i, e);
}
function h$(e, t) {
  var i = this._relativeTime[e > 0 ? "future" : "past"];
  return nn(i) ? i(t) : i.replace(/%s/i, t);
}
var Fy = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function yi(e) {
  return typeof e == "string" ? Fy[e] || Fy[e.toLowerCase()] : void 0;
}
function Tp(e) {
  var t = {}, i, n;
  for (n in e)
    bt(e, n) && (i = yi(n), i && (t[i] = e[n]));
  return t;
}
var d$ = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function f$(e) {
  var t = [], i;
  for (i in e)
    bt(e, i) && t.push({ unit: i, priority: d$[i] });
  return t.sort(function(n, r) {
    return n.priority - r.priority;
  }), t;
}
var fS = /\d/, ti = /\d\d/, vS = /\d{3}/, Cp = /\d{4}/, Hc = /[+-]?\d{6}/, Wt = /\d\d?/, pS = /\d\d\d\d?/, gS = /\d\d\d\d\d\d?/, Yc = /\d{1,3}/, Ap = /\d{1,4}/, Wc = /[+-]?\d{1,6}/, gs = /\d+/, Uc = /[+-]?\d+/, v$ = /Z|[+-]\d\d:?\d\d/gi, Gc = /Z|[+-]\d\d(?::?\d\d)?/gi, p$ = /[+-]?\d+(\.\d{1,3})?/, tl = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, ms = /^[1-9]\d?/, Pp = /^([1-9]\d|\d)/, uc;
uc = {};
function U(e, t, i) {
  uc[e] = nn(t) ? t : function(n, r) {
    return n && i ? i : t;
  };
}
function g$(e, t) {
  return bt(uc, e) ? uc[e](t._strict, t._locale) : new RegExp(m$(e));
}
function m$(e) {
  return Sn(
    e.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(t, i, n, r, a) {
        return i || n || r || a;
      }
    )
  );
}
function Sn(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function di(e) {
  return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
}
function gt(e) {
  var t = +e, i = 0;
  return t !== 0 && isFinite(t) && (i = di(t)), i;
}
var jf = {};
function Ot(e, t) {
  var i, n = t, r;
  for (typeof e == "string" && (e = [e]), Cn(t) && (n = function(a, s) {
    s[t] = gt(a);
  }), r = e.length, i = 0; i < r; i++)
    jf[e[i]] = n;
}
function el(e, t) {
  Ot(e, function(i, n, r, a) {
    r._w = r._w || {}, t(i, r._w, r, a);
  });
}
function _$(e, t, i) {
  t != null && bt(jf, e) && jf[e](t, i._a, i, e);
}
function Xc(e) {
  return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
}
var Te = 0, yn = 1, Wi = 2, he = 3, Mi = 4, bn = 5, Gr = 6, y$ = 7, b$ = 8;
K("Y", 0, 0, function() {
  var e = this.year();
  return e <= 9999 ? Ji(e, 4) : "+" + e;
});
K(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
K(0, ["YYYY", 4], 0, "year");
K(0, ["YYYYY", 5], 0, "year");
K(0, ["YYYYYY", 6, !0], 0, "year");
U("Y", Uc);
U("YY", Wt, ti);
U("YYYY", Ap, Cp);
U("YYYYY", Wc, Hc);
U("YYYYYY", Wc, Hc);
Ot(["YYYYY", "YYYYYY"], Te);
Ot("YYYY", function(e, t) {
  t[Te] = e.length === 2 ? H.parseTwoDigitYear(e) : gt(e);
});
Ot("YY", function(e, t) {
  t[Te] = H.parseTwoDigitYear(e);
});
Ot("Y", function(e, t) {
  t[Te] = parseInt(e, 10);
});
function bo(e) {
  return Xc(e) ? 366 : 365;
}
H.parseTwoDigitYear = function(e) {
  return gt(e) + (gt(e) > 68 ? 1900 : 2e3);
};
var mS = _s("FullYear", !0);
function x$() {
  return Xc(this.year());
}
function _s(e, t) {
  return function(i) {
    return i != null ? (_S(this, e, i), H.updateOffset(this, t), this) : Ho(this, e);
  };
}
function Ho(e, t) {
  if (!e.isValid())
    return NaN;
  var i = e._d, n = e._isUTC;
  switch (t) {
    case "Milliseconds":
      return n ? i.getUTCMilliseconds() : i.getMilliseconds();
    case "Seconds":
      return n ? i.getUTCSeconds() : i.getSeconds();
    case "Minutes":
      return n ? i.getUTCMinutes() : i.getMinutes();
    case "Hours":
      return n ? i.getUTCHours() : i.getHours();
    case "Date":
      return n ? i.getUTCDate() : i.getDate();
    case "Day":
      return n ? i.getUTCDay() : i.getDay();
    case "Month":
      return n ? i.getUTCMonth() : i.getMonth();
    case "FullYear":
      return n ? i.getUTCFullYear() : i.getFullYear();
    default:
      return NaN;
  }
}
function _S(e, t, i) {
  var n, r, a, s, o;
  if (!(!e.isValid() || isNaN(i))) {
    switch (n = e._d, r = e._isUTC, t) {
      case "Milliseconds":
        return void (r ? n.setUTCMilliseconds(i) : n.setMilliseconds(i));
      case "Seconds":
        return void (r ? n.setUTCSeconds(i) : n.setSeconds(i));
      case "Minutes":
        return void (r ? n.setUTCMinutes(i) : n.setMinutes(i));
      case "Hours":
        return void (r ? n.setUTCHours(i) : n.setHours(i));
      case "Date":
        return void (r ? n.setUTCDate(i) : n.setDate(i));
      // case 'Day': // Not real
      //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
      // case 'Month': // Not used because we need to pass two variables
      //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
      case "FullYear":
        break;
      // See below ...
      default:
        return;
    }
    a = i, s = e.month(), o = e.date(), o = o === 29 && s === 1 && !Xc(a) ? 28 : o, r ? n.setUTCFullYear(a, s, o) : n.setFullYear(a, s, o);
  }
}
function w$(e) {
  return e = yi(e), nn(this[e]) ? this[e]() : this;
}
function S$(e, t) {
  if (typeof e == "object") {
    e = Tp(e);
    var i = f$(e), n, r = i.length;
    for (n = 0; n < r; n++)
      this[i[n].unit](e[i[n].unit]);
  } else if (e = yi(e), nn(this[e]))
    return this[e](t);
  return this;
}
function M$(e, t) {
  return (e % t + t) % t;
}
var te;
Array.prototype.indexOf ? te = Array.prototype.indexOf : te = function(e) {
  var t;
  for (t = 0; t < this.length; ++t)
    if (this[t] === e)
      return t;
  return -1;
};
function Ep(e, t) {
  if (isNaN(e) || isNaN(t))
    return NaN;
  var i = M$(t, 12);
  return e += (t - i) / 12, i === 1 ? Xc(e) ? 29 : 28 : 31 - i % 7 % 2;
}
K("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
K("MMM", 0, 0, function(e) {
  return this.localeData().monthsShort(this, e);
});
K("MMMM", 0, 0, function(e) {
  return this.localeData().months(this, e);
});
U("M", Wt, ms);
U("MM", Wt, ti);
U("MMM", function(e, t) {
  return t.monthsShortRegex(e);
});
U("MMMM", function(e, t) {
  return t.monthsRegex(e);
});
Ot(["M", "MM"], function(e, t) {
  t[yn] = gt(e) - 1;
});
Ot(["MMM", "MMMM"], function(e, t, i, n) {
  var r = i._locale.monthsParse(e, n, i._strict);
  r != null ? t[yn] = r : lt(i).invalidMonth = e;
});
var k$ = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), yS = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), bS = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, D$ = tl, T$ = tl;
function C$(e, t) {
  return e ? Ti(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || bS).test(t) ? "format" : "standalone"][e.month()] : Ti(this._months) ? this._months : this._months.standalone;
}
function A$(e, t) {
  return e ? Ti(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[bS.test(t) ? "format" : "standalone"][e.month()] : Ti(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function P$(e, t, i) {
  var n, r, a, s = e.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n)
      a = en([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(
        a,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[n] = this.months(a, "").toLocaleLowerCase();
  return i ? t === "MMM" ? (r = te.call(this._shortMonthsParse, s), r !== -1 ? r : null) : (r = te.call(this._longMonthsParse, s), r !== -1 ? r : null) : t === "MMM" ? (r = te.call(this._shortMonthsParse, s), r !== -1 ? r : (r = te.call(this._longMonthsParse, s), r !== -1 ? r : null)) : (r = te.call(this._longMonthsParse, s), r !== -1 ? r : (r = te.call(this._shortMonthsParse, s), r !== -1 ? r : null));
}
function E$(e, t, i) {
  var n, r, a;
  if (this._monthsParseExact)
    return P$.call(this, e, t, i);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
    if (r = en([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[n] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !i && !this._monthsParse[n] && (a = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[n] = new RegExp(a.replace(".", ""), "i")), i && t === "MMMM" && this._longMonthsParse[n].test(e))
      return n;
    if (i && t === "MMM" && this._shortMonthsParse[n].test(e))
      return n;
    if (!i && this._monthsParse[n].test(e))
      return n;
  }
}
function xS(e, t) {
  if (!e.isValid())
    return e;
  if (typeof t == "string") {
    if (/^\d+$/.test(t))
      t = gt(t);
    else if (t = e.localeData().monthsParse(t), !Cn(t))
      return e;
  }
  var i = t, n = e.date();
  return n = n < 29 ? n : Math.min(n, Ep(e.year(), i)), e._isUTC ? e._d.setUTCMonth(i, n) : e._d.setMonth(i, n), e;
}
function wS(e) {
  return e != null ? (xS(this, e), H.updateOffset(this, !0), this) : Ho(this, "Month");
}
function L$() {
  return Ep(this.year(), this.month());
}
function O$(e) {
  return this._monthsParseExact ? (bt(this, "_monthsRegex") || SS.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (bt(this, "_monthsShortRegex") || (this._monthsShortRegex = D$), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function I$(e) {
  return this._monthsParseExact ? (bt(this, "_monthsRegex") || SS.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (bt(this, "_monthsRegex") || (this._monthsRegex = T$), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex);
}
function SS() {
  function e(l, u) {
    return u.length - l.length;
  }
  var t = [], i = [], n = [], r, a, s, o;
  for (r = 0; r < 12; r++)
    a = en([2e3, r]), s = Sn(this.monthsShort(a, "")), o = Sn(this.months(a, "")), t.push(s), i.push(o), n.push(o), n.push(s);
  t.sort(e), i.sort(e), n.sort(e), this._monthsRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function R$(e, t, i, n, r, a, s) {
  var o;
  return e < 100 && e >= 0 ? (o = new Date(e + 400, t, i, n, r, a, s), isFinite(o.getFullYear()) && o.setFullYear(e)) : o = new Date(e, t, i, n, r, a, s), o;
}
function Yo(e) {
  var t, i;
  return e < 100 && e >= 0 ? (i = Array.prototype.slice.call(arguments), i[0] = e + 400, t = new Date(Date.UTC.apply(null, i)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t;
}
function cc(e, t, i) {
  var n = 7 + t - i, r = (7 + Yo(e, 0, n).getUTCDay() - t) % 7;
  return -r + n - 1;
}
function MS(e, t, i, n, r) {
  var a = (7 + i - n) % 7, s = cc(e, n, r), o = 1 + 7 * (t - 1) + a + s, l, u;
  return o <= 0 ? (l = e - 1, u = bo(l) + o) : o > bo(e) ? (l = e + 1, u = o - bo(e)) : (l = e, u = o), {
    year: l,
    dayOfYear: u
  };
}
function Wo(e, t, i) {
  var n = cc(e.year(), t, i), r = Math.floor((e.dayOfYear() - n - 1) / 7) + 1, a, s;
  return r < 1 ? (s = e.year() - 1, a = r + Mn(s, t, i)) : r > Mn(e.year(), t, i) ? (a = r - Mn(e.year(), t, i), s = e.year() + 1) : (s = e.year(), a = r), {
    week: a,
    year: s
  };
}
function Mn(e, t, i) {
  var n = cc(e, t, i), r = cc(e + 1, t, i);
  return (bo(e) - n + r) / 7;
}
K("w", ["ww", 2], "wo", "week");
K("W", ["WW", 2], "Wo", "isoWeek");
U("w", Wt, ms);
U("ww", Wt, ti);
U("W", Wt, ms);
U("WW", Wt, ti);
el(
  ["w", "ww", "W", "WW"],
  function(e, t, i, n) {
    t[n.substr(0, 1)] = gt(e);
  }
);
function N$(e) {
  return Wo(e, this._week.dow, this._week.doy).week;
}
var F$ = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function B$() {
  return this._week.dow;
}
function $$() {
  return this._week.doy;
}
function z$(e) {
  var t = this.localeData().week(this);
  return e == null ? t : this.add((e - t) * 7, "d");
}
function V$(e) {
  var t = Wo(this, 1, 4).week;
  return e == null ? t : this.add((e - t) * 7, "d");
}
K("d", 0, "do", "day");
K("dd", 0, 0, function(e) {
  return this.localeData().weekdaysMin(this, e);
});
K("ddd", 0, 0, function(e) {
  return this.localeData().weekdaysShort(this, e);
});
K("dddd", 0, 0, function(e) {
  return this.localeData().weekdays(this, e);
});
K("e", 0, 0, "weekday");
K("E", 0, 0, "isoWeekday");
U("d", Wt);
U("e", Wt);
U("E", Wt);
U("dd", function(e, t) {
  return t.weekdaysMinRegex(e);
});
U("ddd", function(e, t) {
  return t.weekdaysShortRegex(e);
});
U("dddd", function(e, t) {
  return t.weekdaysRegex(e);
});
el(["dd", "ddd", "dddd"], function(e, t, i, n) {
  var r = i._locale.weekdaysParse(e, n, i._strict);
  r != null ? t.d = r : lt(i).invalidWeekday = e;
});
el(["d", "e", "E"], function(e, t, i, n) {
  t[n] = gt(e);
});
function H$(e, t) {
  return typeof e != "string" ? e : isNaN(e) ? (e = t.weekdaysParse(e), typeof e == "number" ? e : null) : parseInt(e, 10);
}
function Y$(e, t) {
  return typeof e == "string" ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e;
}
function Lp(e, t) {
  return e.slice(t, 7).concat(e.slice(0, t));
}
var W$ = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), kS = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), U$ = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), G$ = tl, X$ = tl, j$ = tl;
function q$(e, t) {
  var i = Ti(this._weekdays) ? this._weekdays : this._weekdays[e && e !== !0 && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
  return e === !0 ? Lp(i, this._week.dow) : e ? i[e.day()] : i;
}
function Z$(e) {
  return e === !0 ? Lp(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort;
}
function K$(e) {
  return e === !0 ? Lp(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin;
}
function Q$(e, t, i) {
  var n, r, a, s = e.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n)
      a = en([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(
        a,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(
        a,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(a, "").toLocaleLowerCase();
  return i ? t === "dddd" ? (r = te.call(this._weekdaysParse, s), r !== -1 ? r : null) : t === "ddd" ? (r = te.call(this._shortWeekdaysParse, s), r !== -1 ? r : null) : (r = te.call(this._minWeekdaysParse, s), r !== -1 ? r : null) : t === "dddd" ? (r = te.call(this._weekdaysParse, s), r !== -1 || (r = te.call(this._shortWeekdaysParse, s), r !== -1) ? r : (r = te.call(this._minWeekdaysParse, s), r !== -1 ? r : null)) : t === "ddd" ? (r = te.call(this._shortWeekdaysParse, s), r !== -1 || (r = te.call(this._weekdaysParse, s), r !== -1) ? r : (r = te.call(this._minWeekdaysParse, s), r !== -1 ? r : null)) : (r = te.call(this._minWeekdaysParse, s), r !== -1 || (r = te.call(this._weekdaysParse, s), r !== -1) ? r : (r = te.call(this._shortWeekdaysParse, s), r !== -1 ? r : null));
}
function J$(e, t, i) {
  var n, r, a;
  if (this._weekdaysParseExact)
    return Q$.call(this, e, t, i);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
    if (r = en([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[n] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[n] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[n] || (a = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[n] = new RegExp(a.replace(".", ""), "i")), i && t === "dddd" && this._fullWeekdaysParse[n].test(e))
      return n;
    if (i && t === "ddd" && this._shortWeekdaysParse[n].test(e))
      return n;
    if (i && t === "dd" && this._minWeekdaysParse[n].test(e))
      return n;
    if (!i && this._weekdaysParse[n].test(e))
      return n;
  }
}
function tz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = Ho(this, "Day");
  return e != null ? (e = H$(e, this.localeData()), this.add(e - t, "d")) : t;
}
function ez(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return e == null ? t : this.add(e - t, "d");
}
function iz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    var t = Y$(e, this.localeData());
    return this.day(this.day() % 7 ? t : t - 7);
  } else
    return this.day() || 7;
}
function nz(e) {
  return this._weekdaysParseExact ? (bt(this, "_weekdaysRegex") || Op.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (bt(this, "_weekdaysRegex") || (this._weekdaysRegex = G$), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function rz(e) {
  return this._weekdaysParseExact ? (bt(this, "_weekdaysRegex") || Op.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (bt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = X$), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function az(e) {
  return this._weekdaysParseExact ? (bt(this, "_weekdaysRegex") || Op.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (bt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = j$), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Op() {
  function e(c, h) {
    return h.length - c.length;
  }
  var t = [], i = [], n = [], r = [], a, s, o, l, u;
  for (a = 0; a < 7; a++)
    s = en([2e3, 1]).day(a), o = Sn(this.weekdaysMin(s, "")), l = Sn(this.weekdaysShort(s, "")), u = Sn(this.weekdays(s, "")), t.push(o), i.push(l), n.push(u), r.push(o), r.push(l), r.push(u);
  t.sort(e), i.sort(e), n.sort(e), r.sort(e), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + n.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function Ip() {
  return this.hours() % 12 || 12;
}
function sz() {
  return this.hours() || 24;
}
K("H", ["HH", 2], 0, "hour");
K("h", ["hh", 2], 0, Ip);
K("k", ["kk", 2], 0, sz);
K("hmm", 0, 0, function() {
  return "" + Ip.apply(this) + Ji(this.minutes(), 2);
});
K("hmmss", 0, 0, function() {
  return "" + Ip.apply(this) + Ji(this.minutes(), 2) + Ji(this.seconds(), 2);
});
K("Hmm", 0, 0, function() {
  return "" + this.hours() + Ji(this.minutes(), 2);
});
K("Hmmss", 0, 0, function() {
  return "" + this.hours() + Ji(this.minutes(), 2) + Ji(this.seconds(), 2);
});
function DS(e, t) {
  K(e, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      t
    );
  });
}
DS("a", !0);
DS("A", !1);
function TS(e, t) {
  return t._meridiemParse;
}
U("a", TS);
U("A", TS);
U("H", Wt, Pp);
U("h", Wt, ms);
U("k", Wt, ms);
U("HH", Wt, ti);
U("hh", Wt, ti);
U("kk", Wt, ti);
U("hmm", pS);
U("hmmss", gS);
U("Hmm", pS);
U("Hmmss", gS);
Ot(["H", "HH"], he);
Ot(["k", "kk"], function(e, t, i) {
  var n = gt(e);
  t[he] = n === 24 ? 0 : n;
});
Ot(["a", "A"], function(e, t, i) {
  i._isPm = i._locale.isPM(e), i._meridiem = e;
});
Ot(["h", "hh"], function(e, t, i) {
  t[he] = gt(e), lt(i).bigHour = !0;
});
Ot("hmm", function(e, t, i) {
  var n = e.length - 2;
  t[he] = gt(e.substr(0, n)), t[Mi] = gt(e.substr(n)), lt(i).bigHour = !0;
});
Ot("hmmss", function(e, t, i) {
  var n = e.length - 4, r = e.length - 2;
  t[he] = gt(e.substr(0, n)), t[Mi] = gt(e.substr(n, 2)), t[bn] = gt(e.substr(r)), lt(i).bigHour = !0;
});
Ot("Hmm", function(e, t, i) {
  var n = e.length - 2;
  t[he] = gt(e.substr(0, n)), t[Mi] = gt(e.substr(n));
});
Ot("Hmmss", function(e, t, i) {
  var n = e.length - 4, r = e.length - 2;
  t[he] = gt(e.substr(0, n)), t[Mi] = gt(e.substr(n, 2)), t[bn] = gt(e.substr(r));
});
function oz(e) {
  return (e + "").toLowerCase().charAt(0) === "p";
}
var lz = /[ap]\.?m?\.?/i, uz = _s("Hours", !0);
function cz(e, t, i) {
  return e > 11 ? i ? "pm" : "PM" : i ? "am" : "AM";
}
var CS = {
  calendar: Q4,
  longDateFormat: i$,
  invalidDate: r$,
  ordinal: s$,
  dayOfMonthOrdinalParse: o$,
  relativeTime: u$,
  months: k$,
  monthsShort: yS,
  week: F$,
  weekdays: W$,
  weekdaysMin: U$,
  weekdaysShort: kS,
  meridiemParse: lz
}, Ut = {}, Us = {}, Uo;
function hz(e, t) {
  var i, n = Math.min(e.length, t.length);
  for (i = 0; i < n; i += 1)
    if (e[i] !== t[i])
      return i;
  return n;
}
function By(e) {
  return e && e.toLowerCase().replace("_", "-");
}
function dz(e) {
  for (var t = 0, i, n, r, a; t < e.length; ) {
    for (a = By(e[t]).split("-"), i = a.length, n = By(e[t + 1]), n = n ? n.split("-") : null; i > 0; ) {
      if (r = jc(a.slice(0, i).join("-")), r)
        return r;
      if (n && n.length >= i && hz(a, n) >= i - 1)
        break;
      i--;
    }
    t++;
  }
  return Uo;
}
function fz(e) {
  return !!(e && e.match("^[^/\\\\]*$"));
}
function jc(e) {
  var t = null, i;
  if (Ut[e] === void 0 && typeof module < "u" && module && module.exports && fz(e))
    try {
      t = Uo._abbr, i = require, i("./locale/" + e), Jn(t);
    } catch {
      Ut[e] = null;
    }
  return Ut[e];
}
function Jn(e, t) {
  var i;
  return e && ($e(t) ? i = En(e) : i = Rp(e, t), i ? Uo = i : typeof console < "u" && console.warn && console.warn(
    "Locale " + e + " not found. Did you forget to load it?"
  )), Uo._abbr;
}
function Rp(e, t) {
  if (t !== null) {
    var i, n = CS;
    if (t.abbr = e, Ut[e] != null)
      hS(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), n = Ut[e]._config;
    else if (t.parentLocale != null)
      if (Ut[t.parentLocale] != null)
        n = Ut[t.parentLocale]._config;
      else if (i = jc(t.parentLocale), i != null)
        n = i._config;
      else
        return Us[t.parentLocale] || (Us[t.parentLocale] = []), Us[t.parentLocale].push({
          name: e,
          config: t
        }), null;
    return Ut[e] = new kp(Gf(n, t)), Us[e] && Us[e].forEach(function(r) {
      Rp(r.name, r.config);
    }), Jn(e), Ut[e];
  } else
    return delete Ut[e], null;
}
function vz(e, t) {
  if (t != null) {
    var i, n, r = CS;
    Ut[e] != null && Ut[e].parentLocale != null ? Ut[e].set(Gf(Ut[e]._config, t)) : (n = jc(e), n != null && (r = n._config), t = Gf(r, t), n == null && (t.abbr = e), i = new kp(t), i.parentLocale = Ut[e], Ut[e] = i), Jn(e);
  } else
    Ut[e] != null && (Ut[e].parentLocale != null ? (Ut[e] = Ut[e].parentLocale, e === Jn() && Jn(e)) : Ut[e] != null && delete Ut[e]);
  return Ut[e];
}
function En(e) {
  var t;
  if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e)
    return Uo;
  if (!Ti(e)) {
    if (t = jc(e), t)
      return t;
    e = [e];
  }
  return dz(e);
}
function pz() {
  return Xf(Ut);
}
function Np(e) {
  var t, i = e._a;
  return i && lt(e).overflow === -2 && (t = i[yn] < 0 || i[yn] > 11 ? yn : i[Wi] < 1 || i[Wi] > Ep(i[Te], i[yn]) ? Wi : i[he] < 0 || i[he] > 24 || i[he] === 24 && (i[Mi] !== 0 || i[bn] !== 0 || i[Gr] !== 0) ? he : i[Mi] < 0 || i[Mi] > 59 ? Mi : i[bn] < 0 || i[bn] > 59 ? bn : i[Gr] < 0 || i[Gr] > 999 ? Gr : -1, lt(e)._overflowDayOfYear && (t < Te || t > Wi) && (t = Wi), lt(e)._overflowWeeks && t === -1 && (t = y$), lt(e)._overflowWeekday && t === -1 && (t = b$), lt(e).overflow = t), e;
}
var gz = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, mz = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, _z = /Z|[+-]\d\d(?::?\d\d)?/, Jl = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Ed = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], yz = /^\/?Date\((-?\d+)/i, bz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, xz = {
  UT: 0,
  GMT: 0,
  EDT: -240,
  EST: -300,
  CDT: -300,
  CST: -360,
  MDT: -360,
  MST: -420,
  PDT: -420,
  PST: -480
};
function AS(e) {
  var t, i, n = e._i, r = gz.exec(n) || mz.exec(n), a, s, o, l, u = Jl.length, c = Ed.length;
  if (r) {
    for (lt(e).iso = !0, t = 0, i = u; t < i; t++)
      if (Jl[t][1].exec(r[1])) {
        s = Jl[t][0], a = Jl[t][2] !== !1;
        break;
      }
    if (s == null) {
      e._isValid = !1;
      return;
    }
    if (r[3]) {
      for (t = 0, i = c; t < i; t++)
        if (Ed[t][1].exec(r[3])) {
          o = (r[2] || " ") + Ed[t][0];
          break;
        }
      if (o == null) {
        e._isValid = !1;
        return;
      }
    }
    if (!a && o != null) {
      e._isValid = !1;
      return;
    }
    if (r[4])
      if (_z.exec(r[4]))
        l = "Z";
      else {
        e._isValid = !1;
        return;
      }
    e._f = s + (o || "") + (l || ""), Bp(e);
  } else
    e._isValid = !1;
}
function wz(e, t, i, n, r, a) {
  var s = [
    Sz(e),
    yS.indexOf(t),
    parseInt(i, 10),
    parseInt(n, 10),
    parseInt(r, 10)
  ];
  return a && s.push(parseInt(a, 10)), s;
}
function Sz(e) {
  var t = parseInt(e, 10);
  return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t;
}
function Mz(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function kz(e, t, i) {
  if (e) {
    var n = kS.indexOf(e), r = new Date(
      t[0],
      t[1],
      t[2]
    ).getDay();
    if (n !== r)
      return lt(i).weekdayMismatch = !0, i._isValid = !1, !1;
  }
  return !0;
}
function Dz(e, t, i) {
  if (e)
    return xz[e];
  if (t)
    return 0;
  var n = parseInt(i, 10), r = n % 100, a = (n - r) / 100;
  return a * 60 + r;
}
function PS(e) {
  var t = bz.exec(Mz(e._i)), i;
  if (t) {
    if (i = wz(
      t[4],
      t[3],
      t[2],
      t[5],
      t[6],
      t[7]
    ), !kz(t[1], i, e))
      return;
    e._a = i, e._tzm = Dz(t[8], t[9], t[10]), e._d = Yo.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), lt(e).rfc2822 = !0;
  } else
    e._isValid = !1;
}
function Tz(e) {
  var t = yz.exec(e._i);
  if (t !== null) {
    e._d = /* @__PURE__ */ new Date(+t[1]);
    return;
  }
  if (AS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  if (PS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  e._strict ? e._isValid = !1 : H.createFromInputFallback(e);
}
H.createFromInputFallback = _i(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(e) {
    e._d = /* @__PURE__ */ new Date(e._i + (e._useUTC ? " UTC" : ""));
  }
);
function Ba(e, t, i) {
  return e ?? t ?? i;
}
function Cz(e) {
  var t = new Date(H.now());
  return e._useUTC ? [
    t.getUTCFullYear(),
    t.getUTCMonth(),
    t.getUTCDate()
  ] : [t.getFullYear(), t.getMonth(), t.getDate()];
}
function Fp(e) {
  var t, i, n = [], r, a, s;
  if (!e._d) {
    for (r = Cz(e), e._w && e._a[Wi] == null && e._a[yn] == null && Az(e), e._dayOfYear != null && (s = Ba(e._a[Te], r[Te]), (e._dayOfYear > bo(s) || e._dayOfYear === 0) && (lt(e)._overflowDayOfYear = !0), i = Yo(s, 0, e._dayOfYear), e._a[yn] = i.getUTCMonth(), e._a[Wi] = i.getUTCDate()), t = 0; t < 3 && e._a[t] == null; ++t)
      e._a[t] = n[t] = r[t];
    for (; t < 7; t++)
      e._a[t] = n[t] = e._a[t] == null ? t === 2 ? 1 : 0 : e._a[t];
    e._a[he] === 24 && e._a[Mi] === 0 && e._a[bn] === 0 && e._a[Gr] === 0 && (e._nextDay = !0, e._a[he] = 0), e._d = (e._useUTC ? Yo : R$).apply(
      null,
      n
    ), a = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[he] = 24), e._w && typeof e._w.d < "u" && e._w.d !== a && (lt(e).weekdayMismatch = !0);
  }
}
function Az(e) {
  var t, i, n, r, a, s, o, l, u;
  t = e._w, t.GG != null || t.W != null || t.E != null ? (a = 1, s = 4, i = Ba(
    t.GG,
    e._a[Te],
    Wo(Yt(), 1, 4).year
  ), n = Ba(t.W, 1), r = Ba(t.E, 1), (r < 1 || r > 7) && (l = !0)) : (a = e._locale._week.dow, s = e._locale._week.doy, u = Wo(Yt(), a, s), i = Ba(t.gg, e._a[Te], u.year), n = Ba(t.w, u.week), t.d != null ? (r = t.d, (r < 0 || r > 6) && (l = !0)) : t.e != null ? (r = t.e + a, (t.e < 0 || t.e > 6) && (l = !0)) : r = a), n < 1 || n > Mn(i, a, s) ? lt(e)._overflowWeeks = !0 : l != null ? lt(e)._overflowWeekday = !0 : (o = MS(i, n, r, a, s), e._a[Te] = o.year, e._dayOfYear = o.dayOfYear);
}
H.ISO_8601 = function() {
};
H.RFC_2822 = function() {
};
function Bp(e) {
  if (e._f === H.ISO_8601) {
    AS(e);
    return;
  }
  if (e._f === H.RFC_2822) {
    PS(e);
    return;
  }
  e._a = [], lt(e).empty = !0;
  var t = "" + e._i, i, n, r, a, s, o = t.length, l = 0, u, c;
  for (r = dS(e._f, e._locale).match(Dp) || [], c = r.length, i = 0; i < c; i++)
    a = r[i], n = (t.match(g$(a, e)) || [])[0], n && (s = t.substr(0, t.indexOf(n)), s.length > 0 && lt(e).unusedInput.push(s), t = t.slice(
      t.indexOf(n) + n.length
    ), l += n.length), Qa[a] ? (n ? lt(e).empty = !1 : lt(e).unusedTokens.push(a), _$(a, n, e)) : e._strict && !n && lt(e).unusedTokens.push(a);
  lt(e).charsLeftOver = o - l, t.length > 0 && lt(e).unusedInput.push(t), e._a[he] <= 12 && lt(e).bigHour === !0 && e._a[he] > 0 && (lt(e).bigHour = void 0), lt(e).parsedDateParts = e._a.slice(0), lt(e).meridiem = e._meridiem, e._a[he] = Pz(
    e._locale,
    e._a[he],
    e._meridiem
  ), u = lt(e).era, u !== null && (e._a[Te] = e._locale.erasConvertYear(u, e._a[Te])), Fp(e), Np(e);
}
function Pz(e, t, i) {
  var n;
  return i == null ? t : e.meridiemHour != null ? e.meridiemHour(t, i) : (e.isPM != null && (n = e.isPM(i), n && t < 12 && (t += 12), !n && t === 12 && (t = 0)), t);
}
function Ez(e) {
  var t, i, n, r, a, s, o = !1, l = e._f.length;
  if (l === 0) {
    lt(e).invalidFormat = !0, e._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    a = 0, s = !1, t = Mp({}, e), e._useUTC != null && (t._useUTC = e._useUTC), t._f = e._f[r], Bp(t), Sp(t) && (s = !0), a += lt(t).charsLeftOver, a += lt(t).unusedTokens.length * 10, lt(t).score = a, o ? a < n && (n = a, i = t) : (n == null || a < n || s) && (n = a, i = t, s && (o = !0));
  Gn(e, i || t);
}
function Lz(e) {
  if (!e._d) {
    var t = Tp(e._i), i = t.day === void 0 ? t.date : t.day;
    e._a = uS(
      [t.year, t.month, i, t.hour, t.minute, t.second, t.millisecond],
      function(n) {
        return n && parseInt(n, 10);
      }
    ), Fp(e);
  }
}
function Oz(e) {
  var t = new Jo(Np(ES(e)));
  return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t;
}
function ES(e) {
  var t = e._i, i = e._f;
  return e._locale = e._locale || En(e._l), t === null || i === void 0 && t === "" ? Vc({ nullInput: !0 }) : (typeof t == "string" && (e._i = t = e._locale.preparse(t)), Ci(t) ? new Jo(Np(t)) : (Qo(t) ? e._d = t : Ti(i) ? Ez(e) : i ? Bp(e) : Iz(e), Sp(e) || (e._d = null), e));
}
function Iz(e) {
  var t = e._i;
  $e(t) ? e._d = new Date(H.now()) : Qo(t) ? e._d = new Date(t.valueOf()) : typeof t == "string" ? Tz(e) : Ti(t) ? (e._a = uS(t.slice(0), function(i) {
    return parseInt(i, 10);
  }), Fp(e)) : na(t) ? Lz(e) : Cn(t) ? e._d = new Date(t) : H.createFromInputFallback(e);
}
function LS(e, t, i, n, r) {
  var a = {};
  return (t === !0 || t === !1) && (n = t, t = void 0), (i === !0 || i === !1) && (n = i, i = void 0), (na(e) && wp(e) || Ti(e) && e.length === 0) && (e = void 0), a._isAMomentObject = !0, a._useUTC = a._isUTC = r, a._l = i, a._i = e, a._f = t, a._strict = n, Oz(a);
}
function Yt(e, t, i, n) {
  return LS(e, t, i, n, !1);
}
var Rz = _i(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Yt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e < this ? this : e : Vc();
  }
), Nz = _i(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Yt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e > this ? this : e : Vc();
  }
);
function OS(e, t) {
  var i, n;
  if (t.length === 1 && Ti(t[0]) && (t = t[0]), !t.length)
    return Yt();
  for (i = t[0], n = 1; n < t.length; ++n)
    (!t[n].isValid() || t[n][e](i)) && (i = t[n]);
  return i;
}
function Fz() {
  var e = [].slice.call(arguments, 0);
  return OS("isBefore", e);
}
function Bz() {
  var e = [].slice.call(arguments, 0);
  return OS("isAfter", e);
}
var $z = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, Gs = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function zz(e) {
  var t, i = !1, n, r = Gs.length;
  for (t in e)
    if (bt(e, t) && !(te.call(Gs, t) !== -1 && (e[t] == null || !isNaN(e[t]))))
      return !1;
  for (n = 0; n < r; ++n)
    if (e[Gs[n]]) {
      if (i)
        return !1;
      parseFloat(e[Gs[n]]) !== gt(e[Gs[n]]) && (i = !0);
    }
  return !0;
}
function Vz() {
  return this._isValid;
}
function Hz() {
  return Oi(NaN);
}
function qc(e) {
  var t = Tp(e), i = t.year || 0, n = t.quarter || 0, r = t.month || 0, a = t.week || t.isoWeek || 0, s = t.day || 0, o = t.hour || 0, l = t.minute || 0, u = t.second || 0, c = t.millisecond || 0;
  this._isValid = zz(t), this._milliseconds = +c + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  o * 1e3 * 60 * 60, this._days = +s + a * 7, this._months = +r + n * 3 + i * 12, this._data = {}, this._locale = En(), this._bubble();
}
function pu(e) {
  return e instanceof qc;
}
function qf(e) {
  return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e);
}
function Yz(e, t, i) {
  var n = Math.min(e.length, t.length), r = Math.abs(e.length - t.length), a = 0, s;
  for (s = 0; s < n; s++)
    gt(e[s]) !== gt(t[s]) && a++;
  return a + r;
}
function IS(e, t) {
  K(e, 0, 0, function() {
    var i = this.utcOffset(), n = "+";
    return i < 0 && (i = -i, n = "-"), n + Ji(~~(i / 60), 2) + t + Ji(~~i % 60, 2);
  });
}
IS("Z", ":");
IS("ZZ", "");
U("Z", Gc);
U("ZZ", Gc);
Ot(["Z", "ZZ"], function(e, t, i) {
  i._useUTC = !0, i._tzm = $p(Gc, e);
});
var Wz = /([\+\-]|\d\d)/gi;
function $p(e, t) {
  var i = (t || "").match(e), n, r, a;
  return i === null ? null : (n = i[i.length - 1] || [], r = (n + "").match(Wz) || ["-", 0, 0], a = +(r[1] * 60) + gt(r[2]), a === 0 ? 0 : r[0] === "+" ? a : -a);
}
function zp(e, t) {
  var i, n;
  return t._isUTC ? (i = t.clone(), n = (Ci(e) || Qo(e) ? e.valueOf() : Yt(e).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + n), H.updateOffset(i, !1), i) : Yt(e).local();
}
function Zf(e) {
  return -Math.round(e._d.getTimezoneOffset());
}
H.updateOffset = function() {
};
function Uz(e, t, i) {
  var n = this._offset || 0, r;
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    if (typeof e == "string") {
      if (e = $p(Gc, e), e === null)
        return this;
    } else Math.abs(e) < 16 && !i && (e = e * 60);
    return !this._isUTC && t && (r = Zf(this)), this._offset = e, this._isUTC = !0, r != null && this.add(r, "m"), n !== e && (!t || this._changeInProgress ? FS(
      this,
      Oi(e - n, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, H.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? n : Zf(this);
}
function Gz(e, t) {
  return e != null ? (typeof e != "string" && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset();
}
function Xz(e) {
  return this.utcOffset(0, e);
}
function jz(e) {
  return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Zf(this), "m")), this;
}
function qz() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var e = $p(v$, this._i);
    e != null ? this.utcOffset(e) : this.utcOffset(0, !0);
  }
  return this;
}
function Zz(e) {
  return this.isValid() ? (e = e ? Yt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 === 0) : !1;
}
function Kz() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function Qz() {
  if (!$e(this._isDSTShifted))
    return this._isDSTShifted;
  var e = {}, t;
  return Mp(e, this), e = ES(e), e._a ? (t = e._isUTC ? en(e._a) : Yt(e._a), this._isDSTShifted = this.isValid() && Yz(e._a, t.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function Jz() {
  return this.isValid() ? !this._isUTC : !1;
}
function tV() {
  return this.isValid() ? this._isUTC : !1;
}
function RS() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var eV = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, iV = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Oi(e, t) {
  var i = e, n = null, r, a, s;
  return pu(e) ? i = {
    ms: e._milliseconds,
    d: e._days,
    M: e._months
  } : Cn(e) || !isNaN(+e) ? (i = {}, t ? i[t] = +e : i.milliseconds = +e) : (n = eV.exec(e)) ? (r = n[1] === "-" ? -1 : 1, i = {
    y: 0,
    d: gt(n[Wi]) * r,
    h: gt(n[he]) * r,
    m: gt(n[Mi]) * r,
    s: gt(n[bn]) * r,
    ms: gt(qf(n[Gr] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (n = iV.exec(e)) ? (r = n[1] === "-" ? -1 : 1, i = {
    y: Ir(n[2], r),
    M: Ir(n[3], r),
    w: Ir(n[4], r),
    d: Ir(n[5], r),
    h: Ir(n[6], r),
    m: Ir(n[7], r),
    s: Ir(n[8], r)
  }) : i == null ? i = {} : typeof i == "object" && ("from" in i || "to" in i) && (s = nV(
    Yt(i.from),
    Yt(i.to)
  ), i = {}, i.ms = s.milliseconds, i.M = s.months), a = new qc(i), pu(e) && bt(e, "_locale") && (a._locale = e._locale), pu(e) && bt(e, "_isValid") && (a._isValid = e._isValid), a;
}
Oi.fn = qc.prototype;
Oi.invalid = Hz;
function Ir(e, t) {
  var i = e && parseFloat(e.replace(",", "."));
  return (isNaN(i) ? 0 : i) * t;
}
function $y(e, t) {
  var i = {};
  return i.months = t.month() - e.month() + (t.year() - e.year()) * 12, e.clone().add(i.months, "M").isAfter(t) && --i.months, i.milliseconds = +t - +e.clone().add(i.months, "M"), i;
}
function nV(e, t) {
  var i;
  return e.isValid() && t.isValid() ? (t = zp(t, e), e.isBefore(t) ? i = $y(e, t) : (i = $y(t, e), i.milliseconds = -i.milliseconds, i.months = -i.months), i) : { milliseconds: 0, months: 0 };
}
function NS(e, t) {
  return function(i, n) {
    var r, a;
    return n !== null && !isNaN(+n) && (hS(
      t,
      "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), a = i, i = n, n = a), r = Oi(i, n), FS(this, r, e), this;
  };
}
function FS(e, t, i, n) {
  var r = t._milliseconds, a = qf(t._days), s = qf(t._months);
  e.isValid() && (n = n ?? !0, s && xS(e, Ho(e, "Month") + s * i), a && _S(e, "Date", Ho(e, "Date") + a * i), r && e._d.setTime(e._d.valueOf() + r * i), n && H.updateOffset(e, a || s));
}
var rV = NS(1, "add"), aV = NS(-1, "subtract");
function BS(e) {
  return typeof e == "string" || e instanceof String;
}
function sV(e) {
  return Ci(e) || Qo(e) || BS(e) || Cn(e) || lV(e) || oV(e) || e === null || e === void 0;
}
function oV(e) {
  var t = na(e) && !wp(e), i = !1, n = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, a, s = n.length;
  for (r = 0; r < s; r += 1)
    a = n[r], i = i || bt(e, a);
  return t && i;
}
function lV(e) {
  var t = Ti(e), i = !1;
  return t && (i = e.filter(function(n) {
    return !Cn(n) && BS(e);
  }).length === 0), t && i;
}
function uV(e) {
  var t = na(e) && !wp(e), i = !1, n = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, a;
  for (r = 0; r < n.length; r += 1)
    a = n[r], i = i || bt(e, a);
  return t && i;
}
function cV(e, t) {
  var i = e.diff(t, "days", !0);
  return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse";
}
function hV(e, t) {
  arguments.length === 1 && (arguments[0] ? sV(arguments[0]) ? (e = arguments[0], t = void 0) : uV(arguments[0]) && (t = arguments[0], e = void 0) : (e = void 0, t = void 0));
  var i = e || Yt(), n = zp(i, this).startOf("day"), r = H.calendarFormat(this, n) || "sameElse", a = t && (nn(t[r]) ? t[r].call(this, i) : t[r]);
  return this.format(
    a || this.localeData().calendar(r, this, Yt(i))
  );
}
function dV() {
  return new Jo(this);
}
function fV(e, t) {
  var i = Ci(e) ? e : Yt(e);
  return this.isValid() && i.isValid() ? (t = yi(t) || "millisecond", t === "millisecond" ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(t).valueOf()) : !1;
}
function vV(e, t) {
  var i = Ci(e) ? e : Yt(e);
  return this.isValid() && i.isValid() ? (t = yi(t) || "millisecond", t === "millisecond" ? this.valueOf() < i.valueOf() : this.clone().endOf(t).valueOf() < i.valueOf()) : !1;
}
function pV(e, t, i, n) {
  var r = Ci(e) ? e : Yt(e), a = Ci(t) ? t : Yt(t);
  return this.isValid() && r.isValid() && a.isValid() ? (n = n || "()", (n[0] === "(" ? this.isAfter(r, i) : !this.isBefore(r, i)) && (n[1] === ")" ? this.isBefore(a, i) : !this.isAfter(a, i))) : !1;
}
function gV(e, t) {
  var i = Ci(e) ? e : Yt(e), n;
  return this.isValid() && i.isValid() ? (t = yi(t) || "millisecond", t === "millisecond" ? this.valueOf() === i.valueOf() : (n = i.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf())) : !1;
}
function mV(e, t) {
  return this.isSame(e, t) || this.isAfter(e, t);
}
function _V(e, t) {
  return this.isSame(e, t) || this.isBefore(e, t);
}
function yV(e, t, i) {
  var n, r, a;
  if (!this.isValid())
    return NaN;
  if (n = zp(e, this), !n.isValid())
    return NaN;
  switch (r = (n.utcOffset() - this.utcOffset()) * 6e4, t = yi(t), t) {
    case "year":
      a = gu(this, n) / 12;
      break;
    case "month":
      a = gu(this, n);
      break;
    case "quarter":
      a = gu(this, n) / 3;
      break;
    case "second":
      a = (this - n) / 1e3;
      break;
    // 1000
    case "minute":
      a = (this - n) / 6e4;
      break;
    // 1000 * 60
    case "hour":
      a = (this - n) / 36e5;
      break;
    // 1000 * 60 * 60
    case "day":
      a = (this - n - r) / 864e5;
      break;
    // 1000 * 60 * 60 * 24, negate dst
    case "week":
      a = (this - n - r) / 6048e5;
      break;
    // 1000 * 60 * 60 * 24 * 7, negate dst
    default:
      a = this - n;
  }
  return i ? a : di(a);
}
function gu(e, t) {
  if (e.date() < t.date())
    return -gu(t, e);
  var i = (t.year() - e.year()) * 12 + (t.month() - e.month()), n = e.clone().add(i, "months"), r, a;
  return t - n < 0 ? (r = e.clone().add(i - 1, "months"), a = (t - n) / (n - r)) : (r = e.clone().add(i + 1, "months"), a = (t - n) / (r - n)), -(i + a) || 0;
}
H.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
H.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function bV() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function xV(e) {
  if (!this.isValid())
    return null;
  var t = e !== !0, i = t ? this.clone().utc() : this;
  return i.year() < 0 || i.year() > 9999 ? vu(
    i,
    t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : nn(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", vu(i, "Z")) : vu(
    i,
    t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function wV() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var e = "moment", t = "", i, n, r, a;
  return this.isLocal() || (e = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", t = "Z"), i = "[" + e + '("]', n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", a = t + '[")]', this.format(i + n + r + a);
}
function SV(e) {
  e || (e = this.isUtc() ? H.defaultFormatUtc : H.defaultFormat);
  var t = vu(this, e);
  return this.localeData().postformat(t);
}
function MV(e, t) {
  return this.isValid() && (Ci(e) && e.isValid() || Yt(e).isValid()) ? Oi({ to: this, from: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function kV(e) {
  return this.from(Yt(), e);
}
function DV(e, t) {
  return this.isValid() && (Ci(e) && e.isValid() || Yt(e).isValid()) ? Oi({ from: this, to: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function TV(e) {
  return this.to(Yt(), e);
}
function $S(e) {
  var t;
  return e === void 0 ? this._locale._abbr : (t = En(e), t != null && (this._locale = t), this);
}
var zS = _i(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(e) {
    return e === void 0 ? this.localeData() : this.locale(e);
  }
);
function VS() {
  return this._locale;
}
var hc = 1e3, Ja = 60 * hc, dc = 60 * Ja, HS = (365 * 400 + 97) * 24 * dc;
function ts(e, t) {
  return (e % t + t) % t;
}
function YS(e, t, i) {
  return e < 100 && e >= 0 ? new Date(e + 400, t, i) - HS : new Date(e, t, i).valueOf();
}
function WS(e, t, i) {
  return e < 100 && e >= 0 ? Date.UTC(e + 400, t, i) - HS : Date.UTC(e, t, i);
}
function CV(e) {
  var t, i;
  if (e = yi(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (i = this._isUTC ? WS : YS, e) {
    case "year":
      t = i(this.year(), 0, 1);
      break;
    case "quarter":
      t = i(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      t = i(this.year(), this.month(), 1);
      break;
    case "week":
      t = i(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      t = i(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      t = i(this.year(), this.month(), this.date());
      break;
    case "hour":
      t = this._d.valueOf(), t -= ts(
        t + (this._isUTC ? 0 : this.utcOffset() * Ja),
        dc
      );
      break;
    case "minute":
      t = this._d.valueOf(), t -= ts(t, Ja);
      break;
    case "second":
      t = this._d.valueOf(), t -= ts(t, hc);
      break;
  }
  return this._d.setTime(t), H.updateOffset(this, !0), this;
}
function AV(e) {
  var t, i;
  if (e = yi(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (i = this._isUTC ? WS : YS, e) {
    case "year":
      t = i(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      t = i(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      t = i(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      t = i(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      t = i(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      t = i(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      t = this._d.valueOf(), t += dc - ts(
        t + (this._isUTC ? 0 : this.utcOffset() * Ja),
        dc
      ) - 1;
      break;
    case "minute":
      t = this._d.valueOf(), t += Ja - ts(t, Ja) - 1;
      break;
    case "second":
      t = this._d.valueOf(), t += hc - ts(t, hc) - 1;
      break;
  }
  return this._d.setTime(t), H.updateOffset(this, !0), this;
}
function PV() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function EV() {
  return Math.floor(this.valueOf() / 1e3);
}
function LV() {
  return new Date(this.valueOf());
}
function OV() {
  var e = this;
  return [
    e.year(),
    e.month(),
    e.date(),
    e.hour(),
    e.minute(),
    e.second(),
    e.millisecond()
  ];
}
function IV() {
  var e = this;
  return {
    years: e.year(),
    months: e.month(),
    date: e.date(),
    hours: e.hours(),
    minutes: e.minutes(),
    seconds: e.seconds(),
    milliseconds: e.milliseconds()
  };
}
function RV() {
  return this.isValid() ? this.toISOString() : null;
}
function NV() {
  return Sp(this);
}
function FV() {
  return Gn({}, lt(this));
}
function BV() {
  return lt(this).overflow;
}
function $V() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
K("N", 0, 0, "eraAbbr");
K("NN", 0, 0, "eraAbbr");
K("NNN", 0, 0, "eraAbbr");
K("NNNN", 0, 0, "eraName");
K("NNNNN", 0, 0, "eraNarrow");
K("y", ["y", 1], "yo", "eraYear");
K("y", ["yy", 2], 0, "eraYear");
K("y", ["yyy", 3], 0, "eraYear");
K("y", ["yyyy", 4], 0, "eraYear");
U("N", Vp);
U("NN", Vp);
U("NNN", Vp);
U("NNNN", ZV);
U("NNNNN", KV);
Ot(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(e, t, i, n) {
    var r = i._locale.erasParse(e, n, i._strict);
    r ? lt(i).era = r : lt(i).invalidEra = e;
  }
);
U("y", gs);
U("yy", gs);
U("yyy", gs);
U("yyyy", gs);
U("yo", QV);
Ot(["y", "yy", "yyy", "yyyy"], Te);
Ot(["yo"], function(e, t, i, n) {
  var r;
  i._locale._eraYearOrdinalRegex && (r = e.match(i._locale._eraYearOrdinalRegex)), i._locale.eraYearOrdinalParse ? t[Te] = i._locale.eraYearOrdinalParse(e, r) : t[Te] = parseInt(e, 10);
});
function zV(e, t) {
  var i, n, r, a = this._eras || En("en")._eras;
  for (i = 0, n = a.length; i < n; ++i) {
    switch (typeof a[i].since) {
      case "string":
        r = H(a[i].since).startOf("day"), a[i].since = r.valueOf();
        break;
    }
    switch (typeof a[i].until) {
      case "undefined":
        a[i].until = 1 / 0;
        break;
      case "string":
        r = H(a[i].until).startOf("day").valueOf(), a[i].until = r.valueOf();
        break;
    }
  }
  return a;
}
function VV(e, t, i) {
  var n, r, a = this.eras(), s, o, l;
  for (e = e.toUpperCase(), n = 0, r = a.length; n < r; ++n)
    if (s = a[n].name.toUpperCase(), o = a[n].abbr.toUpperCase(), l = a[n].narrow.toUpperCase(), i)
      switch (t) {
        case "N":
        case "NN":
        case "NNN":
          if (o === e)
            return a[n];
          break;
        case "NNNN":
          if (s === e)
            return a[n];
          break;
        case "NNNNN":
          if (l === e)
            return a[n];
          break;
      }
    else if ([s, o, l].indexOf(e) >= 0)
      return a[n];
}
function HV(e, t) {
  var i = e.since <= e.until ? 1 : -1;
  return t === void 0 ? H(e.since).year() : H(e.since).year() + (t - e.offset) * i;
}
function YV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].name;
  return "";
}
function WV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].narrow;
  return "";
}
function UV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].abbr;
  return "";
}
function GV() {
  var e, t, i, n, r = this.localeData().eras();
  for (e = 0, t = r.length; e < t; ++e)
    if (i = r[e].since <= r[e].until ? 1 : -1, n = this.clone().startOf("day").valueOf(), r[e].since <= n && n <= r[e].until || r[e].until <= n && n <= r[e].since)
      return (this.year() - H(r[e].since).year()) * i + r[e].offset;
  return this.year();
}
function XV(e) {
  return bt(this, "_erasNameRegex") || Hp.call(this), e ? this._erasNameRegex : this._erasRegex;
}
function jV(e) {
  return bt(this, "_erasAbbrRegex") || Hp.call(this), e ? this._erasAbbrRegex : this._erasRegex;
}
function qV(e) {
  return bt(this, "_erasNarrowRegex") || Hp.call(this), e ? this._erasNarrowRegex : this._erasRegex;
}
function Vp(e, t) {
  return t.erasAbbrRegex(e);
}
function ZV(e, t) {
  return t.erasNameRegex(e);
}
function KV(e, t) {
  return t.erasNarrowRegex(e);
}
function QV(e, t) {
  return t._eraYearOrdinalRegex || gs;
}
function Hp() {
  var e = [], t = [], i = [], n = [], r, a, s, o, l, u = this.eras();
  for (r = 0, a = u.length; r < a; ++r)
    s = Sn(u[r].name), o = Sn(u[r].abbr), l = Sn(u[r].narrow), t.push(s), e.push(o), i.push(l), n.push(s), n.push(o), n.push(l);
  this._erasRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  );
}
K(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
K(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function Zc(e, t) {
  K(0, [e, e.length], 0, t);
}
Zc("gggg", "weekYear");
Zc("ggggg", "weekYear");
Zc("GGGG", "isoWeekYear");
Zc("GGGGG", "isoWeekYear");
U("G", Uc);
U("g", Uc);
U("GG", Wt, ti);
U("gg", Wt, ti);
U("GGGG", Ap, Cp);
U("gggg", Ap, Cp);
U("GGGGG", Wc, Hc);
U("ggggg", Wc, Hc);
el(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(e, t, i, n) {
    t[n.substr(0, 2)] = gt(e);
  }
);
el(["gg", "GG"], function(e, t, i, n) {
  t[n] = H.parseTwoDigitYear(e);
});
function JV(e) {
  return US.call(
    this,
    e,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function tH(e) {
  return US.call(
    this,
    e,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function eH() {
  return Mn(this.year(), 1, 4);
}
function iH() {
  return Mn(this.isoWeekYear(), 1, 4);
}
function nH() {
  var e = this.localeData()._week;
  return Mn(this.year(), e.dow, e.doy);
}
function rH() {
  var e = this.localeData()._week;
  return Mn(this.weekYear(), e.dow, e.doy);
}
function US(e, t, i, n, r) {
  var a;
  return e == null ? Wo(this, n, r).year : (a = Mn(e, n, r), t > a && (t = a), aH.call(this, e, t, i, n, r));
}
function aH(e, t, i, n, r) {
  var a = MS(e, t, i, n, r), s = Yo(a.year, 0, a.dayOfYear);
  return this.year(s.getUTCFullYear()), this.month(s.getUTCMonth()), this.date(s.getUTCDate()), this;
}
K("Q", 0, "Qo", "quarter");
U("Q", fS);
Ot("Q", function(e, t) {
  t[yn] = (gt(e) - 1) * 3;
});
function sH(e) {
  return e == null ? Math.ceil((this.month() + 1) / 3) : this.month((e - 1) * 3 + this.month() % 3);
}
K("D", ["DD", 2], "Do", "date");
U("D", Wt, ms);
U("DD", Wt, ti);
U("Do", function(e, t) {
  return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient;
});
Ot(["D", "DD"], Wi);
Ot("Do", function(e, t) {
  t[Wi] = gt(e.match(Wt)[0]);
});
var GS = _s("Date", !0);
K("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
U("DDD", Yc);
U("DDDD", vS);
Ot(["DDD", "DDDD"], function(e, t, i) {
  i._dayOfYear = gt(e);
});
function oH(e) {
  var t = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return e == null ? t : this.add(e - t, "d");
}
K("m", ["mm", 2], 0, "minute");
U("m", Wt, Pp);
U("mm", Wt, ti);
Ot(["m", "mm"], Mi);
var lH = _s("Minutes", !1);
K("s", ["ss", 2], 0, "second");
U("s", Wt, Pp);
U("ss", Wt, ti);
Ot(["s", "ss"], bn);
var uH = _s("Seconds", !1);
K("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
K(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
K(0, ["SSS", 3], 0, "millisecond");
K(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
K(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
K(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
K(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
K(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
K(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
U("S", Yc, fS);
U("SS", Yc, ti);
U("SSS", Yc, vS);
var Xn, XS;
for (Xn = "SSSS"; Xn.length <= 9; Xn += "S")
  U(Xn, gs);
function cH(e, t) {
  t[Gr] = gt(("0." + e) * 1e3);
}
for (Xn = "S"; Xn.length <= 9; Xn += "S")
  Ot(Xn, cH);
XS = _s("Milliseconds", !1);
K("z", 0, 0, "zoneAbbr");
K("zz", 0, 0, "zoneName");
function hH() {
  return this._isUTC ? "UTC" : "";
}
function dH() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var z = Jo.prototype;
z.add = rV;
z.calendar = hV;
z.clone = dV;
z.diff = yV;
z.endOf = AV;
z.format = SV;
z.from = MV;
z.fromNow = kV;
z.to = DV;
z.toNow = TV;
z.get = w$;
z.invalidAt = BV;
z.isAfter = fV;
z.isBefore = vV;
z.isBetween = pV;
z.isSame = gV;
z.isSameOrAfter = mV;
z.isSameOrBefore = _V;
z.isValid = NV;
z.lang = zS;
z.locale = $S;
z.localeData = VS;
z.max = Nz;
z.min = Rz;
z.parsingFlags = FV;
z.set = S$;
z.startOf = CV;
z.subtract = aV;
z.toArray = OV;
z.toObject = IV;
z.toDate = LV;
z.toISOString = xV;
z.inspect = wV;
typeof Symbol < "u" && Symbol.for != null && (z[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
z.toJSON = RV;
z.toString = bV;
z.unix = EV;
z.valueOf = PV;
z.creationData = $V;
z.eraName = YV;
z.eraNarrow = WV;
z.eraAbbr = UV;
z.eraYear = GV;
z.year = mS;
z.isLeapYear = x$;
z.weekYear = JV;
z.isoWeekYear = tH;
z.quarter = z.quarters = sH;
z.month = wS;
z.daysInMonth = L$;
z.week = z.weeks = z$;
z.isoWeek = z.isoWeeks = V$;
z.weeksInYear = nH;
z.weeksInWeekYear = rH;
z.isoWeeksInYear = eH;
z.isoWeeksInISOWeekYear = iH;
z.date = GS;
z.day = z.days = tz;
z.weekday = ez;
z.isoWeekday = iz;
z.dayOfYear = oH;
z.hour = z.hours = uz;
z.minute = z.minutes = lH;
z.second = z.seconds = uH;
z.millisecond = z.milliseconds = XS;
z.utcOffset = Uz;
z.utc = Xz;
z.local = jz;
z.parseZone = qz;
z.hasAlignedHourOffset = Zz;
z.isDST = Kz;
z.isLocal = Jz;
z.isUtcOffset = tV;
z.isUtc = RS;
z.isUTC = RS;
z.zoneAbbr = hH;
z.zoneName = dH;
z.dates = _i(
  "dates accessor is deprecated. Use date instead.",
  GS
);
z.months = _i(
  "months accessor is deprecated. Use month instead",
  wS
);
z.years = _i(
  "years accessor is deprecated. Use year instead",
  mS
);
z.zone = _i(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  Gz
);
z.isDSTShifted = _i(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  Qz
);
function fH(e) {
  return Yt(e * 1e3);
}
function vH() {
  return Yt.apply(null, arguments).parseZone();
}
function jS(e) {
  return e;
}
var xt = kp.prototype;
xt.calendar = J4;
xt.longDateFormat = n$;
xt.invalidDate = a$;
xt.ordinal = l$;
xt.preparse = jS;
xt.postformat = jS;
xt.relativeTime = c$;
xt.pastFuture = h$;
xt.set = K4;
xt.eras = zV;
xt.erasParse = VV;
xt.erasConvertYear = HV;
xt.erasAbbrRegex = jV;
xt.erasNameRegex = XV;
xt.erasNarrowRegex = qV;
xt.months = C$;
xt.monthsShort = A$;
xt.monthsParse = E$;
xt.monthsRegex = I$;
xt.monthsShortRegex = O$;
xt.week = N$;
xt.firstDayOfYear = $$;
xt.firstDayOfWeek = B$;
xt.weekdays = q$;
xt.weekdaysMin = K$;
xt.weekdaysShort = Z$;
xt.weekdaysParse = J$;
xt.weekdaysRegex = nz;
xt.weekdaysShortRegex = rz;
xt.weekdaysMinRegex = az;
xt.isPM = oz;
xt.meridiem = cz;
function fc(e, t, i, n) {
  var r = En(), a = en().set(n, t);
  return r[i](a, e);
}
function qS(e, t, i) {
  if (Cn(e) && (t = e, e = void 0), e = e || "", t != null)
    return fc(e, t, i, "month");
  var n, r = [];
  for (n = 0; n < 12; n++)
    r[n] = fc(e, n, i, "month");
  return r;
}
function Yp(e, t, i, n) {
  typeof e == "boolean" ? (Cn(t) && (i = t, t = void 0), t = t || "") : (t = e, i = t, e = !1, Cn(t) && (i = t, t = void 0), t = t || "");
  var r = En(), a = e ? r._week.dow : 0, s, o = [];
  if (i != null)
    return fc(t, (i + a) % 7, n, "day");
  for (s = 0; s < 7; s++)
    o[s] = fc(t, (s + a) % 7, n, "day");
  return o;
}
function pH(e, t) {
  return qS(e, t, "months");
}
function gH(e, t) {
  return qS(e, t, "monthsShort");
}
function mH(e, t, i) {
  return Yp(e, t, i, "weekdays");
}
function _H(e, t, i) {
  return Yp(e, t, i, "weekdaysShort");
}
function yH(e, t, i) {
  return Yp(e, t, i, "weekdaysMin");
}
Jn("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(e) {
    var t = e % 10, i = gt(e % 100 / 10) === 1 ? "th" : t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th";
    return e + i;
  }
});
H.lang = _i(
  "moment.lang is deprecated. Use moment.locale instead.",
  Jn
);
H.langData = _i(
  "moment.langData is deprecated. Use moment.localeData instead.",
  En
);
var un = Math.abs;
function bH() {
  var e = this._data;
  return this._milliseconds = un(this._milliseconds), this._days = un(this._days), this._months = un(this._months), e.milliseconds = un(e.milliseconds), e.seconds = un(e.seconds), e.minutes = un(e.minutes), e.hours = un(e.hours), e.months = un(e.months), e.years = un(e.years), this;
}
function ZS(e, t, i, n) {
  var r = Oi(t, i);
  return e._milliseconds += n * r._milliseconds, e._days += n * r._days, e._months += n * r._months, e._bubble();
}
function xH(e, t) {
  return ZS(this, e, t, 1);
}
function wH(e, t) {
  return ZS(this, e, t, -1);
}
function zy(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e);
}
function SH() {
  var e = this._milliseconds, t = this._days, i = this._months, n = this._data, r, a, s, o, l;
  return e >= 0 && t >= 0 && i >= 0 || e <= 0 && t <= 0 && i <= 0 || (e += zy(Kf(i) + t) * 864e5, t = 0, i = 0), n.milliseconds = e % 1e3, r = di(e / 1e3), n.seconds = r % 60, a = di(r / 60), n.minutes = a % 60, s = di(a / 60), n.hours = s % 24, t += di(s / 24), l = di(KS(t)), i += l, t -= zy(Kf(l)), o = di(i / 12), i %= 12, n.days = t, n.months = i, n.years = o, this;
}
function KS(e) {
  return e * 4800 / 146097;
}
function Kf(e) {
  return e * 146097 / 4800;
}
function MH(e) {
  if (!this.isValid())
    return NaN;
  var t, i, n = this._milliseconds;
  if (e = yi(e), e === "month" || e === "quarter" || e === "year")
    switch (t = this._days + n / 864e5, i = this._months + KS(t), e) {
      case "month":
        return i;
      case "quarter":
        return i / 3;
      case "year":
        return i / 12;
    }
  else
    switch (t = this._days + Math.round(Kf(this._months)), e) {
      case "week":
        return t / 7 + n / 6048e5;
      case "day":
        return t + n / 864e5;
      case "hour":
        return t * 24 + n / 36e5;
      case "minute":
        return t * 1440 + n / 6e4;
      case "second":
        return t * 86400 + n / 1e3;
      // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(t * 864e5) + n;
      default:
        throw new Error("Unknown unit " + e);
    }
}
function Ln(e) {
  return function() {
    return this.as(e);
  };
}
var QS = Ln("ms"), kH = Ln("s"), DH = Ln("m"), TH = Ln("h"), CH = Ln("d"), AH = Ln("w"), PH = Ln("M"), EH = Ln("Q"), LH = Ln("y"), OH = QS;
function IH() {
  return Oi(this);
}
function RH(e) {
  return e = yi(e), this.isValid() ? this[e + "s"]() : NaN;
}
function va(e) {
  return function() {
    return this.isValid() ? this._data[e] : NaN;
  };
}
var NH = va("milliseconds"), FH = va("seconds"), BH = va("minutes"), $H = va("hours"), zH = va("days"), VH = va("months"), HH = va("years");
function YH() {
  return di(this.days() / 7);
}
var fn = Math.round, Ua = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function WH(e, t, i, n, r) {
  return r.relativeTime(t || 1, !!i, e, n);
}
function UH(e, t, i, n) {
  var r = Oi(e).abs(), a = fn(r.as("s")), s = fn(r.as("m")), o = fn(r.as("h")), l = fn(r.as("d")), u = fn(r.as("M")), c = fn(r.as("w")), h = fn(r.as("y")), d = a <= i.ss && ["s", a] || a < i.s && ["ss", a] || s <= 1 && ["m"] || s < i.m && ["mm", s] || o <= 1 && ["h"] || o < i.h && ["hh", o] || l <= 1 && ["d"] || l < i.d && ["dd", l];
  return i.w != null && (d = d || c <= 1 && ["w"] || c < i.w && ["ww", c]), d = d || u <= 1 && ["M"] || u < i.M && ["MM", u] || h <= 1 && ["y"] || ["yy", h], d[2] = t, d[3] = +e > 0, d[4] = n, WH.apply(null, d);
}
function GH(e) {
  return e === void 0 ? fn : typeof e == "function" ? (fn = e, !0) : !1;
}
function XH(e, t) {
  return Ua[e] === void 0 ? !1 : t === void 0 ? Ua[e] : (Ua[e] = t, e === "s" && (Ua.ss = t - 1), !0);
}
function jH(e, t) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var i = !1, n = Ua, r, a;
  return typeof e == "object" && (t = e, e = !1), typeof e == "boolean" && (i = e), typeof t == "object" && (n = Object.assign({}, Ua, t), t.s != null && t.ss == null && (n.ss = t.s - 1)), r = this.localeData(), a = UH(this, !i, n, r), i && (a = r.pastFuture(+this, a)), r.postformat(a);
}
var Ld = Math.abs;
function Na(e) {
  return (e > 0) - (e < 0) || +e;
}
function Kc() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var e = Ld(this._milliseconds) / 1e3, t = Ld(this._days), i = Ld(this._months), n, r, a, s, o = this.asSeconds(), l, u, c, h;
  return o ? (n = di(e / 60), r = di(n / 60), e %= 60, n %= 60, a = di(i / 12), i %= 12, s = e ? e.toFixed(3).replace(/\.?0+$/, "") : "", l = o < 0 ? "-" : "", u = Na(this._months) !== Na(o) ? "-" : "", c = Na(this._days) !== Na(o) ? "-" : "", h = Na(this._milliseconds) !== Na(o) ? "-" : "", l + "P" + (a ? u + a + "Y" : "") + (i ? u + i + "M" : "") + (t ? c + t + "D" : "") + (r || n || e ? "T" : "") + (r ? h + r + "H" : "") + (n ? h + n + "M" : "") + (e ? h + s + "S" : "")) : "P0D";
}
var _t = qc.prototype;
_t.isValid = Vz;
_t.abs = bH;
_t.add = xH;
_t.subtract = wH;
_t.as = MH;
_t.asMilliseconds = QS;
_t.asSeconds = kH;
_t.asMinutes = DH;
_t.asHours = TH;
_t.asDays = CH;
_t.asWeeks = AH;
_t.asMonths = PH;
_t.asQuarters = EH;
_t.asYears = LH;
_t.valueOf = OH;
_t._bubble = SH;
_t.clone = IH;
_t.get = RH;
_t.milliseconds = NH;
_t.seconds = FH;
_t.minutes = BH;
_t.hours = $H;
_t.days = zH;
_t.weeks = YH;
_t.months = VH;
_t.years = HH;
_t.humanize = jH;
_t.toISOString = Kc;
_t.toString = Kc;
_t.toJSON = Kc;
_t.locale = $S;
_t.localeData = VS;
_t.toIsoString = _i(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  Kc
);
_t.lang = zS;
K("X", 0, 0, "unix");
K("x", 0, 0, "valueOf");
U("x", Uc);
U("X", p$);
Ot("X", function(e, t, i) {
  i._d = new Date(parseFloat(e) * 1e3);
});
Ot("x", function(e, t, i) {
  i._d = new Date(gt(e));
});
H.version = "2.30.1";
q4(Yt);
H.fn = z;
H.min = Fz;
H.max = Bz;
H.now = $z;
H.utc = en;
H.unix = fH;
H.months = pH;
H.isDate = Qo;
H.locale = Jn;
H.invalid = Vc;
H.duration = Oi;
H.isMoment = Ci;
H.weekdays = mH;
H.parseZone = vH;
H.localeData = En;
H.isDuration = pu;
H.monthsShort = gH;
H.weekdaysMin = yH;
H.defineLocale = Rp;
H.updateLocale = vz;
H.locales = pz;
H.weekdaysShort = _H;
H.normalizeUnits = yi;
H.relativeTimeRounding = GH;
H.relativeTimeThreshold = XH;
H.calendarFormat = cV;
H.prototype = z;
H.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const dt = (e) => e == null ? "0" : new Intl.NumberFormat("en-US").format(e), Vy = (e, t = "USD") => e == null ? "$0.00" : new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: t,
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(e), qH = { class: "booking-manager-card" }, ZH = { class: "card-header" }, KH = { class: "header-content" }, QH = {
  key: 0,
  class: "payment-success-badge"
}, JH = { class: "badge-value" }, t8 = {
  key: 0,
  class: "loading-state"
}, e8 = {
  key: 1,
  class: "error-state"
}, i8 = { class: "error-content" }, n8 = { class: "error-description" }, r8 = {
  key: 2,
  class: "card-body"
}, a8 = { class: "chart-section" }, s8 = { class: "chart-wrapper" }, o8 = {
  key: 0,
  class: "table-section"
}, l8 = { class: "table-wrapper" }, u8 = { class: "data-table" }, c8 = { class: "table-body" }, h8 = { class: "table-cell font-medium" }, d8 = { class: "table-cell text-center" }, f8 = { class: "table-cell text-center" }, v8 = { class: "percentage-text" }, p8 = { class: "table-cell text-center" }, g8 = { class: "table-cell" }, m8 = { class: "badges-container" }, _8 = { class: "badge badge-success" }, y8 = { class: "badge badge-error" }, b8 = { class: "table-cell" }, x8 = { class: "badges-container" }, w8 = { class: "badge badge-error" }, S8 = { class: "badge badge-warning" }, M8 = { class: "badge badge-yellow" }, k8 = { class: "badge badge-error" }, D8 = {
  key: 1,
  class: "empty-state"
}, T8 = /* @__PURE__ */ fe({
  __name: "BookingManager",
  props: {
    data: { default: () => ({
      total_booking_initiated: 0,
      total_booking_started: 0,
      total_payment_initiated: 0,
      total_not_found: 0,
      total_cancelled: 0,
      total_no_pending_balance: 0,
      total_errors: 0,
      total_payment_success: 0,
      total_payment_failed: 0,
      booking_manager_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    error: { default: null }
  },
  setup(e) {
    const t = e, i = X(() => t.data?.booking_manager_by_day ? [...t.data.booking_manager_by_day].sort(
      (s, o) => new Date(s.date).getTime() - new Date(o.date).getTime()
    ) : []), n = X(() => {
      const s = t.data, o = s.total_booking_initiated || 0, l = s.total_booking_started || 0, u = s.total_payment_initiated || 0, c = s.total_not_found || 0, h = s.total_cancelled || 0, d = s.total_no_pending_balance || 0, f = s.total_errors || 0, v = s.total_payment_success || 0, p = s.total_payment_failed || 0, g = Math.max(0, o - l), m = Math.max(0, l - u - c - h - d - f), _ = (w, S) => {
        const M = S > 0 ? Math.round(w / S * 100) : 0;
        return `${w.toLocaleString()} (${M}%)`;
      }, y = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Payment Initiated" },
        { name: "Not Found" },
        { name: "Cancelled" },
        { name: "No Pending Balance" },
        { name: "Errors" },
        { name: "Payment Success" },
        { name: "Payment Failed" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], b = [];
      return l > 0 && b.push({
        source: "Initiated",
        target: "Started",
        value: l,
        label: _(l, o)
      }), g > 0 && b.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: g,
        label: _(g, o)
      }), u > 0 && b.push({
        source: "Started",
        target: "Payment Initiated",
        value: u,
        label: _(u, l)
      }), c > 0 && b.push({
        source: "Started",
        target: "Not Found",
        value: c,
        label: _(c, l)
      }), h > 0 && b.push({
        source: "Started",
        target: "Cancelled",
        value: h,
        label: _(h, l)
      }), d > 0 && b.push({
        source: "Started",
        target: "No Pending Balance",
        value: d,
        label: _(d, l)
      }), f > 0 && b.push({
        source: "Started",
        target: "Errors",
        value: f,
        label: _(f, l)
      }), m > 0 && b.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: m,
        label: _(m, l)
      }), v > 0 && b.push({
        source: "Payment Initiated",
        target: "Payment Success",
        value: v,
        label: _(v, u)
      }), p > 0 && b.push({
        source: "Payment Initiated",
        target: "Payment Failed",
        value: p,
        label: _(p, u)
      }), { nodes: y, links: b };
    }), r = {
      Initiated: "#DBEAFE",
      Started: "#93C5FD",
      "Payment Initiated": "#FED7AA",
      "Not Found": "#FECACA",
      Cancelled: "#FED7AA",
      "No Pending Balance": "#FEF08A",
      Errors: "#FCA5A5",
      "Payment Success": "#86EFAC",
      "Payment Failed": "#FCA5A5",
      "Abandoned (Init)": "#FEE2E2",
      "Abandoned (Start)": "#FEE2E2"
    }, a = (s, o) => !o || o === 0 ? "0%" : `${Math.round(s / o * 100)}%`;
    return (s, o) => (E(), L("article", qH, [
      x("header", ZH, [
        x("div", KH, [
          o[1] || (o[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Booking Manager Metrics"),
            x("p", { class: "card-subtitle" }, "Booking manager workflow tracking and analysis")
          ], -1)),
          t.loading ? ht("", !0) : (E(), L("div", QH, [
            o[0] || (o[0] = x("p", { class: "badge-label" }, "Payment Success", -1)),
            x("p", JH, R(J(dt)(t.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      t.loading ? (E(), L("div", t8, [...o[2] || (o[2] = [
        Ht('<div class="loading-container" data-v-ee0076af><div class="chart-flow-loader" data-v-ee0076af><div class="flow-line flow-1" data-v-ee0076af></div><div class="flow-line flow-2" data-v-ee0076af></div><div class="flow-line flow-3" data-v-ee0076af></div><div class="flow-line flow-4" data-v-ee0076af></div><div class="flow-line flow-5" data-v-ee0076af></div></div><p class="loading-text" data-v-ee0076af>Loading booking data...</p></div>', 1)
      ])])) : t.error ? (E(), L("div", e8, [
        x("div", i8, [
          o[3] || (o[3] = x("div", { class: "error-icon-wrapper" }, [
            x("svg", {
              class: "error-icon",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
            }, [
              x("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              })
            ])
          ], -1)),
          o[4] || (o[4] = x("p", { class: "error-title" }, "Error loading data", -1)),
          x("p", n8, R(t.error), 1)
        ])
      ])) : (E(), L("div", r8, [
        x("section", a8, [
          x("div", s8, [
            de(fa, {
              data: n.value,
              "node-colors": r,
              height: "500px",
              "node-gap": 15
            }, null, 8, ["data"])
          ])
        ]),
        i.value.length > 0 ? (E(), L("section", o8, [
          o[6] || (o[6] = x("div", { class: "section-header" }, [
            x("h4", { class: "section-title" }, "Daily Overview")
          ], -1)),
          x("div", l8, [
            x("table", u8, [
              o[5] || (o[5] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Initiated"),
                  x("th", { class: "table-header" }, "Started"),
                  x("th", { class: "table-header" }, "Payment Initiated"),
                  x("th", { class: "table-header" }, "Payment Results"),
                  x("th", { class: "table-header" }, "Outcomes")
                ])
              ], -1)),
              x("tbody", c8, [
                (E(!0), L(Rt, null, ue(i.value, (l) => (E(), L("tr", {
                  key: l.date,
                  class: "table-row"
                }, [
                  x("td", h8, R(J(H)(l.date).format("DD/MM/YYYY")), 1),
                  x("td", d8, R(J(dt)(l.booking_initiated_count)), 1),
                  x("td", f8, [
                    mu(R(J(dt)(l.booking_started_count)) + " ", 1),
                    x("span", v8, " (" + R(a(l.booking_started_count, l.booking_initiated_count)) + ") ", 1)
                  ]),
                  x("td", p8, R(J(dt)(l.payment_initiated_count)), 1),
                  x("td", g8, [
                    x("div", m8, [
                      x("span", _8, " Success: " + R(l.payment_success_count ? J(dt)(l.payment_success_count) : "N/A"), 1),
                      x("span", y8, " Failed: " + R(l.payment_failed_count ? J(dt)(l.payment_failed_count) : "N/A"), 1)
                    ])
                  ]),
                  x("td", b8, [
                    x("div", x8, [
                      x("span", w8, " Not Found: " + R(l.not_found_count ? J(dt)(l.not_found_count) : "N/A"), 1),
                      x("span", S8, " Cancelled: " + R(l.cancelled_count ? J(dt)(l.cancelled_count) : "N/A"), 1),
                      x("span", M8, " No Balance: " + R(l.no_pending_balance_count ? J(dt)(l.no_pending_balance_count) : "N/A"), 1),
                      x("span", k8, " Errors: " + R(l.error_count ? J(dt)(l.error_count) : "N/A"), 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (E(), L("section", D8, [...o[7] || (o[7] = [
          Ht('<div class="empty-state-content" data-v-ee0076af><div class="empty-icon-wrapper" data-v-ee0076af><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-ee0076af><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" data-v-ee0076af></path></svg></div><p class="empty-title" data-v-ee0076af>No booking manager data available</p><p class="empty-description" data-v-ee0076af>No booking manager data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), C8 = /* @__PURE__ */ ne(T8, [["__scopeId", "data-v-ee0076af"]]), A8 = { class: "checkin-metrics-card" }, P8 = {
  key: 0,
  class: "loading-state"
}, E8 = {
  key: 1,
  class: "card-body"
}, L8 = {
  key: 0,
  class: "chart-section"
}, O8 = { class: "chart-wrapper" }, I8 = {
  key: 1,
  class: "table-section"
}, R8 = { class: "table-wrapper" }, N8 = { class: "data-table" }, F8 = { class: "table-body" }, B8 = { class: "table-cell font-medium" }, $8 = { class: "table-cell text-center" }, z8 = { class: "table-cell text-center" }, V8 = { class: "table-cell text-center" }, H8 = { class: "table-cell text-center" }, Y8 = { class: "table-cell text-center" }, W8 = { class: "table-cell text-center" }, U8 = { class: "table-cell text-left" }, G8 = {
  key: 0,
  class: "failed-steps"
}, X8 = { class: "step-name" }, j8 = { class: "step-count" }, q8 = {
  key: 1,
  class: "empty-cell"
}, Z8 = {
  key: 2,
  class: "empty-state"
}, K8 = {
  __name: "Checkin",
  props: {
    loading: {
      type: Boolean,
      default: !1
    },
    checkinData: {
      type: Object,
      default: () => ({
        total_checkin_init: 0,
        total_checkin_initiated: 0,
        total_checkin_init_abandoned: 0,
        total_checkin_started: 0,
        total_checkin_completed: 0,
        total_checkin_closed: 0,
        total_checkin_unrecovered: 0,
        checkin_by_day: []
      })
    },
    failedData: {
      type: Object,
      default: () => ({
        total_checkin_failed: 0,
        failed_by_step_by_day: [],
        unrecovered_by_step: []
      })
    }
  },
  setup(e) {
    const t = e, i = {
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }, n = {
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }, r = vi([]), a = X(() => t.checkinData ?? i), s = X(() => t.failedData ?? n), o = X(() => {
      const f = {
        // Main flow progression - from blue to purple to green
        "Checkin Init": "#93C5FD",
        // Blue for started state
        "Booking retrive": "#C7D2FE",
        // Light purple
        "Booking retrive success": "#A5B4FC",
        // Medium purple for success
        "Number of Passengers": "#8B8CF6",
        // Medium purple
        Completed: "#A7F3D0",
        // Light green
        "Closed with BP": "#7BE39E",
        // Green for success
        // Abandoned states - progressive yellow/orange
        "Abandoned (Init)": "#FCA5A5",
        // Light red
        "Abandoned (Started)": "#F87171",
        // Medium red
        "Abandoned (Flow)": "#EF4444",
        // Darker red
        "BP Error": "#EF4444",
        // Darker red for boarding pass error
        // Failed states - progressive red intensity
        Unrecovered: "#F87171"
        // Medium red for main unrecovered node
      };
      return (s.value.unrecovered_by_step || []).forEach((p) => {
        const m = p.step_name.replace(/_/g, " ").split(" ").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join(" "), _ = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        f[m] = _[m] || "#DC2626";
      }), f;
    }), l = (f, v) => !v || v === 0 ? "0%" : `${Math.round(f / v * 100)}%`, u = (f, v) => {
      const p = dt(f), g = l(f, v);
      return `${p} (${g})`;
    }, c = (f) => f.reduce((v, p) => v + p.failed_count, 0), h = X(() => {
      const f = [], v = [];
      if (!a.value.total_checkin_initiated)
        return { nodes: f, links: v };
      f.push({ name: "Checkin Init" }), f.push({ name: "Booking retrive" }), f.push({ name: "Booking retrive success" }), f.push({ name: "Number of Passengers" }), f.push({ name: "Completed" }), f.push({ name: "Closed with BP" });
      const p = a.value.total_checkin_initiated, g = a.value.total_checkin_init, m = a.value.total_checkin_init_abandoned, _ = g - m, y = a.value.total_checkin_started, b = a.value.total_checkin_completed, w = a.value.total_checkin_closed, S = s.value.unrecovered_by_step || [], M = S.reduce((D, P) => D + P.count, 0);
      if (console.log(JSON.stringify(a.value)), g > 0) {
        const D = Math.round(g / p * 100);
        v.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: g,
          label: `${g.toLocaleString()} (${D}%)`
        });
      }
      const k = p - g;
      if (k > 0) {
        const D = Math.round(k / p * 100);
        f.push({ name: "Abandoned (Init)" }), v.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: k,
          label: `${k.toLocaleString()} (${D}%)`
        });
      }
      if (m > 0) {
        const D = Math.round(m / p * 100);
        f.push({ name: "Abandoned (Started)" }), v.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: m,
          label: `${m.toLocaleString()} (${D}%)`
        });
      }
      if (_ > 0) {
        const D = Math.round(_ / p * 100);
        v.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: _,
          label: `${_.toLocaleString()} (${D}%)`
        });
      }
      if (y > 0) {
        const D = Math.round(y / p * 100);
        v.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: y,
          label: `${y.toLocaleString()} (${D}%)`
        });
      }
      if (b > 0) {
        const D = Math.round(b / y * 100);
        v.push({
          source: "Number of Passengers",
          target: "Completed",
          value: b,
          label: `${b.toLocaleString()} (${D}%)`
        });
      }
      if (S.length > 0 && M > 0) {
        f.push({ name: "Unrecovered" });
        const D = Math.round(M / y * 100);
        v.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: M,
          label: `${M.toLocaleString()} (${D}%)`
        }), S.forEach((P) => {
          const I = P.step_name.replace(/_/g, " ").split(" ").map((F) => F.charAt(0).toUpperCase() + F.slice(1)).join(" "), N = Math.round(P.count / y * 100);
          f.push({ name: I }), v.push({
            source: "Unrecovered",
            target: I,
            value: P.count,
            label: `${P.count.toLocaleString()} (${N}%)`
          });
        });
      }
      const T = y - (b + M);
      if (T > 0) {
        const D = Math.round(T / y * 100);
        f.push({ name: "Abandoned (Flow)" }), v.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: T,
          label: `${T.toLocaleString()} (${D}%)`
        });
      }
      const C = b - w;
      if (C > 0) {
        const D = Math.round(C / y * 100);
        f.push({ name: "BP Error" }), v.push({
          source: "Completed",
          target: "BP Error",
          value: C,
          label: `${C.toLocaleString()} (${D}%)`
        });
      }
      if (w > 0) {
        const D = Math.round(w / y * 100);
        v.push({
          source: "Completed",
          target: "Closed with BP",
          value: w,
          label: `${w.toLocaleString()} (${D}%)`
        });
      }
      return console.log(JSON.stringify(f)), console.log(JSON.stringify(v)), { nodes: f, links: v };
    }), d = () => {
      const f = a.value.checkin_by_day || [], v = s.value.failed_by_step_by_day || [];
      if (f.length === 0) {
        r.value = [];
        return;
      }
      r.value = [...f].map((p) => {
        const g = v.find(
          (m) => m.date === p.date
        );
        return {
          ...p,
          failed_steps: g?.steps || []
        };
      }), r.value.sort((p, g) => new Date(p.date) - new Date(g.date));
    };
    return es(
      [() => t.checkinData, () => t.failedData],
      () => {
        d();
      },
      { deep: !0, immediate: !0 }
    ), (f, v) => (E(), L("article", A8, [
      v[3] || (v[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Check-in Metrics"),
          x("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      t.loading ? (E(), L("div", P8, [...v[0] || (v[0] = [
        Ht('<div class="loading-container" data-v-739c92f1><div class="chart-flow-loader" data-v-739c92f1><div class="flow-line flow-1" data-v-739c92f1></div><div class="flow-line flow-2" data-v-739c92f1></div><div class="flow-line flow-3" data-v-739c92f1></div><div class="flow-line flow-4" data-v-739c92f1></div><div class="flow-line flow-5" data-v-739c92f1></div></div><p class="loading-text" data-v-739c92f1>Loading check-in data...</p></div>', 1)
      ])])) : (E(), L("div", E8, [
        h.value.nodes.length > 0 ? (E(), L("section", L8, [
          x("div", O8, [
            de(fa, {
              data: h.value,
              height: "500px",
              "node-colors": o.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : ht("", !0),
        r.value && r.value.length > 0 ? (E(), L("section", I8, [
          x("div", R8, [
            x("table", N8, [
              v[1] || (v[1] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Checkin Init"),
                  x("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  x("th", { class: "table-header" }, "Number of Passengers"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed with BP (%)"),
                  x("th", { class: "table-header" }, "Failed (%)"),
                  x("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              x("tbody", F8, [
                (E(!0), L(Rt, null, ue(r.value, (p) => (E(), L("tr", {
                  key: p.date,
                  class: "table-row"
                }, [
                  x("td", B8, R(J(H)(p.date).format("DD/MM/YYYY")), 1),
                  x("td", $8, R(J(dt)(p.checkin_initiated_count)), 1),
                  x("td", z8, R(u(p.checkin_init_count, p.checkin_initiated_count)), 1),
                  x("td", V8, R(J(dt)(p.checkin_started_count)), 1),
                  x("td", H8, R(u(p.checkin_completed_count, p.checkin_started_count)), 1),
                  x("td", Y8, R(u(p.checkin_closed_count, p.checkin_started_count)), 1),
                  x("td", W8, R(u(c(p.failed_steps), p.checkin_started_count)), 1),
                  x("td", U8, [
                    p.failed_steps && p.failed_steps.length > 0 ? (E(), L("div", G8, [
                      (E(!0), L(Rt, null, ue(p.failed_steps, (g) => (E(), L("div", {
                        key: g.step_name,
                        class: "failed-step-item"
                      }, [
                        x("span", X8, R(g.step_name.replace(/_/g, " ")) + ":", 1),
                        x("span", j8, R(g.failed_count), 1)
                      ]))), 128))
                    ])) : (E(), L("div", q8, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (E(), L("section", Z8, [...v[2] || (v[2] = [
          Ht('<div class="empty-state-content" data-v-739c92f1><div class="empty-icon-wrapper" data-v-739c92f1><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-739c92f1><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-739c92f1></path></svg></div><p class="empty-title" data-v-739c92f1>No check-in data available</p><p class="empty-description" data-v-739c92f1>Try adjusting the date range or check your filters to see check-in performance data.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}, Q8 = /* @__PURE__ */ ne(K8, [["__scopeId", "data-v-739c92f1"]]), J8 = { class: "checkin-metrics-card" }, t6 = {
  key: 0,
  class: "loading-state"
}, e6 = {
  key: 1,
  class: "card-body"
}, i6 = {
  key: 0,
  class: "sankey-section"
}, n6 = {
  key: 1,
  class: "table-section"
}, r6 = { class: "table-wrapper" }, a6 = { class: "data-table" }, s6 = { class: "table-body" }, o6 = { class: "table-cell date-cell" }, l6 = { class: "table-cell text-center" }, u6 = { class: "table-cell text-center" }, c6 = { class: "table-cell text-center" }, h6 = { class: "table-cell text-center" }, d6 = { class: "table-cell text-center" }, f6 = { class: "table-cell text-center" }, v6 = { class: "table-cell reasons-cell" }, p6 = {
  key: 0,
  class: "reasons-list"
}, g6 = { class: "reason-name" }, m6 = { class: "reason-count" }, _6 = {
  key: 1,
  class: "no-reasons"
}, y6 = {
  key: 2,
  class: "empty-state"
}, b6 = { class: "empty-state-content" }, x6 = { class: "empty-icon-wrapper" }, w6 = /* @__PURE__ */ fe({
  __name: "CheckinMetrics",
  props: {
    checkinData: { default: () => ({
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }) },
    failedData: { default: () => ({
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }) },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = (f) => f == null ? "0" : f.toLocaleString(), a = (f) => {
      const v = new Date(f), p = String(v.getDate()).padStart(2, "0"), g = String(v.getMonth() + 1).padStart(2, "0"), m = v.getFullYear();
      return `${p}/${g}/${m}`;
    }, s = (f) => f.replace(/_/g, " ").replace(/\b\w/g, (v) => v.toUpperCase()), o = (f, v) => !v || v === 0 ? "0%" : `${Math.round(f / v * 100)}%`, l = (f, v) => {
      const p = f || 0, g = v || 0, m = r(p), _ = o(p, g);
      return `${m} (${_})`;
    }, u = (f) => f ? f.reduce((v, p) => v + p.failed_count, 0) : 0, c = X(() => {
      const f = {
        "Checkin Init": "#93C5FD",
        "Booking retrive": "#C7D2FE",
        "Booking retrive success": "#A5B4FC",
        "Number of Passengers": "#8B8CF6",
        Completed: "#A7F3D0",
        "Closed with BP": "#7BE39E",
        "Abandoned (Init)": "#FCA5A5",
        "Abandoned (Started)": "#F87171",
        "Abandoned (Flow)": "#EF4444",
        "BP Error": "#EF4444",
        Unrecovered: "#F87171"
      };
      return (i.failedData?.unrecovered_by_step || []).forEach((p) => {
        const m = p.step_name.replace(/_/g, " ").split(" ").map((y) => y.charAt(0).toUpperCase() + y.slice(1)).join(" "), _ = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        f[m] = _[m] || "#DC2626";
      }), f;
    }), h = X(() => {
      const f = i.checkinData?.checkin_by_day || [], v = i.failedData?.failed_by_step_by_day || [];
      return f.map((g) => {
        const m = v.find((_) => _.date === g.date);
        return {
          ...g,
          failed_steps: m?.steps || []
        };
      }).sort((g, m) => new Date(g.date).getTime() - new Date(m.date).getTime());
    }), d = X(() => {
      const f = [], v = [];
      if (!i.checkinData?.total_checkin_initiated)
        return { nodes: f, links: v };
      f.push({ name: "Checkin Init" }), f.push({ name: "Booking retrive" }), f.push({ name: "Booking retrive success" }), f.push({ name: "Number of Passengers" }), f.push({ name: "Completed" }), f.push({ name: "Closed with BP" });
      const p = i.checkinData.total_checkin_initiated || 0, g = i.checkinData.total_checkin_init || 0, m = i.checkinData.total_checkin_init_abandoned || 0, _ = g - m, y = i.checkinData.total_checkin_started || 0, b = i.checkinData.total_checkin_completed || 0, w = i.checkinData.total_checkin_closed || 0, S = i.failedData?.unrecovered_by_step || [], M = S.reduce((D, P) => D + P.count, 0);
      if (g > 0) {
        const D = Math.round(g / p * 100);
        v.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: g,
          label: `${g.toLocaleString()} (${D}%)`
        });
      }
      const k = p - g;
      if (k > 0) {
        const D = Math.round(k / p * 100);
        f.push({ name: "Abandoned (Init)" }), v.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: k,
          label: `${k.toLocaleString()} (${D}%)`
        });
      }
      if (m > 0) {
        const D = Math.round(m / p * 100);
        f.push({ name: "Abandoned (Started)" }), v.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: m,
          label: `${m.toLocaleString()} (${D}%)`
        });
      }
      if (_ > 0) {
        const D = Math.round(_ / p * 100);
        v.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: _,
          label: `${_.toLocaleString()} (${D}%)`
        });
      }
      if (y > 0) {
        const D = Math.round(y / p * 100);
        v.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: y,
          label: `${y.toLocaleString()} (${D}%)`
        });
      }
      if (b > 0) {
        const D = Math.round(b / y * 100);
        v.push({
          source: "Number of Passengers",
          target: "Completed",
          value: b,
          label: `${b.toLocaleString()} (${D}%)`
        });
      }
      if (S.length > 0 && M > 0) {
        f.push({ name: "Unrecovered" });
        const D = Math.round(M / y * 100);
        v.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: M,
          label: `${M.toLocaleString()} (${D}%)`
        }), S.forEach((P) => {
          const I = P.step_name.replace(/_/g, " ").split(" ").map((F) => F.charAt(0).toUpperCase() + F.slice(1)).join(" "), N = Math.round(P.count / y * 100);
          f.push({ name: I }), v.push({
            source: "Unrecovered",
            target: I,
            value: P.count,
            label: `${P.count.toLocaleString()} (${N}%)`
          });
        });
      }
      const T = y - (b + M);
      if (T > 0) {
        const D = Math.round(T / y * 100);
        f.push({ name: "Abandoned (Flow)" }), v.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: T,
          label: `${T.toLocaleString()} (${D}%)`
        });
      }
      const C = b - w;
      if (C > 0) {
        const D = Math.round(C / y * 100);
        f.push({ name: "BP Error" }), v.push({
          source: "Completed",
          target: "BP Error",
          value: C,
          label: `${C.toLocaleString()} (${D}%)`
        });
      }
      if (w > 0) {
        const D = Math.round(w / y * 100);
        v.push({
          source: "Completed",
          target: "Closed with BP",
          value: w,
          label: `${w.toLocaleString()} (${D}%)`
        });
      }
      return { nodes: f, links: v };
    });
    return t({ isDark: n }), (f, v) => (E(), L("article", J8, [
      v[4] || (v[4] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Check-in Metrics"),
          x("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      e.loading ? (E(), L("div", t6, [...v[0] || (v[0] = [
        Ht('<div class="loading-container" data-v-b4a14ad3><div class="chart-bars-loader" data-v-b4a14ad3><div class="bar bar-1" data-v-b4a14ad3></div><div class="bar bar-2" data-v-b4a14ad3></div><div class="bar bar-3" data-v-b4a14ad3></div><div class="bar bar-4" data-v-b4a14ad3></div><div class="bar bar-5" data-v-b4a14ad3></div></div><p class="loading-text" data-v-b4a14ad3>Loading check-in data...</p></div>', 1)
      ])])) : (E(), L("div", e6, [
        d.value.nodes.length > 0 ? (E(), L("div", i6, [
          de(fa, {
            data: d.value,
            height: "500px",
            "node-colors": c.value,
            "use-gradient": !1,
            "node-gap": 30
          }, null, 8, ["data", "node-colors"])
        ])) : ht("", !0),
        h.value && h.value.length > 0 ? (E(), L("div", n6, [
          x("div", r6, [
            x("table", a6, [
              v[1] || (v[1] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Checkin Init"),
                  x("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  x("th", { class: "table-header" }, "Number of Passengers"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed with BP (%)"),
                  x("th", { class: "table-header" }, "Failed (%)"),
                  x("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              x("tbody", s6, [
                (E(!0), L(Rt, null, ue(h.value, (p) => (E(), L("tr", {
                  key: p.date,
                  class: "table-row"
                }, [
                  x("td", o6, R(a(p.date)), 1),
                  x("td", l6, R(r(p.checkin_initiated_count)), 1),
                  x("td", u6, R(l(p.checkin_init_count, p.checkin_initiated_count)), 1),
                  x("td", c6, R(r(p.checkin_started_count)), 1),
                  x("td", h6, R(l(p.checkin_completed_count, p.checkin_started_count)), 1),
                  x("td", d6, R(l(p.checkin_closed_count, p.checkin_started_count)), 1),
                  x("td", f6, R(l(u(p.failed_steps), p.checkin_started_count)), 1),
                  x("td", v6, [
                    p.failed_steps && p.failed_steps.length > 0 ? (E(), L("div", p6, [
                      (E(!0), L(Rt, null, ue(p.failed_steps, (g) => (E(), L("div", {
                        key: g.step_name,
                        class: "reason-item"
                      }, [
                        x("span", g6, R(s(g.step_name)) + ":", 1),
                        x("span", m6, R(g.failed_count), 1)
                      ]))), 128))
                    ])) : (E(), L("div", _6, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (E(), L("div", y6, [
          x("div", b6, [
            x("div", x6, [
              de(J(xp), { class: "empty-icon" })
            ]),
            v[2] || (v[2] = x("p", { class: "empty-title" }, "No check-in data available", -1)),
            v[3] || (v[3] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see check-in metrics.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), S6 = /* @__PURE__ */ ne(w6, [["__scopeId", "data-v-b4a14ad3"]]), M6 = { class: "checkin-segments-card" }, k6 = {
  key: 0,
  class: "loading-state"
}, D6 = {
  key: 1,
  class: "card-body"
}, T6 = {
  key: 0,
  class: "table-section"
}, C6 = { class: "table-wrapper" }, A6 = { class: "data-table" }, P6 = { class: "table-body" }, E6 = { class: "table-cell font-medium text-center" }, L6 = { class: "airport-badge" }, O6 = { class: "table-cell text-center" }, I6 = {
  key: 0,
  class: "airport-badge connection"
}, R6 = {
  key: 1,
  class: "empty-connection"
}, N6 = { class: "table-cell text-center" }, F6 = { class: "airport-badge" }, B6 = { class: "table-cell text-center" }, $6 = {
  key: 0,
  class: "trip-badge roundtrip"
}, z6 = {
  key: 1,
  class: "trip-badge oneway"
}, V6 = { class: "table-cell text-center" }, H6 = { class: "table-cell text-center" }, Y6 = { class: "percentage-value" }, W6 = { class: "table-cell text-center" }, U6 = { class: "percentage-value" }, G6 = { class: "table-cell text-center" }, X6 = { class: "percentage-value success" }, j6 = {
  key: 1,
  class: "empty-state"
}, q6 = /* @__PURE__ */ fe({
  __name: "checkinSegments",
  props: {
    data: { default: () => [] },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = (o, l) => !l || l === 0 || !o ? "0%" : `${Math.round(o / l * 100)}%`, a = (o) => !o || o === "None" ? "-" : String(o).trim().replace(/_[0-9]+$/i, ""), s = (o) => {
      const l = a(o?.departure_airport), u = a(o?.arrival_airport);
      return l === "-" || u === "-" ? !1 : l === u;
    };
    return t({ isDark: n }), (o, l) => (E(), L("article", M6, [
      l[5] || (l[5] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Checkin Segments"),
          x("p", { class: "card-subtitle" }, "Breakdown by flight segment with connection when applicable")
        ])
      ], -1)),
      i.loading ? (E(), L("div", k6, [...l[0] || (l[0] = [
        Ht('<div class="loading-container" data-v-af792a8b><div class="chart-flow-loader" data-v-af792a8b><div class="flow-line flow-1" data-v-af792a8b></div><div class="flow-line flow-2" data-v-af792a8b></div><div class="flow-line flow-3" data-v-af792a8b></div><div class="flow-line flow-4" data-v-af792a8b></div><div class="flow-line flow-5" data-v-af792a8b></div></div><p class="loading-text" data-v-af792a8b>Loading segment data...</p></div>', 1)
      ])])) : (E(), L("div", D6, [
        i.data.length > 0 ? (E(), L("section", T6, [
          x("div", C6, [
            x("table", A6, [
              l[3] || (l[3] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Departure"),
                  x("th", { class: "table-header" }, "Connection"),
                  x("th", { class: "table-header" }, "Arrival"),
                  x("th", { class: "table-header" }, "Trip"),
                  x("th", { class: "table-header" }, "Init"),
                  x("th", { class: "table-header" }, "Started (%)"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed (%)")
                ])
              ], -1)),
              x("tbody", P6, [
                (E(!0), L(Rt, null, ue(i.data, (u, c) => (E(), L("tr", {
                  key: c,
                  class: "table-row"
                }, [
                  x("td", E6, [
                    x("span", L6, R(a(u.departure_airport)), 1)
                  ]),
                  x("td", O6, [
                    a(u.conexion_airport) !== "-" ? (E(), L("span", I6, R(a(u.conexion_airport)), 1)) : (E(), L("span", R6, "-"))
                  ]),
                  x("td", N6, [
                    x("span", F6, R(a(u.arrival_airport)), 1)
                  ]),
                  x("td", B6, [
                    s(u) ? (E(), L("span", $6, [...l[1] || (l[1] = [
                      x("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        x("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                        })
                      ], -1),
                      mu(" Roundtrip ", -1)
                    ])])) : (E(), L("span", z6, [...l[2] || (l[2] = [
                      x("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        x("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M14 5l7 7m0 0l-7 7m7-7H3"
                        })
                      ], -1),
                      mu(" One way ", -1)
                    ])]))
                  ]),
                  x("td", V6, R(J(dt)(u.segment_init_count)), 1),
                  x("td", H6, [
                    x("span", Y6, R(r(u.segment_started_count, u.segment_init_count)), 1)
                  ]),
                  x("td", W6, [
                    x("span", U6, R(r(u.segment_completed_count, u.segment_init_count)), 1)
                  ]),
                  x("td", G6, [
                    x("span", X6, R(r(u.segment_closed_count, u.segment_init_count)), 1)
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (E(), L("section", j6, [...l[4] || (l[4] = [
          Ht('<div class="empty-state-content" data-v-af792a8b><div class="empty-icon-wrapper" data-v-af792a8b><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-af792a8b><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-af792a8b></path></svg></div><p class="empty-title" data-v-af792a8b>No segment data available</p><p class="empty-description" data-v-af792a8b>No flight segment data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), Z6 = /* @__PURE__ */ ne(q6, [["__scopeId", "data-v-af792a8b"]]), K6 = { class: "disruption-metrics-card" }, Q6 = { class: "card-header" }, J6 = { class: "header-content" }, tY = {
  key: 0,
  class: "payment-success-badge"
}, eY = { class: "badge-value" }, iY = {
  key: 0,
  class: "loading-state"
}, nY = {
  key: 1,
  class: "card-body"
}, rY = { class: "chart-section" }, aY = { class: "chart-wrapper" }, sY = {
  key: 1,
  class: "empty-chart"
}, oY = {
  key: 0,
  class: "table-section"
}, lY = { class: "table-wrapper" }, uY = { class: "data-table" }, cY = { class: "table-body" }, hY = { class: "table-cell font-medium text-center" }, dY = { class: "table-cell text-center" }, fY = { class: "table-cell text-center" }, vY = { class: "percentage-text" }, pY = { class: "table-cell text-center" }, gY = { class: "abandoned-value" }, mY = { class: "table-cell" }, _Y = { class: "badges-container badges-wrap" }, yY = { class: "badge badge-vol" }, bY = { class: "badge badge-confirm" }, xY = { class: "badge badge-not-confirm" }, wY = { class: "badge badge-reject" }, SY = { class: "badge badge-not-paid" }, MY = { class: "badge badge-success" }, kY = { class: "table-cell" }, DY = { class: "badges-container badges-wrap" }, TY = { class: "badge badge-inv" }, CY = { class: "badge badge-human" }, AY = { class: "badge badge-accept" }, PY = {
  key: 1,
  class: "empty-state"
}, EY = /* @__PURE__ */ fe({
  __name: "Disruption",
  props: {
    data: { default: () => ({
      total_disruption_conversations: 0,
      total_disruption_initiated: 0,
      total_voluntary: 0,
      total_involuntary: 0,
      total_accepted: 0,
      total_confirmed: 0,
      total_sell_success: 0,
      total_sell_failed: 0,
      total_finished: 0,
      total_payment_success: 0,
      disruption_by_day: []
    }) },
    loading: { type: Boolean, default: !1 }
  },
  setup(e) {
    const t = e, i = X(() => t.data?.disruption_by_day ? [...t.data.disruption_by_day].sort(
      (s, o) => new Date(s.date).getTime() - new Date(o.date).getTime()
    ) : []), n = (s, o) => !o || o === 0 ? "0%" : `${Math.round(s / o * 100)}%`, r = X(() => {
      const s = t.data, o = s.total_disruption_conversations || 0, l = s.total_disruption_initiated || 0, u = s.total_voluntary || 0, c = s.total_involuntary || 0, h = s.total_accepted || 0, d = s.total_confirmed || 0, f = s.total_sell_success || 0, v = s.total_sell_failed || 0, p = Math.max(0, o - l), g = Math.max(0, l - u - c), m = Math.max(0, c - h), _ = Math.max(0, u - d), y = v, b = Math.max(0, d - f - y), w = (k, T) => {
        const C = T > 0 ? Math.round(k / T * 100) : 0;
        return `${k.toLocaleString()} (${C}%)`;
      }, S = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Voluntary" },
        { name: "Confirmed" },
        { name: "Paid" },
        { name: "Not Paid" },
        { name: "Rejected" },
        { name: "Not Confirmed" },
        { name: "Involuntary" },
        { name: "Accepted" },
        { name: "Redirect to Human" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], M = [];
      return l > 0 && M.push({
        source: "Initiated",
        target: "Started",
        value: l,
        label: w(l, o)
      }), p > 0 && M.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: p,
        label: w(p, o)
      }), u > 0 && M.push({
        source: "Started",
        target: "Voluntary",
        value: u,
        label: w(u, o)
      }), c > 0 && M.push({
        source: "Started",
        target: "Involuntary",
        value: c,
        label: w(c, o)
      }), g > 0 && M.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: g,
        label: w(g, o)
      }), h > 0 && M.push({
        source: "Involuntary",
        target: "Accepted",
        value: h,
        label: w(h, o)
      }), m > 0 && M.push({
        source: "Involuntary",
        target: "Redirect to Human",
        value: m,
        label: w(m, o)
      }), d > 0 && M.push({
        source: "Voluntary",
        target: "Confirmed",
        value: d,
        label: w(d, o)
      }), _ > 0 && M.push({
        source: "Voluntary",
        target: "Not Confirmed",
        value: _,
        label: w(_, o)
      }), f > 0 && M.push({
        source: "Confirmed",
        target: "Paid",
        value: f,
        label: w(f, o)
      }), y > 0 && M.push({
        source: "Confirmed",
        target: "Rejected",
        value: y,
        label: w(y, o)
      }), b > 0 && M.push({
        source: "Confirmed",
        target: "Not Paid",
        value: b,
        label: w(b, o)
      }), { nodes: S, links: M };
    }), a = {
      Initiated: "#E5E7EB",
      Started: "#DBEAFE",
      "Abandoned (Start)": "#FEE2E2",
      Voluntary: "#FED7AA",
      Involuntary: "#E9D5FF",
      "Abandoned (Init)": "#FEE2E2",
      Accepted: "#86EFAC",
      "Redirect to Human": "#FCA5A5",
      Confirmed: "#BFDBFE",
      "Not Confirmed": "#FED7AA",
      Paid: "#86EFAC",
      Rejected: "#FCA5A5",
      "Not Paid": "#FED7AA"
    };
    return (s, o) => (E(), L("article", K6, [
      x("header", Q6, [
        x("div", J6, [
          o[1] || (o[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Disruption Metrics"),
            x("p", { class: "card-subtitle" }, "Disruption workflow performance and completion tracking")
          ], -1)),
          t.loading ? ht("", !0) : (E(), L("div", tY, [
            o[0] || (o[0] = x("p", { class: "badge-label" }, "Payment Success", -1)),
            x("p", eY, R(J(dt)(t.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      t.loading ? (E(), L("div", iY, [...o[2] || (o[2] = [
        Ht('<div class="loading-container" data-v-30893461><div class="chart-bars-loader" data-v-30893461><div class="bar bar-1" data-v-30893461></div><div class="bar bar-2" data-v-30893461></div><div class="bar bar-3" data-v-30893461></div><div class="bar bar-4" data-v-30893461></div><div class="bar bar-5" data-v-30893461></div></div><p class="loading-text" data-v-30893461>Loading disruption data...</p></div>', 1)
      ])])) : (E(), L("div", nY, [
        x("section", rY, [
          x("div", aY, [
            r.value.nodes.length > 0 && r.value.links.length > 0 ? (E(), qy(fa, {
              key: 0,
              data: r.value,
              "node-colors": a,
              height: "500px"
            }, null, 8, ["data"])) : (E(), L("div", sY, [...o[3] || (o[3] = [
              x("p", { class: "empty-chart-text" }, "No disruption data available for visualization", -1)
            ])]))
          ])
        ]),
        i.value && i.value.length > 0 ? (E(), L("section", oY, [
          o[5] || (o[5] = Ht('<div class="section-header" data-v-30893461><h4 class="section-title" data-v-30893461>Daily Overview</h4></div><div class="legend-container" data-v-30893461><p class="legend-title" data-v-30893461>Legend</p><div class="legend-items" data-v-30893461><div class="legend-group" data-v-30893461><span class="legend-label" data-v-30893461>Voluntary:</span><span class="badge badge-vol" data-v-30893461>VOL</span></div><div class="legend-group" data-v-30893461><span class="legend-label" data-v-30893461>Involuntary:</span><span class="badge badge-inv" data-v-30893461>INV</span></div><div class="legend-note" data-v-30893461><span data-v-30893461>Vol=Voluntary</span><span data-v-30893461></span><span data-v-30893461>Inv=Involuntary</span></div></div></div>', 2)),
          x("div", lY, [
            x("table", uY, [
              o[4] || (o[4] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Initiated"),
                  x("th", { class: "table-header" }, "Started"),
                  x("th", { class: "table-header" }, "Abandoned (%)"),
                  x("th", { class: "table-header" }, "Voluntary"),
                  x("th", { class: "table-header" }, "Involuntary")
                ])
              ], -1)),
              x("tbody", cY, [
                (E(!0), L(Rt, null, ue(i.value, (l) => (E(), L("tr", {
                  key: l.date,
                  class: "table-row"
                }, [
                  x("td", hY, R(J(H)(l.date).format("DD/MM")), 1),
                  x("td", dY, R(J(dt)(l.disruption_conversations)), 1),
                  x("td", fY, [
                    mu(R(J(dt)(l.disruption_initiated_count)) + " ", 1),
                    x("span", vY, " (" + R(n(l.disruption_initiated_count, l.disruption_conversations)) + ") ", 1)
                  ]),
                  x("td", pY, [
                    x("span", gY, R(J(dt)(l.disruption_initiated_count - l.voluntary_count - l.involuntary_count)) + " (" + R(n(l.disruption_initiated_count - l.voluntary_count - l.involuntary_count, l.disruption_conversations)) + ") ", 1)
                  ]),
                  x("td", mY, [
                    x("div", _Y, [
                      x("span", yY, " VOL " + R(J(dt)(l.voluntary_count)) + " (" + R(n(l.voluntary_count, l.disruption_conversations)) + ") ", 1),
                      x("span", bY, " Confirm " + R(J(dt)(l.confirmed_count)) + " (" + R(n(l.confirmed_count, l.disruption_conversations)) + ") ", 1),
                      x("span", xY, " Not Confirm " + R(J(dt)(l.voluntary_count - l.confirmed_count)) + " (" + R(n(l.voluntary_count - l.confirmed_count, l.disruption_conversations)) + ") ", 1),
                      x("span", wY, " Reject " + R(J(dt)(l.sell_failed_count)) + " (" + R(n(l.sell_failed_count, l.disruption_conversations)) + ") ", 1),
                      x("span", SY, " Not Paid " + R(J(dt)(Math.max(0, l.confirmed_count - l.sell_success_count - l.sell_failed_count))) + " (" + R(n(Math.max(0, l.confirmed_count - l.sell_success_count - l.sell_failed_count), l.disruption_conversations)) + ") ", 1),
                      x("span", MY, " Finish " + R(J(dt)(l.sell_success_count)) + " (" + R(n(l.sell_success_count, l.disruption_conversations)) + ") ", 1)
                    ])
                  ]),
                  x("td", kY, [
                    x("div", DY, [
                      x("span", TY, " INV " + R(J(dt)(l.involuntary_count)) + " (" + R(n(l.involuntary_count, l.disruption_conversations)) + ") ", 1),
                      x("span", CY, " Human " + R(J(dt)(l.involuntary_count - l.accepted_count)) + " (" + R(n(l.involuntary_count - l.accepted_count, l.disruption_conversations)) + ") ", 1),
                      x("span", AY, " Accept " + R(J(dt)(l.accepted_count)) + " (" + R(n(l.accepted_count, l.disruption_conversations)) + ") ", 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (E(), L("section", PY, [...o[6] || (o[6] = [
          Ht('<div class="empty-state-content" data-v-30893461><div class="empty-icon-wrapper" data-v-30893461><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-30893461><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" data-v-30893461></path></svg></div><p class="empty-title" data-v-30893461>No disruption data available</p><p class="empty-description" data-v-30893461>No disruption data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), LY = /* @__PURE__ */ ne(EY, [["__scopeId", "data-v-30893461"]]), OY = { class: "faq-metrics-card" }, IY = {
  key: 0,
  class: "card-body"
}, RY = { class: "kpi-grid" }, NY = { class: "kpi-card" }, FY = { class: "kpi-value" }, BY = { class: "kpi-card" }, $Y = { class: "kpi-value" }, zY = { class: "kpi-card" }, VY = { class: "kpi-value" }, HY = { class: "kpi-card" }, YY = { class: "kpi-value" }, WY = { class: "kpi-card" }, UY = { class: "kpi-value" }, GY = {
  key: 0,
  class: "chart-section"
}, XY = {
  key: 1,
  class: "empty-state"
}, jY = {
  key: 1,
  class: "loading-state"
}, qY = /* @__PURE__ */ fe({
  __name: "FAQ",
  props: {
    loading: { type: Boolean, default: !1 },
    data: { default: null },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n, colors: r } = ye(_e(i, "theme")), a = vi({ labels: [], datasets: [] }), s = X(() => i.data ?? {
      total_faq_events: 0,
      total_documents_found: 0,
      total_airline_information_retrieved: 0,
      total_booking_info_retrieved: 0,
      total_flight_status_retrieved: 0,
      faq_by_day: []
    }), o = X(() => ({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12
            },
            color: r.value.textSecondary
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: r.value.textSecondary,
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(0, 0, 0, 0.1)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'Space Grotesk', sans-serif",
            size: 14,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 13
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: r.value.textSecondary
          }
        },
        y: {
          type: "linear",
          display: !0,
          position: "left",
          beginAtZero: !0,
          grid: {
            color: r.value.gridLines
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: r.value.textSecondary
          }
        }
      },
      interaction: {
        mode: "nearest",
        axis: "x",
        intersect: !1
      }
    })), l = (u) => {
      if (!u) {
        a.value = { labels: [], datasets: [] };
        return;
      }
      const c = u.faq_by_day || [];
      if (c.length > 0) {
        const h = c.map((p) => H(p.date).format("MMM DD")), d = c.map((p) => p.airline_information_retrieved_count || 0), f = c.map((p) => p.flight_status_retrieved_count || 0), v = c.map((p) => p.booking_info_retrieved_count || 0);
        a.value = {
          labels: h,
          datasets: [
            {
              label: "Airline Information",
              data: d,
              borderColor: "#8b5cf6",
              backgroundColor: "rgba(139, 92, 246, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#8b5cf6",
              pointBorderColor: "#7c3aed",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Flight Status",
              data: f,
              borderColor: "#06b6d4",
              backgroundColor: "rgba(6, 182, 212, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#06b6d4",
              pointBorderColor: "#0891b2",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Booking Information",
              data: v,
              borderColor: "#f59e0b",
              backgroundColor: "rgba(245, 158, 11, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#f59e0b",
              pointBorderColor: "#d97706",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            }
          ]
        };
      } else
        a.value = { labels: [], datasets: [] };
    };
    return es(
      () => i.data,
      (u) => {
        l(u ?? null);
      },
      { deep: !0, immediate: !0 }
    ), t({ isDark: n }), (u, c) => (E(), L("article", OY, [
      c[7] || (c[7] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "FAQ Metrics"),
          x("p", { class: "card-subtitle" }, "Daily FAQ consultation and retrieval metrics")
        ])
      ], -1)),
      i.loading ? (E(), L("div", jY, [...c[6] || (c[6] = [
        Ht('<div class="loading-container" data-v-f7ea5669><div class="chart-bars-loader" data-v-f7ea5669><div class="bar bar-1" data-v-f7ea5669></div><div class="bar bar-2" data-v-f7ea5669></div><div class="bar bar-3" data-v-f7ea5669></div><div class="bar bar-4" data-v-f7ea5669></div><div class="bar bar-5" data-v-f7ea5669></div></div><p class="loading-text" data-v-f7ea5669>Loading FAQ metrics...</p></div>', 1)
      ])])) : (E(), L("div", IY, [
        x("div", RY, [
          x("div", NY, [
            c[0] || (c[0] = x("span", { class: "kpi-label" }, "Total FAQ", -1)),
            x("span", FY, R(J(dt)(s.value.total_faq_events)), 1)
          ]),
          x("div", BY, [
            c[1] || (c[1] = x("span", { class: "kpi-label" }, "Documents Found", -1)),
            x("span", $Y, R(J(dt)(s.value.total_documents_found)), 1)
          ]),
          x("div", zY, [
            c[2] || (c[2] = x("span", { class: "kpi-label" }, "Airline Info", -1)),
            x("span", VY, R(J(dt)(s.value.total_airline_information_retrieved)), 1)
          ]),
          x("div", HY, [
            c[3] || (c[3] = x("span", { class: "kpi-label" }, "Booking Info", -1)),
            x("span", YY, R(J(dt)(s.value.total_booking_info_retrieved)), 1)
          ]),
          x("div", WY, [
            c[4] || (c[4] = x("span", { class: "kpi-label" }, "Flight Status", -1)),
            x("span", UY, R(J(dt)(s.value.total_flight_status_retrieved)), 1)
          ])
        ]),
        a.value.labels && a.value.labels.length ? (E(), L("section", GY, [
          de(mv, {
            data: a.value,
            options: o.value
          }, null, 8, ["data", "options"])
        ])) : (E(), L("section", XY, [...c[5] || (c[5] = [
          Ht('<div class="empty-state-content" data-v-f7ea5669><div class="empty-icon-wrapper" data-v-f7ea5669><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-f7ea5669><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" data-v-f7ea5669></path></svg></div><p class="empty-title" data-v-f7ea5669>No FAQ data available</p><p class="empty-description" data-v-f7ea5669>No FAQ consultation data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), ZY = /* @__PURE__ */ ne(qY, [["__scopeId", "data-v-f7ea5669"]]), KY = { class: "messages-per-agent-card" }, QY = {
  key: 0,
  class: "card-body"
}, JY = {
  key: 0,
  class: "chart-section"
}, tW = {
  key: 1,
  class: "empty-state"
}, eW = { class: "empty-state-content" }, iW = { class: "empty-icon-wrapper" }, nW = {
  key: 1,
  class: "loading-state"
}, rW = /* @__PURE__ */ fe({
  __name: "MessagesPerAgent",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, n = e, { isDark: r, colors: a } = ye(_e(n, "theme")), s = X(() => {
      const l = n.data?.agents_by_day || {}, u = Object.keys(l).sort();
      if (u.length === 0)
        return { labels: [], datasets: [] };
      const c = /* @__PURE__ */ new Set();
      for (const f of Object.values(l))
        for (const v of Object.keys(f))
          c.add(v);
      const d = Array.from(c).map((f) => {
        const v = i[f] || "#94a3b8";
        return {
          label: f.charAt(0).toUpperCase() + f.slice(1).replace(/_/g, " "),
          data: u.map((p) => l[p]?.[f] || 0),
          borderColor: v,
          backgroundColor: `${v}20`,
          pointBackgroundColor: v,
          pointBorderColor: r.value ? "#1a1a1d" : "#ffffff",
          pointBorderWidth: 2,
          pointRadius: 5,
          pointHoverRadius: 7,
          tension: 0.3,
          fill: !1
        };
      });
      return {
        labels: u,
        datasets: d
      };
    }), o = X(() => n.options ? n.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            usePointStyle: !0,
            pointStyle: "circle",
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: a.value.textSecondary
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: a.value.tooltipBg,
          titleColor: a.value.tooltipText,
          bodyColor: a.value.tooltipText,
          borderColor: r.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: a.value.textSecondary
          }
        },
        y: {
          display: !0,
          beginAtZero: !0,
          grid: {
            color: a.value.gridLines
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: a.value.textSecondary
          }
        }
      }
    });
    return t({ isDark: r }), (l, u) => (E(), L("article", KY, [
      u[3] || (u[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Messages per Agent"),
          x("p", { class: "card-subtitle" }, "Agent interaction trends over time")
        ])
      ], -1)),
      e.loading ? (E(), L("div", nW, [...u[2] || (u[2] = [
        Ht('<div class="loading-container" data-v-990db308><div class="chart-lines-loader" data-v-990db308><div class="line line-1" data-v-990db308></div><div class="line line-2" data-v-990db308></div><div class="line line-3" data-v-990db308></div><div class="line line-4" data-v-990db308></div><div class="line line-5" data-v-990db308></div></div><p class="loading-text" data-v-990db308>Loading chart data...</p></div>', 1)
      ])])) : (E(), L("div", QY, [
        s.value.labels && s.value.labels.length ? (E(), L("section", JY, [
          de(mv, {
            data: s.value,
            options: o.value
          }, null, 8, ["data", "options"])
        ])) : (E(), L("section", tW, [
          x("div", eW, [
            x("div", iW, [
              de(J(xp), { class: "empty-icon" })
            ]),
            u[0] || (u[0] = x("p", { class: "empty-title" }, "No agent interactions data", -1)),
            u[1] || (u[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), aW = /* @__PURE__ */ ne(rW, [["__scopeId", "data-v-990db308"]]), sW = { class: "record-locator-card" }, oW = {
  key: 0,
  class: "loading-state"
}, lW = {
  key: 1,
  class: "card-body"
}, uW = {
  key: 0,
  class: "chart-section"
}, cW = { class: "chart-wrapper" }, hW = {
  key: 1,
  class: "table-section"
}, dW = { class: "table-wrapper" }, fW = { class: "data-table" }, vW = { class: "table-header-row" }, pW = {
  key: 0,
  class: "table-header"
}, gW = {
  key: 1,
  class: "table-header"
}, mW = { class: "table-body" }, _W = { class: "table-cell font-medium" }, yW = { class: "table-cell text-center" }, bW = { class: "table-cell text-center" }, xW = { class: "table-cell text-center" }, wW = { class: "table-cell text-center" }, SW = { class: "table-cell text-center success-value" }, MW = { class: "table-cell text-center failed-value" }, kW = { class: "table-cell text-center warning-value" }, DW = {
  key: 0,
  class: "table-cell text-center"
}, TW = {
  key: 1,
  class: "table-cell text-center failed-value"
}, CW = {
  key: 2,
  class: "empty-state"
}, AW = /* @__PURE__ */ fe({
  __name: "RecordLocator",
  props: {
    data: { default: () => ({
      total_checkin_initiated: 0,
      total_record_locator_init: 0,
      total_record_locator_started: 0,
      total_record_locator_completed: 0,
      total_record_locator_closed: 0,
      total_record_locator_failed: 0,
      total_record_locator_abandoned: 0,
      total_record_locator_init_abandoned: 0,
      record_locator_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    isAvianca: { type: Boolean, default: !1 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => i.data?.record_locator_by_day ? [...i.data.record_locator_by_day].sort(
      (c, h) => new Date(c.date).getTime() - new Date(h.date).getTime()
    ) : []), a = X(() => i.data), s = X(() => ({
      // Main flow progression - from blue to cyan to green
      "Checkin Init": "#93C5FD",
      // Blue for started state
      "Booking retrive": "#67E8F9",
      // Light cyan
      "Checkin Started": "#22D3EE",
      // Medium cyan
      "Checkin Completed": "#A7F3D0",
      // Light green
      "Checkin Closed": "#7BE39E",
      // Green for success
      // Abandoned states - progressive red
      "Abandoned (Init)": "#FCA5A5",
      // Light red
      "Abandoned (Started)": "#F87171",
      // Medium red
      "Abandoned (Flow)": "#EF4444",
      // Darker red
      // Failed states
      "Checkin Failed": "#F87171"
      // Medium red for main failed node
    })), o = (c, h) => !h || h === 0 ? "0%" : `${Math.round(c / h * 100)}%`, l = (c, h) => {
      const d = dt(c), f = o(c, h);
      return `${d} (${f})`;
    }, u = X(() => {
      const c = [], h = [];
      if (!a.value.total_checkin_initiated)
        return { nodes: c, links: h };
      c.push({ name: "Checkin Init" }), c.push({ name: "Booking retrive" }), c.push({ name: "Checkin Started" }), c.push({ name: "Checkin Completed" }), c.push({ name: "Checkin Closed" });
      const d = a.value.total_checkin_initiated, f = a.value.total_record_locator_init, v = a.value.total_record_locator_started, p = a.value.total_record_locator_completed, g = a.value.total_record_locator_closed, m = a.value.total_record_locator_failed, _ = a.value.total_record_locator_abandoned, y = a.value.total_record_locator_init_abandoned;
      if (f > 0) {
        const w = Math.round(f / d * 100);
        h.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: f,
          label: `${f.toLocaleString()} (${w}%)`
        });
      }
      const b = d - f;
      if (b > 0) {
        const w = Math.round(b / d * 100);
        c.push({ name: "Abandoned (Init)" }), h.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: b,
          label: `${b.toLocaleString()} (${w}%)`
        });
      }
      if (v > 0) {
        const w = Math.round(v / d * 100);
        h.push({
          source: "Booking retrive",
          target: "Checkin Started",
          value: v,
          label: `${v.toLocaleString()} (${w}%)`
        });
      }
      if (y > 0) {
        const w = Math.round(y / d * 100);
        c.push({ name: "Abandoned (Started)" }), h.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: y,
          label: `${y.toLocaleString()} (${w}%)`
        });
      }
      if (p > 0) {
        const w = Math.round(p / v * 100);
        h.push({
          source: "Checkin Started",
          target: "Checkin Completed",
          value: p,
          label: `${p.toLocaleString()} (${w}%)`
        });
      }
      if (g > 0) {
        const w = Math.round(g / v * 100);
        h.push({
          source: "Checkin Completed",
          target: "Checkin Closed",
          value: g,
          label: `${g.toLocaleString()} (${w}%)`
        });
      }
      if (m > 0) {
        const w = Math.round(m / v * 100);
        c.push({ name: "Checkin Failed" }), h.push({
          source: "Checkin Started",
          target: "Checkin Failed",
          value: m,
          label: `${m.toLocaleString()} (${w}%)`
        });
      }
      if (_ > 0) {
        const w = Math.round(_ / v * 100);
        c.push({ name: "Abandoned (Flow)" }), h.push({
          source: "Checkin Started",
          target: "Abandoned (Flow)",
          value: _,
          label: `${_.toLocaleString()} (${w}%)`
        });
      }
      return { nodes: c, links: h };
    });
    return t({ isDark: n }), (c, h) => (E(), L("article", sW, [
      h[10] || (h[10] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Checkin by Record Locator Metrics"),
          x("p", { class: "card-subtitle" }, "Checkin by record locator retrieval and completion analysis")
        ])
      ], -1)),
      i.loading ? (E(), L("div", oW, [...h[0] || (h[0] = [
        Ht('<div class="loading-container" data-v-053c7d07><div class="chart-flow-loader" data-v-053c7d07><div class="flow-line flow-1" data-v-053c7d07></div><div class="flow-line flow-2" data-v-053c7d07></div><div class="flow-line flow-3" data-v-053c7d07></div><div class="flow-line flow-4" data-v-053c7d07></div><div class="flow-line flow-5" data-v-053c7d07></div></div><p class="loading-text" data-v-053c7d07>Loading record locator data...</p></div>', 1)
      ])])) : (E(), L("div", lW, [
        u.value.nodes.length > 0 ? (E(), L("section", uW, [
          x("div", cW, [
            de(fa, {
              data: u.value,
              height: "500px",
              "node-colors": s.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : ht("", !0),
        r.value && r.value.length > 0 ? (E(), L("section", hW, [
          x("div", dW, [
            x("table", fW, [
              x("thead", null, [
                x("tr", vW, [
                  h[1] || (h[1] = x("th", { class: "table-header" }, "Date", -1)),
                  h[2] || (h[2] = x("th", { class: "table-header" }, "Checkin Init", -1)),
                  h[3] || (h[3] = x("th", { class: "table-header" }, "Booking Retrieve (%)", -1)),
                  h[4] || (h[4] = x("th", { class: "table-header" }, "Checkin Started", -1)),
                  h[5] || (h[5] = x("th", { class: "table-header" }, "Checkin Completed (%)", -1)),
                  h[6] || (h[6] = x("th", { class: "table-header" }, "Checkin Closed (%)", -1)),
                  h[7] || (h[7] = x("th", { class: "table-header" }, "Checkin Failed (%)", -1)),
                  h[8] || (h[8] = x("th", { class: "table-header" }, "Abandoned (%)", -1)),
                  i.isAvianca ? (E(), L("th", pW, "Create Payment")) : ht("", !0),
                  i.isAvianca ? (E(), L("th", gW, "Failed Payment")) : ht("", !0)
                ])
              ]),
              x("tbody", mW, [
                (E(!0), L(Rt, null, ue(r.value, (d) => (E(), L("tr", {
                  key: d.date,
                  class: "table-row"
                }, [
                  x("td", _W, R(J(H)(d.date).format("DD/MM/YYYY")), 1),
                  x("td", yW, R(J(dt)(d.checkin_initiated)), 1),
                  x("td", bW, R(l(d.record_locator_init_count, d.checkin_initiated)), 1),
                  x("td", xW, R(J(dt)(d.record_locator_started_count)), 1),
                  x("td", wW, R(l(d.record_locator_completed_count, d.record_locator_started_count)), 1),
                  x("td", SW, R(l(d.record_locator_closed_count, d.record_locator_started_count)), 1),
                  x("td", MW, R(l(d.record_locator_failed_count, d.record_locator_started_count)), 1),
                  x("td", kW, R(l(d.record_locator_abandoned_count, d.record_locator_started_count)), 1),
                  i.isAvianca ? (E(), L("td", DW, R(J(dt)(d.record_locator_create_payment_count)), 1)) : ht("", !0),
                  i.isAvianca ? (E(), L("td", TW, R(J(dt)(d.record_locator_create_payment_failed_count)), 1)) : ht("", !0)
                ]))), 128))
              ])
            ])
          ])
        ])) : (E(), L("section", CW, [...h[9] || (h[9] = [
          Ht('<div class="empty-state-content" data-v-053c7d07><div class="empty-icon-wrapper" data-v-053c7d07><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-053c7d07><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" data-v-053c7d07></path></svg></div><p class="empty-title" data-v-053c7d07>No record locator data available</p><p class="empty-description" data-v-053c7d07>No record locator data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), PW = /* @__PURE__ */ ne(AW, [["__scopeId", "data-v-053c7d07"]]), EW = { class: "seller-metrics-card" }, LW = { class: "card-header" }, OW = { class: "header-content" }, IW = {
  key: 0,
  class: "stats-badge"
}, RW = { class: "badge-value" }, NW = {
  key: 0,
  class: "loading-state"
}, FW = {
  key: 1,
  class: "card-body"
}, BW = {
  key: 0,
  class: "chart-section"
}, $W = { class: "chart-wrapper" }, zW = {
  key: 1,
  class: "empty-state"
}, VW = {
  key: 2,
  class: "table-section"
}, HW = { class: "table-wrapper" }, YW = { class: "data-table" }, WW = { class: "table-body" }, UW = { class: "table-cell font-medium" }, GW = { class: "table-cell text-center" }, XW = { class: "table-cell text-center" }, jW = { class: "table-cell text-center" }, qW = { class: "table-cell text-center" }, ZW = { class: "table-cell text-center" }, KW = { class: "table-cell text-center success-value" }, QW = { class: "table-cell text-left" }, JW = {
  key: 0,
  class: "failed-reasons"
}, t9 = { class: "reason-name" }, e9 = { class: "reason-count" }, i9 = {
  key: 1,
  class: "empty-cell"
}, n9 = /* @__PURE__ */ fe({
  __name: "Seller",
  props: {
    sellerData: { default: () => ({
      total_seller_conversations: 0,
      total_sell_started: 0,
      total_sell_get_quote: 0,
      total_sell_booking_created: 0,
      total_sell_success: 0,
      total_value_sell_success: 0,
      seller_by_day: []
    }) },
    failedData: { default: () => ({
      total_sell_failed: 0,
      failed_by_reason_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => {
      if (!i.sellerData?.seller_by_day) return [];
      const d = [...i.sellerData.seller_by_day];
      return i.failedData?.failed_by_reason_by_day && i.failedData.failed_by_reason_by_day.forEach((f) => {
        const v = d.findIndex((p) => p.date === f.date);
        v !== -1 ? d[v] = { ...d[v], reasons: f.reasons } : d.push({
          date: f.date,
          seller_conversations: 0,
          sell_started_count: 0,
          sell_get_quote_count: 0,
          sell_booking_created_count: 0,
          sell_success_count: 0,
          daily_value_sell_success: 0,
          reasons: f.reasons
        });
      }), d.sort((f, v) => new Date(f.date).getTime() - new Date(v.date).getTime());
    }), a = X(() => i.sellerData), s = X(() => i.failedData), o = X(() => {
      const {
        total_seller_conversations: d = 0,
        total_sell_started: f = 0,
        total_sell_booking_created: v = 0,
        total_sell_success: p = 0
      } = a.value, { failed_by_reason_by_day: g = [] } = s.value;
      if (d === 0) return { nodes: [], links: [] };
      const m = [
        { name: "Sell Initiated", value: d },
        { name: "Sell Started", value: f },
        { name: "Booking Created", value: v },
        { name: "Sell Success", value: p }
      ], _ = [], y = d - f;
      if (y > 0) {
        const M = Math.round(y / d * 100);
        m.push({ name: "Abandoned (Init)", value: y }), _.push({
          source: "Sell Initiated",
          target: "Abandoned (Init)",
          value: y,
          label: `${y.toLocaleString()} (${M}%)`
        });
      }
      if (f > 0) {
        const M = Math.round(f / d * 100);
        _.push({
          source: "Sell Initiated",
          target: "Sell Started",
          value: f,
          label: `${f.toLocaleString()} (${M}%)`
        });
      }
      const b = g.reduce((M, k) => (k.reasons && Array.isArray(k.reasons) && k.reasons.forEach((T) => {
        const C = T.reason, D = T.failed_count;
        M[C] = (M[C] || 0) + D;
      }), M), {});
      if (v > 0) {
        const M = Math.round(v / d * 100);
        _.push({
          source: "Sell Started",
          target: "Booking Created",
          value: v,
          label: `${v.toLocaleString()} (${M}%)`
        });
      }
      if (p > 0) {
        const M = Math.round(p / d * 100);
        _.push({
          source: "Booking Created",
          target: "Sell Success",
          value: p,
          label: `${p.toLocaleString()} (${M}%)`
        });
      }
      const w = f - v;
      if (w > 0) {
        const M = Math.round(w / d * 100);
        m.push({ name: "Failed at Booking", value: w }), _.push({
          source: "Sell Started",
          target: "Failed at Booking",
          value: w,
          label: `${w.toLocaleString()} (${M}%)`
        });
      }
      if (Object.keys(b).length > 0) {
        const M = Object.values(b).reduce((T, C) => T + C, 0), k = w - M;
        if (Object.entries(b).filter(([, T]) => T > 0).sort(([, T], [, C]) => C - T).forEach(([T, C]) => {
          const D = Math.round(C / d * 100);
          m.push({ name: `Failed: ${T}`, value: C }), _.push({
            source: "Failed at Booking",
            target: `Failed: ${T}`,
            value: C,
            label: `${C.toLocaleString()} (${D}%)`
          });
        }), k > 0) {
          const T = Math.round(k / d * 100);
          m.push({ name: "Failed: Without Reason", value: k }), _.push({
            source: "Failed at Booking",
            target: "Failed: Without Reason",
            value: k,
            label: `${k.toLocaleString()} (${T}%)`
          });
        }
      }
      const S = v - p;
      if (S > 0) {
        const M = Math.round(S / d * 100);
        m.push({ name: "Failed at Completion", value: S }), _.push({
          source: "Booking Created",
          target: "Failed at Completion",
          value: S,
          label: `${S.toLocaleString()} (${M}%)`
        });
      }
      return { nodes: m, links: _ };
    }), l = {
      "Sell Initiated": "#DBEAFE",
      "Abandoned (Init)": "#FEE2E2",
      "Sell Started": "#93C5FD",
      "Get Quote": "#C7D2FE",
      "Booking Created": "#8B8CF6",
      "Sell Success": "#7BE39E",
      "Sell Failed": "#FCA5A5",
      "Failed at Quote": "#FCA5A5",
      "Failed at Booking": "#F87171",
      "Failed at Completion": "#EF4444",
      "Failed: rejected": "#F87171",
      "Failed: payment_processing": "#EF4444",
      "Failed: seat_selection": "#F87171",
      "Failed: booking_validation": "#EF4444",
      "Failed: flight_availability": "#DC2626",
      "Failed: passenger_data": "#F87171",
      "Failed: system_error": "#DC2626",
      "Failed: timeout": "#EF4444",
      "Failed: Without Reason": "#F87171"
    }, u = X(() => l), c = (d, f) => !f || f === 0 ? "0%" : `${Math.round(d / f * 100)}%`, h = (d, f) => {
      const v = dt(d), p = c(d, f);
      return `${v} (${p})`;
    };
    return t({ isDark: n }), (d, f) => (E(), L("article", EW, [
      x("header", LW, [
        x("div", OW, [
          f[1] || (f[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Seller Metrics"),
            x("p", { class: "card-subtitle" }, "Sales performance and failure analysis")
          ], -1)),
          i.loading ? ht("", !0) : (E(), L("div", IW, [
            f[0] || (f[0] = x("p", { class: "badge-label" }, "Total Sales Value", -1)),
            x("p", RW, R(J(Vy)(i.sellerData.total_value_sell_success)), 1)
          ]))
        ])
      ]),
      i.loading ? (E(), L("div", NW, [...f[2] || (f[2] = [
        Ht('<div class="loading-container" data-v-23fa99be><div class="chart-flow-loader" data-v-23fa99be><div class="flow-line flow-1" data-v-23fa99be></div><div class="flow-line flow-2" data-v-23fa99be></div><div class="flow-line flow-3" data-v-23fa99be></div><div class="flow-line flow-4" data-v-23fa99be></div><div class="flow-line flow-5" data-v-23fa99be></div></div><p class="loading-text" data-v-23fa99be>Loading sales data...</p></div>', 1)
      ])])) : (E(), L("div", FW, [
        o.value.nodes.length > 0 ? (E(), L("section", BW, [
          x("div", $W, [
            de(fa, {
              data: o.value,
              "node-colors": u.value,
              title: "",
              height: "320px"
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : (E(), L("section", zW, [...f[3] || (f[3] = [
          Ht('<div class="empty-state-content" data-v-23fa99be><div class="empty-icon-wrapper" data-v-23fa99be><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-23fa99be><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-23fa99be></path></svg></div><p class="empty-title" data-v-23fa99be>No sales data available</p><p class="empty-description" data-v-23fa99be>No sales data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])])),
        r.value && r.value.length > 0 ? (E(), L("section", VW, [
          x("div", HW, [
            x("table", YW, [
              f[4] || (f[4] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Sell Initiated"),
                  x("th", { class: "table-header" }, "Sell Started"),
                  x("th", { class: "table-header" }, "Get Quote"),
                  x("th", { class: "table-header" }, "Booking Created"),
                  x("th", { class: "table-header" }, "Sell Success"),
                  x("th", { class: "table-header" }, "Total Sales Value"),
                  x("th", { class: "table-header" }, "Failed")
                ])
              ], -1)),
              x("tbody", WW, [
                (E(!0), L(Rt, null, ue(r.value, (v) => (E(), L("tr", {
                  key: v.date,
                  class: "table-row"
                }, [
                  x("td", UW, R(J(H)(v.date).format("DD/MM/YYYY")), 1),
                  x("td", GW, R(J(dt)(v.seller_conversations || 0)), 1),
                  x("td", XW, R(h(v.sell_started_count, v.seller_conversations || v.sell_started_count)), 1),
                  x("td", jW, R(h(v.sell_get_quote_count, v.seller_conversations || v.sell_started_count)), 1),
                  x("td", qW, R(h(v.sell_booking_created_count, v.seller_conversations || v.sell_started_count)), 1),
                  x("td", ZW, R(h(v.sell_success_count, v.seller_conversations || v.sell_started_count)), 1),
                  x("td", KW, R(J(Vy)(v.daily_value_sell_success)), 1),
                  x("td", QW, [
                    v.reasons && v.reasons.length > 0 ? (E(), L("div", JW, [
                      (E(!0), L(Rt, null, ue(v.reasons, (p) => (E(), L("div", {
                        key: p.reason,
                        class: "failed-reason-item"
                      }, [
                        x("span", t9, R(p.reason) + ":", 1),
                        x("span", e9, R(p.failed_count), 1)
                      ]))), 128))
                    ])) : (E(), L("div", i9, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : ht("", !0)
      ]))
    ]));
  }
}), r9 = /* @__PURE__ */ ne(n9, [["__scopeId", "data-v-23fa99be"]]), a9 = { class: "top-agents-card" }, s9 = {
  key: 0,
  class: "card-body"
}, o9 = {
  key: 0,
  class: "chart-section"
}, l9 = {
  key: 1,
  class: "empty-state"
}, u9 = { class: "empty-state-content" }, c9 = { class: "empty-icon-wrapper" }, h9 = {
  key: 1,
  class: "loading-state"
}, d9 = /* @__PURE__ */ fe({
  __name: "TopAgents",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, n = e, { isDark: r, colors: a } = ye(_e(n, "theme")), s = X(() => {
      const u = (n.data?.top_agents || []).filter(
        (f) => f.agent_type?.toLowerCase() !== "triage"
      );
      if (u.length === 0)
        return { labels: [], datasets: [] };
      const c = u.reduce(
        (f, v) => f + (Number(v.conversations) || 0),
        0
      ), h = u.map((f) => {
        const v = f.agent_type?.toLowerCase();
        return i[v] || "#94a3b8";
      }), d = h.map((f) => `${f}80`);
      return {
        labels: u.map((f) => {
          const v = Number(f.conversations) || 0, p = c ? v / c * 100 : 0;
          return `${f.agent_type} - ${v.toLocaleString()} (${p.toFixed(1)}%)`;
        }),
        datasets: [
          {
            data: u.map((f) => f.conversations),
            backgroundColor: d,
            borderColor: h,
            borderWidth: 2
          }
        ]
      };
    }), o = X(() => n.options ? n.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          position: "bottom",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: a.value.textSecondary
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: a.value.tooltipBg,
          titleColor: a.value.tooltipText,
          bodyColor: a.value.tooltipText,
          borderColor: r.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          callbacks: {
            label: (l) => {
              const u = (l.label || "").toString().split(" - ")[0], c = Number(l.parsed) || 0, h = (l.dataset.data || []).reduce(
                (f, v) => f + (Number(v) || 0),
                0
              ), d = h ? c / h * 100 : 0;
              return `${u}: ${c.toLocaleString()} (${d.toFixed(1)}%)`;
            }
          }
        }
      }
    });
    return t({ isDark: r }), (l, u) => (E(), L("article", a9, [
      u[3] || (u[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Top Agents"),
          x("p", { class: "card-subtitle" }, "Interactions by agent (excluding triage)")
        ])
      ], -1)),
      e.loading ? (E(), L("div", h9, [...u[2] || (u[2] = [
        Ht('<div class="loading-container" data-v-84d73344><div class="chart-lines-loader" data-v-84d73344><div class="line line-1" data-v-84d73344></div><div class="line line-2" data-v-84d73344></div><div class="line line-3" data-v-84d73344></div><div class="line line-4" data-v-84d73344></div><div class="line line-5" data-v-84d73344></div></div><p class="loading-text" data-v-84d73344>Loading chart data...</p></div>', 1)
      ])])) : (E(), L("div", s9, [
        s.value.labels && s.value.labels.length ? (E(), L("section", o9, [
          de(jb, {
            data: s.value,
            options: o.value
          }, null, 8, ["data", "options"])
        ])) : (E(), L("section", l9, [
          x("div", u9, [
            x("div", c9, [
              de(J($4), { class: "empty-icon" })
            ]),
            u[0] || (u[0] = x("p", { class: "empty-title" }, "No top agents data", -1)),
            u[1] || (u[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), f9 = /* @__PURE__ */ ne(d9, [["__scopeId", "data-v-84d73344"]]), v9 = { class: "nps-daily-card" }, p9 = { class: "card-header" }, g9 = { class: "header-content" }, m9 = {
  key: 0,
  class: "stats-badge"
}, _9 = { class: "badge-value" }, y9 = {
  key: 0,
  class: "loading-state"
}, b9 = {
  key: 1,
  class: "card-body"
}, x9 = { class: "tooltip-content" }, w9 = { class: "tooltip-title" }, S9 = { class: "tooltip-stats" }, M9 = { class: "tooltip-stat-row" }, k9 = { class: "tooltip-value" }, D9 = { class: "tooltip-stat-row" }, T9 = { class: "tooltip-value" }, C9 = { class: "tooltip-stat-row" }, A9 = { class: "tooltip-value" }, P9 = { class: "tooltip-stat-row" }, E9 = { class: "tooltip-value" }, L9 = { class: "tooltip-stat-row" }, O9 = { class: "tooltip-value" }, I9 = { class: "tooltip-stat-row" }, R9 = { class: "tooltip-value" }, N9 = {
  key: 2,
  class: "empty-state"
}, Hy = 400, Xs = 60, Yy = 90, Wy = 120, F9 = {
  __name: "npsDailyMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => i.data), a = vi(null), s = vi({
      visible: !1,
      x: 0,
      y: 0,
      date: "",
      min: "",
      max: "",
      q1: "",
      avg: "",
      q3: "",
      median: ""
    }), o = X(() => {
      if (!r.value || !r.value.nps_by_day) return 800;
      const f = r.value.nps_by_day.length;
      return Math.max(800, Xs * 2 + f * Wy);
    }), l = (f, v) => {
      const g = (f - 1) / 9;
      return Xs + v - g * v;
    }, u = (f) => f ? H(f).format("DD-MM-YYYY") : "", c = X(() => {
      if (!r.value || !r.value.nps_by_day || r.value.nps_by_day.length === 0)
        return [];
      const f = [], v = Hy - Xs - Yy;
      return r.value.nps_by_day.forEach((p, g) => {
        const m = p.min_score || 0, _ = p.q1_score || 0, y = p.median_score || 0, b = p.q3_score || 0, w = p.max_score || 0, S = p.average_score || 0;
        f.push({
          label: u(p.date),
          responseCount: p.nps_responses_count || 0,
          isTotal: !1,
          open: _,
          // Q1 as open
          high: w,
          // Max as high
          low: m,
          // Min as low
          close: b,
          // Q3 as close
          median: y,
          average: S,
          openY: l(_, v),
          highY: l(w, v),
          lowY: l(m, v),
          closeY: l(b, v),
          medianY: l(y, v),
          averageY: S > 0 ? l(S, v) : null,
          centerX: Xs + (g + 1) * Wy
        });
      }), f;
    }), h = (f, v) => {
      if (!a.value || !v || v.horizontal) return;
      const p = a.value.getBoundingClientRect(), g = f.clientX, m = f.clientY, _ = 140, y = 160, b = 10, w = 15;
      let S = g - p.left - _ / 2, M = m - p.top - y - w;
      S = Math.max(b, Math.min(S, p.width - _ - b)), M < b && (M = m - p.top + w), M = Math.max(b, Math.min(M, p.height - y - b)), s.value = {
        visible: !0,
        x: S,
        y: M,
        date: v.label || "",
        min: v.low !== void 0 ? v.low.toFixed(1) : "N/A",
        max: v.high !== void 0 ? v.high.toFixed(1) : "N/A",
        q1: v.open !== void 0 ? v.open.toFixed(1) : "N/A",
        avg: v.average !== void 0 && v.average > 0 ? v.average.toFixed(1) : "N/A",
        q3: v.close !== void 0 ? v.close.toFixed(1) : "N/A",
        median: v.median !== void 0 ? v.median.toFixed(1) : "N/A"
      };
    }, d = () => {
      s.value.visible = !1;
    };
    return t({ isDark: n }), (f, v) => (E(), L("article", v9, [
      x("header", p9, [
        x("div", g9, [
          v[1] || (v[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "NPS Daily Metrics"),
            x("p", { class: "card-subtitle" }, "Daily NPS Distribution")
          ], -1)),
          r.value && r.value.nps_by_day && r.value.nps_by_day.length > 0 ? (E(), L("div", m9, [
            v[0] || (v[0] = x("p", { class: "badge-label" }, "Days", -1)),
            x("p", _9, R(r.value.nps_by_day.length), 1)
          ])) : ht("", !0)
        ])
      ]),
      i.loading ? (E(), L("div", y9, [...v[2] || (v[2] = [
        Ht('<div class="loading-container" data-v-f4a54c5c><div class="chart-flow-loader" data-v-f4a54c5c><div class="flow-line flow-1" data-v-f4a54c5c></div><div class="flow-line flow-2" data-v-f4a54c5c></div><div class="flow-line flow-3" data-v-f4a54c5c></div><div class="flow-line flow-4" data-v-f4a54c5c></div><div class="flow-line flow-5" data-v-f4a54c5c></div></div><p class="loading-text" data-v-f4a54c5c>Loading daily NPS data...</p></div>', 1)
      ])])) : r.value && r.value.nps_by_day && r.value.nps_by_day.length > 0 ? (E(), L("div", b9, [
        x("div", {
          class: "chart-wrapper",
          ref_key: "chartContainerRef",
          ref: a
        }, [
          c.value && c.value.length > 0 ? (E(), qy(qb, {
            key: 0,
            "candlestick-data": c.value,
            "chart-width": o.value,
            "chart-height": Hy,
            "chart-margin": Xs,
            "chart-bottom-margin": Yy,
            "show-legend": !0,
            rotation: 0,
            "candle-width": 30,
            onCandleHover: h,
            onCandleLeave: d
          }, null, 8, ["candlestick-data", "chart-width"])) : ht("", !0),
          s.value.visible ? (E(), L("div", {
            key: 1,
            class: "tooltip-overlay",
            style: Xr({
              left: `${s.value.x}px`,
              top: `${s.value.y}px`
            })
          }, [
            x("div", x9, [
              x("div", w9, R(s.value.date), 1),
              v[9] || (v[9] = x("div", { class: "tooltip-divider" }, null, -1)),
              x("div", S9, [
                x("div", M9, [
                  v[3] || (v[3] = x("span", { class: "tooltip-label tooltip-min" }, "Min:", -1)),
                  x("span", k9, R(s.value.min), 1)
                ]),
                x("div", D9, [
                  v[4] || (v[4] = x("span", { class: "tooltip-label tooltip-q1" }, "Q1:", -1)),
                  x("span", T9, R(s.value.q1), 1)
                ]),
                x("div", C9, [
                  v[5] || (v[5] = x("span", { class: "tooltip-label tooltip-median" }, "Median:", -1)),
                  x("span", A9, R(s.value.median), 1)
                ]),
                x("div", P9, [
                  v[6] || (v[6] = x("span", { class: "tooltip-label tooltip-avg" }, "Avg:", -1)),
                  x("span", E9, R(s.value.avg), 1)
                ]),
                x("div", L9, [
                  v[7] || (v[7] = x("span", { class: "tooltip-label tooltip-q3" }, "Q3:", -1)),
                  x("span", O9, R(s.value.q3), 1)
                ]),
                x("div", I9, [
                  v[8] || (v[8] = x("span", { class: "tooltip-label tooltip-max" }, "Max:", -1)),
                  x("span", R9, R(s.value.max), 1)
                ])
              ])
            ])
          ], 4)) : ht("", !0)
        ], 512)
      ])) : (E(), L("div", N9, [...v[10] || (v[10] = [
        Ht('<div class="empty-state-content" data-v-f4a54c5c><div class="empty-icon-wrapper" data-v-f4a54c5c><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-f4a54c5c><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-f4a54c5c></path></svg></div><p class="empty-title" data-v-f4a54c5c>No daily NPS data available</p><p class="empty-description" data-v-f4a54c5c>No daily NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, JS = /* @__PURE__ */ ne(F9, [["__scopeId", "data-v-f4a54c5c"]]), B9 = { class: "nps-overview-card" }, $9 = { class: "card-header" }, z9 = { class: "header-content" }, V9 = {
  key: 0,
  class: "stats-badge"
}, H9 = { class: "badge-value" }, Y9 = {
  key: 0,
  class: "loading-state"
}, W9 = {
  key: 1,
  class: "card-body"
}, U9 = { class: "chart-wrapper" }, G9 = {
  key: 2,
  class: "empty-state"
}, X9 = 500, j9 = 60, q9 = 80, Z9 = {
  __name: "npsOverviewMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: void 0
    }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = ye(_e(i, "theme")), r = X(() => i.data), a = X(() => Math.max(600, window.innerWidth * 0.85));
    return t({ isDark: n }), (s, o) => (E(), L("article", B9, [
      x("header", $9, [
        x("div", z9, [
          o[1] || (o[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "NPS Overview Metrics"),
            x("p", { class: "card-subtitle" }, "Overall NPS Distribution")
          ], -1)),
          r.value && r.value.total_nps_responses > 0 ? (E(), L("div", V9, [
            o[0] || (o[0] = x("p", { class: "badge-label" }, "Responses", -1)),
            x("p", H9, R(r.value.total_nps_responses), 1)
          ])) : ht("", !0)
        ])
      ]),
      i.loading ? (E(), L("div", Y9, [...o[2] || (o[2] = [
        Ht('<div class="loading-container" data-v-fb1d91e3><div class="chart-flow-loader" data-v-fb1d91e3><div class="flow-line flow-1" data-v-fb1d91e3></div><div class="flow-line flow-2" data-v-fb1d91e3></div><div class="flow-line flow-3" data-v-fb1d91e3></div><div class="flow-line flow-4" data-v-fb1d91e3></div><div class="flow-line flow-5" data-v-fb1d91e3></div></div><p class="loading-text" data-v-fb1d91e3>Loading NPS data...</p></div>', 1)
      ])])) : r.value && r.value.total_nps_responses > 0 ? (E(), L("div", W9, [
        x("div", U9, [
          de(Zb, {
            histogram: r.value.histogram || [],
            "min-score": r.value.min_score || 0,
            "max-score": r.value.max_score || 0,
            "q1-score": r.value.q1_score || 0,
            "median-score": r.value.median_score || 0,
            "q3-score": r.value.q3_score || 0,
            "average-score": r.value.average_score || 0,
            "chart-width": a.value,
            "chart-height": X9,
            "chart-margin": j9,
            "chart-bottom-margin": q9
          }, null, 8, ["histogram", "min-score", "max-score", "q1-score", "median-score", "q3-score", "average-score", "chart-width"])
        ])
      ])) : (E(), L("div", G9, [...o[3] || (o[3] = [
        Ht('<div class="empty-state-content" data-v-fb1d91e3><div class="empty-icon-wrapper" data-v-fb1d91e3><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-fb1d91e3><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-fb1d91e3></path></svg></div><p class="empty-title" data-v-fb1d91e3>No NPS data available</p><p class="empty-description" data-v-fb1d91e3>No NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, t2 = /* @__PURE__ */ ne(Z9, [["__scopeId", "data-v-fb1d91e3"]]), K9 = { class: "nps-metrics-container" }, Q9 = {
  __name: "npsMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    }
  },
  setup(e) {
    return (t, i) => (E(), L("div", K9, [
      de(t2, {
        data: e.data,
        loading: e.loading
      }, null, 8, ["data", "loading"]),
      de(JS, {
        data: e.data,
        loading: e.loading
      }, null, 8, ["data", "loading"])
    ]));
  }
}, J9 = /* @__PURE__ */ ne(Q9, [["__scopeId", "data-v-1ecde7da"]]), s7 = {
  install(e) {
    e.component("KiutChartBar", Xb), e.component("KiutChartLine", mv), e.component("KiutPieChart", jb), e.component("KiutBoxplotChart", JC), e.component("KiutCandlestickChart", qb), e.component("KiutHistogramChart", Zb), e.component("KiutSankeyChart", fa), e.component("KiutAgentsPerDay", j4), e.component("KiutBookingManager", C8), e.component("KiutCheckin", Q8), e.component("KiutCheckinMetrics", S6), e.component("KiutCheckinSegments", Z6), e.component("KiutDisruption", LY), e.component("KiutFAQ", ZY), e.component("KiutMessagesPerAgent", aW), e.component("KiutRecordLocator", PW), e.component("KiutSeller", r9), e.component("KiutTopAgents", f9), e.component("KiutNpsDailyMetrics", JS), e.component("KiutNpsMetrics", J9), e.component("KiutNpsOverviewMetrics", t2);
  }
};
export {
  j4 as AgentsPerDay,
  C8 as BookingManager,
  JC as BoxplotChart,
  qb as CandlestickChart,
  Xb as ChartBar,
  mv as ChartLine,
  Q8 as Checkin,
  S6 as CheckinMetrics,
  Z6 as CheckinSegments,
  LY as Disruption,
  ZY as FAQ,
  Zb as HistogramChart,
  s7 as KiutUIPlugin,
  aW as MessagesPerAgent,
  JS as NpsDailyMetrics,
  J9 as NpsMetrics,
  t2 as NpsOverviewMetrics,
  jb as PieChart,
  PW as RecordLocator,
  fa as SankeyChart,
  r9 as Seller,
  f9 as TopAgents
};
//# sourceMappingURL=kiut-ui.es.js.map
