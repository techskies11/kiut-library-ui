import { defineComponent as Me, shallowRef as $y, h as Ld, ref as pt, onMounted as Cn, onUnmounted as qS, watch as Pn, toRaw as Od, nextTick as Hy, version as ZS, isProxy as Yy, createElementBlock as I, openBlock as O, createVNode as Ee, unref as G, computed as ut, normalizeStyle as jr, createCommentVNode as ct, createElementVNode as S, toDisplayString as F, Fragment as Ft, renderList as fe, createStaticVNode as Kt, onBeforeUnmount as KS, withDirectives as Wp, vShow as Up, createTextVNode as gu, createBlock as Wy } from "vue";
function Us(e) {
  return e + 0.5 | 0;
}
const Vi = (e, t, n) => Math.max(Math.min(e, n), t);
function Xo(e) {
  return Vi(Us(e * 2.55), 0, 255);
}
function ji(e) {
  return Vi(Us(e * 255), 0, 255);
}
function fi(e) {
  return Vi(Us(e / 2.55) / 100, 0, 1);
}
function Gp(e) {
  return Vi(Us(e * 100), 0, 100);
}
const tn = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Id = [..."0123456789ABCDEF"], QS = (e) => Id[e & 15], JS = (e) => Id[(e & 240) >> 4] + Id[e & 15], el = (e) => (e & 240) >> 4 === (e & 15), t2 = (e) => el(e.r) && el(e.g) && el(e.b) && el(e.a);
function e2(e) {
  var t = e.length, n;
  return e[0] === "#" && (t === 4 || t === 5 ? n = {
    r: 255 & tn[e[1]] * 17,
    g: 255 & tn[e[2]] * 17,
    b: 255 & tn[e[3]] * 17,
    a: t === 5 ? tn[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (n = {
    r: tn[e[1]] << 4 | tn[e[2]],
    g: tn[e[3]] << 4 | tn[e[4]],
    b: tn[e[5]] << 4 | tn[e[6]],
    a: t === 9 ? tn[e[7]] << 4 | tn[e[8]] : 255
  })), n;
}
const n2 = (e, t) => e < 255 ? t(e) : "";
function i2(e) {
  var t = t2(e) ? QS : JS;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + n2(e.a, t) : void 0;
}
const r2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function Uy(e, t, n) {
  const i = t * Math.min(n, 1 - n), r = (a, o = (a + e / 30) % 12) => n - i * Math.max(Math.min(o - 3, 9 - o, 1), -1);
  return [r(0), r(8), r(4)];
}
function a2(e, t, n) {
  const i = (r, a = (r + e / 60) % 6) => n - n * t * Math.max(Math.min(a, 4 - a, 1), 0);
  return [i(5), i(3), i(1)];
}
function o2(e, t, n) {
  const i = Uy(e, 1, 0.5);
  let r;
  for (t + n > 1 && (r = 1 / (t + n), t *= r, n *= r), r = 0; r < 3; r++)
    i[r] *= 1 - t - n, i[r] += t;
  return i;
}
function s2(e, t, n, i, r) {
  return e === r ? (t - n) / i + (t < n ? 6 : 0) : t === r ? (n - e) / i + 2 : (e - t) / i + 4;
}
function Kf(e) {
  const n = e.r / 255, i = e.g / 255, r = e.b / 255, a = Math.max(n, i, r), o = Math.min(n, i, r), s = (a + o) / 2;
  let l, u, c;
  return a !== o && (c = a - o, u = s > 0.5 ? c / (2 - a - o) : c / (a + o), l = s2(n, i, r, c, a), l = l * 60 + 0.5), [l | 0, u || 0, s];
}
function Qf(e, t, n, i) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, n, i)).map(ji);
}
function Jf(e, t, n) {
  return Qf(Uy, e, t, n);
}
function l2(e, t, n) {
  return Qf(o2, e, t, n);
}
function u2(e, t, n) {
  return Qf(a2, e, t, n);
}
function Gy(e) {
  return (e % 360 + 360) % 360;
}
function c2(e) {
  const t = r2.exec(e);
  let n = 255, i;
  if (!t)
    return;
  t[5] !== i && (n = t[6] ? Xo(+t[5]) : ji(+t[5]));
  const r = Gy(+t[2]), a = +t[3] / 100, o = +t[4] / 100;
  return t[1] === "hwb" ? i = l2(r, a, o) : t[1] === "hsv" ? i = u2(r, a, o) : i = Jf(r, a, o), {
    r: i[0],
    g: i[1],
    b: i[2],
    a: n
  };
}
function h2(e, t) {
  var n = Kf(e);
  n[0] = Gy(n[0] + t), n = Jf(n), e.r = n[0], e.g = n[1], e.b = n[2];
}
function d2(e) {
  if (!e)
    return;
  const t = Kf(e), n = t[0], i = Gp(t[1]), r = Gp(t[2]);
  return e.a < 255 ? `hsla(${n}, ${i}%, ${r}%, ${fi(e.a)})` : `hsl(${n}, ${i}%, ${r}%)`;
}
const jp = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Xp = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function f2() {
  const e = {}, t = Object.keys(Xp), n = Object.keys(jp);
  let i, r, a, o, s;
  for (i = 0; i < t.length; i++) {
    for (o = s = t[i], r = 0; r < n.length; r++)
      a = n[r], s = s.replace(a, jp[a]);
    a = parseInt(Xp[o], 16), e[s] = [a >> 16 & 255, a >> 8 & 255, a & 255];
  }
  return e;
}
let nl;
function v2(e) {
  nl || (nl = f2(), nl.transparent = [0, 0, 0, 0]);
  const t = nl[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const p2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function g2(e) {
  const t = p2.exec(e);
  let n = 255, i, r, a;
  if (t) {
    if (t[7] !== i) {
      const o = +t[7];
      n = t[8] ? Xo(o) : Vi(o * 255, 0, 255);
    }
    return i = +t[1], r = +t[3], a = +t[5], i = 255 & (t[2] ? Xo(i) : Vi(i, 0, 255)), r = 255 & (t[4] ? Xo(r) : Vi(r, 0, 255)), a = 255 & (t[6] ? Xo(a) : Vi(a, 0, 255)), {
      r: i,
      g: r,
      b: a,
      a: n
    };
  }
}
function _2(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${fi(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const Kc = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, va = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function m2(e, t, n) {
  const i = va(fi(e.r)), r = va(fi(e.g)), a = va(fi(e.b));
  return {
    r: ji(Kc(i + n * (va(fi(t.r)) - i))),
    g: ji(Kc(r + n * (va(fi(t.g)) - r))),
    b: ji(Kc(a + n * (va(fi(t.b)) - a))),
    a: e.a + n * (t.a - e.a)
  };
}
function il(e, t, n) {
  if (e) {
    let i = Kf(e);
    i[t] = Math.max(0, Math.min(i[t] + i[t] * n, t === 0 ? 360 : 1)), i = Jf(i), e.r = i[0], e.g = i[1], e.b = i[2];
  }
}
function jy(e, t) {
  return e && Object.assign(t || {}, e);
}
function qp(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = ji(e[3]))) : (t = jy(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = ji(t.a)), t;
}
function y2(e) {
  return e.charAt(0) === "r" ? g2(e) : c2(e);
}
class bs {
  constructor(t) {
    if (t instanceof bs)
      return t;
    const n = typeof t;
    let i;
    n === "object" ? i = qp(t) : n === "string" && (i = e2(t) || v2(t) || y2(t)), this._rgb = i, this._valid = !!i;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = jy(this._rgb);
    return t && (t.a = fi(t.a)), t;
  }
  set rgb(t) {
    this._rgb = qp(t);
  }
  rgbString() {
    return this._valid ? _2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? i2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? d2(this._rgb) : void 0;
  }
  mix(t, n) {
    if (t) {
      const i = this.rgb, r = t.rgb;
      let a;
      const o = n === a ? 0.5 : n, s = 2 * o - 1, l = i.a - r.a, u = ((s * l === -1 ? s : (s + l) / (1 + s * l)) + 1) / 2;
      a = 1 - u, i.r = 255 & u * i.r + a * r.r + 0.5, i.g = 255 & u * i.g + a * r.g + 0.5, i.b = 255 & u * i.b + a * r.b + 0.5, i.a = o * i.a + (1 - o) * r.a, this.rgb = i;
    }
    return this;
  }
  interpolate(t, n) {
    return t && (this._rgb = m2(this._rgb, t._rgb, n)), this;
  }
  clone() {
    return new bs(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = ji(t), this;
  }
  clearer(t) {
    const n = this._rgb;
    return n.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, n = Us(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = n, this;
  }
  opaquer(t) {
    const n = this._rgb;
    return n.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return il(this._rgb, 2, t), this;
  }
  darken(t) {
    return il(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return il(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return il(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return h2(this._rgb, t), this;
  }
}
function ii() {
}
const b2 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function Dt(e) {
  return e == null;
}
function ie(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function dt(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function we(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function Rn(e, t) {
  return we(e) ? e : t;
}
function ot(e, t) {
  return typeof e > "u" ? t : e;
}
const x2 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, Xy = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function Nt(e, t, n) {
  if (e && typeof e.call == "function")
    return e.apply(n, t);
}
function kt(e, t, n, i) {
  let r, a, o;
  if (ie(e))
    for (a = e.length, r = 0; r < a; r++)
      t.call(n, e[r], r);
  else if (dt(e))
    for (o = Object.keys(e), a = o.length, r = 0; r < a; r++)
      t.call(n, e[o[r]], o[r]);
}
function _u(e, t) {
  let n, i, r, a;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (n = 0, i = e.length; n < i; ++n)
    if (r = e[n], a = t[n], r.datasetIndex !== a.datasetIndex || r.index !== a.index)
      return !1;
  return !0;
}
function mu(e) {
  if (ie(e))
    return e.map(mu);
  if (dt(e)) {
    const t = /* @__PURE__ */ Object.create(null), n = Object.keys(e), i = n.length;
    let r = 0;
    for (; r < i; ++r)
      t[n[r]] = mu(e[n[r]]);
    return t;
  }
  return e;
}
function qy(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function w2(e, t, n, i) {
  if (!qy(e))
    return;
  const r = t[e], a = n[e];
  dt(r) && dt(a) ? xs(r, a, i) : t[e] = mu(a);
}
function xs(e, t, n) {
  const i = ie(t) ? t : [
    t
  ], r = i.length;
  if (!dt(e))
    return e;
  n = n || {};
  const a = n.merger || w2;
  let o;
  for (let s = 0; s < r; ++s) {
    if (o = i[s], !dt(o))
      continue;
    const l = Object.keys(o);
    for (let u = 0, c = l.length; u < c; ++u)
      a(l[u], e, o, n);
  }
  return e;
}
function os(e, t) {
  return xs(e, t, {
    merger: S2
  });
}
function S2(e, t, n) {
  if (!qy(e))
    return;
  const i = t[e], r = n[e];
  dt(i) && dt(r) ? os(i, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = mu(r));
}
const Zp = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function M2(e) {
  const t = e.split("."), n = [];
  let i = "";
  for (const r of t)
    i += r, i.endsWith("\\") ? i = i.slice(0, -1) + "." : (n.push(i), i = "");
  return n;
}
function D2(e) {
  const t = M2(e);
  return (n) => {
    for (const i of t) {
      if (i === "")
        break;
      n = n && n[i];
    }
    return n;
  };
}
function ra(e, t) {
  return (Zp[t] || (Zp[t] = D2(t)))(e);
}
function tv(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const ws = (e) => typeof e < "u", Ji = (e) => typeof e == "function", Kp = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const n of e)
    if (!t.has(n))
      return !1;
  return !0;
};
function T2(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const Ct = Math.PI, Ut = 2 * Ct, k2 = Ut + Ct, yu = Number.POSITIVE_INFINITY, C2 = Ct / 180, se = Ct / 2, sr = Ct / 4, Qp = Ct * 2 / 3, Zy = Math.log10, jn = Math.sign;
function ss(e, t, n) {
  return Math.abs(e - t) < n;
}
function Jp(e) {
  const t = Math.round(e);
  e = ss(e, t, e / 1e3) ? t : e;
  const n = Math.pow(10, Math.floor(Zy(e))), i = e / n;
  return (i <= 1 ? 1 : i <= 2 ? 2 : i <= 5 ? 5 : 10) * n;
}
function P2(e) {
  const t = [], n = Math.sqrt(e);
  let i;
  for (i = 1; i < n; i++)
    e % i === 0 && (t.push(i), t.push(e / i));
  return n === (n | 0) && t.push(n), t.sort((r, a) => r - a).pop(), t;
}
function A2(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function Ss(e) {
  return !A2(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function E2(e, t) {
  const n = Math.round(e);
  return n - t <= e && n + t >= e;
}
function L2(e, t, n) {
  let i, r, a;
  for (i = 0, r = e.length; i < r; i++)
    a = e[i][n], isNaN(a) || (t.min = Math.min(t.min, a), t.max = Math.max(t.max, a));
}
function vi(e) {
  return e * (Ct / 180);
}
function O2(e) {
  return e * (180 / Ct);
}
function tg(e) {
  if (!we(e))
    return;
  let t = 1, n = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, n++;
  return n;
}
function Ky(e, t) {
  const n = t.x - e.x, i = t.y - e.y, r = Math.sqrt(n * n + i * i);
  let a = Math.atan2(i, n);
  return a < -0.5 * Ct && (a += Ut), {
    angle: a,
    distance: r
  };
}
function Rd(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function I2(e, t) {
  return (e - t + k2) % Ut - Ct;
}
function je(e) {
  return (e % Ut + Ut) % Ut;
}
function Ms(e, t, n, i) {
  const r = je(e), a = je(t), o = je(n), s = je(a - r), l = je(o - r), u = je(r - a), c = je(r - o);
  return r === a || r === o || i && a === o || s > l && u < c;
}
function _e(e, t, n) {
  return Math.max(t, Math.min(n, e));
}
function R2(e) {
  return _e(e, -32768, 32767);
}
function pi(e, t, n, i = 1e-6) {
  return e >= Math.min(t, n) - i && e <= Math.max(t, n) + i;
}
function ev(e, t, n) {
  n = n || ((o) => e[o] < t);
  let i = e.length - 1, r = 0, a;
  for (; i - r > 1; )
    a = r + i >> 1, n(a) ? r = a : i = a;
  return {
    lo: r,
    hi: i
  };
}
const Vr = (e, t, n, i) => ev(e, n, i ? (r) => {
  const a = e[r][t];
  return a < n || a === n && e[r + 1][t] === n;
} : (r) => e[r][t] < n), N2 = (e, t, n) => ev(e, n, (i) => e[i][t] >= n);
function F2(e, t, n) {
  let i = 0, r = e.length;
  for (; i < r && e[i] < t; )
    i++;
  for (; r > i && e[r - 1] > n; )
    r--;
  return i > 0 || r < e.length ? e.slice(i, r) : e;
}
const Qy = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function B2(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), Qy.forEach((n) => {
    const i = "_onData" + tv(n), r = e[n];
    Object.defineProperty(e, n, {
      configurable: !0,
      enumerable: !1,
      value(...a) {
        const o = r.apply(this, a);
        return e._chartjs.listeners.forEach((s) => {
          typeof s[i] == "function" && s[i](...a);
        }), o;
      }
    });
  });
}
function eg(e, t) {
  const n = e._chartjs;
  if (!n)
    return;
  const i = n.listeners, r = i.indexOf(t);
  r !== -1 && i.splice(r, 1), !(i.length > 0) && (Qy.forEach((a) => {
    delete e[a];
  }), delete e._chartjs);
}
function Jy(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const tb = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function eb(e, t) {
  let n = [], i = !1;
  return function(...r) {
    n = r, i || (i = !0, tb.call(window, () => {
      i = !1, e.apply(t, n);
    }));
  };
}
function z2(e, t) {
  let n;
  return function(...i) {
    return t ? (clearTimeout(n), n = setTimeout(e, t, i)) : e.apply(this, i), t;
  };
}
const nv = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", pe = (e, t, n) => e === "start" ? t : e === "end" ? n : (t + n) / 2, V2 = (e, t, n, i) => e === (i ? "left" : "right") ? n : e === "center" ? (t + n) / 2 : t;
function $2(e, t, n) {
  const i = t.length;
  let r = 0, a = i;
  if (e._sorted) {
    const { iScale: o, vScale: s, _parsed: l } = e, u = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, c = o.axis, { min: h, max: d, minDefined: f, maxDefined: v } = o.getUserBounds();
    if (f) {
      if (r = Math.min(
        // @ts-expect-error Need to type _parsed
        Vr(l, c, h).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? i : Vr(t, c, o.getPixelForValue(h)).lo
      ), u) {
        const g = l.slice(0, r + 1).reverse().findIndex((p) => !Dt(p[s.axis]));
        r -= Math.max(0, g);
      }
      r = _e(r, 0, i - 1);
    }
    if (v) {
      let g = Math.max(
        // @ts-expect-error Need to type _parsed
        Vr(l, o.axis, d, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        n ? 0 : Vr(t, c, o.getPixelForValue(d), !0).hi + 1
      );
      if (u) {
        const p = l.slice(g - 1).findIndex((_) => !Dt(_[s.axis]));
        g += Math.max(0, p);
      }
      a = _e(g, r, i) - r;
    } else
      a = i - r;
  }
  return {
    start: r,
    count: a
  };
}
function H2(e) {
  const { xScale: t, yScale: n, _scaleRanges: i } = e, r = {
    xmin: t.min,
    xmax: t.max,
    ymin: n.min,
    ymax: n.max
  };
  if (!i)
    return e._scaleRanges = r, !0;
  const a = i.xmin !== t.min || i.xmax !== t.max || i.ymin !== n.min || i.ymax !== n.max;
  return Object.assign(i, r), a;
}
const rl = (e) => e === 0 || e === 1, ng = (e, t, n) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Ut / n)), ig = (e, t, n) => Math.pow(2, -10 * e) * Math.sin((e - t) * Ut / n) + 1, ls = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * se) + 1,
  easeOutSine: (e) => Math.sin(e * se),
  easeInOutSine: (e) => -0.5 * (Math.cos(Ct * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => rl(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => rl(e) ? e : ng(e, 0.075, 0.3),
  easeOutElastic: (e) => rl(e) ? e : ig(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return rl(e) ? e : e < 0.5 ? 0.5 * ng(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * ig(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - ls.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? ls.easeInBounce(e * 2) * 0.5 : ls.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function iv(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function rg(e) {
  return iv(e) ? e : new bs(e);
}
function Qc(e) {
  return iv(e) ? e : new bs(e).saturate(0.5).darken(0.1).hexString();
}
const Y2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], W2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function U2(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: W2
    },
    numbers: {
      type: "number",
      properties: Y2
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function G2(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const ag = /* @__PURE__ */ new Map();
function j2(e, t) {
  t = t || {};
  const n = e + JSON.stringify(t);
  let i = ag.get(n);
  return i || (i = new Intl.NumberFormat(e, t), ag.set(n, i)), i;
}
function rv(e, t, n) {
  return j2(t, n).format(e);
}
const X2 = {
  values(e) {
    return ie(e) ? e : "" + e;
  },
  numeric(e, t, n) {
    if (e === 0)
      return "0";
    const i = this.chart.options.locale;
    let r, a = e;
    if (n.length > 1) {
      const u = Math.max(Math.abs(n[0].value), Math.abs(n[n.length - 1].value));
      (u < 1e-4 || u > 1e15) && (r = "scientific"), a = q2(e, n);
    }
    const o = Zy(Math.abs(a)), s = isNaN(o) ? 1 : Math.max(Math.min(-1 * Math.floor(o), 20), 0), l = {
      notation: r,
      minimumFractionDigits: s,
      maximumFractionDigits: s
    };
    return Object.assign(l, this.options.ticks.format), rv(e, i, l);
  }
};
function q2(e, t) {
  let n = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(n) >= 1 && e !== Math.floor(e) && (n = e - Math.floor(e)), n;
}
var nb = {
  formatters: X2
};
function Z2(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, n) => n.lineWidth,
      tickColor: (t, n) => n.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: nb.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const aa = /* @__PURE__ */ Object.create(null), Nd = /* @__PURE__ */ Object.create(null);
function us(e, t) {
  if (!t)
    return e;
  const n = t.split(".");
  for (let i = 0, r = n.length; i < r; ++i) {
    const a = n[i];
    e = e[a] || (e[a] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function Jc(e, t, n) {
  return typeof t == "string" ? xs(us(e, t), n) : xs(us(e, ""), t);
}
class K2 {
  constructor(t, n) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (i) => i.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (i, r) => Qc(r.backgroundColor), this.hoverBorderColor = (i, r) => Qc(r.borderColor), this.hoverColor = (i, r) => Qc(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(n);
  }
  set(t, n) {
    return Jc(this, t, n);
  }
  get(t) {
    return us(this, t);
  }
  describe(t, n) {
    return Jc(Nd, t, n);
  }
  override(t, n) {
    return Jc(aa, t, n);
  }
  route(t, n, i, r) {
    const a = us(this, t), o = us(this, i), s = "_" + n;
    Object.defineProperties(a, {
      [s]: {
        value: a[n],
        writable: !0
      },
      [n]: {
        enumerable: !0,
        get() {
          const l = this[s], u = o[r];
          return dt(l) ? Object.assign({}, u, l) : ot(l, u);
        },
        set(l) {
          this[s] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((n) => n(this));
  }
}
var ee = /* @__PURE__ */ new K2({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  U2,
  G2,
  Z2
]);
function Q2(e) {
  return !e || Dt(e.size) || Dt(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function og(e, t, n, i, r) {
  let a = t[r];
  return a || (a = t[r] = e.measureText(r).width, n.push(r)), a > i && (i = a), i;
}
function lr(e, t, n) {
  const i = e.currentDevicePixelRatio, r = n !== 0 ? Math.max(n / 2, 0.5) : 0;
  return Math.round((t - r) * i) / i + r;
}
function sg(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function Fd(e, t, n, i) {
  ib(e, t, n, i, null);
}
function ib(e, t, n, i, r) {
  let a, o, s, l, u, c, h, d;
  const f = t.pointStyle, v = t.rotation, g = t.radius;
  let p = (v || 0) * C2;
  if (f && typeof f == "object" && (a = f.toString(), a === "[object HTMLImageElement]" || a === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(n, i), e.rotate(p), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), e.restore();
    return;
  }
  if (!(isNaN(g) || g <= 0)) {
    switch (e.beginPath(), f) {
      // Default includes circle
      default:
        r ? e.ellipse(n, i, r / 2, g, 0, 0, Ut) : e.arc(n, i, g, 0, Ut), e.closePath();
        break;
      case "triangle":
        c = r ? r / 2 : g, e.moveTo(n + Math.sin(p) * c, i - Math.cos(p) * g), p += Qp, e.lineTo(n + Math.sin(p) * c, i - Math.cos(p) * g), p += Qp, e.lineTo(n + Math.sin(p) * c, i - Math.cos(p) * g), e.closePath();
        break;
      case "rectRounded":
        u = g * 0.516, l = g - u, o = Math.cos(p + sr) * l, h = Math.cos(p + sr) * (r ? r / 2 - u : l), s = Math.sin(p + sr) * l, d = Math.sin(p + sr) * (r ? r / 2 - u : l), e.arc(n - h, i - s, u, p - Ct, p - se), e.arc(n + d, i - o, u, p - se, p), e.arc(n + h, i + s, u, p, p + se), e.arc(n - d, i + o, u, p + se, p + Ct), e.closePath();
        break;
      case "rect":
        if (!v) {
          l = Math.SQRT1_2 * g, c = r ? r / 2 : l, e.rect(n - c, i - l, 2 * c, 2 * l);
          break;
        }
        p += sr;
      /* falls through */
      case "rectRot":
        h = Math.cos(p) * (r ? r / 2 : g), o = Math.cos(p) * g, s = Math.sin(p) * g, d = Math.sin(p) * (r ? r / 2 : g), e.moveTo(n - h, i - s), e.lineTo(n + d, i - o), e.lineTo(n + h, i + s), e.lineTo(n - d, i + o), e.closePath();
        break;
      case "crossRot":
        p += sr;
      /* falls through */
      case "cross":
        h = Math.cos(p) * (r ? r / 2 : g), o = Math.cos(p) * g, s = Math.sin(p) * g, d = Math.sin(p) * (r ? r / 2 : g), e.moveTo(n - h, i - s), e.lineTo(n + h, i + s), e.moveTo(n + d, i - o), e.lineTo(n - d, i + o);
        break;
      case "star":
        h = Math.cos(p) * (r ? r / 2 : g), o = Math.cos(p) * g, s = Math.sin(p) * g, d = Math.sin(p) * (r ? r / 2 : g), e.moveTo(n - h, i - s), e.lineTo(n + h, i + s), e.moveTo(n + d, i - o), e.lineTo(n - d, i + o), p += sr, h = Math.cos(p) * (r ? r / 2 : g), o = Math.cos(p) * g, s = Math.sin(p) * g, d = Math.sin(p) * (r ? r / 2 : g), e.moveTo(n - h, i - s), e.lineTo(n + h, i + s), e.moveTo(n + d, i - o), e.lineTo(n - d, i + o);
        break;
      case "line":
        o = r ? r / 2 : Math.cos(p) * g, s = Math.sin(p) * g, e.moveTo(n - o, i - s), e.lineTo(n + o, i + s);
        break;
      case "dash":
        e.moveTo(n, i), e.lineTo(n + Math.cos(p) * (r ? r / 2 : g), i + Math.sin(p) * g);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function Ds(e, t, n) {
  return n = n || 0.5, !t || e && e.x > t.left - n && e.x < t.right + n && e.y > t.top - n && e.y < t.bottom + n;
}
function fc(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function vc(e) {
  e.restore();
}
function J2(e, t, n, i, r) {
  if (!t)
    return e.lineTo(n.x, n.y);
  if (r === "middle") {
    const a = (t.x + n.x) / 2;
    e.lineTo(a, t.y), e.lineTo(a, n.y);
  } else r === "after" != !!i ? e.lineTo(t.x, n.y) : e.lineTo(n.x, t.y);
  e.lineTo(n.x, n.y);
}
function tM(e, t, n, i) {
  if (!t)
    return e.lineTo(n.x, n.y);
  e.bezierCurveTo(i ? t.cp1x : t.cp2x, i ? t.cp1y : t.cp2y, i ? n.cp2x : n.cp1x, i ? n.cp2y : n.cp1y, n.x, n.y);
}
function eM(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), Dt(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function nM(e, t, n, i, r) {
  if (r.strikethrough || r.underline) {
    const a = e.measureText(i), o = t - a.actualBoundingBoxLeft, s = t + a.actualBoundingBoxRight, l = n - a.actualBoundingBoxAscent, u = n + a.actualBoundingBoxDescent, c = r.strikethrough ? (l + u) / 2 : u;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = r.decorationWidth || 2, e.moveTo(o, c), e.lineTo(s, c), e.stroke();
  }
}
function iM(e, t) {
  const n = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = n;
}
function Ts(e, t, n, i, r, a = {}) {
  const o = ie(t) ? t : [
    t
  ], s = a.strokeWidth > 0 && a.strokeColor !== "";
  let l, u;
  for (e.save(), e.font = r.string, eM(e, a), l = 0; l < o.length; ++l)
    u = o[l], a.backdrop && iM(e, a.backdrop), s && (a.strokeColor && (e.strokeStyle = a.strokeColor), Dt(a.strokeWidth) || (e.lineWidth = a.strokeWidth), e.strokeText(u, n, i, a.maxWidth)), e.fillText(u, n, i, a.maxWidth), nM(e, n, i, u, a), i += Number(r.lineHeight);
  e.restore();
}
function bu(e, t) {
  const { x: n, y: i, w: r, h: a, radius: o } = t;
  e.arc(n + o.topLeft, i + o.topLeft, o.topLeft, 1.5 * Ct, Ct, !0), e.lineTo(n, i + a - o.bottomLeft), e.arc(n + o.bottomLeft, i + a - o.bottomLeft, o.bottomLeft, Ct, se, !0), e.lineTo(n + r - o.bottomRight, i + a), e.arc(n + r - o.bottomRight, i + a - o.bottomRight, o.bottomRight, se, 0, !0), e.lineTo(n + r, i + o.topRight), e.arc(n + r - o.topRight, i + o.topRight, o.topRight, 0, -se, !0), e.lineTo(n + o.topLeft, i);
}
const rM = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, aM = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function oM(e, t) {
  const n = ("" + e).match(rM);
  if (!n || n[1] === "normal")
    return t * 1.2;
  switch (e = +n[2], n[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const sM = (e) => +e || 0;
function av(e, t) {
  const n = {}, i = dt(t), r = i ? Object.keys(t) : t, a = dt(e) ? i ? (o) => ot(e[o], e[t[o]]) : (o) => e[o] : () => e;
  for (const o of r)
    n[o] = sM(a(o));
  return n;
}
function rb(e) {
  return av(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function Ua(e) {
  return av(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function pn(e) {
  const t = rb(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function me(e, t) {
  e = e || {}, t = t || ee.font;
  let n = ot(e.size, t.size);
  typeof n == "string" && (n = parseInt(n, 10));
  let i = ot(e.style, t.style);
  i && !("" + i).match(aM) && (console.warn('Invalid font style specified: "' + i + '"'), i = void 0);
  const r = {
    family: ot(e.family, t.family),
    lineHeight: oM(ot(e.lineHeight, t.lineHeight), n),
    size: n,
    style: i,
    weight: ot(e.weight, t.weight),
    string: ""
  };
  return r.string = Q2(r), r;
}
function al(e, t, n, i) {
  let r, a, o;
  for (r = 0, a = e.length; r < a; ++r)
    if (o = e[r], o !== void 0 && o !== void 0)
      return o;
}
function lM(e, t, n) {
  const { min: i, max: r } = e, a = Xy(t, (r - i) / 2), o = (s, l) => n && s === 0 ? 0 : s + l;
  return {
    min: o(i, -Math.abs(a)),
    max: o(r, a)
  };
}
function la(e, t) {
  return Object.assign(Object.create(e), t);
}
function ov(e, t = [
  ""
], n, i, r = () => e[0]) {
  const a = n || e;
  typeof i > "u" && (i = lb("_fallback", e));
  const o = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: a,
    _fallback: i,
    _getTarget: r,
    override: (s) => ov([
      s,
      ...e
    ], t, a, i)
  };
  return new Proxy(o, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(s, l) {
      return delete s[l], delete s._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(s, l) {
      return ob(s, l, () => gM(l, t, e, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(s, l) {
      return Reflect.getOwnPropertyDescriptor(s._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(s, l) {
      return ug(s).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(s) {
      return ug(s);
    },
    /**
    * A trap for setting property values.
    */
    set(s, l, u) {
      const c = s._storage || (s._storage = r());
      return s[l] = c[l] = u, delete s._keys, !0;
    }
  });
}
function to(e, t, n, i) {
  const r = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: n,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: ab(e, i),
    setContext: (a) => to(e, a, n, i),
    override: (a) => to(e.override(a), t, n, i)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, o) {
      return delete a[o], delete e[o], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, o, s) {
      return ob(a, o, () => cM(a, o, s));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, o) {
      return a._descriptors.allKeys ? Reflect.has(e, o) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, o);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(a, o) {
      return Reflect.has(e, o);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(a, o, s) {
      return e[o] = s, delete a[o], !0;
    }
  });
}
function ab(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: n = t.scriptable, _indexable: i = t.indexable, _allKeys: r = t.allKeys } = e;
  return {
    allKeys: r,
    scriptable: n,
    indexable: i,
    isScriptable: Ji(n) ? n : () => n,
    isIndexable: Ji(i) ? i : () => i
  };
}
const uM = (e, t) => e ? e + tv(t) : t, sv = (e, t) => dt(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function ob(e, t, n) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const i = n();
  return e[t] = i, i;
}
function cM(e, t, n) {
  const { _proxy: i, _context: r, _subProxy: a, _descriptors: o } = e;
  let s = i[t];
  return Ji(s) && o.isScriptable(t) && (s = hM(t, s, e, n)), ie(s) && s.length && (s = dM(t, s, e, o.isIndexable)), sv(t, s) && (s = to(s, r, a && a[t], o)), s;
}
function hM(e, t, n, i) {
  const { _proxy: r, _context: a, _subProxy: o, _stack: s } = n;
  if (s.has(e))
    throw new Error("Recursion detected: " + Array.from(s).join("->") + "->" + e);
  s.add(e);
  let l = t(a, o || i);
  return s.delete(e), sv(e, l) && (l = lv(r._scopes, r, e, l)), l;
}
function dM(e, t, n, i) {
  const { _proxy: r, _context: a, _subProxy: o, _descriptors: s } = n;
  if (typeof a.index < "u" && i(e))
    return t[a.index % t.length];
  if (dt(t[0])) {
    const l = t, u = r._scopes.filter((c) => c !== l);
    t = [];
    for (const c of l) {
      const h = lv(u, r, e, c);
      t.push(to(h, a, o && o[e], s));
    }
  }
  return t;
}
function sb(e, t, n) {
  return Ji(e) ? e(t, n) : e;
}
const fM = (e, t) => e === !0 ? t : typeof e == "string" ? ra(t, e) : void 0;
function vM(e, t, n, i, r) {
  for (const a of t) {
    const o = fM(n, a);
    if (o) {
      e.add(o);
      const s = sb(o._fallback, n, r);
      if (typeof s < "u" && s !== n && s !== i)
        return s;
    } else if (o === !1 && typeof i < "u" && n !== i)
      return null;
  }
  return !1;
}
function lv(e, t, n, i) {
  const r = t._rootScopes, a = sb(t._fallback, n, i), o = [
    ...e,
    ...r
  ], s = /* @__PURE__ */ new Set();
  s.add(i);
  let l = lg(s, o, n, a || n, i);
  return l === null || typeof a < "u" && a !== n && (l = lg(s, o, a, l, i), l === null) ? !1 : ov(Array.from(s), [
    ""
  ], r, a, () => pM(t, n, i));
}
function lg(e, t, n, i, r) {
  for (; n; )
    n = vM(e, t, n, i, r);
  return n;
}
function pM(e, t, n) {
  const i = e._getTarget();
  t in i || (i[t] = {});
  const r = i[t];
  return ie(r) && dt(n) ? n : r || {};
}
function gM(e, t, n, i) {
  let r;
  for (const a of t)
    if (r = lb(uM(a, e), n), typeof r < "u")
      return sv(e, r) ? lv(n, i, e, r) : r;
}
function lb(e, t) {
  for (const n of t) {
    if (!n)
      continue;
    const i = n[e];
    if (typeof i < "u")
      return i;
  }
}
function ug(e) {
  let t = e._keys;
  return t || (t = e._keys = _M(e._scopes)), t;
}
function _M(e) {
  const t = /* @__PURE__ */ new Set();
  for (const n of e)
    for (const i of Object.keys(n).filter((r) => !r.startsWith("_")))
      t.add(i);
  return Array.from(t);
}
const mM = Number.EPSILON || 1e-14, eo = (e, t) => t < e.length && !e[t].skip && e[t], ub = (e) => e === "x" ? "y" : "x";
function yM(e, t, n, i) {
  const r = e.skip ? t : e, a = t, o = n.skip ? t : n, s = Rd(a, r), l = Rd(o, a);
  let u = s / (s + l), c = l / (s + l);
  u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c;
  const h = i * u, d = i * c;
  return {
    previous: {
      x: a.x - h * (o.x - r.x),
      y: a.y - h * (o.y - r.y)
    },
    next: {
      x: a.x + d * (o.x - r.x),
      y: a.y + d * (o.y - r.y)
    }
  };
}
function bM(e, t, n) {
  const i = e.length;
  let r, a, o, s, l, u = eo(e, 0);
  for (let c = 0; c < i - 1; ++c)
    if (l = u, u = eo(e, c + 1), !(!l || !u)) {
      if (ss(t[c], 0, mM)) {
        n[c] = n[c + 1] = 0;
        continue;
      }
      r = n[c] / t[c], a = n[c + 1] / t[c], s = Math.pow(r, 2) + Math.pow(a, 2), !(s <= 9) && (o = 3 / Math.sqrt(s), n[c] = r * o * t[c], n[c + 1] = a * o * t[c]);
    }
}
function xM(e, t, n = "x") {
  const i = ub(n), r = e.length;
  let a, o, s, l = eo(e, 0);
  for (let u = 0; u < r; ++u) {
    if (o = s, s = l, l = eo(e, u + 1), !s)
      continue;
    const c = s[n], h = s[i];
    o && (a = (c - o[n]) / 3, s[`cp1${n}`] = c - a, s[`cp1${i}`] = h - a * t[u]), l && (a = (l[n] - c) / 3, s[`cp2${n}`] = c + a, s[`cp2${i}`] = h + a * t[u]);
  }
}
function wM(e, t = "x") {
  const n = ub(t), i = e.length, r = Array(i).fill(0), a = Array(i);
  let o, s, l, u = eo(e, 0);
  for (o = 0; o < i; ++o)
    if (s = l, l = u, u = eo(e, o + 1), !!l) {
      if (u) {
        const c = u[t] - l[t];
        r[o] = c !== 0 ? (u[n] - l[n]) / c : 0;
      }
      a[o] = s ? u ? jn(r[o - 1]) !== jn(r[o]) ? 0 : (r[o - 1] + r[o]) / 2 : r[o - 1] : r[o];
    }
  bM(e, r, a), xM(e, a, t);
}
function ol(e, t, n) {
  return Math.max(Math.min(e, n), t);
}
function SM(e, t) {
  let n, i, r, a, o, s = Ds(e[0], t);
  for (n = 0, i = e.length; n < i; ++n)
    o = a, a = s, s = n < i - 1 && Ds(e[n + 1], t), a && (r = e[n], o && (r.cp1x = ol(r.cp1x, t.left, t.right), r.cp1y = ol(r.cp1y, t.top, t.bottom)), s && (r.cp2x = ol(r.cp2x, t.left, t.right), r.cp2y = ol(r.cp2y, t.top, t.bottom)));
}
function MM(e, t, n, i, r) {
  let a, o, s, l;
  if (t.spanGaps && (e = e.filter((u) => !u.skip)), t.cubicInterpolationMode === "monotone")
    wM(e, r);
  else {
    let u = i ? e[e.length - 1] : e[0];
    for (a = 0, o = e.length; a < o; ++a)
      s = e[a], l = yM(u, s, e[Math.min(a + 1, o - (i ? 0 : 1)) % o], t.tension), s.cp1x = l.previous.x, s.cp1y = l.previous.y, s.cp2x = l.next.x, s.cp2y = l.next.y, u = s;
  }
  t.capBezierPoints && SM(e, n);
}
function uv() {
  return typeof window < "u" && typeof document < "u";
}
function cv(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function xu(e, t, n) {
  let i;
  return typeof e == "string" ? (i = parseInt(e, 10), e.indexOf("%") !== -1 && (i = i / 100 * t.parentNode[n])) : i = e, i;
}
const pc = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function DM(e, t) {
  return pc(e).getPropertyValue(t);
}
const TM = [
  "top",
  "right",
  "bottom",
  "left"
];
function Xr(e, t, n) {
  const i = {};
  n = n ? "-" + n : "";
  for (let r = 0; r < 4; r++) {
    const a = TM[r];
    i[a] = parseFloat(e[t + "-" + a + n]) || 0;
  }
  return i.width = i.left + i.right, i.height = i.top + i.bottom, i;
}
const kM = (e, t, n) => (e > 0 || t > 0) && (!n || !n.shadowRoot);
function CM(e, t) {
  const n = e.touches, i = n && n.length ? n[0] : e, { offsetX: r, offsetY: a } = i;
  let o = !1, s, l;
  if (kM(r, a, e.target))
    s = r, l = a;
  else {
    const u = t.getBoundingClientRect();
    s = i.clientX - u.left, l = i.clientY - u.top, o = !0;
  }
  return {
    x: s,
    y: l,
    box: o
  };
}
function Rr(e, t) {
  if ("native" in e)
    return e;
  const { canvas: n, currentDevicePixelRatio: i } = t, r = pc(n), a = r.boxSizing === "border-box", o = Xr(r, "padding"), s = Xr(r, "border", "width"), { x: l, y: u, box: c } = CM(e, n), h = o.left + (c && s.left), d = o.top + (c && s.top);
  let { width: f, height: v } = t;
  return a && (f -= o.width + s.width, v -= o.height + s.height), {
    x: Math.round((l - h) / f * n.width / i),
    y: Math.round((u - d) / v * n.height / i)
  };
}
function PM(e, t, n) {
  let i, r;
  if (t === void 0 || n === void 0) {
    const a = e && cv(e);
    if (!a)
      t = e.clientWidth, n = e.clientHeight;
    else {
      const o = a.getBoundingClientRect(), s = pc(a), l = Xr(s, "border", "width"), u = Xr(s, "padding");
      t = o.width - u.width - l.width, n = o.height - u.height - l.height, i = xu(s.maxWidth, a, "clientWidth"), r = xu(s.maxHeight, a, "clientHeight");
    }
  }
  return {
    width: t,
    height: n,
    maxWidth: i || yu,
    maxHeight: r || yu
  };
}
const $i = (e) => Math.round(e * 10) / 10;
function AM(e, t, n, i) {
  const r = pc(e), a = Xr(r, "margin"), o = xu(r.maxWidth, e, "clientWidth") || yu, s = xu(r.maxHeight, e, "clientHeight") || yu, l = PM(e, t, n);
  let { width: u, height: c } = l;
  if (r.boxSizing === "content-box") {
    const d = Xr(r, "border", "width"), f = Xr(r, "padding");
    u -= f.width + d.width, c -= f.height + d.height;
  }
  return u = Math.max(0, u - a.width), c = Math.max(0, i ? u / i : c - a.height), u = $i(Math.min(u, o, l.maxWidth)), c = $i(Math.min(c, s, l.maxHeight)), u && !c && (c = $i(u / 2)), (t !== void 0 || n !== void 0) && i && l.height && c > l.height && (c = l.height, u = $i(Math.floor(c * i))), {
    width: u,
    height: c
  };
}
function cg(e, t, n) {
  const i = t || 1, r = $i(e.height * i), a = $i(e.width * i);
  e.height = $i(e.height), e.width = $i(e.width);
  const o = e.canvas;
  return o.style && (n || !o.style.height && !o.style.width) && (o.style.height = `${e.height}px`, o.style.width = `${e.width}px`), e.currentDevicePixelRatio !== i || o.height !== r || o.width !== a ? (e.currentDevicePixelRatio = i, o.height = r, o.width = a, e.ctx.setTransform(i, 0, 0, i, 0, 0), !0) : !1;
}
const EM = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    uv() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function hg(e, t) {
  const n = DM(e, t), i = n && n.match(/^(\d+)(\.\d+)?px$/);
  return i ? +i[1] : void 0;
}
function Nr(e, t, n, i) {
  return {
    x: e.x + n * (t.x - e.x),
    y: e.y + n * (t.y - e.y)
  };
}
function LM(e, t, n, i) {
  return {
    x: e.x + n * (t.x - e.x),
    y: i === "middle" ? n < 0.5 ? e.y : t.y : i === "after" ? n < 1 ? e.y : t.y : n > 0 ? t.y : e.y
  };
}
function OM(e, t, n, i) {
  const r = {
    x: e.cp2x,
    y: e.cp2y
  }, a = {
    x: t.cp1x,
    y: t.cp1y
  }, o = Nr(e, r, n), s = Nr(r, a, n), l = Nr(a, t, n), u = Nr(o, s, n), c = Nr(s, l, n);
  return Nr(u, c, n);
}
const IM = function(e, t) {
  return {
    x(n) {
      return e + e + t - n;
    },
    setWidth(n) {
      t = n;
    },
    textAlign(n) {
      return n === "center" ? n : n === "right" ? "left" : "right";
    },
    xPlus(n, i) {
      return n - i;
    },
    leftForLtr(n, i) {
      return n - i;
    }
  };
}, RM = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function Ga(e, t, n) {
  return e ? IM(t, n) : RM();
}
function cb(e, t) {
  let n, i;
  (t === "ltr" || t === "rtl") && (n = e.canvas.style, i = [
    n.getPropertyValue("direction"),
    n.getPropertyPriority("direction")
  ], n.setProperty("direction", t, "important"), e.prevTextDirection = i);
}
function hb(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function db(e) {
  return e === "angle" ? {
    between: Ms,
    compare: I2,
    normalize: je
  } : {
    between: pi,
    compare: (t, n) => t - n,
    normalize: (t) => t
  };
}
function dg({ start: e, end: t, count: n, loop: i, style: r }) {
  return {
    start: e % n,
    end: t % n,
    loop: i && (t - e + 1) % n === 0,
    style: r
  };
}
function NM(e, t, n) {
  const { property: i, start: r, end: a } = n, { between: o, normalize: s } = db(i), l = t.length;
  let { start: u, end: c, loop: h } = e, d, f;
  if (h) {
    for (u += l, c += l, d = 0, f = l; d < f && o(s(t[u % l][i]), r, a); ++d)
      u--, c--;
    u %= l, c %= l;
  }
  return c < u && (c += l), {
    start: u,
    end: c,
    loop: h,
    style: e.style
  };
}
function fb(e, t, n) {
  if (!n)
    return [
      e
    ];
  const { property: i, start: r, end: a } = n, o = t.length, { compare: s, between: l, normalize: u } = db(i), { start: c, end: h, loop: d, style: f } = NM(e, t, n), v = [];
  let g = !1, p = null, _, m, y;
  const b = () => l(r, y, _) && s(r, y) !== 0, x = () => s(a, _) === 0 || l(a, y, _), w = () => g || b(), M = () => !g || x();
  for (let D = c, T = c; D <= h; ++D)
    m = t[D % o], !m.skip && (_ = u(m[i]), _ !== y && (g = l(_, r, a), p === null && w() && (p = s(_, r) === 0 ? D : T), p !== null && M() && (v.push(dg({
      start: p,
      end: D,
      loop: d,
      count: o,
      style: f
    })), p = null), T = D, y = _));
  return p !== null && v.push(dg({
    start: p,
    end: h,
    loop: d,
    count: o,
    style: f
  })), v;
}
function vb(e, t) {
  const n = [], i = e.segments;
  for (let r = 0; r < i.length; r++) {
    const a = fb(i[r], e.points, t);
    a.length && n.push(...a);
  }
  return n;
}
function FM(e, t, n, i) {
  let r = 0, a = t - 1;
  if (n && !i)
    for (; r < t && !e[r].skip; )
      r++;
  for (; r < t && e[r].skip; )
    r++;
  for (r %= t, n && (a += r); a > r && e[a % t].skip; )
    a--;
  return a %= t, {
    start: r,
    end: a
  };
}
function BM(e, t, n, i) {
  const r = e.length, a = [];
  let o = t, s = e[t], l;
  for (l = t + 1; l <= n; ++l) {
    const u = e[l % r];
    u.skip || u.stop ? s.skip || (i = !1, a.push({
      start: t % r,
      end: (l - 1) % r,
      loop: i
    }), t = o = u.stop ? l : null) : (o = l, s.skip && (t = l)), s = u;
  }
  return o !== null && a.push({
    start: t % r,
    end: o % r,
    loop: i
  }), a;
}
function zM(e, t) {
  const n = e.points, i = e.options.spanGaps, r = n.length;
  if (!r)
    return [];
  const a = !!e._loop, { start: o, end: s } = FM(n, r, a, i);
  if (i === !0)
    return fg(e, [
      {
        start: o,
        end: s,
        loop: a
      }
    ], n, t);
  const l = s < o ? s + r : s, u = !!e._fullLoop && o === 0 && s === r - 1;
  return fg(e, BM(n, o, l, u), n, t);
}
function fg(e, t, n, i) {
  return !i || !i.setContext || !n ? t : VM(e, t, n, i);
}
function VM(e, t, n, i) {
  const r = e._chart.getContext(), a = vg(e.options), { _datasetIndex: o, options: { spanGaps: s } } = e, l = n.length, u = [];
  let c = a, h = t[0].start, d = h;
  function f(v, g, p, _) {
    const m = s ? -1 : 1;
    if (v !== g) {
      for (v += l; n[v % l].skip; )
        v -= m;
      for (; n[g % l].skip; )
        g += m;
      v % l !== g % l && (u.push({
        start: v % l,
        end: g % l,
        loop: p,
        style: _
      }), c = _, h = g % l);
    }
  }
  for (const v of t) {
    h = s ? h : v.start;
    let g = n[h % l], p;
    for (d = h + 1; d <= v.end; d++) {
      const _ = n[d % l];
      p = vg(i.setContext(la(r, {
        type: "segment",
        p0: g,
        p1: _,
        p0DataIndex: (d - 1) % l,
        p1DataIndex: d % l,
        datasetIndex: o
      }))), $M(p, c) && f(h, d - 1, v.loop, c), g = _, c = p;
    }
    h < d - 1 && f(h, d - 1, v.loop, c);
  }
  return u;
}
function vg(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function $M(e, t) {
  if (!t)
    return !1;
  const n = [], i = function(r, a) {
    return iv(a) ? (n.includes(a) || n.push(a), n.indexOf(a)) : a;
  };
  return JSON.stringify(e, i) !== JSON.stringify(t, i);
}
function sl(e, t, n) {
  return e.options.clip ? e[n] : t[n];
}
function HM(e, t) {
  const { xScale: n, yScale: i } = e;
  return n && i ? {
    left: sl(n, t, "left"),
    right: sl(n, t, "right"),
    top: sl(i, t, "top"),
    bottom: sl(i, t, "bottom")
  } : t;
}
function pb(e, t) {
  const n = t._clip;
  if (n.disabled)
    return !1;
  const i = HM(t, e.chartArea);
  return {
    left: n.left === !1 ? 0 : i.left - (n.left === !0 ? 0 : n.left),
    right: n.right === !1 ? e.width : i.right + (n.right === !0 ? 0 : n.right),
    top: n.top === !1 ? 0 : i.top - (n.top === !0 ? 0 : n.top),
    bottom: n.bottom === !1 ? e.height : i.bottom + (n.bottom === !0 ? 0 : n.bottom)
  };
}
let YM = class {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, n, i, r) {
    const a = n.listeners[r], o = n.duration;
    a.forEach((s) => s({
      chart: t,
      initial: n.initial,
      numSteps: o,
      currentStep: Math.min(i - n.start, o)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = tb.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let n = 0;
    this._charts.forEach((i, r) => {
      if (!i.running || !i.items.length)
        return;
      const a = i.items;
      let o = a.length - 1, s = !1, l;
      for (; o >= 0; --o)
        l = a[o], l._active ? (l._total > i.duration && (i.duration = l._total), l.tick(t), s = !0) : (a[o] = a[a.length - 1], a.pop());
      s && (r.draw(), this._notify(r, i, t, "progress")), a.length || (i.running = !1, this._notify(r, i, t, "complete"), i.initial = !1), n += a.length;
    }), this._lastDate = t, n === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const n = this._charts;
    let i = n.get(t);
    return i || (i = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, n.set(t, i)), i;
  }
  listen(t, n, i) {
    this._getAnims(t).listeners[n].push(i);
  }
  add(t, n) {
    !n || !n.length || this._getAnims(t).items.push(...n);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const n = this._charts.get(t);
    n && (n.running = !0, n.start = Date.now(), n.duration = n.items.reduce((i, r) => Math.max(i, r._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const n = this._charts.get(t);
    return !(!n || !n.running || !n.items.length);
  }
  stop(t) {
    const n = this._charts.get(t);
    if (!n || !n.items.length)
      return;
    const i = n.items;
    let r = i.length - 1;
    for (; r >= 0; --r)
      i[r].cancel();
    n.items = [], this._notify(t, n, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
};
var ui = /* @__PURE__ */ new YM();
const pg = "transparent", WM = {
  boolean(e, t, n) {
    return n > 0.5 ? t : e;
  },
  color(e, t, n) {
    const i = rg(e || pg), r = i.valid && rg(t || pg);
    return r && r.valid ? r.mix(i, n).hexString() : t;
  },
  number(e, t, n) {
    return e + (t - e) * n;
  }
};
let UM = class {
  constructor(t, n, i, r) {
    const a = n[i];
    r = al([
      t.to,
      r,
      a,
      t.from
    ]);
    const o = al([
      t.from,
      a,
      r
    ]);
    this._active = !0, this._fn = t.fn || WM[t.type || typeof o], this._easing = ls[t.easing] || ls.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = n, this._prop = i, this._from = o, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, n, i) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], a = i - this._start, o = this._duration - a;
      this._start = i, this._duration = Math.floor(Math.max(o, t.duration)), this._total += a, this._loop = !!t.loop, this._to = al([
        t.to,
        n,
        r,
        t.from
      ]), this._from = al([
        t.from,
        r,
        n
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const n = t - this._start, i = this._duration, r = this._prop, a = this._from, o = this._loop, s = this._to;
    let l;
    if (this._active = a !== s && (o || n < i), !this._active) {
      this._target[r] = s, this._notify(!0);
      return;
    }
    if (n < 0) {
      this._target[r] = a;
      return;
    }
    l = n / i % 2, l = o && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(a, s, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((n, i) => {
      t.push({
        res: n,
        rej: i
      });
    });
  }
  _notify(t) {
    const n = t ? "res" : "rej", i = this._promises || [];
    for (let r = 0; r < i.length; r++)
      i[r][n]();
  }
};
class gb {
  constructor(t, n) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(n);
  }
  configure(t) {
    if (!dt(t))
      return;
    const n = Object.keys(ee.animation), i = this._properties;
    Object.getOwnPropertyNames(t).forEach((r) => {
      const a = t[r];
      if (!dt(a))
        return;
      const o = {};
      for (const s of n)
        o[s] = a[s];
      (ie(a.properties) && a.properties || [
        r
      ]).forEach((s) => {
        (s === r || !i.has(s)) && i.set(s, o);
      });
    });
  }
  _animateOptions(t, n) {
    const i = n.options, r = jM(t, i);
    if (!r)
      return [];
    const a = this._createAnimations(r, i);
    return i.$shared && GM(t.options.$animations, i).then(() => {
      t.options = i;
    }, () => {
    }), a;
  }
  _createAnimations(t, n) {
    const i = this._properties, r = [], a = t.$animations || (t.$animations = {}), o = Object.keys(n), s = Date.now();
    let l;
    for (l = o.length - 1; l >= 0; --l) {
      const u = o[l];
      if (u.charAt(0) === "$")
        continue;
      if (u === "options") {
        r.push(...this._animateOptions(t, n));
        continue;
      }
      const c = n[u];
      let h = a[u];
      const d = i.get(u);
      if (h)
        if (d && h.active()) {
          h.update(d, c, s);
          continue;
        } else
          h.cancel();
      if (!d || !d.duration) {
        t[u] = c;
        continue;
      }
      a[u] = h = new UM(d, t, u, c), r.push(h);
    }
    return r;
  }
  update(t, n) {
    if (this._properties.size === 0) {
      Object.assign(t, n);
      return;
    }
    const i = this._createAnimations(t, n);
    if (i.length)
      return ui.add(this._chart, i), !0;
  }
}
function GM(e, t) {
  const n = [], i = Object.keys(t);
  for (let r = 0; r < i.length; r++) {
    const a = e[i[r]];
    a && a.active() && n.push(a.wait());
  }
  return Promise.all(n);
}
function jM(e, t) {
  if (!t)
    return;
  let n = e.options;
  if (!n) {
    e.options = t;
    return;
  }
  return n.$shared && (e.options = n = Object.assign({}, n, {
    $shared: !1,
    $animations: {}
  })), n;
}
function gg(e, t) {
  const n = e && e.options || {}, i = n.reverse, r = n.min === void 0 ? t : 0, a = n.max === void 0 ? t : 0;
  return {
    start: i ? a : r,
    end: i ? r : a
  };
}
function XM(e, t, n) {
  if (n === !1)
    return !1;
  const i = gg(e, n), r = gg(t, n);
  return {
    top: r.end,
    right: i.end,
    bottom: r.start,
    left: i.start
  };
}
function qM(e) {
  let t, n, i, r;
  return dt(e) ? (t = e.top, n = e.right, i = e.bottom, r = e.left) : t = n = i = r = e, {
    top: t,
    right: n,
    bottom: i,
    left: r,
    disabled: e === !1
  };
}
function _b(e, t) {
  const n = [], i = e._getSortedDatasetMetas(t);
  let r, a;
  for (r = 0, a = i.length; r < a; ++r)
    n.push(i[r].index);
  return n;
}
function _g(e, t, n, i = {}) {
  const r = e.keys, a = i.mode === "single";
  let o, s, l, u;
  if (t === null)
    return;
  let c = !1;
  for (o = 0, s = r.length; o < s; ++o) {
    if (l = +r[o], l === n) {
      if (c = !0, i.all)
        continue;
      break;
    }
    u = e.values[l], we(u) && (a || t === 0 || jn(t) === jn(u)) && (t += u);
  }
  return !c && !i.all ? 0 : t;
}
function ZM(e, t) {
  const { iScale: n, vScale: i } = t, r = n.axis === "x" ? "x" : "y", a = i.axis === "x" ? "x" : "y", o = Object.keys(e), s = new Array(o.length);
  let l, u, c;
  for (l = 0, u = o.length; l < u; ++l)
    c = o[l], s[l] = {
      [r]: c,
      [a]: e[c]
    };
  return s;
}
function th(e, t) {
  const n = e && e.options.stacked;
  return n || n === void 0 && t.stack !== void 0;
}
function KM(e, t, n) {
  return `${e.id}.${t.id}.${n.stack || n.type}`;
}
function QM(e) {
  const { min: t, max: n, minDefined: i, maxDefined: r } = e.getUserBounds();
  return {
    min: i ? t : Number.NEGATIVE_INFINITY,
    max: r ? n : Number.POSITIVE_INFINITY
  };
}
function JM(e, t, n) {
  const i = e[t] || (e[t] = {});
  return i[n] || (i[n] = {});
}
function mg(e, t, n, i) {
  for (const r of t.getMatchingVisibleMetas(i).reverse()) {
    const a = e[r.index];
    if (n && a > 0 || !n && a < 0)
      return r.index;
  }
  return null;
}
function yg(e, t) {
  const { chart: n, _cachedMeta: i } = e, r = n._stacks || (n._stacks = {}), { iScale: a, vScale: o, index: s } = i, l = a.axis, u = o.axis, c = KM(a, o, i), h = t.length;
  let d;
  for (let f = 0; f < h; ++f) {
    const v = t[f], { [l]: g, [u]: p } = v, _ = v._stacks || (v._stacks = {});
    d = _[u] = JM(r, c, g), d[s] = p, d._top = mg(d, o, !0, i.type), d._bottom = mg(d, o, !1, i.type);
    const m = d._visualValues || (d._visualValues = {});
    m[s] = p;
  }
}
function eh(e, t) {
  const n = e.scales;
  return Object.keys(n).filter((i) => n[i].axis === t).shift();
}
function tD(e, t) {
  return la(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function eD(e, t, n) {
  return la(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: n,
    index: t,
    mode: "default",
    type: "data"
  });
}
function yo(e, t) {
  const n = e.controller.index, i = e.vScale && e.vScale.axis;
  if (i) {
    t = t || e._parsed;
    for (const r of t) {
      const a = r._stacks;
      if (!a || a[i] === void 0 || a[i][n] === void 0)
        return;
      delete a[i][n], a[i]._visualValues !== void 0 && a[i]._visualValues[n] !== void 0 && delete a[i]._visualValues[n];
    }
  }
}
const nh = (e) => e === "reset" || e === "none", bg = (e, t) => t ? e : Object.assign({}, e), nD = (e, t, n) => e && !t.hidden && t._stacked && {
  keys: _b(n, !0),
  values: null
};
class gc {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, n) {
    this.chart = t, this._ctx = t.ctx, this.index = n, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = th(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && yo(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, n = this._cachedMeta, i = this.getDataset(), r = (h, d, f, v) => h === "x" ? d : h === "r" ? v : f, a = n.xAxisID = ot(i.xAxisID, eh(t, "x")), o = n.yAxisID = ot(i.yAxisID, eh(t, "y")), s = n.rAxisID = ot(i.rAxisID, eh(t, "r")), l = n.indexAxis, u = n.iAxisID = r(l, a, o, s), c = n.vAxisID = r(l, o, a, s);
    n.xScale = this.getScaleForId(a), n.yScale = this.getScaleForId(o), n.rScale = this.getScaleForId(s), n.iScale = this.getScaleForId(u), n.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const n = this._cachedMeta;
    return t === n.iScale ? n.vScale : n.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && eg(this._data, this), t._stacked && yo(t);
  }
  _dataCheck() {
    const t = this.getDataset(), n = t.data || (t.data = []), i = this._data;
    if (dt(n)) {
      const r = this._cachedMeta;
      this._data = ZM(n, r);
    } else if (i !== n) {
      if (i) {
        eg(i, this);
        const r = this._cachedMeta;
        yo(r), r._parsed = [];
      }
      n && Object.isExtensible(n) && B2(n, this), this._syncList = [], this._data = n;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const n = this._cachedMeta, i = this.getDataset();
    let r = !1;
    this._dataCheck();
    const a = n._stacked;
    n._stacked = th(n.vScale, n), n.stack !== i.stack && (r = !0, yo(n), n.stack = i.stack), this._resyncElements(t), (r || a !== n._stacked) && (yg(this, n._parsed), n._stacked = th(n.vScale, n));
  }
  configure() {
    const t = this.chart.config, n = t.datasetScopeKeys(this._type), i = t.getOptionScopes(this.getDataset(), n, !0);
    this.options = t.createResolver(i, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, n) {
    const { _cachedMeta: i, _data: r } = this, { iScale: a, _stacked: o } = i, s = a.axis;
    let l = t === 0 && n === r.length ? !0 : i._sorted, u = t > 0 && i._parsed[t - 1], c, h, d;
    if (this._parsing === !1)
      i._parsed = r, i._sorted = !0, d = r;
    else {
      ie(r[t]) ? d = this.parseArrayData(i, r, t, n) : dt(r[t]) ? d = this.parseObjectData(i, r, t, n) : d = this.parsePrimitiveData(i, r, t, n);
      const f = () => h[s] === null || u && h[s] < u[s];
      for (c = 0; c < n; ++c)
        i._parsed[c + t] = h = d[c], l && (f() && (l = !1), u = h);
      i._sorted = l;
    }
    o && yg(this, d);
  }
  parsePrimitiveData(t, n, i, r) {
    const { iScale: a, vScale: o } = t, s = a.axis, l = o.axis, u = a.getLabels(), c = a === o, h = new Array(r);
    let d, f, v;
    for (d = 0, f = r; d < f; ++d)
      v = d + i, h[d] = {
        [s]: c || a.parse(u[v], v),
        [l]: o.parse(n[v], v)
      };
    return h;
  }
  parseArrayData(t, n, i, r) {
    const { xScale: a, yScale: o } = t, s = new Array(r);
    let l, u, c, h;
    for (l = 0, u = r; l < u; ++l)
      c = l + i, h = n[c], s[l] = {
        x: a.parse(h[0], c),
        y: o.parse(h[1], c)
      };
    return s;
  }
  parseObjectData(t, n, i, r) {
    const { xScale: a, yScale: o } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(r);
    let c, h, d, f;
    for (c = 0, h = r; c < h; ++c)
      d = c + i, f = n[d], u[c] = {
        x: a.parse(ra(f, s), d),
        y: o.parse(ra(f, l), d)
      };
    return u;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, n, i) {
    const r = this.chart, a = this._cachedMeta, o = n[t.axis], s = {
      keys: _b(r, !0),
      values: n._stacks[t.axis]._visualValues
    };
    return _g(s, o, a.index, {
      mode: i
    });
  }
  updateRangeFromParsed(t, n, i, r) {
    const a = i[n.axis];
    let o = a === null ? NaN : a;
    const s = r && i._stacks[n.axis];
    r && s && (r.values = s, o = _g(r, a, this._cachedMeta.index)), t.min = Math.min(t.min, o), t.max = Math.max(t.max, o);
  }
  getMinMax(t, n) {
    const i = this._cachedMeta, r = i._parsed, a = i._sorted && t === i.iScale, o = r.length, s = this._getOtherScale(t), l = nD(n, i, this.chart), u = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: h } = QM(s);
    let d, f;
    function v() {
      f = r[d];
      const g = f[s.axis];
      return !we(f[t.axis]) || c > g || h < g;
    }
    for (d = 0; d < o && !(!v() && (this.updateRangeFromParsed(u, t, f, l), a)); ++d)
      ;
    if (a) {
      for (d = o - 1; d >= 0; --d)
        if (!v()) {
          this.updateRangeFromParsed(u, t, f, l);
          break;
        }
    }
    return u;
  }
  getAllParsedValues(t) {
    const n = this._cachedMeta._parsed, i = [];
    let r, a, o;
    for (r = 0, a = n.length; r < a; ++r)
      o = n[r][t.axis], we(o) && i.push(o);
    return i;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, i = n.iScale, r = n.vScale, a = this.getParsed(t);
    return {
      label: i ? "" + i.getLabelForValue(a[i.axis]) : "",
      value: r ? "" + r.getLabelForValue(a[r.axis]) : ""
    };
  }
  _update(t) {
    const n = this._cachedMeta;
    this.update(t || "default"), n._clip = qM(ot(this.options.clip, XM(n.xScale, n.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, n = this.chart, i = this._cachedMeta, r = i.data || [], a = n.chartArea, o = [], s = this._drawStart || 0, l = this._drawCount || r.length - s, u = this.options.drawActiveElementsOnTop;
    let c;
    for (i.dataset && i.dataset.draw(t, a, s, l), c = s; c < s + l; ++c) {
      const h = r[c];
      h.hidden || (h.active && u ? o.push(h) : h.draw(t, a));
    }
    for (c = 0; c < o.length; ++c)
      o[c].draw(t, a);
  }
  getStyle(t, n) {
    const i = n ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(i) : this.resolveDataElementOptions(t || 0, i);
  }
  getContext(t, n, i) {
    const r = this.getDataset();
    let a;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const o = this._cachedMeta.data[t];
      a = o.$context || (o.$context = eD(this.getContext(), t, o)), a.parsed = this.getParsed(t), a.raw = r.data[t], a.index = a.dataIndex = t;
    } else
      a = this.$context || (this.$context = tD(this.chart.getContext(), this.index)), a.dataset = r, a.index = a.datasetIndex = this.index;
    return a.active = !!n, a.mode = i, a;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, n) {
    return this._resolveElementOptions(this.dataElementType.id, n, t);
  }
  _resolveElementOptions(t, n = "default", i) {
    const r = n === "active", a = this._cachedDataOpts, o = t + "-" + n, s = a[o], l = this.enableOptionSharing && ws(i);
    if (s)
      return bg(s, l);
    const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, t), h = r ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], d = u.getOptionScopes(this.getDataset(), c), f = Object.keys(ee.elements[t]), v = () => this.getContext(i, r, n), g = u.resolveNamedOptions(d, f, v, h);
    return g.$shared && (g.$shared = l, a[o] = Object.freeze(bg(g, l))), g;
  }
  _resolveAnimations(t, n, i) {
    const r = this.chart, a = this._cachedDataOpts, o = `animation-${n}`, s = a[o];
    if (s)
      return s;
    let l;
    if (r.options.animation !== !1) {
      const c = this.chart.config, h = c.datasetAnimationScopeKeys(this._type, n), d = c.getOptionScopes(this.getDataset(), h);
      l = c.createResolver(d, this.getContext(t, i, n));
    }
    const u = new gb(r, l && l.animations);
    return l && l._cacheable && (a[o] = Object.freeze(u)), u;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, n) {
    return !n || nh(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, n) {
    const i = this.resolveDataElementOptions(t, n), r = this._sharedOptions, a = this.getSharedOptions(i), o = this.includeOptions(n, a) || a !== r;
    return this.updateSharedOptions(a, n, i), {
      sharedOptions: a,
      includeOptions: o
    };
  }
  updateElement(t, n, i, r) {
    nh(r) ? Object.assign(t, i) : this._resolveAnimations(n, r).update(t, i);
  }
  updateSharedOptions(t, n, i) {
    t && !nh(n) && this._resolveAnimations(void 0, n).update(t, i);
  }
  _setStyle(t, n, i, r) {
    t.active = r;
    const a = this.getStyle(n, r);
    this._resolveAnimations(n, i, r).update(t, {
      options: !r && this.getSharedOptions(a) || a
    });
  }
  removeHoverStyle(t, n, i) {
    this._setStyle(t, i, "active", !1);
  }
  setHoverStyle(t, n, i) {
    this._setStyle(t, i, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const n = this._data, i = this._cachedMeta.data;
    for (const [s, l, u] of this._syncList)
      this[s](l, u);
    this._syncList = [];
    const r = i.length, a = n.length, o = Math.min(a, r);
    o && this.parse(0, o), a > r ? this._insertElements(r, a - r, t) : a < r && this._removeElements(a, r - a);
  }
  _insertElements(t, n, i = !0) {
    const r = this._cachedMeta, a = r.data, o = t + n;
    let s;
    const l = (u) => {
      for (u.length += n, s = u.length - 1; s >= o; s--)
        u[s] = u[s - n];
    };
    for (l(a), s = t; s < o; ++s)
      a[s] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(t, n), i && this.updateElements(a, t, n, "reset");
  }
  updateElements(t, n, i, r) {
  }
  _removeElements(t, n) {
    const i = this._cachedMeta;
    if (this._parsing) {
      const r = i._parsed.splice(t, n);
      i._stacked && yo(i, r);
    }
    i.data.splice(t, n);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [n, i, r] = t;
      this[n](i, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, n) {
    n && this._sync([
      "_removeElements",
      t,
      n
    ]);
    const i = arguments.length - 2;
    i && this._sync([
      "_insertElements",
      t,
      i
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function iD(e, t) {
  if (!e._cache.$bar) {
    const n = e.getMatchingVisibleMetas(t);
    let i = [];
    for (let r = 0, a = n.length; r < a; r++)
      i = i.concat(n[r].controller.getAllParsedValues(e));
    e._cache.$bar = Jy(i.sort((r, a) => r - a));
  }
  return e._cache.$bar;
}
function rD(e) {
  const t = e.iScale, n = iD(t, e.type);
  let i = t._length, r, a, o, s;
  const l = () => {
    o === 32767 || o === -32768 || (ws(s) && (i = Math.min(i, Math.abs(o - s) || i)), s = o);
  };
  for (r = 0, a = n.length; r < a; ++r)
    o = t.getPixelForValue(n[r]), l();
  for (s = void 0, r = 0, a = t.ticks.length; r < a; ++r)
    o = t.getPixelForTick(r), l();
  return i;
}
function aD(e, t, n, i) {
  const r = n.barThickness;
  let a, o;
  return Dt(r) ? (a = t.min * n.categoryPercentage, o = n.barPercentage) : (a = r * i, o = 1), {
    chunk: a / i,
    ratio: o,
    start: t.pixels[e] - a / 2
  };
}
function oD(e, t, n, i) {
  const r = t.pixels, a = r[e];
  let o = e > 0 ? r[e - 1] : null, s = e < r.length - 1 ? r[e + 1] : null;
  const l = n.categoryPercentage;
  o === null && (o = a - (s === null ? t.end - t.start : s - a)), s === null && (s = a + a - o);
  const u = a - (a - Math.min(o, s)) / 2 * l;
  return {
    chunk: Math.abs(s - o) / 2 * l / i,
    ratio: n.barPercentage,
    start: u
  };
}
function sD(e, t, n, i) {
  const r = n.parse(e[0], i), a = n.parse(e[1], i), o = Math.min(r, a), s = Math.max(r, a);
  let l = o, u = s;
  Math.abs(o) > Math.abs(s) && (l = s, u = o), t[n.axis] = u, t._custom = {
    barStart: l,
    barEnd: u,
    start: r,
    end: a,
    min: o,
    max: s
  };
}
function mb(e, t, n, i) {
  return ie(e) ? sD(e, t, n, i) : t[n.axis] = n.parse(e, i), t;
}
function xg(e, t, n, i) {
  const r = e.iScale, a = e.vScale, o = r.getLabels(), s = r === a, l = [];
  let u, c, h, d;
  for (u = n, c = n + i; u < c; ++u)
    d = t[u], h = {}, h[r.axis] = s || r.parse(o[u], u), l.push(mb(d, h, a, u));
  return l;
}
function ih(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function lD(e, t, n) {
  return e !== 0 ? jn(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= n ? 1 : -1);
}
function uD(e) {
  let t, n, i, r, a;
  return e.horizontal ? (t = e.base > e.x, n = "left", i = "right") : (t = e.base < e.y, n = "bottom", i = "top"), t ? (r = "end", a = "start") : (r = "start", a = "end"), {
    start: n,
    end: i,
    reverse: t,
    top: r,
    bottom: a
  };
}
function cD(e, t, n, i) {
  let r = t.borderSkipped;
  const a = {};
  if (!r) {
    e.borderSkipped = a;
    return;
  }
  if (r === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: o, end: s, reverse: l, top: u, bottom: c } = uD(e);
  r === "middle" && n && (e.enableBorderRadius = !0, (n._top || 0) === i ? r = u : (n._bottom || 0) === i ? r = c : (a[wg(c, o, s, l)] = !0, r = u)), a[wg(r, o, s, l)] = !0, e.borderSkipped = a;
}
function wg(e, t, n, i) {
  return i ? (e = hD(e, t, n), e = Sg(e, n, t)) : e = Sg(e, t, n), e;
}
function hD(e, t, n) {
  return e === t ? n : e === n ? t : e;
}
function Sg(e, t, n) {
  return e === "start" ? t : e === "end" ? n : e;
}
function dD(e, { inflateAmount: t }, n) {
  e.inflateAmount = t === "auto" ? n === 1 ? 0.33 : 0 : t;
}
class fD extends gc {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, n, i, r) {
    return xg(t, n, i, r);
  }
  parseArrayData(t, n, i, r) {
    return xg(t, n, i, r);
  }
  parseObjectData(t, n, i, r) {
    const { iScale: a, vScale: o } = t, { xAxisKey: s = "x", yAxisKey: l = "y" } = this._parsing, u = a.axis === "x" ? s : l, c = o.axis === "x" ? s : l, h = [];
    let d, f, v, g;
    for (d = i, f = i + r; d < f; ++d)
      g = n[d], v = {}, v[a.axis] = a.parse(ra(g, u), d), h.push(mb(ra(g, c), v, o, d));
    return h;
  }
  updateRangeFromParsed(t, n, i, r) {
    super.updateRangeFromParsed(t, n, i, r);
    const a = i._custom;
    a && n === this._cachedMeta.vScale && (t.min = Math.min(t.min, a.min), t.max = Math.max(t.max, a.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, { iScale: i, vScale: r } = n, a = this.getParsed(t), o = a._custom, s = ih(o) ? "[" + o.start + ", " + o.end + "]" : "" + r.getLabelForValue(a[r.axis]);
    return {
      label: "" + i.getLabelForValue(a[i.axis]),
      value: s
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const n = this._cachedMeta;
    this.updateElements(n.data, 0, n.data.length, t);
  }
  updateElements(t, n, i, r) {
    const a = r === "reset", { index: o, _cachedMeta: { vScale: s } } = this, l = s.getBasePixel(), u = s.isHorizontal(), c = this._getRuler(), { sharedOptions: h, includeOptions: d } = this._getSharedOptions(n, r);
    for (let f = n; f < n + i; f++) {
      const v = this.getParsed(f), g = a || Dt(v[s.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(f), p = this._calculateBarIndexPixels(f, c), _ = (v._stacks || {})[s.axis], m = {
        horizontal: u,
        base: g.base,
        enableBorderRadius: !_ || ih(v._custom) || o === _._top || o === _._bottom,
        x: u ? g.head : p.center,
        y: u ? p.center : g.head,
        height: u ? p.size : Math.abs(g.size),
        width: u ? Math.abs(g.size) : p.size
      };
      d && (m.options = h || this.resolveDataElementOptions(f, t[f].active ? "active" : r));
      const y = m.options || t[f].options;
      cD(m, y, _, o), dD(m, y, c.ratio), this.updateElement(t[f], f, m, r);
    }
  }
  _getStacks(t, n) {
    const { iScale: i } = this._cachedMeta, r = i.getMatchingVisibleMetas(this._type).filter((c) => c.controller.options.grouped), a = i.options.stacked, o = [], s = this._cachedMeta.controller.getParsed(n), l = s && s[i.axis], u = (c) => {
      const h = c._parsed.find((f) => f[i.axis] === l), d = h && h[c.vScale.axis];
      if (Dt(d) || isNaN(d))
        return !0;
    };
    for (const c of r)
      if (!(n !== void 0 && u(c)) && ((a === !1 || o.indexOf(c.stack) === -1 || a === void 0 && c.stack === void 0) && o.push(c.stack), c.index === t))
        break;
    return o.length || o.push(void 0), o;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, n = this.chart.options.indexAxis;
    return Object.keys(t).filter((i) => t[i].axis === n).shift();
  }
  _getAxis() {
    const t = {}, n = this.getFirstScaleIdForIndexAxis();
    for (const i of this.chart.data.datasets)
      t[ot(this.chart.options.indexAxis === "x" ? i.xAxisID : i.yAxisID, n)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, n, i) {
    const r = this._getStacks(t, i), a = n !== void 0 ? r.indexOf(n) : -1;
    return a === -1 ? r.length - 1 : a;
  }
  _getRuler() {
    const t = this.options, n = this._cachedMeta, i = n.iScale, r = [];
    let a, o;
    for (a = 0, o = n.data.length; a < o; ++a)
      r.push(i.getPixelForValue(this.getParsed(a)[i.axis], a));
    const s = t.barThickness;
    return {
      min: s || rD(n),
      pixels: r,
      start: i._startPixel,
      end: i._endPixel,
      stackCount: this._getStackCount(),
      scale: i,
      grouped: t.grouped,
      ratio: s ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: n, _stacked: i, index: r }, options: { base: a, minBarLength: o } } = this, s = a || 0, l = this.getParsed(t), u = l._custom, c = ih(u);
    let h = l[n.axis], d = 0, f = i ? this.applyStack(n, l, i) : h, v, g;
    f !== h && (d = f - h, f = h), c && (h = u.barStart, f = u.barEnd - u.barStart, h !== 0 && jn(h) !== jn(u.barEnd) && (d = 0), d += h);
    const p = !Dt(a) && !c ? a : d;
    let _ = n.getPixelForValue(p);
    if (this.chart.getDataVisibility(t) ? v = n.getPixelForValue(d + f) : v = _, g = v - _, Math.abs(g) < o) {
      g = lD(g, n, s) * o, h === s && (_ -= g / 2);
      const m = n.getPixelForDecimal(0), y = n.getPixelForDecimal(1), b = Math.min(m, y), x = Math.max(m, y);
      _ = Math.max(Math.min(_, x), b), v = _ + g, i && !c && (l._stacks[n.axis]._visualValues[r] = n.getValueForPixel(v) - n.getValueForPixel(_));
    }
    if (_ === n.getPixelForValue(s)) {
      const m = jn(g) * n.getLineWidthForValue(s) / 2;
      _ += m, g -= m;
    }
    return {
      size: g,
      base: _,
      head: v,
      center: v + g / 2
    };
  }
  _calculateBarIndexPixels(t, n) {
    const i = n.scale, r = this.options, a = r.skipNull, o = ot(r.maxBarThickness, 1 / 0);
    let s, l;
    const u = this._getAxisCount();
    if (n.grouped) {
      const c = a ? this._getStackCount(t) : n.stackCount, h = r.barThickness === "flex" ? oD(t, n, r, c * u) : aD(t, n, r, c * u), d = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, f = this._getAxis().indexOf(ot(d, this.getFirstScaleIdForIndexAxis())), v = this._getStackIndex(this.index, this._cachedMeta.stack, a ? t : void 0) + f;
      s = h.start + h.chunk * v + h.chunk / 2, l = Math.min(o, h.chunk * h.ratio);
    } else
      s = i.getPixelForValue(this.getParsed(t)[i.axis], t), l = Math.min(o, n.min * n.ratio);
    return {
      base: s - l / 2,
      head: s + l / 2,
      center: s,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, n = t.vScale, i = t.data, r = i.length;
    let a = 0;
    for (; a < r; ++a)
      this.getParsed(a)[n.axis] !== null && !i[a].hidden && i[a].draw(this._ctx);
  }
}
function vD(e, t, n) {
  let i = 1, r = 1, a = 0, o = 0;
  if (t < Ut) {
    const s = e, l = s + t, u = Math.cos(s), c = Math.sin(s), h = Math.cos(l), d = Math.sin(l), f = (y, b, x) => Ms(y, s, l, !0) ? 1 : Math.max(b, b * n, x, x * n), v = (y, b, x) => Ms(y, s, l, !0) ? -1 : Math.min(b, b * n, x, x * n), g = f(0, u, h), p = f(se, c, d), _ = v(Ct, u, h), m = v(Ct + se, c, d);
    i = (g - _) / 2, r = (p - m) / 2, a = -(g + _) / 2, o = -(p + m) / 2;
  }
  return {
    ratioX: i,
    ratioY: r,
    offsetX: a,
    offsetY: o
  };
}
class pD extends gc {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const n = t.data, { labels: { pointStyle: i, textAlign: r, color: a, useBorderRadius: o, borderRadius: s } } = t.legend.options;
            return n.labels.length && n.datasets.length ? n.labels.map((l, u) => {
              const h = t.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: l,
                fillStyle: h.backgroundColor,
                fontColor: a,
                hidden: !t.getDataVisibility(u),
                lineDash: h.borderDash,
                lineDashOffset: h.borderDashOffset,
                lineJoin: h.borderJoinStyle,
                lineWidth: h.borderWidth,
                strokeStyle: h.borderColor,
                textAlign: r,
                pointStyle: i,
                borderRadius: o && (s || h.borderRadius),
                index: u
              };
            }) : [];
          }
        },
        onClick(t, n, i) {
          i.chart.toggleDataVisibility(n.index), i.chart.update();
        }
      }
    }
  };
  constructor(t, n) {
    super(t, n), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, n) {
    const i = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = i;
    else {
      let a = (l) => +i[l];
      if (dt(i[t])) {
        const { key: l = "value" } = this._parsing;
        a = (u) => +ra(i[u], l);
      }
      let o, s;
      for (o = t, s = t + n; o < s; ++o)
        r._parsed[o] = a(o);
    }
  }
  _getRotation() {
    return vi(this.options.rotation - 90);
  }
  _getCircumference() {
    return vi(this.options.circumference);
  }
  _getRotationExtents() {
    let t = Ut, n = -Ut;
    for (let i = 0; i < this.chart.data.datasets.length; ++i)
      if (this.chart.isDatasetVisible(i) && this.chart.getDatasetMeta(i).type === this._type) {
        const r = this.chart.getDatasetMeta(i).controller, a = r._getRotation(), o = r._getCircumference();
        t = Math.min(t, a), n = Math.max(n, a + o);
      }
    return {
      rotation: t,
      circumference: n - t
    };
  }
  update(t) {
    const n = this.chart, { chartArea: i } = n, r = this._cachedMeta, a = r.data, o = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing, s = Math.max((Math.min(i.width, i.height) - o) / 2, 0), l = Math.min(x2(this.options.cutout, s), 1), u = this._getRingWeight(this.index), { circumference: c, rotation: h } = this._getRotationExtents(), { ratioX: d, ratioY: f, offsetX: v, offsetY: g } = vD(h, c, l), p = (i.width - o) / d, _ = (i.height - o) / f, m = Math.max(Math.min(p, _) / 2, 0), y = Xy(this.options.radius, m), b = Math.max(y * l, 0), x = (y - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = v * y, this.offsetY = g * y, r.total = this.calculateTotal(), this.outerRadius = y - x * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - x * u, 0), this.updateElements(a, 0, a.length, t);
  }
  _circumference(t, n) {
    const i = this.options, r = this._cachedMeta, a = this._getCircumference();
    return n && i.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * a / Ut);
  }
  updateElements(t, n, i, r) {
    const a = r === "reset", o = this.chart, s = o.chartArea, u = o.options.animation, c = (s.left + s.right) / 2, h = (s.top + s.bottom) / 2, d = a && u.animateScale, f = d ? 0 : this.innerRadius, v = d ? 0 : this.outerRadius, { sharedOptions: g, includeOptions: p } = this._getSharedOptions(n, r);
    let _ = this._getRotation(), m;
    for (m = 0; m < n; ++m)
      _ += this._circumference(m, a);
    for (m = n; m < n + i; ++m) {
      const y = this._circumference(m, a), b = t[m], x = {
        x: c + this.offsetX,
        y: h + this.offsetY,
        startAngle: _,
        endAngle: _ + y,
        circumference: y,
        outerRadius: v,
        innerRadius: f
      };
      p && (x.options = g || this.resolveDataElementOptions(m, b.active ? "active" : r)), _ += y, this.updateElement(b, m, x, r);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, n = t.data;
    let i = 0, r;
    for (r = 0; r < n.length; r++) {
      const a = t._parsed[r];
      a !== null && !isNaN(a) && this.chart.getDataVisibility(r) && !n[r].hidden && (i += Math.abs(a));
    }
    return i;
  }
  calculateCircumference(t) {
    const n = this._cachedMeta.total;
    return n > 0 && !isNaN(t) ? Ut * (Math.abs(t) / n) : 0;
  }
  getLabelAndValue(t) {
    const n = this._cachedMeta, i = this.chart, r = i.data.labels || [], a = rv(n._parsed[t], i.options.locale);
    return {
      label: r[t] || "",
      value: a
    };
  }
  getMaxBorderWidth(t) {
    let n = 0;
    const i = this.chart;
    let r, a, o, s, l;
    if (!t) {
      for (r = 0, a = i.data.datasets.length; r < a; ++r)
        if (i.isDatasetVisible(r)) {
          o = i.getDatasetMeta(r), t = o.data, s = o.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (r = 0, a = t.length; r < a; ++r)
      l = s.resolveDataElementOptions(r), l.borderAlign !== "inner" && (n = Math.max(n, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return n;
  }
  getMaxOffset(t) {
    let n = 0;
    for (let i = 0, r = t.length; i < r; ++i) {
      const a = this.resolveDataElementOptions(i);
      n = Math.max(n, a.offset || 0, a.hoverOffset || 0);
    }
    return n;
  }
  _getRingWeightOffset(t) {
    let n = 0;
    for (let i = 0; i < t; ++i)
      this.chart.isDatasetVisible(i) && (n += this._getRingWeight(i));
    return n;
  }
  _getRingWeight(t) {
    return Math.max(ot(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class gD extends gc {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const n = this._cachedMeta, { dataset: i, data: r = [], _dataset: a } = n, o = this.chart._animationsDisabled;
    let { start: s, count: l } = $2(n, r, o);
    this._drawStart = s, this._drawCount = l, H2(n) && (s = 0, l = r.length), i._chart = this.chart, i._datasetIndex = this.index, i._decimated = !!a._decimated, i.points = r;
    const u = this.resolveDatasetElementOptions(t);
    this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(i, void 0, {
      animated: !o,
      options: u
    }, t), this.updateElements(r, s, l, t);
  }
  updateElements(t, n, i, r) {
    const a = r === "reset", { iScale: o, vScale: s, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: h } = this._getSharedOptions(n, r), d = o.axis, f = s.axis, { spanGaps: v, segment: g } = this.options, p = Ss(v) ? v : Number.POSITIVE_INFINITY, _ = this.chart._animationsDisabled || a || r === "none", m = n + i, y = t.length;
    let b = n > 0 && this.getParsed(n - 1);
    for (let x = 0; x < y; ++x) {
      const w = t[x], M = _ ? w : {};
      if (x < n || x >= m) {
        M.skip = !0;
        continue;
      }
      const D = this.getParsed(x), T = Dt(D[f]), C = M[d] = o.getPixelForValue(D[d], x), k = M[f] = a || T ? s.getBasePixel() : s.getPixelForValue(l ? this.applyStack(s, D, l) : D[f], x);
      M.skip = isNaN(C) || isNaN(k) || T, M.stop = x > 0 && Math.abs(D[d] - b[d]) > p, g && (M.parsed = D, M.raw = u.data[x]), h && (M.options = c || this.resolveDataElementOptions(x, w.active ? "active" : r)), _ || this.updateElement(w, x, M, r), b = D;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, n = t.dataset, i = n.options && n.options.borderWidth || 0, r = t.data || [];
    if (!r.length)
      return i;
    const a = r[0].size(this.resolveDataElementOptions(0)), o = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(i, a, o) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
class _D extends pD {
  static id = "pie";
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
}
function ur() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class hv {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(hv.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return ur();
  }
  parse() {
    return ur();
  }
  format() {
    return ur();
  }
  add() {
    return ur();
  }
  diff() {
    return ur();
  }
  startOf() {
    return ur();
  }
  endOf() {
    return ur();
  }
}
var mD = {
  _date: hv
};
function yD(e, t, n, i) {
  const { controller: r, data: a, _sorted: o } = e, s = r._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (s && t === s.axis && t !== "r" && o && a.length) {
    const u = s._reversePixels ? N2 : Vr;
    if (i) {
      if (r._sharedOptions) {
        const c = a[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const d = u(a, t, n - h), f = u(a, t, n + h);
          return {
            lo: d.lo,
            hi: f.hi
          };
        }
      }
    } else {
      const c = u(a, t, n);
      if (l) {
        const { vScale: h } = r._cachedMeta, { _parsed: d } = e, f = d.slice(0, c.lo + 1).reverse().findIndex((g) => !Dt(g[h.axis]));
        c.lo -= Math.max(0, f);
        const v = d.slice(c.hi).findIndex((g) => !Dt(g[h.axis]));
        c.hi += Math.max(0, v);
      }
      return c;
    }
  }
  return {
    lo: 0,
    hi: a.length - 1
  };
}
function _c(e, t, n, i, r) {
  const a = e.getSortedVisibleDatasetMetas(), o = n[t];
  for (let s = 0, l = a.length; s < l; ++s) {
    const { index: u, data: c } = a[s], { lo: h, hi: d } = yD(a[s], t, o, r);
    for (let f = h; f <= d; ++f) {
      const v = c[f];
      v.skip || i(v, u, f);
    }
  }
}
function bD(e) {
  const t = e.indexOf("x") !== -1, n = e.indexOf("y") !== -1;
  return function(i, r) {
    const a = t ? Math.abs(i.x - r.x) : 0, o = n ? Math.abs(i.y - r.y) : 0;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(o, 2));
  };
}
function rh(e, t, n, i, r) {
  const a = [];
  return !r && !e.isPointInArea(t) || _c(e, n, t, function(s, l, u) {
    !r && !Ds(s, e.chartArea, 0) || s.inRange(t.x, t.y, i) && a.push({
      element: s,
      datasetIndex: l,
      index: u
    });
  }, !0), a;
}
function xD(e, t, n, i) {
  let r = [];
  function a(o, s, l) {
    const { startAngle: u, endAngle: c } = o.getProps([
      "startAngle",
      "endAngle"
    ], i), { angle: h } = Ky(o, {
      x: t.x,
      y: t.y
    });
    Ms(h, u, c) && r.push({
      element: o,
      datasetIndex: s,
      index: l
    });
  }
  return _c(e, n, t, a), r;
}
function wD(e, t, n, i, r, a) {
  let o = [];
  const s = bD(n);
  let l = Number.POSITIVE_INFINITY;
  function u(c, h, d) {
    const f = c.inRange(t.x, t.y, r);
    if (i && !f)
      return;
    const v = c.getCenterPoint(r);
    if (!(!!a || e.isPointInArea(v)) && !f)
      return;
    const p = s(t, v);
    p < l ? (o = [
      {
        element: c,
        datasetIndex: h,
        index: d
      }
    ], l = p) : p === l && o.push({
      element: c,
      datasetIndex: h,
      index: d
    });
  }
  return _c(e, n, t, u), o;
}
function ah(e, t, n, i, r, a) {
  return !a && !e.isPointInArea(t) ? [] : n === "r" && !i ? xD(e, t, n, r) : wD(e, t, n, i, r, a);
}
function Mg(e, t, n, i, r) {
  const a = [], o = n === "x" ? "inXRange" : "inYRange";
  let s = !1;
  return _c(e, n, t, (l, u, c) => {
    l[o] && l[o](t[n], r) && (a.push({
      element: l,
      datasetIndex: u,
      index: c
    }), s = s || l.inRange(t.x, t.y, r));
  }), i && !s ? [] : a;
}
var SD = {
  modes: {
    index(e, t, n, i) {
      const r = Rr(t, e), a = n.axis || "x", o = n.includeInvisible || !1, s = n.intersect ? rh(e, r, a, i, o) : ah(e, r, a, !1, i, o), l = [];
      return s.length ? (e.getSortedVisibleDatasetMetas().forEach((u) => {
        const c = s[0].index, h = u.data[c];
        h && !h.skip && l.push({
          element: h,
          datasetIndex: u.index,
          index: c
        });
      }), l) : [];
    },
    dataset(e, t, n, i) {
      const r = Rr(t, e), a = n.axis || "xy", o = n.includeInvisible || !1;
      let s = n.intersect ? rh(e, r, a, i, o) : ah(e, r, a, !1, i, o);
      if (s.length > 0) {
        const l = s[0].datasetIndex, u = e.getDatasetMeta(l).data;
        s = [];
        for (let c = 0; c < u.length; ++c)
          s.push({
            element: u[c],
            datasetIndex: l,
            index: c
          });
      }
      return s;
    },
    point(e, t, n, i) {
      const r = Rr(t, e), a = n.axis || "xy", o = n.includeInvisible || !1;
      return rh(e, r, a, i, o);
    },
    nearest(e, t, n, i) {
      const r = Rr(t, e), a = n.axis || "xy", o = n.includeInvisible || !1;
      return ah(e, r, a, n.intersect, i, o);
    },
    x(e, t, n, i) {
      const r = Rr(t, e);
      return Mg(e, r, "x", n.intersect, i);
    },
    y(e, t, n, i) {
      const r = Rr(t, e);
      return Mg(e, r, "y", n.intersect, i);
    }
  }
};
const yb = [
  "left",
  "top",
  "right",
  "bottom"
];
function bo(e, t) {
  return e.filter((n) => n.pos === t);
}
function Dg(e, t) {
  return e.filter((n) => yb.indexOf(n.pos) === -1 && n.box.axis === t);
}
function xo(e, t) {
  return e.sort((n, i) => {
    const r = t ? i : n, a = t ? n : i;
    return r.weight === a.weight ? r.index - a.index : r.weight - a.weight;
  });
}
function MD(e) {
  const t = [];
  let n, i, r, a, o, s;
  for (n = 0, i = (e || []).length; n < i; ++n)
    r = e[n], { position: a, options: { stack: o, stackWeight: s = 1 } } = r, t.push({
      index: n,
      box: r,
      pos: a,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: o && a + o,
      stackWeight: s
    });
  return t;
}
function DD(e) {
  const t = {};
  for (const n of e) {
    const { stack: i, pos: r, stackWeight: a } = n;
    if (!i || !yb.includes(r))
      continue;
    const o = t[i] || (t[i] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    o.count++, o.weight += a;
  }
  return t;
}
function TD(e, t) {
  const n = DD(e), { vBoxMaxWidth: i, hBoxMaxHeight: r } = t;
  let a, o, s;
  for (a = 0, o = e.length; a < o; ++a) {
    s = e[a];
    const { fullSize: l } = s.box, u = n[s.stack], c = u && s.stackWeight / u.weight;
    s.horizontal ? (s.width = c ? c * i : l && t.availableWidth, s.height = r) : (s.width = i, s.height = c ? c * r : l && t.availableHeight);
  }
  return n;
}
function kD(e) {
  const t = MD(e), n = xo(t.filter((u) => u.box.fullSize), !0), i = xo(bo(t, "left"), !0), r = xo(bo(t, "right")), a = xo(bo(t, "top"), !0), o = xo(bo(t, "bottom")), s = Dg(t, "x"), l = Dg(t, "y");
  return {
    fullSize: n,
    leftAndTop: i.concat(a),
    rightAndBottom: r.concat(l).concat(o).concat(s),
    chartArea: bo(t, "chartArea"),
    vertical: i.concat(r).concat(l),
    horizontal: a.concat(o).concat(s)
  };
}
function Tg(e, t, n, i) {
  return Math.max(e[n], t[n]) + Math.max(e[i], t[i]);
}
function bb(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function CD(e, t, n, i) {
  const { pos: r, box: a } = n, o = e.maxPadding;
  if (!dt(r)) {
    n.size && (e[r] -= n.size);
    const h = i[n.stack] || {
      size: 0,
      count: 1
    };
    h.size = Math.max(h.size, n.horizontal ? a.height : a.width), n.size = h.size / h.count, e[r] += n.size;
  }
  a.getPadding && bb(o, a.getPadding());
  const s = Math.max(0, t.outerWidth - Tg(o, e, "left", "right")), l = Math.max(0, t.outerHeight - Tg(o, e, "top", "bottom")), u = s !== e.w, c = l !== e.h;
  return e.w = s, e.h = l, n.horizontal ? {
    same: u,
    other: c
  } : {
    same: c,
    other: u
  };
}
function PD(e) {
  const t = e.maxPadding;
  function n(i) {
    const r = Math.max(t[i] - e[i], 0);
    return e[i] += r, r;
  }
  e.y += n("top"), e.x += n("left"), n("right"), n("bottom");
}
function AD(e, t) {
  const n = t.maxPadding;
  function i(r) {
    const a = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((o) => {
      a[o] = Math.max(t[o], n[o]);
    }), a;
  }
  return i(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function qo(e, t, n, i) {
  const r = [];
  let a, o, s, l, u, c;
  for (a = 0, o = e.length, u = 0; a < o; ++a) {
    s = e[a], l = s.box, l.update(s.width || t.w, s.height || t.h, AD(s.horizontal, t));
    const { same: h, other: d } = CD(t, n, s, i);
    u |= h && r.length, c = c || d, l.fullSize || r.push(s);
  }
  return u && qo(r, t, n, i) || c;
}
function ll(e, t, n, i, r) {
  e.top = n, e.left = t, e.right = t + i, e.bottom = n + r, e.width = i, e.height = r;
}
function kg(e, t, n, i) {
  const r = n.padding;
  let { x: a, y: o } = t;
  for (const s of e) {
    const l = s.box, u = i[s.stack] || {
      placed: 0,
      weight: 1
    }, c = s.stackWeight / u.weight || 1;
    if (s.horizontal) {
      const h = t.w * c, d = u.size || l.height;
      ws(u.start) && (o = u.start), l.fullSize ? ll(l, r.left, o, n.outerWidth - r.right - r.left, d) : ll(l, t.left + u.placed, o, h, d), u.start = o, u.placed += h, o = l.bottom;
    } else {
      const h = t.h * c, d = u.size || l.width;
      ws(u.start) && (a = u.start), l.fullSize ? ll(l, a, r.top, d, n.outerHeight - r.bottom - r.top) : ll(l, a, t.top + u.placed, d, h), u.start = a, u.placed += h, a = l.right;
    }
  }
  t.x = a, t.y = o;
}
var fn = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(n) {
            t.draw(n);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const n = e.boxes ? e.boxes.indexOf(t) : -1;
    n !== -1 && e.boxes.splice(n, 1);
  },
  configure(e, t, n) {
    t.fullSize = n.fullSize, t.position = n.position, t.weight = n.weight;
  },
  update(e, t, n, i) {
    if (!e)
      return;
    const r = pn(e.options.layout.padding), a = Math.max(t - r.width, 0), o = Math.max(n - r.height, 0), s = kD(e.boxes), l = s.vertical, u = s.horizontal;
    kt(e.boxes, (g) => {
      typeof g.beforeLayout == "function" && g.beforeLayout();
    });
    const c = l.reduce((g, p) => p.box.options && p.box.options.display === !1 ? g : g + 1, 0) || 1, h = Object.freeze({
      outerWidth: t,
      outerHeight: n,
      padding: r,
      availableWidth: a,
      availableHeight: o,
      vBoxMaxWidth: a / 2 / c,
      hBoxMaxHeight: o / 2
    }), d = Object.assign({}, r);
    bb(d, pn(i));
    const f = Object.assign({
      maxPadding: d,
      w: a,
      h: o,
      x: r.left,
      y: r.top
    }, r), v = TD(l.concat(u), h);
    qo(s.fullSize, f, h, v), qo(l, f, h, v), qo(u, f, h, v) && qo(l, f, h, v), PD(f), kg(s.leftAndTop, f, h, v), f.x += f.w, f.y += f.h, kg(s.rightAndBottom, f, h, v), e.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, kt(s.chartArea, (g) => {
      const p = g.box;
      Object.assign(p, e.chartArea), p.update(f.w, f.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class xb {
  acquireContext(t, n) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, n, i) {
  }
  removeEventListener(t, n, i) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, n, i, r) {
    return n = Math.max(0, n || t.width), i = i || t.height, {
      width: n,
      height: Math.max(0, r ? Math.floor(n / r) : i)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class ED extends xb {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const Jl = "$chartjs", LD = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Cg = (e) => e === null || e === "";
function OD(e, t) {
  const n = e.style, i = e.getAttribute("height"), r = e.getAttribute("width");
  if (e[Jl] = {
    initial: {
      height: i,
      width: r,
      style: {
        display: n.display,
        height: n.height,
        width: n.width
      }
    }
  }, n.display = n.display || "block", n.boxSizing = n.boxSizing || "border-box", Cg(r)) {
    const a = hg(e, "width");
    a !== void 0 && (e.width = a);
  }
  if (Cg(i))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const a = hg(e, "height");
      a !== void 0 && (e.height = a);
    }
  return e;
}
const wb = EM ? {
  passive: !0
} : !1;
function ID(e, t, n) {
  e && e.addEventListener(t, n, wb);
}
function RD(e, t, n) {
  e && e.canvas && e.canvas.removeEventListener(t, n, wb);
}
function ND(e, t) {
  const n = LD[e.type] || e.type, { x: i, y: r } = Rr(e, t);
  return {
    type: n,
    chart: t,
    native: e,
    x: i !== void 0 ? i : null,
    y: r !== void 0 ? r : null
  };
}
function wu(e, t) {
  for (const n of e)
    if (n === t || n.contains(t))
      return !0;
}
function FD(e, t, n) {
  const i = e.canvas, r = new MutationObserver((a) => {
    let o = !1;
    for (const s of a)
      o = o || wu(s.addedNodes, i), o = o && !wu(s.removedNodes, i);
    o && n();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function BD(e, t, n) {
  const i = e.canvas, r = new MutationObserver((a) => {
    let o = !1;
    for (const s of a)
      o = o || wu(s.removedNodes, i), o = o && !wu(s.addedNodes, i);
    o && n();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const ks = /* @__PURE__ */ new Map();
let Pg = 0;
function Sb() {
  const e = window.devicePixelRatio;
  e !== Pg && (Pg = e, ks.forEach((t, n) => {
    n.currentDevicePixelRatio !== e && t();
  }));
}
function zD(e, t) {
  ks.size || window.addEventListener("resize", Sb), ks.set(e, t);
}
function VD(e) {
  ks.delete(e), ks.size || window.removeEventListener("resize", Sb);
}
function $D(e, t, n) {
  const i = e.canvas, r = i && cv(i);
  if (!r)
    return;
  const a = eb((s, l) => {
    const u = r.clientWidth;
    n(s, l), u < r.clientWidth && n();
  }, window), o = new ResizeObserver((s) => {
    const l = s[0], u = l.contentRect.width, c = l.contentRect.height;
    u === 0 && c === 0 || a(u, c);
  });
  return o.observe(r), zD(e, a), o;
}
function oh(e, t, n) {
  n && n.disconnect(), t === "resize" && VD(e);
}
function HD(e, t, n) {
  const i = e.canvas, r = eb((a) => {
    e.ctx !== null && n(ND(a, e));
  }, e);
  return ID(i, t, r), r;
}
class YD extends xb {
  acquireContext(t, n) {
    const i = t && t.getContext && t.getContext("2d");
    return i && i.canvas === t ? (OD(t, n), i) : null;
  }
  releaseContext(t) {
    const n = t.canvas;
    if (!n[Jl])
      return !1;
    const i = n[Jl].initial;
    [
      "height",
      "width"
    ].forEach((a) => {
      const o = i[a];
      Dt(o) ? n.removeAttribute(a) : n.setAttribute(a, o);
    });
    const r = i.style || {};
    return Object.keys(r).forEach((a) => {
      n.style[a] = r[a];
    }), n.width = n.width, delete n[Jl], !0;
  }
  addEventListener(t, n, i) {
    this.removeEventListener(t, n);
    const r = t.$proxies || (t.$proxies = {}), o = {
      attach: FD,
      detach: BD,
      resize: $D
    }[n] || HD;
    r[n] = o(t, n, i);
  }
  removeEventListener(t, n) {
    const i = t.$proxies || (t.$proxies = {}), r = i[n];
    if (!r)
      return;
    ({
      attach: oh,
      detach: oh,
      resize: oh
    }[n] || RD)(t, n, r), i[n] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, n, i, r) {
    return AM(t, n, i, r);
  }
  isAttached(t) {
    const n = t && cv(t);
    return !!(n && n.isConnected);
  }
}
function WD(e) {
  return !uv() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? ED : YD;
}
let Ci = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: n, y: i } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: i
    };
  }
  hasValue() {
    return Ss(this.x) && Ss(this.y);
  }
  getProps(t, n) {
    const i = this.$animations;
    if (!n || !i)
      return this;
    const r = {};
    return t.forEach((a) => {
      r[a] = i[a] && i[a].active() ? i[a]._to : this[a];
    }), r;
  }
};
function UD(e, t) {
  const n = e.options.ticks, i = GD(e), r = Math.min(n.maxTicksLimit || i, i), a = n.major.enabled ? XD(t) : [], o = a.length, s = a[0], l = a[o - 1], u = [];
  if (o > r)
    return qD(t, u, a, o / r), u;
  const c = jD(a, t, r);
  if (o > 0) {
    let h, d;
    const f = o > 1 ? Math.round((l - s) / (o - 1)) : null;
    for (ul(t, u, c, Dt(f) ? 0 : s - f, s), h = 0, d = o - 1; h < d; h++)
      ul(t, u, c, a[h], a[h + 1]);
    return ul(t, u, c, l, Dt(f) ? t.length : l + f), u;
  }
  return ul(t, u, c), u;
}
function GD(e) {
  const t = e.options.offset, n = e._tickSize(), i = e._length / n + (t ? 0 : 1), r = e._maxLength / n;
  return Math.floor(Math.min(i, r));
}
function jD(e, t, n) {
  const i = ZD(e), r = t.length / n;
  if (!i)
    return Math.max(r, 1);
  const a = P2(i);
  for (let o = 0, s = a.length - 1; o < s; o++) {
    const l = a[o];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function XD(e) {
  const t = [];
  let n, i;
  for (n = 0, i = e.length; n < i; n++)
    e[n].major && t.push(n);
  return t;
}
function qD(e, t, n, i) {
  let r = 0, a = n[0], o;
  for (i = Math.ceil(i), o = 0; o < e.length; o++)
    o === a && (t.push(e[o]), r++, a = n[r * i]);
}
function ul(e, t, n, i, r) {
  const a = ot(i, 0), o = Math.min(ot(r, e.length), e.length);
  let s = 0, l, u, c;
  for (n = Math.ceil(n), r && (l = r - i, n = l / Math.floor(l / n)), c = a; c < 0; )
    s++, c = Math.round(a + s * n);
  for (u = Math.max(a, 0); u < o; u++)
    u === c && (t.push(e[u]), s++, c = Math.round(a + s * n));
}
function ZD(e) {
  const t = e.length;
  let n, i;
  if (t < 2)
    return !1;
  for (i = e[0], n = 1; n < t; ++n)
    if (e[n] - e[n - 1] !== i)
      return !1;
  return i;
}
const KD = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Ag = (e, t, n) => t === "top" || t === "left" ? e[t] + n : e[t] - n, Eg = (e, t) => Math.min(t || e, e);
function Lg(e, t) {
  const n = [], i = e.length / t, r = e.length;
  let a = 0;
  for (; a < r; a += i)
    n.push(e[Math.floor(a)]);
  return n;
}
function QD(e, t, n) {
  const i = e.ticks.length, r = Math.min(t, i - 1), a = e._startPixel, o = e._endPixel, s = 1e-6;
  let l = e.getPixelForTick(r), u;
  if (!(n && (i === 1 ? u = Math.max(l - a, o - l) : t === 0 ? u = (e.getPixelForTick(1) - l) / 2 : u = (l - e.getPixelForTick(r - 1)) / 2, l += r < t ? u : -u, l < a - s || l > o + s)))
    return l;
}
function JD(e, t) {
  kt(e, (n) => {
    const i = n.gc, r = i.length / 2;
    let a;
    if (r > t) {
      for (a = 0; a < r; ++a)
        delete n.data[i[a]];
      i.splice(0, r);
    }
  });
}
function wo(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function Og(e, t) {
  if (!e.display)
    return 0;
  const n = me(e.font, t), i = pn(e.padding);
  return (ie(e.text) ? e.text.length : 1) * n.lineHeight + i.height;
}
function tT(e, t) {
  return la(e, {
    scale: t,
    type: "scale"
  });
}
function eT(e, t, n) {
  return la(e, {
    tick: n,
    index: t,
    type: "tick"
  });
}
function nT(e, t, n) {
  let i = nv(e);
  return (n && t !== "right" || !n && t === "right") && (i = KD(i)), i;
}
function iT(e, t, n, i) {
  const { top: r, left: a, bottom: o, right: s, chart: l } = e, { chartArea: u, scales: c } = l;
  let h = 0, d, f, v;
  const g = o - r, p = s - a;
  if (e.isHorizontal()) {
    if (f = pe(i, a, s), dt(n)) {
      const _ = Object.keys(n)[0], m = n[_];
      v = c[_].getPixelForValue(m) + g - t;
    } else n === "center" ? v = (u.bottom + u.top) / 2 + g - t : v = Ag(e, n, t);
    d = s - a;
  } else {
    if (dt(n)) {
      const _ = Object.keys(n)[0], m = n[_];
      f = c[_].getPixelForValue(m) - p + t;
    } else n === "center" ? f = (u.left + u.right) / 2 - p + t : f = Ag(e, n, t);
    v = pe(i, o, r), h = n === "left" ? -se : se;
  }
  return {
    titleX: f,
    titleY: v,
    maxWidth: d,
    rotation: h
  };
}
class lo extends Ci {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, n) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: n, _suggestedMin: i, _suggestedMax: r } = this;
    return t = Rn(t, Number.POSITIVE_INFINITY), n = Rn(n, Number.NEGATIVE_INFINITY), i = Rn(i, Number.POSITIVE_INFINITY), r = Rn(r, Number.NEGATIVE_INFINITY), {
      min: Rn(t, i),
      max: Rn(n, r),
      minDefined: we(t),
      maxDefined: we(n)
    };
  }
  getMinMax(t) {
    let { min: n, max: i, minDefined: r, maxDefined: a } = this.getUserBounds(), o;
    if (r && a)
      return {
        min: n,
        max: i
      };
    const s = this.getMatchingVisibleMetas();
    for (let l = 0, u = s.length; l < u; ++l)
      o = s[l].controller.getMinMax(this, t), r || (n = Math.min(n, o.min)), a || (i = Math.max(i, o.max));
    return n = a && n > i ? i : n, i = r && n > i ? n : i, {
      min: Rn(n, Rn(i, n)),
      max: Rn(i, Rn(n, i))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    Nt(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, n, i) {
    const { beginAtZero: r, grace: a, ticks: o } = this.options, s = o.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = n, this._margins = i = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, i), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + i.left + i.right : this.height + i.top + i.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = lM(this, a, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = s < this.ticks.length;
    this._convertTicksToLabels(l ? Lg(this.ticks, s) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), o.display && (o.autoSkip || o.source === "auto") && (this.ticks = UD(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, n, i;
    this.isHorizontal() ? (n = this.left, i = this.right) : (n = this.top, i = this.bottom, t = !t), this._startPixel = n, this._endPixel = i, this._reversePixels = t, this._length = i - n, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    Nt(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    Nt(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    Nt(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), Nt(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    Nt(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const n = this.options.ticks;
    let i, r, a;
    for (i = 0, r = t.length; i < r; i++)
      a = t[i], a.label = Nt(n.callback, [
        a.value,
        i,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    Nt(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    Nt(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, n = t.ticks, i = Eg(this.ticks.length, t.ticks.maxTicksLimit), r = n.minRotation || 0, a = n.maxRotation;
    let o = r, s, l, u;
    if (!this._isVisible() || !n.display || r >= a || i <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const c = this._getLabelSizes(), h = c.widest.width, d = c.highest.height, f = _e(this.chart.width - h, 0, this.maxWidth);
    s = t.offset ? this.maxWidth / i : f / (i - 1), h + 6 > s && (s = f / (i - (t.offset ? 0.5 : 1)), l = this.maxHeight - wo(t.grid) - n.padding - Og(t.title, this.chart.options.font), u = Math.sqrt(h * h + d * d), o = O2(Math.min(Math.asin(_e((c.highest.height + 6) / s, -1, 1)), Math.asin(_e(l / u, -1, 1)) - Math.asin(_e(d / u, -1, 1)))), o = Math.max(r, Math.min(a, o))), this.labelRotation = o;
  }
  afterCalculateLabelRotation() {
    Nt(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    Nt(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: n, options: { ticks: i, title: r, grid: a } } = this, o = this._isVisible(), s = this.isHorizontal();
    if (o) {
      const l = Og(r, n.options.font);
      if (s ? (t.width = this.maxWidth, t.height = wo(a) + l) : (t.height = this.maxHeight, t.width = wo(a) + l), i.display && this.ticks.length) {
        const { first: u, last: c, widest: h, highest: d } = this._getLabelSizes(), f = i.padding * 2, v = vi(this.labelRotation), g = Math.cos(v), p = Math.sin(v);
        if (s) {
          const _ = i.mirror ? 0 : p * h.width + g * d.height;
          t.height = Math.min(this.maxHeight, t.height + _ + f);
        } else {
          const _ = i.mirror ? 0 : g * h.width + p * d.height;
          t.width = Math.min(this.maxWidth, t.width + _ + f);
        }
        this._calculatePadding(u, c, p, g);
      }
    }
    this._handleMargins(), s ? (this.width = this._length = n.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = n.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, n, i, r) {
    const { ticks: { align: a, padding: o }, position: s } = this.options, l = this.labelRotation !== 0, u = s !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);
      let d = 0, f = 0;
      l ? u ? (d = r * t.width, f = i * n.height) : (d = i * t.height, f = r * n.width) : a === "start" ? f = n.width : a === "end" ? d = t.width : a !== "inner" && (d = t.width / 2, f = n.width / 2), this.paddingLeft = Math.max((d - c + o) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - h + o) * this.width / (this.width - h), 0);
    } else {
      let c = n.height / 2, h = t.height / 2;
      a === "start" ? (c = 0, h = t.height) : a === "end" && (c = n.height, h = 0), this.paddingTop = c + o, this.paddingBottom = h + o;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    Nt(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: n } = this.options;
    return n === "top" || n === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let n, i;
    for (n = 0, i = t.length; n < i; n++)
      Dt(t[n].label) && (t.splice(n, 1), i--, n--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const n = this.options.ticks.sampleSize;
      let i = this.ticks;
      n < i.length && (i = Lg(i, n)), this._labelSizes = t = this._computeLabelSizes(i, i.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, n, i) {
    const { ctx: r, _longestTextCache: a } = this, o = [], s = [], l = Math.floor(n / Eg(n, i));
    let u = 0, c = 0, h, d, f, v, g, p, _, m, y, b, x;
    for (h = 0; h < n; h += l) {
      if (v = t[h].label, g = this._resolveTickFontOptions(h), r.font = p = g.string, _ = a[p] = a[p] || {
        data: {},
        gc: []
      }, m = g.lineHeight, y = b = 0, !Dt(v) && !ie(v))
        y = og(r, _.data, _.gc, y, v), b = m;
      else if (ie(v))
        for (d = 0, f = v.length; d < f; ++d)
          x = v[d], !Dt(x) && !ie(x) && (y = og(r, _.data, _.gc, y, x), b += m);
      o.push(y), s.push(b), u = Math.max(y, u), c = Math.max(b, c);
    }
    JD(a, n);
    const w = o.indexOf(u), M = s.indexOf(c), D = (T) => ({
      width: o[T] || 0,
      height: s[T] || 0
    });
    return {
      first: D(0),
      last: D(n - 1),
      widest: D(w),
      highest: D(M),
      widths: o,
      heights: s
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, n) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const n = this._startPixel + t * this._length;
    return R2(this._alignToPixels ? lr(this.chart, n, 0) : n);
  }
  getDecimalForPixel(t) {
    const n = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - n : n;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: n } = this;
    return t < 0 && n < 0 ? n : t > 0 && n > 0 ? t : 0;
  }
  getContext(t) {
    const n = this.ticks || [];
    if (t >= 0 && t < n.length) {
      const i = n[t];
      return i.$context || (i.$context = eT(this.getContext(), t, i));
    }
    return this.$context || (this.$context = tT(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, n = vi(this.labelRotation), i = Math.abs(Math.cos(n)), r = Math.abs(Math.sin(n)), a = this._getLabelSizes(), o = t.autoSkipPadding || 0, s = a ? a.widest.width + o : 0, l = a ? a.highest.height + o : 0;
    return this.isHorizontal() ? l * i > s * r ? s / i : l / r : l * r < s * i ? l / i : s / r;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const n = this.axis, i = this.chart, r = this.options, { grid: a, position: o, border: s } = r, l = a.offset, u = this.isHorizontal(), h = this.ticks.length + (l ? 1 : 0), d = wo(a), f = [], v = s.setContext(this.getContext()), g = v.display ? v.width : 0, p = g / 2, _ = function(N) {
      return lr(i, N, g);
    };
    let m, y, b, x, w, M, D, T, C, k, E, A;
    if (o === "top")
      m = _(this.bottom), M = this.bottom - d, T = m - p, k = _(t.top) + p, A = t.bottom;
    else if (o === "bottom")
      m = _(this.top), k = t.top, A = _(t.bottom) - p, M = m + p, T = this.top + d;
    else if (o === "left")
      m = _(this.right), w = this.right - d, D = m - p, C = _(t.left) + p, E = t.right;
    else if (o === "right")
      m = _(this.left), C = t.left, E = _(t.right) - p, w = m + p, D = this.left + d;
    else if (n === "x") {
      if (o === "center")
        m = _((t.top + t.bottom) / 2 + 0.5);
      else if (dt(o)) {
        const N = Object.keys(o)[0], V = o[N];
        m = _(this.chart.scales[N].getPixelForValue(V));
      }
      k = t.top, A = t.bottom, M = m + p, T = M + d;
    } else if (n === "y") {
      if (o === "center")
        m = _((t.left + t.right) / 2);
      else if (dt(o)) {
        const N = Object.keys(o)[0], V = o[N];
        m = _(this.chart.scales[N].getPixelForValue(V));
      }
      w = m - p, D = w - d, C = t.left, E = t.right;
    }
    const L = ot(r.ticks.maxTicksLimit, h), R = Math.max(1, Math.ceil(h / L));
    for (y = 0; y < h; y += R) {
      const N = this.getContext(y), V = a.setContext(N), q = s.setContext(N), W = V.lineWidth, Z = V.color, bt = q.dash || [], et = q.dashOffset, at = V.tickWidth, ht = V.tickColor, Ht = V.tickBorderDash || [], Rt = V.tickBorderDashOffset;
      b = QD(this, y, l), b !== void 0 && (x = lr(i, b, W), u ? w = D = C = E = x : M = T = k = A = x, f.push({
        tx1: w,
        ty1: M,
        tx2: D,
        ty2: T,
        x1: C,
        y1: k,
        x2: E,
        y2: A,
        width: W,
        color: Z,
        borderDash: bt,
        borderDashOffset: et,
        tickWidth: at,
        tickColor: ht,
        tickBorderDash: Ht,
        tickBorderDashOffset: Rt
      }));
    }
    return this._ticksLength = h, this._borderValue = m, f;
  }
  _computeLabelItems(t) {
    const n = this.axis, i = this.options, { position: r, ticks: a } = i, o = this.isHorizontal(), s = this.ticks, { align: l, crossAlign: u, padding: c, mirror: h } = a, d = wo(i.grid), f = d + c, v = h ? -c : f, g = -vi(this.labelRotation), p = [];
    let _, m, y, b, x, w, M, D, T, C, k, E, A = "middle";
    if (r === "top")
      w = this.bottom - v, M = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      w = this.top + v, M = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const R = this._getYAxisLabelAlignment(d);
      M = R.textAlign, x = R.x;
    } else if (r === "right") {
      const R = this._getYAxisLabelAlignment(d);
      M = R.textAlign, x = R.x;
    } else if (n === "x") {
      if (r === "center")
        w = (t.top + t.bottom) / 2 + f;
      else if (dt(r)) {
        const R = Object.keys(r)[0], N = r[R];
        w = this.chart.scales[R].getPixelForValue(N) + f;
      }
      M = this._getXAxisLabelAlignment();
    } else if (n === "y") {
      if (r === "center")
        x = (t.left + t.right) / 2 - f;
      else if (dt(r)) {
        const R = Object.keys(r)[0], N = r[R];
        x = this.chart.scales[R].getPixelForValue(N);
      }
      M = this._getYAxisLabelAlignment(d).textAlign;
    }
    n === "y" && (l === "start" ? A = "top" : l === "end" && (A = "bottom"));
    const L = this._getLabelSizes();
    for (_ = 0, m = s.length; _ < m; ++_) {
      y = s[_], b = y.label;
      const R = a.setContext(this.getContext(_));
      D = this.getPixelForTick(_) + a.labelOffset, T = this._resolveTickFontOptions(_), C = T.lineHeight, k = ie(b) ? b.length : 1;
      const N = k / 2, V = R.color, q = R.textStrokeColor, W = R.textStrokeWidth;
      let Z = M;
      o ? (x = D, M === "inner" && (_ === m - 1 ? Z = this.options.reverse ? "left" : "right" : _ === 0 ? Z = this.options.reverse ? "right" : "left" : Z = "center"), r === "top" ? u === "near" || g !== 0 ? E = -k * C + C / 2 : u === "center" ? E = -L.highest.height / 2 - N * C + C : E = -L.highest.height + C / 2 : u === "near" || g !== 0 ? E = C / 2 : u === "center" ? E = L.highest.height / 2 - N * C : E = L.highest.height - k * C, h && (E *= -1), g !== 0 && !R.showLabelBackdrop && (x += C / 2 * Math.sin(g))) : (w = D, E = (1 - k) * C / 2);
      let bt;
      if (R.showLabelBackdrop) {
        const et = pn(R.backdropPadding), at = L.heights[_], ht = L.widths[_];
        let Ht = E - et.top, Rt = 0 - et.left;
        switch (A) {
          case "middle":
            Ht -= at / 2;
            break;
          case "bottom":
            Ht -= at;
            break;
        }
        switch (M) {
          case "center":
            Rt -= ht / 2;
            break;
          case "right":
            Rt -= ht;
            break;
          case "inner":
            _ === m - 1 ? Rt -= ht : _ > 0 && (Rt -= ht / 2);
            break;
        }
        bt = {
          left: Rt,
          top: Ht,
          width: ht + et.width,
          height: at + et.height,
          color: R.backdropColor
        };
      }
      p.push({
        label: b,
        font: T,
        textOffset: E,
        options: {
          rotation: g,
          color: V,
          strokeColor: q,
          strokeWidth: W,
          textAlign: Z,
          textBaseline: A,
          translation: [
            x,
            w
          ],
          backdrop: bt
        }
      });
    }
    return p;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: n } = this.options;
    if (-vi(this.labelRotation))
      return t === "top" ? "left" : "right";
    let r = "center";
    return n.align === "start" ? r = "left" : n.align === "end" ? r = "right" : n.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(t) {
    const { position: n, ticks: { crossAlign: i, mirror: r, padding: a } } = this.options, o = this._getLabelSizes(), s = t + a, l = o.widest.width;
    let u, c;
    return n === "left" ? r ? (c = this.right + a, i === "near" ? u = "left" : i === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - s, i === "near" ? u = "right" : i === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : n === "right" ? r ? (c = this.left + a, i === "near" ? u = "right" : i === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + s, i === "near" ? u = "left" : i === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", {
      textAlign: u,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, n = this.options.position;
    if (n === "left" || n === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (n === "top" || n === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: n }, left: i, top: r, width: a, height: o } = this;
    n && (t.save(), t.fillStyle = n, t.fillRect(i, r, a, o), t.restore());
  }
  getLineWidthForValue(t) {
    const n = this.options.grid;
    if (!this._isVisible() || !n.display)
      return 0;
    const r = this.ticks.findIndex((a) => a.value === t);
    return r >= 0 ? n.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(t) {
    const n = this.options.grid, i = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let a, o;
    const s = (l, u, c) => {
      !c.width || !c.color || (i.save(), i.lineWidth = c.width, i.strokeStyle = c.color, i.setLineDash(c.borderDash || []), i.lineDashOffset = c.borderDashOffset, i.beginPath(), i.moveTo(l.x, l.y), i.lineTo(u.x, u.y), i.stroke(), i.restore());
    };
    if (n.display)
      for (a = 0, o = r.length; a < o; ++a) {
        const l = r[a];
        n.drawOnChartArea && s({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), n.drawTicks && s({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: n, options: { border: i, grid: r } } = this, a = i.setContext(this.getContext()), o = i.display ? a.width : 0;
    if (!o)
      return;
    const s = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let u, c, h, d;
    this.isHorizontal() ? (u = lr(t, this.left, o) - o / 2, c = lr(t, this.right, s) + s / 2, h = d = l) : (h = lr(t, this.top, o) - o / 2, d = lr(t, this.bottom, s) + s / 2, u = c = l), n.save(), n.lineWidth = a.width, n.strokeStyle = a.color, n.beginPath(), n.moveTo(u, h), n.lineTo(c, d), n.stroke(), n.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const i = this.ctx, r = this._computeLabelArea();
    r && fc(i, r);
    const a = this.getLabelItems(t);
    for (const o of a) {
      const s = o.options, l = o.font, u = o.label, c = o.textOffset;
      Ts(i, u, 0, c, l, s);
    }
    r && vc(i);
  }
  drawTitle() {
    const { ctx: t, options: { position: n, title: i, reverse: r } } = this;
    if (!i.display)
      return;
    const a = me(i.font), o = pn(i.padding), s = i.align;
    let l = a.lineHeight / 2;
    n === "bottom" || n === "center" || dt(n) ? (l += o.bottom, ie(i.text) && (l += a.lineHeight * (i.text.length - 1))) : l += o.top;
    const { titleX: u, titleY: c, maxWidth: h, rotation: d } = iT(this, l, n, s);
    Ts(t, i.text, 0, 0, a, {
      color: i.color,
      maxWidth: h,
      rotation: d,
      textAlign: nT(s, n, r),
      textBaseline: "middle",
      translation: [
        u,
        c
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, n = t.ticks && t.ticks.z || 0, i = ot(t.grid && t.grid.z, -1), r = ot(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== lo.prototype.draw ? [
      {
        z: n,
        draw: (a) => {
          this.draw(a);
        }
      }
    ] : [
      {
        z: i,
        draw: (a) => {
          this.drawBackground(), this.drawGrid(a), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: n,
        draw: (a) => {
          this.drawLabels(a);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const n = this.chart.getSortedVisibleDatasetMetas(), i = this.axis + "AxisID", r = [];
    let a, o;
    for (a = 0, o = n.length; a < o; ++a) {
      const s = n[a];
      s[i] === this.id && (!t || s.type === t) && r.push(s);
    }
    return r;
  }
  _resolveTickFontOptions(t) {
    const n = this.options.ticks.setContext(this.getContext(t));
    return me(n.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class cl {
  constructor(t, n, i) {
    this.type = t, this.scope = n, this.override = i, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const n = Object.getPrototypeOf(t);
    let i;
    oT(n) && (i = this.register(n));
    const r = this.items, a = t.id, o = this.scope + "." + a;
    if (!a)
      throw new Error("class does not have id: " + t);
    return a in r || (r[a] = t, rT(t, o, i), this.override && ee.override(t.id, t.overrides)), o;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const n = this.items, i = t.id, r = this.scope;
    i in n && delete n[i], r && i in ee[r] && (delete ee[r][i], this.override && delete aa[i]);
  }
}
function rT(e, t, n) {
  const i = xs(/* @__PURE__ */ Object.create(null), [
    n ? ee.get(n) : {},
    ee.get(t),
    e.defaults
  ]);
  ee.set(t, i), e.defaultRoutes && aT(t, e.defaultRoutes), e.descriptors && ee.describe(t, e.descriptors);
}
function aT(e, t) {
  Object.keys(t).forEach((n) => {
    const i = n.split("."), r = i.pop(), a = [
      e
    ].concat(i).join("."), o = t[n].split("."), s = o.pop(), l = o.join(".");
    ee.route(a, r, l, s);
  });
}
function oT(e) {
  return "id" in e && "defaults" in e;
}
class sT {
  constructor() {
    this.controllers = new cl(gc, "datasets", !0), this.elements = new cl(Ci, "elements"), this.plugins = new cl(Object, "plugins"), this.scales = new cl(lo, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, n, i) {
    [
      ...n
    ].forEach((r) => {
      const a = i || this._getRegistryForType(r);
      i || a.isForType(r) || a === this.plugins && r.id ? this._exec(t, a, r) : kt(r, (o) => {
        const s = i || this._getRegistryForType(o);
        this._exec(t, s, o);
      });
    });
  }
  _exec(t, n, i) {
    const r = tv(t);
    Nt(i["before" + r], [], i), n[t](i), Nt(i["after" + r], [], i);
  }
  _getRegistryForType(t) {
    for (let n = 0; n < this._typedRegistries.length; n++) {
      const i = this._typedRegistries[n];
      if (i.isForType(t))
        return i;
    }
    return this.plugins;
  }
  _get(t, n, i) {
    const r = n.get(t);
    if (r === void 0)
      throw new Error('"' + t + '" is not a registered ' + i + ".");
    return r;
  }
}
var Hn = /* @__PURE__ */ new sT();
class lT {
  constructor() {
    this._init = void 0;
  }
  notify(t, n, i, r) {
    if (n === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")), this._init === void 0)
      return;
    const a = r ? this._descriptors(t).filter(r) : this._descriptors(t), o = this._notify(a, t, n, i);
    return n === "afterDestroy" && (this._notify(a, t, "stop"), this._notify(this._init, t, "uninstall"), this._init = void 0), o;
  }
  _notify(t, n, i, r) {
    r = r || {};
    for (const a of t) {
      const o = a.plugin, s = o[i], l = [
        n,
        r,
        a.options
      ];
      if (Nt(s, l, o) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    Dt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const n = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), n;
  }
  _createDescriptors(t, n) {
    const i = t && t.config, r = ot(i.options && i.options.plugins, {}), a = uT(i);
    return r === !1 && !n ? [] : hT(t, a, r, n);
  }
  _notifyStateChanges(t) {
    const n = this._oldCache || [], i = this._cache, r = (a, o) => a.filter((s) => !o.some((l) => s.plugin.id === l.plugin.id));
    this._notify(r(n, i), t, "stop"), this._notify(r(i, n), t, "start");
  }
}
function uT(e) {
  const t = {}, n = [], i = Object.keys(Hn.plugins.items);
  for (let a = 0; a < i.length; a++)
    n.push(Hn.getPlugin(i[a]));
  const r = e.plugins || [];
  for (let a = 0; a < r.length; a++) {
    const o = r[a];
    n.indexOf(o) === -1 && (n.push(o), t[o.id] = !0);
  }
  return {
    plugins: n,
    localIds: t
  };
}
function cT(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function hT(e, { plugins: t, localIds: n }, i, r) {
  const a = [], o = e.getContext();
  for (const s of t) {
    const l = s.id, u = cT(i[l], r);
    u !== null && a.push({
      plugin: s,
      options: dT(e.config, {
        plugin: s,
        local: n[l]
      }, u, o)
    });
  }
  return a;
}
function dT(e, { plugin: t, local: n }, i, r) {
  const a = e.pluginScopeKeys(t), o = e.getOptionScopes(i, a);
  return n && t.defaults && o.push(t.defaults), e.createResolver(o, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Bd(e, t) {
  const n = ee.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || n.indexAxis || "x";
}
function fT(e, t) {
  let n = e;
  return e === "_index_" ? n = t : e === "_value_" && (n = t === "x" ? "y" : "x"), n;
}
function vT(e, t) {
  return e === t ? "_index_" : "_value_";
}
function Ig(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function pT(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function zd(e, ...t) {
  if (Ig(e))
    return e;
  for (const n of t) {
    const i = n.axis || pT(n.position) || e.length > 1 && Ig(e[0].toLowerCase());
    if (i)
      return i;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function Rg(e, t, n) {
  if (n[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function gT(e, t) {
  if (t.data && t.data.datasets) {
    const n = t.data.datasets.filter((i) => i.xAxisID === e || i.yAxisID === e);
    if (n.length)
      return Rg(e, "x", n[0]) || Rg(e, "y", n[0]);
  }
  return {};
}
function _T(e, t) {
  const n = aa[e.type] || {
    scales: {}
  }, i = t.scales || {}, r = Bd(e.type, t), a = /* @__PURE__ */ Object.create(null);
  return Object.keys(i).forEach((o) => {
    const s = i[o];
    if (!dt(s))
      return console.error(`Invalid scale configuration for scale: ${o}`);
    if (s._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${o}`);
    const l = zd(o, s, gT(o, e), ee.scales[s.type]), u = vT(l, r), c = n.scales || {};
    a[o] = os(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      s,
      c[l],
      c[u]
    ]);
  }), e.data.datasets.forEach((o) => {
    const s = o.type || e.type, l = o.indexAxis || Bd(s, t), c = (aa[s] || {}).scales || {};
    Object.keys(c).forEach((h) => {
      const d = fT(h, l), f = o[d + "AxisID"] || d;
      a[f] = a[f] || /* @__PURE__ */ Object.create(null), os(a[f], [
        {
          axis: d
        },
        i[f],
        c[h]
      ]);
    });
  }), Object.keys(a).forEach((o) => {
    const s = a[o];
    os(s, [
      ee.scales[s.type],
      ee.scale
    ]);
  }), a;
}
function Mb(e) {
  const t = e.options || (e.options = {});
  t.plugins = ot(t.plugins, {}), t.scales = _T(e, t);
}
function Db(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function mT(e) {
  return e = e || {}, e.data = Db(e.data), Mb(e), e;
}
const Ng = /* @__PURE__ */ new Map(), Tb = /* @__PURE__ */ new Set();
function hl(e, t) {
  let n = Ng.get(e);
  return n || (n = t(), Ng.set(e, n), Tb.add(n)), n;
}
const So = (e, t, n) => {
  const i = ra(t, n);
  i !== void 0 && e.add(i);
};
class yT {
  constructor(t) {
    this._config = mT(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Db(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Mb(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return hl(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, n) {
    return hl(`${t}.transition.${n}`, () => [
      [
        `datasets.${t}.transitions.${n}`,
        `transitions.${n}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, n) {
    return hl(`${t}-${n}`, () => [
      [
        `datasets.${t}.elements.${n}`,
        `datasets.${t}`,
        `elements.${n}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const n = t.id, i = this.type;
    return hl(`${i}-plugin-${n}`, () => [
      [
        `plugins.${n}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, n) {
    const i = this._scopeCache;
    let r = i.get(t);
    return (!r || n) && (r = /* @__PURE__ */ new Map(), i.set(t, r)), r;
  }
  getOptionScopes(t, n, i) {
    const { options: r, type: a } = this, o = this._cachedScopes(t, i), s = o.get(n);
    if (s)
      return s;
    const l = /* @__PURE__ */ new Set();
    n.forEach((c) => {
      t && (l.add(t), c.forEach((h) => So(l, t, h))), c.forEach((h) => So(l, r, h)), c.forEach((h) => So(l, aa[a] || {}, h)), c.forEach((h) => So(l, ee, h)), c.forEach((h) => So(l, Nd, h));
    });
    const u = Array.from(l);
    return u.length === 0 && u.push(/* @__PURE__ */ Object.create(null)), Tb.has(n) && o.set(n, u), u;
  }
  chartOptionScopes() {
    const { options: t, type: n } = this;
    return [
      t,
      aa[n] || {},
      ee.datasets[n] || {},
      {
        type: n
      },
      ee,
      Nd
    ];
  }
  resolveNamedOptions(t, n, i, r = [
    ""
  ]) {
    const a = {
      $shared: !0
    }, { resolver: o, subPrefixes: s } = Fg(this._resolverCache, t, r);
    let l = o;
    if (xT(o, n)) {
      a.$shared = !1, i = Ji(i) ? i() : i;
      const u = this.createResolver(t, i, s);
      l = to(o, i, u);
    }
    for (const u of n)
      a[u] = l[u];
    return a;
  }
  createResolver(t, n, i = [
    ""
  ], r) {
    const { resolver: a } = Fg(this._resolverCache, t, i);
    return dt(n) ? to(a, n, void 0, r) : a;
  }
}
function Fg(e, t, n) {
  let i = e.get(t);
  i || (i = /* @__PURE__ */ new Map(), e.set(t, i));
  const r = n.join();
  let a = i.get(r);
  return a || (a = {
    resolver: ov(t, n),
    subPrefixes: n.filter((s) => !s.toLowerCase().includes("hover"))
  }, i.set(r, a)), a;
}
const bT = (e) => dt(e) && Object.getOwnPropertyNames(e).some((t) => Ji(e[t]));
function xT(e, t) {
  const { isScriptable: n, isIndexable: i } = ab(e);
  for (const r of t) {
    const a = n(r), o = i(r), s = (o || a) && e[r];
    if (a && (Ji(s) || bT(s)) || o && ie(s))
      return !0;
  }
  return !1;
}
var wT = "4.5.1";
const ST = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Bg(e, t) {
  return e === "top" || e === "bottom" || ST.indexOf(e) === -1 && t === "x";
}
function zg(e, t) {
  return function(n, i) {
    return n[e] === i[e] ? n[t] - i[t] : n[e] - i[e];
  };
}
function Vg(e) {
  const t = e.chart, n = t.options.animation;
  t.notifyPlugins("afterRender"), Nt(n && n.onComplete, [
    e
  ], t);
}
function MT(e) {
  const t = e.chart, n = t.options.animation;
  Nt(n && n.onProgress, [
    e
  ], t);
}
function kb(e) {
  return uv() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const tu = {}, $g = (e) => {
  const t = kb(e);
  return Object.values(tu).filter((n) => n.canvas === t).pop();
};
function DT(e, t, n) {
  const i = Object.keys(e);
  for (const r of i) {
    const a = +r;
    if (a >= t) {
      const o = e[r];
      delete e[r], (n > 0 || a > t) && (e[a + n] = o);
    }
  }
}
function TT(e, t, n, i) {
  return !n || e.type === "mouseout" ? null : i ? t : e;
}
let uo = class {
  static defaults = ee;
  static instances = tu;
  static overrides = aa;
  static registry = Hn;
  static version = wT;
  static getChart = $g;
  static register(...t) {
    Hn.add(...t), Hg();
  }
  static unregister(...t) {
    Hn.remove(...t), Hg();
  }
  constructor(t, n) {
    const i = this.config = new yT(n), r = kb(t), a = $g(r);
    if (a)
      throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas with ID '" + a.canvas.id + "' can be reused.");
    const o = i.createResolver(i.chartOptionScopes(), this.getContext());
    this.platform = new (i.platform || WD(r))(), this.platform.updateConfig(i);
    const s = this.platform.acquireContext(r, o.aspectRatio), l = s && s.canvas, u = l && l.height, c = l && l.width;
    if (this.id = b2(), this.ctx = s, this.canvas = l, this.width = c, this.height = u, this._options = o, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new lT(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = z2((h) => this.update(h), o.resizeDelay || 0), this._dataChanges = [], tu[this.id] = this, !s || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    ui.listen(this, "complete", Vg), ui.listen(this, "progress", MT), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: n }, width: i, height: r, _aspectRatio: a } = this;
    return Dt(t) ? n && a ? a : r ? i / r : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Hn;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : cg(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return sg(this.canvas, this.ctx), this;
  }
  stop() {
    return ui.stop(this), this;
  }
  resize(t, n) {
    ui.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: n
    } : this._resize(t, n);
  }
  _resize(t, n) {
    const i = this.options, r = this.canvas, a = i.maintainAspectRatio && this.aspectRatio, o = this.platform.getMaximumSize(r, t, n, a), s = i.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = o.width, this.height = o.height, this._aspectRatio = this.aspectRatio, cg(this, s, !0) && (this.notifyPlugins("resize", {
      size: o
    }), Nt(i.onResize, [
      this,
      o
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const n = this.options.scales || {};
    kt(n, (i, r) => {
      i.id = r;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, n = t.scales, i = this.scales, r = Object.keys(i).reduce((o, s) => (o[s] = !1, o), {});
    let a = [];
    n && (a = a.concat(Object.keys(n).map((o) => {
      const s = n[o], l = zd(o, s), u = l === "r", c = l === "x";
      return {
        options: s,
        dposition: u ? "chartArea" : c ? "bottom" : "left",
        dtype: u ? "radialLinear" : c ? "category" : "linear"
      };
    }))), kt(a, (o) => {
      const s = o.options, l = s.id, u = zd(l, s), c = ot(s.type, o.dtype);
      (s.position === void 0 || Bg(s.position, u) !== Bg(o.dposition)) && (s.position = o.dposition), r[l] = !0;
      let h = null;
      if (l in i && i[l].type === c)
        h = i[l];
      else {
        const d = Hn.getScale(c);
        h = new d({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), i[h.id] = h;
      }
      h.init(s, t);
    }), kt(r, (o, s) => {
      o || delete i[s];
    }), kt(i, (o) => {
      fn.configure(this, o, o.options), fn.addBox(this, o);
    });
  }
  _updateMetasets() {
    const t = this._metasets, n = this.data.datasets.length, i = t.length;
    if (t.sort((r, a) => r.index - a.index), i > n) {
      for (let r = n; r < i; ++r)
        this._destroyDatasetMeta(r);
      t.splice(n, i - n);
    }
    this._sortedMetasets = t.slice(0).sort(zg("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: n } } = this;
    t.length > n.length && delete this._stacks, t.forEach((i, r) => {
      n.filter((a) => a === i._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const t = [], n = this.data.datasets;
    let i, r;
    for (this._removeUnreferencedMetasets(), i = 0, r = n.length; i < r; i++) {
      const a = n[i];
      let o = this.getDatasetMeta(i);
      const s = a.type || this.config.type;
      if (o.type && o.type !== s && (this._destroyDatasetMeta(i), o = this.getDatasetMeta(i)), o.type = s, o.indexAxis = a.indexAxis || Bd(s, this.options), o.order = a.order || 0, o.index = i, o.label = "" + a.label, o.visible = this.isDatasetVisible(i), o.controller)
        o.controller.updateIndex(i), o.controller.linkScales();
      else {
        const l = Hn.getController(s), { datasetElementType: u, dataElementType: c } = ee.datasets[s];
        Object.assign(l, {
          dataElementType: Hn.getElement(c),
          datasetElementType: u && Hn.getElement(u)
        }), o.controller = new l(this, i), t.push(o.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    kt(this.data.datasets, (t, n) => {
      this.getDatasetMeta(n).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const n = this.config;
    n.update();
    const i = this._options = n.createResolver(n.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !i.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const a = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let o = 0;
    for (let u = 0, c = this.data.datasets.length; u < c; u++) {
      const { controller: h } = this.getDatasetMeta(u), d = !r && a.indexOf(h) === -1;
      h.buildOrUpdateElements(d), o = Math.max(+h.getMaxOverflow(), o);
    }
    o = this._minPadding = i.layout.autoPadding ? o : 0, this._updateLayout(o), r || kt(a, (u) => {
      u.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(zg("z", "_idx"));
    const { _active: s, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : s.length && this._updateHoverStyles(s, s, !0), this.render();
  }
  _updateScales() {
    kt(this.scales, (t) => {
      fn.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, n = new Set(Object.keys(this._listeners)), i = new Set(t.events);
    (!Kp(n, i) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, n = this._getUniformDataChanges() || [];
    for (const { method: i, start: r, count: a } of n) {
      const o = i === "_removeElements" ? -a : a;
      DT(t, r, o);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const n = this.data.datasets.length, i = (a) => new Set(t.filter((o) => o[0] === a).map((o, s) => s + "," + o.splice(1).join(","))), r = i(0);
    for (let a = 1; a < n; a++)
      if (!Kp(r, i(a)))
        return;
    return Array.from(r).map((a) => a.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    fn.update(this, this.width, this.height, t);
    const n = this.chartArea, i = n.width <= 0 || n.height <= 0;
    this._layers = [], kt(this.boxes, (r) => {
      i && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, a) => {
      r._idx = a;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let n = 0, i = this.data.datasets.length; n < i; ++n)
        this.getDatasetMeta(n).controller.configure();
      for (let n = 0, i = this.data.datasets.length; n < i; ++n)
        this._updateDataset(n, Ji(t) ? t({
          datasetIndex: n
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, n) {
    const i = this.getDatasetMeta(t), r = {
      meta: i,
      index: t,
      mode: n,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (i.controller._update(n), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (ui.has(this) ? this.attached && !ui.running(this) && ui.start(this) : (this.draw(), Vg({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: i, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(i, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const n = this._layers;
    for (t = 0; t < n.length && n[t].z <= 0; ++t)
      n[t].draw(this.chartArea);
    for (this._drawDatasets(); t < n.length; ++t)
      n[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const n = this._sortedMetasets, i = [];
    let r, a;
    for (r = 0, a = n.length; r < a; ++r) {
      const o = n[r];
      (!t || o.visible) && i.push(o);
    }
    return i;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let n = t.length - 1; n >= 0; --n)
      this._drawDataset(t[n]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const n = this.ctx, i = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, r = pb(this, t);
    this.notifyPlugins("beforeDatasetDraw", i) !== !1 && (r && fc(n, r), t.controller.draw(), r && vc(n), i.cancelable = !1, this.notifyPlugins("afterDatasetDraw", i));
  }
  isPointInArea(t) {
    return Ds(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, n, i, r) {
    const a = SD.modes[n];
    return typeof a == "function" ? a(this, t, i, r) : [];
  }
  getDatasetMeta(t) {
    const n = this.data.datasets[t], i = this._metasets;
    let r = i.filter((a) => a && a._dataset === n).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: n && n.order || 0,
      index: t,
      _dataset: n,
      _parsed: [],
      _sorted: !1
    }, i.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = la(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const n = this.data.datasets[t];
    if (!n)
      return !1;
    const i = this.getDatasetMeta(t);
    return typeof i.hidden == "boolean" ? !i.hidden : !n.hidden;
  }
  setDatasetVisibility(t, n) {
    const i = this.getDatasetMeta(t);
    i.hidden = !n;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, n, i) {
    const r = i ? "show" : "hide", a = this.getDatasetMeta(t), o = a.controller._resolveAnimations(void 0, r);
    ws(n) ? (a.data[n].hidden = !i, this.update()) : (this.setDatasetVisibility(t, i), o.update(a, {
      visible: i
    }), this.update((s) => s.datasetIndex === t ? r : void 0));
  }
  hide(t, n) {
    this._updateVisibility(t, n, !1);
  }
  show(t, n) {
    this._updateVisibility(t, n, !0);
  }
  _destroyDatasetMeta(t) {
    const n = this._metasets[t];
    n && n.controller && n.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, n;
    for (this.stop(), ui.remove(this), t = 0, n = this.data.datasets.length; t < n; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: n } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), sg(t, n), this.platform.releaseContext(n), this.canvas = null, this.ctx = null), delete tu[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, n = this.platform, i = (a, o) => {
      n.addEventListener(this, a, o), t[a] = o;
    }, r = (a, o, s) => {
      a.offsetX = o, a.offsetY = s, this._eventHandler(a);
    };
    kt(this.options.events, (a) => i(a, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, n = this.platform, i = (l, u) => {
      n.addEventListener(this, l, u), t[l] = u;
    }, r = (l, u) => {
      t[l] && (n.removeEventListener(this, l, u), delete t[l]);
    }, a = (l, u) => {
      this.canvas && this.resize(l, u);
    };
    let o;
    const s = () => {
      r("attach", s), this.attached = !0, this.resize(), i("resize", a), i("detach", o);
    };
    o = () => {
      this.attached = !1, r("resize", a), this._stop(), this._resize(0, 0), i("attach", s);
    }, n.isAttached(this.canvas) ? s() : o();
  }
  unbindEvents() {
    kt(this._listeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._listeners = {}, kt(this._responsiveListeners, (t, n) => {
      this.platform.removeEventListener(this, n, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, n, i) {
    const r = i ? "set" : "remove";
    let a, o, s, l;
    for (n === "dataset" && (a = this.getDatasetMeta(t[0].datasetIndex), a.controller["_" + r + "DatasetHoverStyle"]()), s = 0, l = t.length; s < l; ++s) {
      o = t[s];
      const u = o && this.getDatasetMeta(o.datasetIndex).controller;
      u && u[r + "HoverStyle"](o.element, o.datasetIndex, o.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const n = this._active || [], i = t.map(({ datasetIndex: a, index: o }) => {
      const s = this.getDatasetMeta(a);
      if (!s)
        throw new Error("No dataset found at index " + a);
      return {
        datasetIndex: a,
        element: s.data[o],
        index: o
      };
    });
    !_u(i, n) && (this._active = i, this._lastEvent = null, this._updateHoverStyles(i, n));
  }
  notifyPlugins(t, n, i) {
    return this._plugins.notify(this, t, n, i);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((n) => n.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, n, i) {
    const r = this.options.hover, a = (l, u) => l.filter((c) => !u.some((h) => c.datasetIndex === h.datasetIndex && c.index === h.index)), o = a(n, t), s = i ? t : a(t, n);
    o.length && this.updateHoverStyle(o, r.mode, !1), s.length && r.mode && this.updateHoverStyle(s, r.mode, !0);
  }
  _eventHandler(t, n) {
    const i = {
      event: t,
      replay: n,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, r = (o) => (o.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", i, r) === !1)
      return;
    const a = this._handleEvent(t, n, i.inChartArea);
    return i.cancelable = !1, this.notifyPlugins("afterEvent", i, r), (a || i.changed) && this.render(), this;
  }
  _handleEvent(t, n, i) {
    const { _active: r = [], options: a } = this, o = n, s = this._getActiveElements(t, r, i, o), l = T2(t), u = TT(t, this._lastEvent, i, l);
    i && (this._lastEvent = null, Nt(a.onHover, [
      t,
      s,
      this
    ], this), l && Nt(a.onClick, [
      t,
      s,
      this
    ], this));
    const c = !_u(s, r);
    return (c || n) && (this._active = s, this._updateHoverStyles(s, r, n)), this._lastEvent = u, c;
  }
  _getActiveElements(t, n, i, r) {
    if (t.type === "mouseout")
      return [];
    if (!i)
      return n;
    const a = this.options.hover;
    return this.getElementsAtEventForMode(t, a.mode, a, r);
  }
};
function Hg() {
  return kt(uo.instances, (e) => e._plugins.invalidate());
}
function kT(e, t, n) {
  const { startAngle: i, x: r, y: a, outerRadius: o, innerRadius: s, options: l } = t, { borderWidth: u, borderJoinStyle: c } = l, h = Math.min(u / o, je(i - n));
  if (e.beginPath(), e.arc(r, a, o - u / 2, i + h / 2, n - h / 2), s > 0) {
    const d = Math.min(u / s, je(i - n));
    e.arc(r, a, s + u / 2, n - d / 2, i + d / 2, !0);
  } else {
    const d = Math.min(u / 2, o * je(i - n));
    if (c === "round")
      e.arc(r, a, d, n - Ct / 2, i + Ct / 2, !0);
    else if (c === "bevel") {
      const f = 2 * d * d, v = -f * Math.cos(n + Ct / 2) + r, g = -f * Math.sin(n + Ct / 2) + a, p = f * Math.cos(i + Ct / 2) + r, _ = f * Math.sin(i + Ct / 2) + a;
      e.lineTo(v, g), e.lineTo(p, _);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function CT(e, t, n) {
  const { startAngle: i, pixelMargin: r, x: a, y: o, outerRadius: s, innerRadius: l } = t;
  let u = r / s;
  e.beginPath(), e.arc(a, o, s, i - u, n + u), l > r ? (u = r / l, e.arc(a, o, l, n + u, i - u, !0)) : e.arc(a, o, r, n + se, i - se), e.closePath(), e.clip();
}
function PT(e) {
  return av(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function AT(e, t, n, i) {
  const r = PT(e.options.borderRadius), a = (n - t) / 2, o = Math.min(a, i * t / 2), s = (l) => {
    const u = (n - Math.min(a, l)) * i / 2;
    return _e(l, 0, Math.min(a, u));
  };
  return {
    outerStart: s(r.outerStart),
    outerEnd: s(r.outerEnd),
    innerStart: _e(r.innerStart, 0, o),
    innerEnd: _e(r.innerEnd, 0, o)
  };
}
function pa(e, t, n, i) {
  return {
    x: n + e * Math.cos(t),
    y: i + e * Math.sin(t)
  };
}
function Su(e, t, n, i, r, a) {
  const { x: o, y: s, startAngle: l, pixelMargin: u, innerRadius: c } = t, h = Math.max(t.outerRadius + i + n - u, 0), d = c > 0 ? c + i + n + u : 0;
  let f = 0;
  const v = r - l;
  if (i) {
    const R = c > 0 ? c - i : 0, N = h > 0 ? h - i : 0, V = (R + N) / 2, q = V !== 0 ? v * V / (V + i) : v;
    f = (v - q) / 2;
  }
  const g = Math.max(1e-3, v * h - n / Ct) / h, p = (v - g) / 2, _ = l + p + f, m = r - p - f, { outerStart: y, outerEnd: b, innerStart: x, innerEnd: w } = AT(t, d, h, m - _), M = h - y, D = h - b, T = _ + y / M, C = m - b / D, k = d + x, E = d + w, A = _ + x / k, L = m - w / E;
  if (e.beginPath(), a) {
    const R = (T + C) / 2;
    if (e.arc(o, s, h, T, R), e.arc(o, s, h, R, C), b > 0) {
      const W = pa(D, C, o, s);
      e.arc(W.x, W.y, b, C, m + se);
    }
    const N = pa(E, m, o, s);
    if (e.lineTo(N.x, N.y), w > 0) {
      const W = pa(E, L, o, s);
      e.arc(W.x, W.y, w, m + se, L + Math.PI);
    }
    const V = (m - w / d + (_ + x / d)) / 2;
    if (e.arc(o, s, d, m - w / d, V, !0), e.arc(o, s, d, V, _ + x / d, !0), x > 0) {
      const W = pa(k, A, o, s);
      e.arc(W.x, W.y, x, A + Math.PI, _ - se);
    }
    const q = pa(M, _, o, s);
    if (e.lineTo(q.x, q.y), y > 0) {
      const W = pa(M, T, o, s);
      e.arc(W.x, W.y, y, _ - se, T);
    }
  } else {
    e.moveTo(o, s);
    const R = Math.cos(T) * h + o, N = Math.sin(T) * h + s;
    e.lineTo(R, N);
    const V = Math.cos(C) * h + o, q = Math.sin(C) * h + s;
    e.lineTo(V, q);
  }
  e.closePath();
}
function ET(e, t, n, i, r) {
  const { fullCircles: a, startAngle: o, circumference: s } = t;
  let l = t.endAngle;
  if (a) {
    Su(e, t, n, i, l, r);
    for (let u = 0; u < a; ++u)
      e.fill();
    isNaN(s) || (l = o + (s % Ut || Ut));
  }
  return Su(e, t, n, i, l, r), e.fill(), l;
}
function LT(e, t, n, i, r) {
  const { fullCircles: a, startAngle: o, circumference: s, options: l } = t, { borderWidth: u, borderJoinStyle: c, borderDash: h, borderDashOffset: d, borderRadius: f } = l, v = l.borderAlign === "inner";
  if (!u)
    return;
  e.setLineDash(h || []), e.lineDashOffset = d, v ? (e.lineWidth = u * 2, e.lineJoin = c || "round") : (e.lineWidth = u, e.lineJoin = c || "bevel");
  let g = t.endAngle;
  if (a) {
    Su(e, t, n, i, g, r);
    for (let p = 0; p < a; ++p)
      e.stroke();
    isNaN(s) || (g = o + (s % Ut || Ut));
  }
  v && CT(e, t, g), l.selfJoin && g - o >= Ct && f === 0 && c !== "miter" && kT(e, t, g), a || (Su(e, t, n, i, g, r), e.stroke());
}
class OT extends Ci {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, n, i) {
    const r = this.getProps([
      "x",
      "y"
    ], i), { angle: a, distance: o } = Ky(r, {
      x: t,
      y: n
    }), { startAngle: s, endAngle: l, innerRadius: u, outerRadius: c, circumference: h } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], i), d = (this.options.spacing + this.options.borderWidth) / 2, f = ot(h, l - s), v = Ms(a, s, l) && s !== l, g = f >= Ut || v, p = pi(o, u + d, c + d);
    return g && p;
  }
  getCenterPoint(t) {
    const { x: n, y: i, startAngle: r, endAngle: a, innerRadius: o, outerRadius: s } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: u } = this.options, c = (r + a) / 2, h = (o + s + u + l) / 2;
    return {
      x: n + Math.cos(c) * h,
      y: i + Math.sin(c) * h
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: n, circumference: i } = this, r = (n.offset || 0) / 4, a = (n.spacing || 0) / 2, o = n.circular;
    if (this.pixelMargin = n.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = i > Ut ? Math.floor(i / Ut) : 0, i === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const s = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(s) * r, Math.sin(s) * r);
    const l = 1 - Math.sin(Math.min(Ct, i || 0)), u = r * l;
    t.fillStyle = n.backgroundColor, t.strokeStyle = n.borderColor, ET(t, this, u, a, o), LT(t, this, u, a, o), t.restore();
  }
}
function Cb(e, t, n = t) {
  e.lineCap = ot(n.borderCapStyle, t.borderCapStyle), e.setLineDash(ot(n.borderDash, t.borderDash)), e.lineDashOffset = ot(n.borderDashOffset, t.borderDashOffset), e.lineJoin = ot(n.borderJoinStyle, t.borderJoinStyle), e.lineWidth = ot(n.borderWidth, t.borderWidth), e.strokeStyle = ot(n.borderColor, t.borderColor);
}
function IT(e, t, n) {
  e.lineTo(n.x, n.y);
}
function RT(e) {
  return e.stepped ? J2 : e.tension || e.cubicInterpolationMode === "monotone" ? tM : IT;
}
function Pb(e, t, n = {}) {
  const i = e.length, { start: r = 0, end: a = i - 1 } = n, { start: o, end: s } = t, l = Math.max(r, o), u = Math.min(a, s), c = r < o && a < o || r > s && a > s;
  return {
    count: i,
    start: l,
    loop: t.loop,
    ilen: u < l && !c ? i + u - l : u - l
  };
}
function NT(e, t, n, i) {
  const { points: r, options: a } = t, { count: o, start: s, loop: l, ilen: u } = Pb(r, n, i), c = RT(a);
  let { move: h = !0, reverse: d } = i || {}, f, v, g;
  for (f = 0; f <= u; ++f)
    v = r[(s + (d ? u - f : f)) % o], !v.skip && (h ? (e.moveTo(v.x, v.y), h = !1) : c(e, g, v, d, a.stepped), g = v);
  return l && (v = r[(s + (d ? u : 0)) % o], c(e, g, v, d, a.stepped)), !!l;
}
function FT(e, t, n, i) {
  const r = t.points, { count: a, start: o, ilen: s } = Pb(r, n, i), { move: l = !0, reverse: u } = i || {};
  let c = 0, h = 0, d, f, v, g, p, _;
  const m = (b) => (o + (u ? s - b : b)) % a, y = () => {
    g !== p && (e.lineTo(c, p), e.lineTo(c, g), e.lineTo(c, _));
  };
  for (l && (f = r[m(0)], e.moveTo(f.x, f.y)), d = 0; d <= s; ++d) {
    if (f = r[m(d)], f.skip)
      continue;
    const b = f.x, x = f.y, w = b | 0;
    w === v ? (x < g ? g = x : x > p && (p = x), c = (h * c + b) / ++h) : (y(), e.lineTo(b, x), v = w, h = 0, g = p = x), _ = x;
  }
  y();
}
function Vd(e) {
  const t = e.options, n = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !n ? FT : NT;
}
function BT(e) {
  return e.stepped ? LM : e.tension || e.cubicInterpolationMode === "monotone" ? OM : Nr;
}
function zT(e, t, n, i) {
  let r = t._path;
  r || (r = t._path = new Path2D(), t.path(r, n, i) && r.closePath()), Cb(e, t.options), e.stroke(r);
}
function VT(e, t, n, i) {
  const { segments: r, options: a } = t, o = Vd(t);
  for (const s of r)
    Cb(e, a, s.style), e.beginPath(), o(e, t, s, {
      start: n,
      end: n + i - 1
    }) && e.closePath(), e.stroke();
}
const $T = typeof Path2D == "function";
function HT(e, t, n, i) {
  $T && !t.options.segment ? zT(e, t, n, i) : VT(e, t, n, i);
}
class mc extends Ci {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, n) {
    const i = this.options;
    if ((i.tension || i.cubicInterpolationMode === "monotone") && !i.stepped && !this._pointsUpdated) {
      const r = i.spanGaps ? this._loop : this._fullLoop;
      MM(this._points, i, t, r, n), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = zM(this, this.options.segment));
  }
  first() {
    const t = this.segments, n = this.points;
    return t.length && n[t[0].start];
  }
  last() {
    const t = this.segments, n = this.points, i = t.length;
    return i && n[t[i - 1].end];
  }
  interpolate(t, n) {
    const i = this.options, r = t[n], a = this.points, o = vb(this, {
      property: n,
      start: r,
      end: r
    });
    if (!o.length)
      return;
    const s = [], l = BT(i);
    let u, c;
    for (u = 0, c = o.length; u < c; ++u) {
      const { start: h, end: d } = o[u], f = a[h], v = a[d];
      if (f === v) {
        s.push(f);
        continue;
      }
      const g = Math.abs((r - f[n]) / (v[n] - f[n])), p = l(f, v, g, i.stepped);
      p[n] = t[n], s.push(p);
    }
    return s.length === 1 ? s[0] : s;
  }
  pathSegment(t, n, i) {
    return Vd(this)(t, this, n, i);
  }
  path(t, n, i) {
    const r = this.segments, a = Vd(this);
    let o = this._loop;
    n = n || 0, i = i || this.points.length - n;
    for (const s of r)
      o &= a(t, this, s, {
        start: n,
        end: n + i - 1
      });
    return !!o;
  }
  draw(t, n, i, r) {
    const a = this.options || {};
    (this.points || []).length && a.borderWidth && (t.save(), HT(t, this, i, r), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function Yg(e, t, n, i) {
  const r = e.options, { [n]: a } = e.getProps([
    n
  ], i);
  return Math.abs(t - a) < r.radius + r.hitRadius;
}
class YT extends Ci {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, n, i) {
    const r = this.options, { x: a, y: o } = this.getProps([
      "x",
      "y"
    ], i);
    return Math.pow(t - a, 2) + Math.pow(n - o, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(t, n) {
    return Yg(this, t, "x", n);
  }
  inYRange(t, n) {
    return Yg(this, t, "y", n);
  }
  getCenterPoint(t) {
    const { x: n, y: i } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: n,
      y: i
    };
  }
  size(t) {
    t = t || this.options || {};
    let n = t.radius || 0;
    n = Math.max(n, n && t.hoverRadius || 0);
    const i = n && t.borderWidth || 0;
    return (n + i) * 2;
  }
  draw(t, n) {
    const i = this.options;
    this.skip || i.radius < 0.1 || !Ds(this, n, this.size(i) / 2) || (t.strokeStyle = i.borderColor, t.lineWidth = i.borderWidth, t.fillStyle = i.backgroundColor, Fd(t, i, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function Ab(e, t) {
  const { x: n, y: i, base: r, width: a, height: o } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let s, l, u, c, h;
  return e.horizontal ? (h = o / 2, s = Math.min(n, r), l = Math.max(n, r), u = i - h, c = i + h) : (h = a / 2, s = n - h, l = n + h, u = Math.min(i, r), c = Math.max(i, r)), {
    left: s,
    top: u,
    right: l,
    bottom: c
  };
}
function Hi(e, t, n, i) {
  return e ? 0 : _e(t, n, i);
}
function WT(e, t, n) {
  const i = e.options.borderWidth, r = e.borderSkipped, a = rb(i);
  return {
    t: Hi(r.top, a.top, 0, n),
    r: Hi(r.right, a.right, 0, t),
    b: Hi(r.bottom, a.bottom, 0, n),
    l: Hi(r.left, a.left, 0, t)
  };
}
function UT(e, t, n) {
  const { enableBorderRadius: i } = e.getProps([
    "enableBorderRadius"
  ]), r = e.options.borderRadius, a = Ua(r), o = Math.min(t, n), s = e.borderSkipped, l = i || dt(r);
  return {
    topLeft: Hi(!l || s.top || s.left, a.topLeft, 0, o),
    topRight: Hi(!l || s.top || s.right, a.topRight, 0, o),
    bottomLeft: Hi(!l || s.bottom || s.left, a.bottomLeft, 0, o),
    bottomRight: Hi(!l || s.bottom || s.right, a.bottomRight, 0, o)
  };
}
function GT(e) {
  const t = Ab(e), n = t.right - t.left, i = t.bottom - t.top, r = WT(e, n / 2, i / 2), a = UT(e, n / 2, i / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: n,
      h: i,
      radius: a
    },
    inner: {
      x: t.left + r.l,
      y: t.top + r.t,
      w: n - r.l - r.r,
      h: i - r.t - r.b,
      radius: {
        topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function sh(e, t, n, i) {
  const r = t === null, a = n === null, s = e && !(r && a) && Ab(e, i);
  return s && (r || pi(t, s.left, s.right)) && (a || pi(n, s.top, s.bottom));
}
function jT(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function XT(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function lh(e, t, n = {}) {
  const i = e.x !== n.x ? -t : 0, r = e.y !== n.y ? -t : 0, a = (e.x + e.w !== n.x + n.w ? t : 0) - i, o = (e.y + e.h !== n.y + n.h ? t : 0) - r;
  return {
    x: e.x + i,
    y: e.y + r,
    w: e.w + a,
    h: e.h + o,
    radius: e.radius
  };
}
class qT extends Ci {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: n, options: { borderColor: i, backgroundColor: r } } = this, { inner: a, outer: o } = GT(this), s = jT(o.radius) ? bu : XT;
    t.save(), (o.w !== a.w || o.h !== a.h) && (t.beginPath(), s(t, lh(o, n, a)), t.clip(), s(t, lh(a, -n, o)), t.fillStyle = i, t.fill("evenodd")), t.beginPath(), s(t, lh(a, n)), t.fillStyle = r, t.fill(), t.restore();
  }
  inRange(t, n, i) {
    return sh(this, t, n, i);
  }
  inXRange(t, n) {
    return sh(this, t, null, n);
  }
  inYRange(t, n) {
    return sh(this, null, t, n);
  }
  getCenterPoint(t) {
    const { x: n, y: i, base: r, horizontal: a } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: a ? (n + r) / 2 : n,
      y: a ? i : (i + r) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
function ZT(e, t, n) {
  const i = e.segments, r = e.points, a = t.points, o = [];
  for (const s of i) {
    let { start: l, end: u } = s;
    u = yc(l, u, r);
    const c = $d(n, r[l], r[u], s.loop);
    if (!t.segments) {
      o.push({
        source: s,
        target: c,
        start: r[l],
        end: r[u]
      });
      continue;
    }
    const h = vb(t, c);
    for (const d of h) {
      const f = $d(n, a[d.start], a[d.end], d.loop), v = fb(s, r, f);
      for (const g of v)
        o.push({
          source: g,
          target: d,
          start: {
            [n]: Wg(c, f, "start", Math.max)
          },
          end: {
            [n]: Wg(c, f, "end", Math.min)
          }
        });
    }
  }
  return o;
}
function $d(e, t, n, i) {
  if (i)
    return;
  let r = t[e], a = n[e];
  return e === "angle" && (r = je(r), a = je(a)), {
    property: e,
    start: r,
    end: a
  };
}
function KT(e, t) {
  const { x: n = null, y: i = null } = e || {}, r = t.points, a = [];
  return t.segments.forEach(({ start: o, end: s }) => {
    s = yc(o, s, r);
    const l = r[o], u = r[s];
    i !== null ? (a.push({
      x: l.x,
      y: i
    }), a.push({
      x: u.x,
      y: i
    })) : n !== null && (a.push({
      x: n,
      y: l.y
    }), a.push({
      x: n,
      y: u.y
    }));
  }), a;
}
function yc(e, t, n) {
  for (; t > e; t--) {
    const i = n[t];
    if (!isNaN(i.x) && !isNaN(i.y))
      break;
  }
  return t;
}
function Wg(e, t, n, i) {
  return e && t ? i(e[n], t[n]) : e ? e[n] : t ? t[n] : 0;
}
function Eb(e, t) {
  let n = [], i = !1;
  return ie(e) ? (i = !0, n = e) : n = KT(e, t), n.length ? new mc({
    points: n,
    options: {
      tension: 0
    },
    _loop: i,
    _fullLoop: i
  }) : null;
}
function Ug(e) {
  return e && e.fill !== !1;
}
function QT(e, t, n) {
  let r = e[t].fill;
  const a = [
    t
  ];
  let o;
  if (!n)
    return r;
  for (; r !== !1 && a.indexOf(r) === -1; ) {
    if (!we(r))
      return r;
    if (o = e[r], !o)
      return !1;
    if (o.visible)
      return r;
    a.push(r), r = o.fill;
  }
  return !1;
}
function JT(e, t, n) {
  const i = ik(e);
  if (dt(i))
    return isNaN(i.value) ? !1 : i;
  let r = parseFloat(i);
  return we(r) && Math.floor(r) === r ? tk(i[0], t, r, n) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(i) >= 0 && i;
}
function tk(e, t, n, i) {
  return (e === "-" || e === "+") && (n = t + n), n === t || n < 0 || n >= i ? !1 : n;
}
function ek(e, t) {
  let n = null;
  return e === "start" ? n = t.bottom : e === "end" ? n = t.top : dt(e) ? n = t.getPixelForValue(e.value) : t.getBasePixel && (n = t.getBasePixel()), n;
}
function nk(e, t, n) {
  let i;
  return e === "start" ? i = n : e === "end" ? i = t.options.reverse ? t.min : t.max : dt(e) ? i = e.value : i = t.getBaseValue(), i;
}
function ik(e) {
  const t = e.options, n = t.fill;
  let i = ot(n && n.target, n);
  return i === void 0 && (i = !!t.backgroundColor), i === !1 || i === null ? !1 : i === !0 ? "origin" : i;
}
function rk(e) {
  const { scale: t, index: n, line: i } = e, r = [], a = i.segments, o = i.points, s = ak(t, n);
  s.push(Eb({
    x: null,
    y: t.bottom
  }, i));
  for (let l = 0; l < a.length; l++) {
    const u = a[l];
    for (let c = u.start; c <= u.end; c++)
      ok(r, o[c], s);
  }
  return new mc({
    points: r,
    options: {}
  });
}
function ak(e, t) {
  const n = [], i = e.getMatchingVisibleMetas("line");
  for (let r = 0; r < i.length; r++) {
    const a = i[r];
    if (a.index === t)
      break;
    a.hidden || n.unshift(a.dataset);
  }
  return n;
}
function ok(e, t, n) {
  const i = [];
  for (let r = 0; r < n.length; r++) {
    const a = n[r], { first: o, last: s, point: l } = sk(a, t, "x");
    if (!(!l || o && s)) {
      if (o)
        i.unshift(l);
      else if (e.push(l), !s)
        break;
    }
  }
  e.push(...i);
}
function sk(e, t, n) {
  const i = e.interpolate(t, n);
  if (!i)
    return {};
  const r = i[n], a = e.segments, o = e.points;
  let s = !1, l = !1;
  for (let u = 0; u < a.length; u++) {
    const c = a[u], h = o[c.start][n], d = o[c.end][n];
    if (pi(r, h, d)) {
      s = r === h, l = r === d;
      break;
    }
  }
  return {
    first: s,
    last: l,
    point: i
  };
}
class Lb {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, n, i) {
    const { x: r, y: a, radius: o } = this;
    return n = n || {
      start: 0,
      end: Ut
    }, t.arc(r, a, o, n.end, n.start, !0), !i.bounds;
  }
  interpolate(t) {
    const { x: n, y: i, radius: r } = this, a = t.angle;
    return {
      x: n + Math.cos(a) * r,
      y: i + Math.sin(a) * r,
      angle: a
    };
  }
}
function lk(e) {
  const { chart: t, fill: n, line: i } = e;
  if (we(n))
    return uk(t, n);
  if (n === "stack")
    return rk(e);
  if (n === "shape")
    return !0;
  const r = ck(e);
  return r instanceof Lb ? r : Eb(r, i);
}
function uk(e, t) {
  const n = e.getDatasetMeta(t);
  return n && e.isDatasetVisible(t) ? n.dataset : null;
}
function ck(e) {
  return (e.scale || {}).getPointPositionForValue ? dk(e) : hk(e);
}
function hk(e) {
  const { scale: t = {}, fill: n } = e, i = ek(n, t);
  if (we(i)) {
    const r = t.isHorizontal();
    return {
      x: r ? i : null,
      y: r ? null : i
    };
  }
  return null;
}
function dk(e) {
  const { scale: t, fill: n } = e, i = t.options, r = t.getLabels().length, a = i.reverse ? t.max : t.min, o = nk(n, t, a), s = [];
  if (i.grid.circular) {
    const l = t.getPointPositionForValue(0, a);
    return new Lb({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(o)
    });
  }
  for (let l = 0; l < r; ++l)
    s.push(t.getPointPositionForValue(l, o));
  return s;
}
function uh(e, t, n) {
  const i = lk(t), { chart: r, index: a, line: o, scale: s, axis: l } = t, u = o.options, c = u.fill, h = u.backgroundColor, { above: d = h, below: f = h } = c || {}, v = r.getDatasetMeta(a), g = pb(r, v);
  i && o.points.length && (fc(e, n), fk(e, {
    line: o,
    target: i,
    above: d,
    below: f,
    area: n,
    scale: s,
    axis: l,
    clip: g
  }), vc(e));
}
function fk(e, t) {
  const { line: n, target: i, above: r, below: a, area: o, scale: s, clip: l } = t, u = n._loop ? "angle" : t.axis;
  e.save();
  let c = a;
  a !== r && (u === "x" ? (Gg(e, i, o.top), ch(e, {
    line: n,
    target: i,
    color: r,
    scale: s,
    property: u,
    clip: l
  }), e.restore(), e.save(), Gg(e, i, o.bottom)) : u === "y" && (jg(e, i, o.left), ch(e, {
    line: n,
    target: i,
    color: a,
    scale: s,
    property: u,
    clip: l
  }), e.restore(), e.save(), jg(e, i, o.right), c = r)), ch(e, {
    line: n,
    target: i,
    color: c,
    scale: s,
    property: u,
    clip: l
  }), e.restore();
}
function Gg(e, t, n) {
  const { segments: i, points: r } = t;
  let a = !0, o = !1;
  e.beginPath();
  for (const s of i) {
    const { start: l, end: u } = s, c = r[l], h = r[yc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(c.x, n), e.lineTo(c.x, c.y)), o = !!t.pathSegment(e, s, {
      move: o
    }), o ? e.closePath() : e.lineTo(h.x, n);
  }
  e.lineTo(t.first().x, n), e.closePath(), e.clip();
}
function jg(e, t, n) {
  const { segments: i, points: r } = t;
  let a = !0, o = !1;
  e.beginPath();
  for (const s of i) {
    const { start: l, end: u } = s, c = r[l], h = r[yc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(n, c.y), e.lineTo(c.x, c.y)), o = !!t.pathSegment(e, s, {
      move: o
    }), o ? e.closePath() : e.lineTo(n, h.y);
  }
  e.lineTo(n, t.first().y), e.closePath(), e.clip();
}
function ch(e, t) {
  const { line: n, target: i, property: r, color: a, scale: o, clip: s } = t, l = ZT(n, i, r);
  for (const { source: u, target: c, start: h, end: d } of l) {
    const { style: { backgroundColor: f = a } = {} } = u, v = i !== !0;
    e.save(), e.fillStyle = f, vk(e, o, s, v && $d(r, h, d)), e.beginPath();
    const g = !!n.pathSegment(e, u);
    let p;
    if (v) {
      g ? e.closePath() : Xg(e, i, d, r);
      const _ = !!i.pathSegment(e, c, {
        move: g,
        reverse: !0
      });
      p = g && _, p || Xg(e, i, h, r);
    }
    e.closePath(), e.fill(p ? "evenodd" : "nonzero"), e.restore();
  }
}
function vk(e, t, n, i) {
  const r = t.chart.chartArea, { property: a, start: o, end: s } = i || {};
  if (a === "x" || a === "y") {
    let l, u, c, h;
    a === "x" ? (l = o, u = r.top, c = s, h = r.bottom) : (l = r.left, u = o, c = r.right, h = s), e.beginPath(), n && (l = Math.max(l, n.left), c = Math.min(c, n.right), u = Math.max(u, n.top), h = Math.min(h, n.bottom)), e.rect(l, u, c - l, h - u), e.clip();
  }
}
function Xg(e, t, n, i) {
  const r = t.interpolate(n, i);
  r && e.lineTo(r.x, r.y);
}
var pk = {
  id: "filler",
  afterDatasetsUpdate(e, t, n) {
    const i = (e.data.datasets || []).length, r = [];
    let a, o, s, l;
    for (o = 0; o < i; ++o)
      a = e.getDatasetMeta(o), s = a.dataset, l = null, s && s.options && s instanceof mc && (l = {
        visible: e.isDatasetVisible(o),
        index: o,
        fill: JT(s, o, i),
        chart: e,
        axis: a.controller.options.indexAxis,
        scale: a.vScale,
        line: s
      }), a.$filler = l, r.push(l);
    for (o = 0; o < i; ++o)
      l = r[o], !(!l || l.fill === !1) && (l.fill = QT(r, o, n.propagate));
  },
  beforeDraw(e, t, n) {
    const i = n.drawTime === "beforeDraw", r = e.getSortedVisibleDatasetMetas(), a = e.chartArea;
    for (let o = r.length - 1; o >= 0; --o) {
      const s = r[o].$filler;
      s && (s.line.updateControlPoints(a, s.axis), i && s.fill && uh(e.ctx, s, a));
    }
  },
  beforeDatasetsDraw(e, t, n) {
    if (n.drawTime !== "beforeDatasetsDraw")
      return;
    const i = e.getSortedVisibleDatasetMetas();
    for (let r = i.length - 1; r >= 0; --r) {
      const a = i[r].$filler;
      Ug(a) && uh(e.ctx, a, e.chartArea);
    }
  },
  beforeDatasetDraw(e, t, n) {
    const i = t.meta.$filler;
    !Ug(i) || n.drawTime !== "beforeDatasetDraw" || uh(e.ctx, i, e.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const qg = (e, t) => {
  let { boxHeight: n = t, boxWidth: i = t } = e;
  return e.usePointStyle && (n = Math.min(n, t), i = e.pointStyleWidth || Math.min(i, t)), {
    boxWidth: i,
    boxHeight: n,
    itemHeight: Math.max(t, n)
  };
}, gk = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class Zg extends Ci {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, n, i) {
    this.maxWidth = t, this.maxHeight = n, this._margins = i, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let n = Nt(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (n = n.filter((i) => t.filter(i, this.chart.data))), t.sort && (n = n.sort((i, r) => t.sort(i, r, this.chart.data))), this.options.reverse && n.reverse(), this.legendItems = n;
  }
  fit() {
    const { options: t, ctx: n } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const i = t.labels, r = me(i.font), a = r.size, o = this._computeTitleHeight(), { boxWidth: s, itemHeight: l } = qg(i, a);
    let u, c;
    n.font = r.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(o, a, s, l) + 10) : (c = this.maxHeight, u = this._fitCols(o, r, s, l) + 10), this.width = Math.min(u, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, n, i, r) {
    const { ctx: a, maxWidth: o, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [
      0
    ], c = r + s;
    let h = t;
    a.textAlign = "left", a.textBaseline = "middle";
    let d = -1, f = -c;
    return this.legendItems.forEach((v, g) => {
      const p = i + n / 2 + a.measureText(v.text).width;
      (g === 0 || u[u.length - 1] + p + 2 * s > o) && (h += c, u[u.length - (g > 0 ? 0 : 1)] = 0, f += c, d++), l[g] = {
        left: 0,
        top: f,
        row: d,
        width: p,
        height: r
      }, u[u.length - 1] += p + s;
    }), h;
  }
  _fitCols(t, n, i, r) {
    const { ctx: a, maxHeight: o, options: { labels: { padding: s } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = o - t;
    let h = s, d = 0, f = 0, v = 0, g = 0;
    return this.legendItems.forEach((p, _) => {
      const { itemWidth: m, itemHeight: y } = _k(i, n, a, p, r);
      _ > 0 && f + y + 2 * s > c && (h += d + s, u.push({
        width: d,
        height: f
      }), v += d + s, g++, d = f = 0), l[_] = {
        left: v,
        top: f,
        col: g,
        width: m,
        height: y
      }, d = Math.max(d, m), f += y + s;
    }), h += d, u.push({
      width: d,
      height: f
    }), h;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: n, options: { align: i, labels: { padding: r }, rtl: a } } = this, o = Ga(a, this.left, this.width);
    if (this.isHorizontal()) {
      let s = 0, l = pe(i, this.left + r, this.right - this.lineWidths[s]);
      for (const u of n)
        s !== u.row && (s = u.row, l = pe(i, this.left + r, this.right - this.lineWidths[s])), u.top += this.top + t + r, u.left = o.leftForLtr(o.x(l), u.width), l += u.width + r;
    } else {
      let s = 0, l = pe(i, this.top + t + r, this.bottom - this.columnSizes[s].height);
      for (const u of n)
        u.col !== s && (s = u.col, l = pe(i, this.top + t + r, this.bottom - this.columnSizes[s].height)), u.top = l, u.left += this.left + r, u.left = o.leftForLtr(o.x(u.left), u.width), l += u.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      fc(t, this), this._draw(), vc(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: n, lineWidths: i, ctx: r } = this, { align: a, labels: o } = t, s = ee.color, l = Ga(t.rtl, this.left, this.width), u = me(o.font), { padding: c } = o, h = u.size, d = h / 2;
    let f;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = u.string;
    const { boxWidth: v, boxHeight: g, itemHeight: p } = qg(o, h), _ = function(w, M, D) {
      if (isNaN(v) || v <= 0 || isNaN(g) || g < 0)
        return;
      r.save();
      const T = ot(D.lineWidth, 1);
      if (r.fillStyle = ot(D.fillStyle, s), r.lineCap = ot(D.lineCap, "butt"), r.lineDashOffset = ot(D.lineDashOffset, 0), r.lineJoin = ot(D.lineJoin, "miter"), r.lineWidth = T, r.strokeStyle = ot(D.strokeStyle, s), r.setLineDash(ot(D.lineDash, [])), o.usePointStyle) {
        const C = {
          radius: g * Math.SQRT2 / 2,
          pointStyle: D.pointStyle,
          rotation: D.rotation,
          borderWidth: T
        }, k = l.xPlus(w, v / 2), E = M + d;
        ib(r, C, k, E, o.pointStyleWidth && v);
      } else {
        const C = M + Math.max((h - g) / 2, 0), k = l.leftForLtr(w, v), E = Ua(D.borderRadius);
        r.beginPath(), Object.values(E).some((A) => A !== 0) ? bu(r, {
          x: k,
          y: C,
          w: v,
          h: g,
          radius: E
        }) : r.rect(k, C, v, g), r.fill(), T !== 0 && r.stroke();
      }
      r.restore();
    }, m = function(w, M, D) {
      Ts(r, D.text, w, M + p / 2, u, {
        strikethrough: D.hidden,
        textAlign: l.textAlign(D.textAlign)
      });
    }, y = this.isHorizontal(), b = this._computeTitleHeight();
    y ? f = {
      x: pe(a, this.left + c, this.right - i[0]),
      y: this.top + c + b,
      line: 0
    } : f = {
      x: this.left + c,
      y: pe(a, this.top + b + c, this.bottom - n[0].height),
      line: 0
    }, cb(this.ctx, t.textDirection);
    const x = p + c;
    this.legendItems.forEach((w, M) => {
      r.strokeStyle = w.fontColor, r.fillStyle = w.fontColor;
      const D = r.measureText(w.text).width, T = l.textAlign(w.textAlign || (w.textAlign = o.textAlign)), C = v + d + D;
      let k = f.x, E = f.y;
      l.setWidth(this.width), y ? M > 0 && k + C + c > this.right && (E = f.y += x, f.line++, k = f.x = pe(a, this.left + c, this.right - i[f.line])) : M > 0 && E + x > this.bottom && (k = f.x = k + n[f.line].width + c, f.line++, E = f.y = pe(a, this.top + b + c, this.bottom - n[f.line].height));
      const A = l.x(k);
      if (_(A, E, w), k = V2(T, k + v + d, y ? k + C : this.right, t.rtl), m(l.x(k), E, w), y)
        f.x += C + c;
      else if (typeof w.text != "string") {
        const L = u.lineHeight;
        f.y += Ob(w, L) + c;
      } else
        f.y += x;
    }), hb(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, n = t.title, i = me(n.font), r = pn(n.padding);
    if (!n.display)
      return;
    const a = Ga(t.rtl, this.left, this.width), o = this.ctx, s = n.position, l = i.size / 2, u = r.top + l;
    let c, h = this.left, d = this.width;
    if (this.isHorizontal())
      d = Math.max(...this.lineWidths), c = this.top + u, h = pe(t.align, h, this.right - d);
    else {
      const v = this.columnSizes.reduce((g, p) => Math.max(g, p.height), 0);
      c = u + pe(t.align, this.top, this.bottom - v - t.labels.padding - this._computeTitleHeight());
    }
    const f = pe(s, h, h + d);
    o.textAlign = a.textAlign(nv(s)), o.textBaseline = "middle", o.strokeStyle = n.color, o.fillStyle = n.color, o.font = i.string, Ts(o, n.text, f, c, i);
  }
  _computeTitleHeight() {
    const t = this.options.title, n = me(t.font), i = pn(t.padding);
    return t.display ? n.lineHeight + i.height : 0;
  }
  _getLegendItemAt(t, n) {
    let i, r, a;
    if (pi(t, this.left, this.right) && pi(n, this.top, this.bottom)) {
      for (a = this.legendHitBoxes, i = 0; i < a.length; ++i)
        if (r = a[i], pi(t, r.left, r.left + r.width) && pi(n, r.top, r.top + r.height))
          return this.legendItems[i];
    }
    return null;
  }
  handleEvent(t) {
    const n = this.options;
    if (!bk(t.type, n))
      return;
    const i = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const r = this._hoveredItem, a = gk(r, i);
      r && !a && Nt(n.onLeave, [
        t,
        r,
        this
      ], this), this._hoveredItem = i, i && !a && Nt(n.onHover, [
        t,
        i,
        this
      ], this);
    } else i && Nt(n.onClick, [
      t,
      i,
      this
    ], this);
  }
}
function _k(e, t, n, i, r) {
  const a = mk(i, e, t, n), o = yk(r, i, t.lineHeight);
  return {
    itemWidth: a,
    itemHeight: o
  };
}
function mk(e, t, n, i) {
  let r = e.text;
  return r && typeof r != "string" && (r = r.reduce((a, o) => a.length > o.length ? a : o)), t + n.size / 2 + i.measureText(r).width;
}
function yk(e, t, n) {
  let i = e;
  return typeof t.text != "string" && (i = Ob(t, n)), i;
}
function Ob(e, t) {
  const n = e.text ? e.text.length : 0;
  return t * n;
}
function bk(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var dv = {
  id: "legend",
  _element: Zg,
  start(e, t, n) {
    const i = e.legend = new Zg({
      ctx: e.ctx,
      options: n,
      chart: e
    });
    fn.configure(e, i, n), fn.addBox(e, i);
  },
  stop(e) {
    fn.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, n) {
    const i = e.legend;
    fn.configure(e, i, n), i.options = n;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, n) {
      const i = t.datasetIndex, r = n.chart;
      r.isDatasetVisible(i) ? (r.hide(i), t.hidden = !0) : (r.show(i), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: n, pointStyle: i, textAlign: r, color: a, useBorderRadius: o, borderRadius: s } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const u = l.controller.getStyle(n ? 0 : void 0), c = pn(u.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: u.backgroundColor,
            fontColor: a,
            hidden: !l.visible,
            lineCap: u.borderCapStyle,
            lineDash: u.borderDash,
            lineDashOffset: u.borderDashOffset,
            lineJoin: u.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: u.borderColor,
            pointStyle: i || u.pointStyle,
            rotation: u.rotation,
            textAlign: r || u.textAlign,
            borderRadius: o && (s || u.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class Ib extends Ci {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, n) {
    const i = this.options;
    if (this.left = 0, this.top = 0, !i.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = n;
    const r = ie(i.text) ? i.text.length : 1;
    this._padding = pn(i.padding);
    const a = r * me(i.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = a : this.width = a;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: n, left: i, bottom: r, right: a, options: o } = this, s = o.align;
    let l = 0, u, c, h;
    return this.isHorizontal() ? (c = pe(s, i, a), h = n + t, u = a - i) : (o.position === "left" ? (c = i + t, h = pe(s, r, n), l = Ct * -0.5) : (c = a - t, h = pe(s, n, r), l = Ct * 0.5), u = r - n), {
      titleX: c,
      titleY: h,
      maxWidth: u,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, n = this.options;
    if (!n.display)
      return;
    const i = me(n.font), a = i.lineHeight / 2 + this._padding.top, { titleX: o, titleY: s, maxWidth: l, rotation: u } = this._drawArgs(a);
    Ts(t, n.text, 0, 0, i, {
      color: n.color,
      maxWidth: l,
      rotation: u,
      textAlign: nv(n.align),
      textBaseline: "middle",
      translation: [
        o,
        s
      ]
    });
  }
}
function xk(e, t) {
  const n = new Ib({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  fn.configure(e, n, t), fn.addBox(e, n), e.titleBlock = n;
}
var Rb = {
  id: "title",
  _element: Ib,
  start(e, t, n) {
    xk(e, n);
  },
  stop(e) {
    const t = e.titleBlock;
    fn.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, n) {
    const i = e.titleBlock;
    fn.configure(e, i, n), i.options = n;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Zo = {
  average(e) {
    if (!e.length)
      return !1;
    let t, n, i = /* @__PURE__ */ new Set(), r = 0, a = 0;
    for (t = 0, n = e.length; t < n; ++t) {
      const s = e[t].element;
      if (s && s.hasValue()) {
        const l = s.tooltipPosition();
        i.add(l.x), r += l.y, ++a;
      }
    }
    return a === 0 || i.size === 0 ? !1 : {
      x: [
        ...i
      ].reduce((s, l) => s + l) / i.size,
      y: r / a
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let n = t.x, i = t.y, r = Number.POSITIVE_INFINITY, a, o, s;
    for (a = 0, o = e.length; a < o; ++a) {
      const l = e[a].element;
      if (l && l.hasValue()) {
        const u = l.getCenterPoint(), c = Rd(t, u);
        c < r && (r = c, s = l);
      }
    }
    if (s) {
      const l = s.tooltipPosition();
      n = l.x, i = l.y;
    }
    return {
      x: n,
      y: i
    };
  }
};
function $n(e, t) {
  return t && (ie(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function ci(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function wk(e, t) {
  const { element: n, datasetIndex: i, index: r } = t, a = e.getDatasetMeta(i).controller, { label: o, value: s } = a.getLabelAndValue(r);
  return {
    chart: e,
    label: o,
    parsed: a.getParsed(r),
    raw: e.data.datasets[i].data[r],
    formattedValue: s,
    dataset: a.getDataset(),
    dataIndex: r,
    datasetIndex: i,
    element: n
  };
}
function Kg(e, t) {
  const n = e.chart.ctx, { body: i, footer: r, title: a } = e, { boxWidth: o, boxHeight: s } = t, l = me(t.bodyFont), u = me(t.titleFont), c = me(t.footerFont), h = a.length, d = r.length, f = i.length, v = pn(t.padding);
  let g = v.height, p = 0, _ = i.reduce((b, x) => b + x.before.length + x.lines.length + x.after.length, 0);
  if (_ += e.beforeBody.length + e.afterBody.length, h && (g += h * u.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom), _) {
    const b = t.displayColors ? Math.max(s, l.lineHeight) : l.lineHeight;
    g += f * b + (_ - f) * l.lineHeight + (_ - 1) * t.bodySpacing;
  }
  d && (g += t.footerMarginTop + d * c.lineHeight + (d - 1) * t.footerSpacing);
  let m = 0;
  const y = function(b) {
    p = Math.max(p, n.measureText(b).width + m);
  };
  return n.save(), n.font = u.string, kt(e.title, y), n.font = l.string, kt(e.beforeBody.concat(e.afterBody), y), m = t.displayColors ? o + 2 + t.boxPadding : 0, kt(i, (b) => {
    kt(b.before, y), kt(b.lines, y), kt(b.after, y);
  }), m = 0, n.font = c.string, kt(e.footer, y), n.restore(), p += v.width, {
    width: p,
    height: g
  };
}
function Sk(e, t) {
  const { y: n, height: i } = t;
  return n < i / 2 ? "top" : n > e.height - i / 2 ? "bottom" : "center";
}
function Mk(e, t, n, i) {
  const { x: r, width: a } = i, o = n.caretSize + n.caretPadding;
  if (e === "left" && r + a + o > t.width || e === "right" && r - a - o < 0)
    return !0;
}
function Dk(e, t, n, i) {
  const { x: r, width: a } = n, { width: o, chartArea: { left: s, right: l } } = e;
  let u = "center";
  return i === "center" ? u = r <= (s + l) / 2 ? "left" : "right" : r <= a / 2 ? u = "left" : r >= o - a / 2 && (u = "right"), Mk(u, e, t, n) && (u = "center"), u;
}
function Qg(e, t, n) {
  const i = n.yAlign || t.yAlign || Sk(e, n);
  return {
    xAlign: n.xAlign || t.xAlign || Dk(e, t, n, i),
    yAlign: i
  };
}
function Tk(e, t) {
  let { x: n, width: i } = e;
  return t === "right" ? n -= i : t === "center" && (n -= i / 2), n;
}
function kk(e, t, n) {
  let { y: i, height: r } = e;
  return t === "top" ? i += n : t === "bottom" ? i -= r + n : i -= r / 2, i;
}
function Jg(e, t, n, i) {
  const { caretSize: r, caretPadding: a, cornerRadius: o } = e, { xAlign: s, yAlign: l } = n, u = r + a, { topLeft: c, topRight: h, bottomLeft: d, bottomRight: f } = Ua(o);
  let v = Tk(t, s);
  const g = kk(t, l, u);
  return l === "center" ? s === "left" ? v += u : s === "right" && (v -= u) : s === "left" ? v -= Math.max(c, d) + r : s === "right" && (v += Math.max(h, f) + r), {
    x: _e(v, 0, i.width - t.width),
    y: _e(g, 0, i.height - t.height)
  };
}
function dl(e, t, n) {
  const i = pn(n.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - i.right : e.x + i.left;
}
function t_(e) {
  return $n([], ci(e));
}
function Ck(e, t, n) {
  return la(e, {
    tooltip: t,
    tooltipItems: n,
    type: "tooltip"
  });
}
function e_(e, t) {
  const n = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return n ? e.override(n) : e;
}
const Nb = {
  beforeTitle: ii,
  title(e) {
    if (e.length > 0) {
      const t = e[0], n = t.chart.data.labels, i = n ? n.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (i > 0 && t.dataIndex < i)
        return n[t.dataIndex];
    }
    return "";
  },
  afterTitle: ii,
  beforeBody: ii,
  beforeLabel: ii,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const n = e.formattedValue;
    return Dt(n) || (t += n), t;
  },
  labelColor(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: n.borderColor,
      backgroundColor: n.backgroundColor,
      borderWidth: n.borderWidth,
      borderDash: n.borderDash,
      borderDashOffset: n.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const n = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: n.pointStyle,
      rotation: n.rotation
    };
  },
  afterLabel: ii,
  afterBody: ii,
  beforeFooter: ii,
  footer: ii,
  afterFooter: ii
};
function Ie(e, t, n, i) {
  const r = e[t].call(n, i);
  return typeof r > "u" ? Nb[t].call(n, i) : r;
}
class n_ extends Ci {
  static positioners = Zo;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const n = this.chart, i = this.options.setContext(this.getContext()), r = i.enabled && n.options.animation && i.animations, a = new gb(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(a)), a;
  }
  getContext() {
    return this.$context || (this.$context = Ck(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, n) {
    const { callbacks: i } = n, r = Ie(i, "beforeTitle", this, t), a = Ie(i, "title", this, t), o = Ie(i, "afterTitle", this, t);
    let s = [];
    return s = $n(s, ci(r)), s = $n(s, ci(a)), s = $n(s, ci(o)), s;
  }
  getBeforeBody(t, n) {
    return t_(Ie(n.callbacks, "beforeBody", this, t));
  }
  getBody(t, n) {
    const { callbacks: i } = n, r = [];
    return kt(t, (a) => {
      const o = {
        before: [],
        lines: [],
        after: []
      }, s = e_(i, a);
      $n(o.before, ci(Ie(s, "beforeLabel", this, a))), $n(o.lines, Ie(s, "label", this, a)), $n(o.after, ci(Ie(s, "afterLabel", this, a))), r.push(o);
    }), r;
  }
  getAfterBody(t, n) {
    return t_(Ie(n.callbacks, "afterBody", this, t));
  }
  getFooter(t, n) {
    const { callbacks: i } = n, r = Ie(i, "beforeFooter", this, t), a = Ie(i, "footer", this, t), o = Ie(i, "afterFooter", this, t);
    let s = [];
    return s = $n(s, ci(r)), s = $n(s, ci(a)), s = $n(s, ci(o)), s;
  }
  _createItems(t) {
    const n = this._active, i = this.chart.data, r = [], a = [], o = [];
    let s = [], l, u;
    for (l = 0, u = n.length; l < u; ++l)
      s.push(wk(this.chart, n[l]));
    return t.filter && (s = s.filter((c, h, d) => t.filter(c, h, d, i))), t.itemSort && (s = s.sort((c, h) => t.itemSort(c, h, i))), kt(s, (c) => {
      const h = e_(t.callbacks, c);
      r.push(Ie(h, "labelColor", this, c)), a.push(Ie(h, "labelPointStyle", this, c)), o.push(Ie(h, "labelTextColor", this, c));
    }), this.labelColors = r, this.labelPointStyles = a, this.labelTextColors = o, this.dataPoints = s, s;
  }
  update(t, n) {
    const i = this.options.setContext(this.getContext()), r = this._active;
    let a, o = [];
    if (!r.length)
      this.opacity !== 0 && (a = {
        opacity: 0
      });
    else {
      const s = Zo[i.position].call(this, r, this._eventPosition);
      o = this._createItems(i), this.title = this.getTitle(o, i), this.beforeBody = this.getBeforeBody(o, i), this.body = this.getBody(o, i), this.afterBody = this.getAfterBody(o, i), this.footer = this.getFooter(o, i);
      const l = this._size = Kg(this, i), u = Object.assign({}, s, l), c = Qg(this.chart, i, u), h = Jg(i, u, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, a = {
        opacity: 1,
        x: h.x,
        y: h.y,
        width: l.width,
        height: l.height,
        caretX: s.x,
        caretY: s.y
      };
    }
    this._tooltipItems = o, this.$context = void 0, a && this._resolveAnimations().update(this, a), t && i.external && i.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: n
    });
  }
  drawCaret(t, n, i, r) {
    const a = this.getCaretPosition(t, i, r);
    n.lineTo(a.x1, a.y1), n.lineTo(a.x2, a.y2), n.lineTo(a.x3, a.y3);
  }
  getCaretPosition(t, n, i) {
    const { xAlign: r, yAlign: a } = this, { caretSize: o, cornerRadius: s } = i, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: h } = Ua(s), { x: d, y: f } = t, { width: v, height: g } = n;
    let p, _, m, y, b, x;
    return a === "center" ? (b = f + g / 2, r === "left" ? (p = d, _ = p - o, y = b + o, x = b - o) : (p = d + v, _ = p + o, y = b - o, x = b + o), m = p) : (r === "left" ? _ = d + Math.max(l, c) + o : r === "right" ? _ = d + v - Math.max(u, h) - o : _ = this.caretX, a === "top" ? (y = f, b = y - o, p = _ - o, m = _ + o) : (y = f + g, b = y + o, p = _ + o, m = _ - o), x = y), {
      x1: p,
      x2: _,
      x3: m,
      y1: y,
      y2: b,
      y3: x
    };
  }
  drawTitle(t, n, i) {
    const r = this.title, a = r.length;
    let o, s, l;
    if (a) {
      const u = Ga(i.rtl, this.x, this.width);
      for (t.x = dl(this, i.titleAlign, i), n.textAlign = u.textAlign(i.titleAlign), n.textBaseline = "middle", o = me(i.titleFont), s = i.titleSpacing, n.fillStyle = i.titleColor, n.font = o.string, l = 0; l < a; ++l)
        n.fillText(r[l], u.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + s, l + 1 === a && (t.y += i.titleMarginBottom - s);
    }
  }
  _drawColorBox(t, n, i, r, a) {
    const o = this.labelColors[i], s = this.labelPointStyles[i], { boxHeight: l, boxWidth: u } = a, c = me(a.bodyFont), h = dl(this, "left", a), d = r.x(h), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, v = n.y + f;
    if (a.usePointStyle) {
      const g = {
        radius: Math.min(u, l) / 2,
        pointStyle: s.pointStyle,
        rotation: s.rotation,
        borderWidth: 1
      }, p = r.leftForLtr(d, u) + u / 2, _ = v + l / 2;
      t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, Fd(t, g, p, _), t.strokeStyle = o.borderColor, t.fillStyle = o.backgroundColor, Fd(t, g, p, _);
    } else {
      t.lineWidth = dt(o.borderWidth) ? Math.max(...Object.values(o.borderWidth)) : o.borderWidth || 1, t.strokeStyle = o.borderColor, t.setLineDash(o.borderDash || []), t.lineDashOffset = o.borderDashOffset || 0;
      const g = r.leftForLtr(d, u), p = r.leftForLtr(r.xPlus(d, 1), u - 2), _ = Ua(o.borderRadius);
      Object.values(_).some((m) => m !== 0) ? (t.beginPath(), t.fillStyle = a.multiKeyBackground, bu(t, {
        x: g,
        y: v,
        w: u,
        h: l,
        radius: _
      }), t.fill(), t.stroke(), t.fillStyle = o.backgroundColor, t.beginPath(), bu(t, {
        x: p,
        y: v + 1,
        w: u - 2,
        h: l - 2,
        radius: _
      }), t.fill()) : (t.fillStyle = a.multiKeyBackground, t.fillRect(g, v, u, l), t.strokeRect(g, v, u, l), t.fillStyle = o.backgroundColor, t.fillRect(p, v + 1, u - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[i];
  }
  drawBody(t, n, i) {
    const { body: r } = this, { bodySpacing: a, bodyAlign: o, displayColors: s, boxHeight: l, boxWidth: u, boxPadding: c } = i, h = me(i.bodyFont);
    let d = h.lineHeight, f = 0;
    const v = Ga(i.rtl, this.x, this.width), g = function(D) {
      n.fillText(D, v.x(t.x + f), t.y + d / 2), t.y += d + a;
    }, p = v.textAlign(o);
    let _, m, y, b, x, w, M;
    for (n.textAlign = o, n.textBaseline = "middle", n.font = h.string, t.x = dl(this, p, i), n.fillStyle = i.bodyColor, kt(this.beforeBody, g), f = s && p !== "right" ? o === "center" ? u / 2 + c : u + 2 + c : 0, b = 0, w = r.length; b < w; ++b) {
      for (_ = r[b], m = this.labelTextColors[b], n.fillStyle = m, kt(_.before, g), y = _.lines, s && y.length && (this._drawColorBox(n, t, b, v, i), d = Math.max(h.lineHeight, l)), x = 0, M = y.length; x < M; ++x)
        g(y[x]), d = h.lineHeight;
      kt(_.after, g);
    }
    f = 0, d = h.lineHeight, kt(this.afterBody, g), t.y -= a;
  }
  drawFooter(t, n, i) {
    const r = this.footer, a = r.length;
    let o, s;
    if (a) {
      const l = Ga(i.rtl, this.x, this.width);
      for (t.x = dl(this, i.footerAlign, i), t.y += i.footerMarginTop, n.textAlign = l.textAlign(i.footerAlign), n.textBaseline = "middle", o = me(i.footerFont), n.fillStyle = i.footerColor, n.font = o.string, s = 0; s < a; ++s)
        n.fillText(r[s], l.x(t.x), t.y + o.lineHeight / 2), t.y += o.lineHeight + i.footerSpacing;
    }
  }
  drawBackground(t, n, i, r) {
    const { xAlign: a, yAlign: o } = this, { x: s, y: l } = t, { width: u, height: c } = i, { topLeft: h, topRight: d, bottomLeft: f, bottomRight: v } = Ua(r.cornerRadius);
    n.fillStyle = r.backgroundColor, n.strokeStyle = r.borderColor, n.lineWidth = r.borderWidth, n.beginPath(), n.moveTo(s + h, l), o === "top" && this.drawCaret(t, n, i, r), n.lineTo(s + u - d, l), n.quadraticCurveTo(s + u, l, s + u, l + d), o === "center" && a === "right" && this.drawCaret(t, n, i, r), n.lineTo(s + u, l + c - v), n.quadraticCurveTo(s + u, l + c, s + u - v, l + c), o === "bottom" && this.drawCaret(t, n, i, r), n.lineTo(s + f, l + c), n.quadraticCurveTo(s, l + c, s, l + c - f), o === "center" && a === "left" && this.drawCaret(t, n, i, r), n.lineTo(s, l + h), n.quadraticCurveTo(s, l, s + h, l), n.closePath(), n.fill(), r.borderWidth > 0 && n.stroke();
  }
  _updateAnimationTarget(t) {
    const n = this.chart, i = this.$animations, r = i && i.x, a = i && i.y;
    if (r || a) {
      const o = Zo[t.position].call(this, this._active, this._eventPosition);
      if (!o)
        return;
      const s = this._size = Kg(this, t), l = Object.assign({}, o, this._size), u = Qg(n, t, l), c = Jg(t, l, u, n);
      (r._to !== c.x || a._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = s.width, this.height = s.height, this.caretX = o.x, this.caretY = o.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const n = this.options.setContext(this.getContext());
    let i = this.opacity;
    if (!i)
      return;
    this._updateAnimationTarget(n);
    const r = {
      width: this.width,
      height: this.height
    }, a = {
      x: this.x,
      y: this.y
    };
    i = Math.abs(i) < 1e-3 ? 0 : i;
    const o = pn(n.padding), s = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    n.enabled && s && (t.save(), t.globalAlpha = i, this.drawBackground(a, t, r, n), cb(t, n.textDirection), a.y += o.top, this.drawTitle(a, t, n), this.drawBody(a, t, n), this.drawFooter(a, t, n), hb(t, n.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, n) {
    const i = this._active, r = t.map(({ datasetIndex: s, index: l }) => {
      const u = this.chart.getDatasetMeta(s);
      if (!u)
        throw new Error("Cannot find a dataset at index " + s);
      return {
        datasetIndex: s,
        element: u.data[l],
        index: l
      };
    }), a = !_u(i, r), o = this._positionChanged(r, n);
    (a || o) && (this._active = r, this._eventPosition = n, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, n, i = !0) {
    if (n && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, a = this._active || [], o = this._getActiveElements(t, a, n, i), s = this._positionChanged(o, t), l = n || !_u(o, a) || s;
    return l && (this._active = o, (r.enabled || r.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, n))), l;
  }
  _getActiveElements(t, n, i, r) {
    const a = this.options;
    if (t.type === "mouseout")
      return [];
    if (!r)
      return n.filter((s) => this.chart.data.datasets[s.datasetIndex] && this.chart.getDatasetMeta(s.datasetIndex).controller.getParsed(s.index) !== void 0);
    const o = this.chart.getElementsAtEventForMode(t, a.mode, a, i);
    return a.reverse && o.reverse(), o;
  }
  _positionChanged(t, n) {
    const { caretX: i, caretY: r, options: a } = this, o = Zo[a.position].call(this, t, n);
    return o !== !1 && (i !== o.x || r !== o.y);
  }
}
var fv = {
  id: "tooltip",
  _element: n_,
  positioners: Zo,
  afterInit(e, t, n) {
    n && (e.tooltip = new n_({
      chart: e,
      options: n
    }));
  },
  beforeUpdate(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  reset(e, t, n) {
    e.tooltip && e.tooltip.initialize(n);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const n = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...n,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", n);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const n = t.replay;
      e.tooltip.handleEvent(t.event, n, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Nb
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const Pk = (e, t, n, i) => (typeof t == "string" ? (n = e.push(t) - 1, i.unshift({
  index: n,
  label: t
})) : isNaN(t) && (n = null), n);
function Ak(e, t, n, i) {
  const r = e.indexOf(t);
  if (r === -1)
    return Pk(e, t, n, i);
  const a = e.lastIndexOf(t);
  return r !== a ? n : r;
}
const Ek = (e, t) => e === null ? null : _e(Math.round(e), 0, t);
function i_(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Fb extends lo {
  static id = "category";
  static defaults = {
    ticks: {
      callback: i_
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const n = this._addedLabels;
    if (n.length) {
      const i = this.getLabels();
      for (const { index: r, label: a } of n)
        i[r] === a && i.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, n) {
    if (Dt(t))
      return null;
    const i = this.getLabels();
    return n = isFinite(n) && i[n] === t ? n : Ak(i, t, ot(n, t), this._addedLabels), Ek(n, i.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: n } = this.getUserBounds();
    let { min: i, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (i = 0), n || (r = this.getLabels().length - 1)), this.min = i, this.max = r;
  }
  buildTicks() {
    const t = this.min, n = this.max, i = this.options.offset, r = [];
    let a = this.getLabels();
    a = t === 0 && n === a.length - 1 ? a : a.slice(t, n + 1), this._valueRange = Math.max(a.length - (i ? 0 : 1), 1), this._startValue = this.min - (i ? 0.5 : 0);
    for (let o = t; o <= n; o++)
      r.push({
        value: o
      });
    return r;
  }
  getLabelForValue(t) {
    return i_.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const n = this.ticks;
    return t < 0 || t > n.length - 1 ? null : this.getPixelForValue(n[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function Lk(e, t) {
  const n = [], { bounds: r, step: a, min: o, max: s, precision: l, count: u, maxTicks: c, maxDigits: h, includeBounds: d } = e, f = a || 1, v = c - 1, { min: g, max: p } = t, _ = !Dt(o), m = !Dt(s), y = !Dt(u), b = (p - g) / (h + 1);
  let x = Jp((p - g) / v / f) * f, w, M, D, T;
  if (x < 1e-14 && !_ && !m)
    return [
      {
        value: g
      },
      {
        value: p
      }
    ];
  T = Math.ceil(p / x) - Math.floor(g / x), T > v && (x = Jp(T * x / v / f) * f), Dt(l) || (w = Math.pow(10, l), x = Math.ceil(x * w) / w), r === "ticks" ? (M = Math.floor(g / x) * x, D = Math.ceil(p / x) * x) : (M = g, D = p), _ && m && a && E2((s - o) / a, x / 1e3) ? (T = Math.round(Math.min((s - o) / x, c)), x = (s - o) / T, M = o, D = s) : y ? (M = _ ? o : M, D = m ? s : D, T = u - 1, x = (D - M) / T) : (T = (D - M) / x, ss(T, Math.round(T), x / 1e3) ? T = Math.round(T) : T = Math.ceil(T));
  const C = Math.max(tg(x), tg(M));
  w = Math.pow(10, Dt(l) ? C : l), M = Math.round(M * w) / w, D = Math.round(D * w) / w;
  let k = 0;
  for (_ && (d && M !== o ? (n.push({
    value: o
  }), M < o && k++, ss(Math.round((M + k * x) * w) / w, o, r_(o, b, e)) && k++) : M < o && k++); k < T; ++k) {
    const E = Math.round((M + k * x) * w) / w;
    if (m && E > s)
      break;
    n.push({
      value: E
    });
  }
  return m && d && D !== s ? n.length && ss(n[n.length - 1].value, s, r_(s, b, e)) ? n[n.length - 1].value = s : n.push({
    value: s
  }) : (!m || D === s) && n.push({
    value: D
  }), n;
}
function r_(e, t, { horizontal: n, minRotation: i }) {
  const r = vi(i), a = (n ? Math.sin(r) : Math.cos(r)) || 1e-3, o = 0.75 * t * ("" + e).length;
  return Math.min(t / a, o);
}
class Ok extends lo {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, n) {
    return Dt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: n, maxDefined: i } = this.getUserBounds();
    let { min: r, max: a } = this;
    const o = (l) => r = n ? r : l, s = (l) => a = i ? a : l;
    if (t) {
      const l = jn(r), u = jn(a);
      l < 0 && u < 0 ? s(0) : l > 0 && u > 0 && o(0);
    }
    if (r === a) {
      let l = a === 0 ? 1 : Math.abs(a * 0.05);
      s(a + l), t || o(r - l);
    }
    this.min = r, this.max = a;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: n, stepSize: i } = t, r;
    return i ? (r = Math.ceil(this.max / i) - Math.floor(this.min / i) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${i} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), n = n || 11), n && (r = Math.min(n, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, n = t.ticks;
    let i = this.getTickLimit();
    i = Math.max(2, i);
    const r = {
      maxTicks: i,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: n.precision,
      step: n.stepSize,
      count: n.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: n.minRotation || 0,
      includeBounds: n.includeBounds !== !1
    }, a = this._range || this, o = Lk(r, a);
    return t.bounds === "ticks" && L2(o, this, "value"), t.reverse ? (o.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), o;
  }
  configure() {
    const t = this.ticks;
    let n = this.min, i = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const r = (i - n) / Math.max(t.length - 1, 1) / 2;
      n -= r, i += r;
    }
    this._startValue = n, this._endValue = i, this._valueRange = i - n;
  }
  getLabelForValue(t) {
    return rv(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Bb extends Ok {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: nb.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: n } = this.getMinMax(!0);
    this.min = we(t) ? t : 0, this.max = we(n) ? n : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), n = t ? this.width : this.height, i = vi(this.options.ticks.minRotation), r = (t ? Math.sin(i) : Math.cos(i)) || 1e-3, a = this._resolveTickFontOptions(0);
    return Math.ceil(n / Math.min(40, a.lineHeight / r));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const bc = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, He = /* @__PURE__ */ Object.keys(bc);
function a_(e, t) {
  return e - t;
}
function o_(e, t) {
  if (Dt(t))
    return null;
  const n = e._adapter, { parser: i, round: r, isoWeekday: a } = e._parseOpts;
  let o = t;
  return typeof i == "function" && (o = i(o)), we(o) || (o = typeof i == "string" ? n.parse(o, i) : n.parse(o)), o === null ? null : (r && (o = r === "week" && (Ss(a) || a === !0) ? n.startOf(o, "isoWeek", a) : n.startOf(o, r)), +o);
}
function s_(e, t, n, i) {
  const r = He.length;
  for (let a = He.indexOf(e); a < r - 1; ++a) {
    const o = bc[He[a]], s = o.steps ? o.steps : Number.MAX_SAFE_INTEGER;
    if (o.common && Math.ceil((n - t) / (s * o.size)) <= i)
      return He[a];
  }
  return He[r - 1];
}
function Ik(e, t, n, i, r) {
  for (let a = He.length - 1; a >= He.indexOf(n); a--) {
    const o = He[a];
    if (bc[o].common && e._adapter.diff(r, i, o) >= t - 1)
      return o;
  }
  return He[n ? He.indexOf(n) : 0];
}
function Rk(e) {
  for (let t = He.indexOf(e) + 1, n = He.length; t < n; ++t)
    if (bc[He[t]].common)
      return He[t];
}
function l_(e, t, n) {
  if (!n)
    e[t] = !0;
  else if (n.length) {
    const { lo: i, hi: r } = ev(n, t), a = n[i] >= t ? n[i] : n[r];
    e[a] = !0;
  }
}
function Nk(e, t, n, i) {
  const r = e._adapter, a = +r.startOf(t[0].value, i), o = t[t.length - 1].value;
  let s, l;
  for (s = a; s <= o; s = +r.add(s, 1, i))
    l = n[s], l >= 0 && (t[l].major = !0);
  return t;
}
function u_(e, t, n) {
  const i = [], r = {}, a = t.length;
  let o, s;
  for (o = 0; o < a; ++o)
    s = t[o], r[s] = o, i.push({
      value: s,
      major: !1
    });
  return a === 0 || !n ? i : Nk(e, i, r, n);
}
class c_ extends lo {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, n = {}) {
    const i = t.time || (t.time = {}), r = this._adapter = new mD._date(t.adapters.date);
    r.init(n), os(i.displayFormats, r.formats()), this._parseOpts = {
      parser: i.parser,
      round: i.round,
      isoWeekday: i.isoWeekday
    }, super.init(t), this._normalized = n.normalized;
  }
  parse(t, n) {
    return t === void 0 ? null : o_(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, n = this._adapter, i = t.time.unit || "day";
    let { min: r, max: a, minDefined: o, maxDefined: s } = this.getUserBounds();
    function l(u) {
      !o && !isNaN(u.min) && (r = Math.min(r, u.min)), !s && !isNaN(u.max) && (a = Math.max(a, u.max));
    }
    (!o || !s) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), r = we(r) && !isNaN(r) ? r : +n.startOf(Date.now(), i), a = we(a) && !isNaN(a) ? a : +n.endOf(Date.now(), i) + 1, this.min = Math.min(r, a - 1), this.max = Math.max(r + 1, a);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let n = Number.POSITIVE_INFINITY, i = Number.NEGATIVE_INFINITY;
    return t.length && (n = t[0], i = t[t.length - 1]), {
      min: n,
      max: i
    };
  }
  buildTicks() {
    const t = this.options, n = t.time, i = t.ticks, r = i.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const a = this.min, o = this.max, s = F2(r, a, o);
    return this._unit = n.unit || (i.autoSkip ? s_(n.minUnit, this.min, this.max, this._getLabelCapacity(a)) : Ik(this, s.length, n.minUnit, this.min, this.max)), this._majorUnit = !i.major.enabled || this._unit === "year" ? void 0 : Rk(this._unit), this.initOffsets(r), t.reverse && s.reverse(), u_(this, s, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let n = 0, i = 0, r, a;
    this.options.offset && t.length && (r = this.getDecimalForValue(t[0]), t.length === 1 ? n = 1 - r : n = (this.getDecimalForValue(t[1]) - r) / 2, a = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? i = a : i = (a - this.getDecimalForValue(t[t.length - 2])) / 2);
    const o = t.length < 3 ? 0.5 : 0.25;
    n = _e(n, 0, o), i = _e(i, 0, o), this._offsets = {
      start: n,
      end: i,
      factor: 1 / (n + 1 + i)
    };
  }
  _generate() {
    const t = this._adapter, n = this.min, i = this.max, r = this.options, a = r.time, o = a.unit || s_(a.minUnit, n, i, this._getLabelCapacity(n)), s = ot(r.ticks.stepSize, 1), l = o === "week" ? a.isoWeekday : !1, u = Ss(l) || l === !0, c = {};
    let h = n, d, f;
    if (u && (h = +t.startOf(h, "isoWeek", l)), h = +t.startOf(h, u ? "day" : o), t.diff(i, n, o) > 1e5 * s)
      throw new Error(n + " and " + i + " are too far apart with stepSize of " + s + " " + o);
    const v = r.ticks.source === "data" && this.getDataTimestamps();
    for (d = h, f = 0; d < i; d = +t.add(d, s, o), f++)
      l_(c, d, v);
    return (d === i || r.bounds === "ticks" || f === 1) && l_(c, d, v), Object.keys(c).sort(a_).map((g) => +g);
  }
  getLabelForValue(t) {
    const n = this._adapter, i = this.options.time;
    return i.tooltipFormat ? n.format(t, i.tooltipFormat) : n.format(t, i.displayFormats.datetime);
  }
  format(t, n) {
    const r = this.options.time.displayFormats, a = this._unit, o = n || r[a];
    return this._adapter.format(t, o);
  }
  _tickFormatFunction(t, n, i, r) {
    const a = this.options, o = a.ticks.callback;
    if (o)
      return Nt(o, [
        t,
        n,
        i
      ], this);
    const s = a.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && s[l], h = u && s[u], d = i[n], f = u && h && d && d.major;
    return this._adapter.format(t, r || (f ? h : c));
  }
  generateTickLabels(t) {
    let n, i, r;
    for (n = 0, i = t.length; n < i; ++n)
      r = t[n], r.label = this._tickFormatFunction(r.value, n, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const n = this._offsets, i = this.getDecimalForValue(t);
    return this.getPixelForDecimal((n.start + i) * n.factor);
  }
  getValueForPixel(t) {
    const n = this._offsets, i = this.getDecimalForPixel(t) / n.factor - n.end;
    return this.min + i * (this.max - this.min);
  }
  _getLabelSize(t) {
    const n = this.options.ticks, i = this.ctx.measureText(t).width, r = vi(this.isHorizontal() ? n.maxRotation : n.minRotation), a = Math.cos(r), o = Math.sin(r), s = this._resolveTickFontOptions(0).size;
    return {
      w: i * a + s * o,
      h: i * o + s * a
    };
  }
  _getLabelCapacity(t) {
    const n = this.options.time, i = n.displayFormats, r = i[n.unit] || i.millisecond, a = this._tickFormatFunction(t, 0, u_(this, [
      t
    ], this._majorUnit), r), o = this._getLabelSize(a), s = Math.floor(this.isHorizontal() ? this.width / o.w : this.height / o.h) - 1;
    return s > 0 ? s : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], n, i;
    if (t.length)
      return t;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (n = 0, i = r.length; n < i; ++n)
      t = t.concat(r[n].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let n, i;
    if (t.length)
      return t;
    const r = this.getLabels();
    for (n = 0, i = r.length; n < i; ++n)
      t.push(o_(this, r[n]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return Jy(t.sort(a_));
  }
}
function fl(e, t, n) {
  let i = 0, r = e.length - 1, a, o, s, l;
  n ? (t >= e[i].pos && t <= e[r].pos && ({ lo: i, hi: r } = Vr(e, "pos", t)), { pos: a, time: s } = e[i], { pos: o, time: l } = e[r]) : (t >= e[i].time && t <= e[r].time && ({ lo: i, hi: r } = Vr(e, "time", t)), { time: a, pos: s } = e[i], { time: o, pos: l } = e[r]);
  const u = o - a;
  return u ? s + (l - s) * (t - a) / u : s;
}
class XW extends c_ {
  static id = "timeseries";
  static defaults = c_.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), n = this._table = this.buildLookupTable(t);
    this._minPos = fl(n, this.min), this._tableRange = fl(n, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: n, max: i } = this, r = [], a = [];
    let o, s, l, u, c;
    for (o = 0, s = t.length; o < s; ++o)
      u = t[o], u >= n && u <= i && r.push(u);
    if (r.length < 2)
      return [
        {
          time: n,
          pos: 0
        },
        {
          time: i,
          pos: 1
        }
      ];
    for (o = 0, s = r.length; o < s; ++o)
      c = r[o + 1], l = r[o - 1], u = r[o], Math.round((c + l) / 2) !== u && a.push({
        time: u,
        pos: o / (s - 1)
      });
    return a;
  }
  _generate() {
    const t = this.min, n = this.max;
    let i = super.getDataTimestamps();
    return (!i.includes(t) || !i.length) && i.splice(0, 0, t), (!i.includes(n) || i.length === 1) && i.push(n), i.sort((r, a) => r - a);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const n = this.getDataTimestamps(), i = this.getLabelTimestamps();
    return n.length && i.length ? t = this.normalize(n.concat(i)) : t = n.length ? n : i, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (fl(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const n = this._offsets, i = this.getDecimalForPixel(t) / n.factor - n.end;
    return fl(this._table, i * this._tableRange + this._minPos, !0);
  }
}
const zb = {
  data: {
    type: Object,
    required: !0
  },
  options: {
    type: Object,
    default: () => ({})
  },
  plugins: {
    type: Array,
    default: () => []
  },
  datasetIdKey: {
    type: String,
    default: "label"
  },
  updateMode: {
    type: String,
    default: void 0
  }
}, Fk = {
  ariaLabel: {
    type: String
  },
  ariaDescribedby: {
    type: String
  }
}, Bk = {
  type: {
    type: String,
    required: !0
  },
  destroyDelay: {
    type: Number,
    default: 0
    // No delay by default
  },
  ...zb,
  ...Fk
}, zk = ZS[0] === "2" ? (e, t) => Object.assign(e, {
  attrs: t
}) : (e, t) => Object.assign(e, t);
function ga(e) {
  return Yy(e) ? Od(e) : e;
}
function Vk(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
  return Yy(t) ? new Proxy(e, {}) : e;
}
function $k(e, t) {
  const n = e.options;
  n && t && Object.assign(n, t);
}
function Vb(e, t) {
  e.labels = t;
}
function $b(e, t, n) {
  const i = [];
  e.datasets = t.map((r) => {
    const a = e.datasets.find((o) => o[n] === r[n]);
    return !a || !r.data || i.includes(a) ? {
      ...r
    } : (i.push(a), Object.assign(a, r), a);
  });
}
function Hk(e, t) {
  const n = {
    labels: [],
    datasets: []
  };
  return Vb(n, e.labels), $b(n, e.datasets, t), n;
}
const Yk = Me({
  props: Bk,
  setup(e, t) {
    let { expose: n, slots: i } = t;
    const r = pt(null), a = $y(null);
    n({
      chart: a
    });
    const o = () => {
      if (!r.value) return;
      const { type: u, data: c, options: h, plugins: d, datasetIdKey: f } = e, v = Hk(c, f), g = Vk(v, c);
      a.value = new uo(r.value, {
        type: u,
        data: g,
        options: {
          ...h
        },
        plugins: d
      });
    }, s = () => {
      const u = Od(a.value);
      u && (e.destroyDelay > 0 ? setTimeout(() => {
        u.destroy(), a.value = null;
      }, e.destroyDelay) : (u.destroy(), a.value = null));
    }, l = (u) => {
      u.update(e.updateMode);
    };
    return Cn(o), qS(s), Pn([
      () => e.options,
      () => e.data
    ], (u, c) => {
      let [h, d] = u, [f, v] = c;
      const g = Od(a.value);
      if (!g)
        return;
      let p = !1;
      if (h) {
        const _ = ga(h), m = ga(f);
        _ && _ !== m && ($k(g, _), p = !0);
      }
      if (d) {
        const _ = ga(d.labels), m = ga(v.labels), y = ga(d.datasets), b = ga(v.datasets);
        _ !== m && (Vb(g.config.data, _), p = !0), y && y !== b && ($b(g.config.data, y, e.datasetIdKey), p = !0);
      }
      p && Hy(() => {
        l(g);
      });
    }, {
      deep: !0
    }), () => Ld("canvas", {
      role: "img",
      "aria-label": e.ariaLabel,
      "aria-describedby": e.ariaDescribedby,
      ref: r
    }, [
      Ld("p", {}, [
        i.default ? i.default() : ""
      ])
    ]);
  }
});
function vv(e, t) {
  return uo.register(t), Me({
    props: zb,
    setup(n, i) {
      let { expose: r } = i;
      const a = $y(null), o = (s) => {
        a.value = s?.chart;
      };
      return r({
        chart: a
      }), () => Ld(Yk, zk({
        ref: o
      }, {
        type: e,
        ...n
      }));
    }
  });
}
const Wk = /* @__PURE__ */ vv("bar", fD), Uk = /* @__PURE__ */ vv("line", gD), Gk = /* @__PURE__ */ vv("pie", _D), jk = { class: "chart-container" }, Xk = /* @__PURE__ */ Me({
  __name: "ChartBar",
  props: {
    data: {},
    options: {},
    stacked: { type: Boolean }
  },
  setup(e) {
    const t = e;
    uo.register(
      Fb,
      Bb,
      qT,
      Rb,
      fv,
      dv
    );
    const n = t.data, i = (o) => typeof o == "string" ? o.charAt(0).toUpperCase() + o.slice(1).toLowerCase() : o, r = {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: "#475569",
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          },
          generateLabels: function(o) {
            return o.data.datasets.map((l, u) => ({
              text: i(l.label || ""),
              fillStyle: Array.isArray(l.backgroundColor) ? l.backgroundColor[0] : l.backgroundColor,
              strokeStyle: Array.isArray(l.borderColor) ? l.borderColor[0] : l.borderColor,
              lineWidth: l.borderWidth,
              hidden: !o.isDatasetVisible(u),
              index: u,
              datasetIndex: u
            }));
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: "rgba(15, 23, 42, 0.95)",
          titleColor: "#f1f5f9",
          bodyColor: "#e2e8f0",
          borderColor: "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(o) {
              return o.length > 0 ? String(i(o[0].label)) : "";
            },
            label: function(o) {
              let s = String(i(o.dataset.label || ""));
              return s && (s += ": "), o.parsed.y !== null && (s += o.parsed.y), s;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          stacked: t.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            color: "rgba(148, 163, 184, 0.12)",
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(o) {
              return i(o);
            }
          }
        },
        x: {
          stacked: t.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(o) {
              const s = this.getLabelForValue(o);
              return i(s);
            }
          }
        }
      },
      elements: {
        bar: {
          borderRadius: 8,
          borderWidth: 0
        }
      }
    }, a = t.options || r;
    return (o, s) => (O(), I("div", jk, [
      Ee(G(Wk), {
        data: G(n),
        options: G(a)
      }, null, 8, ["data", "options"])
    ]));
  }
}), de = (e, t) => {
  const n = e.__vccOpts || e;
  for (const [i, r] of t)
    n[i] = r;
  return n;
}, qk = /* @__PURE__ */ de(Xk, [["__scopeId", "data-v-14d316b3"]]), Zk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: qk
}, Symbol.toStringTag, { value: "Module" })), Kk = { class: "chart-container" }, Qk = /* @__PURE__ */ Me({
  __name: "ChartLine",
  props: {
    data: {},
    options: {}
  },
  setup(e) {
    const t = e;
    uo.register(
      Fb,
      Bb,
      YT,
      mc,
      Rb,
      fv,
      dv,
      pk
    );
    const n = t.data, i = (o) => typeof o == "string" ? o.charAt(0).toUpperCase() + o.slice(1).toLowerCase() : o, r = {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: "#475569",
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(o) {
              return o.data.datasets.map((l, u) => ({
                text: i(l.label || ""),
                fillStyle: l.backgroundColor,
                strokeStyle: l.borderColor,
                lineWidth: l.borderWidth,
                hidden: !o.isDatasetVisible(u),
                index: u,
                datasetIndex: u
              }));
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: "rgba(15, 23, 42, 0.95)",
          titleColor: "#f1f5f9",
          bodyColor: "#e2e8f0",
          borderColor: "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(o) {
              return o.length > 0 ? String(i(o[0].label)) : "";
            },
            label: function(o) {
              let s = String(i(o.dataset.label || ""));
              return s && (s += ": "), o.parsed.y !== null && (s += o.parsed.y), s;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: "rgba(148, 163, 184, 0.12)",
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(o) {
              return i(o);
            }
          }
        },
        x: {
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: "#64748b",
            padding: 8,
            callback: function(o) {
              const s = this.getLabelForValue(o);
              return i(s);
            }
          }
        }
      },
      elements: {
        line: {
          tension: 0.4,
          borderWidth: 2.5,
          borderCapStyle: "round"
        },
        point: {
          radius: 4,
          hoverRadius: 6,
          borderWidth: 2,
          backgroundColor: "#ffffff",
          hoverBorderWidth: 3
        }
      }
    }, a = t.options || r;
    return (o, s) => (O(), I("div", Kk, [
      Ee(G(Uk), {
        data: G(n),
        options: G(a)
      }, null, 8, ["data", "options"])
    ]));
  }
}), pv = /* @__PURE__ */ de(Qk, [["__scopeId", "data-v-cc07cec7"]]), Jk = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: pv
}, Symbol.toStringTag, { value: "Module" })), tC = { class: "chart-container" }, eC = /* @__PURE__ */ Me({
  __name: "PieChart",
  props: {
    data: {},
    options: {},
    doughnut: { type: Boolean }
  },
  setup(e) {
    const t = e;
    uo.register(OT, fv, dv);
    const n = t.data, i = (o) => typeof o == "string" ? o.charAt(0).toUpperCase() + o.slice(1).toLowerCase() : o, r = {
      responsive: !0,
      maintainAspectRatio: !1,
      cutout: t.doughnut ? "60%" : 0,
      plugins: {
        legend: {
          display: !0,
          position: "bottom",
          align: "center",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: "#475569",
            padding: 16,
            boxWidth: 14,
            boxHeight: 14,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(o) {
              const s = o.data;
              return s.labels.length && s.datasets.length ? s.labels.map((l, u) => {
                const c = o.getDatasetMeta(0), h = s.datasets[0], d = h.data[u], f = Array.isArray(h.backgroundColor) ? h.backgroundColor[u] : h.backgroundColor;
                return {
                  text: `${i(l)}: ${d}`,
                  fillStyle: f,
                  hidden: c.data[u]?.hidden || !1,
                  index: u
                };
              }) : [];
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: "rgba(15, 23, 42, 0.95)",
          titleColor: "#f1f5f9",
          bodyColor: "#e2e8f0",
          borderColor: "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(o) {
              return o.length > 0 ? String(i(o[0].label)) : "";
            },
            label: function(o) {
              const s = o.label || "", l = o.parsed || 0, u = o.dataset.data.reduce((h, d) => h + d, 0), c = (l / u * 100).toFixed(1);
              return `${i(s)}: ${l} (${c}%)`;
            }
          }
        }
      },
      elements: {
        arc: {
          borderWidth: 2,
          borderColor: "#ffffff",
          hoverOffset: 8
        }
      },
      animation: {
        animateRotate: !0,
        animateScale: !0
      }
    }, a = t.options || r;
    return (o, s) => (O(), I("div", tC, [
      Ee(G(Gk), {
        data: G(n),
        options: G(a)
      }, null, 8, ["data", "options"])
    ]));
  }
}), nC = /* @__PURE__ */ de(eC, [["__scopeId", "data-v-f56c62c9"]]), iC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: nC
}, Symbol.toStringTag, { value: "Module" })), rC = { class: "chart-container" }, aC = ["viewBox"], oC = ["transform"], sC = ["x", "width"], lC = {
  x: "0",
  y: "0",
  "text-anchor": "middle",
  fill: "#f1f5f9",
  "font-size": "12",
  "font-weight": "500",
  "font-family": "'DM Sans', sans-serif",
  "dominant-baseline": "middle"
}, uC = ["x1", "y1", "x2", "y2"], cC = ["points"], hC = ["x1", "y1", "x2", "y2"], dC = ["x", "y"], fC = ["x1", "y1", "x2", "y2"], vC = ["points"], pC = ["transform"], gC = ["y1", "y2"], _C = ["y1", "y2"], mC = ["y1", "y2"], yC = ["y1", "y2"], bC = ["y", "height"], xC = ["y1", "y2"], wC = ["y1", "y2"], SC = ["y1", "y2"], MC = ["y1", "y2"], DC = ["y", "height"], TC = ["cy", "onMouseenter"], kC = ["cy", "onMouseenter"], CC = ["cy", "onMouseenter"], PC = ["cy", "onMouseenter"], AC = ["y1", "y2", "onMouseenter"], EC = ["y1", "y2", "onMouseenter"], LC = ["x", "y"], OC = ["x", "y"], IC = ["transform"], RC = /* @__PURE__ */ Me({
  __name: "BoxplotChart",
  props: {
    boxplotData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    showLegend: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = e, n = pt({
      visible: !1,
      x: 0,
      y: 0,
      text: ""
    }), i = (u) => typeof u == "string" ? u.charAt(0).toUpperCase() + u.slice(1).toLowerCase() : u, r = (u, c) => {
      const h = u.currentTarget.closest("svg");
      if (!h) return;
      const d = h.getBoundingClientRect(), f = h.createSVGPoint();
      f.x = u.clientX - d.left, f.y = u.clientY - d.top, n.value = {
        visible: !0,
        x: f.x,
        y: f.y - 20,
        text: c
      };
    }, a = (u) => {
      if (n.value.visible) {
        const c = u.currentTarget, h = c.getBoundingClientRect(), d = c.createSVGPoint();
        d.x = u.clientX - h.left, d.y = u.clientY - h.top, n.value.x = d.x, n.value.y = d.y - 20;
      }
    }, o = () => {
      n.value.visible = !1;
    }, s = () => {
      n.value.visible = !1;
    }, l = ut(() => {
      const u = [], h = t.chartHeight - t.chartMargin - t.chartBottomMargin;
      for (let d = 1; d <= 10; d++) {
        const f = d, v = (f - 1) / 9, g = t.chartMargin + h - v * h;
        u.push({ value: f, y: g });
      }
      return u;
    });
    return (u, c) => (O(), I("div", rC, [
      (O(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full boxplot-svg",
        style: jr(`min-height: ${e.chartHeight}px;`),
        onMousemove: a,
        onMouseleave: o
      }, [
        n.value.visible ? (O(), I("g", {
          key: 0,
          transform: `translate(${n.value.x}, ${n.value.y})`
        }, [
          S("rect", {
            x: -(n.value.text.length * 6 + 10),
            y: -16,
            width: n.value.text.length * 12 + 20,
            height: "24",
            fill: "rgba(15, 23, 42, 0.95)",
            rx: "6",
            stroke: "rgba(148, 163, 184, 0.2)",
            "stroke-width": "1"
          }, null, 8, sC),
          S("text", lC, F(n.value.text), 1)
        ], 8, oC)) : ct("", !0),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, uC),
        S("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: "#475569"
        }, null, 8, cC),
        (O(!0), I(Ft, null, fe(l.value, (h, d) => (O(), I(Ft, { key: d }, [
          S("line", {
            x1: e.chartMargin - 6,
            y1: h.y,
            x2: e.chartMargin,
            y2: h.y,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, hC),
          S("text", {
            x: e.chartMargin - 12,
            y: h.y + 4,
            "text-anchor": "end",
            fill: "#64748b",
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, F(h.value), 9, dC)
        ], 64))), 128)),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, fC),
        S("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: "#475569"
        }, null, 8, vC),
        (O(!0), I(Ft, null, fe(e.boxplotData, (h, d) => (O(), I(Ft, { key: d }, [
          S("g", {
            transform: `translate(${h.centerX}, 0)`
          }, [
            h.isTotal ? (O(), I(Ft, { key: 0 }, [
              S("line", {
                x1: 0,
                y1: h.minY,
                x2: 0,
                y2: h.q1Y,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, gC),
              S("line", {
                x1: 0,
                y1: h.q3Y,
                x2: 0,
                y2: h.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, _C),
              S("line", {
                x1: -18,
                y1: h.minY,
                x2: 18,
                y2: h.minY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, mC),
              S("line", {
                x1: -18,
                y1: h.maxY,
                x2: 18,
                y2: h.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, yC),
              S("rect", {
                x: -24,
                y: h.q3Y,
                width: "48",
                height: h.q1Y - h.q3Y,
                fill: "#8b5cf6",
                "fill-opacity": "0.15",
                stroke: "#8b5cf6",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, bC)
            ], 64)) : (O(), I(Ft, { key: 1 }, [
              S("line", {
                x1: 0,
                y1: h.minY,
                x2: 0,
                y2: h.q1Y,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, xC),
              S("line", {
                x1: 0,
                y1: h.q3Y,
                x2: 0,
                y2: h.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, wC),
              S("line", {
                x1: -18,
                y1: h.minY,
                x2: 18,
                y2: h.minY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, SC),
              S("line", {
                x1: -18,
                y1: h.maxY,
                x2: 18,
                y2: h.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, MC),
              S("rect", {
                x: -24,
                y: h.q3Y,
                width: "48",
                height: h.q1Y - h.q3Y,
                fill: "#C67DFF",
                "fill-opacity": "0.15",
                stroke: "#C67DFF",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, DC)
            ], 64)),
            S("circle", {
              cx: 0,
              cy: h.minY,
              r: "6",
              fill: "#5d4b93",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (f) => r(f, `Min: ${h.min.toFixed(1)}`),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, TC),
            S("circle", {
              cx: 0,
              cy: h.q1Y,
              r: "6",
              fill: "#a855f7",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (f) => r(f, `Q1: ${h.q1.toFixed(1)}`),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, kC),
            S("circle", {
              cx: 0,
              cy: h.q3Y,
              r: "6",
              fill: "#7c3aed",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (f) => r(f, `Q3: ${h.q3.toFixed(1)}`),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, CC),
            S("circle", {
              cx: 0,
              cy: h.maxY,
              r: "6",
              fill: "#C67DFF",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (f) => r(f, `Max: ${h.max.toFixed(1)}`),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, PC),
            S("line", {
              x1: -24,
              y1: h.medianY,
              x2: 24,
              y2: h.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3.5",
              class: "hover-line",
              onMouseenter: (f) => r(f, `Median: ${h.median.toFixed(1)}`),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, AC),
            h.averageY ? (O(), I("line", {
              key: 2,
              x1: -24,
              y1: h.averageY,
              x2: 24,
              y2: h.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (f) => r(f, `Avg: ${h.average.toFixed(1)}`),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, EC)) : ct("", !0)
          ], 8, pC),
          S("text", {
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: "#475569",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, F(i(h.label)), 9, LC),
          h.responseCount ? (O(), I("text", {
            key: 0,
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: "#64748b",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + F(h.responseCount), 9, OC)) : ct("", !0)
        ], 64))), 128)),
        e.showLegend ? (O(), I("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [...c[0] || (c[0] = [
          Kt('<g transform="translate(-200, 0)" data-v-c5c408d5><circle cx="0" cy="0" r="5" fill="#5d4b93" stroke="#ffffff" stroke-width="1.5" data-v-c5c408d5></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-c5c408d5> Min </text></g><g transform="translate(-130, 0)" data-v-c5c408d5><circle cx="0" cy="0" r="5" fill="#a855f7" stroke="#ffffff" stroke-width="1.5" data-v-c5c408d5></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-c5c408d5> Q1 </text></g><g transform="translate(-60, 0)" data-v-c5c408d5><circle cx="0" cy="0" r="5" fill="#7c3aed" stroke="#ffffff" stroke-width="1.5" data-v-c5c408d5></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-c5c408d5> Q3 </text></g><g transform="translate(10, 0)" data-v-c5c408d5><circle cx="0" cy="0" r="5" fill="#C67DFF" stroke="#ffffff" stroke-width="1.5" data-v-c5c408d5></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-c5c408d5> Max </text></g><g transform="translate(80, 0)" data-v-c5c408d5><line x1="0" y1="0" x2="14" y2="0" stroke="#f97316" stroke-width="2.5" stroke-dasharray="6,4" data-v-c5c408d5></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-c5c408d5> Avg </text></g><g transform="translate(150, 0)" data-v-c5c408d5><line x1="0" y1="0" x2="14" y2="0" stroke="#8b5cf6" stroke-width="2.5" data-v-c5c408d5></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-c5c408d5> Median </text></g>', 6)
        ])], 8, IC)) : ct("", !0)
      ], 44, aC))
    ]));
  }
}), NC = /* @__PURE__ */ de(RC, [["__scopeId", "data-v-c5c408d5"]]), FC = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: NC
}, Symbol.toStringTag, { value: "Module" })), BC = { class: "chart-container" }, zC = ["viewBox"], VC = ["transform"], $C = ["x", "y", "width", "height"], HC = ["y"], YC = ["y"], WC = ["x1", "y1", "x2", "y2"], UC = ["points"], GC = ["x1", "y1", "x2", "y2"], jC = ["x1", "y1", "x2", "y2"], XC = ["x", "y"], qC = ["x", "y", "transform"], ZC = ["x1", "y1", "x2", "y2"], KC = ["points"], QC = ["transform"], JC = ["y1", "y2", "stroke", "onMouseenter"], tP = ["x", "y", "width", "height", "fill", "stroke", "onMouseenter"], eP = ["x1", "y1", "x2", "y2", "onMouseenter"], nP = ["x1", "y1", "x2", "y2", "onMouseenter"], iP = ["cy", "onMouseenter"], rP = ["cy", "onMouseenter"], aP = ["x", "y"], oP = ["x", "y"], sP = ["transform"], lP = /* @__PURE__ */ Me({
  __name: "CandlestickChart",
  props: {
    candlestickData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    candleWidth: { default: 35 },
    showLegend: { type: Boolean, default: !0 },
    yAxisLabel: { default: "score" }
  },
  setup(e) {
    const t = e, n = pt({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), i = (u) => typeof u == "string" ? u.charAt(0).toUpperCase() + u.slice(1).toLowerCase() : u, r = (u, c, h) => {
      const d = u.currentTarget.closest("svg");
      if (!d) return;
      const f = d.getBoundingClientRect(), v = d.createSVGPoint();
      v.x = u.clientX - f.left, v.y = u.clientY - f.top;
      let g = i(c.label), p = "";
      switch (h) {
        case "body":
          p = `Q1: ${c.q1.toFixed(1)} | Q3: ${c.q3.toFixed(1)}`;
          break;
        case "wick":
          p = `Min: ${c.low.toFixed(1)} | Max: ${c.high.toFixed(1)}`;
          break;
        case "median":
          p = `Median: ${c.median.toFixed(1)}`;
          break;
        case "average":
          p = `Average: ${c.average?.toFixed(1)}`;
          break;
        case "min":
          p = `Min: ${c.low.toFixed(1)}`;
          break;
        case "max":
          p = `Max: ${c.high.toFixed(1)}`;
          break;
      }
      const _ = Math.max(180, p.length * 7 + 40), m = 48;
      n.value = {
        visible: !0,
        x: v.x,
        y: v.y - 20,
        title: g,
        text: p,
        width: _,
        height: m
      };
    }, a = (u) => {
      if (n.value.visible) {
        const c = u.currentTarget, h = c.getBoundingClientRect(), d = c.createSVGPoint();
        d.x = u.clientX - h.left, d.y = u.clientY - h.top, n.value.x = d.x, n.value.y = d.y - 20;
      }
    }, o = () => {
      n.value.visible = !1;
    }, s = () => {
      n.value.visible = !1;
    }, l = ut(() => {
      const u = [], h = t.chartHeight - t.chartMargin - t.chartBottomMargin;
      for (let d = 1; d <= 10; d++) {
        const f = d, v = (f - 1) / 9, g = t.chartMargin + h - v * h;
        u.push({ value: f, y: g });
      }
      return u;
    });
    return (u, c) => (O(), I("div", BC, [
      (O(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full candlestick-svg",
        style: jr(`min-height: ${e.chartHeight}px;`),
        onMousemove: a,
        onMouseleave: o
      }, [
        n.value.visible ? (O(), I("g", {
          key: 0,
          transform: `translate(${n.value.x}, ${n.value.y})`
        }, [
          S("rect", {
            x: -n.value.width / 2,
            y: -n.value.height - 10,
            width: n.value.width,
            height: n.value.height,
            fill: "rgba(15, 23, 42, 0.95)",
            rx: "8",
            stroke: "rgba(148, 163, 184, 0.2)",
            "stroke-width": "1"
          }, null, 8, $C),
          S("text", {
            x: "0",
            y: -n.value.height + 8,
            "text-anchor": "middle",
            fill: "#f1f5f9",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(n.value.title), 9, HC),
          S("text", {
            x: "0",
            y: -n.value.height + 26,
            "text-anchor": "middle",
            fill: "#e2e8f0",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(n.value.text), 9, YC)
        ], 8, VC)) : ct("", !0),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, WC),
        S("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: "#475569"
        }, null, 8, UC),
        (O(!0), I(Ft, null, fe(l.value, (h, d) => (O(), I("line", {
          key: `grid-${d}`,
          x1: e.chartMargin,
          y1: h.y,
          x2: e.chartWidth - e.chartMargin,
          y2: h.y,
          stroke: "#e5e7eb",
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, GC))), 128)),
        (O(!0), I(Ft, null, fe(l.value, (h, d) => (O(), I(Ft, { key: d }, [
          S("line", {
            x1: e.chartMargin - 6,
            y1: h.y,
            x2: e.chartMargin,
            y2: h.y,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, jC),
          S("text", {
            x: e.chartMargin - 12,
            y: h.y + 4,
            "text-anchor": "end",
            fill: "#64748b",
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, F(h.value), 9, XC)
        ], 64))), 128)),
        S("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: "#475569",
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, F(i(e.yAxisLabel)), 9, qC),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, ZC),
        S("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: "#475569"
        }, null, 8, KC),
        (O(!0), I(Ft, null, fe(e.candlestickData, (h, d) => (O(), I(Ft, { key: d }, [
          S("g", {
            transform: `translate(${h.centerX}, 0)`
          }, [
            S("line", {
              x1: 0,
              y1: h.highY,
              x2: 0,
              y2: h.lowY,
              stroke: h.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              class: "hover-line",
              onMouseenter: (f) => r(f, h, "wick"),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, JC),
            S("rect", {
              x: -e.candleWidth / 2,
              y: Math.min(h.q1Y, h.q3Y),
              width: e.candleWidth,
              height: Math.abs(h.q3Y - h.q1Y),
              fill: h.isTotal ? "rgba(139, 92, 246, 0.15)" : "rgba(198, 125, 255, 0.15)",
              stroke: h.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              rx: "4",
              class: "hover-rect",
              onMouseenter: (f) => r(f, h, "body"),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, tP),
            h.medianY ? (O(), I("line", {
              key: 0,
              x1: -e.candleWidth / 2,
              y1: h.medianY,
              x2: e.candleWidth / 2,
              y2: h.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3",
              class: "hover-line",
              onMouseenter: (f) => r(f, h, "median"),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, eP)) : ct("", !0),
            h.averageY ? (O(), I("line", {
              key: 1,
              x1: -e.candleWidth / 2,
              y1: h.averageY,
              x2: e.candleWidth / 2,
              y2: h.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (f) => r(f, h, "average"),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, nP)) : ct("", !0),
            S("circle", {
              cx: 0,
              cy: h.lowY,
              r: "5",
              fill: "#5d4b93",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (f) => r(f, h, "min"),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, iP),
            S("circle", {
              cx: 0,
              cy: h.highY,
              r: "5",
              fill: "#C67DFF",
              stroke: "#ffffff",
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (f) => r(f, h, "max"),
              onMouseleave: s,
              style: { cursor: "pointer" }
            }, null, 40, rP)
          ], 8, QC),
          S("text", {
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: "#475569",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, F(i(h.label)), 9, aP),
          h.responseCount ? (O(), I("text", {
            key: 0,
            x: h.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: "#64748b",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + F(h.responseCount), 9, oP)) : ct("", !0)
        ], 64))), 128)),
        e.showLegend ? (O(), I("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [...c[0] || (c[0] = [
          Kt('<g transform="translate(-180, 0)" data-v-6d2b6ae8><circle cx="0" cy="0" r="5" fill="#5d4b93" stroke="#ffffff" stroke-width="1.5" data-v-6d2b6ae8></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-6d2b6ae8> Min </text></g><g transform="translate(-120, 0)" data-v-6d2b6ae8><rect x="-6" y="-6" width="12" height="12" fill="rgba(198, 125, 255, 0.15)" stroke="#C67DFF" stroke-width="1.5" rx="2" data-v-6d2b6ae8></rect><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-6d2b6ae8> Q1 </text></g><g transform="translate(-60, 0)" data-v-6d2b6ae8><rect x="-6" y="-6" width="12" height="12" fill="rgba(198, 125, 255, 0.15)" stroke="#C67DFF" stroke-width="1.5" rx="2" data-v-6d2b6ae8></rect><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-6d2b6ae8> Q3 </text></g><g transform="translate(0, 0)" data-v-6d2b6ae8><circle cx="0" cy="0" r="5" fill="#C67DFF" stroke="#ffffff" stroke-width="1.5" data-v-6d2b6ae8></circle><text x="10" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-6d2b6ae8> Max </text></g><g transform="translate(60, 0)" data-v-6d2b6ae8><line x1="0" y1="0" x2="14" y2="0" stroke="#f97316" stroke-width="2.5" stroke-dasharray="6,4" data-v-6d2b6ae8></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-6d2b6ae8> Avg </text></g><g transform="translate(130, 0)" data-v-6d2b6ae8><line x1="0" y1="0" x2="14" y2="0" stroke="#8b5cf6" stroke-width="2.5" data-v-6d2b6ae8></line><text x="18" y="4" fill="#475569" font-size="12" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-6d2b6ae8> Median </text></g>', 6)
        ])], 8, sP)) : ct("", !0)
      ], 44, zC))
    ]));
  }
}), Hb = /* @__PURE__ */ de(lP, [["__scopeId", "data-v-6d2b6ae8"]]), uP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Hb
}, Symbol.toStringTag, { value: "Module" })), cP = { class: "chart-container" }, hP = ["viewBox"], dP = ["transform"], fP = ["x", "y", "width", "height"], vP = ["y"], pP = ["y"], gP = ["x1", "y1", "x2", "y2"], _P = ["x1", "y1", "x2", "y2"], mP = ["points"], yP = ["x1", "y1", "x2", "y2"], bP = ["x", "y"], xP = ["x", "y", "transform"], wP = ["x1", "y1", "x2", "y2"], SP = ["points"], MP = ["x1", "y1", "x2", "y2"], DP = ["x", "y"], TP = ["x", "y"], kP = ["d"], CP = ["x", "y", "width", "height", "onMouseenter"], PP = ["x1", "y1", "x2", "y2"], AP = ["x", "y"], EP = ["x1", "y1", "x2", "y2"], LP = ["x", "y"], OP = ["x1", "y1", "x2", "y2"], IP = ["x", "y"], RP = ["x1", "y1", "x2", "y2"], NP = ["x", "y"], FP = ["x1", "y1", "x2", "y2"], BP = ["x", "y"], zP = ["x1", "y1", "x2", "y2"], VP = ["x", "y"], $P = ["transform"], HP = /* @__PURE__ */ Me({
  __name: "HistogramChart",
  props: {
    histogram: { default: () => [] },
    minScore: { default: 0 },
    maxScore: { default: 0 },
    q1Score: { default: 0 },
    medianScore: { default: 0 },
    q3Score: { default: 0 },
    averageScore: { default: 0 },
    chartWidth: { default: 800 },
    chartHeight: { default: 450 },
    chartMargin: { default: 60 },
    chartBottomMargin: { default: 80 },
    showLegend: { type: Boolean, default: !0 }
  },
  setup(e) {
    const t = e, n = pt({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), i = ut(() => t.chartWidth - t.chartMargin * 2), r = ut(() => t.chartHeight - t.chartMargin - t.chartBottomMargin), a = ut(() => i.value / 10 * 0.6), o = ut(() => !t.histogram || t.histogram.length === 0 ? 1 : Math.max(...t.histogram.map((L) => L.count || 0), 1) + 30), s = ut(() => {
      if (!t.histogram || t.histogram.length === 0) return 1;
      const A = t.averageScore || 0;
      let L = 0, R = 0;
      if (t.histogram.forEach((V) => {
        const q = V.count || 0;
        L += q;
        const W = V.score - A;
        R += q * (W * W);
      }), L === 0) return 1;
      const N = R / L;
      return Math.sqrt(N) || 1;
    }), l = (A, L, R) => {
      if (R === 0) return 0;
      const N = 1 / (R * Math.sqrt(2 * Math.PI)), V = -0.5 * Math.pow((A - L) / R, 2);
      return N * Math.exp(V);
    }, u = ut(() => {
      if (!t.histogram || t.histogram.length === 0 || t.averageScore === 0 && s.value === 0) return null;
      const A = t.averageScore, L = s.value, R = [], N = 100, V = 1, q = 10, W = t.histogram.reduce((at, ht) => at + (ht.count || 0), 0);
      if (W === 0) return null;
      let Z = 0;
      for (let at = 0; at <= N; at++) {
        const ht = V + (q - V) * (at / N), Ht = l(ht, A, L);
        Ht > Z && (Z = Ht);
      }
      const et = r.value * 0.8 / Z * W * 7e-3;
      for (let at = 0; at <= N; at++) {
        const ht = V + (q - V) * (at / N), Rt = l(ht, A, L) * et, Oe = h(ht);
        if (Oe !== null) {
          const Ue = t.chartHeight - t.chartBottomMargin - Rt;
          R.push(`${at === 0 ? "M" : "L"} ${Oe} ${Ue}`);
        }
      }
      return R.join(" ");
    }), c = ut(() => {
      if (!t.histogram || t.histogram.length === 0) return [];
      const A = i.value / 10;
      return t.histogram.map((L, R) => {
        const N = t.chartMargin + (R + 0.5) * A, V = L.count > 0 ? L.count / o.value * r.value : 0, q = t.chartHeight - t.chartBottomMargin - V;
        return {
          score: L.score,
          count: L.count,
          x: N,
          y: q,
          height: V
        };
      });
    }), h = (A) => {
      if (A < 1 || A > 10) return null;
      const L = i.value / 10;
      return t.chartMargin + (A - 0.5) * L;
    }, d = ut(() => h(t.minScore)), f = ut(() => h(t.maxScore)), v = ut(() => h(t.q1Score)), g = ut(() => h(t.medianScore)), p = ut(() => h(t.q3Score)), _ = ut(() => h(t.averageScore)), m = ut(() => t.minScore), y = ut(() => t.maxScore), b = ut(() => t.q1Score), x = ut(() => t.medianScore), w = ut(() => t.q3Score), M = ut(() => t.averageScore), D = ut(() => {
      const A = [];
      for (let R = 0; R <= 5; R++) {
        const N = Math.round(o.value / 5 * R), V = t.chartHeight - t.chartBottomMargin - R / 5 * r.value;
        A.push({ value: N, y: V });
      }
      return A;
    }), T = (A, L) => {
      const R = A.currentTarget.closest("svg");
      if (!R) return;
      const N = R.getBoundingClientRect(), V = R.createSVGPoint();
      V.x = A.clientX - N.left, V.y = A.clientY - N.top;
      const q = `Score: ${L.score}`, W = `Count: ${L.count}`, Z = 120, bt = 48;
      n.value = {
        visible: !0,
        x: V.x,
        y: V.y - 20,
        title: q,
        text: W,
        width: Z,
        height: bt
      };
    }, C = (A) => {
      if (n.value.visible) {
        const L = A.currentTarget, R = L.getBoundingClientRect(), N = L.createSVGPoint();
        N.x = A.clientX - R.left, N.y = A.clientY - R.top, n.value.x = N.x, n.value.y = N.y - 20;
      }
    }, k = () => {
      n.value.visible = !1;
    }, E = () => {
      n.value.visible = !1;
    };
    return (A, L) => (O(), I("div", cP, [
      (O(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full histogram-svg",
        style: jr(`min-height: ${e.chartHeight}px;`),
        onMousemove: C,
        onMouseleave: k
      }, [
        n.value.visible ? (O(), I("g", {
          key: 0,
          transform: `translate(${n.value.x}, ${n.value.y})`
        }, [
          S("rect", {
            x: -n.value.width / 2,
            y: -n.value.height - 10,
            width: n.value.width,
            height: n.value.height,
            fill: "rgba(15, 23, 42, 0.95)",
            rx: "8",
            stroke: "rgba(148, 163, 184, 0.2)",
            "stroke-width": "1"
          }, null, 8, fP),
          S("text", {
            x: "0",
            y: -n.value.height + 8,
            "text-anchor": "middle",
            fill: "#f1f5f9",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(n.value.title), 9, vP),
          S("text", {
            x: "0",
            y: -n.value.height + 26,
            "text-anchor": "middle",
            fill: "#e2e8f0",
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, F(n.value.text), 9, pP)
        ], 8, dP)) : ct("", !0),
        (O(!0), I(Ft, null, fe(D.value, (R, N) => (O(), I("line", {
          key: `grid-${N}`,
          x1: e.chartMargin,
          y1: R.y,
          x2: e.chartWidth - e.chartMargin,
          y2: R.y,
          stroke: "#e5e7eb",
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, gP))), 128)),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, _P),
        S("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: "#475569"
        }, null, 8, mP),
        (O(!0), I(Ft, null, fe(D.value, (R, N) => (O(), I(Ft, {
          key: `y-tick-${N}`
        }, [
          S("line", {
            x1: e.chartMargin - 6,
            y1: R.y,
            x2: e.chartMargin,
            y2: R.y,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, yP),
          S("text", {
            x: e.chartMargin - 12,
            y: R.y + 4,
            "text-anchor": "end",
            fill: "#64748b",
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, F(R.value), 9, bP)
        ], 64))), 128)),
        S("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: "#475569",
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, " Count ", 8, xP),
        S("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#475569",
          "stroke-width": "2"
        }, null, 8, wP),
        S("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: "#475569"
        }, null, 8, SP),
        (O(!0), I(Ft, null, fe(c.value, (R, N) => (O(), I(Ft, {
          key: `tick-${N}`
        }, [
          S("line", {
            x1: R.x,
            y1: e.chartHeight - e.chartBottomMargin,
            x2: R.x,
            y2: e.chartHeight - e.chartBottomMargin + 5,
            stroke: "#cbd5e1",
            "stroke-width": "1"
          }, null, 8, MP),
          S("text", {
            x: R.x,
            y: e.chartHeight - e.chartBottomMargin + 20,
            "text-anchor": "middle",
            fill: "#475569",
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, F(R.score), 9, DP)
        ], 64))), 128)),
        S("text", {
          x: e.chartWidth / 2,
          y: e.chartHeight - e.chartBottomMargin + 40,
          "text-anchor": "middle",
          fill: "#475569",
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Score ", 8, TP),
        u.value ? (O(), I("path", {
          key: 1,
          d: u.value,
          fill: "none",
          stroke: "#8b5cf6",
          "stroke-width": "2.5",
          opacity: "0.7",
          class: "gaussian-curve"
        }, null, 8, kP)) : ct("", !0),
        (O(!0), I(Ft, null, fe(c.value, (R, N) => (O(), I("rect", {
          key: `bar-${N}`,
          x: R.x - a.value / 2,
          y: R.y,
          width: a.value,
          height: R.height,
          fill: "rgba(198, 125, 255, 0.6)",
          stroke: "#C67DFF",
          "stroke-width": "2",
          rx: "4",
          class: "histogram-bar",
          onMouseenter: (V) => T(V, R),
          onMouseleave: E,
          style: { cursor: "pointer" }
        }, null, 40, CP))), 128)),
        d.value ? (O(), I("line", {
          key: 2,
          x1: d.value,
          y1: e.chartMargin,
          x2: d.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#5d4b93",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, PP)) : ct("", !0),
        d.value ? (O(), I("text", {
          key: 3,
          x: d.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#5d4b93",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Min: " + F(m.value.toFixed(1)), 9, AP)) : ct("", !0),
        v.value ? (O(), I("line", {
          key: 4,
          x1: v.value,
          y1: e.chartMargin,
          x2: v.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#a855f7",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, EP)) : ct("", !0),
        v.value ? (O(), I("text", {
          key: 5,
          x: v.value,
          y: e.chartMargin - 10,
          "text-anchor": "middle",
          fill: "#a855f7",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q1: " + F(b.value.toFixed(1)), 9, LP)) : ct("", !0),
        g.value ? (O(), I("line", {
          key: 6,
          x1: g.value,
          y1: e.chartMargin,
          x2: g.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#8b5cf6",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, OP)) : ct("", !0),
        g.value ? (O(), I("text", {
          key: 7,
          x: g.value,
          y: e.chartMargin - 25,
          "text-anchor": "middle",
          fill: "#8b5cf6",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Median: " + F(x.value.toFixed(1)), 9, IP)) : ct("", !0),
        _.value ? (O(), I("line", {
          key: 8,
          x1: _.value,
          y1: e.chartMargin,
          x2: _.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#f97316",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, RP)) : ct("", !0),
        _.value ? (O(), I("text", {
          key: 9,
          x: _.value,
          y: e.chartMargin - 25,
          "text-anchor": "middle",
          fill: "#f97316",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Avg: " + F(M.value.toFixed(1)), 9, NP)) : ct("", !0),
        p.value ? (O(), I("line", {
          key: 10,
          x1: p.value,
          y1: e.chartMargin,
          x2: p.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#7c3aed",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, FP)) : ct("", !0),
        p.value ? (O(), I("text", {
          key: 11,
          x: p.value,
          y: e.chartMargin - 10,
          "text-anchor": "middle",
          fill: "#7c3aed",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q3: " + F(w.value.toFixed(1)), 9, BP)) : ct("", !0),
        f.value ? (O(), I("line", {
          key: 12,
          x1: f.value,
          y1: e.chartMargin,
          x2: f.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#C67DFF",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, zP)) : ct("", !0),
        f.value ? (O(), I("text", {
          key: 13,
          x: f.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#C67DFF",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Max: " + F(y.value.toFixed(1)), 9, VP)) : ct("", !0),
        e.showLegend ? (O(), I("g", {
          key: 14,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 50})`
        }, [...L[0] || (L[0] = [
          Kt('<g transform="translate(-220, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#8b5cf6" stroke-width="2.5" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Gaussian </text></g><g transform="translate(-140, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#5d4b93" stroke-width="2.5" stroke-dasharray="6,4" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Min </text></g><g transform="translate(-80, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#a855f7" stroke-width="2.5" stroke-dasharray="6,4" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Q1 </text></g><g transform="translate(-20, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#8b5cf6" stroke-width="3" stroke-dasharray="6,4" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Median </text></g><g transform="translate(60, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#f97316" stroke-width="3" stroke-dasharray="6,4" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Avg </text></g><g transform="translate(130, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#7c3aed" stroke-width="2.5" stroke-dasharray="6,4" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Q3 </text></g><g transform="translate(180, 0)" data-v-d1cc2dd2><line x1="0" y1="0" x2="20" y2="0" stroke="#C67DFF" stroke-width="2.5" stroke-dasharray="6,4" data-v-d1cc2dd2></line><text x="24" y="4" fill="#475569" font-size="11" font-family="&#39;DM Sans&#39;, sans-serif" font-weight="500" data-v-d1cc2dd2> Max </text></g>', 7)
        ])], 8, $P)) : ct("", !0)
      ], 44, hP))
    ]));
  }
}), Yb = /* @__PURE__ */ de(HP, [["__scopeId", "data-v-d1cc2dd2"]]), YP = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: Yb
}, Symbol.toStringTag, { value: "Module" }));
var Hd = function(e, t) {
  return Hd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
    n.__proto__ = i;
  } || function(n, i) {
    for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (n[r] = i[r]);
  }, Hd(e, t);
};
function ae(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Hd(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
var WP = /* @__PURE__ */ (function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
})(), UP = /* @__PURE__ */ (function() {
  function e() {
    this.browser = new WP(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
})(), tt = new UP();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (tt.wxa = !0, tt.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? tt.worker = !0 : !tt.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (tt.node = !0, tt.svgSupported = !0) : GP(navigator.userAgent, tt);
function GP(e, t) {
  var n = t.browser, i = e.match(/Firefox\/([\d.]+)/), r = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), a = e.match(/Edge?\/([\d.]+)/), o = /micromessenger/i.test(e);
  i && (n.firefox = !0, n.version = i[1]), r && (n.ie = !0, n.version = r[1]), a && (n.edge = !0, n.version = a[1], n.newEdge = +a[1].split(".")[0] > 18), o && (n.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !n.ie && !n.edge, t.pointerEventsSupported = "onpointerdown" in window && (n.edge || n.ie && +n.version >= 11);
  var s = t.domSupported = typeof document < "u";
  if (s) {
    var l = document.documentElement.style;
    t.transform3dSupported = (n.ie && "transition" in l || n.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || n.ie && +n.version >= 9;
  }
}
var gv = 12, jP = "sans-serif", tr = gv + "px " + jP, XP = 20, qP = 100, ZP = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function KP(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var n = 0; n < e.length; n++) {
    var i = String.fromCharCode(n + 32), r = (e.charCodeAt(n) - XP) / qP;
    t[i] = r;
  }
  return t;
}
var QP = KP(ZP), Mi = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ (function() {
    var e, t;
    return function(n, i) {
      if (!e) {
        var r = Mi.createCanvas();
        e = r && r.getContext("2d");
      }
      if (e)
        return t !== i && (t = e.font = i || tr), e.measureText(n);
      n = n || "", i = i || tr;
      var a = /((?:\d+)?\.?\d*)px/.exec(i), o = a && +a[1] || gv, s = 0;
      if (i.indexOf("mono") >= 0)
        s = o * n.length;
      else
        for (var l = 0; l < n.length; l++) {
          var u = QP[n[l]];
          s += u == null ? o : u * o;
        }
      return { width: s };
    };
  })(),
  loadImage: function(e, t, n) {
    var i = new Image();
    return i.onload = t, i.onerror = n, i.src = e, i;
  }
}, Wb = ho([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), Ub = ho([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), co = Object.prototype.toString, xc = Array.prototype, JP = xc.forEach, tA = xc.filter, _v = xc.slice, eA = xc.map, h_ = (function() {
}).constructor, vl = h_ ? h_.prototype : null, mv = "__proto__", nA = 2311;
function Gb() {
  return nA++;
}
function qr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function ft(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, n = co.call(e);
  if (n === "[object Array]") {
    if (!cs(e)) {
      t = [];
      for (var i = 0, r = e.length; i < r; i++)
        t[i] = ft(e[i]);
    }
  } else if (Ub[n]) {
    if (!cs(e)) {
      var a = e.constructor;
      if (a.from)
        t = a.from(e);
      else {
        t = new a(e.length);
        for (var i = 0, r = e.length; i < r; i++)
          t[i] = e[i];
      }
    }
  } else if (!Wb[n] && !cs(e) && !no(e)) {
    t = {};
    for (var o in e)
      e.hasOwnProperty(o) && o !== mv && (t[o] = ft(e[o]));
  }
  return t;
}
function re(e, t, n) {
  if (!X(t) || !X(e))
    return n ? ft(t) : e;
  for (var i in t)
    if (t.hasOwnProperty(i) && i !== mv) {
      var r = e[i], a = t[i];
      X(a) && X(r) && !U(a) && !U(r) && !no(a) && !no(r) && !d_(a) && !d_(r) && !cs(a) && !cs(r) ? re(r, a, n) : (n || !(i in e)) && (e[i] = ft(t[i]));
    }
  return e;
}
function $(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var n in t)
      t.hasOwnProperty(n) && n !== mv && (e[n] = t[n]);
  return e;
}
function Qt(e, t, n) {
  for (var i = jt(t), r = 0, a = i.length; r < a; r++) {
    var o = i[r];
    e[o] == null && (e[o] = t[o]);
  }
  return e;
}
function zt(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var n = 0, i = e.length; n < i; n++)
      if (e[n] === t)
        return n;
  }
  return -1;
}
function iA(e, t) {
  var n = e.prototype;
  function i() {
  }
  i.prototype = t.prototype, e.prototype = new i();
  for (var r in n)
    n.hasOwnProperty(r) && (e.prototype[r] = n[r]);
  e.prototype.constructor = e, e.superClass = t;
}
function An(e, t, n) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var i = Object.getOwnPropertyNames(t), r = 0; r < i.length; r++) {
      var a = i[r];
      a !== "constructor" && e[a] == null && (e[a] = t[a]);
    }
  else
    Qt(e, t);
}
function We(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function P(e, t, n) {
  if (e && t)
    if (e.forEach && e.forEach === JP)
      e.forEach(t, n);
    else if (e.length === +e.length)
      for (var i = 0, r = e.length; i < r; i++)
        t.call(n, e[i], i, e);
    else
      for (var a in e)
        e.hasOwnProperty(a) && t.call(n, e[a], a, e);
}
function yt(e, t, n) {
  if (!e)
    return [];
  if (!t)
    return yv(e);
  if (e.map && e.map === eA)
    return e.map(t, n);
  for (var i = [], r = 0, a = e.length; r < a; r++)
    i.push(t.call(n, e[r], r, e));
  return i;
}
function ho(e, t, n, i) {
  if (e && t) {
    for (var r = 0, a = e.length; r < a; r++)
      n = t.call(i, n, e[r], r, e);
    return n;
  }
}
function qe(e, t, n) {
  if (!e)
    return [];
  if (!t)
    return yv(e);
  if (e.filter && e.filter === tA)
    return e.filter(t, n);
  for (var i = [], r = 0, a = e.length; r < a; r++)
    t.call(n, e[r], r, e) && i.push(e[r]);
  return i;
}
function jt(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var n in e)
    e.hasOwnProperty(n) && t.push(n);
  return t;
}
function rA(e, t) {
  for (var n = [], i = 2; i < arguments.length; i++)
    n[i - 2] = arguments[i];
  return function() {
    return e.apply(t, n.concat(_v.call(arguments)));
  };
}
var Tt = vl && gt(vl.bind) ? vl.call.bind(vl.bind) : rA;
function Pe(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return function() {
    return e.apply(this, t.concat(_v.call(arguments)));
  };
}
function U(e) {
  return Array.isArray ? Array.isArray(e) : co.call(e) === "[object Array]";
}
function gt(e) {
  return typeof e == "function";
}
function K(e) {
  return typeof e == "string";
}
function Mu(e) {
  return co.call(e) === "[object String]";
}
function Xt(e) {
  return typeof e == "number";
}
function X(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function d_(e) {
  return !!Wb[co.call(e)];
}
function Le(e) {
  return !!Ub[co.call(e)];
}
function no(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function wc(e) {
  return e.colorStops != null;
}
function aA(e) {
  return e.image != null;
}
function oA(e) {
  return co.call(e) === "[object RegExp]";
}
function jb(e) {
  return e !== e;
}
function er() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var n = 0, i = e.length; n < i; n++)
    if (e[n] != null)
      return e[n];
}
function J(e, t) {
  return e ?? t;
}
function Zr(e, t, n) {
  return e ?? t ?? n;
}
function yv(e) {
  for (var t = [], n = 1; n < arguments.length; n++)
    t[n - 1] = arguments[n];
  return _v.apply(e, t);
}
function bv(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function Q(e, t) {
  if (!e)
    throw new Error(t);
}
function Un(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var Xb = "__ec_primitive__";
function Yd(e) {
  e[Xb] = !0;
}
function cs(e) {
  return e[Xb];
}
var sA = (function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var n = this.has(t);
    return n && delete this.data[t], n;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, n) {
    return this.data[t] = n, this;
  }, e.prototype.keys = function() {
    return jt(this.data);
  }, e.prototype.forEach = function(t) {
    var n = this.data;
    for (var i in n)
      n.hasOwnProperty(i) && t(n[i], i);
  }, e;
})(), qb = typeof Map == "function";
function lA() {
  return qb ? /* @__PURE__ */ new Map() : new sA();
}
var uA = (function() {
  function e(t) {
    var n = U(t);
    this.data = lA();
    var i = this;
    t instanceof e ? t.each(r) : t && P(t, r);
    function r(a, o) {
      n ? i.set(a, o) : i.set(o, a);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, n) {
    return this.data.set(t, n), n;
  }, e.prototype.each = function(t, n) {
    this.data.forEach(function(i, r) {
      t.call(n, i, r);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return qb ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
})();
function st(e) {
  return new uA(e);
}
function cA(e, t) {
  for (var n = new e.constructor(e.length + t.length), i = 0; i < e.length; i++)
    n[i] = e[i];
  for (var r = e.length, i = 0; i < t.length; i++)
    n[i + r] = t[i];
  return n;
}
function Sc(e, t) {
  var n;
  if (Object.create)
    n = Object.create(e);
  else {
    var i = function() {
    };
    i.prototype = e, n = new i();
  }
  return t && $(n, t), n;
}
function Zb(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function Xn(e, t) {
  return e.hasOwnProperty(t);
}
function ye() {
}
var hA = 180 / Math.PI;
var Wd = function(e, t) {
  return Wd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(n, i) {
    n.__proto__ = i;
  } || function(n, i) {
    for (var r in i) Object.prototype.hasOwnProperty.call(i, r) && (n[r] = i[r]);
  }, Wd(e, t);
};
function At(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Wd(e, t);
  function n() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (n.prototype = t.prototype, new n());
}
function fo(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function dA(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function fA(e) {
  return [e[0], e[1]];
}
function f_(e, t, n) {
  return e[0] = t[0] + n[0], e[1] = t[1] + n[1], e;
}
function vA(e, t, n) {
  return e[0] = t[0] - n[0], e[1] = t[1] - n[1], e;
}
function pA(e) {
  return Math.sqrt(gA(e));
}
function gA(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function hh(e, t, n) {
  return e[0] = t[0] * n, e[1] = t[1] * n, e;
}
function _A(e, t) {
  var n = pA(t);
  return n === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / n, e[1] = t[1] / n), e;
}
function Ud(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var mA = Ud;
function yA(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var ja = yA;
function Ke(e, t, n) {
  var i = t[0], r = t[1];
  return e[0] = n[0] * i + n[2] * r + n[4], e[1] = n[1] * i + n[3] * r + n[5], e;
}
function Ba(e, t, n) {
  return e[0] = Math.min(t[0], n[0]), e[1] = Math.min(t[1], n[1]), e;
}
function za(e, t, n) {
  return e[0] = Math.max(t[0], n[0]), e[1] = Math.max(t[1], n[1]), e;
}
var _a = /* @__PURE__ */ (function() {
  function e(t, n) {
    this.target = t, this.topTarget = n && n.topTarget;
  }
  return e;
})(), bA = (function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var n = t.target; n && !n.draggable; )
      n = n.parent || n.__hostTarget;
    n && (this._draggingTarget = n, n.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new _a(n, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var n = this._draggingTarget;
    if (n) {
      var i = t.offsetX, r = t.offsetY, a = i - this._x, o = r - this._y;
      this._x = i, this._y = r, n.drift(a, o, t), this.handler.dispatchToElement(new _a(n, t), "drag", t.event);
      var s = this.handler.findHover(i, r, n).target, l = this._dropTarget;
      this._dropTarget = s, n !== s && (l && s !== l && this.handler.dispatchToElement(new _a(l, t), "dragleave", t.event), s && s !== l && this.handler.dispatchToElement(new _a(s, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var n = this._draggingTarget;
    n && (n.dragging = !1), this.handler.dispatchToElement(new _a(n, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new _a(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
})(), En = (function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, n, i, r) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof n == "function" && (r = i, i = n, n = null), !i || !t)
      return this;
    var o = this._$eventProcessor;
    n != null && o && o.normalizeQuery && (n = o.normalizeQuery(n)), a[t] || (a[t] = []);
    for (var s = 0; s < a[t].length; s++)
      if (a[t][s].h === i)
        return this;
    var l = {
      h: i,
      query: n,
      ctx: r || this,
      callAtLast: i.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var n = this._$handlers;
    return !n || !n[t] || !n[t].length;
  }, e.prototype.off = function(t, n) {
    var i = this._$handlers;
    if (!i)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (n) {
      if (i[t]) {
        for (var r = [], a = 0, o = i[t].length; a < o; a++)
          i[t][a].h !== n && r.push(i[t][a]);
        i[t] = r;
      }
      i[t] && i[t].length === 0 && delete i[t];
    } else
      delete i[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var n = [], i = 1; i < arguments.length; i++)
      n[i - 1] = arguments[i];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var o = n.length, s = r.length, l = 0; l < s; l++) {
        var u = r[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (o) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, n[0]);
              break;
            case 2:
              u.h.call(u.ctx, n[0], n[1]);
              break;
            default:
              u.h.apply(u.ctx, n);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var n = [], i = 1; i < arguments.length; i++)
      n[i - 1] = arguments[i];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var o = n.length, s = n[o - 1], l = r.length, u = 0; u < l; u++) {
        var c = r[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (o) {
            case 0:
              c.h.call(s);
              break;
            case 1:
              c.h.call(s, n[0]);
              break;
            case 2:
              c.h.call(s, n[0], n[1]);
              break;
            default:
              c.h.apply(s, n.slice(1, o - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e;
})(), xA = Math.log(2);
function Gd(e, t, n, i, r, a) {
  var o = i + "-" + r, s = e.length;
  if (a.hasOwnProperty(o))
    return a[o];
  if (t === 1) {
    var l = Math.round(Math.log((1 << s) - 1 & ~r) / xA);
    return e[n][l];
  }
  for (var u = i | 1 << n, c = n + 1; i & 1 << c; )
    c++;
  for (var h = 0, d = 0, f = 0; d < s; d++) {
    var v = 1 << d;
    v & r || (h += (f % 2 ? -1 : 1) * e[n][d] * Gd(e, t - 1, c, u, r | v, a), f++);
  }
  return a[o] = h, h;
}
function v_(e, t) {
  var n = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], i = {}, r = Gd(n, 8, 0, 0, 0, i);
  if (r !== 0) {
    for (var a = [], o = 0; o < 8; o++)
      for (var s = 0; s < 8; s++)
        a[s] == null && (a[s] = 0), a[s] += ((o + s) % 2 ? -1 : 1) * Gd(n, 7, o === 0 ? 1 : 0, 1 << o, 1 << s, i) / r * t[o];
    return function(l, u, c) {
      var h = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
    };
  }
}
var Du = "___zrEVENTSAVED", dh = [];
function wA(e, t, n, i, r) {
  return jd(dh, t, i, r, !0) && jd(e, n, dh[0], dh[1]);
}
function SA(e, t) {
  e && n(e), t && n(t);
  function n(i) {
    var r = i[Du];
    r && (r.clearMarkers && r.clearMarkers(), delete i[Du]);
  }
}
function jd(e, t, n, i, r) {
  if (t.getBoundingClientRect && tt.domSupported && !Kb(t)) {
    var a = t[Du] || (t[Du] = {}), o = MA(t, a), s = DA(o, a, r);
    if (s)
      return s(e, n, i), !0;
  }
  return !1;
}
function MA(e, t) {
  var n = t.markers;
  if (n)
    return n;
  n = t.markers = [];
  for (var i = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
    var o = document.createElement("div"), s = o.style, l = a % 2, u = (a >> 1) % 2;
    s.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      i[l] + ":0",
      r[u] + ":0",
      i[1 - l] + ":auto",
      r[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(o), n.push(o);
  }
  return t.clearMarkers = function() {
    P(n, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, n;
}
function DA(e, t, n) {
  for (var i = n ? "invTrans" : "trans", r = t[i], a = t.srcCoords, o = [], s = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), h = 2 * u, d = c.left, f = c.top;
    o.push(d, f), l = l && a && d === a[h] && f === a[h + 1], s.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && r ? r : (t.srcCoords = o, t[i] = n ? v_(s, o) : v_(o, s));
}
function Kb(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var TA = /([&<>"'])/g, kA = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Be(e) {
  return e == null ? "" : (e + "").replace(TA, function(t, n) {
    return kA[n];
  });
}
var CA = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, fh = [], PA = tt.browser.firefox && +tt.browser.version.split(".")[0] < 39;
function Xd(e, t, n, i) {
  return n = n || {}, i ? p_(e, t, n) : PA && t.layerX != null && t.layerX !== t.offsetX ? (n.zrX = t.layerX, n.zrY = t.layerY) : t.offsetX != null ? (n.zrX = t.offsetX, n.zrY = t.offsetY) : p_(e, t, n), n;
}
function p_(e, t, n) {
  if (tt.domSupported && e.getBoundingClientRect) {
    var i = t.clientX, r = t.clientY;
    if (Kb(e)) {
      var a = e.getBoundingClientRect();
      n.zrX = i - a.left, n.zrY = r - a.top;
      return;
    } else if (jd(fh, e, i, r)) {
      n.zrX = fh[0], n.zrY = fh[1];
      return;
    }
  }
  n.zrX = n.zrY = 0;
}
function xv(e) {
  return e || window.event;
}
function an(e, t, n) {
  if (t = xv(t), t.zrX != null)
    return t;
  var i = t.type, r = i && i.indexOf("touch") >= 0;
  if (r) {
    var o = i !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    o && Xd(e, o, t, n);
  } else {
    Xd(e, t, t, n);
    var a = AA(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var s = t.button;
  return t.which == null && s !== void 0 && CA.test(t.type) && (t.which = s & 1 ? 1 : s & 2 ? 3 : s & 4 ? 2 : 0), t;
}
function AA(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var n = e.deltaX, i = e.deltaY;
  if (n == null || i == null)
    return t;
  var r = Math.abs(i !== 0 ? i : n), a = i > 0 ? -1 : i < 0 ? 1 : n > 0 ? -1 : 1;
  return 3 * r * a;
}
function EA(e, t, n, i) {
  e.addEventListener(t, n, i);
}
function LA(e, t, n, i) {
  e.removeEventListener(t, n, i);
}
var Tu = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function g_(e) {
  return e.which === 2 || e.which === 3;
}
var OA = (function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, n, i) {
    return this._doTrack(t, n, i), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, n, i) {
    var r = t.touches;
    if (r) {
      for (var a = {
        points: [],
        touches: [],
        target: n,
        event: t
      }, o = 0, s = r.length; o < s; o++) {
        var l = r[o], u = Xd(i, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, e.prototype._recognize = function(t) {
    for (var n in vh)
      if (vh.hasOwnProperty(n)) {
        var i = vh[n](this._track, t);
        if (i)
          return i;
      }
  }, e;
})();
function __(e) {
  var t = e[1][0] - e[0][0], n = e[1][1] - e[0][1];
  return Math.sqrt(t * t + n * n);
}
function IA(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var vh = {
  pinch: function(e, t) {
    var n = e.length;
    if (n) {
      var i = (e[n - 1] || {}).points, r = (e[n - 2] || {}).points || i;
      if (r && r.length > 1 && i && i.length > 1) {
        var a = __(i) / __(r);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var o = IA(i);
        return t.pinchX = o[0], t.pinchY = o[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function qn() {
  return [1, 0, 0, 1, 0, 0];
}
function wv(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function Sv(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function hs(e, t, n) {
  var i = t[0] * n[0] + t[2] * n[1], r = t[1] * n[0] + t[3] * n[1], a = t[0] * n[2] + t[2] * n[3], o = t[1] * n[2] + t[3] * n[3], s = t[0] * n[4] + t[2] * n[5] + t[4], l = t[1] * n[4] + t[3] * n[5] + t[5];
  return e[0] = i, e[1] = r, e[2] = a, e[3] = o, e[4] = s, e[5] = l, e;
}
function qd(e, t, n) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + n[0], e[5] = t[5] + n[1], e;
}
function Mv(e, t, n, i) {
  i === void 0 && (i = [0, 0]);
  var r = t[0], a = t[2], o = t[4], s = t[1], l = t[3], u = t[5], c = Math.sin(n), h = Math.cos(n);
  return e[0] = r * h + s * c, e[1] = -r * c + s * h, e[2] = a * h + l * c, e[3] = -a * c + h * l, e[4] = h * (o - i[0]) + c * (u - i[1]) + i[0], e[5] = h * (u - i[1]) - c * (o - i[0]) + i[1], e;
}
function RA(e, t, n) {
  var i = n[0], r = n[1];
  return e[0] = t[0] * i, e[1] = t[1] * r, e[2] = t[2] * i, e[3] = t[3] * r, e[4] = t[4] * i, e[5] = t[5] * r, e;
}
function Gs(e, t) {
  var n = t[0], i = t[2], r = t[4], a = t[1], o = t[3], s = t[5], l = n * o - a * i;
  return l ? (l = 1 / l, e[0] = o * l, e[1] = -a * l, e[2] = -i * l, e[3] = n * l, e[4] = (i * s - o * r) * l, e[5] = (a * r - n * s) * l, e) : null;
}
var Lt = (function() {
  function e(t, n) {
    this.x = t || 0, this.y = n || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, n) {
    return this.x = t, this.y = n, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, n) {
    this.x += t.x * n, this.y += t.y * n;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var n = this.x - t.x, i = this.y - t.y;
    return Math.sqrt(n * n + i * i);
  }, e.prototype.distanceSquare = function(t) {
    var n = this.x - t.x, i = this.y - t.y;
    return n * n + i * i;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var n = this.x, i = this.y;
      return this.x = t[0] * n + t[2] * i + t[4], this.y = t[1] * n + t[3] * i + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, n, i) {
    t.x = n, t.y = i;
  }, e.copy = function(t, n) {
    t.x = n.x, t.y = n.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, n) {
    return t.x * n.x + t.y * n.y;
  }, e.add = function(t, n, i) {
    t.x = n.x + i.x, t.y = n.y + i.y;
  }, e.sub = function(t, n, i) {
    t.x = n.x - i.x, t.y = n.y - i.y;
  }, e.scale = function(t, n, i) {
    t.x = n.x * i, t.y = n.y * i;
  }, e.scaleAndAdd = function(t, n, i, r) {
    t.x = n.x + i.x * r, t.y = n.y + i.y * r;
  }, e.lerp = function(t, n, i, r) {
    var a = 1 - r;
    t.x = a * n.x + r * i.x, t.y = a * n.y + r * i.y;
  }, e;
})(), $r = Math.min, Va = Math.max, Zd = Math.abs, m_ = ["x", "y"], NA = ["width", "height"], cr = new Lt(), hr = new Lt(), dr = new Lt(), fr = new Lt(), Xe = Qb(), Ko = Xe.minTv, Kd = Xe.maxTv, ds = [0, 0], it = (function() {
  function e(t, n, i, r) {
    e.set(this, t, n, i, r);
  }
  return e.set = function(t, n, i, r, a) {
    return r < 0 && (n = n + r, r = -r), a < 0 && (i = i + a, a = -a), t.x = n, t.y = i, t.width = r, t.height = a, t;
  }, e.prototype.union = function(t) {
    var n = $r(t.x, this.x), i = $r(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Va(t.x + t.width, this.x + this.width) - n : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Va(t.y + t.height, this.y + this.height) - i : this.height = t.height, this.x = n, this.y = i;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var n = this, i = t.width / n.width, r = t.height / n.height, a = qn();
    return qd(a, a, [-n.x, -n.y]), RA(a, a, [i, r]), qd(a, a, [t.x, t.y]), a;
  }, e.prototype.intersect = function(t, n, i) {
    return e.intersect(this, t, n, i);
  }, e.intersect = function(t, n, i, r) {
    i && Lt.set(i, 0, 0);
    var a = r && r.outIntersectRect || null, o = r && r.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !n)
      return !1;
    t instanceof e || (t = e.set(FA, t.x, t.y, t.width, t.height)), n instanceof e || (n = e.set(BA, n.x, n.y, n.width, n.height));
    var s = !!i;
    Xe.reset(r, s);
    var l = Xe.touchThreshold, u = t.x + l, c = t.x + t.width - l, h = t.y + l, d = t.y + t.height - l, f = n.x + l, v = n.x + n.width - l, g = n.y + l, p = n.y + n.height - l;
    if (u > c || h > d || f > v || g > p)
      return !1;
    var _ = !(c < f || v < u || d < g || p < h);
    return (s || a) && (ds[0] = 1 / 0, ds[1] = 0, y_(u, c, f, v, 0, s, a, o), y_(h, d, g, p, 1, s, a, o), s && Lt.copy(i, _ ? Xe.useDir ? Xe.dirMinTv : Ko : Kd)), _;
  }, e.contain = function(t, n, i) {
    return n >= t.x && n <= t.x + t.width && i >= t.y && i <= t.y + t.height;
  }, e.prototype.contain = function(t, n) {
    return e.contain(this, t, n);
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, n) {
    return t.x = n.x, t.y = n.y, t.width = n.width, t.height = n.height, t;
  }, e.applyTransform = function(t, n, i) {
    if (!i) {
      t !== n && e.copy(t, n);
      return;
    }
    if (i[1] < 1e-5 && i[1] > -1e-5 && i[2] < 1e-5 && i[2] > -1e-5) {
      var r = i[0], a = i[3], o = i[4], s = i[5];
      t.x = n.x * r + o, t.y = n.y * a + s, t.width = n.width * r, t.height = n.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    cr.x = dr.x = n.x, cr.y = fr.y = n.y, hr.x = fr.x = n.x + n.width, hr.y = dr.y = n.y + n.height, cr.transform(i), fr.transform(i), hr.transform(i), dr.transform(i), t.x = $r(cr.x, hr.x, dr.x, fr.x), t.y = $r(cr.y, hr.y, dr.y, fr.y);
    var l = Va(cr.x, hr.x, dr.x, fr.x), u = Va(cr.y, hr.y, dr.y, fr.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
})(), FA = new it(0, 0, 0, 0), BA = new it(0, 0, 0, 0);
function y_(e, t, n, i, r, a, o, s) {
  var l = Zd(t - n), u = Zd(i - e), c = $r(l, u), h = m_[r], d = m_[1 - r], f = NA[r];
  t < n || i < e ? l < u ? (a && (Kd[h] = -l), s && (o[h] = t, o[f] = 0)) : (a && (Kd[h] = u), s && (o[h] = e, o[f] = 0)) : (o && (o[h] = Va(e, n), o[f] = $r(t, i) - o[h]), a && (c < ds[0] || Xe.useDir) && (ds[0] = $r(c, ds[0]), (l < u || !Xe.bidirectional) && (Ko[h] = l, Ko[d] = 0, Xe.useDir && Xe.calcDirMTV()), (l >= u || !Xe.bidirectional) && (Ko[h] = -u, Ko[d] = 0, Xe.useDir && Xe.calcDirMTV())));
}
function Qb() {
  var e = 0, t = new Lt(), n = new Lt(), i = {
    minTv: new Lt(),
    maxTv: new Lt(),
    useDir: !1,
    dirMinTv: new Lt(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, o) {
      i.touchThreshold = 0, a && a.touchThreshold != null && (i.touchThreshold = Va(0, a.touchThreshold)), i.negativeSize = !1, o && (i.minTv.set(1 / 0, 1 / 0), i.maxTv.set(0, 0), i.useDir = !1, a && a.direction != null && (i.useDir = !0, i.dirMinTv.copy(i.minTv), n.copy(i.minTv), e = a.direction, i.bidirectional = a.bidirectional == null || !!a.bidirectional, i.bidirectional || t.set(Math.cos(e), Math.sin(e))));
    },
    calcDirMTV: function() {
      var a = i.minTv, o = i.dirMinTv, s = a.y * a.y + a.x * a.x, l = Math.sin(e), u = Math.cos(e), c = l * a.y + u * a.x;
      if (r(c)) {
        r(a.x) && r(a.y) && o.set(0, 0);
        return;
      }
      if (n.x = s * u / c, n.y = s * l / c, r(n.x) && r(n.y)) {
        o.set(0, 0);
        return;
      }
      (i.bidirectional || t.dot(n) > 0) && n.len() < o.len() && o.copy(n);
    }
  };
  function r(a) {
    return Zd(a) < 1e-10;
  }
  return i;
}
var Jb = "silent";
function zA(e, t, n) {
  return {
    type: e,
    event: n,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: n.zrX,
    offsetY: n.zrY,
    gestureEvent: n.gestureEvent,
    pinchX: n.pinchX,
    pinchY: n.pinchY,
    pinchScale: n.pinchScale,
    wheelDelta: n.zrDelta,
    zrByTouch: n.zrByTouch,
    which: n.which,
    stop: VA
  };
}
function VA() {
  Tu(this.event);
}
var $A = (function(e) {
  At(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.handler = null, n;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
})(En), Mo = /* @__PURE__ */ (function() {
  function e(t, n) {
    this.x = t, this.y = n;
  }
  return e;
})(), HA = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], ph = new it(0, 0, 0, 0), t1 = (function(e) {
  At(t, e);
  function t(n, i, r, a, o) {
    var s = e.call(this) || this;
    return s._hovered = new Mo(0, 0), s.storage = n, s.painter = i, s.painterRoot = a, s._pointerSize = o, r = r || new $A(), s.proxy = null, s.setHandlerProxy(r), s._draggingMgr = new bA(s), s;
  }
  return t.prototype.setHandlerProxy = function(n) {
    this.proxy && this.proxy.dispose(), n && (P(HA, function(i) {
      n.on && n.on(i, this[i], this);
    }, this), n.handler = this), this.proxy = n;
  }, t.prototype.mousemove = function(n) {
    var i = n.zrX, r = n.zrY, a = e1(this, i, r), o = this._hovered, s = o.target;
    s && !s.__zr && (o = this.findHover(o.x, o.y), s = o.target);
    var l = this._hovered = a ? new Mo(i, r) : this.findHover(i, r), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), s && u !== s && this.dispatchToElement(o, "mouseout", n), this.dispatchToElement(l, "mousemove", n), u && u !== s && this.dispatchToElement(l, "mouseover", n);
  }, t.prototype.mouseout = function(n) {
    var i = n.zrEventControl;
    i !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", n), i !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: n });
  }, t.prototype.resize = function() {
    this._hovered = new Mo(0, 0);
  }, t.prototype.dispatch = function(n, i) {
    var r = this[n];
    r && r.call(this, i);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(n) {
    var i = this.proxy;
    i.setCursor && i.setCursor(n);
  }, t.prototype.dispatchToElement = function(n, i, r) {
    n = n || {};
    var a = n.target;
    if (!(a && a.silent)) {
      for (var o = "on" + i, s = zA(i, n, r); a && (a[o] && (s.cancelBubble = !!a[o].call(a, s)), a.trigger(i, s), a = a.__hostTarget ? a.__hostTarget : a.parent, !s.cancelBubble); )
        ;
      s.cancelBubble || (this.trigger(i, s), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[o] == "function" && l[o].call(l, s), l.trigger && l.trigger(i, s);
      }));
    }
  }, t.prototype.findHover = function(n, i, r) {
    var a = this.storage.getDisplayList(), o = new Mo(n, i);
    if (b_(a, o, n, i, r), this._pointerSize && !o.target) {
      for (var s = [], l = this._pointerSize, u = l / 2, c = new it(n - u, i - u, l, l), h = a.length - 1; h >= 0; h--) {
        var d = a[h];
        d !== r && !d.ignore && !d.ignoreCoarsePointer && (!d.parent || !d.parent.ignoreCoarsePointer) && (ph.copy(d.getBoundingRect()), d.transform && ph.applyTransform(d.transform), ph.intersect(c) && s.push(d));
      }
      if (s.length)
        for (var f = 4, v = Math.PI / 12, g = Math.PI * 2, p = 0; p < u; p += f)
          for (var _ = 0; _ < g; _ += v) {
            var m = n + p * Math.cos(_), y = i + p * Math.sin(_);
            if (b_(s, o, m, y, r), o.target)
              return o;
          }
    }
    return o;
  }, t.prototype.processGesture = function(n, i) {
    this._gestureMgr || (this._gestureMgr = new OA());
    var r = this._gestureMgr;
    i === "start" && r.clear();
    var a = r.recognize(n, this.findHover(n.zrX, n.zrY, null).target, this.proxy.dom);
    if (i === "end" && r.clear(), a) {
      var o = a.type;
      n.gestureEvent = o;
      var s = new Mo();
      s.target = a.target, this.dispatchToElement(s, o, a.event);
    }
  }, t;
})(En);
P(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  t1.prototype[e] = function(t) {
    var n = t.zrX, i = t.zrY, r = e1(this, n, i), a, o;
    if ((e !== "mouseup" || !r) && (a = this.findHover(n, i), o = a.target), e === "mousedown")
      this._downEl = o, this._downPoint = [t.zrX, t.zrY], this._upEl = o;
    else if (e === "mouseup")
      this._upEl = o;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || mA(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, e, t);
  };
});
function YA(e, t, n) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, n)) {
    for (var i = e, r = void 0, a = !1; i; ) {
      if (i.ignoreClip && (a = !0), !a) {
        var o = i.getClipPath();
        if (o && !o.contain(t, n))
          return !1;
      }
      i.silent && (r = !0);
      var s = i.__hostTarget;
      i = s ? i.ignoreHostSilent ? null : s : i.parent;
    }
    return r ? Jb : !0;
  }
  return !1;
}
function b_(e, t, n, i, r) {
  for (var a = e.length - 1; a >= 0; a--) {
    var o = e[a], s = void 0;
    if (o !== r && !o.ignore && (s = YA(o, n, i)) && (!t.topTarget && (t.topTarget = o), s !== Jb)) {
      t.target = o;
      break;
    }
  }
}
function e1(e, t, n) {
  var i = e.painter;
  return t < 0 || t > i.getWidth() || n < 0 || n > i.getHeight();
}
var n1 = 32, Do = 7;
function WA(e) {
  for (var t = 0; e >= n1; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function x_(e, t, n, i) {
  var r = t + 1;
  if (r === n)
    return 1;
  if (i(e[r++], e[t]) < 0) {
    for (; r < n && i(e[r], e[r - 1]) < 0; )
      r++;
    UA(e, t, r);
  } else
    for (; r < n && i(e[r], e[r - 1]) >= 0; )
      r++;
  return r - t;
}
function UA(e, t, n) {
  for (n--; t < n; ) {
    var i = e[t];
    e[t++] = e[n], e[n--] = i;
  }
}
function w_(e, t, n, i, r) {
  for (i === t && i++; i < n; i++) {
    for (var a = e[i], o = t, s = i, l; o < s; )
      l = o + s >>> 1, r(a, e[l]) < 0 ? s = l : o = l + 1;
    var u = i - o;
    switch (u) {
      case 3:
        e[o + 3] = e[o + 2];
      case 2:
        e[o + 2] = e[o + 1];
      case 1:
        e[o + 1] = e[o];
        break;
      default:
        for (; u > 0; )
          e[o + u] = e[o + u - 1], u--;
    }
    e[o] = a;
  }
}
function gh(e, t, n, i, r, a) {
  var o = 0, s = 0, l = 1;
  if (a(e, t[n + r]) > 0) {
    for (s = i - r; l < s && a(e, t[n + r + l]) > 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += r, l += r;
  } else {
    for (s = r + 1; l < s && a(e, t[n + r - l]) <= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = r - l, l = r - u;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(e, t[n + c]) > 0 ? o = c + 1 : l = c;
  }
  return l;
}
function _h(e, t, n, i, r, a) {
  var o = 0, s = 0, l = 1;
  if (a(e, t[n + r]) < 0) {
    for (s = r + 1; l < s && a(e, t[n + r - l]) < 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s);
    var u = o;
    o = r - l, l = r - u;
  } else {
    for (s = i - r; l < s && a(e, t[n + r + l]) >= 0; )
      o = l, l = (l << 1) + 1, l <= 0 && (l = s);
    l > s && (l = s), o += r, l += r;
  }
  for (o++; o < l; ) {
    var c = o + (l - o >>> 1);
    a(e, t[n + c]) < 0 ? l = c : o = c + 1;
  }
  return l;
}
function GA(e, t) {
  var n = Do, i, r, a = 0, o = [];
  i = [], r = [];
  function s(f, v) {
    i[a] = f, r[a] = v, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var f = a - 2;
      if (f >= 1 && r[f - 1] <= r[f] + r[f + 1] || f >= 2 && r[f - 2] <= r[f] + r[f - 1])
        r[f - 1] < r[f + 1] && f--;
      else if (r[f] > r[f + 1])
        break;
      c(f);
    }
  }
  function u() {
    for (; a > 1; ) {
      var f = a - 2;
      f > 0 && r[f - 1] < r[f + 1] && f--, c(f);
    }
  }
  function c(f) {
    var v = i[f], g = r[f], p = i[f + 1], _ = r[f + 1];
    r[f] = g + _, f === a - 3 && (i[f + 1] = i[f + 2], r[f + 1] = r[f + 2]), a--;
    var m = _h(e[p], e, v, g, 0, t);
    v += m, g -= m, g !== 0 && (_ = gh(e[v + g - 1], e, p, _, _ - 1, t), _ !== 0 && (g <= _ ? h(v, g, p, _) : d(v, g, p, _)));
  }
  function h(f, v, g, p) {
    var _ = 0;
    for (_ = 0; _ < v; _++)
      o[_] = e[f + _];
    var m = 0, y = g, b = f;
    if (e[b++] = e[y++], --p === 0) {
      for (_ = 0; _ < v; _++)
        e[b + _] = o[m + _];
      return;
    }
    if (v === 1) {
      for (_ = 0; _ < p; _++)
        e[b + _] = e[y + _];
      e[b + p] = o[m];
      return;
    }
    for (var x = n, w, M, D; ; ) {
      w = 0, M = 0, D = !1;
      do
        if (t(e[y], o[m]) < 0) {
          if (e[b++] = e[y++], M++, w = 0, --p === 0) {
            D = !0;
            break;
          }
        } else if (e[b++] = o[m++], w++, M = 0, --v === 1) {
          D = !0;
          break;
        }
      while ((w | M) < x);
      if (D)
        break;
      do {
        if (w = _h(e[y], o, m, v, 0, t), w !== 0) {
          for (_ = 0; _ < w; _++)
            e[b + _] = o[m + _];
          if (b += w, m += w, v -= w, v <= 1) {
            D = !0;
            break;
          }
        }
        if (e[b++] = e[y++], --p === 0) {
          D = !0;
          break;
        }
        if (M = gh(o[m], e, y, p, 0, t), M !== 0) {
          for (_ = 0; _ < M; _++)
            e[b + _] = e[y + _];
          if (b += M, y += M, p -= M, p === 0) {
            D = !0;
            break;
          }
        }
        if (e[b++] = o[m++], --v === 1) {
          D = !0;
          break;
        }
        x--;
      } while (w >= Do || M >= Do);
      if (D)
        break;
      x < 0 && (x = 0), x += 2;
    }
    if (n = x, n < 1 && (n = 1), v === 1) {
      for (_ = 0; _ < p; _++)
        e[b + _] = e[y + _];
      e[b + p] = o[m];
    } else {
      if (v === 0)
        throw new Error();
      for (_ = 0; _ < v; _++)
        e[b + _] = o[m + _];
    }
  }
  function d(f, v, g, p) {
    var _ = 0;
    for (_ = 0; _ < p; _++)
      o[_] = e[g + _];
    var m = f + v - 1, y = p - 1, b = g + p - 1, x = 0, w = 0;
    if (e[b--] = e[m--], --v === 0) {
      for (x = b - (p - 1), _ = 0; _ < p; _++)
        e[x + _] = o[_];
      return;
    }
    if (p === 1) {
      for (b -= v, m -= v, w = b + 1, x = m + 1, _ = v - 1; _ >= 0; _--)
        e[w + _] = e[x + _];
      e[b] = o[y];
      return;
    }
    for (var M = n; ; ) {
      var D = 0, T = 0, C = !1;
      do
        if (t(o[y], e[m]) < 0) {
          if (e[b--] = e[m--], D++, T = 0, --v === 0) {
            C = !0;
            break;
          }
        } else if (e[b--] = o[y--], T++, D = 0, --p === 1) {
          C = !0;
          break;
        }
      while ((D | T) < M);
      if (C)
        break;
      do {
        if (D = v - _h(o[y], e, f, v, v - 1, t), D !== 0) {
          for (b -= D, m -= D, v -= D, w = b + 1, x = m + 1, _ = D - 1; _ >= 0; _--)
            e[w + _] = e[x + _];
          if (v === 0) {
            C = !0;
            break;
          }
        }
        if (e[b--] = o[y--], --p === 1) {
          C = !0;
          break;
        }
        if (T = p - gh(e[m], o, 0, p, p - 1, t), T !== 0) {
          for (b -= T, y -= T, p -= T, w = b + 1, x = y + 1, _ = 0; _ < T; _++)
            e[w + _] = o[x + _];
          if (p <= 1) {
            C = !0;
            break;
          }
        }
        if (e[b--] = e[m--], --v === 0) {
          C = !0;
          break;
        }
        M--;
      } while (D >= Do || T >= Do);
      if (C)
        break;
      M < 0 && (M = 0), M += 2;
    }
    if (n = M, n < 1 && (n = 1), p === 1) {
      for (b -= v, m -= v, w = b + 1, x = m + 1, _ = v - 1; _ >= 0; _--)
        e[w + _] = e[x + _];
      e[b] = o[y];
    } else {
      if (p === 0)
        throw new Error();
      for (x = b - (p - 1), _ = 0; _ < p; _++)
        e[x + _] = o[_];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: s
  };
}
function eu(e, t, n, i) {
  n || (n = 0), i || (i = e.length);
  var r = i - n;
  if (!(r < 2)) {
    var a = 0;
    if (r < n1) {
      a = x_(e, n, i, t), w_(e, n, i, n + a, t);
      return;
    }
    var o = GA(e, t), s = WA(r);
    do {
      if (a = x_(e, n, i, t), a < s) {
        var l = r;
        l > s && (l = s), w_(e, n, n + l, n + a, t), a = l;
      }
      o.pushRun(n, a), o.mergeRuns(), r -= a, n += a;
    } while (r !== 0);
    o.forceMergeRuns();
  }
}
var Ze = 1, Qo = 2, Na = 4, S_ = !1;
function mh() {
  S_ || (S_ = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function M_(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var jA = (function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = M_;
  }
  return e.prototype.traverse = function(t, n) {
    for (var i = 0; i < this._roots.length; i++)
      this._roots[i].traverse(t, n);
  }, e.prototype.getDisplayList = function(t, n) {
    n = n || !1;
    var i = this._displayList;
    return (t || !i.length) && this.updateDisplayList(n), i;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var n = this._roots, i = this._displayList, r = 0, a = n.length; r < a; r++)
      this._updateAndAddDisplayable(n[r], null, t);
    i.length = this._displayListLen, eu(i, M_);
  }, e.prototype._updateAndAddDisplayable = function(t, n, i) {
    if (!(t.ignore && !i)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var r = t.getClipPath(), a = n && n.length, o = 0, s = t.__clipPaths;
      if (!t.ignoreClip && (a || r)) {
        if (s || (s = t.__clipPaths = []), a)
          for (var l = 0; l < n.length; l++)
            s[o++] = n[l];
        for (var u = r, c = t; u; )
          u.parent = c, u.updateTransform(), s[o++] = u, c = u, u = u.getClipPath();
      }
      if (s && (s.length = o), t.childrenRef) {
        for (var h = t.childrenRef(), d = 0; d < h.length; d++) {
          var f = h[d];
          t.__dirty && (f.__dirty |= Ze), this._updateAndAddDisplayable(f, s, i);
        }
        t.__dirty = 0;
      } else {
        var v = t;
        isNaN(v.z) && (mh(), v.z = 0), isNaN(v.z2) && (mh(), v.z2 = 0), isNaN(v.zlevel) && (mh(), v.zlevel = 0), this._displayList[this._displayListLen++] = v;
      }
      var g = t.getDecalElement && t.getDecalElement();
      g && this._updateAndAddDisplayable(g, s, i);
      var p = t.getTextGuideLine();
      p && this._updateAndAddDisplayable(p, s, i);
      var _ = t.getTextContent();
      _ && this._updateAndAddDisplayable(_, s, i);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var n = 0, i = t.length; n < i; n++)
        this.delRoot(t[n]);
      return;
    }
    var r = zt(this._roots, t);
    r >= 0 && this._roots.splice(r, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
})(), ku;
ku = tt.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var fs = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, n = 0.1, i = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!n || n < 1 ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), -(n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / i)));
  },
  elasticOut: function(e) {
    var t, n = 0.1, i = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!n || n < 1 ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), n * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / i) + 1);
  },
  elasticInOut: function(e) {
    var t, n = 0.1, i = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!n || n < 1 ? (n = 1, t = i / 4) : t = i * Math.asin(1 / n) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (n * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / i)) : n * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / i) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - fs.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? fs.bounceIn(e * 2) * 0.5 : fs.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, pl = Math.pow, Xi = Math.sqrt, Cu = 1e-8, i1 = 1e-4, D_ = Xi(3), gl = 1 / 3, Yn = fo(), ln = fo(), Xa = fo();
function Yi(e) {
  return e > -Cu && e < Cu;
}
function r1(e) {
  return e > Cu || e < -Cu;
}
function Ce(e, t, n, i, r) {
  var a = 1 - r;
  return a * a * (a * e + 3 * r * t) + r * r * (r * i + 3 * a * n);
}
function T_(e, t, n, i, r) {
  var a = 1 - r;
  return 3 * (((t - e) * a + 2 * (n - t) * r) * a + (i - n) * r * r);
}
function a1(e, t, n, i, r, a) {
  var o = i + 3 * (t - n) - e, s = 3 * (n - t * 2 + e), l = 3 * (t - e), u = e - r, c = s * s - 3 * o * l, h = s * l - 9 * o * u, d = l * l - 3 * s * u, f = 0;
  if (Yi(c) && Yi(h))
    if (Yi(s))
      a[0] = 0;
    else {
      var v = -l / s;
      v >= 0 && v <= 1 && (a[f++] = v);
    }
  else {
    var g = h * h - 4 * c * d;
    if (Yi(g)) {
      var p = h / c, v = -s / o + p, _ = -p / 2;
      v >= 0 && v <= 1 && (a[f++] = v), _ >= 0 && _ <= 1 && (a[f++] = _);
    } else if (g > 0) {
      var m = Xi(g), y = c * s + 1.5 * o * (-h + m), b = c * s + 1.5 * o * (-h - m);
      y < 0 ? y = -pl(-y, gl) : y = pl(y, gl), b < 0 ? b = -pl(-b, gl) : b = pl(b, gl);
      var v = (-s - (y + b)) / (3 * o);
      v >= 0 && v <= 1 && (a[f++] = v);
    } else {
      var x = (2 * c * s - 3 * o * h) / (2 * Xi(c * c * c)), w = Math.acos(x) / 3, M = Xi(c), D = Math.cos(w), v = (-s - 2 * M * D) / (3 * o), _ = (-s + M * (D + D_ * Math.sin(w))) / (3 * o), T = (-s + M * (D - D_ * Math.sin(w))) / (3 * o);
      v >= 0 && v <= 1 && (a[f++] = v), _ >= 0 && _ <= 1 && (a[f++] = _), T >= 0 && T <= 1 && (a[f++] = T);
    }
  }
  return f;
}
function o1(e, t, n, i, r) {
  var a = 6 * n - 12 * t + 6 * e, o = 9 * t + 3 * i - 3 * e - 9 * n, s = 3 * t - 3 * e, l = 0;
  if (Yi(o)) {
    if (r1(a)) {
      var u = -s / a;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = a * a - 4 * o * s;
    if (Yi(c))
      r[0] = -a / (2 * o);
    else if (c > 0) {
      var h = Xi(c), u = (-a + h) / (2 * o), d = (-a - h) / (2 * o);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function Pu(e, t, n, i, r, a) {
  var o = (t - e) * r + e, s = (n - t) * r + t, l = (i - n) * r + n, u = (s - o) * r + o, c = (l - s) * r + s, h = (c - u) * r + u;
  a[0] = e, a[1] = o, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = i;
}
function XA(e, t, n, i, r, a, o, s, l, u, c) {
  var h, d = 5e-3, f = 1 / 0, v, g, p, _;
  Yn[0] = l, Yn[1] = u;
  for (var m = 0; m < 1; m += 0.05)
    ln[0] = Ce(e, n, r, o, m), ln[1] = Ce(t, i, a, s, m), p = ja(Yn, ln), p < f && (h = m, f = p);
  f = 1 / 0;
  for (var y = 0; y < 32 && !(d < i1); y++)
    v = h - d, g = h + d, ln[0] = Ce(e, n, r, o, v), ln[1] = Ce(t, i, a, s, v), p = ja(ln, Yn), v >= 0 && p < f ? (h = v, f = p) : (Xa[0] = Ce(e, n, r, o, g), Xa[1] = Ce(t, i, a, s, g), _ = ja(Xa, Yn), g <= 1 && _ < f ? (h = g, f = _) : d *= 0.5);
  return Xi(f);
}
function qA(e, t, n, i, r, a, o, s, l) {
  for (var u = e, c = t, h = 0, d = 1 / l, f = 1; f <= l; f++) {
    var v = f * d, g = Ce(e, n, r, o, v), p = Ce(t, i, a, s, v), _ = g - u, m = p - c;
    h += Math.sqrt(_ * _ + m * m), u = g, c = p;
  }
  return h;
}
function ze(e, t, n, i) {
  var r = 1 - i;
  return r * (r * e + 2 * i * t) + i * i * n;
}
function k_(e, t, n, i) {
  return 2 * ((1 - i) * (t - e) + i * (n - t));
}
function ZA(e, t, n, i, r) {
  var a = e - 2 * t + n, o = 2 * (t - e), s = e - i, l = 0;
  if (Yi(a)) {
    if (r1(o)) {
      var u = -s / o;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = o * o - 4 * a * s;
    if (Yi(c)) {
      var u = -o / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u);
    } else if (c > 0) {
      var h = Xi(c), u = (-o + h) / (2 * a), d = (-o - h) / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function s1(e, t, n) {
  var i = e + n - 2 * t;
  return i === 0 ? 0.5 : (e - t) / i;
}
function Au(e, t, n, i, r) {
  var a = (t - e) * i + e, o = (n - t) * i + t, s = (o - a) * i + a;
  r[0] = e, r[1] = a, r[2] = s, r[3] = s, r[4] = o, r[5] = n;
}
function KA(e, t, n, i, r, a, o, s, l) {
  var u, c = 5e-3, h = 1 / 0;
  Yn[0] = o, Yn[1] = s;
  for (var d = 0; d < 1; d += 0.05) {
    ln[0] = ze(e, n, r, d), ln[1] = ze(t, i, a, d);
    var f = ja(Yn, ln);
    f < h && (u = d, h = f);
  }
  h = 1 / 0;
  for (var v = 0; v < 32 && !(c < i1); v++) {
    var g = u - c, p = u + c;
    ln[0] = ze(e, n, r, g), ln[1] = ze(t, i, a, g);
    var f = ja(ln, Yn);
    if (g >= 0 && f < h)
      u = g, h = f;
    else {
      Xa[0] = ze(e, n, r, p), Xa[1] = ze(t, i, a, p);
      var _ = ja(Xa, Yn);
      p <= 1 && _ < h ? (u = p, h = _) : c *= 0.5;
    }
  }
  return Xi(h);
}
function QA(e, t, n, i, r, a, o) {
  for (var s = e, l = t, u = 0, c = 1 / o, h = 1; h <= o; h++) {
    var d = h * c, f = ze(e, n, r, d), v = ze(t, i, a, d), g = f - s, p = v - l;
    u += Math.sqrt(g * g + p * p), s = f, l = v;
  }
  return u;
}
var JA = /cubic-bezier\(([0-9,\.e ]+)\)/;
function l1(e) {
  var t = e && JA.exec(e);
  if (t) {
    var n = t[1].split(","), i = +Un(n[0]), r = +Un(n[1]), a = +Un(n[2]), o = +Un(n[3]);
    if (isNaN(i + r + a + o))
      return;
    var s = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : a1(0, i, a, 1, l, s) && Ce(0, r, o, 1, s[0]);
    };
  }
}
var tE = (function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || ye, this.ondestroy = t.ondestroy || ye, this.onrestart = t.onrestart || ye, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, n) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += n;
      return;
    }
    var i = this._life, r = t - this._startTime - this._pausedTime, a = r / i;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var o = this.easingFunc, s = o ? o(a) : a;
    if (this.onframe(s), a === 1)
      if (this.loop) {
        var l = r % i;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = gt(t) ? t : fs[t] || l1(t);
  }, e;
})(), u1 = /* @__PURE__ */ (function() {
  function e(t) {
    this.value = t;
  }
  return e;
})(), eE = (function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var n = new u1(t);
    return this.insertEntry(n), n;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var n = t.prev, i = t.next;
    n ? n.next = i : this.head = i, i ? i.prev = n : this.tail = n, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
})(), io = (function() {
  function e(t) {
    this._list = new eE(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, n) {
    var i = this._list, r = this._map, a = null;
    if (r[t] == null) {
      var o = i.len(), s = this._lastRemovedEntry;
      if (o >= this._maxSize && o > 0) {
        var l = i.head;
        i.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      s ? s.value = n : s = new u1(n), s.key = t, i.insertEntry(s), r[t] = s;
    }
    return a;
  }, e.prototype.get = function(t) {
    var n = this._map[t], i = this._list;
    if (n != null)
      return n !== i.tail && (i.remove(n), i.insertEntry(n)), n.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
})(), C_ = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function qi(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function nE(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function Eu(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function yh(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? qi(parseFloat(t) / 100 * 255) : qi(parseInt(t, 10));
}
function Kr(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Eu(parseFloat(t) / 100) : Eu(parseFloat(t));
}
function bh(e, t, n) {
  return n < 0 ? n += 1 : n > 1 && (n -= 1), n * 6 < 1 ? e + (t - e) * n * 6 : n * 2 < 1 ? t : n * 3 < 2 ? e + (t - e) * (2 / 3 - n) * 6 : e;
}
function _l(e, t, n) {
  return e + (t - e) * n;
}
function rn(e, t, n, i, r) {
  return e[0] = t, e[1] = n, e[2] = i, e[3] = r, e;
}
function Qd(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var c1 = new io(20), ml = null;
function ma(e, t) {
  ml && Qd(ml, t), ml = c1.put(e, ml || t.slice());
}
function bi(e, t) {
  if (e) {
    t = t || [];
    var n = c1.get(e);
    if (n)
      return Qd(t, n);
    e = e + "";
    var i = e.replace(/ /g, "").toLowerCase();
    if (i in C_)
      return Qd(t, C_[i]), ma(e, t), t;
    var r = i.length;
    if (i.charAt(0) === "#") {
      if (r === 4 || r === 5) {
        var a = parseInt(i.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          rn(t, 0, 0, 0, 1);
          return;
        }
        return rn(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(i.slice(4), 16) / 15 : 1), ma(e, t), t;
      } else if (r === 7 || r === 9) {
        var a = parseInt(i.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          rn(t, 0, 0, 0, 1);
          return;
        }
        return rn(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(i.slice(7), 16) / 255 : 1), ma(e, t), t;
      }
      return;
    }
    var o = i.indexOf("("), s = i.indexOf(")");
    if (o !== -1 && s + 1 === r) {
      var l = i.substr(0, o), u = i.substr(o + 1, s - (o + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? rn(t, +u[0], +u[1], +u[2], 1) : rn(t, 0, 0, 0, 1);
          c = Kr(u.pop());
        case "rgb":
          if (u.length >= 3)
            return rn(t, yh(u[0]), yh(u[1]), yh(u[2]), u.length === 3 ? c : Kr(u[3])), ma(e, t), t;
          rn(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            rn(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = Kr(u[3]), Jd(u, t), ma(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            rn(t, 0, 0, 0, 1);
            return;
          }
          return Jd(u, t), ma(e, t), t;
        default:
          return;
      }
    }
    rn(t, 0, 0, 0, 1);
  }
}
function Jd(e, t) {
  var n = (parseFloat(e[0]) % 360 + 360) % 360 / 360, i = Kr(e[1]), r = Kr(e[2]), a = r <= 0.5 ? r * (i + 1) : r + i - r * i, o = r * 2 - a;
  return t = t || [], rn(t, qi(bh(o, a, n + 1 / 3) * 255), qi(bh(o, a, n) * 255), qi(bh(o, a, n - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function iE(e) {
  if (e) {
    var t = e[0] / 255, n = e[1] / 255, i = e[2] / 255, r = Math.min(t, n, i), a = Math.max(t, n, i), o = a - r, s = (a + r) / 2, l, u;
    if (o === 0)
      l = 0, u = 0;
    else {
      s < 0.5 ? u = o / (a + r) : u = o / (2 - a - r);
      var c = ((a - t) / 6 + o / 2) / o, h = ((a - n) / 6 + o / 2) / o, d = ((a - i) / 6 + o / 2) / o;
      t === a ? l = d - h : n === a ? l = 1 / 3 + c - d : i === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var f = [l * 360, u, s];
    return e[3] != null && f.push(e[3]), f;
  }
}
function P_(e, t) {
  var n = bi(e);
  if (n) {
    for (var i = 0; i < 3; i++)
      n[i] = n[i] * (1 - t) | 0, n[i] > 255 ? n[i] = 255 : n[i] < 0 && (n[i] = 0);
    return Qr(n, n.length === 4 ? "rgba" : "rgb");
  }
}
function xh(e, t, n) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    n = n || [];
    var i = e * (t.length - 1), r = Math.floor(i), a = Math.ceil(i), o = t[r], s = t[a], l = i - r;
    return n[0] = qi(_l(o[0], s[0], l)), n[1] = qi(_l(o[1], s[1], l)), n[2] = qi(_l(o[2], s[2], l)), n[3] = Eu(_l(o[3], s[3], l)), n;
  }
}
function qa(e, t, n, i) {
  var r = bi(e);
  if (e)
    return r = iE(r), t != null && (r[0] = nE(gt(t) ? t(r[0]) : t)), n != null && (r[1] = Kr(gt(n) ? n(r[1]) : n)), i != null && (r[2] = Kr(gt(i) ? i(r[2]) : i)), Qr(Jd(r), "rgba");
}
function rE(e, t) {
  var n = bi(e);
  if (n && t != null)
    return n[3] = Eu(t), Qr(n, "rgba");
}
function Qr(e, t) {
  if (!(!e || !e.length)) {
    var n = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (n += "," + e[3]), t + "(" + n + ")";
  }
}
function Lu(e, t) {
  var n = bi(e);
  return n ? (0.299 * n[0] + 0.587 * n[1] + 0.114 * n[2]) * n[3] / 255 + (1 - n[3]) * t : 0;
}
var A_ = new io(100);
function E_(e) {
  if (K(e)) {
    var t = A_.get(e);
    return t || (t = P_(e, -0.1), A_.put(e, t)), t;
  } else if (wc(e)) {
    var n = $({}, e);
    return n.colorStops = yt(e.colorStops, function(i) {
      return {
        offset: i.offset,
        color: P_(i.color, -0.1)
      };
    }), n;
  }
  return e;
}
function aE(e) {
  return e.type === "linear";
}
function oE(e) {
  return e.type === "radial";
}
(function() {
  return tt.hasGlobalWindow && gt(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && qr("Base64 isn't natively supported in the current environment."), null;
  };
})();
var tf = Array.prototype.slice;
function hi(e, t, n) {
  return (t - e) * n + e;
}
function wh(e, t, n, i) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = hi(t[a], n[a], i);
  return e;
}
function sE(e, t, n, i) {
  for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
    e[o] || (e[o] = []);
    for (var s = 0; s < a; s++)
      e[o][s] = hi(t[o][s], n[o][s], i);
  }
  return e;
}
function yl(e, t, n, i) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = t[a] + n[a] * i;
  return e;
}
function L_(e, t, n, i) {
  for (var r = t.length, a = r && t[0].length, o = 0; o < r; o++) {
    e[o] || (e[o] = []);
    for (var s = 0; s < a; s++)
      e[o][s] = t[o][s] + n[o][s] * i;
  }
  return e;
}
function lE(e, t) {
  for (var n = e.length, i = t.length, r = n > i ? t : e, a = Math.min(n, i), o = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, s = a; s < Math.max(n, i); s++)
    r.push({
      offset: o.offset,
      color: o.color.slice()
    });
}
function uE(e, t, n) {
  var i = e, r = t;
  if (!(!i.push || !r.push)) {
    var a = i.length, o = r.length;
    if (a !== o) {
      var s = a > o;
      if (s)
        i.length = o;
      else
        for (var l = a; l < o; l++)
          i.push(n === 1 ? r[l] : tf.call(r[l]));
    }
    for (var u = i[0] && i[0].length, l = 0; l < i.length; l++)
      if (n === 1)
        isNaN(i[l]) && (i[l] = r[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(i[l][c]) && (i[l][c] = r[l][c]);
  }
}
function nu(e) {
  if (We(e)) {
    var t = e.length;
    if (We(e[0])) {
      for (var n = [], i = 0; i < t; i++)
        n.push(tf.call(e[i]));
      return n;
    }
    return tf.call(e);
  }
  return e;
}
function iu(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function cE(e) {
  return We(e && e[0]) ? 2 : 1;
}
var bl = 0, ru = 1, h1 = 2, Jo = 3, ef = 4, nf = 5, O_ = 6;
function I_(e) {
  return e === ef || e === nf;
}
function xl(e) {
  return e === ru || e === h1;
}
var To = [0, 0, 0, 0], hE = (function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, n, i) {
    this._needsSort = !0;
    var r = this.keyframes, a = r.length, o = !1, s = O_, l = n;
    if (We(n)) {
      var u = cE(n);
      s = u, (u === 1 && !Xt(n[0]) || u === 2 && !Xt(n[0][0])) && (o = !0);
    } else if (Xt(n) && !jb(n))
      s = bl;
    else if (K(n))
      if (!isNaN(+n))
        s = bl;
      else {
        var c = bi(n);
        c && (l = c, s = Jo);
      }
    else if (wc(n)) {
      var h = $({}, l);
      h.colorStops = yt(n.colorStops, function(f) {
        return {
          offset: f.offset,
          color: bi(f.color)
        };
      }), aE(n) ? s = ef : oE(n) && (s = nf), l = h;
    }
    a === 0 ? this.valType = s : (s !== this.valType || s === O_) && (o = !0), this.discrete = this.discrete || o;
    var d = {
      time: t,
      value: l,
      rawValue: n,
      percent: 0
    };
    return i && (d.easing = i, d.easingFunc = gt(i) ? i : fs[i] || l1(i)), r.push(d), d;
  }, e.prototype.prepare = function(t, n) {
    var i = this.keyframes;
    this._needsSort && i.sort(function(g, p) {
      return g.time - p.time;
    });
    for (var r = this.valType, a = i.length, o = i[a - 1], s = this.discrete, l = xl(r), u = I_(r), c = 0; c < a; c++) {
      var h = i[c], d = h.value, f = o.value;
      h.percent = h.time / t, s || (l && c !== a - 1 ? uE(d, f, r) : u && lE(d.colorStops, f.colorStops));
    }
    if (!s && r !== nf && n && this.needsAnimate() && n.needsAnimate() && r === n.valType && !n._finished) {
      this._additiveTrack = n;
      for (var v = i[0].value, c = 0; c < a; c++)
        r === bl ? i[c].additiveValue = i[c].value - v : r === Jo ? i[c].additiveValue = yl([], i[c].value, v, -1) : xl(r) && (i[c].additiveValue = r === ru ? yl([], i[c].value, v, -1) : L_([], i[c].value, v, -1));
    }
  }, e.prototype.step = function(t, n) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var i = this._additiveTrack != null, r = i ? "additiveValue" : "value", a = this.valType, o = this.keyframes, s = o.length, l = this.propName, u = a === Jo, c, h = this._lastFr, d = Math.min, f, v;
      if (s === 1)
        f = v = o[0];
      else {
        if (n < 0)
          c = 0;
        else if (n < this._lastFrP) {
          var g = d(h + 1, s - 1);
          for (c = g; c >= 0 && !(o[c].percent <= n); c--)
            ;
          c = d(c, s - 2);
        } else {
          for (c = h; c < s && !(o[c].percent > n); c++)
            ;
          c = d(c - 1, s - 2);
        }
        v = o[c + 1], f = o[c];
      }
      if (f && v) {
        this._lastFr = c, this._lastFrP = n;
        var p = v.percent - f.percent, _ = p === 0 ? 1 : d((n - f.percent) / p, 1);
        v.easingFunc && (_ = v.easingFunc(_));
        var m = i ? this._additiveValue : u ? To : t[l];
        if ((xl(a) || u) && !m && (m = this._additiveValue = []), this.discrete)
          t[l] = _ < 1 ? f.rawValue : v.rawValue;
        else if (xl(a))
          a === ru ? wh(m, f[r], v[r], _) : sE(m, f[r], v[r], _);
        else if (I_(a)) {
          var y = f[r], b = v[r], x = a === ef;
          t[l] = {
            type: x ? "linear" : "radial",
            x: hi(y.x, b.x, _),
            y: hi(y.y, b.y, _),
            colorStops: yt(y.colorStops, function(M, D) {
              var T = b.colorStops[D];
              return {
                offset: hi(M.offset, T.offset, _),
                color: iu(wh([], M.color, T.color, _))
              };
            }),
            global: b.global
          }, x ? (t[l].x2 = hi(y.x2, b.x2, _), t[l].y2 = hi(y.y2, b.y2, _)) : t[l].r = hi(y.r, b.r, _);
        } else if (u)
          wh(m, f[r], v[r], _), i || (t[l] = iu(m));
        else {
          var w = hi(f[r], v[r], _);
          i ? this._additiveValue = w : t[l] = w;
        }
        i && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var n = this.valType, i = this.propName, r = this._additiveValue;
    n === bl ? t[i] = t[i] + r : n === Jo ? (bi(t[i], To), yl(To, To, r, 1), t[i] = iu(To)) : n === ru ? yl(t[i], t[i], r, 1) : n === h1 && L_(t[i], t[i], r, 1);
  }, e;
})(), Dv = (function() {
  function e(t, n, i, r) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = n, n && r) {
      qr("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = r, this._allowDiscrete = i;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, n, i) {
    return this.whenWithKeys(t, n, jt(n), i);
  }, e.prototype.whenWithKeys = function(t, n, i, r) {
    for (var a = this._tracks, o = 0; o < i.length; o++) {
      var s = i[o], l = a[s];
      if (!l) {
        l = a[s] = new hE(s);
        var u = void 0, c = this._getAdditiveTrack(s);
        if (c) {
          var h = c.keyframes, d = h[h.length - 1];
          u = d && d.value, c.valType === Jo && u && (u = iu(u));
        } else
          u = this._target[s];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, nu(u), r), this._trackKeys.push(s);
      }
      l.addKeyframe(t, nu(n[s]), r);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var n = t.length, i = 0; i < n; i++)
        t[i].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, n = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, n)
      for (var i = 0; i < n.length; i++)
        n[i].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, n = this._trackKeys, i = 0; i < n.length; i++)
      t[n[i]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var n, i = this._additiveAnimators;
    if (i)
      for (var r = 0; r < i.length; r++) {
        var a = i[r].getTrack(t);
        a && (n = a);
      }
    return n;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var n = this, i = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var o = this._trackKeys[a], s = this._tracks[o], l = this._getAdditiveTrack(o), u = s.keyframes, c = u.length;
        if (s.prepare(r, l), s.needsAnimate())
          if (!this._allowDiscrete && s.discrete) {
            var h = u[c - 1];
            h && (n._target[s.propName] = h.rawValue), s.setFinished();
          } else
            i.push(s);
      }
      if (i.length || this._force) {
        var d = new tE({
          life: r,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(f) {
            n._started = 2;
            var v = n._additiveAnimators;
            if (v) {
              for (var g = !1, p = 0; p < v.length; p++)
                if (v[p]._clip) {
                  g = !0;
                  break;
                }
              g || (n._additiveAnimators = null);
            }
            for (var p = 0; p < i.length; p++)
              i[p].step(n._target, f);
            var _ = n._onframeCbs;
            if (_)
              for (var p = 0; p < _.length; p++)
                _[p](n._target, f);
          },
          ondestroy: function() {
            n._doneCallback();
          }
        });
        this._clip = d, this.animation && this.animation.addClip(d), t && d.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var n = this._clip;
      t && n.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return yt(this._trackKeys, function(n) {
      return t._tracks[n];
    });
  }, e.prototype.stopTracks = function(t, n) {
    if (!t.length || !this._clip)
      return !0;
    for (var i = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
      var o = i[t[a]];
      o && !o.isFinished() && (n ? o.step(this._target, 1) : this._started === 1 && o.step(this._target, 0), o.setFinished());
    }
    for (var s = !0, a = 0; a < r.length; a++)
      if (!i[r[a]].isFinished()) {
        s = !1;
        break;
      }
    return s && this._abortedCallback(), s;
  }, e.prototype.saveTo = function(t, n, i) {
    if (t) {
      n = n || this._trackKeys;
      for (var r = 0; r < n.length; r++) {
        var a = n[r], o = this._tracks[a];
        if (!(!o || o.isFinished())) {
          var s = o.keyframes, l = s[i ? 0 : s.length - 1];
          l && (t[a] = nu(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, n) {
    n = n || jt(t);
    for (var i = 0; i < n.length; i++) {
      var r = n[i], a = this._tracks[r];
      if (a) {
        var o = a.keyframes;
        if (o.length > 1) {
          var s = o.pop();
          a.addKeyframe(s.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, e;
})();
function $a() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var dE = (function(e) {
  At(t, e);
  function t(n) {
    var i = e.call(this) || this;
    return i._running = !1, i._time = 0, i._pausedTime = 0, i._pauseStart = 0, i._paused = !1, n = n || {}, i.stage = n.stage || {}, i;
  }
  return t.prototype.addClip = function(n) {
    n.animation && this.removeClip(n), this._head ? (this._tail.next = n, n.prev = this._tail, n.next = null, this._tail = n) : this._head = this._tail = n, n.animation = this;
  }, t.prototype.addAnimator = function(n) {
    n.animation = this;
    var i = n.getClip();
    i && this.addClip(i);
  }, t.prototype.removeClip = function(n) {
    if (n.animation) {
      var i = n.prev, r = n.next;
      i ? i.next = r : this._head = r, r ? r.prev = i : this._tail = i, n.next = n.prev = n.animation = null;
    }
  }, t.prototype.removeAnimator = function(n) {
    var i = n.getClip();
    i && this.removeClip(i), n.animation = null;
  }, t.prototype.update = function(n) {
    for (var i = $a() - this._pausedTime, r = i - this._time, a = this._head; a; ) {
      var o = a.next, s = a.step(i, r);
      s && (a.ondestroy(), this.removeClip(a)), a = o;
    }
    this._time = i, n || (this.trigger("frame", r), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var n = this;
    this._running = !0;
    function i() {
      n._running && (ku(i), !n._paused && n.update());
    }
    ku(i);
  }, t.prototype.start = function() {
    this._running || (this._time = $a(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = $a(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += $a() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var n = this._head; n; ) {
      var i = n.next;
      n.prev = n.next = n.animation = null, n = i;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(n, i) {
    i = i || {}, this.start();
    var r = new Dv(n, i.loop);
    return this.addAnimator(r), r;
  }, t;
})(En), fE = 300, Sh = tt.domSupported, Mh = (function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], n = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, i = yt(e, function(r) {
    var a = r.replace("mouse", "pointer");
    return n.hasOwnProperty(a) ? a : r;
  });
  return {
    mouse: e,
    touch: t,
    pointer: i
  };
})(), R_ = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, N_ = !1;
function rf(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function vE(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function Dh(e) {
  e && (e.zrByTouch = !0);
}
function pE(e, t) {
  return an(e.dom, new gE(e, t), !0);
}
function d1(e, t) {
  for (var n = t, i = !1; n && n.nodeType !== 9 && !(i = n.domBelongToZr || n !== t && n === e.painterRoot); )
    n = n.parentNode;
  return i;
}
var gE = /* @__PURE__ */ (function() {
  function e(t, n) {
    this.stopPropagation = ye, this.stopImmediatePropagation = ye, this.preventDefault = ye, this.type = n.type, this.target = this.currentTarget = t.dom, this.pointerType = n.pointerType, this.clientX = n.clientX, this.clientY = n.clientY;
  }
  return e;
})(), bn = {
  mousedown: function(e) {
    e = an(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = an(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = an(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = an(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    d1(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    N_ = !0, e = an(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    N_ || (e = an(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = an(this.dom, e), Dh(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), bn.mousemove.call(this, e), bn.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = an(this.dom, e), Dh(e), this.handler.processGesture(e, "change"), bn.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = an(this.dom, e), Dh(e), this.handler.processGesture(e, "end"), bn.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < fE && bn.click.call(this, e);
  },
  pointerdown: function(e) {
    bn.mousedown.call(this, e);
  },
  pointermove: function(e) {
    rf(e) || bn.mousemove.call(this, e);
  },
  pointerup: function(e) {
    bn.mouseup.call(this, e);
  },
  pointerout: function(e) {
    rf(e) || bn.mouseout.call(this, e);
  }
};
P(["click", "dblclick", "contextmenu"], function(e) {
  bn[e] = function(t) {
    t = an(this.dom, t), this.trigger(e, t);
  };
});
var af = {
  pointermove: function(e) {
    rf(e) || af.mousemove.call(this, e);
  },
  pointerup: function(e) {
    af.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function _E(e, t) {
  var n = t.domHandlers;
  tt.pointerEventsSupported ? P(Mh.pointer, function(i) {
    au(t, i, function(r) {
      n[i].call(e, r);
    });
  }) : (tt.touchEventsSupported && P(Mh.touch, function(i) {
    au(t, i, function(r) {
      n[i].call(e, r), vE(t);
    });
  }), P(Mh.mouse, function(i) {
    au(t, i, function(r) {
      r = xv(r), t.touching || n[i].call(e, r);
    });
  }));
}
function mE(e, t) {
  tt.pointerEventsSupported ? P(R_.pointer, n) : tt.touchEventsSupported || P(R_.mouse, n);
  function n(i) {
    function r(a) {
      a = xv(a), d1(e, a.target) || (a = pE(e, a), t.domHandlers[i].call(e, a));
    }
    au(t, i, r, { capture: !0 });
  }
}
function au(e, t, n, i) {
  e.mounted[t] = n, e.listenerOpts[t] = i, EA(e.domTarget, t, n, i);
}
function Th(e) {
  var t = e.mounted;
  for (var n in t)
    t.hasOwnProperty(n) && LA(e.domTarget, n, t[n], e.listenerOpts[n]);
  e.mounted = {};
}
var F_ = /* @__PURE__ */ (function() {
  function e(t, n) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = n;
  }
  return e;
})(), yE = (function(e) {
  At(t, e);
  function t(n, i) {
    var r = e.call(this) || this;
    return r.__pointerCapturing = !1, r.dom = n, r.painterRoot = i, r._localHandlerScope = new F_(n, bn), Sh && (r._globalHandlerScope = new F_(document, af)), _E(r, r._localHandlerScope), r;
  }
  return t.prototype.dispose = function() {
    Th(this._localHandlerScope), Sh && Th(this._globalHandlerScope);
  }, t.prototype.setCursor = function(n) {
    this.dom.style && (this.dom.style.cursor = n || "default");
  }, t.prototype.__togglePointerCapture = function(n) {
    if (this.__mayPointerCapture = null, Sh && +this.__pointerCapturing ^ +n) {
      this.__pointerCapturing = n;
      var i = this._globalHandlerScope;
      n ? mE(this, i) : Th(i);
    }
  }, t;
})(En), f1 = 1;
tt.hasGlobalWindow && (f1 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Ou = f1, of = 0.4, sf = "#333", lf = "#ccc", bE = "#eee", B_ = wv, z_ = 5e-5;
function vr(e) {
  return e > z_ || e < -z_;
}
var pr = [], ya = [], kh = qn(), Ch = Math.abs, Hr = (function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return vr(this.rotation) || vr(this.x) || vr(this.y) || vr(this.scaleX - 1) || vr(this.scaleY - 1) || vr(this.skewX) || vr(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, n = this.needLocalTransform(), i = this.transform;
    if (!(n || t)) {
      i && (B_(i), this.invTransform = null);
      return;
    }
    i = i || qn(), n ? this.getLocalTransform(i) : B_(i), t && (n ? hs(i, t, i) : Sv(i, t)), this.transform = i, this._resolveGlobalScaleRatio(i);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var n = this.globalScaleRatio;
    if (n != null && n !== 1) {
      this.getGlobalScale(pr);
      var i = pr[0] < 0 ? -1 : 1, r = pr[1] < 0 ? -1 : 1, a = ((pr[0] - i) * n + i) / pr[0] || 0, o = ((pr[1] - r) * n + r) / pr[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= o, t[3] *= o;
    }
    this.invTransform = this.invTransform || qn(), Gs(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, n = []; t; )
      n.push(t), t = t.parent;
    for (; t = n.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var n = t[0] * t[0] + t[1] * t[1], i = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
      i = Math.sqrt(i) * Math.cos(a), n = Math.sqrt(n), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = n, this.scaleY = i, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, n = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || qn(), hs(ya, t.invTransform, n), n = ya);
      var i = this.originX, r = this.originY;
      (i || r) && (kh[4] = i, kh[5] = r, hs(ya, n, kh), ya[4] -= i, ya[5] -= r, n = ya), this.setLocalTransform(n);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var n = this.transform;
    return t = t || [], n ? (t[0] = Math.sqrt(n[0] * n[0] + n[1] * n[1]), t[1] = Math.sqrt(n[2] * n[2] + n[3] * n[3]), n[0] < 0 && (t[0] = -t[0]), n[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, n) {
    var i = [t, n], r = this.invTransform;
    return r && Ke(i, i, r), i;
  }, e.prototype.transformCoordToGlobal = function(t, n) {
    var i = [t, n], r = this.transform;
    return r && Ke(i, i, r), i;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Ch(t[0] - 1) > 1e-10 && Ch(t[3] - 1) > 1e-10 ? Math.sqrt(Ch(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    uf(this, t);
  }, e.getLocalTransform = function(t, n) {
    n = n || [];
    var i = t.originX || 0, r = t.originY || 0, a = t.scaleX, o = t.scaleY, s = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, h = t.y, d = t.skewX ? Math.tan(t.skewX) : 0, f = t.skewY ? Math.tan(-t.skewY) : 0;
    if (i || r || s || l) {
      var v = i + s, g = r + l;
      n[4] = -v * a - d * g * o, n[5] = -g * o - f * v * a;
    } else
      n[4] = n[5] = 0;
    return n[0] = a, n[3] = o, n[1] = f * a, n[2] = d * o, u && Mv(n, n, u), n[4] += i + c, n[5] += r + h, n;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  })(), e;
})(), Cs = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function uf(e, t) {
  for (var n = 0; n < Cs.length; n++) {
    var i = Cs[n];
    e[i] = t[i];
  }
}
function Zn(e) {
  wl || (wl = new io(100)), e = e || tr;
  var t = wl.get(e);
  return t || (t = {
    font: e,
    strWidthCache: new io(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: Mi.measureText("", e).width,
    asciiCharWidth: Mi.measureText("a", e).width
  }, wl.put(e, t)), t;
}
var wl;
function xE(e) {
  if (!(Ph >= V_)) {
    e = e || tr;
    for (var t = [], n = +/* @__PURE__ */ new Date(), i = 0; i <= 127; i++)
      t[i] = Mi.measureText(String.fromCharCode(i), e).width;
    var r = +/* @__PURE__ */ new Date() - n;
    return r > 16 ? Ph = V_ : r > 2 && Ph++, t;
  }
}
var Ph = 0, V_ = 5;
function v1(e, t) {
  return e.asciiWidthMapTried || (e.asciiWidthMap = xE(e.font), e.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? e.asciiWidthMap != null ? e.asciiWidthMap[t] : e.asciiCharWidth : e.stWideCharWidth;
}
function Kn(e, t) {
  var n = e.strWidthCache, i = n.get(t);
  return i == null && (i = Mi.measureText(t, e.font).width, n.put(t, i)), i;
}
function $_(e, t, n, i) {
  var r = Kn(Zn(t), e), a = Mc(t), o = ro(0, r, n), s = Jr(0, a, i), l = new it(o, s, r, a);
  return l;
}
function wE(e, t, n, i) {
  var r = ((e || "") + "").split(`
`), a = r.length;
  if (a === 1)
    return $_(r[0], t, n, i);
  for (var o = new it(0, 0, 0, 0), s = 0; s < r.length; s++) {
    var l = $_(r[s], t, n, i);
    s === 0 ? o.copy(l) : o.union(l);
  }
  return o;
}
function ro(e, t, n, i) {
  return n === "right" ? i ? e += t : e -= t : n === "center" && (i ? e += t / 2 : e -= t / 2), e;
}
function Jr(e, t, n, i) {
  return n === "middle" ? i ? e += t / 2 : e -= t / 2 : n === "bottom" && (i ? e += t : e -= t), e;
}
function Mc(e) {
  return Zn(e).stWideCharWidth;
}
function Ps(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function p1(e, t, n) {
  var i = t.position || "inside", r = t.distance != null ? t.distance : 5, a = n.height, o = n.width, s = a / 2, l = n.x, u = n.y, c = "left", h = "top";
  if (i instanceof Array)
    l += Ps(i[0], n.width), u += Ps(i[1], n.height), c = null, h = null;
  else
    switch (i) {
      case "left":
        l -= r, u += s, c = "right", h = "middle";
        break;
      case "right":
        l += r + o, u += s, h = "middle";
        break;
      case "top":
        l += o / 2, u -= r, c = "center", h = "bottom";
        break;
      case "bottom":
        l += o / 2, u += a + r, c = "center";
        break;
      case "inside":
        l += o / 2, u += s, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += r, u += s, h = "middle";
        break;
      case "insideRight":
        l += o - r, u += s, c = "right", h = "middle";
        break;
      case "insideTop":
        l += o / 2, u += r, c = "center";
        break;
      case "insideBottom":
        l += o / 2, u += a - r, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += r, u += r;
        break;
      case "insideTopRight":
        l += o - r, u += r, c = "right";
        break;
      case "insideBottomLeft":
        l += r, u += a - r, h = "bottom";
        break;
      case "insideBottomRight":
        l += o - r, u += a - r, c = "right", h = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = h, e;
}
var Ah = "__zr_normal__", Eh = Cs.concat(["ignore"]), SE = ho(Cs, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), ba = {}, ME = new it(0, 0, 0, 0), Sl = [], Dc = (function() {
  function e(t) {
    this.id = Gb(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, n, i) {
    switch (this.draggable) {
      case "horizontal":
        n = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var r = this.transform;
    r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += n, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var n = this._textContent;
    if (n && (!n.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var i = this.textConfig, r = i.local, a = n.innerTransformable, o = void 0, s = void 0, l = !1;
      a.parent = r ? this : null;
      var u = !1;
      a.copyTransform(n);
      var c = i.position != null, h = i.autoOverflowArea, d = void 0;
      if ((h || c) && (d = ME, i.layoutRect ? d.copy(i.layoutRect) : d.copy(this.getBoundingRect()), r || d.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(ba, i, d) : p1(ba, i, d), a.x = ba.x, a.y = ba.y, o = ba.align, s = ba.verticalAlign;
        var f = i.origin;
        if (f && i.rotation != null) {
          var v = void 0, g = void 0;
          f === "center" ? (v = d.width * 0.5, g = d.height * 0.5) : (v = Ps(f[0], d.width), g = Ps(f[1], d.height)), u = !0, a.originX = -a.x + v + (r ? 0 : d.x), a.originY = -a.y + g + (r ? 0 : d.y);
        }
      }
      i.rotation != null && (a.rotation = i.rotation);
      var p = i.offset;
      p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
      var _ = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (h) {
        var m = _.overflowRect = _.overflowRect || new it(0, 0, 0, 0);
        a.getLocalTransform(Sl), Gs(Sl, Sl), it.copy(m, d), m.applyTransform(Sl);
      } else
        _.overflowRect = null;
      var y = i.inside == null ? typeof i.position == "string" && i.position.indexOf("inside") >= 0 : i.inside, b = void 0, x = void 0, w = void 0;
      y && this.canBeInsideText() ? (b = i.insideFill, x = i.insideStroke, (b == null || b === "auto") && (b = this.getInsideTextFill()), (x == null || x === "auto") && (x = this.getInsideTextStroke(b), w = !0)) : (b = i.outsideFill, x = i.outsideStroke, (b == null || b === "auto") && (b = this.getOutsideFill()), (x == null || x === "auto") && (x = this.getOutsideStroke(b), w = !0)), b = b || "#000", (b !== _.fill || x !== _.stroke || w !== _.autoStroke || o !== _.align || s !== _.verticalAlign) && (l = !0, _.fill = b, _.stroke = x, _.autoStroke = w, _.align = o, _.verticalAlign = s, n.setDefaultTextStyle(_)), n.__dirty |= Ze, l && n.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? lf : sf;
  }, e.prototype.getOutsideStroke = function(t) {
    var n = this.__zr && this.__zr.getBackgroundColor(), i = typeof n == "string" && bi(n);
    i || (i = [255, 255, 255, 1]);
    for (var r = i[3], a = this.__zr.isDarkMode(), o = 0; o < 3; o++)
      i[o] = i[o] * r + (a ? 0 : 255) * (1 - r);
    return i[3] = 1, Qr(i, "rgba");
  }, e.prototype.traverse = function(t, n) {
  }, e.prototype.attrKV = function(t, n) {
    t === "textConfig" ? this.setTextConfig(n) : t === "textContent" ? this.setTextContent(n) : t === "clipPath" ? this.setClipPath(n) : t === "extra" ? (this.extra = this.extra || {}, $(this.extra, n)) : this[t] = n;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, n) {
    if (typeof t == "string")
      this.attrKV(t, n);
    else if (X(t))
      for (var i = t, r = jt(i), a = 0; a < r.length; a++) {
        var o = r[a];
        this.attrKV(o, t[o]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var n = this._normalState, i = 0; i < this.animators.length; i++) {
      var r = this.animators[i], a = r.__fromStateTransition;
      if (!(r.getLoop() || a && a !== Ah)) {
        var o = r.targetName, s = o ? n[o] : n;
        r.saveTo(s);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var n = this._normalState;
    n || (n = this._normalState = {}), t.textConfig && !n.textConfig && (n.textConfig = this.textConfig), this._savePrimaryToNormal(t, n, Eh);
  }, e.prototype._savePrimaryToNormal = function(t, n, i) {
    for (var r = 0; r < i.length; r++) {
      var a = i[r];
      t[a] != null && !(a in n) && (n[a] = this[a]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var n = this.states;
    return n[t] || (n[t] = {}), n[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(Ah, !1, t);
  }, e.prototype.useState = function(t, n, i, r) {
    var a = t === Ah, o = this.hasState();
    if (!(!o && a)) {
      var s = this.currentStates, l = this.stateTransition;
      if (!(zt(s, t) >= 0 && (n || s.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          qr("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || r);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, n, !i && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, d = this._textGuide;
        return h && h.useState(t, n, i, c), d && d.useState(t, n, i, c), a ? (this.currentStates = [], this._normalState = {}) : n ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Ze), u;
      }
    }
  }, e.prototype.useStates = function(t, n, i) {
    if (!t.length)
      this.clearStates();
    else {
      var r = [], a = this.currentStates, o = t.length, s = o === a.length;
      if (s) {
        for (var l = 0; l < o; l++)
          if (t[l] !== a[l]) {
            s = !1;
            break;
          }
      }
      if (s)
        return;
      for (var l = 0; l < o; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && r.push(c);
      }
      var h = r[o - 1], d = !!(h && h.hoverLayer || i);
      d && this._toggleHoverLayerFlag(!0);
      var f = this._mergeStates(r), v = this.stateTransition;
      this.saveCurrentToNormalState(f), this._applyStateObj(t.join(","), f, this._normalState, !1, !n && !this.__inHover && v && v.duration > 0, v);
      var g = this._textContent, p = this._textGuide;
      g && g.useStates(t, n, d), p && p.useStates(t, n, d), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !d && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Ze);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var n = t.__hostTarget;
      t = n ? t.ignoreHostSilent ? null : n : t.parent;
    }
    return !1;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var n = this.animators[t];
      n.targetName && n.changeTarget(this[n.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var n = zt(this.currentStates, t);
    if (n >= 0) {
      var i = this.currentStates.slice();
      i.splice(n, 1), this.useStates(i);
    }
  }, e.prototype.replaceState = function(t, n, i) {
    var r = this.currentStates.slice(), a = zt(r, t), o = zt(r, n) >= 0;
    a >= 0 ? o ? r.splice(a, 1) : r[a] = n : i && !o && r.push(n), this.useStates(r);
  }, e.prototype.toggleState = function(t, n) {
    n ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var n = {}, i, r = 0; r < t.length; r++) {
      var a = t[r];
      $(n, a), a.textConfig && (i = i || {}, $(i, a.textConfig));
    }
    return i && (n.textConfig = i), n;
  }, e.prototype._applyStateObj = function(t, n, i, r, a, o) {
    var s = !(n && r);
    n && n.textConfig ? (this.textConfig = $({}, r ? this.textConfig : i.textConfig), $(this.textConfig, n.textConfig)) : s && i.textConfig && (this.textConfig = i.textConfig);
    for (var l = {}, u = !1, c = 0; c < Eh.length; c++) {
      var h = Eh[c], d = a && SE[h];
      n && n[h] != null ? d ? (u = !0, l[h] = n[h]) : this[h] = n[h] : s && i[h] != null && (d ? (u = !0, l[h] = i[h]) : this[h] = i[h]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], v = f.targetName;
        f.getLoop() || f.__changeFinalValue(v ? (n || i)[v] : n || i);
      }
    u && this._transitionState(t, l, o);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var n = this.__zr;
    n && t.addSelfToZr(n), t.__zr = n, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var n = this._textContent;
    if (n !== t) {
      if (n && n !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new Hr(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), $(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= Ze;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var n = this._textContent, i = this._textGuide;
    n && (n.__inHover = t), i && (i.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var n = this.animators;
      if (n)
        for (var i = 0; i < n.length; i++)
          t.animation.addAnimator(n[i]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var n = this.animators;
      if (n)
        for (var i = 0; i < n.length; i++)
          t.animation.removeAnimator(n[i]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, n, i) {
    var r = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !r) {
      qr('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new Dv(r, n, i);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, e.prototype.addAnimator = function(t, n) {
    var i = this.__zr, r = this;
    t.during(function() {
      r.updateDuringAnimation(n);
    }).done(function() {
      var a = r.animators, o = zt(a, t);
      o >= 0 && a.splice(o, 1);
    }), this.animators.push(t), i && i.animation.addAnimator(t), i && i.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, n) {
    for (var i = this.animators, r = i.length, a = [], o = 0; o < r; o++) {
      var s = i[o];
      !t || t === s.scope ? s.stop(n) : a.push(s);
    }
    return this.animators = a, this;
  }, e.prototype.animateTo = function(t, n, i) {
    Lh(this, t, n, i);
  }, e.prototype.animateFrom = function(t, n, i) {
    Lh(this, t, n, i, !0);
  }, e.prototype._transitionState = function(t, n, i, r) {
    for (var a = Lh(this, n, i, r), o = 0; o < a.length; o++)
      a[o].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = Ze;
    var n = {};
    function i(a, o, s) {
      n[a + o + s] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + o + "', '" + s + "' instead"), n[a + o + s] = !0);
    }
    function r(a, o, s, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && i(a, s, l), !this[o]) {
            var c = this[o] = [];
            u(this, c);
          }
          return this[o];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && i(a, s, l), this[s] = c[0], this[l] = c[1], this[o] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[s];
          },
          set: function(d) {
            c[s] = d;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(d) {
            c[l] = d;
          }
        });
      }
    }
    Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
  })(), e;
})();
An(Dc, En);
An(Dc, Hr);
function Lh(e, t, n, i, r) {
  n = n || {};
  var a = [];
  g1(e, "", e, t, n, i, a, r);
  var o = a.length, s = !1, l = n.done, u = n.aborted, c = function() {
    s = !0, o--, o <= 0 && (s ? l && l() : u && u());
  }, h = function() {
    o--, o <= 0 && (s ? l && l() : u && u());
  };
  o || l && l(), a.length > 0 && n.during && a[0].during(function(v, g) {
    n.during(g);
  });
  for (var d = 0; d < a.length; d++) {
    var f = a[d];
    c && f.done(c), h && f.aborted(h), n.force && f.duration(n.duration), f.start(n.easing);
  }
  return a;
}
function Oh(e, t, n) {
  for (var i = 0; i < n; i++)
    e[i] = t[i];
}
function DE(e) {
  return We(e[0]);
}
function TE(e, t, n) {
  if (We(t[n]))
    if (We(e[n]) || (e[n] = []), Le(t[n])) {
      var i = t[n].length;
      e[n].length !== i && (e[n] = new t[n].constructor(i), Oh(e[n], t[n], i));
    } else {
      var r = t[n], a = e[n], o = r.length;
      if (DE(r))
        for (var s = r[0].length, l = 0; l < o; l++)
          a[l] ? Oh(a[l], r[l], s) : a[l] = Array.prototype.slice.call(r[l]);
      else
        Oh(a, r, o);
      a.length = r.length;
    }
  else
    e[n] = t[n];
}
function kE(e, t) {
  return e === t || We(e) && We(t) && CE(e, t);
}
function CE(e, t) {
  var n = e.length;
  if (n !== t.length)
    return !1;
  for (var i = 0; i < n; i++)
    if (e[i] !== t[i])
      return !1;
  return !0;
}
function g1(e, t, n, i, r, a, o, s) {
  for (var l = jt(i), u = r.duration, c = r.delay, h = r.additive, d = r.setToFinal, f = !X(a), v = e.animators, g = [], p = 0; p < l.length; p++) {
    var _ = l[p], m = i[_];
    if (m != null && n[_] != null && (f || a[_]))
      if (X(m) && !We(m) && !wc(m)) {
        if (t) {
          s || (n[_] = m, e.updateDuringAnimation(t));
          continue;
        }
        g1(e, _, n[_], m, r, a && a[_], o, s);
      } else
        g.push(_);
    else s || (n[_] = m, e.updateDuringAnimation(t), g.push(_));
  }
  var y = g.length;
  if (!h && y)
    for (var b = 0; b < v.length; b++) {
      var x = v[b];
      if (x.targetName === t) {
        var w = x.stopTracks(g);
        if (w) {
          var M = zt(v, x);
          v.splice(M, 1);
        }
      }
    }
  if (r.force || (g = qe(g, function(k) {
    return !kE(i[k], n[k]);
  }), y = g.length), y > 0 || r.force && !o.length) {
    var D = void 0, T = void 0, C = void 0;
    if (s) {
      T = {}, d && (D = {});
      for (var b = 0; b < y; b++) {
        var _ = g[b];
        T[_] = n[_], d ? D[_] = i[_] : n[_] = i[_];
      }
    } else if (d) {
      C = {};
      for (var b = 0; b < y; b++) {
        var _ = g[b];
        C[_] = nu(n[_]), TE(n, i, _);
      }
    }
    var x = new Dv(n, !1, !1, h ? qe(v, function(E) {
      return E.targetName === t;
    }) : null);
    x.targetName = t, r.scope && (x.scope = r.scope), d && D && x.whenWithKeys(0, D, g), C && x.whenWithKeys(0, C, g), x.whenWithKeys(u ?? 500, s ? T : i, g).delay(c || 0), e.addAnimator(x, t), o.push(x);
  }
}
var Dn = (function(e) {
  At(t, e);
  function t(n) {
    var i = e.call(this) || this;
    return i.isGroup = !0, i._children = [], i.attr(n), i;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(n) {
    return this._children[n];
  }, t.prototype.childOfName = function(n) {
    for (var i = this._children, r = 0; r < i.length; r++)
      if (i[r].name === n)
        return i[r];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(n) {
    if (n && (n !== this && n.parent !== this && (this._children.push(n), this._doAdd(n)), process.env.NODE_ENV !== "production" && n.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(n, i) {
    if (n && n !== this && n.parent !== this && i && i.parent === this) {
      var r = this._children, a = r.indexOf(i);
      a >= 0 && (r.splice(a, 0, n), this._doAdd(n));
    }
    return this;
  }, t.prototype.replace = function(n, i) {
    var r = zt(this._children, n);
    return r >= 0 && this.replaceAt(i, r), this;
  }, t.prototype.replaceAt = function(n, i) {
    var r = this._children, a = r[i];
    if (n && n !== this && n.parent !== this && n !== a) {
      r[i] = n, a.parent = null;
      var o = this.__zr;
      o && a.removeSelfFromZr(o), this._doAdd(n);
    }
    return this;
  }, t.prototype._doAdd = function(n) {
    n.parent && n.parent.remove(n), n.parent = this;
    var i = this.__zr;
    i && i !== n.__zr && n.addSelfToZr(i), i && i.refresh();
  }, t.prototype.remove = function(n) {
    var i = this.__zr, r = this._children, a = zt(r, n);
    return a < 0 ? this : (r.splice(a, 1), n.parent = null, i && n.removeSelfFromZr(i), i && i.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var n = this._children, i = this.__zr, r = 0; r < n.length; r++) {
      var a = n[r];
      i && a.removeSelfFromZr(i), a.parent = null;
    }
    return n.length = 0, this;
  }, t.prototype.eachChild = function(n, i) {
    for (var r = this._children, a = 0; a < r.length; a++) {
      var o = r[a];
      n.call(i, o, a);
    }
    return this;
  }, t.prototype.traverse = function(n, i) {
    for (var r = 0; r < this._children.length; r++) {
      var a = this._children[r], o = n.call(i, a);
      a.isGroup && !o && a.traverse(n, i);
    }
    return this;
  }, t.prototype.addSelfToZr = function(n) {
    e.prototype.addSelfToZr.call(this, n);
    for (var i = 0; i < this._children.length; i++) {
      var r = this._children[i];
      r.addSelfToZr(n);
    }
  }, t.prototype.removeSelfFromZr = function(n) {
    e.prototype.removeSelfFromZr.call(this, n);
    for (var i = 0; i < this._children.length; i++) {
      var r = this._children[i];
      r.removeSelfFromZr(n);
    }
  }, t.prototype.getBoundingRect = function(n) {
    for (var i = new it(0, 0, 0, 0), r = n || this._children, a = [], o = null, s = 0; s < r.length; s++) {
      var l = r[s];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (it.applyTransform(i, u, c), o = o || i.clone(), o.union(i)) : (o = o || u.clone(), o.union(u));
      }
    }
    return o || i;
  }, t;
})(Dc);
Dn.prototype.type = "group";
var ts = {}, _1 = {};
function PE(e) {
  delete _1[e];
}
function AE(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return Lu(e, 1) < of;
  if (e.colorStops) {
    for (var t = e.colorStops, n = 0, i = t.length, r = 0; r < i; r++)
      n += Lu(t[r].color, 1);
    return n /= i, n < of;
  }
  return !1;
}
var EE = (function() {
  function e(t, n, i) {
    var r = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, i = i || {}, this.dom = n, this.id = t;
    var a = new jA(), o = i.renderer || "canvas";
    if (ts[o] || (o = jt(ts)[0]), process.env.NODE_ENV !== "production" && !ts[o])
      throw new Error("Renderer '" + o + "' is not imported. Please import it first.");
    i.useDirtyRect = i.useDirtyRect == null ? !1 : i.useDirtyRect;
    var s = new ts[o](n, a, i, t), l = i.ssr || s.ssrOnly;
    this.storage = a, this.painter = s;
    var u = !tt.node && !tt.worker && !l ? new yE(s.getViewportRoot(), s.root) : null, c = i.useCoarsePointer, h = c == null || c === "auto" ? tt.touchEventsSupported : !!c, d = 44, f;
    h && (f = J(i.pointerSize, d)), this.handler = new t1(a, s, u, s.root, f), this.animation = new dE({
      stage: {
        update: l ? null : function() {
          return r._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, n) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, n), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = AE(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var n, i = $a();
    this._needsRefresh && (n = !0, this.refreshImmediately(t)), this._needsRefreshHover && (n = !0, this.refreshHoverImmediately());
    var r = $a();
    n ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: r - i
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, n) {
    if (!this._disposed)
      return this.handler.findHover(t, n);
  }, e.prototype.on = function(t, n, i) {
    return this._disposed || this.handler.on(t, n, i), this;
  }, e.prototype.off = function(t, n) {
    this._disposed || this.handler.off(t, n);
  }, e.prototype.trigger = function(t, n) {
    this._disposed || this.handler.trigger(t, n);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), n = 0; n < t.length; n++)
        t[n] instanceof Dn && t[n].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, PE(this.id));
  }, e;
})();
function H_(e, t) {
  var n = new EE(Gb(), e, t);
  return _1[n.id] = n, n;
}
function LE(e, t) {
  ts[e] = t;
}
var Y_ = 1e-4, m1 = 20;
function OE(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
var As = Math.min, wn = Math.max, gi = Math.abs;
function Es(e, t, n, i) {
  var r = t[0], a = t[1], o = n[0], s = n[1], l = a - r, u = s - o;
  if (l === 0)
    return u === 0 ? o : (o + s) / 2;
  if (l > 0) {
    if (e <= r)
      return o;
    if (e >= a)
      return s;
  } else {
    if (e >= r)
      return o;
    if (e <= a)
      return s;
  }
  return (e - r) / l * u + o;
}
var Ve = IE;
function IE(e, t, n) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return RE(e, t, n);
}
function RE(e, t, n) {
  return K(e) ? OE(e).match(/%$/) ? parseFloat(e) / 100 * t + (n || 0) : parseFloat(e) : e == null ? NaN : +e;
}
function NE(e, t, n) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), m1), e = (+e).toFixed(t), n ? e : +e;
}
function W_(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, n = 0; n < 15; n++, t *= 10)
      if (Math.round(e * t) / t === e)
        return n;
  }
  return FE(e);
}
function FE(e) {
  var t = e.toString().toLowerCase(), n = t.indexOf("e"), i = n > 0 ? +t.slice(n + 1) : 0, r = n > 0 ? n : t.length, a = t.indexOf("."), o = a < 0 ? 0 : r - 1 - a;
  return Math.max(0, o - i);
}
function BE(e, t) {
  var n = Math.max(W_(e), W_(t)), i = e + t;
  return n > m1 ? i : NE(i, n);
}
function y1(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function Iu(e) {
  return e > -Y_ && e < Y_;
}
var zE = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Tc(e) {
  if (e instanceof Date)
    return e;
  if (K(e)) {
    var t = zE.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var n = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (n -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, n, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function Ru(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !K(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function b1(e) {
  return !isNaN(Ru(e));
}
function x1() {
  return Math.round(Math.random() * 9);
}
function w1(e, t) {
  return t === 0 ? e : w1(t, e % t);
}
function U_(e, t) {
  return e == null ? t : t == null ? e : e * t / w1(e, t);
}
var VE = "[ECharts] ", G_ = {}, $E = typeof console < "u" && console.warn && console.log;
function kc(e, t, n) {
  if ($E) {
    if (n) {
      if (G_[t])
        return;
      G_[t] = !0;
    }
    console[e](VE + t);
  }
}
function HE(e, t) {
  kc("log", e, t);
}
function un(e, t) {
  kc("warn", e, t);
}
function qt(e, t) {
  kc("error", e, t);
}
function Di(e) {
  process.env.NODE_ENV !== "production" && kc("warn", "DEPRECATED: " + e, !0);
}
function he(e, t, n) {
  process.env.NODE_ENV !== "production" && Di((n ? "[" + n + "]" : "") + (e + " is deprecated; use " + t + " instead."));
}
function Nu() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var n = "";
  if (process.env.NODE_ENV !== "production") {
    var i = function(r) {
      return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : jb(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : gt(r) ? "function () { ... }" : oA(r) ? r + "" : null;
    };
    n = yt(e, function(r) {
      if (K(r))
        return r;
      var a = i(r);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(r, function(o, s) {
            var l = i(s);
            return l ?? s;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return n;
}
function $e(e) {
  throw new Error(e);
}
var S1 = "series\0", YE = "\0_ec_\0";
function Ae(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function j_(e, t, n) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var i = 0, r = n.length; i < r; i++) {
      var a = n[i];
      !e.emphasis[t].hasOwnProperty(a) && e[t].hasOwnProperty(a) && (e.emphasis[t][a] = e[t][a]);
    }
  }
}
var X_ = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function js(e) {
  return X(e) && !U(e) && !(e instanceof Date) ? e.value : e;
}
function WE(e) {
  return X(e) && !(e instanceof Array);
}
function UE(e, t, n) {
  var i = n === "normalMerge", r = n === "replaceMerge", a = n === "replaceAll";
  e = e || [], t = (t || []).slice();
  var o = st();
  P(t, function(l, u) {
    if (!X(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !Z_(l.id) && q_(l.id), l.name != null && !Z_(l.name) && q_(l.name));
  });
  var s = GE(e, o, n);
  return (i || r) && jE(s, e, o, t), i && XE(s, t), i || r ? qE(s, t, r) : a && ZE(s, t), KE(s), s;
}
function GE(e, t, n) {
  var i = [];
  if (n === "replaceAll")
    return i;
  for (var r = 0; r < e.length; r++) {
    var a = e[r];
    a && a.id != null && t.set(a.id, r), i.push({
      existing: n === "replaceMerge" || ao(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return i;
}
function jE(e, t, n, i) {
  P(i, function(r, a) {
    if (!(!r || r.id == null)) {
      var o = vs(r.id), s = n.get(o);
      if (s != null) {
        var l = e[s];
        Q(!l.newOption, 'Duplicated option on id "' + o + '".'), l.newOption = r, l.existing = t[s], i[a] = null;
      }
    }
  });
}
function XE(e, t) {
  P(t, function(n, i) {
    if (!(!n || n.name == null))
      for (var r = 0; r < e.length; r++) {
        var a = e[r].existing;
        if (!e[r].newOption && a && (a.id == null || n.id == null) && !ao(n) && !ao(a) && M1("name", a, n)) {
          e[r].newOption = n, t[i] = null;
          return;
        }
      }
  });
}
function qE(e, t, n) {
  P(t, function(i) {
    if (i) {
      for (
        var r, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (r = e[a]) && (r.newOption || ao(r.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        r.existing && i.id != null && !M1("id", i, r.existing));
      )
        a++;
      r ? (r.newOption = i, r.brandNew = n) : e.push({
        newOption: i,
        brandNew: n,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function ZE(e, t) {
  P(t, function(n) {
    e.push({
      newOption: n,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function KE(e) {
  var t = st();
  P(e, function(n) {
    var i = n.existing;
    i && t.set(i.id, n);
  }), P(e, function(n) {
    var i = n.newOption;
    Q(!i || i.id == null || !t.get(i.id) || t.get(i.id) === n, "id duplicates: " + (i && i.id)), i && i.id != null && t.set(i.id, n), !n.keyInfo && (n.keyInfo = {});
  }), P(e, function(n, i) {
    var r = n.existing, a = n.newOption, o = n.keyInfo;
    if (X(a)) {
      if (o.name = a.name != null ? vs(a.name) : r ? r.name : S1 + i, r)
        o.id = vs(r.id);
      else if (a.id != null)
        o.id = vs(a.id);
      else {
        var s = 0;
        do
          o.id = "\0" + o.name + "\0" + s++;
        while (t.get(o.id));
      }
      t.set(o.id, n);
    }
  });
}
function M1(e, t, n) {
  var i = Mn(t[e], null), r = Mn(n[e], null);
  return i != null && r != null && i === r;
}
function vs(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return Mn(e, "");
}
function Mn(e, t) {
  return e == null ? t : K(e) ? e : Xt(e) || Mu(e) ? e + "" : t;
}
function q_(e) {
  process.env.NODE_ENV !== "production" && un("`" + e + "` is invalid id or name. Must be a string or number.");
}
function Z_(e) {
  return Mu(e) || b1(e);
}
function D1(e) {
  var t = e.name;
  return !!(t && t.indexOf(S1));
}
function ao(e) {
  return e && e.id != null && vs(e.id).indexOf(YE) === 0;
}
function QE(e, t, n) {
  P(e, function(i) {
    var r = i.newOption;
    X(r) && (i.keyInfo.mainType = t, i.keyInfo.subType = JE(t, r, i.existing, n));
  });
}
function JE(e, t, n, i) {
  var r = t.type ? t.type : n ? n.subType : i.determineSubType(e, t);
  return r;
}
function Xs(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return U(t.dataIndex) ? yt(t.dataIndex, function(n) {
      return e.indexOfRawIndex(n);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return U(t.name) ? yt(t.name, function(n) {
      return e.indexOfName(n);
    }) : e.indexOfName(t.name);
}
function Wt() {
  var e = "__ec_inner_" + tL++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var tL = x1();
function Ih(e, t, n) {
  var i = Tv(t, n), r = i.mainTypeSpecified, a = i.queryOptionMap, o = i.others, s = o, l = n ? n.defaultMainType : null;
  return !r && l && a.set(l, {}), a.each(function(u, c) {
    var h = qs(e, c, u, {
      useDefault: l === c,
      enableAll: n && n.enableAll != null ? n.enableAll : !0,
      enableNone: n && n.enableNone != null ? n.enableNone : !0
    });
    s[c + "Models"] = h.models, s[c + "Model"] = h.models[0];
  }), s;
}
function Tv(e, t) {
  var n;
  if (K(e)) {
    var i = {};
    i[e + "Index"] = 0, n = i;
  } else
    n = e;
  var r = st(), a = {}, o = !1;
  return P(n, function(s, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = s;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || t && t.includeMainTypes && zt(t.includeMainTypes, c) < 0)) {
      o = o || !!c;
      var d = r.get(c) || r.set(c, {});
      d[h] = s;
    }
  }), {
    mainTypeSpecified: o,
    queryOptionMap: r,
    others: a
  };
}
var zi = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
};
function qs(e, t, n, i) {
  i = i || zi;
  var r = n.index, a = n.id, o = n.name, s = {
    models: null,
    specified: r != null || a != null || o != null
  };
  if (!s.specified) {
    var l = void 0;
    return s.models = i.useDefault && (l = e.getComponent(t)) ? [l] : [], s;
  }
  if (r === "none" || r === !1) {
    if (i.enableNone)
      return s.models = [], s;
    process.env.NODE_ENV !== "production" && qt('`"none"` or `false` is not a valid value on index option.'), r = -1;
  }
  return r === "all" && (i.enableAll ? r = a = o = null : (process.env.NODE_ENV !== "production" && qt('`"all"` is not a valid value on index option.'), r = -1)), s.models = e.queryComponents({
    mainType: t,
    index: r,
    id: a,
    name: o
  }), s;
}
function T1(e, t, n) {
  e.setAttribute ? e.setAttribute(t, n) : e[t] = n;
}
function eL(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function nL(e) {
  return e === "auto" ? tt.domSupported ? "html" : "richText" : e || "html";
}
function iL(e, t) {
  var n = st(), i = [];
  return P(e, function(r) {
    var a = t(r);
    (n.get(a) || (i.push(a), n.set(a, []))).push(r);
  }), {
    keys: i,
    buckets: n
  };
}
var rL = ".", gr = "___EC__COMPONENT__CONTAINER___", k1 = "___EC__EXTENDED_CLASS___";
function Gn(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var n = e.split(rL);
    t.main = n[0] || "", t.sub = n[1] || "";
  }
  return t;
}
function aL(e) {
  Q(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function oL(e) {
  return !!(e && e[k1]);
}
function kv(e, t) {
  e.$constructor = e, e.extend = function(n) {
    process.env.NODE_ENV !== "production" && P(t, function(a) {
      n[a] || console.warn("Method `" + a + "` should be implemented" + (n.type ? " in " + n.type : "") + ".");
    });
    var i = this, r;
    return sL(i) ? r = /** @class */
    (function(a) {
      ae(o, a);
      function o() {
        return a.apply(this, arguments) || this;
      }
      return o;
    })(i) : (r = function() {
      (n.$constructor || i).apply(this, arguments);
    }, iA(r, this)), $(r.prototype, n), r[k1] = !0, r.extend = this.extend, r.superCall = cL, r.superApply = hL, r.superClass = i, r;
  };
}
function sL(e) {
  return gt(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function C1(e, t) {
  e.extend = t.extend;
}
var lL = Math.round(Math.random() * 10);
function uL(e) {
  var t = ["__\0is_clz", lL++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && Q(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(n) {
    return !!(n && n[t]);
  };
}
function cL(e, t) {
  for (var n = [], i = 2; i < arguments.length; i++)
    n[i - 2] = arguments[i];
  return this.superClass.prototype[t].apply(e, n);
}
function hL(e, t, n) {
  return this.superClass.prototype[t].apply(e, n);
}
function Cv(e) {
  var t = {};
  e.registerClass = function(i) {
    var r = i.type || i.prototype.type;
    if (r) {
      aL(r), i.prototype.type = r;
      var a = Gn(r);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = i;
      else if (a.sub !== gr) {
        var o = n(a);
        o[a.sub] = i;
      }
    }
    return i;
  }, e.getClass = function(i, r, a) {
    var o = t[i];
    if (o && o[gr] && (o = r ? o[r] : null), a && !o)
      throw new Error(r ? "Component " + i + "." + (r || "") + " is used but not imported." : i + ".type should be specified.");
    return o;
  }, e.getClassesByMainType = function(i) {
    var r = Gn(i), a = [], o = t[r.main];
    return o && o[gr] ? P(o, function(s, l) {
      l !== gr && a.push(s);
    }) : a.push(o), a;
  }, e.hasClass = function(i) {
    var r = Gn(i);
    return !!t[r.main];
  }, e.getAllClassMainTypes = function() {
    var i = [];
    return P(t, function(r, a) {
      i.push(a);
    }), i;
  }, e.hasSubTypes = function(i) {
    var r = Gn(i), a = t[r.main];
    return a && a[gr];
  };
  function n(i) {
    var r = t[i.main];
    return (!r || !r[gr]) && (r = t[i.main] = {}, r[gr] = !0), r;
  }
}
function Ls(e, t) {
  for (var n = 0; n < e.length; n++)
    e[n][1] || (e[n][1] = e[n][0]);
  return t = t || !1, function(i, r, a) {
    for (var o = {}, s = 0; s < e.length; s++) {
      var l = e[s][1];
      if (!(r && zt(r, l) >= 0 || a && zt(a, l) < 0)) {
        var u = i.getShallow(l, t);
        u != null && (o[e[s][0]] = u);
      }
    }
    return o;
  };
}
var dL = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], fL = Ls(dL), vL = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, n) {
      return fL(this, t, n);
    }, e;
  })()
), cf = new io(50);
function pL(e) {
  if (typeof e == "string") {
    var t = cf.get(e);
    return t && t.image;
  } else
    return e;
}
function P1(e, t, n, i, r) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !n)
        return t;
      var a = cf.get(e), o = { hostEl: n, cb: i, cbPayload: r };
      return a ? (t = a.image, !Cc(t) && a.pending.push(o)) : (t = Mi.loadImage(e, K_, K_), t.__zrImageSrc = e, cf.put(e, t.__cachedImgObj = {
        image: t,
        pending: [o]
      })), t;
    } else
      return e;
  else return t;
}
function K_() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var n = e.pending[t], i = n.cb;
    i && i(this, n.cbPayload), n.hostEl.dirty();
  }
  e.pending.length = 0;
}
function Cc(e) {
  return e && e.width && e.height;
}
var Rh = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function gL(e, t, n, i, r, a) {
  if (!n) {
    e.text = "", e.isTruncated = !1;
    return;
  }
  var o = (t + "").split(`
`);
  a = A1(n, i, r, a);
  for (var s = !1, l = {}, u = 0, c = o.length; u < c; u++)
    E1(l, o[u], a), o[u] = l.textLine, s = s || l.isTruncated;
  e.text = o.join(`
`), e.isTruncated = s;
}
function A1(e, t, n, i) {
  i = i || {};
  var r = $({}, i);
  n = J(n, "..."), r.maxIterations = J(i.maxIterations, 2);
  var a = r.minChar = J(i.minChar, 0), o = r.fontMeasureInfo = Zn(t), s = o.asciiCharWidth;
  r.placeholder = J(i.placeholder, "");
  for (var l = e = Math.max(0, e - 1), u = 0; u < a && l >= s; u++)
    l -= s;
  var c = Kn(o, n);
  return c > l && (n = "", c = 0), l = e - c, r.ellipsis = n, r.ellipsisWidth = c, r.contentWidth = l, r.containerWidth = e, r;
}
function E1(e, t, n) {
  var i = n.containerWidth, r = n.contentWidth, a = n.fontMeasureInfo;
  if (!i) {
    e.textLine = "", e.isTruncated = !1;
    return;
  }
  var o = Kn(a, t);
  if (o <= i) {
    e.textLine = t, e.isTruncated = !1;
    return;
  }
  for (var s = 0; ; s++) {
    if (o <= r || s >= n.maxIterations) {
      t += n.ellipsis;
      break;
    }
    var l = s === 0 ? _L(t, r, a) : o > 0 ? Math.floor(t.length * r / o) : 0;
    t = t.substr(0, l), o = Kn(a, t);
  }
  t === "" && (t = n.placeholder), e.textLine = t, e.isTruncated = !0;
}
function _L(e, t, n) {
  for (var i = 0, r = 0, a = e.length; r < a && i < t; r++)
    i += v1(n, e.charCodeAt(r));
  return r;
}
function mL(e, t, n, i) {
  var r = Pv(e), a = t.overflow, o = t.padding, s = o ? o[1] + o[3] : 0, l = o ? o[0] + o[2] : 0, u = t.font, c = a === "truncate", h = Mc(u), d = J(t.lineHeight, h), f = t.lineOverflow === "truncate", v = !1, g = t.width;
  g == null && n != null && (g = n - s);
  var p = t.height;
  p == null && i != null && (p = i - l);
  var _;
  g != null && (a === "break" || a === "breakAll") ? _ = r ? L1(r, t.font, g, a === "breakAll", 0).lines : [] : _ = r ? r.split(`
`) : [];
  var m = _.length * d;
  if (p == null && (p = m), m > p && f) {
    var y = Math.floor(p / d);
    v = v || _.length > y, _ = _.slice(0, y), m = _.length * d;
  }
  if (r && c && g != null)
    for (var b = A1(g, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), x = {}, w = 0; w < _.length; w++)
      E1(x, _[w], b), _[w] = x.textLine, v = v || x.isTruncated;
  for (var M = p, D = 0, T = Zn(u), w = 0; w < _.length; w++)
    D = Math.max(Kn(T, _[w]), D);
  g == null && (g = D);
  var C = g;
  return M += l, C += s, {
    lines: _,
    height: p,
    outerWidth: C,
    outerHeight: M,
    lineHeight: d,
    calculatedLineHeight: h,
    contentWidth: D,
    contentHeight: m,
    width: g,
    isTruncated: v
  };
}
var yL = /* @__PURE__ */ (function() {
  function e() {
  }
  return e;
})(), Q_ = /* @__PURE__ */ (function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
})(), bL = /* @__PURE__ */ (function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return e;
})();
function xL(e, t, n, i, r) {
  var a = new bL(), o = Pv(e);
  if (!o)
    return a;
  var s = t.padding, l = s ? s[1] + s[3] : 0, u = s ? s[0] + s[2] : 0, c = t.width;
  c == null && n != null && (c = n - l);
  var h = t.height;
  h == null && i != null && (h = i - u);
  for (var d = t.overflow, f = (d === "break" || d === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: d === "breakAll" } : null, v = Rh.lastIndex = 0, g; (g = Rh.exec(o)) != null; ) {
    var p = g.index;
    p > v && Nh(a, o.substring(v, p), t, f), Nh(a, g[2], t, f, g[1]), v = Rh.lastIndex;
  }
  v < o.length && Nh(a, o.substring(v, o.length), t, f);
  var _ = [], m = 0, y = 0, b = d === "truncate", x = t.lineOverflow === "truncate", w = {};
  function M(Rt, Oe, Ue) {
    Rt.width = Oe, Rt.lineHeight = Ue, m += Ue, y = Math.max(y, Oe);
  }
  t: for (var D = 0; D < a.lines.length; D++) {
    for (var T = a.lines[D], C = 0, k = 0, E = 0; E < T.tokens.length; E++) {
      var A = T.tokens[E], L = A.styleName && t.rich[A.styleName] || {}, R = A.textPadding = L.padding, N = R ? R[1] + R[3] : 0, V = A.font = L.font || t.font;
      A.contentHeight = Mc(V);
      var q = J(L.height, A.contentHeight);
      if (A.innerHeight = q, R && (q += R[0] + R[2]), A.height = q, A.lineHeight = Zr(L.lineHeight, t.lineHeight, q), A.align = L && L.align || r, A.verticalAlign = L && L.verticalAlign || "middle", x && h != null && m + A.lineHeight > h) {
        var W = a.lines.length;
        E > 0 ? (T.tokens = T.tokens.slice(0, E), M(T, k, C), a.lines = a.lines.slice(0, D + 1)) : a.lines = a.lines.slice(0, D), a.isTruncated = a.isTruncated || a.lines.length < W;
        break t;
      }
      var Z = L.width, bt = Z == null || Z === "auto";
      if (typeof Z == "string" && Z.charAt(Z.length - 1) === "%")
        A.percentWidth = Z, _.push(A), A.contentWidth = Kn(Zn(V), A.text);
      else {
        if (bt) {
          var et = L.backgroundColor, at = et && et.image;
          at && (at = pL(at), Cc(at) && (A.width = Math.max(A.width, at.width * q / at.height)));
        }
        var ht = b && c != null ? c - k : null;
        ht != null && ht < A.width ? !bt || ht < N ? (A.text = "", A.width = A.contentWidth = 0) : (gL(w, A.text, ht - N, V, t.ellipsis, { minChar: t.truncateMinChar }), A.text = w.text, a.isTruncated = a.isTruncated || w.isTruncated, A.width = A.contentWidth = Kn(Zn(V), A.text)) : A.contentWidth = Kn(Zn(V), A.text);
      }
      A.width += N, k += A.width, L && (C = Math.max(C, A.lineHeight));
    }
    M(T, k, C);
  }
  a.outerWidth = a.width = J(c, y), a.outerHeight = a.height = J(h, m), a.contentHeight = m, a.contentWidth = y, a.outerWidth += l, a.outerHeight += u;
  for (var D = 0; D < _.length; D++) {
    var A = _[D], Ht = A.percentWidth;
    A.width = parseInt(Ht, 10) / 100 * a.width;
  }
  return a;
}
function Nh(e, t, n, i, r) {
  var a = t === "", o = r && n.rich[r] || {}, s = e.lines, l = o.font || n.font, u = !1, c, h;
  if (i) {
    var d = o.padding, f = d ? d[1] + d[3] : 0;
    if (o.width != null && o.width !== "auto") {
      var v = Ps(o.width, i.width) + f;
      s.length > 0 && v + i.accumWidth > i.width && (c = t.split(`
`), u = !0), i.accumWidth = v;
    } else {
      var g = L1(t, l, i.width, i.breakAll, i.accumWidth);
      i.accumWidth = g.accumWidth + f, h = g.linesWidths, c = g.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var p = Zn(l), _ = 0; _ < c.length; _++) {
    var m = c[_], y = new yL();
    if (y.styleName = r, y.text = m, y.isLineHolder = !m && !a, typeof o.width == "number" ? y.width = o.width : y.width = h ? h[_] : Kn(p, m), !_ && !u) {
      var b = (s[s.length - 1] || (s[0] = new Q_())).tokens, x = b.length;
      x === 1 && b[0].isLineHolder ? b[0] = y : (m || !x || a) && b.push(y);
    } else
      s.push(new Q_([y]));
  }
}
function wL(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var SL = ho(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function ML(e) {
  return wL(e) ? !!SL[e] : !0;
}
function L1(e, t, n, i, r) {
  for (var a = [], o = [], s = "", l = "", u = 0, c = 0, h = Zn(t), d = 0; d < e.length; d++) {
    var f = e.charAt(d);
    if (f === `
`) {
      l && (s += l, c += u), a.push(s), o.push(c), s = "", l = "", u = 0, c = 0;
      continue;
    }
    var v = v1(h, f.charCodeAt(0)), g = i ? !1 : !ML(f);
    if (a.length ? c + v > n : r + c + v > n) {
      c ? (s || l) && (g ? (s || (s = l, l = "", u = 0, c = u), a.push(s), o.push(c - u), l += f, u += v, s = "", c = u) : (l && (s += l, l = "", u = 0), a.push(s), o.push(c), s = f, c = v)) : g ? (a.push(l), o.push(u), l = f, u = v) : (a.push(f), o.push(v));
      continue;
    }
    c += v, g ? (l += f, u += v) : (l && (s += l, l = "", u = 0), s += f);
  }
  return l && (s += l), s && (a.push(s), o.push(c)), a.length === 1 && (c += r), {
    accumWidth: c,
    lines: a,
    linesWidths: o
  };
}
function J_(e, t, n, i, r, a) {
  if (e.baseX = n, e.baseY = i, e.outerWidth = e.outerHeight = null, !!t) {
    var o = t.width * 2, s = t.height * 2;
    it.set(tm, ro(n, o, r), Jr(i, s, a), o, s), it.intersect(t, tm, null, em);
    var l = em.outIntersectRect;
    e.outerWidth = l.width, e.outerHeight = l.height, e.baseX = ro(l.x, l.width, r, !0), e.baseY = Jr(l.y, l.height, a, !0);
  }
}
var tm = new it(0, 0, 0, 0), em = { outIntersectRect: {}, clamp: !0 };
function Pv(e) {
  return e != null ? e += "" : e = "";
}
function DL(e) {
  var t = Pv(e.text), n = e.font, i = Kn(Zn(n), t), r = Mc(n);
  return hf(e, i, r, null);
}
function hf(e, t, n, i) {
  var r = new it(ro(e.x || 0, t, e.textAlign), Jr(e.y || 0, n, e.textBaseline), t, n), a = i ?? (O1(e) ? e.lineWidth : 0);
  return a > 0 && (r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a), r;
}
function O1(e) {
  var t = e.stroke;
  return t != null && t !== "none" && e.lineWidth > 0;
}
var df = "__zr_style_" + Math.round(Math.random() * 10), ta = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, Pc = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
ta[df] = !0;
var nm = ["z", "z2", "invisible"], TL = ["invisible"], Zs = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype._init = function(n) {
    for (var i = jt(n), r = 0; r < i.length; r++) {
      var a = i[r];
      a === "style" ? this.useStyle(n[a]) : e.prototype.attrKV.call(this, a, n[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(n, i, r, a) {
    var o = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && kL(this, n, i) || o && !o[0] && !o[3])
      return !1;
    if (r && this.__clipPaths && this.__clipPaths.length) {
      for (var s = 0; s < this.__clipPaths.length; ++s)
        if (this.__clipPaths[s].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(n, i) {
    return this.rectContain(n, i);
  }, t.prototype.traverse = function(n, i) {
    n.call(i, this);
  }, t.prototype.rectContain = function(n, i) {
    var r = this.transformCoordToLocal(n, i), a = this.getBoundingRect();
    return a.contain(r[0], r[1]);
  }, t.prototype.getPaintRect = function() {
    var n = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var i = this.transform, r = this.getBoundingRect(), a = this.style, o = a.shadowBlur || 0, s = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      n = this._paintRect || (this._paintRect = new it(0, 0, 0, 0)), i ? it.applyTransform(n, r, i) : n.copy(r), (o || s || l) && (n.width += o * 2 + Math.abs(s), n.height += o * 2 + Math.abs(l), n.x = Math.min(n.x, n.x + s - o), n.y = Math.min(n.y, n.y + l - o));
      var u = this.dirtyRectTolerance;
      n.isZero() || (n.x = Math.floor(n.x - u), n.y = Math.floor(n.y - u), n.width = Math.ceil(n.width + 1 + u * 2), n.height = Math.ceil(n.height + 1 + u * 2));
    }
    return n;
  }, t.prototype.setPrevPaintRect = function(n) {
    n ? (this._prevPaintRect = this._prevPaintRect || new it(0, 0, 0, 0), this._prevPaintRect.copy(n)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(n) {
    return this.animate("style", n);
  }, t.prototype.updateDuringAnimation = function(n) {
    n === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(n, i) {
    n !== "style" ? e.prototype.attrKV.call(this, n, i) : this.style ? this.setStyle(i) : this.useStyle(i);
  }, t.prototype.setStyle = function(n, i) {
    return typeof n == "string" ? this.style[n] = i : $(this.style, n), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(n) {
    n || this.markRedraw(), this.__dirty |= Qo, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & Qo);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~Qo;
  }, t.prototype.createStyle = function(n) {
    return Sc(ta, n);
  }, t.prototype.useStyle = function(n) {
    n[df] || (n = this.createStyle(n)), this.__inHover ? this.__hoverStyle = n : this.style = n, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(n) {
    return n[df];
  }, t.prototype._innerSaveToNormal = function(n) {
    e.prototype._innerSaveToNormal.call(this, n);
    var i = this._normalState;
    n.style && !i.style && (i.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(n, i, nm);
  }, t.prototype._applyStateObj = function(n, i, r, a, o, s) {
    e.prototype._applyStateObj.call(this, n, i, r, a, o, s);
    var l = !(i && a), u;
    if (i && i.style ? o ? a ? u = i.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, i.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, i.style)) : l && (u = r.style), u)
      if (o) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = jt(c), d = 0; d < h.length; d++) {
            var f = h[d];
            f in u && (u[f] = u[f], this.style[f] = c[f]);
          }
        for (var v = jt(u), d = 0; d < v.length; d++) {
          var f = v[d];
          this.style[f] = this.style[f];
        }
        this._transitionState(n, {
          style: u
        }, s, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var g = this.__inHover ? TL : nm, d = 0; d < g.length; d++) {
      var f = g[d];
      i && i[f] != null ? this[f] = i[f] : l && r[f] != null && (this[f] = r[f]);
    }
  }, t.prototype._mergeStates = function(n) {
    for (var i = e.prototype._mergeStates.call(this, n), r, a = 0; a < n.length; a++) {
      var o = n[a];
      o.style && (r = r || {}, this._mergeStyle(r, o.style));
    }
    return r && (i.style = r), i;
  }, t.prototype._mergeStyle = function(n, i) {
    return $(n, i), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return Pc;
  }, t.initDefaultProps = (function() {
    var n = t.prototype;
    n.type = "displayable", n.invisible = !1, n.z = 0, n.z2 = 0, n.zlevel = 0, n.culling = !1, n.cursor = "pointer", n.rectHover = !1, n.incremental = !1, n._rect = null, n.dirtyRectTolerance = 0, n.__dirty = Ze | Qo;
  })(), t;
})(Dc), Fh = new it(0, 0, 0, 0), Bh = new it(0, 0, 0, 0);
function kL(e, t, n) {
  return Fh.copy(e.getBoundingRect()), e.transform && Fh.applyTransform(e.transform), Bh.width = t, Bh.height = n, !Fh.intersect(Bh);
}
var cn = Math.min, hn = Math.max, zh = Math.sin, Vh = Math.cos, _r = Math.PI * 2, Ml = fo(), Dl = fo(), Tl = fo();
function im(e, t, n, i, r, a) {
  r[0] = cn(e, n), r[1] = cn(t, i), a[0] = hn(e, n), a[1] = hn(t, i);
}
var rm = [], am = [];
function CL(e, t, n, i, r, a, o, s, l, u) {
  var c = o1, h = Ce, d = c(e, n, r, o, rm);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var f = 0; f < d; f++) {
    var v = h(e, n, r, o, rm[f]);
    l[0] = cn(v, l[0]), u[0] = hn(v, u[0]);
  }
  d = c(t, i, a, s, am);
  for (var f = 0; f < d; f++) {
    var g = h(t, i, a, s, am[f]);
    l[1] = cn(g, l[1]), u[1] = hn(g, u[1]);
  }
  l[0] = cn(e, l[0]), u[0] = hn(e, u[0]), l[0] = cn(o, l[0]), u[0] = hn(o, u[0]), l[1] = cn(t, l[1]), u[1] = hn(t, u[1]), l[1] = cn(s, l[1]), u[1] = hn(s, u[1]);
}
function PL(e, t, n, i, r, a, o, s) {
  var l = s1, u = ze, c = hn(cn(l(e, n, r), 1), 0), h = hn(cn(l(t, i, a), 1), 0), d = u(e, n, r, c), f = u(t, i, a, h);
  o[0] = cn(e, r, d), o[1] = cn(t, a, f), s[0] = hn(e, r, d), s[1] = hn(t, a, f);
}
function AL(e, t, n, i, r, a, o, s, l) {
  var u = Ba, c = za, h = Math.abs(r - a);
  if (h % _r < 1e-4 && h > 1e-4) {
    s[0] = e - n, s[1] = t - i, l[0] = e + n, l[1] = t + i;
    return;
  }
  if (Ml[0] = Vh(r) * n + e, Ml[1] = zh(r) * i + t, Dl[0] = Vh(a) * n + e, Dl[1] = zh(a) * i + t, u(s, Ml, Dl), c(l, Ml, Dl), r = r % _r, r < 0 && (r = r + _r), a = a % _r, a < 0 && (a = a + _r), r > a && !o ? a += _r : r < a && o && (r += _r), o) {
    var d = a;
    a = r, r = d;
  }
  for (var f = 0; f < a; f += Math.PI / 2)
    f > r && (Tl[0] = Vh(f) * n + e, Tl[1] = zh(f) * i + t, u(s, Tl, s), c(l, Tl, l));
}
var Mt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, mr = [], yr = [], Nn = [], Li = [], Fn = [], Bn = [], $h = Math.min, Hh = Math.max, br = Math.cos, xr = Math.sin, ri = Math.abs, ff = Math.PI, Fi = ff * 2, Yh = typeof Float32Array < "u", ko = [];
function Wh(e) {
  var t = Math.round(e / ff * 1e8) / 1e8;
  return t % 2 * ff;
}
function EL(e, t) {
  var n = Wh(e[0]);
  n < 0 && (n += Fi);
  var i = n - e[0], r = e[1];
  r += i, !t && r - n >= Fi ? r = n + Fi : t && n - r >= Fi ? r = n - Fi : !t && n > r ? r = n + (Fi - Wh(n - r)) : t && n < r && (r = n - (Fi - Wh(r - n))), e[0] = n, e[1] = r;
}
var oo = (function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, n, i) {
    i = i || 0, i > 0 && (this._ux = ri(i / Ou / t) || 0, this._uy = ri(i / Ou / n) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, n) {
    return this._drawPendingPt(), this.addData(Mt.M, t, n), this._ctx && this._ctx.moveTo(t, n), this._x0 = t, this._y0 = n, this._xi = t, this._yi = n, this;
  }, e.prototype.lineTo = function(t, n) {
    var i = ri(t - this._xi), r = ri(n - this._yi), a = i > this._ux || r > this._uy;
    if (this.addData(Mt.L, t, n), this._ctx && a && this._ctx.lineTo(t, n), a)
      this._xi = t, this._yi = n, this._pendingPtDist = 0;
    else {
      var o = i * i + r * r;
      o > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = n, this._pendingPtDist = o);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, n, i, r, a, o) {
    return this._drawPendingPt(), this.addData(Mt.C, t, n, i, r, a, o), this._ctx && this._ctx.bezierCurveTo(t, n, i, r, a, o), this._xi = a, this._yi = o, this;
  }, e.prototype.quadraticCurveTo = function(t, n, i, r) {
    return this._drawPendingPt(), this.addData(Mt.Q, t, n, i, r), this._ctx && this._ctx.quadraticCurveTo(t, n, i, r), this._xi = i, this._yi = r, this;
  }, e.prototype.arc = function(t, n, i, r, a, o) {
    this._drawPendingPt(), ko[0] = r, ko[1] = a, EL(ko, o), r = ko[0], a = ko[1];
    var s = a - r;
    return this.addData(Mt.A, t, n, i, i, r, s, 0, o ? 0 : 1), this._ctx && this._ctx.arc(t, n, i, r, a, o), this._xi = br(a) * i + t, this._yi = xr(a) * i + n, this;
  }, e.prototype.arcTo = function(t, n, i, r, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, n, i, r, a), this;
  }, e.prototype.rect = function(t, n, i, r) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, n, i, r), this.addData(Mt.R, t, n, i, r), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Mt.Z);
    var t = this._ctx, n = this._x0, i = this._y0;
    return t && t.closePath(), this._xi = n, this._yi = i, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    if (this._saveData) {
      var n = t.length;
      !(this.data && this.data.length === n) && Yh && (this.data = new Float32Array(n));
      for (var i = 0; i < n; i++)
        this.data[i] = t[i];
      this._len = n;
    }
  }, e.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var n = t.length, i = 0, r = this._len, a = 0; a < n; a++)
        i += t[a].len();
      var o = this.data;
      if (Yh && (o instanceof Float32Array || !o) && (this.data = new Float32Array(r + i), r > 0 && o))
        for (var s = 0; s < r; s++)
          this.data[s] = o[s];
      for (var a = 0; a < n; a++)
        for (var l = t[a].data, s = 0; s < l.length; s++)
          this.data[r++] = l[s];
      this._len = r;
    }
  }, e.prototype.addData = function(t, n, i, r, a, o, s, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], n = 0; n < this._len; n++)
        t[n] = this.data[n];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, Yh && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    Nn[0] = Nn[1] = Fn[0] = Fn[1] = Number.MAX_VALUE, Li[0] = Li[1] = Bn[0] = Bn[1] = -Number.MAX_VALUE;
    var t = this.data, n = 0, i = 0, r = 0, a = 0, o;
    for (o = 0; o < this._len; ) {
      var s = t[o++], l = o === 1;
      switch (l && (n = t[o], i = t[o + 1], r = n, a = i), s) {
        case Mt.M:
          n = r = t[o++], i = a = t[o++], Fn[0] = r, Fn[1] = a, Bn[0] = r, Bn[1] = a;
          break;
        case Mt.L:
          im(n, i, t[o], t[o + 1], Fn, Bn), n = t[o++], i = t[o++];
          break;
        case Mt.C:
          CL(n, i, t[o++], t[o++], t[o++], t[o++], t[o], t[o + 1], Fn, Bn), n = t[o++], i = t[o++];
          break;
        case Mt.Q:
          PL(n, i, t[o++], t[o++], t[o], t[o + 1], Fn, Bn), n = t[o++], i = t[o++];
          break;
        case Mt.A:
          var u = t[o++], c = t[o++], h = t[o++], d = t[o++], f = t[o++], v = t[o++] + f;
          o += 1;
          var g = !t[o++];
          l && (r = br(f) * h + u, a = xr(f) * d + c), AL(u, c, h, d, f, v, g, Fn, Bn), n = br(v) * h + u, i = xr(v) * d + c;
          break;
        case Mt.R:
          r = n = t[o++], a = i = t[o++];
          var p = t[o++], _ = t[o++];
          im(r, a, r + p, a + _, Fn, Bn);
          break;
        case Mt.Z:
          n = r, i = a;
          break;
      }
      Ba(Nn, Nn, Fn), za(Li, Li, Bn);
    }
    return o === 0 && (Nn[0] = Nn[1] = Li[0] = Li[1] = 0), new it(Nn[0], Nn[1], Li[0] - Nn[0], Li[1] - Nn[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, n = this._len, i = this._ux, r = this._uy, a = 0, o = 0, s = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, d = 0; d < n; ) {
      var f = t[d++], v = d === 1;
      v && (a = t[d], o = t[d + 1], s = a, l = o);
      var g = -1;
      switch (f) {
        case Mt.M:
          a = s = t[d++], o = l = t[d++];
          break;
        case Mt.L: {
          var p = t[d++], _ = t[d++], m = p - a, y = _ - o;
          (ri(m) > i || ri(y) > r || d === n - 1) && (g = Math.sqrt(m * m + y * y), a = p, o = _);
          break;
        }
        case Mt.C: {
          var b = t[d++], x = t[d++], p = t[d++], _ = t[d++], w = t[d++], M = t[d++];
          g = qA(a, o, b, x, p, _, w, M, 10), a = w, o = M;
          break;
        }
        case Mt.Q: {
          var b = t[d++], x = t[d++], p = t[d++], _ = t[d++];
          g = QA(a, o, b, x, p, _, 10), a = p, o = _;
          break;
        }
        case Mt.A:
          var D = t[d++], T = t[d++], C = t[d++], k = t[d++], E = t[d++], A = t[d++], L = A + E;
          d += 1, v && (s = br(E) * C + D, l = xr(E) * k + T), g = Hh(C, k) * $h(Fi, Math.abs(A)), a = br(L) * C + D, o = xr(L) * k + T;
          break;
        case Mt.R: {
          s = a = t[d++], l = o = t[d++];
          var R = t[d++], N = t[d++];
          g = R * 2 + N * 2;
          break;
        }
        case Mt.Z: {
          var m = s - a, y = l - o;
          g = Math.sqrt(m * m + y * y), a = s, o = l;
          break;
        }
      }
      g >= 0 && (u[h++] = g, c += g);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, n) {
    var i = this.data, r = this._ux, a = this._uy, o = this._len, s, l, u, c, h, d, f = n < 1, v, g, p = 0, _ = 0, m, y = 0, b, x;
    if (!(f && (this._pathSegLen || this._calculateLength(), v = this._pathSegLen, g = this._pathLen, m = n * g, !m)))
      t: for (var w = 0; w < o; ) {
        var M = i[w++], D = w === 1;
        switch (D && (u = i[w], c = i[w + 1], s = u, l = c), M !== Mt.L && y > 0 && (t.lineTo(b, x), y = 0), M) {
          case Mt.M:
            s = u = i[w++], l = c = i[w++], t.moveTo(u, c);
            break;
          case Mt.L: {
            h = i[w++], d = i[w++];
            var T = ri(h - u), C = ri(d - c);
            if (T > r || C > a) {
              if (f) {
                var k = v[_++];
                if (p + k > m) {
                  var E = (m - p) / k;
                  t.lineTo(u * (1 - E) + h * E, c * (1 - E) + d * E);
                  break t;
                }
                p += k;
              }
              t.lineTo(h, d), u = h, c = d, y = 0;
            } else {
              var A = T * T + C * C;
              A > y && (b = h, x = d, y = A);
            }
            break;
          }
          case Mt.C: {
            var L = i[w++], R = i[w++], N = i[w++], V = i[w++], q = i[w++], W = i[w++];
            if (f) {
              var k = v[_++];
              if (p + k > m) {
                var E = (m - p) / k;
                Pu(u, L, N, q, E, mr), Pu(c, R, V, W, E, yr), t.bezierCurveTo(mr[1], yr[1], mr[2], yr[2], mr[3], yr[3]);
                break t;
              }
              p += k;
            }
            t.bezierCurveTo(L, R, N, V, q, W), u = q, c = W;
            break;
          }
          case Mt.Q: {
            var L = i[w++], R = i[w++], N = i[w++], V = i[w++];
            if (f) {
              var k = v[_++];
              if (p + k > m) {
                var E = (m - p) / k;
                Au(u, L, N, E, mr), Au(c, R, V, E, yr), t.quadraticCurveTo(mr[1], yr[1], mr[2], yr[2]);
                break t;
              }
              p += k;
            }
            t.quadraticCurveTo(L, R, N, V), u = N, c = V;
            break;
          }
          case Mt.A:
            var Z = i[w++], bt = i[w++], et = i[w++], at = i[w++], ht = i[w++], Ht = i[w++], Rt = i[w++], Oe = !i[w++], Ue = et > at ? et : at, De = ri(et - at) > 1e-3, oe = ht + Ht, nt = !1;
            if (f) {
              var k = v[_++];
              p + k > m && (oe = ht + Ht * (m - p) / k, nt = !0), p += k;
            }
            if (De && t.ellipse ? t.ellipse(Z, bt, et, at, Rt, ht, oe, Oe) : t.arc(Z, bt, Ue, ht, oe, Oe), nt)
              break t;
            D && (s = br(ht) * et + Z, l = xr(ht) * at + bt), u = br(oe) * et + Z, c = xr(oe) * at + bt;
            break;
          case Mt.R:
            s = u = i[w], l = c = i[w + 1], h = i[w++], d = i[w++];
            var _t = i[w++], or = i[w++];
            if (f) {
              var k = v[_++];
              if (p + k > m) {
                var Te = m - p;
                t.moveTo(h, d), t.lineTo(h + $h(Te, _t), d), Te -= _t, Te > 0 && t.lineTo(h + _t, d + $h(Te, or)), Te -= or, Te > 0 && t.lineTo(h + Hh(_t - Te, 0), d + or), Te -= _t, Te > 0 && t.lineTo(h, d + Hh(or - Te, 0));
                break t;
              }
              p += k;
            }
            t.rect(h, d, _t, or);
            break;
          case Mt.Z:
            if (f) {
              var k = v[_++];
              if (p + k > m) {
                var E = (m - p) / k;
                t.lineTo(u * (1 - E) + s * E, c * (1 - E) + l * E);
                break t;
              }
              p += k;
            }
            t.closePath(), u = s, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), n = this.data;
    return t.data = n.slice ? n.slice() : Array.prototype.slice.call(n), t._len = this._len, t;
  }, e.prototype.canSave = function() {
    return !!this._saveData;
  }, e.CMD = Mt, e.initDefaultProps = (function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  })(), e;
})();
function xa(e, t, n, i, r, a, o) {
  if (r === 0)
    return !1;
  var s = r, l = 0, u = e;
  if (o > t + s && o > i + s || o < t - s && o < i - s || a > e + s && a > n + s || a < e - s && a < n - s)
    return !1;
  if (e !== n)
    l = (t - i) / (e - n), u = (e * i - n * t) / (e - n);
  else
    return Math.abs(a - e) <= s / 2;
  var c = l * a - o + u, h = c * c / (l * l + 1);
  return h <= s / 2 * s / 2;
}
function LL(e, t, n, i, r, a, o, s, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > t + h && c > i + h && c > a + h && c > s + h || c < t - h && c < i - h && c < a - h && c < s - h || u > e + h && u > n + h && u > r + h && u > o + h || u < e - h && u < n - h && u < r - h && u < o - h)
    return !1;
  var d = XA(e, t, n, i, r, a, o, s, u, c);
  return d <= h / 2;
}
function OL(e, t, n, i, r, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  if (l > t + u && l > i + u && l > a + u || l < t - u && l < i - u && l < a - u || s > e + u && s > n + u && s > r + u || s < e - u && s < n - u && s < r - u)
    return !1;
  var c = KA(e, t, n, i, r, a, s, l);
  return c <= u / 2;
}
var om = Math.PI * 2;
function kl(e) {
  return e %= om, e < 0 && (e += om), e;
}
var Co = Math.PI * 2;
function IL(e, t, n, i, r, a, o, s, l) {
  if (o === 0)
    return !1;
  var u = o;
  s -= e, l -= t;
  var c = Math.sqrt(s * s + l * l);
  if (c - u > n || c + u < n)
    return !1;
  if (Math.abs(i - r) % Co < 1e-4)
    return !0;
  if (a) {
    var h = i;
    i = kl(r), r = kl(h);
  } else
    i = kl(i), r = kl(r);
  i > r && (r += Co);
  var d = Math.atan2(l, s);
  return d < 0 && (d += Co), d >= i && d <= r || d + Co >= i && d + Co <= r;
}
function wr(e, t, n, i, r, a) {
  if (a > t && a > i || a < t && a < i || i === t)
    return 0;
  var o = (a - t) / (i - t), s = i < t ? 1 : -1;
  (o === 1 || o === 0) && (s = i < t ? 0.5 : -0.5);
  var l = o * (n - e) + e;
  return l === r ? 1 / 0 : l > r ? s : 0;
}
var Oi = oo.CMD, Sr = Math.PI * 2, RL = 1e-4;
function NL(e, t) {
  return Math.abs(e - t) < RL;
}
var ke = [-1, -1, -1], sn = [-1, -1];
function FL() {
  var e = sn[0];
  sn[0] = sn[1], sn[1] = e;
}
function BL(e, t, n, i, r, a, o, s, l, u) {
  if (u > t && u > i && u > a && u > s || u < t && u < i && u < a && u < s)
    return 0;
  var c = a1(t, i, a, s, u, ke);
  if (c === 0)
    return 0;
  for (var h = 0, d = -1, f = void 0, v = void 0, g = 0; g < c; g++) {
    var p = ke[g], _ = p === 0 || p === 1 ? 0.5 : 1, m = Ce(e, n, r, o, p);
    m < l || (d < 0 && (d = o1(t, i, a, s, sn), sn[1] < sn[0] && d > 1 && FL(), f = Ce(t, i, a, s, sn[0]), d > 1 && (v = Ce(t, i, a, s, sn[1]))), d === 2 ? p < sn[0] ? h += f < t ? _ : -_ : p < sn[1] ? h += v < f ? _ : -_ : h += s < v ? _ : -_ : p < sn[0] ? h += f < t ? _ : -_ : h += s < f ? _ : -_);
  }
  return h;
}
function zL(e, t, n, i, r, a, o, s) {
  if (s > t && s > i && s > a || s < t && s < i && s < a)
    return 0;
  var l = ZA(t, i, a, s, ke);
  if (l === 0)
    return 0;
  var u = s1(t, i, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = ze(t, i, a, u), d = 0; d < l; d++) {
      var f = ke[d] === 0 || ke[d] === 1 ? 0.5 : 1, v = ze(e, n, r, ke[d]);
      v < o || (ke[d] < u ? c += h < t ? f : -f : c += a < h ? f : -f);
    }
    return c;
  } else {
    var f = ke[0] === 0 || ke[0] === 1 ? 0.5 : 1, v = ze(e, n, r, ke[0]);
    return v < o ? 0 : a < t ? f : -f;
  }
}
function VL(e, t, n, i, r, a, o, s) {
  if (s -= t, s > n || s < -n)
    return 0;
  var l = Math.sqrt(n * n - s * s);
  ke[0] = -l, ke[1] = l;
  var u = Math.abs(i - r);
  if (u < 1e-4)
    return 0;
  if (u >= Sr - 1e-4) {
    i = 0, r = Sr;
    var c = a ? 1 : -1;
    return o >= ke[0] + e && o <= ke[1] + e ? c : 0;
  }
  if (i > r) {
    var h = i;
    i = r, r = h;
  }
  i < 0 && (i += Sr, r += Sr);
  for (var d = 0, f = 0; f < 2; f++) {
    var v = ke[f];
    if (v + e > o) {
      var g = Math.atan2(s, v), c = a ? 1 : -1;
      g < 0 && (g = Sr + g), (g >= i && g <= r || g + Sr >= i && g + Sr <= r) && (g > Math.PI / 2 && g < Math.PI * 1.5 && (c = -c), d += c);
    }
  }
  return d;
}
function I1(e, t, n, i, r) {
  for (var a = e.data, o = e.len(), s = 0, l = 0, u = 0, c = 0, h = 0, d, f, v = 0; v < o; ) {
    var g = a[v++], p = v === 1;
    switch (g === Oi.M && v > 1 && (n || (s += wr(l, u, c, h, i, r))), p && (l = a[v], u = a[v + 1], c = l, h = u), g) {
      case Oi.M:
        c = a[v++], h = a[v++], l = c, u = h;
        break;
      case Oi.L:
        if (n) {
          if (xa(l, u, a[v], a[v + 1], t, i, r))
            return !0;
        } else
          s += wr(l, u, a[v], a[v + 1], i, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Oi.C:
        if (n) {
          if (LL(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], t, i, r))
            return !0;
        } else
          s += BL(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], i, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Oi.Q:
        if (n) {
          if (OL(l, u, a[v++], a[v++], a[v], a[v + 1], t, i, r))
            return !0;
        } else
          s += zL(l, u, a[v++], a[v++], a[v], a[v + 1], i, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Oi.A:
        var _ = a[v++], m = a[v++], y = a[v++], b = a[v++], x = a[v++], w = a[v++];
        v += 1;
        var M = !!(1 - a[v++]);
        d = Math.cos(x) * y + _, f = Math.sin(x) * b + m, p ? (c = d, h = f) : s += wr(l, u, d, f, i, r);
        var D = (i - _) * b / y + _;
        if (n) {
          if (IL(_, m, b, x, x + w, M, t, D, r))
            return !0;
        } else
          s += VL(_, m, b, x, x + w, M, D, r);
        l = Math.cos(x + w) * y + _, u = Math.sin(x + w) * b + m;
        break;
      case Oi.R:
        c = l = a[v++], h = u = a[v++];
        var T = a[v++], C = a[v++];
        if (d = c + T, f = h + C, n) {
          if (xa(c, h, d, h, t, i, r) || xa(d, h, d, f, t, i, r) || xa(d, f, c, f, t, i, r) || xa(c, f, c, h, t, i, r))
            return !0;
        } else
          s += wr(d, h, d, f, i, r), s += wr(c, f, c, h, i, r);
        break;
      case Oi.Z:
        if (n) {
          if (xa(l, u, c, h, t, i, r))
            return !0;
        } else
          s += wr(l, u, c, h, i, r);
        l = c, u = h;
        break;
    }
  }
  return !n && !NL(u, h) && (s += wr(l, u, c, h, i, r) || 0), s !== 0;
}
function $L(e, t, n) {
  return I1(e, 0, !1, t, n);
}
function HL(e, t, n, i) {
  return I1(e, t, !0, n, i);
}
var R1 = Qt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, ta), YL = {
  style: Qt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, Pc.style)
}, Uh = Cs.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), It = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.update = function() {
    var n = this;
    e.prototype.update.call(this);
    var i = this.style;
    if (i.decal) {
      var r = this._decalEl = this._decalEl || new t();
      r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
        n.buildPath(l, n.shape);
      }), r.silent = !0;
      var a = r.style;
      for (var o in i)
        a[o] !== i[o] && (a[o] = i[o]);
      a.fill = i.fill ? i.decal : null, a.decal = null, a.shadowColor = null, i.strokeFirst && (a.stroke = null);
      for (var s = 0; s < Uh.length; ++s)
        r[Uh[s]] = this[Uh[s]];
      r.__dirty |= Ze;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(n) {
    var i = jt(n);
    this.shape = this.getDefaultShape();
    var r = this.getDefaultStyle();
    r && this.useStyle(r);
    for (var a = 0; a < i.length; a++) {
      var o = i[a], s = n[o];
      o === "style" ? this.style ? $(this.style, s) : this.useStyle(s) : o === "shape" ? $(this.shape, s) : e.prototype.attrKV.call(this, o, s);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var n = this.style.fill;
    if (n !== "none") {
      if (K(n)) {
        var i = Lu(n, 0);
        return i > 0.5 ? sf : i > 0.2 ? bE : lf;
      } else if (n)
        return lf;
    }
    return sf;
  }, t.prototype.getInsideTextStroke = function(n) {
    var i = this.style.fill;
    if (K(i)) {
      var r = this.__zr, a = !!(r && r.isDarkMode()), o = Lu(n, 0) < of;
      if (a === o)
        return i;
    }
  }, t.prototype.buildPath = function(n, i, r) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~Na;
  }, t.prototype.getUpdatedPathProxy = function(n) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, n), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new oo(!1);
  }, t.prototype.hasStroke = function() {
    var n = this.style, i = n.stroke;
    return !(i == null || i === "none" || !(n.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var n = this.style, i = n.fill;
    return i != null && i !== "none";
  }, t.prototype.getBoundingRect = function() {
    var n = this._rect, i = this.style, r = !n;
    if (r) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var o = this.path;
      (a || this.__dirty & Na) && (o.beginPath(), this.buildPath(o, this.shape, !1), this.pathUpdated()), n = o.getBoundingRect();
    }
    if (this._rect = n, this.hasStroke() && this.path && this.path.len() > 0) {
      var s = this._rectStroke || (this._rectStroke = n.clone());
      if (this.__dirty || r) {
        s.copy(n);
        var l = i.strokeNoScale ? this.getLineScale() : 1, u = i.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (s.width += u / l, s.height += u / l, s.x -= u / l / 2, s.y -= u / l / 2);
      }
      return s;
    }
    return n;
  }, t.prototype.contain = function(n, i) {
    var r = this.transformCoordToLocal(n, i), a = this.getBoundingRect(), o = this.style;
    if (n = r[0], i = r[1], a.contain(n, i)) {
      var s = this.path;
      if (this.hasStroke()) {
        var l = o.lineWidth, u = o.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), HL(s, l / u, n, i)))
          return !0;
      }
      if (this.hasFill())
        return $L(s, n, i);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= Na, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(n) {
    return this.animate("shape", n);
  }, t.prototype.updateDuringAnimation = function(n) {
    n === "style" ? this.dirtyStyle() : n === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(n, i) {
    n === "shape" ? this.setShape(i) : e.prototype.attrKV.call(this, n, i);
  }, t.prototype.setShape = function(n, i) {
    var r = this.shape;
    return r || (r = this.shape = {}), typeof n == "string" ? r[n] = i : $(r, n), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & Na);
  }, t.prototype.createStyle = function(n) {
    return Sc(R1, n);
  }, t.prototype._innerSaveToNormal = function(n) {
    e.prototype._innerSaveToNormal.call(this, n);
    var i = this._normalState;
    n.shape && !i.shape && (i.shape = $({}, this.shape));
  }, t.prototype._applyStateObj = function(n, i, r, a, o, s) {
    e.prototype._applyStateObj.call(this, n, i, r, a, o, s);
    var l = !(i && a), u;
    if (i && i.shape ? o ? a ? u = i.shape : (u = $({}, r.shape), $(u, i.shape)) : (u = $({}, a ? this.shape : r.shape), $(u, i.shape)) : l && (u = r.shape), u)
      if (o) {
        this.shape = $({}, this.shape);
        for (var c = {}, h = jt(u), d = 0; d < h.length; d++) {
          var f = h[d];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(n, {
          shape: c
        }, s);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(n) {
    for (var i = e.prototype._mergeStates.call(this, n), r, a = 0; a < n.length; a++) {
      var o = n[a];
      o.shape && (r = r || {}, this._mergeStyle(r, o.shape));
    }
    return r && (i.shape = r), i;
  }, t.prototype.getAnimationStyleProps = function() {
    return YL;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(n) {
    var i = (function(a) {
      At(o, a);
      function o(s) {
        var l = a.call(this, s) || this;
        return n.init && n.init.call(l, s), l;
      }
      return o.prototype.getDefaultStyle = function() {
        return ft(n.style);
      }, o.prototype.getDefaultShape = function() {
        return ft(n.shape);
      }, o;
    })(t);
    for (var r in n)
      typeof n[r] == "function" && (i.prototype[r] = n[r]);
    return i;
  }, t.initDefaultProps = (function() {
    var n = t.prototype;
    n.type = "path", n.strokeContainThreshold = 5, n.segmentIgnoreThreshold = 0, n.subPixelOptimize = !1, n.autoBatch = !1, n.__dirty = Ze | Qo | Na;
  })(), t;
})(Zs), WL = Qt({
  strokeFirst: !0,
  font: tr,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, R1), Fu = (function(e) {
  At(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return O1(this.style);
  }, t.prototype.hasFill = function() {
    var n = this.style, i = n.fill;
    return i != null && i !== "none";
  }, t.prototype.createStyle = function(n) {
    return Sc(WL, n);
  }, t.prototype.setBoundingRect = function(n) {
    this._rect = n;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = DL(this.style)), this._rect;
  }, t.initDefaultProps = (function() {
    var n = t.prototype;
    n.dirtyRectTolerance = 10;
  })(), t;
})(Zs);
Fu.prototype.type = "tspan";
var UL = Qt({
  x: 0,
  y: 0
}, ta), GL = {
  style: Qt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, Pc.style)
};
function jL(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var ua = (function(e) {
  At(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(n) {
    return Sc(UL, n);
  }, t.prototype._getSize = function(n) {
    var i = this.style, r = i[n];
    if (r != null)
      return r;
    var a = jL(i.image) ? i.image : this.__image;
    if (!a)
      return 0;
    var o = n === "width" ? "height" : "width", s = i[o];
    return s == null ? a[n] : a[n] / a[o] * s;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return GL;
  }, t.prototype.getBoundingRect = function() {
    var n = this.style;
    return this._rect || (this._rect = new it(n.x || 0, n.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
})(Zs);
ua.prototype.type = "image";
function XL(e, t) {
  var n = t.x, i = t.y, r = t.width, a = t.height, o = t.r, s, l, u, c;
  r < 0 && (n = n + r, r = -r), a < 0 && (i = i + a, a = -a), typeof o == "number" ? s = l = u = c = o : o instanceof Array ? o.length === 1 ? s = l = u = c = o[0] : o.length === 2 ? (s = u = o[0], l = c = o[1]) : o.length === 3 ? (s = o[0], l = c = o[1], u = o[2]) : (s = o[0], l = o[1], u = o[2], c = o[3]) : s = l = u = c = 0;
  var h;
  s + l > r && (h = s + l, s *= r / h, l *= r / h), u + c > r && (h = u + c, u *= r / h, c *= r / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), s + c > a && (h = s + c, s *= a / h, c *= a / h), e.moveTo(n + s, i), e.lineTo(n + r - l, i), l !== 0 && e.arc(n + r - l, i + l, l, -Math.PI / 2, 0), e.lineTo(n + r, i + a - u), u !== 0 && e.arc(n + r - u, i + a - u, u, 0, Math.PI / 2), e.lineTo(n + c, i + a), c !== 0 && e.arc(n + c, i + a - c, c, Math.PI / 2, Math.PI), e.lineTo(n, i + s), s !== 0 && e.arc(n + s, i + s, s, Math.PI, Math.PI * 1.5);
}
var Ha = Math.round;
function N1(e, t, n) {
  if (t) {
    var i = t.x1, r = t.x2, a = t.y1, o = t.y2;
    e.x1 = i, e.x2 = r, e.y1 = a, e.y2 = o;
    var s = n && n.lineWidth;
    return s && (Ha(i * 2) === Ha(r * 2) && (e.x1 = e.x2 = Yr(i, s, !0)), Ha(a * 2) === Ha(o * 2) && (e.y1 = e.y2 = Yr(a, s, !0))), e;
  }
}
function F1(e, t, n) {
  if (t) {
    var i = t.x, r = t.y, a = t.width, o = t.height;
    e.x = i, e.y = r, e.width = a, e.height = o;
    var s = n && n.lineWidth;
    return s && (e.x = Yr(i, s, !0), e.y = Yr(r, s, !0), e.width = Math.max(Yr(i + a, s, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max(Yr(r + o, s, !1) - e.y, o === 0 ? 0 : 1)), e;
  }
}
function Yr(e, t, n) {
  if (!t)
    return e;
  var i = Ha(e * 2);
  return (i + Ha(t)) % 2 === 0 ? i / 2 : (i + (n ? 1 : -1)) / 2;
}
var qL = /* @__PURE__ */ (function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
})(), ZL = {}, be = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new qL();
  }, t.prototype.buildPath = function(n, i) {
    var r, a, o, s;
    if (this.subPixelOptimize) {
      var l = F1(ZL, i, this.style);
      r = l.x, a = l.y, o = l.width, s = l.height, l.r = i.r, i = l;
    } else
      r = i.x, a = i.y, o = i.width, s = i.height;
    i.r ? XL(n, i) : n.rect(r, a, o, s);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
})(It);
be.prototype.type = "rect";
var sm = {
  fill: "#000"
}, lm = 2, zn = {}, KL = {
  style: Qt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, Pc.style)
}, gn = (function(e) {
  At(t, e);
  function t(n) {
    var i = e.call(this) || this;
    return i.type = "text", i._children = [], i._defaultStyle = sm, i.attr(n), i;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var n = 0; n < this._children.length; n++) {
      var i = this._children[n];
      i.zlevel = this.zlevel, i.z = this.z, i.z2 = this.z2, i.culling = this.culling, i.cursor = this.cursor, i.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var n = this.innerTransformable;
    n ? (n.updateTransform(), n.transform && (this.transform = n.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(n) {
    var i = this.innerTransformable;
    return i ? i.getLocalTransform(n) : e.prototype.getLocalTransform.call(this, n);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, nO(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(n) {
    e.prototype.addSelfToZr.call(this, n);
    for (var i = 0; i < this._children.length; i++)
      this._children[i].__zr = n;
  }, t.prototype.removeSelfFromZr = function(n) {
    e.prototype.removeSelfFromZr.call(this, n);
    for (var i = 0; i < this._children.length; i++)
      this._children[i].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var n = new it(0, 0, 0, 0), i = this._children, r = [], a = null, o = 0; o < i.length; o++) {
        var s = i[o], l = s.getBoundingRect(), u = s.getLocalTransform(r);
        u ? (n.copy(l), n.applyTransform(u), a = a || n.clone(), a.union(n)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || n;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(n) {
    this._defaultStyle = n || sm;
  }, t.prototype.setTextContent = function(n) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(n, i) {
    if (!i)
      return n;
    var r = i.rich, a = n.rich || r && {};
    return $(n, i), r && a ? (this._mergeRich(a, r), n.rich = a) : a && (n.rich = a), n;
  }, t.prototype._mergeRich = function(n, i) {
    for (var r = jt(i), a = 0; a < r.length; a++) {
      var o = r[a];
      n[o] = n[o] || {}, $(n[o], i[o]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return KL;
  }, t.prototype._getOrCreateChild = function(n) {
    var i = this._children[this._childCursor];
    return (!i || !(i instanceof n)) && (i = new n()), this._children[this._childCursor++] = i, i.__zr = this.__zr, i.parent = this, i;
  }, t.prototype._updatePlainTexts = function() {
    var n = this.style, i = n.font || tr, r = n.padding, a = this._defaultStyle, o = n.x || 0, s = n.y || 0, l = n.align || a.align || "left", u = n.verticalAlign || a.verticalAlign || "top";
    J_(zn, a.overflowRect, o, s, l, u), o = zn.baseX, s = zn.baseY;
    var c = pm(n), h = mL(c, n, zn.outerWidth, zn.outerHeight), d = Gh(n), f = !!n.backgroundColor, v = h.outerHeight, g = h.outerWidth, p = h.lines, _ = h.lineHeight;
    this.isTruncated = !!h.isTruncated;
    var m = o, y = Jr(s, h.contentHeight, u);
    if (d || r) {
      var b = ro(o, g, l), x = Jr(s, v, u);
      d && this._renderBackground(n, n, b, x, g, v);
    }
    y += _ / 2, r && (m = vm(o, l, r), u === "top" ? y += r[0] : u === "bottom" && (y -= r[2]));
    for (var w = 0, M = !1, D = !1, T = fm("fill" in n ? n.fill : (D = !0, a.fill)), C = dm("stroke" in n ? n.stroke : !f && (!a.autoStroke || D) ? (w = lm, M = !0, a.stroke) : null), k = n.textShadowBlur > 0, E = 0; E < p.length; E++) {
      var A = this._getOrCreateChild(Fu), L = A.createStyle();
      A.useStyle(L), L.text = p[E], L.x = m, L.y = y, L.textAlign = l, L.textBaseline = "middle", L.opacity = n.opacity, L.strokeFirst = !0, k && (L.shadowBlur = n.textShadowBlur || 0, L.shadowColor = n.textShadowColor || "transparent", L.shadowOffsetX = n.textShadowOffsetX || 0, L.shadowOffsetY = n.textShadowOffsetY || 0), L.stroke = C, L.fill = T, C && (L.lineWidth = n.lineWidth || w, L.lineDash = n.lineDash, L.lineDashOffset = n.lineDashOffset || 0), L.font = i, cm(L, n), y += _, A.setBoundingRect(hf(L, h.contentWidth, h.calculatedLineHeight, M ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var n = this.style, i = this._defaultStyle, r = n.align || i.align, a = n.verticalAlign || i.verticalAlign, o = n.x || 0, s = n.y || 0;
    J_(zn, i.overflowRect, o, s, r, a), o = zn.baseX, s = zn.baseY;
    var l = pm(n), u = xL(l, n, zn.outerWidth, zn.outerHeight, r), c = u.width, h = u.outerWidth, d = u.outerHeight, f = n.padding;
    this.isTruncated = !!u.isTruncated;
    var v = ro(o, h, r), g = Jr(s, d, a), p = v, _ = g;
    f && (p += f[3], _ += f[0]);
    var m = p + c;
    Gh(n) && this._renderBackground(n, n, v, g, h, d);
    for (var y = !!n.backgroundColor, b = 0; b < u.lines.length; b++) {
      for (var x = u.lines[b], w = x.tokens, M = w.length, D = x.lineHeight, T = x.width, C = 0, k = p, E = m, A = M - 1, L = void 0; C < M && (L = w[C], !L.align || L.align === "left"); )
        this._placeToken(L, n, D, _, k, "left", y), T -= L.width, k += L.width, C++;
      for (; A >= 0 && (L = w[A], L.align === "right"); )
        this._placeToken(L, n, D, _, E, "right", y), T -= L.width, E -= L.width, A--;
      for (k += (c - (k - p) - (m - E) - T) / 2; C <= A; )
        L = w[C], this._placeToken(L, n, D, _, k + L.width / 2, "center", y), k += L.width, C++;
      _ += D;
    }
  }, t.prototype._placeToken = function(n, i, r, a, o, s, l) {
    var u = i.rich[n.styleName] || {};
    u.text = n.text;
    var c = n.verticalAlign, h = a + r / 2;
    c === "top" ? h = a + n.height / 2 : c === "bottom" && (h = a + r - n.height / 2);
    var d = !n.isLineHolder && Gh(u);
    d && this._renderBackground(u, i, s === "right" ? o - n.width : s === "center" ? o - n.width / 2 : o, h - n.height / 2, n.width, n.height);
    var f = !!u.backgroundColor, v = n.textPadding;
    v && (o = vm(o, s, v), h -= n.height / 2 - v[0] - n.innerHeight / 2);
    var g = this._getOrCreateChild(Fu), p = g.createStyle();
    g.useStyle(p);
    var _ = this._defaultStyle, m = !1, y = 0, b = !1, x = fm("fill" in u ? u.fill : "fill" in i ? i.fill : (m = !0, _.fill)), w = dm("stroke" in u ? u.stroke : "stroke" in i ? i.stroke : !f && !l && (!_.autoStroke || m) ? (y = lm, b = !0, _.stroke) : null), M = u.textShadowBlur > 0 || i.textShadowBlur > 0;
    p.text = n.text, p.x = o, p.y = h, M && (p.shadowBlur = u.textShadowBlur || i.textShadowBlur || 0, p.shadowColor = u.textShadowColor || i.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || i.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || i.textShadowOffsetY || 0), p.textAlign = s, p.textBaseline = "middle", p.font = n.font || tr, p.opacity = Zr(u.opacity, i.opacity, 1), cm(p, u), w && (p.lineWidth = Zr(u.lineWidth, i.lineWidth, y), p.lineDash = J(u.lineDash, i.lineDash), p.lineDashOffset = i.lineDashOffset || 0, p.stroke = w), x && (p.fill = x), g.setBoundingRect(hf(p, n.contentWidth, n.contentHeight, b ? 0 : null));
  }, t.prototype._renderBackground = function(n, i, r, a, o, s) {
    var l = n.backgroundColor, u = n.borderWidth, c = n.borderColor, h = l && l.image, d = l && !h, f = n.borderRadius, v = this, g, p;
    if (d || n.lineHeight || u && c) {
      g = this._getOrCreateChild(be), g.useStyle(g.createStyle()), g.style.fill = null;
      var _ = g.shape;
      _.x = r, _.y = a, _.width = o, _.height = s, _.r = f, g.dirtyShape();
    }
    if (d) {
      var m = g.style;
      m.fill = l || null, m.fillOpacity = J(n.fillOpacity, 1);
    } else if (h) {
      p = this._getOrCreateChild(ua), p.onload = function() {
        v.dirtyStyle();
      };
      var y = p.style;
      y.image = l.image, y.x = r, y.y = a, y.width = o, y.height = s;
    }
    if (u && c) {
      var m = g.style;
      m.lineWidth = u, m.stroke = c, m.strokeOpacity = J(n.strokeOpacity, 1), m.lineDash = n.borderDash, m.lineDashOffset = n.borderDashOffset || 0, g.strokeContainThreshold = 0, g.hasFill() && g.hasStroke() && (m.strokeFirst = !0, m.lineWidth *= 2);
    }
    var b = (g || p).style;
    b.shadowBlur = n.shadowBlur || 0, b.shadowColor = n.shadowColor || "transparent", b.shadowOffsetX = n.shadowOffsetX || 0, b.shadowOffsetY = n.shadowOffsetY || 0, b.opacity = Zr(n.opacity, i.opacity, 1);
  }, t.makeFont = function(n) {
    var i = "";
    return eO(n) && (i = [
      n.fontStyle,
      n.fontWeight,
      tO(n.fontSize),
      n.fontFamily || "sans-serif"
    ].join(" ")), i && Un(i) || n.textFont || n.font;
  }, t;
})(Zs), QL = { left: !0, right: 1, center: 1 }, JL = { top: 1, bottom: 1, middle: 1 }, um = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function tO(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? gv + "px" : e + "px";
}
function cm(e, t) {
  for (var n = 0; n < um.length; n++) {
    var i = um[n], r = t[i];
    r != null && (e[i] = r);
  }
}
function eO(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function nO(e) {
  return hm(e), P(e.rich, hm), e;
}
function hm(e) {
  if (e) {
    e.font = gn.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || QL[t] ? t : "left";
    var n = e.verticalAlign;
    n === "center" && (n = "middle"), e.verticalAlign = n == null || JL[n] ? n : "top";
    var i = e.padding;
    i && (e.padding = bv(e.padding));
  }
}
function dm(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function fm(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function vm(e, t, n) {
  return t === "right" ? e - n[1] : t === "center" ? e + n[3] / 2 - n[1] / 2 : e + n[3];
}
function pm(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function Gh(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
var Bt = Wt(), iO = function(e, t, n, i) {
  if (i) {
    var r = Bt(i);
    r.dataIndex = n, r.dataType = t, r.seriesIndex = e, r.ssrType = "chart", i.type === "group" && i.traverse(function(a) {
      var o = Bt(a);
      o.seriesIndex = e, o.dataIndex = n, o.dataType = t, o.ssrType = "chart";
    });
  }
}, gm = 1, _m = {}, B1 = Wt(), Av = Wt(), z1 = 0, Ev = 1, Lv = 2, nr = ["emphasis", "blur", "select"], mm = ["normal", "emphasis", "blur", "select"], rO = 10, aO = 9, ea = "highlight", ou = "downplay", Bu = "select", vf = "unselect", zu = "toggleSelect", Ov = "selectchanged";
function wa(e) {
  return e != null && e !== "none";
}
function Ac(e, t, n) {
  e.onHoverStateChange && (e.hoverState || 0) !== n && e.onHoverStateChange(t), e.hoverState = n;
}
function V1(e) {
  Ac(e, "emphasis", Lv);
}
function $1(e) {
  e.hoverState === Lv && Ac(e, "normal", z1);
}
function Iv(e) {
  Ac(e, "blur", Ev);
}
function H1(e) {
  e.hoverState === Ev && Ac(e, "normal", z1);
}
function oO(e) {
  e.selected = !0;
}
function sO(e) {
  e.selected = !1;
}
function ym(e, t, n) {
  t(e, n);
}
function Pi(e, t, n) {
  ym(e, t, n), e.isGroup && e.traverse(function(i) {
    ym(i, t, n);
  });
}
function lO(e, t, n, i) {
  for (var r = e.style, a = {}, o = 0; o < t.length; o++) {
    var s = t[o], l = r[s];
    a[s] = l ?? (i && i[s]);
  }
  for (var o = 0; o < e.animators.length; o++) {
    var u = e.animators[o];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(n) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function uO(e, t, n, i) {
  var r = n && zt(n, "select") >= 0, a = !1;
  if (e instanceof It) {
    var o = B1(e), s = r && o.selectFill || o.normalFill, l = r && o.selectStroke || o.normalStroke;
    if (wa(s) || wa(l)) {
      i = i || {};
      var u = i.style || {};
      u.fill === "inherit" ? (a = !0, i = $({}, i), u = $({}, u), u.fill = s) : !wa(u.fill) && wa(s) ? (a = !0, i = $({}, i), u = $({}, u), u.fill = E_(s)) : !wa(u.stroke) && wa(l) && (a || (i = $({}, i), u = $({}, u)), u.stroke = E_(l)), i.style = u;
    }
  }
  if (i && i.z2 == null) {
    a || (i = $({}, i));
    var c = e.z2EmphasisLift;
    i.z2 = e.z2 + (c ?? rO);
  }
  return i;
}
function cO(e, t, n) {
  if (n && n.z2 == null) {
    n = $({}, n);
    var i = e.z2SelectLift;
    n.z2 = e.z2 + (i ?? aO);
  }
  return n;
}
function hO(e, t, n) {
  var i = zt(e.currentStates, t) >= 0, r = e.style.opacity, a = i ? null : lO(e, ["opacity"], t, {
    opacity: 1
  });
  n = n || {};
  var o = n.style || {};
  return o.opacity == null && (n = $({}, n), o = $({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: i ? r : a.opacity * 0.1
  }, o), n.style = o), n;
}
function jh(e, t) {
  var n = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return uO(this, e, t, n);
    if (e === "blur")
      return hO(this, e, n);
    if (e === "select")
      return cO(this, e, n);
  }
  return n;
}
function dO(e) {
  e.stateProxy = jh;
  var t = e.getTextContent(), n = e.getTextGuideLine();
  t && (t.stateProxy = jh), n && (n.stateProxy = jh);
}
function bm(e, t) {
  !G1(e, t) && !e.__highByOuter && Pi(e, V1);
}
function xm(e, t) {
  !G1(e, t) && !e.__highByOuter && Pi(e, $1);
}
function Vu(e, t) {
  e.__highByOuter |= 1 << (t || 0), Pi(e, V1);
}
function $u(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && Pi(e, $1);
}
function fO(e) {
  Pi(e, Iv);
}
function Y1(e) {
  Pi(e, H1);
}
function W1(e) {
  Pi(e, oO);
}
function U1(e) {
  Pi(e, sO);
}
function G1(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function j1(e) {
  var t = e.getModel(), n = [], i = [];
  t.eachComponent(function(r, a) {
    var o = Av(a), s = r === "series", l = s ? e.getViewOfSeriesModel(a) : e.getViewOfComponentModel(a);
    !s && i.push(l), o.isBlured && (l.group.traverse(function(u) {
      H1(u);
    }), s && n.push(a)), o.isBlured = !1;
  }), P(i, function(r) {
    r && r.toggleBlurSeries && r.toggleBlurSeries(n, !1, t);
  });
}
function pf(e, t, n, i) {
  var r = i.getModel();
  n = n || "coordinateSystem";
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var d = u.getItemGraphicEl(c[h]);
      d && Y1(d);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var o = r.getSeriesByIndex(e), s = o.coordinateSystem;
    s && s.master && (s = s.master);
    var l = [];
    r.eachSeries(function(u) {
      var c = o === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var d = h && s ? h === s : c;
      if (!// Not blur other series if blurScope series
      (n === "series" && !c || n === "coordinateSystem" && !d || t === "series" && c)) {
        var f = i.getViewOfSeriesModel(u);
        if (f.group.traverse(function(p) {
          p.__highByOuter && c && t === "self" || Iv(p);
        }), We(t))
          a(u.getData(), t);
        else if (X(t))
          for (var v = jt(t), g = 0; g < v.length; g++)
            a(u.getData(v[g]), t[v[g]]);
        l.push(u), Av(u).isBlured = !0;
      }
    }), r.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = i.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, r);
      }
    });
  }
}
function gf(e, t, n) {
  if (!(e == null || t == null)) {
    var i = n.getModel().getComponent(e, t);
    if (i) {
      Av(i).isBlured = !0;
      var r = n.getViewOfComponentModel(i);
      !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
        Iv(a);
      });
    }
  }
}
function vO(e, t, n) {
  var i = e.seriesIndex, r = e.getData(t.dataType);
  if (!r) {
    process.env.NODE_ENV !== "production" && qt("Unknown dataType " + t.dataType);
    return;
  }
  var a = Xs(r, t);
  a = (U(a) ? a[0] : a) || 0;
  var o = r.getItemGraphicEl(a);
  if (!o)
    for (var s = r.count(), l = 0; !o && l < s; )
      o = r.getItemGraphicEl(l++);
  if (o) {
    var u = Bt(o);
    pf(i, u.focus, u.blurScope, n);
  } else {
    var c = e.get(["emphasis", "focus"]), h = e.get(["emphasis", "blurScope"]);
    c != null && pf(i, c, h, n);
  }
}
function Rv(e, t, n, i) {
  var r = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || n == null)
    return r;
  var a = i.getModel().getComponent(e, t);
  if (!a)
    return r;
  var o = i.getViewOfComponentModel(a);
  if (!o || !o.findHighDownDispatchers)
    return r;
  for (var s = o.findHighDownDispatchers(n), l, u = 0; u < s.length; u++)
    if (process.env.NODE_ENV !== "production" && !so(s[u]) && qt("param should be highDownDispatcher"), Bt(s[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: s
  };
}
function pO(e, t, n) {
  process.env.NODE_ENV !== "production" && !so(e) && qt("param should be highDownDispatcher");
  var i = Bt(e), r = Rv(i.componentMainType, i.componentIndex, i.componentHighDownName, n), a = r.dispatchers, o = r.focusSelf;
  a ? (o && gf(i.componentMainType, i.componentIndex, n), P(a, function(s) {
    return bm(s, t);
  })) : (pf(i.seriesIndex, i.focus, i.blurScope, n), i.focus === "self" && gf(i.componentMainType, i.componentIndex, n), bm(e, t));
}
function gO(e, t, n) {
  process.env.NODE_ENV !== "production" && !so(e) && qt("param should be highDownDispatcher"), j1(n);
  var i = Bt(e), r = Rv(i.componentMainType, i.componentIndex, i.componentHighDownName, n).dispatchers;
  r ? P(r, function(a) {
    return xm(a, t);
  }) : xm(e, t);
}
function _O(e, t, n) {
  if (_f(t)) {
    var i = t.dataType, r = e.getData(i), a = Xs(r, t);
    U(a) || (a = [a]), e[t.type === zu ? "toggleSelect" : t.type === Bu ? "select" : "unselect"](a, i);
  }
}
function wm(e) {
  var t = e.getAllData();
  P(t, function(n) {
    var i = n.data, r = n.type;
    i.eachItemGraphicEl(function(a, o) {
      e.isSelected(o, r) ? W1(a) : U1(a);
    });
  });
}
function mO(e) {
  var t = [];
  return e.eachSeries(function(n) {
    var i = n.getAllData();
    P(i, function(r) {
      r.data;
      var a = r.type, o = n.getSelectedDataIndices();
      if (o.length > 0) {
        var s = {
          dataIndex: o,
          seriesIndex: n.seriesIndex
        };
        a != null && (s.dataType = a), t.push(s);
      }
    });
  }), t;
}
function yO(e, t, n) {
  X1(e, !0), Pi(e, dO), xO(e, t, n);
}
function bO(e) {
  X1(e, !1);
}
function Sm(e, t, n, i) {
  i ? bO(e) : yO(e, t, n);
}
function xO(e, t, n) {
  var i = Bt(e);
  t != null ? (i.focus = t, i.blurScope = n) : i.focus && (i.focus = null);
}
var Mm = ["emphasis", "blur", "select"], wO = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function Dm(e, t, n, i) {
  n = n || "itemStyle";
  for (var r = 0; r < Mm.length; r++) {
    var a = Mm[r], o = t.getModel([a, n]), s = e.ensureState(a);
    s.style = i ? i(o) : o[wO[n]]();
  }
}
function X1(e, t) {
  var n = t === !1, i = e;
  e.highDownSilentOnTouch && (i.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!n || i.__highDownDispatcher) && (i.__highByOuter = i.__highByOuter || 0, i.__highDownDispatcher = !n);
}
function so(e) {
  return !!(e && e.__highDownDispatcher);
}
function SO(e) {
  var t = _m[e];
  return t == null && gm <= 32 && (t = _m[e] = gm++), t;
}
function _f(e) {
  var t = e.type;
  return t === Bu || t === vf || t === zu;
}
function Tm(e) {
  var t = e.type;
  return t === ea || t === ou;
}
function MO(e) {
  var t = B1(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var n = e.states.select || {};
  t.selectFill = n.style && n.style.fill || null, t.selectStroke = n.style && n.style.stroke || null;
}
var Sa = oo.CMD, DO = [[], [], []], km = Math.sqrt, TO = Math.atan2;
function kO(e, t) {
  if (t) {
    var n = e.data, i = e.len(), r, a, o, s, l, u, c = Sa.M, h = Sa.C, d = Sa.L, f = Sa.R, v = Sa.A, g = Sa.Q;
    for (o = 0, s = 0; o < i; ) {
      switch (r = n[o++], s = o, a = 0, r) {
        case c:
          a = 1;
          break;
        case d:
          a = 1;
          break;
        case h:
          a = 3;
          break;
        case g:
          a = 2;
          break;
        case v:
          var p = t[4], _ = t[5], m = km(t[0] * t[0] + t[1] * t[1]), y = km(t[2] * t[2] + t[3] * t[3]), b = TO(-t[1] / y, t[0] / m);
          n[o] *= m, n[o++] += p, n[o] *= y, n[o++] += _, n[o++] *= m, n[o++] *= y, n[o++] += b, n[o++] += b, o += 2, s = o;
          break;
        case f:
          u[0] = n[o++], u[1] = n[o++], Ke(u, u, t), n[s++] = u[0], n[s++] = u[1], u[0] += n[o++], u[1] += n[o++], Ke(u, u, t), n[s++] = u[0], n[s++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var x = DO[l];
        x[0] = n[o++], x[1] = n[o++], Ke(x, x, t), n[s++] = x[0], n[s++] = x[1];
      }
    }
    e.increaseVersion();
  }
}
var Xh = Math.sqrt, Cl = Math.sin, Pl = Math.cos, Po = Math.PI;
function Cm(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function mf(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (Cm(e) * Cm(t));
}
function Pm(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos(mf(e, t));
}
function Am(e, t, n, i, r, a, o, s, l, u, c) {
  var h = l * (Po / 180), d = Pl(h) * (e - n) / 2 + Cl(h) * (t - i) / 2, f = -1 * Cl(h) * (e - n) / 2 + Pl(h) * (t - i) / 2, v = d * d / (o * o) + f * f / (s * s);
  v > 1 && (o *= Xh(v), s *= Xh(v));
  var g = (r === a ? -1 : 1) * Xh((o * o * (s * s) - o * o * (f * f) - s * s * (d * d)) / (o * o * (f * f) + s * s * (d * d))) || 0, p = g * o * f / s, _ = g * -s * d / o, m = (e + n) / 2 + Pl(h) * p - Cl(h) * _, y = (t + i) / 2 + Cl(h) * p + Pl(h) * _, b = Pm([1, 0], [(d - p) / o, (f - _) / s]), x = [(d - p) / o, (f - _) / s], w = [(-1 * d - p) / o, (-1 * f - _) / s], M = Pm(x, w);
  if (mf(x, w) <= -1 && (M = Po), mf(x, w) >= 1 && (M = 0), M < 0) {
    var D = Math.round(M / Po * 1e6) / 1e6;
    M = Po * 2 + D % 2 * Po;
  }
  c.addData(u, m, y, o, s, b, M, h, a);
}
var CO = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, PO = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function AO(e) {
  var t = new oo();
  if (!e)
    return t;
  var n = 0, i = 0, r = n, a = i, o, s = oo.CMD, l = e.match(CO);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), d = void 0, f = c.match(PO) || [], v = f.length, g = 0; g < v; g++)
      f[g] = parseFloat(f[g]);
    for (var p = 0; p < v; ) {
      var _ = void 0, m = void 0, y = void 0, b = void 0, x = void 0, w = void 0, M = void 0, D = n, T = i, C = void 0, k = void 0;
      switch (h) {
        case "l":
          n += f[p++], i += f[p++], d = s.L, t.addData(d, n, i);
          break;
        case "L":
          n = f[p++], i = f[p++], d = s.L, t.addData(d, n, i);
          break;
        case "m":
          n += f[p++], i += f[p++], d = s.M, t.addData(d, n, i), r = n, a = i, h = "l";
          break;
        case "M":
          n = f[p++], i = f[p++], d = s.M, t.addData(d, n, i), r = n, a = i, h = "L";
          break;
        case "h":
          n += f[p++], d = s.L, t.addData(d, n, i);
          break;
        case "H":
          n = f[p++], d = s.L, t.addData(d, n, i);
          break;
        case "v":
          i += f[p++], d = s.L, t.addData(d, n, i);
          break;
        case "V":
          i = f[p++], d = s.L, t.addData(d, n, i);
          break;
        case "C":
          d = s.C, t.addData(d, f[p++], f[p++], f[p++], f[p++], f[p++], f[p++]), n = f[p - 2], i = f[p - 1];
          break;
        case "c":
          d = s.C, t.addData(d, f[p++] + n, f[p++] + i, f[p++] + n, f[p++] + i, f[p++] + n, f[p++] + i), n += f[p - 2], i += f[p - 1];
          break;
        case "S":
          _ = n, m = i, C = t.len(), k = t.data, o === s.C && (_ += n - k[C - 4], m += i - k[C - 3]), d = s.C, D = f[p++], T = f[p++], n = f[p++], i = f[p++], t.addData(d, _, m, D, T, n, i);
          break;
        case "s":
          _ = n, m = i, C = t.len(), k = t.data, o === s.C && (_ += n - k[C - 4], m += i - k[C - 3]), d = s.C, D = n + f[p++], T = i + f[p++], n += f[p++], i += f[p++], t.addData(d, _, m, D, T, n, i);
          break;
        case "Q":
          D = f[p++], T = f[p++], n = f[p++], i = f[p++], d = s.Q, t.addData(d, D, T, n, i);
          break;
        case "q":
          D = f[p++] + n, T = f[p++] + i, n += f[p++], i += f[p++], d = s.Q, t.addData(d, D, T, n, i);
          break;
        case "T":
          _ = n, m = i, C = t.len(), k = t.data, o === s.Q && (_ += n - k[C - 4], m += i - k[C - 3]), n = f[p++], i = f[p++], d = s.Q, t.addData(d, _, m, n, i);
          break;
        case "t":
          _ = n, m = i, C = t.len(), k = t.data, o === s.Q && (_ += n - k[C - 4], m += i - k[C - 3]), n += f[p++], i += f[p++], d = s.Q, t.addData(d, _, m, n, i);
          break;
        case "A":
          y = f[p++], b = f[p++], x = f[p++], w = f[p++], M = f[p++], D = n, T = i, n = f[p++], i = f[p++], d = s.A, Am(D, T, n, i, w, M, y, b, x, d, t);
          break;
        case "a":
          y = f[p++], b = f[p++], x = f[p++], w = f[p++], M = f[p++], D = n, T = i, n += f[p++], i += f[p++], d = s.A, Am(D, T, n, i, w, M, y, b, x, d, t);
          break;
      }
    }
    (h === "z" || h === "Z") && (d = s.Z, t.addData(d), n = r, i = a), o = d;
  }
  return t.toStatic(), t;
}
var q1 = (function(e) {
  At(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(n) {
  }, t;
})(It);
function Z1(e) {
  return e.setData != null;
}
function K1(e, t) {
  var n = AO(e), i = $({}, t);
  return i.buildPath = function(r) {
    var a = Z1(r);
    if (a && r.canSave()) {
      r.appendPath(n);
      var o = r.getContext();
      o && r.rebuildPath(o, 1);
    } else {
      var o = a ? r.getContext() : r;
      o && n.rebuildPath(o, 1);
    }
  }, i.applyTransform = function(r) {
    kO(n, r), this.dirtyShape();
  }, i;
}
function EO(e, t) {
  return new q1(K1(e, t));
}
function LO(e, t) {
  var n = K1(e, t), i = (function(r) {
    At(a, r);
    function a(o) {
      var s = r.call(this, o) || this;
      return s.applyTransform = n.applyTransform, s.buildPath = n.buildPath, s;
    }
    return a;
  })(q1);
  return i;
}
function OO(e, t) {
  for (var n = [], i = e.length, r = 0; r < i; r++) {
    var a = e[r];
    n.push(a.getUpdatedPathProxy(!0));
  }
  var o = new It(t);
  return o.createPathProxy(), o.buildPath = function(s) {
    if (Z1(s)) {
      s.appendPath(n);
      var l = s.getContext();
      l && s.rebuildPath(l, 1);
    }
  }, o;
}
var IO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
})(), Ec = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new IO();
  }, t.prototype.buildPath = function(n, i) {
    n.moveTo(i.cx + i.r, i.cy), n.arc(i.cx, i.cy, i.r, 0, Math.PI * 2);
  }, t;
})(It);
Ec.prototype.type = "circle";
var RO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
})(), Nv = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new RO();
  }, t.prototype.buildPath = function(n, i) {
    var r = 0.5522848, a = i.cx, o = i.cy, s = i.rx, l = i.ry, u = s * r, c = l * r;
    n.moveTo(a - s, o), n.bezierCurveTo(a - s, o - c, a - u, o - l, a, o - l), n.bezierCurveTo(a + u, o - l, a + s, o - c, a + s, o), n.bezierCurveTo(a + s, o + c, a + u, o + l, a, o + l), n.bezierCurveTo(a - u, o + l, a - s, o + c, a - s, o), n.closePath();
  }, t;
})(It);
Nv.prototype.type = "ellipse";
var Q1 = Math.PI, qh = Q1 * 2, Mr = Math.sin, Ma = Math.cos, NO = Math.acos, ve = Math.atan2, Em = Math.abs, ps = Math.sqrt, es = Math.max, Vn = Math.min, yn = 1e-4;
function FO(e, t, n, i, r, a, o, s) {
  var l = n - e, u = i - t, c = o - r, h = s - a, d = h * l - c * u;
  if (!(d * d < yn))
    return d = (c * (t - a) - h * (e - r)) / d, [e + d * l, t + d * u];
}
function Al(e, t, n, i, r, a, o) {
  var s = e - n, l = t - i, u = (o ? a : -a) / ps(s * s + l * l), c = u * l, h = -u * s, d = e + c, f = t + h, v = n + c, g = i + h, p = (d + v) / 2, _ = (f + g) / 2, m = v - d, y = g - f, b = m * m + y * y, x = r - a, w = d * g - v * f, M = (y < 0 ? -1 : 1) * ps(es(0, x * x * b - w * w)), D = (w * y - m * M) / b, T = (-w * m - y * M) / b, C = (w * y + m * M) / b, k = (-w * m + y * M) / b, E = D - p, A = T - _, L = C - p, R = k - _;
  return E * E + A * A > L * L + R * R && (D = C, T = k), {
    cx: D,
    cy: T,
    x0: -c,
    y0: -h,
    x1: D * (r / x - 1),
    y1: T * (r / x - 1)
  };
}
function BO(e) {
  var t;
  if (U(e)) {
    var n = e.length;
    if (!n)
      return e;
    n === 1 ? t = [e[0], e[0], 0, 0] : n === 2 ? t = [e[0], e[0], e[1], e[1]] : n === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function zO(e, t) {
  var n, i = es(t.r, 0), r = es(t.r0 || 0, 0), a = i > 0, o = r > 0;
  if (!(!a && !o)) {
    if (a || (i = r, r = 0), r > i) {
      var s = i;
      i = r, r = s;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, h = t.cy, d = !!t.clockwise, f = Em(u - l), v = f > qh && f % qh;
      if (v > yn && (f = v), !(i > yn))
        e.moveTo(c, h);
      else if (f > qh - yn)
        e.moveTo(c + i * Ma(l), h + i * Mr(l)), e.arc(c, h, i, l, u, !d), r > yn && (e.moveTo(c + r * Ma(u), h + r * Mr(u)), e.arc(c, h, r, u, l, d));
      else {
        var g = void 0, p = void 0, _ = void 0, m = void 0, y = void 0, b = void 0, x = void 0, w = void 0, M = void 0, D = void 0, T = void 0, C = void 0, k = void 0, E = void 0, A = void 0, L = void 0, R = i * Ma(l), N = i * Mr(l), V = r * Ma(u), q = r * Mr(u), W = f > yn;
        if (W) {
          var Z = t.cornerRadius;
          Z && (n = BO(Z), g = n[0], p = n[1], _ = n[2], m = n[3]);
          var bt = Em(i - r) / 2;
          if (y = Vn(bt, _), b = Vn(bt, m), x = Vn(bt, g), w = Vn(bt, p), T = M = es(y, b), C = D = es(x, w), (M > yn || D > yn) && (k = i * Ma(u), E = i * Mr(u), A = r * Ma(l), L = r * Mr(l), f < Q1)) {
            var et = FO(R, N, A, L, k, E, V, q);
            if (et) {
              var at = R - et[0], ht = N - et[1], Ht = k - et[0], Rt = E - et[1], Oe = 1 / Mr(NO((at * Ht + ht * Rt) / (ps(at * at + ht * ht) * ps(Ht * Ht + Rt * Rt))) / 2), Ue = ps(et[0] * et[0] + et[1] * et[1]);
              T = Vn(M, (i - Ue) / (Oe + 1)), C = Vn(D, (r - Ue) / (Oe - 1));
            }
          }
        }
        if (!W)
          e.moveTo(c + R, h + N);
        else if (T > yn) {
          var De = Vn(_, T), oe = Vn(m, T), nt = Al(A, L, R, N, i, De, d), _t = Al(k, E, V, q, i, oe, d);
          e.moveTo(c + nt.cx + nt.x0, h + nt.cy + nt.y0), T < M && De === oe ? e.arc(c + nt.cx, h + nt.cy, T, ve(nt.y0, nt.x0), ve(_t.y0, _t.x0), !d) : (De > 0 && e.arc(c + nt.cx, h + nt.cy, De, ve(nt.y0, nt.x0), ve(nt.y1, nt.x1), !d), e.arc(c, h, i, ve(nt.cy + nt.y1, nt.cx + nt.x1), ve(_t.cy + _t.y1, _t.cx + _t.x1), !d), oe > 0 && e.arc(c + _t.cx, h + _t.cy, oe, ve(_t.y1, _t.x1), ve(_t.y0, _t.x0), !d));
        } else
          e.moveTo(c + R, h + N), e.arc(c, h, i, l, u, !d);
        if (!(r > yn) || !W)
          e.lineTo(c + V, h + q);
        else if (C > yn) {
          var De = Vn(g, C), oe = Vn(p, C), nt = Al(V, q, k, E, r, -oe, d), _t = Al(R, N, A, L, r, -De, d);
          e.lineTo(c + nt.cx + nt.x0, h + nt.cy + nt.y0), C < D && De === oe ? e.arc(c + nt.cx, h + nt.cy, C, ve(nt.y0, nt.x0), ve(_t.y0, _t.x0), !d) : (oe > 0 && e.arc(c + nt.cx, h + nt.cy, oe, ve(nt.y0, nt.x0), ve(nt.y1, nt.x1), !d), e.arc(c, h, r, ve(nt.cy + nt.y1, nt.cx + nt.x1), ve(_t.cy + _t.y1, _t.cx + _t.x1), d), De > 0 && e.arc(c + _t.cx, h + _t.cy, De, ve(_t.y1, _t.x1), ve(_t.y0, _t.x0), !d));
        } else
          e.lineTo(c + V, h + q), e.arc(c, h, r, u, l, d);
      }
      e.closePath();
    }
  }
}
var VO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
})(), Fv = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new VO();
  }, t.prototype.buildPath = function(n, i) {
    zO(n, i);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
})(It);
Fv.prototype.type = "sector";
var $O = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
})(), Bv = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new $O();
  }, t.prototype.buildPath = function(n, i) {
    var r = i.cx, a = i.cy, o = Math.PI * 2;
    n.moveTo(r + i.r, a), n.arc(r, a, i.r, 0, o, !1), n.moveTo(r + i.r0, a), n.arc(r, a, i.r0, 0, o, !0);
  }, t;
})(It);
Bv.prototype.type = "ring";
function HO(e, t, n, i) {
  var r = [], a = [], o = [], s = [], l, u, c, h;
  if (i) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var d = 0, f = e.length; d < f; d++)
      Ba(c, c, e[d]), za(h, h, e[d]);
    Ba(c, c, i[0]), za(h, h, i[1]);
  }
  for (var d = 0, f = e.length; d < f; d++) {
    var v = e[d];
    if (n)
      l = e[d ? d - 1 : f - 1], u = e[(d + 1) % f];
    else if (d === 0 || d === f - 1) {
      r.push(fA(e[d]));
      continue;
    } else
      l = e[d - 1], u = e[d + 1];
    vA(a, u, l), hh(a, a, t);
    var g = Ud(v, l), p = Ud(v, u), _ = g + p;
    _ !== 0 && (g /= _, p /= _), hh(o, a, -g), hh(s, a, p);
    var m = f_([], v, o), y = f_([], v, s);
    i && (za(m, m, c), Ba(m, m, h), za(y, y, c), Ba(y, y, h)), r.push(m), r.push(y);
  }
  return n && r.push(r.shift()), r;
}
function J1(e, t, n) {
  var i = t.smooth, r = t.points;
  if (r && r.length >= 2) {
    if (i) {
      var a = HO(r, i, n, t.smoothConstraint);
      e.moveTo(r[0][0], r[0][1]);
      for (var o = r.length, s = 0; s < (n ? o : o - 1); s++) {
        var l = a[s * 2], u = a[s * 2 + 1], c = r[(s + 1) % o];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(r[0][0], r[0][1]);
      for (var s = 1, h = r.length; s < h; s++)
        e.lineTo(r[s][0], r[s][1]);
    }
    n && e.closePath();
  }
}
var YO = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), zv = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new YO();
  }, t.prototype.buildPath = function(n, i) {
    J1(n, i, !0);
  }, t;
})(It);
zv.prototype.type = "polygon";
var WO = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), Vv = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new WO();
  }, t.prototype.buildPath = function(n, i) {
    J1(n, i, !1);
  }, t;
})(It);
Vv.prototype.type = "polyline";
var UO = {}, GO = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
})(), vo = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new GO();
  }, t.prototype.buildPath = function(n, i) {
    var r, a, o, s;
    if (this.subPixelOptimize) {
      var l = N1(UO, i, this.style);
      r = l.x1, a = l.y1, o = l.x2, s = l.y2;
    } else
      r = i.x1, a = i.y1, o = i.x2, s = i.y2;
    var u = i.percent;
    u !== 0 && (n.moveTo(r, a), u < 1 && (o = r * (1 - u) + o * u, s = a * (1 - u) + s * u), n.lineTo(o, s));
  }, t.prototype.pointAt = function(n) {
    var i = this.shape;
    return [
      i.x1 * (1 - n) + i.x2 * n,
      i.y1 * (1 - n) + i.y2 * n
    ];
  }, t;
})(It);
vo.prototype.type = "line";
var Re = [], jO = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
})();
function Lm(e, t, n) {
  var i = e.cpx2, r = e.cpy2;
  return i != null || r != null ? [
    (n ? T_ : Ce)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (n ? T_ : Ce)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (n ? k_ : ze)(e.x1, e.cpx1, e.x2, t),
    (n ? k_ : ze)(e.y1, e.cpy1, e.y2, t)
  ];
}
var $v = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new jO();
  }, t.prototype.buildPath = function(n, i) {
    var r = i.x1, a = i.y1, o = i.x2, s = i.y2, l = i.cpx1, u = i.cpy1, c = i.cpx2, h = i.cpy2, d = i.percent;
    d !== 0 && (n.moveTo(r, a), c == null || h == null ? (d < 1 && (Au(r, l, o, d, Re), l = Re[1], o = Re[2], Au(a, u, s, d, Re), u = Re[1], s = Re[2]), n.quadraticCurveTo(l, u, o, s)) : (d < 1 && (Pu(r, l, c, o, d, Re), l = Re[1], c = Re[2], o = Re[3], Pu(a, u, h, s, d, Re), u = Re[1], h = Re[2], s = Re[3]), n.bezierCurveTo(l, u, c, h, o, s)));
  }, t.prototype.pointAt = function(n) {
    return Lm(this.shape, n, !1);
  }, t.prototype.tangentAt = function(n) {
    var i = Lm(this.shape, n, !0);
    return _A(i, i);
  }, t;
})(It);
$v.prototype.type = "bezier-curve";
var XO = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
})(), Lc = (function(e) {
  At(t, e);
  function t(n) {
    return e.call(this, n) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new XO();
  }, t.prototype.buildPath = function(n, i) {
    var r = i.cx, a = i.cy, o = Math.max(i.r, 0), s = i.startAngle, l = i.endAngle, u = i.clockwise, c = Math.cos(s), h = Math.sin(s);
    n.moveTo(c * o + r, h * o + a), n.arc(r, a, o, s, l, !u);
  }, t;
})(It);
Lc.prototype.type = "arc";
var qO = (function(e) {
  At(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.type = "compound", n;
  }
  return t.prototype._updatePathDirty = function() {
    for (var n = this.shape.paths, i = this.shapeChanged(), r = 0; r < n.length; r++)
      i = i || n[r].shapeChanged();
    i && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var n = this.shape.paths || [], i = this.getGlobalScale(), r = 0; r < n.length; r++)
      n[r].path || n[r].createPathProxy(), n[r].path.setScale(i[0], i[1], n[r].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(n, i) {
    for (var r = i.paths || [], a = 0; a < r.length; a++)
      r[a].buildPath(n, r[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var n = this.shape.paths || [], i = 0; i < n.length; i++)
      n[i].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), It.prototype.getBoundingRect.call(this);
  }, t;
})(It), tx = (function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, n) {
    this.colorStops.push({
      offset: t,
      color: n
    });
  }, e;
})(), ex = (function(e) {
  At(t, e);
  function t(n, i, r, a, o, s) {
    var l = e.call(this, o) || this;
    return l.x = n ?? 0, l.y = i ?? 0, l.x2 = r ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = s || !1, l;
  }
  return t;
})(tx), ZO = (function(e) {
  At(t, e);
  function t(n, i, r, a, o) {
    var s = e.call(this, a) || this;
    return s.x = n ?? 0.5, s.y = i ?? 0.5, s.r = r ?? 0.5, s.type = "radial", s.global = o || !1, s;
  }
  return t;
})(tx), Zh = Math.min, KO = Math.max, El = Math.abs, Dr = [0, 0], Tr = [0, 0], ce = Qb(), Ll = ce.minTv, Ol = ce.maxTv, nx = (function() {
  function e(t, n) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var i = 0; i < 4; i++)
      this._corners[i] = new Lt();
    for (var i = 0; i < 2; i++)
      this._axes[i] = new Lt();
    t && this.fromBoundingRect(t, n);
  }
  return e.prototype.fromBoundingRect = function(t, n) {
    var i = this._corners, r = this._axes, a = t.x, o = t.y, s = a + t.width, l = o + t.height;
    if (i[0].set(a, o), i[1].set(s, o), i[2].set(s, l), i[3].set(a, l), n)
      for (var u = 0; u < 4; u++)
        i[u].transform(n);
    Lt.sub(r[0], i[1], i[0]), Lt.sub(r[1], i[3], i[0]), r[0].normalize(), r[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = r[u].dot(i[0]);
  }, e.prototype.intersect = function(t, n, i) {
    var r = !0, a = !n;
    return n && Lt.set(n, 0, 0), ce.reset(i, !a), !this._intersectCheckOneSide(this, t, a, 1) && (r = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (r = !1, a) || !a && !ce.negativeSize && Lt.copy(n, r ? ce.useDir ? ce.dirMinTv : Ll : Ol), r;
  }, e.prototype._intersectCheckOneSide = function(t, n, i, r) {
    for (var a = !0, o = 0; o < 2; o++) {
      var s = t._axes[o];
      if (t._getProjMinMaxOnAxis(o, t._corners, Dr), t._getProjMinMaxOnAxis(o, n._corners, Tr), ce.negativeSize || Dr[1] < Tr[0] || Dr[0] > Tr[1]) {
        if (a = !1, ce.negativeSize || i)
          return a;
        var l = El(Tr[0] - Dr[1]), u = El(Dr[0] - Tr[1]);
        Zh(l, u) > Ol.len() && (l < u ? Lt.scale(Ol, s, -l * r) : Lt.scale(Ol, s, u * r));
      } else if (!i) {
        var l = El(Tr[0] - Dr[1]), u = El(Dr[0] - Tr[1]);
        (ce.useDir || Zh(l, u) < Ll.len()) && ((l < u || !ce.bidirectional) && (Lt.scale(Ll, s, l * r), ce.useDir && ce.calcDirMTV()), (l >= u || !ce.bidirectional) && (Lt.scale(Ll, s, -u * r), ce.useDir && ce.calcDirMTV()));
      }
    }
    return a;
  }, e.prototype._getProjMinMaxOnAxis = function(t, n, i) {
    for (var r = this._axes[t], a = this._origin, o = n[0].dot(r) + a[t], s = o, l = o, u = 1; u < n.length; u++) {
      var c = n[u].dot(r) + a[t];
      s = Zh(c, s), l = KO(c, l);
    }
    i[0] = s + ce.touchThreshold, i[1] = l - ce.touchThreshold, ce.negativeSize = i[1] < i[0];
  }, e;
})(), QO = [], JO = (function(e) {
  At(t, e);
  function t() {
    var n = e !== null && e.apply(this, arguments) || this;
    return n.notClear = !0, n.incremental = !0, n._displayables = [], n._temporaryDisplayables = [], n._cursor = 0, n;
  }
  return t.prototype.traverse = function(n, i) {
    n.call(i, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(n, i) {
    i ? this._temporaryDisplayables.push(n) : this._displayables.push(n), this.markRedraw();
  }, t.prototype.addDisplayables = function(n, i) {
    i = i || !1;
    for (var r = 0; r < n.length; r++)
      this.addDisplayable(n[r], i);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(n) {
    for (var i = this._cursor; i < this._displayables.length; i++)
      n && n(this._displayables[i]);
    for (var i = 0; i < this._temporaryDisplayables.length; i++)
      n && n(this._temporaryDisplayables[i]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var n = this._cursor; n < this._displayables.length; n++) {
      var i = this._displayables[n];
      i.parent = this, i.update(), i.parent = null;
    }
    for (var n = 0; n < this._temporaryDisplayables.length; n++) {
      var i = this._temporaryDisplayables[n];
      i.parent = this, i.update(), i.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var n = new it(1 / 0, 1 / 0, -1 / 0, -1 / 0), i = 0; i < this._displayables.length; i++) {
        var r = this._displayables[i], a = r.getBoundingRect().clone();
        r.needLocalTransform() && a.applyTransform(r.getLocalTransform(QO)), n.union(a);
      }
      this._rect = n;
    }
    return this._rect;
  }, t.prototype.contain = function(n, i) {
    var r = this.transformCoordToLocal(n, i), a = this.getBoundingRect();
    if (a.contain(r[0], r[1]))
      for (var o = 0; o < this._displayables.length; o++) {
        var s = this._displayables[o];
        if (s.contain(n, i))
          return !0;
      }
    return !1;
  }, t;
})(Zs);
Wt();
function tI(e, t, n, i, r) {
  var a;
  if (t && t.ecModel) {
    var o = t.ecModel.getUpdatePayload();
    a = o && o.animation;
  }
  var s = t && t.isAnimationEnabled(), l = e === "update";
  if (s) {
    var u = void 0, c = void 0, h = void 0;
    i ? (u = J(i.duration, 200), c = J(i.easing, "cubicOut"), h = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), gt(h) && (h = h(n, r)), gt(u) && (u = u(n));
    var d = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return d;
  } else
    return null;
}
function Hv(e, t, n, i, r, a, o) {
  var s = !1, l;
  gt(r) ? (o = a, a = r, r = null) : X(r) && (a = r.cb, o = r.during, s = r.isFrom, l = r.removeOpt, r = r.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = tI(e, i, r, u ? l || {} : null, i && i.getAnimationDelayParams ? i.getAnimationDelayParams(t, r) : null);
  if (c && c.duration > 0) {
    var h = c.duration, d = c.delay, f = c.easing, v = {
      duration: h,
      delay: d || 0,
      easing: f,
      done: a,
      force: !!a || !!o,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: o
    };
    s ? t.animateFrom(n, v) : t.animateTo(n, v);
  } else
    t.stopAnimation(), !s && t.attr(n), o && o(1), a && a();
}
function Yv(e, t, n, i, r, a) {
  Hv("update", e, t, n, i, r, a);
}
function ix(e, t, n, i, r, a) {
  Hv("enter", e, t, n, i, r, a);
}
function gs(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var n = e.animators[t];
    if (n.scope === "leave")
      return !0;
  }
  return !1;
}
function rx(e, t, n, i, r, a) {
  gs(e) || Hv("leave", e, t, n, i, r, a);
}
function Om(e, t, n, i) {
  e.removeTextContent(), e.removeTextGuideLine(), rx(e, {
    style: {
      opacity: 0
    }
  }, t, n, i);
}
function eI(e, t, n) {
  function i() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(r) {
    r.isGroup || Om(r, t, n, i);
  }) : Om(e, t, n, i);
}
var yf = {}, nI = ["x", "y"], iI = ["width", "height"];
function rI(e) {
  return It.extend(e);
}
var aI = LO;
function oI(e, t) {
  return aI(e, t);
}
function Ln(e, t) {
  yf[e] = t;
}
function sI(e) {
  if (yf.hasOwnProperty(e))
    return yf[e];
}
function Wv(e, t, n, i) {
  var r = EO(e, t);
  return n && (i === "center" && (n = ox(n, r.getBoundingRect())), sx(r, n)), r;
}
function ax(e, t, n) {
  var i = new ua({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(r) {
      if (n === "center") {
        var a = {
          width: r.width,
          height: r.height
        };
        i.setStyle(ox(t, a));
      }
    }
  });
  return i;
}
function ox(e, t) {
  var n = t.width / t.height, i = e.height * n, r;
  i <= e.width ? r = e.height : (i = e.width, r = i / n);
  var a = e.x + e.width / 2, o = e.y + e.height / 2;
  return {
    x: a - i / 2,
    y: o - r / 2,
    width: i,
    height: r
  };
}
var lI = OO;
function sx(e, t) {
  if (e.applyTransform) {
    var n = e.getBoundingRect(), i = n.calculateTransform(t);
    e.applyTransform(i);
  }
}
function Uv(e, t) {
  return N1(e, e, {
    lineWidth: t
  }), e;
}
function uI(e, t) {
  return F1(e, e, t), e;
}
var cI = Yr;
function hI(e, t) {
  for (var n = wv([]); e && e !== t; )
    hs(n, e.getLocalTransform(), n), e = e.parent;
  return n;
}
function Gv(e, t, n) {
  return t && !We(t) && (t = Hr.getLocalTransform(t)), n && (t = Gs([], t)), Ke([], e, t);
}
function dI(e, t, n) {
  var i = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : gi(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : gi(2 * t[4] / t[2]), a = [e === "left" ? -i : e === "right" ? i : 0, e === "top" ? -r : e === "bottom" ? r : 0];
  return a = Gv(a, t, n), gi(a[0]) > gi(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function Im(e) {
  return !e.isGroup;
}
function fI(e) {
  return e.shape != null;
}
function vI(e, t, n) {
  if (!e || !t)
    return;
  function i(o) {
    var s = {};
    return o.traverse(function(l) {
      Im(l) && l.anid && (s[l.anid] = l);
    }), s;
  }
  function r(o) {
    var s = {
      x: o.x,
      y: o.y,
      rotation: o.rotation
    };
    return fI(o) && (s.shape = ft(o.shape)), s;
  }
  var a = i(e);
  t.traverse(function(o) {
    if (Im(o) && o.anid) {
      var s = a[o.anid];
      if (s) {
        var l = r(o);
        o.attr(r(s)), Yv(o, l, n, Bt(o).dataIndex);
      }
    }
  });
}
function pI(e, t) {
  return yt(e, function(n) {
    var i = n[0];
    i = wn(i, t.x), i = As(i, t.x + t.width);
    var r = n[1];
    return r = wn(r, t.y), r = As(r, t.y + t.height), [i, r];
  });
}
function gI(e, t) {
  var n = wn(e.x, t.x), i = As(e.x + e.width, t.x + t.width), r = wn(e.y, t.y), a = As(e.y + e.height, t.y + t.height);
  if (i >= n && a >= r)
    return {
      x: n,
      y: r,
      width: i - n,
      height: a - r
    };
}
function lx(e, t, n) {
  var i = $({
    rectHover: !0
  }, t), r = i.style = {
    strokeNoScale: !0
  };
  if (n = n || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (r.image = e.slice(8), Qt(r, n), new ua(i)) : Wv(e.replace("path://", ""), i, n, "center");
}
function _I(e, t, n, i, r) {
  for (var a = 0, o = r[r.length - 1]; a < r.length; a++) {
    var s = r[a];
    if (ux(e, t, n, i, s[0], s[1], o[0], o[1]))
      return !0;
    o = s;
  }
}
function ux(e, t, n, i, r, a, o, s) {
  var l = n - e, u = i - t, c = o - r, h = s - a, d = Kh(c, h, l, u);
  if (mI(d))
    return !1;
  var f = e - r, v = t - a, g = Kh(f, v, l, u) / d;
  if (g < 0 || g > 1)
    return !1;
  var p = Kh(f, v, c, h) / d;
  return !(p < 0 || p > 1);
}
function Kh(e, t, n, i) {
  return e * i - n * t;
}
function mI(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function bf(e, t, n, i, r) {
  return t == null || (Xt(t) ? Ot[0] = Ot[1] = Ot[2] = Ot[3] = t : (process.env.NODE_ENV !== "production" && Q(t.length === 4), Ot[0] = t[0], Ot[1] = t[1], Ot[2] = t[2], Ot[3] = t[3]), i && (Ot[0] = wn(0, Ot[0]), Ot[1] = wn(0, Ot[1]), Ot[2] = wn(0, Ot[2]), Ot[3] = wn(0, Ot[3])), n && (Ot[0] = -Ot[0], Ot[1] = -Ot[1], Ot[2] = -Ot[2], Ot[3] = -Ot[3]), Rm(e, Ot, "x", "width", 3, 1, r && r[0] || 0), Rm(e, Ot, "y", "height", 0, 2, r && r[1] || 0)), e;
}
var Ot = [0, 0, 0, 0];
function Rm(e, t, n, i, r, a, o) {
  var s = t[a] + t[r], l = e[i];
  e[i] += s, o = wn(0, As(o, l)), e[i] < o ? (e[i] = o, e[n] += t[r] >= 0 ? -t[r] : t[a] >= 0 ? l + t[a] : gi(s) > 1e-8 ? (l - o) * t[r] / s : 0) : e[n] -= t[r];
}
function jv(e) {
  var t = e.itemTooltipOption, n = e.componentModel, i = e.itemName, r = K(t) ? {
    formatter: t
  } : t, a = n.mainType, o = n.componentIndex, s = {
    componentType: a,
    name: i,
    $vars: ["name"]
  };
  s[a + "Index"] = o;
  var l = e.formatterParamsExtra;
  l && P(jt(l), function(c) {
    Xn(s, c) || (s[c] = l[c], s.$vars.push(c));
  });
  var u = Bt(e.el);
  u.componentMainType = a, u.componentIndex = o, u.tooltipConfig = {
    name: i,
    option: Qt({
      content: i,
      encodeHTMLContent: !0,
      formatterParams: s
    }, r)
  };
}
function xf(e, t) {
  var n;
  e.isGroup && (n = t(e)), n || e.traverse(t);
}
function cx(e, t) {
  if (e)
    if (U(e))
      for (var n = 0; n < e.length; n++)
        xf(e[n], t);
    else
      xf(e, t);
}
function Xv(e) {
  return !e || gi(e[1]) < Il && gi(e[2]) < Il || gi(e[0]) < Il && gi(e[3]) < Il;
}
var Il = 1e-5;
function Os(e, t) {
  return e ? it.copy(e, t) : t.clone();
}
function qv(e, t) {
  return t ? Sv(e || qn(), t) : void 0;
}
function Is(e) {
  return {
    z: e.get("z") || 0,
    zlevel: e.get("zlevel") || 0
  };
}
function yI(e) {
  var t = -1 / 0, n = 1 / 0;
  xf(e, function(a) {
    i(a), i(a.getTextContent()), i(a.getTextGuideLine());
  });
  function i(a) {
    if (!(!a || a.isGroup)) {
      var o = a.currentStates;
      if (o.length)
        for (var s = 0; s < o.length; s++)
          r(a.states[o[s]]);
      r(a);
    }
  }
  function r(a) {
    if (a) {
      var o = a.z2;
      o > t && (t = o), o < n && (n = o);
    }
  }
  return n > t && (n = t = 0), {
    min: n,
    max: t
  };
}
function hx(e, t, n) {
  dx(e, t, n, -1 / 0);
}
function dx(e, t, n, i) {
  if (e.ignoreModelZ)
    return i;
  var r = e.getTextContent(), a = e.getTextGuideLine(), o = e.isGroup;
  if (o)
    for (var s = e.childrenRef(), l = 0; l < s.length; l++)
      i = wn(dx(s[l], t, n, i), i);
  else
    e.z = t, e.zlevel = n, i = wn(e.z2 || 0, i);
  if (r && (r.z = t, r.zlevel = n, isFinite(i) && (r.z2 = i + 2)), a) {
    var u = e.textGuideLineConfig;
    a.z = t, a.zlevel = n, isFinite(i) && (a.z2 = i + (u && u.showAbove ? 1 : -1));
  }
  return i;
}
Ln("circle", Ec);
Ln("ellipse", Nv);
Ln("sector", Fv);
Ln("ring", Bv);
Ln("polygon", zv);
Ln("polyline", Vv);
Ln("rect", be);
Ln("line", vo);
Ln("bezierCurve", $v);
Ln("arc", Lc);
const bI = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Lc,
  BezierCurve: $v,
  BoundingRect: it,
  Circle: Ec,
  CompoundPath: qO,
  Ellipse: Nv,
  Group: Dn,
  Image: ua,
  IncrementalDisplayable: JO,
  Line: vo,
  LinearGradient: ex,
  OrientedBoundingRect: nx,
  Path: It,
  Point: Lt,
  Polygon: zv,
  Polyline: Vv,
  RadialGradient: ZO,
  Rect: be,
  Ring: Bv,
  Sector: Fv,
  Text: gn,
  WH: iI,
  XY: nI,
  applyTransform: Gv,
  calcZ2Range: yI,
  clipPointsByRect: pI,
  clipRectByRect: gI,
  createIcon: lx,
  ensureCopyRect: Os,
  ensureCopyTransform: qv,
  expandOrShrinkRect: bf,
  extendPath: oI,
  extendShape: rI,
  getShapeClass: sI,
  getTransform: hI,
  groupTransition: vI,
  initProps: ix,
  isBoundingRectAxisAligned: Xv,
  isElementRemoved: gs,
  lineLineIntersect: ux,
  linePolygonIntersect: _I,
  makeImage: ax,
  makePath: Wv,
  mergePath: lI,
  registerShape: Ln,
  removeElement: rx,
  removeElementWithFadeOut: eI,
  resizePath: sx,
  retrieveZInfo: Is,
  setTooltipConfig: jv,
  subPixelOptimize: cI,
  subPixelOptimizeLine: Uv,
  subPixelOptimizeRect: uI,
  transformDirection: dI,
  traverseElements: cx,
  traverseUpdateZ: hx,
  updateProps: Yv
}, Symbol.toStringTag, { value: "Module" }));
var Oc = {};
function xI(e, t) {
  for (var n = 0; n < nr.length; n++) {
    var i = nr[n], r = t[i], a = e.ensureState(i);
    a.style = a.style || {}, a.style.text = r;
  }
  var o = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(o, !0);
}
function Nm(e, t, n) {
  var i = e.labelFetcher, r = e.labelDataIndex, a = e.labelDimIndex, o = t.normal, s;
  i && (s = i.getFormattedLabel(r, "normal", null, a, o && o.get("formatter"), n != null ? {
    interpolatedValue: n
  } : null)), s == null && (s = gt(e.defaultText) ? e.defaultText(r, e, n) : e.defaultText);
  for (var l = {
    normal: s
  }, u = 0; u < nr.length; u++) {
    var c = nr[u], h = t[c];
    l[c] = J(i ? i.getFormattedLabel(r, c, null, a, h && h.get("formatter")) : null, s);
  }
  return l;
}
function Fm(e, t, n, i) {
  n = n || Oc;
  for (var r = e instanceof gn, a = !1, o = 0; o < mm.length; o++) {
    var s = t[mm[o]];
    if (s && s.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = r ? e : e.getTextContent();
  if (a) {
    r || (l || (l = new gn(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = Nm(n, t), c = t.normal, h = !!c.getShallow("show"), d = oa(c, i, n, !1, !r);
    d.text = u.normal, r || e.setTextConfig(zm(c, n, !1));
    for (var o = 0; o < nr.length; o++) {
      var f = nr[o], s = t[f];
      if (s) {
        var v = l.ensureState(f), g = !!J(s.getShallow("show"), h);
        if (g !== h && (v.ignore = !g), v.style = oa(s, i, n, !0, !r), v.style.text = u[f], !r) {
          var p = e.ensureState(f);
          p.textConfig = zm(s, n, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (d.x = l.style.x), l.style.y != null && (d.y = l.style.y), l.ignore = !h, l.useStyle(d), l.dirty(), n.enableTextSetter && (DI(l).setLabelText = function(_) {
      var m = Nm(n, t, _);
      xI(l, m);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function Bm(e, t) {
  t = t || "label";
  for (var n = {
    normal: e.getModel(t)
  }, i = 0; i < nr.length; i++) {
    var r = nr[i];
    n[r] = e.getModel([r, t]);
  }
  return n;
}
function oa(e, t, n, i, r) {
  var a = {};
  return wI(a, e, n, i, r), t && $(a, t), a;
}
function zm(e, t, n) {
  t = t || {};
  var i = {}, r, a = e.getShallow("rotate"), o = J(e.getShallow("distance"), n ? null : 5), s = e.getShallow("offset");
  return r = e.getShallow("position") || (n ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (i.position = r), s != null && (i.offset = s), a != null && (a *= Math.PI / 180, i.rotation = a), o != null && (i.distance = o), i.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (i.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (i.layoutRect = t.layoutRect), i;
}
function wI(e, t, n, i, r) {
  n = n || Oc;
  var a = t.ecModel, o = a && a.option.textStyle, s = SI(t), l;
  if (s) {
    l = {};
    var u = "richInheritPlainLabel", c = J(t.get(u), a ? a.get(u) : void 0);
    for (var h in s)
      if (s.hasOwnProperty(h)) {
        var d = t.getModel(["rich", h]);
        Ym(l[h] = {}, d, o, t, c, n, i, r, !1, !0);
      }
  }
  l && (e.rich = l);
  var f = t.get("overflow");
  f && (e.overflow = f);
  var v = t.get("lineOverflow");
  v && (e.lineOverflow = v);
  var g = e, p = t.get("minMargin");
  if (p != null)
    p = Xt(p) ? p / 2 : 0, g.margin = [p, p, p, p], g.__marginType = Ya.minMargin;
  else {
    var _ = t.get("textMargin");
    _ != null && (g.margin = bv(_), g.__marginType = Ya.textMargin);
  }
  Ym(e, t, o, null, null, n, i, r, !0, !1);
}
function SI(e) {
  for (var t; e && e !== e.ecModel; ) {
    var n = (e.option || Oc).rich;
    if (n) {
      t = t || {};
      for (var i = jt(n), r = 0; r < i.length; r++) {
        var a = i[r];
        t[a] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var Vm = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], $m = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], Hm = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function Ym(e, t, n, i, r, a, o, s, l, u) {
  n = !o && n || Oc;
  var c = a && a.inheritColor, h = t.getShallow("color"), d = t.getShallow("textBorderColor"), f = J(t.getShallow("opacity"), n.opacity);
  (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && he("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), (d === "inherit" || d === "auto") && (process.env.NODE_ENV !== "production" && d === "auto" && he("color: 'auto'", "color: 'inherit'"), c ? d = c : d = null), s || (h = h || n.color, d = d || n.textBorderColor), h != null && (e.fill = h), d != null && (e.stroke = d);
  var v = J(t.getShallow("textBorderWidth"), n.textBorderWidth);
  v != null && (e.lineWidth = v);
  var g = J(t.getShallow("textBorderType"), n.textBorderType);
  g != null && (e.lineDash = g);
  var p = J(t.getShallow("textBorderDashOffset"), n.textBorderDashOffset);
  p != null && (e.lineDashOffset = p), !o && f == null && !u && (f = a && a.defaultOpacity), f != null && (e.opacity = f), !o && !s && e.fill == null && a.inheritColor && (e.fill = a.inheritColor);
  for (var _ = 0; _ < Vm.length; _++) {
    var m = Vm[_], y = r !== !1 && i ? Zr(t.getShallow(m), i.getShallow(m), n[m]) : J(t.getShallow(m), n[m]);
    y != null && (e[m] = y);
  }
  for (var _ = 0; _ < $m.length; _++) {
    var m = $m[_], y = t.getShallow(m);
    y != null && (e[m] = y);
  }
  if (e.verticalAlign == null) {
    var b = t.getShallow("baseline");
    b != null && (e.verticalAlign = b);
  }
  if (!l || !a.disableBox) {
    for (var _ = 0; _ < Hm.length; _++) {
      var m = Hm[_], y = t.getShallow(m);
      y != null && (e[m] = y);
    }
    var x = t.getShallow("borderType");
    x != null && (e.borderDash = x), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && he("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = c), (e.borderColor === "auto" || e.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && he("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = c);
  }
}
function MI(e, t) {
  var n = t && t.getModel("textStyle");
  return Un([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || n && n.getShallow("fontStyle") || "",
    e.fontWeight || n && n.getShallow("fontWeight") || "",
    (e.fontSize || n && n.getShallow("fontSize") || 12) + "px",
    e.fontFamily || n && n.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var DI = Wt(), Ya = {
  minMargin: 1,
  textMargin: 2
}, TI = ["textStyle", "color"], Qh = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], Jh = new gn(), kI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var n = this.ecModel;
      return this.getShallow("color") || (!t && n ? n.get(TI) : null);
    }, e.prototype.getFont = function() {
      return MI({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var n = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, i = 0; i < Qh.length; i++)
        n[Qh[i]] = this.getShallow(Qh[i]);
      return Jh.useStyle(n), Jh.update(), Jh.getBoundingRect();
    }, e;
  })()
), fx = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], CI = Ls(fx), PI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return CI(this, t);
    }, e;
  })()
), vx = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], AI = Ls(vx), EI = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, n) {
      return AI(this, t, n);
    }, e;
  })()
), Gt = (
  /** @class */
  (function() {
    function e(t, n, i) {
      this.parentModel = n, this.ecModel = i, this.option = t;
    }
    return e.prototype.init = function(t, n, i) {
    }, e.prototype.mergeOption = function(t, n) {
      re(this.option, t, !0);
    }, e.prototype.get = function(t, n) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !n && this.parentModel);
    }, e.prototype.getShallow = function(t, n) {
      var i = this.option, r = i == null ? i : i[t];
      if (r == null && !n) {
        var a = this.parentModel;
        a && (r = a.getShallow(t));
      }
      return r;
    }, e.prototype.getModel = function(t, n) {
      var i = t != null, r = i ? this.parsePath(t) : null, a = i ? this._doGet(r) : this.option;
      return n = n || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new e(a, n, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(ft(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!tt.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, n) {
      var i = this.option;
      if (!t)
        return i;
      for (var r = 0; r < t.length && !(t[r] && (i = i && typeof i == "object" ? i[t[r]] : null, i == null)); r++)
        ;
      return i == null && n && (i = n._doGet(this.resolveParentPath(t), n.parentModel)), i;
    }, e;
  })()
);
kv(Gt);
uL(Gt);
An(Gt, PI);
An(Gt, EI);
An(Gt, vL);
An(Gt, kI);
var LI = Math.round(Math.random() * 10);
function Ic(e) {
  return [e || "", LI++].join("_");
}
function OI(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(n, i) {
    var r = Gn(n);
    t[r.main] = i;
  }, e.determineSubType = function(n, i) {
    var r = i.type;
    if (!r) {
      var a = Gn(n).main;
      e.hasSubTypes(n) && t[a] && (r = t[a](i));
    }
    return r;
  };
}
function II(e, t) {
  e.topologicalTravel = function(a, o, s, l) {
    if (!a.length)
      return;
    var u = n(o), c = u.graph, h = u.noEntryList, d = {};
    for (P(a, function(m) {
      d[m] = !0;
    }); h.length; ) {
      var f = h.pop(), v = c[f], g = !!d[f];
      g && (s.call(l, f, v.originalDeps.slice()), delete d[f]), P(v.successor, g ? _ : p);
    }
    P(d, function() {
      var m = "";
      throw process.env.NODE_ENV !== "production" && (m = Nu("Circular dependency may exists: ", d, a, o)), new Error(m);
    });
    function p(m) {
      c[m].entryCount--, c[m].entryCount === 0 && h.push(m);
    }
    function _(m) {
      d[m] = !0, p(m);
    }
  };
  function n(a) {
    var o = {}, s = [];
    return P(a, function(l) {
      var u = i(o, l), c = u.originalDeps = t(l), h = r(c, a);
      u.entryCount = h.length, u.entryCount === 0 && s.push(l), P(h, function(d) {
        zt(u.predecessor, d) < 0 && u.predecessor.push(d);
        var f = i(o, d);
        zt(f.successor, d) < 0 && f.successor.push(l);
      });
    }), {
      graph: o,
      noEntryList: s
    };
  }
  function i(a, o) {
    return a[o] || (a[o] = {
      predecessor: [],
      successor: []
    }), a[o];
  }
  function r(a, o) {
    var s = [];
    return P(a, function(l) {
      zt(o, l) >= 0 && s.push(l);
    }), s;
  }
}
const RI = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, NI = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var Hu = "ZH", Zv = "EN", Za = Zv, su = {}, Kv = {}, px = tt.domSupported ? (function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Za).toUpperCase()
  );
  return e.indexOf(Hu) > -1 ? Hu : Za;
})() : Za;
function gx(e, t) {
  e = e.toUpperCase(), Kv[e] = new Gt(t), su[e] = t;
}
function FI(e) {
  if (K(e)) {
    var t = su[e.toUpperCase()] || {};
    return e === Hu || e === Zv ? ft(t) : re(ft(t), ft(su[Za]), !1);
  } else
    return re(ft(e), ft(su[Za]), !1);
}
function BI(e) {
  return Kv[e];
}
function zI() {
  return Kv[Za];
}
gx(Zv, RI);
gx(Hu, NI);
function Ii(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function _x(e, t, n, i) {
  var r = Tc(e), a = r[VI(n)](), o = r[$I(n)]() + 1, s = Math.floor((o - 1) / 3) + 1, l = r[HI(n)](), u = r["get" + (n ? "UTC" : "") + "Day"](), c = r[YI(n)](), h = (c - 1) % 12 + 1, d = r[WI(n)](), f = r[UI(n)](), v = r[GI(n)](), g = c >= 12 ? "pm" : "am", p = g.toUpperCase(), _ = i instanceof Gt ? i : BI(px) || zI(), m = _.getModel("time"), y = m.get("month"), b = m.get("monthAbbr"), x = m.get("dayOfWeek"), w = m.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, g + "").replace(/{A}/g, p + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, Ii(a % 100 + "", 2)).replace(/{Q}/g, s + "").replace(/{MMMM}/g, y[o - 1]).replace(/{MMM}/g, b[o - 1]).replace(/{MM}/g, Ii(o, 2)).replace(/{M}/g, o + "").replace(/{dd}/g, Ii(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, x[u]).replace(/{ee}/g, w[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Ii(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Ii(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Ii(d, 2)).replace(/{m}/g, d + "").replace(/{ss}/g, Ii(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, Ii(v, 3)).replace(/{S}/g, v + "");
}
function VI(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function $I(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function HI(e) {
  return e ? "getUTCDate" : "getDate";
}
function YI(e) {
  return e ? "getUTCHours" : "getHours";
}
function WI(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function UI(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function GI(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function jI(e) {
  if (!b1(e))
    return K(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function mx(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(n, i) {
    return i.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var Qv = bv;
function wf(e, t, n) {
  var i = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function r(c) {
    return c && Un(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var o = t === "time", s = e instanceof Date;
  if (o || s) {
    var l = o ? Tc(e) : e;
    if (isNaN(+l)) {
      if (s)
        return "-";
    } else return _x(l, i, n);
  }
  if (t === "ordinal")
    return Mu(e) ? r(e) : Xt(e) && a(e) ? e + "" : "-";
  var u = Ru(e);
  return a(u) ? jI(u) : Mu(e) ? r(e) : typeof e == "boolean" ? e + "" : "-";
}
var Wm = ["a", "b", "c", "d", "e", "f", "g"], td = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function yx(e, t, n) {
  U(t) || (t = [t]);
  var i = t.length;
  if (!i)
    return "";
  for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
    var o = Wm[a];
    e = e.replace(td(o), td(o, 0));
  }
  for (var s = 0; s < i; s++)
    for (var l = 0; l < r.length; l++) {
      var u = t[s][r[l]];
      e = e.replace(td(Wm[l], s), n ? Be(u) : u);
    }
  return e;
}
function XI(e, t) {
  var n = K(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, i = n.color, r = n.type;
  t = n.extraCssText;
  var a = n.renderMode || "html";
  if (!i)
    return "";
  if (a === "html")
    return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Be(i) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Be(i) + ";" + (t || "") + '"></span>';
  var o = n.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + o + "|}  ",
    style: r === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: i
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: i
    }
  };
}
function Rs(e, t) {
  return t = t || "transparent", K(e) ? e : X(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function Um(e, t) {
  if (t === "_blank" || t === "blank") {
    var n = window.open();
    n.opener = null, n.location.href = e;
  } else
    window.open(e, t);
}
var ed = {}, nd = {}, Rc = (
  /** @class */
  (function() {
    function e() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return e.prototype.create = function(t, n) {
      this._nonSeriesBoxMasterList = i(ed, !0), this._normalMasterList = i(nd, !1);
      function i(r, a) {
        var o = [];
        return P(r, function(s, l) {
          var u = s.create(t, n);
          o = o.concat(u || []), process.env.NODE_ENV !== "production" && a && P(u, function(c) {
            return Q(!c.update);
          });
        }), o;
      }
    }, e.prototype.update = function(t, n) {
      P(this._normalMasterList, function(i) {
        i.update && i.update(t, n);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, e.register = function(t, n) {
      if (t === "matrix" || t === "calendar") {
        ed[t] = n;
        return;
      }
      nd[t] = n;
    }, e.get = function(t) {
      return nd[t] || ed[t];
    }, e;
  })()
), Gm = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
}, qI = st();
function ZI(e) {
  var t = e.getShallow("coord", !0), n = Gm.coord;
  if (t == null) {
    var i = qI.get(e.type);
    i && i.getCoord2 && (n = Gm.coord2, t = i.getCoord2(e));
  }
  return {
    coord: t,
    from: n
  };
}
var lu = P, KI = ["left", "right", "top", "bottom", "width", "height"], Rl = [["width", "left", "right"], ["height", "top", "bottom"]];
function bx(e, t, n, i, r) {
  var a = 0, o = 0;
  i == null && (i = 1 / 0), r == null && (r = 1 / 0);
  var s = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = t.childAt(u + 1), d = h && h.getBoundingRect(), f, v;
    if (e === "horizontal") {
      var g = c.width + (d ? -d.x + c.x : 0);
      f = a + g, f > i || l.newline ? (a = 0, f = g, o += s + n, s = c.height) : s = Math.max(s, c.height);
    } else {
      var p = c.height + (d ? -d.y + c.y : 0);
      v = o + p, v > r || l.newline ? (a += s + n, o = 0, v = p, s = c.width) : s = Math.max(s, c.width);
    }
    l.newline || (l.x = a, l.y = o, l.markRedraw(), e === "horizontal" ? a = f + n : o = v + n);
  });
}
Pe(bx, "vertical");
Pe(bx, "horizontal");
function QI(e, t) {
  return {
    left: e.getShallow("left", t),
    top: e.getShallow("top", t),
    right: e.getShallow("right", t),
    bottom: e.getShallow("bottom", t),
    width: e.getShallow("width", t),
    height: e.getShallow("height", t)
  };
}
function Jv(e, t, n) {
  n = Qv(n || 0);
  var i = t.width, r = t.height, a = Ve(e.left, i), o = Ve(e.top, r), s = Ve(e.right, i), l = Ve(e.bottom, r), u = Ve(e.width, i), c = Ve(e.height, r), h = n[2] + n[0], d = n[1] + n[3], f = e.aspect;
  switch (isNaN(u) && (u = i - s - d - a), isNaN(c) && (c = r - l - h - o), f != null && (isNaN(u) && isNaN(c) && (f > i / r ? u = i * 0.8 : c = r * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(a) && (a = i - s - u - d), isNaN(o) && (o = r - l - c - h), e.left || e.right) {
    case "center":
      a = i / 2 - u / 2 - n[3];
      break;
    case "right":
      a = i - u - d;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      o = r / 2 - c / 2 - n[0];
      break;
    case "bottom":
      o = r - c - h;
      break;
  }
  a = a || 0, o = o || 0, isNaN(u) && (u = i - d - a - (s || 0)), isNaN(c) && (c = r - h - o - (l || 0));
  var v = new it((t.x || 0) + a + n[3], (t.y || 0) + o + n[0], u, c);
  return v.margin = n, v;
}
var id = {
  rect: 1
};
function xx(e, t, n) {
  var i, r, a, o = e.boxCoordinateSystem, s;
  if (o) {
    var l = ZI(e), u = l.coord, c = l.from;
    if (o.dataToLayout) {
      a = id.rect, s = c;
      var h = o.dataToLayout(u);
      i = h.contentRect || h.rect;
    } else
      process.env.NODE_ENV !== "production" && qt(e.type + "[" + e.componentIndex + "]" + (" layout based on " + o.type + " is not supported."));
  }
  return a == null && (a = id.rect), a === id.rect && (i || (i = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), r = [i.x + i.width / 2, i.y + i.height / 2]), {
    type: a,
    refContainer: i,
    refPoint: r,
    boxCoordFrom: s
  };
}
function Yu(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return X(t) ? t : t ? {
    type: t
  } : null;
}
function Wu(e, t, n) {
  var i = n && n.ignoreSize;
  !U(i) && (i = [i, i]);
  var r = o(Rl[0], 0), a = o(Rl[1], 1);
  l(Rl[0], e, r), l(Rl[1], e, a);
  function o(u, c) {
    var h = {}, d = 0, f = {}, v = 0, g = 2;
    if (lu(u, function(m) {
      f[m] = e[m];
    }), lu(u, function(m) {
      Xn(t, m) && (h[m] = f[m] = t[m]), s(h, m) && d++, s(f, m) && v++;
    }), i[c])
      return s(t, u[1]) ? f[u[2]] = null : s(t, u[2]) && (f[u[1]] = null), f;
    if (v === g || !d)
      return f;
    if (d >= g)
      return h;
    for (var p = 0; p < u.length; p++) {
      var _ = u[p];
      if (!Xn(h, _) && Xn(e, _)) {
        h[_] = e[_];
        break;
      }
    }
    return h;
  }
  function s(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, h) {
    lu(u, function(d) {
      c[d] = h[d];
    });
  }
}
function Sx(e) {
  return JI({}, e);
}
function JI(e, t) {
  return t && e && lu(KI, function(n) {
    Xn(t, n) && (e[n] = t[n]);
  }), e;
}
var t5 = Wt(), Pt = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(n, i, r) {
      var a = e.call(this, n, i, r) || this;
      return a.uid = Ic("ec_cpt_model"), a;
    }
    return t.prototype.init = function(n, i, r) {
      this.mergeDefaultAndTheme(n, r);
    }, t.prototype.mergeDefaultAndTheme = function(n, i) {
      var r = Yu(this), a = r ? Sx(n) : {}, o = i.getTheme();
      re(n, o.get(this.mainType)), re(n, this.getDefaultOption()), r && Wu(n, a, r);
    }, t.prototype.mergeOption = function(n, i) {
      re(this.option, n, !0);
      var r = Yu(this);
      r && Wu(this.option, n, r);
    }, t.prototype.optionUpdated = function(n, i) {
    }, t.prototype.getDefaultOption = function() {
      var n = this.constructor;
      if (!oL(n))
        return n.defaultOption;
      var i = t5(this);
      if (!i.defaultOption) {
        for (var r = [], a = n; a; ) {
          var o = a.prototype.defaultOption;
          o && r.push(o), a = a.superClass;
        }
        for (var s = {}, l = r.length - 1; l >= 0; l--)
          s = re(s, r[l], !0);
        i.defaultOption = s;
      }
      return i.defaultOption;
    }, t.prototype.getReferringComponents = function(n, i) {
      var r = n + "Index", a = n + "Id";
      return qs(this.ecModel, n, {
        index: this.get(r, !0),
        id: this.get(a, !0)
      }, i);
    }, t.prototype.getBoxLayoutParams = function() {
      return QI(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(n) {
      this.option.zlevel = n;
    }, t.protoInitialize = (function() {
      var n = t.prototype;
      n.type = "component", n.id = "", n.name = "", n.mainType = "", n.subType = "", n.componentIndex = 0;
    })(), t;
  })(Gt)
);
C1(Pt, Gt);
Cv(Pt);
OI(Pt);
II(Pt, e5);
function e5(e) {
  var t = [];
  return P(Pt.getClassesByMainType(e), function(n) {
    t = t.concat(n.dependencies || n.prototype.dependencies || []);
  }), t = yt(t, function(n) {
    return Gn(n).main;
  }), e !== "dataset" && zt(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var St = {
  color: {},
  darkColor: {},
  size: {}
}, Zt = St.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
$(Zt, {
  primary: Zt.neutral80,
  secondary: Zt.neutral70,
  tertiary: Zt.neutral60,
  quaternary: Zt.neutral50,
  disabled: Zt.neutral20,
  border: Zt.neutral30,
  borderTint: Zt.neutral20,
  borderShade: Zt.neutral40,
  background: Zt.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: Zt.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: Zt.neutral70,
  axisLineTint: Zt.neutral40,
  axisTick: Zt.neutral70,
  axisTickMinor: Zt.neutral60,
  axisLabel: Zt.neutral70,
  axisSplitLine: Zt.neutral15,
  axisMinorSplitLine: Zt.neutral05
});
for (var kr in Zt)
  if (Zt.hasOwnProperty(kr)) {
    var jm = Zt[kr];
    kr === "theme" ? St.darkColor.theme = Zt.theme.slice() : kr === "highlight" ? St.darkColor.highlight = "rgba(255,231,130,0.4)" : kr.indexOf("accent") === 0 ? St.darkColor[kr] = qa(jm, null, function(e) {
      return e * 0.5;
    }, function(e) {
      return Math.min(1, 1.3 - e);
    }) : St.darkColor[kr] = qa(jm, null, function(e) {
      return e * 0.9;
    }, function(e) {
      return 1 - Math.pow(e, 1.5);
    });
  }
St.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var Mx = "";
typeof navigator < "u" && (Mx = navigator.platform || "");
var Da = "rgba(0, 0, 0, 0.2)", Dx = St.color.theme[0], n5 = qa(Dx, null, null, 0.9);
const i5 = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: St.color.theme,
  gradientColor: [n5, Dx],
  aria: {
    decal: {
      decals: [{
        color: Da,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Da,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Da,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Da,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Da,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Da,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: Mx.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Sf = st(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), Qe = "original", Se = "arrayRows", On = "objectRows", ti = "keyedColumns", xi = "typedArray", Tx = "unknown", Qn = "column", ca = "row", Ge = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, kx = Wt();
function r5(e) {
  kx(e).datasetMap = st();
}
function a5(e, t, n) {
  var i = {}, r = Cx(t);
  if (!r || !e)
    return i;
  var a = [], o = [], s = t.ecModel, l = kx(s).datasetMap, u = r.uid + "_" + n.seriesLayoutBy, c, h;
  e = e.slice(), P(e, function(g, p) {
    var _ = X(g) ? g : e[p] = {
      name: g
    };
    _.type === "ordinal" && c == null && (c = p, h = v(_)), i[_.name] = [];
  });
  var d = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  P(e, function(g, p) {
    var _ = g.name, m = v(g);
    if (c == null) {
      var y = d.valueWayDim;
      f(i[_], y, m), f(o, y, m), d.valueWayDim += m;
    } else if (c === p)
      f(i[_], 0, m), f(a, 0, m);
    else {
      var y = d.categoryWayDim;
      f(i[_], y, m), f(o, y, m), d.categoryWayDim += m;
    }
  });
  function f(g, p, _) {
    for (var m = 0; m < _; m++)
      g.push(p + m);
  }
  function v(g) {
    var p = g.dimsDef;
    return p ? p.length : 1;
  }
  return a.length && (i.itemName = a), o.length && (i.seriesName = o), i;
}
function Cx(e) {
  var t = e.get("data", !0);
  if (!t)
    return qs(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, zi).models[0];
}
function o5(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : qs(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, zi).models;
}
function Px(e, t) {
  return s5(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function s5(e, t, n, i, r, a) {
  var o, s = 5;
  if (Le(e))
    return Ge.Not;
  var l, u;
  if (i) {
    var c = i[a];
    X(c) ? (l = c.name, u = c.type) : K(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? Ge.Must : Ge.Not;
  if (t === Se) {
    var h = e;
    if (n === ca) {
      for (var d = h[a], f = 0; f < (d || []).length && f < s; f++)
        if ((o = b(d[r + f])) != null)
          return o;
    } else
      for (var f = 0; f < h.length && f < s; f++) {
        var v = h[r + f];
        if (v && (o = b(v[a])) != null)
          return o;
      }
  } else if (t === On) {
    var g = e;
    if (!l)
      return Ge.Not;
    for (var f = 0; f < g.length && f < s; f++) {
      var p = g[f];
      if (p && (o = b(p[l])) != null)
        return o;
    }
  } else if (t === ti) {
    var _ = e;
    if (!l)
      return Ge.Not;
    var d = _[l];
    if (!d || Le(d))
      return Ge.Not;
    for (var f = 0; f < d.length && f < s; f++)
      if ((o = b(d[f])) != null)
        return o;
  } else if (t === Qe)
    for (var m = e, f = 0; f < m.length && f < s; f++) {
      var p = m[f], y = js(p);
      if (!U(y))
        return Ge.Not;
      if ((o = b(y[a])) != null)
        return o;
    }
  function b(x) {
    var w = K(x);
    if (x != null && Number.isFinite(Number(x)) && x !== "")
      return w ? Ge.Might : Ge.Not;
    if (w && x !== "-")
      return Ge.Must;
  }
  return Ge.Not;
}
var l5 = st();
function u5(e, t, n) {
  var i = l5.get(t);
  if (!i)
    return n;
  var r = i(e);
  if (!r)
    return n;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < r.length; a++)
      Q(ao(r[a]));
  return n.concat(r);
}
var Xm = Wt();
Wt();
var tp = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, n, i) {
      var r = Ae(this.get("color", !0)), a = this.get("colorLayer", !0);
      return h5(this, Xm, r, a, t, n, i);
    }, e.prototype.clearColorPalette = function() {
      d5(this, Xm);
    }, e;
  })()
);
function c5(e, t) {
  for (var n = e.length, i = 0; i < n; i++)
    if (e[i].length > t)
      return e[i];
  return e[n - 1];
}
function h5(e, t, n, i, r, a, o) {
  a = a || e;
  var s = t(a), l = s.paletteIdx || 0, u = s.paletteNameMap = s.paletteNameMap || {};
  if (u.hasOwnProperty(r))
    return u[r];
  var c = o == null || !i ? n : c5(i, o);
  if (c = c || n, !(!c || !c.length)) {
    var h = c[l];
    return r && (u[r] = h), s.paletteIdx = (l + 1) % c.length, h;
  }
}
function d5(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var Nl, Ao, qm, rd = "\0_ec_inner", Zm = 1, f5 = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, v5 = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, Uu = {};
function p5(e) {
  P(e, function(t, n) {
    if (!Pt.hasClass(n)) {
      var i = f5[n];
      i && !Uu[i] && (qt("Component " + n + ` is used but not imported.
import { ` + i + ` } from 'echarts/components';
echarts.use([` + i + "]);"), Uu[i] = !0);
    }
  });
}
var ep = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(n, i, r, a, o, s) {
      a = a || {}, this.option = null, this._theme = new Gt(a), this._locale = new Gt(o), this._optionManager = s;
    }, t.prototype.setOption = function(n, i, r) {
      process.env.NODE_ENV !== "production" && (Q(n != null, "option is null/undefined"), Q(n[rd] !== Zm, "please use chart.getOption()"));
      var a = Jm(i);
      this._optionManager.setOption(n, r, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(n, i) {
      return this._resetOption(n, Jm(i));
    }, t.prototype._resetOption = function(n, i) {
      var r = !1, a = this._optionManager;
      if (!n || n === "recreate") {
        var o = a.mountOption(n === "recreate");
        process.env.NODE_ENV !== "production" && p5(o), !this.option || n === "recreate" ? qm(this, o) : (this.restoreData(), this._mergeOption(o, i)), r = !0;
      }
      if ((n === "timeline" || n === "media") && this.restoreData(), !n || n === "recreate" || n === "timeline") {
        var s = a.getTimelineOption(this);
        s && (r = !0, this._mergeOption(s, i));
      }
      if (!n || n === "recreate" || n === "media") {
        var l = a.getMediaOption(this);
        l.length && P(l, function(u) {
          r = !0, this._mergeOption(u, i);
        }, this);
      }
      return r;
    }, t.prototype.mergeOption = function(n) {
      this._mergeOption(n, null);
    }, t.prototype._mergeOption = function(n, i) {
      var r = this.option, a = this._componentsMap, o = this._componentsCount, s = [], l = st(), u = i && i.replaceMergeMainTypeMap;
      r5(this), P(n, function(h, d) {
        h != null && (Pt.hasClass(d) ? d && (s.push(d), l.set(d, !0)) : r[d] = r[d] == null ? ft(h) : re(r[d], h, !0));
      }), u && u.each(function(h, d) {
        Pt.hasClass(d) && !l.get(d) && (s.push(d), l.set(d, !0));
      }), Pt.topologicalTravel(s, Pt.getAllClassMainTypes(), c, this);
      function c(h) {
        var d = u5(this, h, Ae(n[h])), f = a.get(h), v = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          f ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), g = UE(f, d, v);
        QE(g, h, Pt), r[h] = null, a.set(h, null), o.set(h, 0);
        var p = [], _ = [], m = 0, y, b;
        P(g, function(x, w) {
          var M = x.existing, D = x.newOption;
          if (!D)
            M && (M.mergeOption({}, this), M.optionUpdated({}, !1));
          else {
            var T = h === "series", C = Pt.getClass(
              h,
              x.keyInfo.subType,
              !T
              // Give a more detailed warn later if series don't exists
            );
            if (!C) {
              if (process.env.NODE_ENV !== "production") {
                var k = x.keyInfo.subType, E = v5[k];
                Uu[k] || (Uu[k] = !0, qt(E ? "Series " + k + ` is used but not imported.
import { ` + E + ` } from 'echarts/charts';
echarts.use([` + E + "]);" : "Unknown series " + k));
              }
              return;
            }
            if (h === "tooltip") {
              if (y) {
                process.env.NODE_ENV !== "production" && (b || (un("Currently only one tooltip component is allowed."), b = !0));
                return;
              }
              y = !0;
            }
            if (M && M.constructor === C)
              M.name = x.keyInfo.name, M.mergeOption(D, this), M.optionUpdated(D, !1);
            else {
              var A = $({
                componentIndex: w
              }, x.keyInfo);
              M = new C(D, this, this, A), $(M, A), x.brandNew && (M.__requireNewView = !0), M.init(D, this, this), M.optionUpdated(null, !0);
            }
          }
          M ? (p.push(M.option), _.push(M), m++) : (p.push(void 0), _.push(void 0));
        }, this), r[h] = p, a.set(h, _), o.set(h, m), h === "series" && Nl(this);
      }
      this._seriesIndices || Nl(this);
    }, t.prototype.getOption = function() {
      var n = ft(this.option);
      return P(n, function(i, r) {
        if (Pt.hasClass(r)) {
          for (var a = Ae(i), o = a.length, s = !1, l = o - 1; l >= 0; l--)
            a[l] && !ao(a[l]) ? s = !0 : (a[l] = null, !s && o--);
          a.length = o, n[r] = a;
        }
      }), delete n[rd], n;
    }, t.prototype.setTheme = function(n) {
      this._theme = new Gt(n), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(n) {
      this._payload = n;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(n, i) {
      var r = this._componentsMap.get(n);
      if (r) {
        var a = r[i || 0];
        if (a)
          return a;
        if (i == null) {
          for (var o = 0; o < r.length; o++)
            if (r[o])
              return r[o];
        }
      }
    }, t.prototype.queryComponents = function(n) {
      var i = n.mainType;
      if (!i)
        return [];
      var r = n.index, a = n.id, o = n.name, s = this._componentsMap.get(i);
      if (!s || !s.length)
        return [];
      var l;
      return r != null ? (l = [], P(Ae(r), function(u) {
        s[u] && l.push(s[u]);
      })) : a != null ? l = Km("id", a, s) : o != null ? l = Km("name", o, s) : l = qe(s, function(u) {
        return !!u;
      }), Qm(l, n);
    }, t.prototype.findComponents = function(n) {
      var i = n.query, r = n.mainType, a = s(i), o = a ? this.queryComponents(a) : qe(this._componentsMap.get(r), function(u) {
        return !!u;
      });
      return l(Qm(o, n));
      function s(u) {
        var c = r + "Index", h = r + "Id", d = r + "Name";
        return u && (u[c] != null || u[h] != null || u[d] != null) ? {
          mainType: r,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[d]
        } : null;
      }
      function l(u) {
        return n.filter ? qe(u, n.filter) : u;
      }
    }, t.prototype.eachComponent = function(n, i, r) {
      var a = this._componentsMap;
      if (gt(n)) {
        var o = i, s = n;
        a.each(function(h, d) {
          for (var f = 0; h && f < h.length; f++) {
            var v = h[f];
            v && s.call(o, d, v, v.componentIndex);
          }
        });
      } else
        for (var l = K(n) ? a.get(n) : X(n) ? this.findComponents(n) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && i.call(r, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(n) {
      var i = Mn(n, null);
      return qe(this._componentsMap.get("series"), function(r) {
        return !!r && i != null && r.name === i;
      });
    }, t.prototype.getSeriesByIndex = function(n) {
      return this._componentsMap.get("series")[n];
    }, t.prototype.getSeriesByType = function(n) {
      return qe(this._componentsMap.get("series"), function(i) {
        return !!i && i.subType === n;
      });
    }, t.prototype.getSeries = function() {
      return qe(this._componentsMap.get("series"), function(n) {
        return !!n;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(n, i) {
      Ao(this), P(this._seriesIndices, function(r) {
        var a = this._componentsMap.get("series")[r];
        n.call(i, a, r);
      }, this);
    }, t.prototype.eachRawSeries = function(n, i) {
      P(this._componentsMap.get("series"), function(r) {
        r && n.call(i, r, r.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(n, i, r) {
      Ao(this), P(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        o.subType === n && i.call(r, o, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(n, i, r) {
      return P(this.getSeriesByType(n), i, r);
    }, t.prototype.isSeriesFiltered = function(n) {
      return Ao(this), this._seriesIndicesMap.get(n.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(n, i) {
      Ao(this);
      var r = [];
      P(this._seriesIndices, function(a) {
        var o = this._componentsMap.get("series")[a];
        n.call(i, o, a) && r.push(a);
      }, this), this._seriesIndices = r, this._seriesIndicesMap = st(r);
    }, t.prototype.restoreData = function(n) {
      Nl(this);
      var i = this._componentsMap, r = [];
      i.each(function(a, o) {
        Pt.hasClass(o) && r.push(o);
      }), Pt.topologicalTravel(r, Pt.getAllClassMainTypes(), function(a) {
        P(i.get(a), function(o) {
          o && (a !== "series" || !g5(o, n)) && o.restoreData();
        });
      });
    }, t.internalField = (function() {
      Nl = function(n) {
        var i = n._seriesIndices = [];
        P(n._componentsMap.get("series"), function(r) {
          r && i.push(r.componentIndex);
        }), n._seriesIndicesMap = st(i);
      }, Ao = function(n) {
        if (process.env.NODE_ENV !== "production" && !n._seriesIndices)
          throw new Error("Option should contains series.");
      }, qm = function(n, i) {
        n.option = {}, n.option[rd] = Zm, n._componentsMap = st({
          series: []
        }), n._componentsCount = st();
        var r = i.aria;
        X(r) && r.enabled == null && (r.enabled = !0), _5(i, n._theme.option), re(i, i5, !1), n._mergeOption(i, null);
      };
    })(), t;
  })(Gt)
);
function g5(e, t) {
  if (t) {
    var n = t.seriesIndex, i = t.seriesId, r = t.seriesName;
    return n != null && e.componentIndex !== n || i != null && e.id !== i || r != null && e.name !== r;
  }
}
function _5(e, t) {
  var n = e.color && !e.colorLayer;
  P(t, function(i, r) {
    r === "colorLayer" && n || r === "color" && e.color || Pt.hasClass(r) || (typeof i == "object" ? e[r] = e[r] ? re(e[r], i, !1) : ft(i) : e[r] == null && (e[r] = i));
  });
}
function Km(e, t, n) {
  if (U(t)) {
    var i = st();
    return P(t, function(a) {
      if (a != null) {
        var o = Mn(a, null);
        o != null && i.set(a, !0);
      }
    }), qe(n, function(a) {
      return a && i.get(a[e]);
    });
  } else {
    var r = Mn(t, null);
    return qe(n, function(a) {
      return a && r != null && a[e] === r;
    });
  }
}
function Qm(e, t) {
  return t.hasOwnProperty("subType") ? qe(e, function(n) {
    return n && n.subType === t.subType;
  }) : e;
}
function Jm(e) {
  var t = st();
  return e && P(Ae(e.replaceMerge), function(n) {
    process.env.NODE_ENV !== "production" && Q(Pt.hasClass(n), '"' + n + '" is not valid component main type in "replaceMerge"'), t.set(n, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
An(ep, tp);
var m5 = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], Ax = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      P(m5, function(n) {
        this[n] = Tt(t[n], t);
      }, this);
    }
    return e;
  })()
), y5 = /^(min|max)?(.+)$/, b5 = (
  /** @class */
  (function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, n, i) {
      t && (P(Ae(t.series), function(o) {
        o && o.data && Le(o.data) && Yd(o.data);
      }), P(Ae(t.dataset), function(o) {
        o && o.source && Le(o.source) && Yd(o.source);
      })), t = ft(t);
      var r = this._optionBackup, a = x5(t, n, !r);
      this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, e.prototype.mountOption = function(t) {
      var n = this._optionBackup;
      return this._timelineOptions = n.timelineOptions, this._mediaList = n.mediaList, this._mediaDefault = n.mediaDefault, this._currentMediaIndices = [], ft(t ? n.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var n, i = this._timelineOptions;
      if (i.length) {
        var r = t.getComponent("timeline");
        r && (n = ft(
          // FIXME:TS as TimelineModel or quivlant interface
          i[r.getCurrentIndex()]
        ));
      }
      return n;
    }, e.prototype.getMediaOption = function(t) {
      var n = this._api.getWidth(), i = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, o = [], s = [];
      if (!r.length && !a)
        return s;
      for (var l = 0, u = r.length; l < u; l++)
        w5(r[l].query, n, i) && o.push(l);
      return !o.length && a && (o = [-1]), o.length && !M5(o, this._currentMediaIndices) && (s = yt(o, function(c) {
        return ft(c === -1 ? a.option : r[c].option);
      })), this._currentMediaIndices = o, s;
    }, e;
  })()
);
function x5(e, t, n) {
  var i = [], r, a, o = e.baseOption, s = e.timeline, l = e.options, u = e.media, c = !!e.media, h = !!(l || s || o && o.timeline);
  o ? (a = o, a.timeline || (a.timeline = s)) : ((h || c) && (e.options = e.media = null), a = e), c && (U(u) ? P(u, function(f) {
    process.env.NODE_ENV !== "production" && f && !f.option && X(f.query) && X(f.query.option) && qt("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), f && f.option && (f.query ? i.push(f) : r || (r = f));
  }) : process.env.NODE_ENV !== "production" && qt("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), d(a), P(l, function(f) {
    return d(f);
  }), P(i, function(f) {
    return d(f.option);
  });
  function d(f) {
    P(t, function(v) {
      v(f, n);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: r,
    mediaList: i
  };
}
function w5(e, t, n) {
  var i = {
    width: t,
    height: n,
    aspectratio: t / n
    // lower case for convenience.
  }, r = !0;
  return P(e, function(a, o) {
    var s = o.match(y5);
    if (!(!s || !s[1] || !s[2])) {
      var l = s[1], u = s[2].toLowerCase();
      S5(i[u], a, l) || (r = !1);
    }
  }), r;
}
function S5(e, t, n) {
  return n === "min" ? e >= t : n === "max" ? e <= t : e === t;
}
function M5(e, t) {
  return e.join(",") === t.join(",");
}
var en = P, Ns = X, t0 = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function ad(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var n = 0, i = t0.length; n < i; n++) {
      var r = t0[n], a = t.normal, o = t.emphasis;
      a && a[r] && (process.env.NODE_ENV !== "production" && he("itemStyle.normal." + r, r), e[r] = e[r] || {}, e[r].normal ? re(e[r].normal, a[r]) : e[r].normal = a[r], a[r] = null), o && o[r] && (process.env.NODE_ENV !== "production" && he("itemStyle.emphasis." + r, "emphasis." + r), e[r] = e[r] || {}, e[r].emphasis ? re(e[r].emphasis, o[r]) : e[r].emphasis = o[r], o[r] = null);
    }
}
function ge(e, t, n) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var i = e[t].normal, r = e[t].emphasis;
    i && (process.env.NODE_ENV !== "production" && Di("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), n ? (e[t].normal = e[t].emphasis = null, Qt(e[t], i)) : e[t] = i), r && (process.env.NODE_ENV !== "production" && Di(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = r, r.focus && (e.emphasis.focus = r.focus), r.blurScope && (e.emphasis.blurScope = r.blurScope));
  }
}
function ns(e) {
  ge(e, "itemStyle"), ge(e, "lineStyle"), ge(e, "areaStyle"), ge(e, "label"), ge(e, "labelLine"), ge(e, "upperLabel"), ge(e, "edgeLabel");
}
function te(e, t) {
  var n = Ns(e) && e[t], i = Ns(n) && n.textStyle;
  if (i) {
    process.env.NODE_ENV !== "production" && Di("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var r = 0, a = X_.length; r < a; r++) {
      var o = X_[r];
      i.hasOwnProperty(o) && (n[o] = i[o]);
    }
  }
}
function on(e) {
  e && (ns(e), te(e, "label"), e.emphasis && te(e.emphasis, "label"));
}
function D5(e) {
  if (Ns(e)) {
    ad(e), ns(e), te(e, "label"), te(e, "upperLabel"), te(e, "edgeLabel"), e.emphasis && (te(e.emphasis, "label"), te(e.emphasis, "upperLabel"), te(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (ad(t), on(t));
    var n = e.markLine;
    n && (ad(n), on(n));
    var i = e.markArea;
    i && on(i);
    var r = e.data;
    if (e.type === "graph") {
      r = r || e.nodes;
      var a = e.links || e.edges;
      if (a && !Le(a))
        for (var o = 0; o < a.length; o++)
          on(a[o]);
      P(e.categories, function(u) {
        ns(u);
      });
    }
    if (r && !Le(r))
      for (var o = 0; o < r.length; o++)
        on(r[o]);
    if (t = e.markPoint, t && t.data)
      for (var s = t.data, o = 0; o < s.length; o++)
        on(s[o]);
    if (n = e.markLine, n && n.data)
      for (var l = n.data, o = 0; o < l.length; o++)
        U(l[o]) ? (on(l[o][0]), on(l[o][1])) : on(l[o]);
    e.type === "gauge" ? (te(e, "axisLabel"), te(e, "title"), te(e, "detail")) : e.type === "treemap" ? (ge(e.breadcrumb, "itemStyle"), P(e.levels, function(u) {
      ns(u);
    })) : e.type === "tree" && ns(e.leaves);
  }
}
function ai(e) {
  return U(e) ? e : e ? [e] : [];
}
function e0(e) {
  return (U(e) ? e[0] : e) || {};
}
function T5(e, t) {
  en(ai(e.series), function(i) {
    Ns(i) && D5(i);
  });
  var n = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && n.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), en(n, function(i) {
    en(ai(e[i]), function(r) {
      r && (te(r, "axisLabel"), te(r.axisPointer, "label"));
    });
  }), en(ai(e.parallel), function(i) {
    var r = i && i.parallelAxisDefault;
    te(r, "axisLabel"), te(r && r.axisPointer, "label");
  }), en(ai(e.calendar), function(i) {
    ge(i, "itemStyle"), te(i, "dayLabel"), te(i, "monthLabel"), te(i, "yearLabel");
  }), en(ai(e.radar), function(i) {
    te(i, "name"), i.name && i.axisName == null && (i.axisName = i.name, delete i.name, process.env.NODE_ENV !== "production" && Di("name property in radar component has been changed to axisName")), i.nameGap != null && i.axisNameGap == null && (i.axisNameGap = i.nameGap, delete i.nameGap, process.env.NODE_ENV !== "production" && Di("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && en(i.indicator, function(r) {
      r.text && he("text", "name", "radar.indicator");
    });
  }), en(ai(e.geo), function(i) {
    Ns(i) && (on(i), en(ai(i.regions), function(r) {
      on(r);
    }));
  }), en(ai(e.timeline), function(i) {
    on(i), ge(i, "label"), ge(i, "itemStyle"), ge(i, "controlStyle", !0);
    var r = i.data;
    U(r) && P(r, function(a) {
      X(a) && (ge(a, "label"), ge(a, "itemStyle"));
    });
  }), en(ai(e.toolbox), function(i) {
    ge(i, "iconStyle"), en(i.feature, function(r) {
      ge(r, "iconStyle");
    });
  }), te(e0(e.axisPointer), "label"), te(e0(e.tooltip).axisPointer, "label");
}
function k5(e, t) {
  for (var n = t.split(","), i = e, r = 0; r < n.length && (i = i && i[n[r]], i != null); r++)
    ;
  return i;
}
function C5(e, t, n, i) {
  for (var r = t.split(","), a = e, o, s = 0; s < r.length - 1; s++)
    o = r[s], a[o] == null && (a[o] = {}), a = a[o];
  a[r[s]] == null && (a[r[s]] = n);
}
function n0(e) {
  e && P(P5, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var P5 = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], A5 = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], od = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Eo(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var n = 0; n < od.length; n++) {
      var i = od[n][1], r = od[n][0];
      t[i] != null && (t[r] = t[i], process.env.NODE_ENV !== "production" && he(i, r));
    }
}
function i0(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && he("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function r0(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && he("downplay", "blur", "sunburst"));
}
function E5(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && he("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function Ex(e, t) {
  if (e)
    for (var n = 0; n < e.length; n++)
      t(e[n]), e[n] && Ex(e[n].children, t);
}
function Lx(e, t) {
  T5(e, t), e.series = Ae(e.series), P(e.series, function(n) {
    if (X(n)) {
      var i = n.type;
      if (i === "line")
        n.clipOverflow != null && (n.clip = n.clipOverflow, process.env.NODE_ENV !== "production" && he("clipOverflow", "clip", "line"));
      else if (i === "pie" || i === "gauge") {
        n.clockWise != null && (n.clockwise = n.clockWise, process.env.NODE_ENV !== "production" && he("clockWise", "clockwise")), i0(n.label);
        var r = n.data;
        if (r && !Le(r))
          for (var a = 0; a < r.length; a++)
            i0(r[a]);
        n.hoverOffset != null && (n.emphasis = n.emphasis || {}, (n.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && he("hoverOffset", "emphasis.scaleSize"), n.emphasis.scaleSize = n.hoverOffset));
      } else if (i === "gauge") {
        var o = k5(n, "pointer.color");
        o != null && C5(n, "itemStyle.color", o);
      } else if (i === "bar") {
        Eo(n), Eo(n.backgroundStyle), Eo(n.emphasis);
        var r = n.data;
        if (r && !Le(r))
          for (var a = 0; a < r.length; a++)
            typeof r[a] == "object" && (Eo(r[a]), Eo(r[a] && r[a].emphasis));
      } else if (i === "sunburst") {
        var s = n.highlightPolicy;
        s && (n.emphasis = n.emphasis || {}, n.emphasis.focus || (n.emphasis.focus = s, process.env.NODE_ENV !== "production" && he("highlightPolicy", "emphasis.focus", "sunburst"))), r0(n), Ex(n.data, r0);
      } else i === "graph" || i === "sankey" ? E5(n) : i === "map" && (n.mapType && !n.map && (process.env.NODE_ENV !== "production" && he("mapType", "map", "map"), n.map = n.mapType), n.mapLocation && (process.env.NODE_ENV !== "production" && Di("`mapLocation` is not used anymore."), Qt(n, n.mapLocation)));
      n.hoverAnimation != null && (n.emphasis = n.emphasis || {}, n.emphasis && n.emphasis.scale == null && (process.env.NODE_ENV !== "production" && he("hoverAnimation", "emphasis.scale"), n.emphasis.scale = n.hoverAnimation)), n0(n);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), P(A5, function(n) {
    var i = e[n];
    i && (U(i) || (i = [i]), P(i, function(r) {
      n0(r);
    }));
  });
}
function L5(e) {
  var t = st();
  e.eachSeries(function(n) {
    var i = n.get("stack");
    if (i) {
      var r = t.get(i) || t.set(i, []), a = n.getData(), o = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: n
      };
      if (!o.stackedDimension || !(o.isStackedByIndex || o.stackedByDimension))
        return;
      r.push(o);
    }
  }), t.each(function(n) {
    if (n.length !== 0) {
      var i = n[0].seriesModel, r = i.get("stackOrder") || "seriesAsc";
      r === "seriesDesc" && n.reverse(), P(n, function(a, o) {
        a.data.setCalculationInfo("stackedOnSeries", o > 0 ? n[o - 1].seriesModel : null);
      }), O5(n);
    }
  });
}
function O5(e) {
  P(e, function(t, n) {
    var i = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], o = t.data, s = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    o.modify(a, function(u, c, h) {
      var d = o.get(t.stackedDimension, h);
      if (isNaN(d))
        return r;
      var f, v;
      s ? v = o.getRawIndex(h) : f = o.get(t.stackedByDimension, h);
      for (var g = NaN, p = n - 1; p >= 0; p--) {
        var _ = e[p];
        if (s || (v = _.data.rawIndexOf(_.stackedByDimension, f)), v >= 0) {
          var m = _.data.getByRawIndex(_.stackResultDimension, v);
          if (l === "all" || l === "positive" && m > 0 || l === "negative" && m < 0 || l === "samesign" && d >= 0 && m > 0 || l === "samesign" && d <= 0 && m < 0) {
            d = BE(d, m), g = m;
            break;
          }
        }
      }
      return i[0] = d, i[1] = g, i;
    });
  });
}
var Nc = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === ti ? {} : []), this.sourceFormat = t.sourceFormat || Tx, this.seriesLayoutBy = t.seriesLayoutBy || Qn, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var n = this.dimensionsDefine = t.dimensionsDefine;
      if (n)
        for (var i = 0; i < n.length; i++) {
          var r = n[i];
          r.type == null && Px(this, i) === Ge.Must && (r.type = "ordinal");
        }
    }
    return e;
  })()
);
function np(e) {
  return e instanceof Nc;
}
function Mf(e, t, n) {
  n = n || Ox(e);
  var i = t.seriesLayoutBy, r = R5(e, n, i, t.sourceHeader, t.dimensions), a = new Nc({
    data: e,
    sourceFormat: n,
    seriesLayoutBy: i,
    dimensionsDefine: r.dimensionsDefine,
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount,
    metaRawOption: ft(t)
  });
  return a;
}
function ip(e) {
  return new Nc({
    data: e,
    sourceFormat: Le(e) ? xi : Qe
  });
}
function I5(e) {
  return new Nc({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: ft(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function Ox(e) {
  var t = Tx;
  if (Le(e))
    t = xi;
  else if (U(e)) {
    e.length === 0 && (t = Se);
    for (var n = 0, i = e.length; n < i; n++) {
      var r = e[n];
      if (r != null) {
        if (U(r) || Le(r)) {
          t = Se;
          break;
        } else if (X(r)) {
          t = On;
          break;
        }
      }
    }
  } else if (X(e)) {
    for (var a in e)
      if (Xn(e, a) && We(e[a])) {
        t = ti;
        break;
      }
  }
  return t;
}
function R5(e, t, n, i, r) {
  var a, o;
  if (!e)
    return {
      dimensionsDefine: a0(r),
      startIndex: o,
      dimensionsDetectedCount: a
    };
  if (t === Se) {
    var s = e;
    i === "auto" || i == null ? o0(function(u) {
      u != null && u !== "-" && (K(u) ? o == null && (o = 1) : o = 0);
    }, n, s, 10) : o = Xt(i) ? i : i ? 1 : 0, !r && o === 1 && (r = [], o0(function(u, c) {
      r[c] = u != null ? u + "" : "";
    }, n, s, 1 / 0)), a = r ? r.length : n === ca ? s.length : s[0] ? s[0].length : null;
  } else if (t === On)
    r || (r = N5(e));
  else if (t === ti)
    r || (r = [], P(e, function(u, c) {
      r.push(c);
    }));
  else if (t === Qe) {
    var l = js(e[0]);
    a = U(l) && l.length || 1;
  } else t === xi && process.env.NODE_ENV !== "production" && Q(!!r, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: o,
    dimensionsDefine: a0(r),
    dimensionsDetectedCount: a
  };
}
function N5(e) {
  for (var t = 0, n; t < e.length && !(n = e[t++]); )
    ;
  if (n)
    return jt(n);
}
function a0(e) {
  if (e) {
    var t = st();
    return yt(e, function(n, i) {
      n = X(n) ? n : {
        name: n
      };
      var r = {
        name: n.name,
        displayName: n.displayName,
        type: n.type
      };
      if (r.name == null)
        return r;
      r.name += "", r.displayName == null && (r.displayName = r.name);
      var a = t.get(r.name);
      return a ? r.name += "-" + a.count++ : t.set(r.name, {
        count: 1
      }), r;
    });
  }
}
function o0(e, t, n, i) {
  if (t === ca)
    for (var r = 0; r < n.length && r < i; r++)
      e(n[r] ? n[r][0] : null, r);
  else
    for (var a = n[0] || [], r = 0; r < a.length && r < i; r++)
      e(a[r], r);
}
function Ix(e) {
  var t = e.sourceFormat;
  return t === On || t === ti;
}
var Cr, Pr, Ar, Er, s0, l0, Rx = (
  /** @class */
  (function() {
    function e(t, n) {
      var i = np(t) ? t : ip(t);
      this._source = i;
      var r = this._data = i.data, a = i.sourceFormat, o = i.seriesLayoutBy;
      if (a === xi) {
        if (process.env.NODE_ENV !== "production" && n == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = n, this._data = r;
      }
      if (process.env.NODE_ENV !== "production") {
        var s = F5[Gu(a, o)];
        s && s(r, i.dimensionsDefine);
      }
      l0(this, r, i);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, n) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    })(), e.internalField = (function() {
      var t;
      l0 = function(o, s, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, d = l.dimensionsDefine, f = s0[Gu(u, c)];
        if (process.env.NODE_ENV !== "production" && Q(f, "Invalide sourceFormat: " + u), $(o, f), u === xi)
          o.getItem = n, o.count = r, o.fillStorage = i;
        else {
          var v = Nx(u, c);
          o.getItem = Tt(v, null, s, h, d);
          var g = Fx(u, c);
          o.count = Tt(g, null, s, h, d);
        }
      };
      var n = function(o, s) {
        o = o - this._offset, s = s || [];
        for (var l = this._data, u = this._dimSize, c = u * o, h = 0; h < u; h++)
          s[h] = l[c + h];
        return s;
      }, i = function(o, s, l, u) {
        for (var c = this._data, h = this._dimSize, d = 0; d < h; d++) {
          for (var f = u[d], v = f[0] == null ? 1 / 0 : f[0], g = f[1] == null ? -1 / 0 : f[1], p = s - o, _ = l[d], m = 0; m < p; m++) {
            var y = c[m * h + d];
            _[o + m] = y, y < v && (v = y), y > g && (g = y);
          }
          f[0] = v, f[1] = g;
        }
      }, r = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      s0 = (t = {}, t[Se + "_" + Qn] = {
        pure: !0,
        appendData: a
      }, t[Se + "_" + ca] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[On] = {
        pure: !0,
        appendData: a
      }, t[ti] = {
        pure: !0,
        appendData: function(o) {
          var s = this._data;
          P(o, function(l, u) {
            for (var c = s[u] || (s[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, t[Qe] = {
        appendData: a
      }, t[xi] = {
        persistent: !1,
        pure: !0,
        appendData: function(o) {
          process.env.NODE_ENV !== "production" && Q(Le(o), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = o;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(o) {
        for (var s = 0; s < o.length; s++)
          this._data.push(o[s]);
      }
    })(), e;
  })()
), Fl = function(e) {
  U(e) || qt("series.data or dataset.source must be an array.");
}, F5 = (Cr = {}, Cr[Se + "_" + Qn] = Fl, Cr[Se + "_" + ca] = Fl, Cr[On] = Fl, Cr[ti] = function(e, t) {
  for (var n = 0; n < t.length; n++) {
    var i = t[n].name;
    i == null && qt("dimension name must not be null/undefined.");
  }
}, Cr[Qe] = Fl, Cr), u0 = function(e, t, n, i) {
  return e[i];
}, B5 = (Pr = {}, Pr[Se + "_" + Qn] = function(e, t, n, i) {
  return e[i + t];
}, Pr[Se + "_" + ca] = function(e, t, n, i, r) {
  i += t;
  for (var a = r || [], o = e, s = 0; s < o.length; s++) {
    var l = o[s];
    a[s] = l ? l[i] : null;
  }
  return a;
}, Pr[On] = u0, Pr[ti] = function(e, t, n, i, r) {
  for (var a = r || [], o = 0; o < n.length; o++) {
    var s = n[o].name, l = s != null ? e[s] : null;
    a[o] = l ? l[i] : null;
  }
  return a;
}, Pr[Qe] = u0, Pr);
function Nx(e, t) {
  var n = B5[Gu(e, t)];
  return process.env.NODE_ENV !== "production" && Q(n, 'Do not support get item on "' + e + '", "' + t + '".'), n;
}
var c0 = function(e, t, n) {
  return e.length;
}, z5 = (Ar = {}, Ar[Se + "_" + Qn] = function(e, t, n) {
  return Math.max(0, e.length - t);
}, Ar[Se + "_" + ca] = function(e, t, n) {
  var i = e[0];
  return i ? Math.max(0, i.length - t) : 0;
}, Ar[On] = c0, Ar[ti] = function(e, t, n) {
  var i = n[0].name, r = i != null ? e[i] : null;
  return r ? r.length : 0;
}, Ar[Qe] = c0, Ar);
function Fx(e, t) {
  var n = z5[Gu(e, t)];
  return process.env.NODE_ENV !== "production" && Q(n, 'Do not support count on "' + e + '", "' + t + '".'), n;
}
var sd = function(e, t, n) {
  return e[t];
}, V5 = (Er = {}, Er[Se] = sd, Er[On] = function(e, t, n) {
  return e[n];
}, Er[ti] = sd, Er[Qe] = function(e, t, n) {
  var i = js(e);
  return i instanceof Array ? i[t] : i;
}, Er[xi] = sd, Er);
function Bx(e) {
  var t = V5[e];
  return process.env.NODE_ENV !== "production" && Q(t, 'Do not support get value on "' + e + '".'), t;
}
function Gu(e, t) {
  return e === Se ? e + "_" + t : e;
}
function ju(e, t, n) {
  if (e) {
    var i = e.getRawDataItem(t);
    if (i != null) {
      var r = e.getStore(), a = r.getSource().sourceFormat;
      if (n != null) {
        var o = e.getDimensionIndex(n), s = r.getDimensionProperty(o);
        return Bx(a)(i, o, s);
      } else {
        var l = i;
        return a === Qe && (l = js(i)), l;
      }
    }
  }
}
var $5 = /\{@(.+?)\}/g, H5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, n) {
      var i = this.getData(n), r = this.getRawValue(t, n), a = i.getRawIndex(t), o = i.getName(t), s = i.getRawDataItem(t), l = i.getItemVisual(t, "style"), u = l && l[i.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, d = h === "series", f = i.userOutput && i.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: d ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: d ? this.id : null,
        seriesName: d ? this.name : null,
        name: o,
        dataIndex: a,
        data: s,
        dataType: n,
        value: r,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, n, i, r, a, o) {
      n = n || "normal";
      var s = this.getData(i), l = this.getDataParams(t, i);
      if (o && (l.value = o.interpolatedValue), r != null && U(l.value) && (l.value = l.value[r]), !a) {
        var u = s.getItemModel(t);
        a = u.get(n === "normal" ? ["label", "formatter"] : [n, "label", "formatter"]);
      }
      if (gt(a))
        return l.status = n, l.dimensionIndex = r, a(l);
      if (K(a)) {
        var c = yx(a, l);
        return c.replace($5, function(h, d) {
          var f = d.length, v = d;
          v.charAt(0) === "[" && v.charAt(f - 1) === "]" && (v = +v.slice(1, f - 1), process.env.NODE_ENV !== "production" && isNaN(v) && qt("Invalide label formatter: @" + d + ", only support @[0], @[1], @[2], ..."));
          var g = ju(s, t, v);
          if (o && U(o.interpolatedValue)) {
            var p = s.getDimensionIndex(v);
            p >= 0 && (g = o.interpolatedValue[p]);
          }
          return g != null ? g + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, n) {
      return ju(this.getData(n), t);
    }, e.prototype.formatTooltip = function(t, n, i) {
    }, e;
  })()
);
function h0(e) {
  var t, n;
  return X(e) ? e.type ? n = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + Nu(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: n
  };
}
function _s(e) {
  return new Y5(e);
}
var Y5 = (
  /** @class */
  (function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var n = this._upstream, i = t && t.skip;
      if (this._dirty && n) {
        var r = this.context;
        r.data = r.outputData = n.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !i && (a = this._plan(this.context));
      var o = c(this._modBy), s = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (o !== l || s !== u) && (a = "reset");
      function c(m) {
        return !(m >= 1) && (m = 1), m;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = !1, h = this._doReset(i)), this._modBy = l, this._modDataCount = u;
      var d = t && t.step;
      if (n ? (process.env.NODE_ENV !== "production" && Q(n._outputDueEnd != null), this._dueEnd = n._outputDueEnd) : (process.env.NODE_ENV !== "production" && Q(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var f = this._dueIndex, v = Math.min(d != null ? this._dueIndex + d : 1 / 0, this._dueEnd);
        if (!i && (h || f < v)) {
          var g = this._progress;
          if (U(g))
            for (var p = 0; p < g.length; p++)
              this._doProgress(g[p], f, v, l, u);
          else
            this._doProgress(g, f, v, l, u);
        }
        this._dueIndex = v;
        var _ = this._settedOutputEnd != null ? this._settedOutputEnd : v;
        process.env.NODE_ENV !== "production" && Q(_ >= this._outputDueEnd), this._outputDueEnd = _;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, n, i, r, a) {
      d0.reset(n, i, r, a), this._callingProgress = t, this._callingProgress({
        start: n,
        end: i,
        count: i - n,
        next: d0.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var n, i;
      !t && this._reset && (n = this._reset(this.context), n && n.progress && (i = n.forceFirstProgress, n = n.progress), U(n) && !n.length && (n = null)), this._progress = n, this._modBy = this._modDataCount = null;
      var r = this._downstream;
      return r && r.dirty(), i;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && Q(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  })()
), d0 = /* @__PURE__ */ (function() {
  var e, t, n, i, r, a = {
    reset: function(l, u, c, h) {
      t = l, e = u, n = c, i = h, r = Math.ceil(i / n), a.next = n > 1 && i > 0 ? s : o;
    }
  };
  return a;
  function o() {
    return t < e ? t++ : null;
  }
  function s() {
    var l = t % r * n + Math.ceil(t / r), u = t >= e ? null : l < i ? l : t;
    return t++, u;
  }
})();
function uu(e, t) {
  var n = t && t.type;
  return n === "ordinal" ? e : (n === "time" && !Xt(e) && e != null && e !== "-" && (e = +Tc(e)), e == null || e === "" ? NaN : Number(e));
}
st({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +Tc(e);
  },
  trim: function(e) {
    return K(e) ? Un(e) : e;
  }
});
var W5 = (
  /** @class */
  (function() {
    function e(t, n) {
      var i = t === "desc";
      this._resultLT = i ? 1 : -1, n == null && (n = i ? "min" : "max"), this._incomparable = n === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, n) {
      var i = Xt(t) ? t : Ru(t), r = Xt(n) ? n : Ru(n), a = isNaN(i), o = isNaN(r);
      if (a && (i = this._incomparable), o && (r = this._incomparable), a && o) {
        var s = K(t), l = K(n);
        s && (i = l ? t : 0), l && (r = s ? n : 0);
      }
      return i < r ? this._resultLT : i > r ? -this._resultLT : 0;
    }, e;
  })()
), U5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, n) {
    }, e.prototype.retrieveValueFromItem = function(t, n) {
    }, e.prototype.convertValue = function(t, n) {
      return uu(t, n);
    }, e;
  })()
);
function G5(e, t) {
  var n = new U5(), i = e.data, r = n.sourceFormat = e.sourceFormat, a = e.startIndex, o = "";
  e.seriesLayoutBy !== Qn && (process.env.NODE_ENV !== "production" && (o = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), $e(o));
  var s = [], l = {}, u = e.dimensionsDefine;
  if (u)
    P(u, function(g, p) {
      var _ = g.name, m = {
        index: p,
        name: _,
        displayName: g.displayName
      };
      if (s.push(m), _ != null) {
        var y = "";
        Xn(l, _) && (process.env.NODE_ENV !== "production" && (y = 'dimension name "' + _ + '" duplicated.'), $e(y)), l[_] = m;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      s.push({
        index: c
      });
  var h = Nx(r, Qn);
  t.__isBuiltIn && (n.getRawDataItem = function(g) {
    return h(i, a, s, g);
  }, n.getRawData = Tt(j5, null, e)), n.cloneRawData = Tt(X5, null, e);
  var d = Fx(r, Qn);
  n.count = Tt(d, null, i, a, s);
  var f = Bx(r);
  n.retrieveValue = function(g, p) {
    var _ = h(i, a, s, g);
    return v(_, p);
  };
  var v = n.retrieveValueFromItem = function(g, p) {
    if (g != null) {
      var _ = s[p];
      if (_)
        return f(g, p, _.name);
    }
  };
  return n.getDimensionInfo = Tt(q5, null, s, l), n.cloneAllDimensionInfo = Tt(Z5, null, s), n;
}
function j5(e) {
  var t = e.sourceFormat;
  if (!rp(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`getRawData` is not supported in source format " + t), $e(n);
  }
  return e.data;
}
function X5(e) {
  var t = e.sourceFormat, n = e.data;
  if (!rp(t)) {
    var i = "";
    process.env.NODE_ENV !== "production" && (i = "`cloneRawData` is not supported in source format " + t), $e(i);
  }
  if (t === Se) {
    for (var r = [], a = 0, o = n.length; a < o; a++)
      r.push(n[a].slice());
    return r;
  } else if (t === On) {
    for (var r = [], a = 0, o = n.length; a < o; a++)
      r.push($({}, n[a]));
    return r;
  }
}
function q5(e, t, n) {
  if (n != null) {
    if (Xt(n) || !isNaN(n) && !Xn(t, n))
      return e[n];
    if (Xn(t, n))
      return t[n];
  }
}
function Z5(e) {
  return ft(e);
}
var zx = st();
function K5(e) {
  e = ft(e);
  var t = e.type, n = "";
  t || (process.env.NODE_ENV !== "production" && (n = "Must have a `type` when `registerTransform`."), $e(n));
  var i = t.split(":");
  i.length !== 2 && (process.env.NODE_ENV !== "production" && (n = 'Name must include namespace like "ns:regression".'), $e(n));
  var r = !1;
  i[0] === "echarts" && (t = i[1], r = !0), e.__isBuiltIn = r, zx.set(t, e);
}
function Q5(e, t, n) {
  var i = Ae(e), r = i.length, a = "";
  r || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), $e(a));
  for (var o = 0, s = r; o < s; o++) {
    var l = i[o];
    t = J5(l, t, n, r === 1 ? null : o), o !== s - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function J5(e, t, n, i) {
  var r = "";
  t.length || (process.env.NODE_ENV !== "production" && (r = "Must have at least one upstream dataset."), $e(r)), X(e) || (process.env.NODE_ENV !== "production" && (r = "transform declaration must be an object rather than " + typeof e + "."), $e(r));
  var a = e.type, o = zx.get(a);
  o || (process.env.NODE_ENV !== "production" && (r = 'Can not find transform on type "' + a + '".'), $e(r));
  var s = yt(t, function(c) {
    return G5(c, o);
  }), l = Ae(o.transform({
    upstream: s[0],
    upstreamList: s,
    config: ft(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = yt(l, function(c) {
      var h = i != null ? " === pipe index: " + i : "";
      return ["=== dataset index: " + n.datasetIndex + h + " ===", "- transform result data:", Nu(c.data), "- transform result dimensions:", Nu(c.dimensions)].join(`
`);
    }).join(`
`);
    HE(u);
  }
  return yt(l, function(c, h) {
    var d = "";
    X(c) || (process.env.NODE_ENV !== "production" && (d = "A transform should not return some empty results."), $e(d)), c.data || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be not be null or undefined"), $e(d));
    var f = Ox(c.data);
    rp(f) || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be array rows or object rows."), $e(d));
    var v, g = t[0];
    if (g && h === 0 && !c.dimensions) {
      var p = g.startIndex;
      p && (c.data = g.data.slice(0, p).concat(c.data)), v = {
        seriesLayoutBy: Qn,
        sourceHeader: p,
        dimensions: g.metaRawOption.dimensions
      };
    } else
      v = {
        seriesLayoutBy: Qn,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return Mf(c.data, v, null);
  });
}
function rp(e) {
  return e === Se || e === On;
}
var Fc = "undefined", tR = typeof Uint32Array === Fc ? Array : Uint32Array, eR = typeof Uint16Array === Fc ? Array : Uint16Array, Vx = typeof Int32Array === Fc ? Array : Int32Array, f0 = typeof Float64Array === Fc ? Array : Float64Array, $x = {
  float: f0,
  int: Vx,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: f0
}, ld;
function Ta(e) {
  return e > 65535 ? tR : eR;
}
function ka() {
  return [1 / 0, -1 / 0];
}
function nR(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function v0(e, t, n, i, r) {
  var a = $x[n || "float"];
  if (r) {
    var o = e[t], s = o && o.length;
    if (s !== i) {
      for (var l = new a(i), u = 0; u < s; u++)
        l[u] = o[u];
      e[t] = l;
    }
  } else
    e[t] = new a(i);
}
var Df = (
  /** @class */
  (function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = st();
    }
    return e.prototype.initData = function(t, n, i) {
      process.env.NODE_ENV !== "production" && Q(gt(t.getItem) && gt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var r = t.getSource(), a = this.defaultDimValueGetter = ld[r.sourceFormat];
      this._dimValueGetter = i || a, this._rawExtent = [];
      var o = Ix(r);
      this._dimensions = yt(n, function(s) {
        return process.env.NODE_ENV !== "production" && o && Q(s.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: s.type,
          property: s.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, n) {
      var i = this._calcDimNameToIdx, r = this._dimensions, a = i.get(t);
      if (a != null) {
        if (r[a].type === n)
          return a;
      } else
        a = r.length;
      return r[a] = {
        type: n
      }, i.set(t, a), this._chunks[a] = new $x[n || "float"](this._rawCount), this._rawExtent[a] = ka(), a;
    }, e.prototype.collectOrdinalMeta = function(t, n) {
      var i = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, o = r.ordinalOffset || 0, s = i.length;
      o === 0 && (a[t] = ka());
      for (var l = a[t], u = o; u < s; u++) {
        var c = i[u] = n.parseAndCollect(i[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      r.ordinalMeta = n, r.ordinalOffset = s, r.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var n = this._dimensions[t], i = n.ordinalMeta;
      return i;
    }, e.prototype.getDimensionProperty = function(t) {
      var n = this._dimensions[t];
      return n && n.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && Q(!this._indices, "appendData can only be called on raw data.");
      var n = this._provider, i = this.count();
      n.appendData(t);
      var r = n.count();
      return n.persistent || (r += i), i < r && this._initDataFromProvider(i, r, !0), [i, r];
    }, e.prototype.appendValues = function(t, n) {
      for (var i = this._chunks, r = this._dimensions, a = r.length, o = this._rawExtent, s = this.count(), l = s + Math.max(t.length, n || 0), u = 0; u < a; u++) {
        var c = r[u];
        v0(i, u, c.type, l, !0);
      }
      for (var h = [], d = s; d < l; d++)
        for (var f = d - s, v = 0; v < a; v++) {
          var c = r[v], g = ld.arrayRows.call(this, t[f] || h, c.property, f, v);
          i[v][d] = g;
          var p = o[v];
          g < p[0] && (p[0] = g), g > p[1] && (p[1] = g);
        }
      return this._rawCount = this._count = l, {
        start: s,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, n, i) {
      for (var r = this._provider, a = this._chunks, o = this._dimensions, s = o.length, l = this._rawExtent, u = yt(o, function(m) {
        return m.property;
      }), c = 0; c < s; c++) {
        var h = o[c];
        l[c] || (l[c] = ka()), v0(a, c, h.type, n, i);
      }
      if (r.fillStorage)
        r.fillStorage(t, n, a, l);
      else
        for (var d = [], f = t; f < n; f++) {
          d = r.getItem(f, d);
          for (var v = 0; v < s; v++) {
            var g = a[v], p = this._dimValueGetter(d, u[v], f, v);
            g[f] = p;
            var _ = l[v];
            p < _[0] && (_[0] = p), p > _[1] && (_[1] = p);
          }
        }
      !r.persistent && r.clean && r.clean(), this._rawCount = this._count = n, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, n) {
      if (!(n >= 0 && n < this._count))
        return NaN;
      var i = this._chunks[t];
      return i ? i[this.getRawIndex(n)] : NaN;
    }, e.prototype.getValues = function(t, n) {
      var i = [], r = [];
      if (n == null) {
        n = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          r.push(a);
      } else
        r = t;
      for (var a = 0, o = r.length; a < o; a++)
        i.push(this.get(r[a], n));
      return i;
    }, e.prototype.getByRawIndex = function(t, n) {
      if (!(n >= 0 && n < this._rawCount))
        return NaN;
      var i = this._chunks[t];
      return i ? i[n] : NaN;
    }, e.prototype.getSum = function(t) {
      var n = this._chunks[t], i = 0;
      if (n)
        for (var r = 0, a = this.count(); r < a; r++) {
          var o = this.get(t, r);
          isNaN(o) || (i += o);
        }
      return i;
    }, e.prototype.getMedian = function(t) {
      var n = [];
      this.each([t], function(a) {
        isNaN(a) || n.push(a);
      });
      var i = n.sort(function(a, o) {
        return a - o;
      }), r = this.count();
      return r === 0 ? 0 : r % 2 === 1 ? i[(r - 1) / 2] : (i[r / 2] + i[r / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var n = this._indices, i = n[t];
      if (i != null && i < this._count && i === t)
        return t;
      for (var r = 0, a = this._count - 1; r <= a; ) {
        var o = (r + a) / 2 | 0;
        if (n[o] < t)
          r = o + 1;
        else if (n[o] > t)
          a = o - 1;
        else
          return o;
      }
      return -1;
    }, e.prototype.getIndices = function() {
      var t, n = this._indices;
      if (n) {
        var i = n.constructor, r = this._count;
        if (i === Array) {
          t = new i(r);
          for (var a = 0; a < r; a++)
            t[a] = n[a];
        } else
          t = new i(n.buffer, 0, r);
      } else {
        var i = Ta(this._rawCount);
        t = new i(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, e.prototype.filter = function(t, n) {
      if (!this._count)
        return this;
      for (var i = this.clone(), r = i.count(), a = Ta(i._rawCount), o = new a(r), s = [], l = t.length, u = 0, c = t[0], h = i._chunks, d = 0; d < r; d++) {
        var f = void 0, v = i.getRawIndex(d);
        if (l === 0)
          f = n(d);
        else if (l === 1) {
          var g = h[c][v];
          f = n(g, d);
        } else {
          for (var p = 0; p < l; p++)
            s[p] = h[t[p]][v];
          s[p] = d, f = n.apply(null, s);
        }
        f && (o[u++] = v);
      }
      return u < r && (i._indices = o), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, e.prototype.selectRange = function(t) {
      var n = this.clone(), i = n._count;
      if (!i)
        return this;
      var r = jt(t), a = r.length;
      if (!a)
        return this;
      var o = n.count(), s = Ta(n._rawCount), l = new s(o), u = 0, c = r[0], h = t[c][0], d = t[c][1], f = n._chunks, v = !1;
      if (!n._indices) {
        var g = 0;
        if (a === 1) {
          for (var p = f[r[0]], _ = 0; _ < i; _++) {
            var m = p[_];
            (m >= h && m <= d || isNaN(m)) && (l[u++] = g), g++;
          }
          v = !0;
        } else if (a === 2) {
          for (var p = f[r[0]], y = f[r[1]], b = t[r[1]][0], x = t[r[1]][1], _ = 0; _ < i; _++) {
            var m = p[_], w = y[_];
            (m >= h && m <= d || isNaN(m)) && (w >= b && w <= x || isNaN(w)) && (l[u++] = g), g++;
          }
          v = !0;
        }
      }
      if (!v)
        if (a === 1)
          for (var _ = 0; _ < o; _++) {
            var M = n.getRawIndex(_), m = f[r[0]][M];
            (m >= h && m <= d || isNaN(m)) && (l[u++] = M);
          }
        else
          for (var _ = 0; _ < o; _++) {
            for (var D = !0, M = n.getRawIndex(_), T = 0; T < a; T++) {
              var C = r[T], m = f[C][M];
              (m < t[C][0] || m > t[C][1]) && (D = !1);
            }
            D && (l[u++] = n.getRawIndex(_));
          }
      return u < o && (n._indices = l), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.map = function(t, n) {
      var i = this.clone(t);
      return this._updateDims(i, t, n), i;
    }, e.prototype.modify = function(t, n) {
      this._updateDims(this, t, n);
    }, e.prototype._updateDims = function(t, n, i) {
      for (var r = t._chunks, a = [], o = n.length, s = t.count(), l = [], u = t._rawExtent, c = 0; c < n.length; c++)
        u[n[c]] = ka();
      for (var h = 0; h < s; h++) {
        for (var d = t.getRawIndex(h), f = 0; f < o; f++)
          l[f] = r[n[f]][d];
        l[o] = h;
        var v = i && i.apply(null, l);
        if (v != null) {
          typeof v != "object" && (a[0] = v, v = a);
          for (var c = 0; c < v.length; c++) {
            var g = n[c], p = v[c], _ = u[g], m = r[g];
            m && (m[d] = p), p < _[0] && (_[0] = p), p > _[1] && (_[1] = p);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, n) {
      var i = this.clone([t], !0), r = i._chunks, a = r[t], o = this.count(), s = 0, l = Math.floor(1 / n), u = this.getRawIndex(0), c, h, d, f = new (Ta(this._rawCount))(Math.min((Math.ceil(o / l) + 2) * 2, o));
      f[s++] = u;
      for (var v = 1; v < o - 1; v += l) {
        for (var g = Math.min(v + l, o - 1), p = Math.min(v + l * 2, o), _ = (p + g) / 2, m = 0, y = g; y < p; y++) {
          var b = this.getRawIndex(y), x = a[b];
          isNaN(x) || (m += x);
        }
        m /= p - g;
        var w = v, M = Math.min(v + l, o), D = v - 1, T = a[u];
        c = -1, d = w;
        for (var C = -1, k = 0, y = w; y < M; y++) {
          var b = this.getRawIndex(y), x = a[b];
          if (isNaN(x)) {
            k++, C < 0 && (C = b);
            continue;
          }
          h = Math.abs((D - _) * (x - T) - (D - y) * (m - T)), h > c && (c = h, d = b);
        }
        k > 0 && k < M - w && (f[s++] = Math.min(C, d), d = Math.max(C, d)), f[s++] = d, u = d;
      }
      return f[s++] = this.getRawIndex(o - 1), i._count = s, i._indices = f, i.getRawIndex = this._getRawIdx, i;
    }, e.prototype.minmaxDownSample = function(t, n) {
      for (var i = this.clone([t], !0), r = i._chunks, a = Math.floor(1 / n), o = r[t], s = this.count(), l = new (Ta(this._rawCount))(Math.ceil(s / a) * 2), u = 0, c = 0; c < s; c += a) {
        var h = c, d = o[this.getRawIndex(h)], f = c, v = o[this.getRawIndex(f)], g = a;
        c + a > s && (g = s - c);
        for (var p = 0; p < g; p++) {
          var _ = this.getRawIndex(c + p), m = o[_];
          m < d && (d = m, h = c + p), m > v && (v = m, f = c + p);
        }
        var y = this.getRawIndex(h), b = this.getRawIndex(f);
        h < f ? (l[u++] = y, l[u++] = b) : (l[u++] = b, l[u++] = y);
      }
      return i._count = u, i._indices = l, i._updateGetRawIdx(), i;
    }, e.prototype.downSample = function(t, n, i, r) {
      for (var a = this.clone([t], !0), o = a._chunks, s = [], l = Math.floor(1 / n), u = o[t], c = this.count(), h = a._rawExtent[t] = ka(), d = new (Ta(this._rawCount))(Math.ceil(c / l)), f = 0, v = 0; v < c; v += l) {
        l > c - v && (l = c - v, s.length = l);
        for (var g = 0; g < l; g++) {
          var p = this.getRawIndex(v + g);
          s[g] = u[p];
        }
        var _ = i(s), m = this.getRawIndex(Math.min(v + r(s, _) || 0, c - 1));
        u[m] = _, _ < h[0] && (h[0] = _), _ > h[1] && (h[1] = _), d[f++] = m;
      }
      return a._count = f, a._indices = d, a._updateGetRawIdx(), a;
    }, e.prototype.each = function(t, n) {
      if (this._count)
        for (var i = t.length, r = this._chunks, a = 0, o = this.count(); a < o; a++) {
          var s = this.getRawIndex(a);
          switch (i) {
            case 0:
              n(a);
              break;
            case 1:
              n(r[t[0]][s], a);
              break;
            case 2:
              n(r[t[0]][s], r[t[1]][s], a);
              break;
            default:
              for (var l = 0, u = []; l < i; l++)
                u[l] = r[t[l]][s];
              u[l] = a, n.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var n = this._chunks[t], i = ka();
      if (!n)
        return i;
      var r = this.count(), a = !this._indices, o;
      if (a)
        return this._rawExtent[t].slice();
      if (o = this._extent[t], o)
        return o.slice();
      o = i;
      for (var s = o[0], l = o[1], u = 0; u < r; u++) {
        var c = this.getRawIndex(u), h = n[c];
        h < s && (s = h), h > l && (l = h);
      }
      return o = [s, l], this._extent[t] = o, o;
    }, e.prototype.getRawDataItem = function(t) {
      var n = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(n);
      for (var i = [], r = this._chunks, a = 0; a < r.length; a++)
        i.push(r[a][n]);
      return i;
    }, e.prototype.clone = function(t, n) {
      var i = new e(), r = this._chunks, a = t && ho(t, function(s, l) {
        return s[l] = !0, s;
      }, {});
      if (a)
        for (var o = 0; o < r.length; o++)
          i._chunks[o] = a[o] ? nR(r[o]) : r[o];
      else
        i._chunks = r;
      return this._copyCommonProps(i), n || (i._indices = this._cloneIndices()), i._updateGetRawIdx(), i;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = ft(this._extent), t._rawExtent = ft(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, n = void 0;
        if (t === Array) {
          var i = this._indices.length;
          n = new t(i);
          for (var r = 0; r < i; r++)
            n[r] = this._indices[r];
        } else
          n = new t(this._indices);
        return n;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = (function() {
      function t(n, i, r, a) {
        return uu(n[a], this._dimensions[a]);
      }
      ld = {
        arrayRows: t,
        objectRows: function(n, i, r, a) {
          return uu(n[i], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(n, i, r, a) {
          var o = n && (n.value == null ? n : n.value);
          return uu(o instanceof Array ? o[a] : o, this._dimensions[a]);
        },
        typedArray: function(n, i, r, a) {
          return n[a];
        }
      };
    })(), e;
  })()
), iR = (
  /** @class */
  (function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, n) {
      this._sourceList = t, this._upstreamSignList = n, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, n = this._getUpstreamSourceManagers(), i = !!n.length, r, a;
      if (Lo(t)) {
        var o = t, s = void 0, l = void 0, u = void 0;
        if (i) {
          var c = n[0];
          c.prepareSource(), u = c.getSource(), s = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          s = o.get("data", !0), l = Le(s) ? xi : Qe, a = [];
        var h = this._getSourceMetaRawOption() || {}, d = u && u.metaRawOption || {}, f = J(h.seriesLayoutBy, d.seriesLayoutBy) || null, v = J(h.sourceHeader, d.sourceHeader), g = J(h.dimensions, d.dimensions), p = f !== d.seriesLayoutBy || !!v != !!d.sourceHeader || g;
        r = p ? [Mf(s, {
          seriesLayoutBy: f,
          sourceHeader: v,
          dimensions: g
        }, l)] : [];
      } else {
        var _ = t;
        if (i) {
          var m = this._applyTransform(n);
          r = m.sourceList, a = m.upstreamSignList;
        } else {
          var y = _.get("source", !0);
          r = [Mf(y, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && Q(r && a), this._setLocalSource(r, a);
    }, e.prototype._applyTransform = function(t) {
      var n = this._sourceHost, i = n.get("transform", !0), r = n.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && Q(r != null || i != null), r != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), p0(a));
      }
      var o, s = [], l = [];
      return P(t, function(u) {
        u.prepareSource();
        var c = u.getSource(r || 0), h = "";
        r != null && !c && (process.env.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + r), p0(h)), s.push(c), l.push(u._getVersionSign());
      }), i ? o = Q5(i, s, {
        datasetIndex: n.componentIndex
      }) : r != null && (o = [I5(s[0])]), {
        sourceList: o,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), n = 0; n < t.length; n++) {
        var i = t[n];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          i._isDirty() || this._upstreamSignList[n] !== i._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var n = this._sourceList[t];
      if (!n) {
        var i = this._getUpstreamSourceManagers();
        return i[0] && i[0].getSource(t);
      }
      return n;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && Q(Lo(this._sourceHost), "Can only call getDataStore on series source manager.");
      var n = t.makeStoreSchema();
      return this._innerGetDataStore(n.dimensions, t.source, n.hash);
    }, e.prototype._innerGetDataStore = function(t, n, i) {
      var r = 0, a = this._storeList, o = a[r];
      o || (o = a[r] = {});
      var s = o[i];
      if (!s) {
        var l = this._getUpstreamSourceManagers()[0];
        Lo(this._sourceHost) && l ? s = l._innerGetDataStore(t, n, i) : (s = new Df(), s.initData(new Rx(n, t.length), t)), o[i] = s;
      }
      return s;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (Lo(t)) {
        var n = Cx(t);
        return n ? [n.getSourceManager()] : [];
      } else
        return yt(o5(t), function(i) {
          return i.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, n, i, r;
      if (Lo(t))
        n = t.get("seriesLayoutBy", !0), i = t.get("sourceHeader", !0), r = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        n = a.get("seriesLayoutBy", !0), i = a.get("sourceHeader", !0), r = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: n,
        sourceHeader: i,
        dimensions: r
      };
    }, e;
  })()
);
function Lo(e) {
  return e.mainType === "series";
}
function p0(e) {
  throw new Error(e);
}
var rR = "line-height:1";
function Hx(e) {
  var t = e.lineHeight;
  return t == null ? rR : "line-height:" + Be(t + "") + "px";
}
function Yx(e, t) {
  var n = e.color || St.color.tertiary, i = e.fontSize || 12, r = e.fontWeight || "400", a = e.color || St.color.secondary, o = e.fontSize || 14, s = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Be(i + "") + "px;color:" + Be(n) + ";font-weight:" + Be(r + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Be(o + "") + "px;color:" + Be(a) + ";font-weight:" + Be(s + "")
  } : {
    nameStyle: {
      fontSize: i,
      fill: n,
      fontWeight: r
    },
    valueStyle: {
      fontSize: o,
      fill: a,
      fontWeight: s
    }
  };
}
var aR = [0, 10, 20, 30], oR = ["", `
`, `

`, `


`];
function sa(e, t) {
  return t.type = e, t;
}
function Tf(e) {
  return e.type === "section";
}
function Wx(e) {
  return Tf(e) ? sR : lR;
}
function Ux(e) {
  if (Tf(e)) {
    var t = 0, n = e.blocks.length, i = n > 1 || n > 0 && !e.noHeader;
    return P(e.blocks, function(r) {
      var a = Ux(r);
      a >= t && (t = a + +(i && // 0 always can not be readable gap level.
      (!a || Tf(r) && !r.noHeader)));
    }), t;
  }
  return 0;
}
function sR(e, t, n, i) {
  var r = t.noHeader, a = uR(Ux(t)), o = [], s = t.blocks || [];
  Q(!s || U(s)), s = s || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    s = s.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Xn(u, l)) {
      var c = new W5(u[l], null);
      s.sort(function(g, p) {
        return c.evaluate(g.sortParam, p.sortParam);
      });
    } else l === "seriesDesc" && s.reverse();
  }
  P(s, function(g, p) {
    var _ = t.valueFormatter, m = Wx(g)(
      // Inherit valueFormatter
      _ ? $($({}, e), {
        valueFormatter: _
      }) : e,
      g,
      p > 0 ? a.html : 0,
      i
    );
    m != null && o.push(m);
  });
  var h = e.renderMode === "richText" ? o.join(a.richText) : kf(i, o.join(""), r ? n : a.html);
  if (r)
    return h;
  var d = wf(t.header, "ordinal", e.useUTC), f = Yx(i, e.renderMode).nameStyle, v = Hx(i);
  return e.renderMode === "richText" ? Gx(e, d, f) + a.richText + h : kf(i, '<div style="' + f + ";" + v + ';">' + Be(d) + "</div>" + h, n);
}
function lR(e, t, n, i) {
  var r = e.renderMode, a = t.noName, o = t.noValue, s = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(b) {
    return b = U(b) ? b : [b], yt(b, function(x, w) {
      return wf(x, U(f) ? f[w] : f, u);
    });
  };
  if (!(a && o)) {
    var h = s ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || St.color.secondary, r), d = a ? "" : wf(l, "ordinal", u), f = t.valueType, v = o ? [] : c(t.value, t.dataIndex), g = !s || !a, p = !s && a, _ = Yx(i, r), m = _.nameStyle, y = _.valueStyle;
    return r === "richText" ? (s ? "" : h) + (a ? "" : Gx(e, d, m)) + (o ? "" : dR(e, v, g, p, y)) : kf(i, (s ? "" : h) + (a ? "" : cR(d, !s, m)) + (o ? "" : hR(v, g, p, y)), n);
  }
}
function g0(e, t, n, i, r, a) {
  if (e) {
    var o = Wx(e), s = {
      useUTC: r,
      renderMode: n,
      orderMode: i,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return o(s, e, 0, a);
  }
}
function uR(e) {
  return {
    html: aR[e],
    richText: oR[e]
  };
}
function kf(e, t, n) {
  var i = '<div style="clear:both"></div>', r = "margin: " + n + "px 0 0", a = Hx(e);
  return '<div style="' + r + ";" + a + ';">' + t + i + "</div>";
}
function cR(e, t, n) {
  var i = t ? "margin-left:2px" : "";
  return '<span style="' + n + ";" + i + '">' + Be(e) + "</span>";
}
function hR(e, t, n, i) {
  var r = n ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
  return e = U(e) ? e : [e], '<span style="' + a + ";" + i + '">' + yt(e, function(o) {
    return Be(o);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function Gx(e, t, n) {
  return e.markupStyleCreator.wrapRichTextStyle(t, n);
}
function dR(e, t, n, i, r) {
  var a = [r], o = i ? 10 : 20;
  return n && a.push({
    padding: [0, 0, 0, o],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(U(t) ? t.join("  ") : t, a);
}
function fR(e, t) {
  var n = e.getData().getItemVisual(t, "style"), i = n[e.visualDrawType];
  return Rs(i);
}
function jx(e, t) {
  var n = e.get("padding");
  return n ?? (t === "richText" ? [8, 10] : 10);
}
var ud = (
  /** @class */
  (function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = x1();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, n, i) {
      var r = i === "richText" ? this._generateStyleName() : null, a = XI({
        color: n,
        type: t,
        renderMode: i,
        markerId: r
      });
      return K(a) ? a : (process.env.NODE_ENV !== "production" && Q(r), this.richTextStyles[r] = a.style, a.content);
    }, e.prototype.wrapRichTextStyle = function(t, n) {
      var i = {};
      U(n) ? P(n, function(a) {
        return $(i, a);
      }) : $(i, n);
      var r = this._generateStyleName();
      return this.richTextStyles[r] = i, "{" + r + "|" + t + "}";
    }, e;
  })()
);
function vR(e) {
  var t = e.series, n = e.dataIndex, i = e.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), o = a.length, s = t.getRawValue(n), l = U(s), u = fR(t, n), c, h, d, f;
  if (o > 1 || l && !o) {
    var v = pR(s, t, n, a, u);
    c = v.inlineValues, h = v.inlineValueTypes, d = v.blocks, f = v.inlineValues[0];
  } else if (o) {
    var g = r.getDimensionInfo(a[0]);
    f = c = ju(r, n, a[0]), h = g.type;
  } else
    f = c = l ? s[0] : s;
  var p = D1(t), _ = p && t.name || "", m = r.getName(n), y = i ? _ : m;
  return sa("section", {
    header: _,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: i || !p,
    sortParam: f,
    blocks: [sa("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: y,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !Un(y),
      value: c,
      valueType: h,
      dataIndex: n
    })].concat(d || [])
  });
}
function pR(e, t, n, i, r) {
  var a = t.getData(), o = ho(e, function(h, d, f) {
    var v = a.getDimensionInfo(f);
    return h = h || v && v.tooltip !== !1 && v.displayName != null;
  }, !1), s = [], l = [], u = [];
  i.length ? P(i, function(h) {
    c(ju(a, n, h), h);
  }) : P(e, c);
  function c(h, d) {
    var f = a.getDimensionInfo(d);
    !f || f.otherDims.tooltip === !1 || (o ? u.push(sa("nameValue", {
      markerType: "subItem",
      markerColor: r,
      name: f.displayName,
      value: h,
      valueType: f.type
    })) : (s.push(h), l.push(f.type)));
  }
  return {
    inlineValues: s,
    inlineValueTypes: l,
    blocks: u
  };
}
var Ri = Wt();
function Bl(e, t) {
  return e.getName(t) || e.getId(t);
}
var gR = "__universalTransitionEnabled", ir = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n._selectedDataIndicesMap = {}, n;
    }
    return t.prototype.init = function(n, i, r) {
      this.seriesIndex = this.componentIndex, this.dataTask = _s({
        count: mR,
        reset: yR
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(n, r);
      var a = Ri(this).sourceManager = new iR(this);
      a.prepareSource();
      var o = this.getInitialData(n, r);
      m0(o, this), this.dataTask.context.data = o, process.env.NODE_ENV !== "production" && Q(o, "getInitialData returned invalid data."), Ri(this).dataBeforeProcessed = o, _0(this), this._initSelectedMapFromData(o);
    }, t.prototype.mergeDefaultAndTheme = function(n, i) {
      var r = Yu(this), a = r ? Sx(n) : {}, o = this.subType;
      Pt.hasClass(o) && (o += "Series"), re(n, i.getTheme().get(this.subType)), re(n, this.getDefaultOption()), j_(n, "label", ["show"]), this.fillDataTextStyle(n.data), r && Wu(n, a, r);
    }, t.prototype.mergeOption = function(n, i) {
      n = re(this.option, n, !0), this.fillDataTextStyle(n.data);
      var r = Yu(this);
      r && Wu(this.option, n, r);
      var a = Ri(this).sourceManager;
      a.dirty(), a.prepareSource();
      var o = this.getInitialData(n, i);
      m0(o, this), this.dataTask.dirty(), this.dataTask.context.data = o, Ri(this).dataBeforeProcessed = o, _0(this), this._initSelectedMapFromData(o);
    }, t.prototype.fillDataTextStyle = function(n) {
      if (n && !Le(n))
        for (var i = ["show"], r = 0; r < n.length; r++)
          n[r] && n[r].label && j_(n[r], "label", i);
    }, t.prototype.getInitialData = function(n, i) {
    }, t.prototype.appendData = function(n) {
      var i = this.getRawData();
      i.appendData(n.data);
    }, t.prototype.getData = function(n) {
      var i = Cf(this);
      if (i) {
        var r = i.context.data;
        return n == null || !r.getLinkedData ? r : r.getLinkedData(n);
      } else
        return Ri(this).data;
    }, t.prototype.getAllData = function() {
      var n = this.getData();
      return n && n.getLinkedDataAll ? n.getLinkedDataAll() : [{
        data: n
      }];
    }, t.prototype.setData = function(n) {
      var i = Cf(this);
      if (i) {
        var r = i.context;
        r.outputData = n, i !== this.dataTask && (r.data = n);
      }
      Ri(this).data = n;
    }, t.prototype.getEncode = function() {
      var n = this.get("encode", !0);
      if (n)
        return st(n);
    }, t.prototype.getSourceManager = function() {
      return Ri(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return Ri(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var n = this.get("colorBy");
      return n || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var n = this.coordinateSystem;
      return n && n.getBaseAxis && n.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(n, i, r, a) {
      var o = this.getData(), s = this.coordinateSystem, l = s && s.getAxis(n);
      if (!s || !l)
        return [];
      var u = l.dataToCoord(r);
      a == null && (a = 1 / 0);
      var c = [], h = 1 / 0, d = -1, f = 0;
      return o.each(i, function(v, g) {
        var p = l.dataToCoord(v), _ = u - p, m = Math.abs(_);
        m <= a && ((m < h || m === h && _ >= 0 && d < 0) && (h = m, d = _, f = 0), _ === d && (c[f++] = g));
      }), c.length = f, c;
    }, t.prototype.formatTooltip = function(n, i, r) {
      return vR({
        series: this,
        dataIndex: n,
        multipleSeries: i
      });
    }, t.prototype.isAnimationEnabled = function() {
      var n = this.ecModel;
      if (tt.node && !(n && n.ssr))
        return !1;
      var i = this.getShallow("animation");
      return i && this.getData().count() > this.getShallow("animationThreshold") && (i = !1), !!i;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(n, i, r) {
      var a = this.ecModel, o = tp.prototype.getColorFromPalette.call(this, n, i, r);
      return o || (o = a.getColorFromPalette(n, i, r)), o;
    }, t.prototype.coordDimToDataDim = function(n) {
      return this.getRawData().mapDimensionsAll(n);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(n, i) {
      this._innerSelect(this.getData(i), n);
    }, t.prototype.unselect = function(n, i) {
      var r = this.option.selectedMap;
      if (r) {
        var a = this.option.selectedMode, o = this.getData(i);
        if (a === "series" || r === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var s = 0; s < n.length; s++) {
          var l = n[s], u = Bl(o, l);
          r[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(n, i) {
      for (var r = [], a = 0; a < n.length; a++)
        r[0] = n[a], this.isSelected(n[a], i) ? this.unselect(r, i) : this.select(r, i);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var n = this._selectedDataIndicesMap, i = jt(n), r = [], a = 0; a < i.length; a++) {
        var o = n[i[a]];
        o >= 0 && r.push(o);
      }
      return r;
    }, t.prototype.isSelected = function(n, i) {
      var r = this.option.selectedMap;
      if (!r)
        return !1;
      var a = this.getData(i);
      return (r === "all" || r[Bl(a, n)]) && !a.getItemModel(n).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[gR])
        return !0;
      var n = this.option.universalTransition;
      return n ? n === !0 ? !0 : n && n.enabled : !1;
    }, t.prototype._innerSelect = function(n, i) {
      var r, a, o = this.option, s = o.selectedMode, l = i.length;
      if (!(!s || !l)) {
        if (s === "series")
          o.selectedMap = "all";
        else if (s === "multiple") {
          X(o.selectedMap) || (o.selectedMap = {});
          for (var u = o.selectedMap, c = 0; c < l; c++) {
            var h = i[c], d = Bl(n, h);
            u[d] = !0, this._selectedDataIndicesMap[d] = n.getRawIndex(h);
          }
        } else if (s === "single" || s === !0) {
          var f = i[l - 1], d = Bl(n, f);
          o.selectedMap = (r = {}, r[d] = !0, r), this._selectedDataIndicesMap = (a = {}, a[d] = n.getRawIndex(f), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(n) {
      if (!this.option.selectedMap) {
        var i = [];
        n.hasItemOption && n.each(function(r) {
          var a = n.getRawDataItem(r);
          a && a.selected && i.push(r);
        }), i.length > 0 && this._innerSelect(n, i);
      }
    }, t.registerClass = function(n) {
      return Pt.registerClass(n);
    }, t.protoInitialize = (function() {
      var n = t.prototype;
      n.type = "series.__base__", n.seriesIndex = 0, n.ignoreStyleOnData = !1, n.hasSymbolVisual = !1, n.defaultSymbol = "circle", n.visualStyleAccessPath = "itemStyle", n.visualDrawType = "fill";
    })(), t;
  })(Pt)
);
An(ir, H5);
An(ir, tp);
C1(ir, Pt);
function _0(e) {
  var t = e.name;
  D1(e) || (e.name = _R(e) || t);
}
function _R(e) {
  var t = e.getRawData(), n = t.mapDimensionsAll("seriesName"), i = [];
  return P(n, function(r) {
    var a = t.getDimensionInfo(r);
    a.displayName && i.push(a.displayName);
  }), i.join(" ");
}
function mR(e) {
  return e.model.getRawData().count();
}
function yR(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), bR;
}
function bR(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function m0(e, t) {
  P(cA(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(n) {
    e.wrapMethod(n, Pe(xR, t));
  });
}
function xR(e, t) {
  var n = Cf(e);
  return n && n.setOutputEnd((t || this).count()), t;
}
function Cf(e) {
  var t = (e.ecModel || {}).scheduler, n = t && t.getPipeline(e.uid);
  if (n) {
    var i = n.currentTask;
    if (i) {
      var r = i.agentStubMap;
      r && (i = r.get(e.uid));
    }
    return i;
  }
}
var Ti = (
  /** @class */
  (function() {
    function e() {
      this.group = new Dn(), this.uid = Ic("viewComponent");
    }
    return e.prototype.init = function(t, n) {
    }, e.prototype.render = function(t, n, i, r) {
    }, e.prototype.dispose = function(t, n) {
    }, e.prototype.updateView = function(t, n, i, r) {
    }, e.prototype.updateLayout = function(t, n, i, r) {
    }, e.prototype.updateVisual = function(t, n, i, r) {
    }, e.prototype.toggleBlurSeries = function(t, n, i) {
    }, e.prototype.eachRendered = function(t) {
      var n = this.group;
      n && n.traverse(t);
    }, e;
  })()
);
kv(Ti);
Cv(Ti);
function wR() {
  var e = Wt();
  return function(t) {
    var n = e(t), i = t.pipelineContext, r = !!n.large, a = !!n.progressiveRender, o = n.large = !!(i && i.large), s = n.progressiveRender = !!(i && i.progressiveRender);
    return (r !== o || a !== s) && "reset";
  };
}
var Xx = Wt(), SR = wR(), Zi = (
  /** @class */
  (function() {
    function e() {
      this.group = new Dn(), this.uid = Ic("viewChart"), this.renderTask = _s({
        plan: MR,
        reset: DR
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, n) {
    }, e.prototype.render = function(t, n, i, r) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, n, i, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && qt("Unknown dataType " + r.dataType);
        return;
      }
      b0(a, r, "emphasis");
    }, e.prototype.downplay = function(t, n, i, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && qt("Unknown dataType " + r.dataType);
        return;
      }
      b0(a, r, "normal");
    }, e.prototype.remove = function(t, n) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, n) {
    }, e.prototype.updateView = function(t, n, i, r) {
      this.render(t, n, i, r);
    }, e.prototype.updateLayout = function(t, n, i, r) {
      this.render(t, n, i, r);
    }, e.prototype.updateVisual = function(t, n, i, r) {
      this.render(t, n, i, r);
    }, e.prototype.eachRendered = function(t) {
      cx(this.group, t);
    }, e.markUpdateMethod = function(t, n) {
      Xx(t).updateMethod = n;
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.type = "chart";
    })(), e;
  })()
);
function y0(e, t, n) {
  e && so(e) && (t === "emphasis" ? Vu : $u)(e, n);
}
function b0(e, t, n) {
  var i = Xs(e, t), r = t && t.highlightKey != null ? SO(t.highlightKey) : null;
  i != null ? P(Ae(i), function(a) {
    y0(e.getItemGraphicEl(a), n, r);
  }) : e.eachItemGraphicEl(function(a) {
    y0(a, n, r);
  });
}
kv(Zi, ["dispose"]);
Cv(Zi);
function MR(e) {
  return SR(e.model);
}
function DR(e) {
  var t = e.model, n = e.ecModel, i = e.api, r = e.payload, a = t.pipelineContext.progressiveRender, o = e.view, s = r && Xx(r).updateMethod, l = a ? "incrementalPrepareRender" : s && o[s] ? s : "render";
  return l !== "render" && o[l](t, n, i, r), TR[l];
}
var TR = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, Xu = "\0__throttleOriginMethod", x0 = "\0__throttleRate", w0 = "\0__throttleType";
function qx(e, t, n) {
  var i, r = 0, a = 0, o = null, s, l, u, c;
  t = t || 0;
  function h() {
    a = (/* @__PURE__ */ new Date()).getTime(), o = null, e.apply(l, u || []);
  }
  var d = function() {
    for (var f = [], v = 0; v < arguments.length; v++)
      f[v] = arguments[v];
    i = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
    var g = c || t, p = c || n;
    c = null, s = i - (p ? r : a) - g, clearTimeout(o), p ? o = setTimeout(h, g) : s >= 0 ? h() : o = setTimeout(h, -s), r = i;
  };
  return d.clear = function() {
    o && (clearTimeout(o), o = null);
  }, d.debounceNextCall = function(f) {
    c = f;
  }, d;
}
function Zx(e, t, n, i) {
  var r = e[t];
  if (r) {
    var a = r[Xu] || r, o = r[w0], s = r[x0];
    if (s !== n || o !== i) {
      if (n == null || !i)
        return e[t] = a;
      r = e[t] = qx(a, n, i === "debounce"), r[Xu] = a, r[w0] = i, r[x0] = n;
    }
    return r;
  }
}
function Pf(e, t) {
  var n = e[t];
  n && n[Xu] && (n.clear && n.clear(), e[t] = n[Xu]);
}
var S0 = Wt(), M0 = {
  itemStyle: Ls(vx, !0),
  lineStyle: Ls(fx, !0)
}, kR = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function Kx(e, t) {
  var n = e.visualStyleMapper || M0[t];
  return n || (console.warn("Unknown style type '" + t + "'."), M0.itemStyle);
}
function Qx(e, t) {
  var n = e.visualDrawType || kR[t];
  return n || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var CR = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var n = e.getData(), i = e.visualStyleAccessPath || "itemStyle", r = e.getModel(i), a = Kx(e, i), o = a(r), s = r.getShallow("decal");
    s && (n.setVisual("decal", s), s.dirty = !0);
    var l = Qx(e, i), u = o[l], c = gt(u) ? u : null, h = o.fill === "auto" || o.stroke === "auto";
    if (!o[l] || c || h) {
      var d = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      o[l] || (o[l] = d, n.setVisual("colorFromPalette", !0)), o.fill = o.fill === "auto" || gt(o.fill) ? d : o.fill, o.stroke = o.stroke === "auto" || gt(o.stroke) ? d : o.stroke;
    }
    if (n.setVisual("style", o), n.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return n.setVisual("colorFromPalette", !1), {
        dataEach: function(f, v) {
          var g = e.getDataParams(v), p = $({}, o);
          p[l] = c(g), f.setItemVisual(v, "style", p);
        }
      };
  }
}, Oo = new Gt(), PR = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var n = e.getData(), i = e.visualStyleAccessPath || "itemStyle", r = Kx(e, i), a = n.getVisual("drawType");
      return {
        dataEach: n.hasItemOption ? function(o, s) {
          var l = o.getRawDataItem(s);
          if (l && l[i]) {
            Oo.option = l[i];
            var u = r(Oo), c = o.ensureUniqueItemVisual(s, "style");
            $(c, u), Oo.option.decal && (o.setItemVisual(s, "decal", Oo.option.decal), Oo.option.decal.dirty = !0), a in u && o.setItemVisual(s, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, AR = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = st();
    e.eachSeries(function(n) {
      var i = n.getColorBy();
      if (!n.isColorBySeries()) {
        var r = n.type + "-" + i, a = t.get(r);
        a || (a = {}, t.set(r, a)), S0(n).scope = a;
      }
    }), e.eachSeries(function(n) {
      if (!(n.isColorBySeries() || e.isSeriesFiltered(n))) {
        var i = n.getRawData(), r = {}, a = n.getData(), o = S0(n).scope, s = n.visualStyleAccessPath || "itemStyle", l = Qx(n, s);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          r[c] = u;
        }), i.each(function(u) {
          var c = r[u], h = a.getItemVisual(c, "colorFromPalette");
          if (h) {
            var d = a.ensureUniqueItemVisual(c, "style"), f = i.getName(u) || u + "", v = i.count();
            d[l] = n.getColorFromPalette(f, o, v);
          }
        });
      }
    });
  }
}, zl = Math.PI;
function ER(e, t) {
  t = t || {}, Qt(t, {
    text: "loading",
    textColor: St.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: St.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var n = new Dn(), i = new be({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  n.add(i);
  var r = new gn({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new be({
    style: {
      fill: "none"
    },
    textContent: r,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  n.add(a);
  var o;
  return t.showSpinner && (o = new Lc({
    shape: {
      startAngle: -zl / 2,
      endAngle: -zl / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), o.animateShape(!0).when(1e3, {
    endAngle: zl * 3 / 2
  }).start("circularInOut"), o.animateShape(!0).when(1e3, {
    startAngle: zl * 3 / 2
  }).delay(300).start("circularInOut"), n.add(o)), n.resize = function() {
    var s = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && s ? 10 : 0) - s) / 2 - (t.showSpinner && s ? 0 : 5 + s / 2) + (t.showSpinner ? 0 : s / 2) + (s ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && o.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), i.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, n.resize(), n;
}
var Jx = (
  /** @class */
  (function() {
    function e(t, n, i, r) {
      this._stageTaskMap = st(), this.ecInstance = t, this.api = n, i = this._dataProcessorHandlers = i.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = i.concat(r);
    }
    return e.prototype.restoreData = function(t, n) {
      t.restoreData(n), this._stageTaskMap.each(function(i) {
        var r = i.overallTask;
        r && r.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, n) {
      if (t.__pipeline) {
        var i = this._pipelineMap.get(t.__pipeline.id), r = i.context, a = !n && i.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > i.blockIndex, o = a ? i.step : null, s = r && r.modDataCount, l = s != null ? Math.ceil(s / o) : null;
        return {
          step: o,
          modBy: l,
          modDataCount: s
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, n) {
      var i = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), o = i.progressiveEnabled && n.incrementalPrepareRender && a >= i.threshold, s = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = i.context = {
        progressiveRender: o,
        modDataCount: l,
        large: s
      };
    }, e.prototype.restorePipelines = function(t) {
      var n = this, i = n._pipelineMap = st();
      t.eachSeries(function(r) {
        var a = r.getProgressive(), o = r.uid;
        i.set(o, {
          id: o,
          head: null,
          tail: null,
          threshold: r.getProgressiveThreshold(),
          progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), n._pipe(r, r.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, n = this.api.getModel(), i = this.api;
      P(this._allHandlers, function(r) {
        var a = t.get(r.uid) || t.set(r.uid, {}), o = "";
        process.env.NODE_ENV !== "production" && (o = '"reset" and "overallReset" must not be both specified.'), Q(!(r.reset && r.overallReset), o), r.reset && this._createSeriesStageTask(r, a, n, i), r.overallReset && this._createOverallStageTask(r, a, n, i);
      }, this);
    }, e.prototype.prepareView = function(t, n, i, r) {
      var a = t.renderTask, o = a.context;
      o.model = n, o.ecModel = i, o.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(n, a);
    }, e.prototype.performDataProcessorTasks = function(t, n) {
      this._performStageTasks(this._dataProcessorHandlers, t, n, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, n, i) {
      this._performStageTasks(this._visualHandlers, t, n, i);
    }, e.prototype._performStageTasks = function(t, n, i, r) {
      r = r || {};
      var a = !1, o = this;
      P(t, function(l, u) {
        if (!(r.visualType && r.visualType !== l.visualType)) {
          var c = o._stageTaskMap.get(l.uid), h = c.seriesTaskMap, d = c.overallTask;
          if (d) {
            var f, v = d.agentStubMap;
            v.each(function(p) {
              s(r, p) && (p.dirty(), f = !0);
            }), f && d.dirty(), o.updatePayload(d, i);
            var g = o.getPerformArgs(d, r.block);
            v.each(function(p) {
              p.perform(g);
            }), d.perform(g) && (a = !0);
          } else h && h.each(function(p, _) {
            s(r, p) && p.dirty();
            var m = o.getPerformArgs(p, r.block);
            m.skip = !l.performRawSeries && n.isSeriesFiltered(p.context.model), o.updatePayload(p, i), p.perform(m) && (a = !0);
          });
        }
      });
      function s(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var n;
      t.eachSeries(function(i) {
        n = i.dataTask.perform() || n;
      }), this.unfinished = n || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var n = t.tail;
        do {
          if (n.__block) {
            t.blockIndex = n.__idxInPipeline;
            break;
          }
          n = n.getUpstream();
        } while (n);
      });
    }, e.prototype.updatePayload = function(t, n) {
      n !== "remain" && (t.context.payload = n);
    }, e.prototype._createSeriesStageTask = function(t, n, i, r) {
      var a = this, o = n.seriesTaskMap, s = n.seriesTaskMap = st(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? i.eachRawSeries(c) : l ? i.eachRawSeriesByType(l, c) : u && u(i, r).each(c);
      function c(h) {
        var d = h.uid, f = s.set(d, o && o.get(d) || _s({
          plan: NR,
          reset: FR,
          count: zR
        }));
        f.context = {
          model: h,
          ecModel: i,
          api: r,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(h, f);
      }
    }, e.prototype._createOverallStageTask = function(t, n, i, r) {
      var a = this, o = n.overallTask = n.overallTask || _s({
        reset: LR
      });
      o.context = {
        ecModel: i,
        api: r,
        overallReset: t.overallReset,
        scheduler: a
      };
      var s = o.agentStubMap, l = o.agentStubMap = st(), u = t.seriesType, c = t.getTargetSeries, h = !0, d = !1, f = "";
      process.env.NODE_ENV !== "production" && (f = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), Q(!t.createOnAllSeries, f), u ? i.eachRawSeriesByType(u, v) : c ? c(i, r).each(v) : (h = !1, P(i.getSeries(), v));
      function v(g) {
        var p = g.uid, _ = l.set(p, s && s.get(p) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (d = !0, _s({
          reset: OR,
          onDirty: RR
        })));
        _.context = {
          model: g,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, _.agent = o, _.__block = h, a._pipe(g, _);
      }
      d && o.dirty();
    }, e.prototype._pipe = function(t, n) {
      var i = t.uid, r = this._pipelineMap.get(i);
      !r.head && (r.head = n), r.tail && r.tail.pipe(n), r.tail = n, n.__idxInPipeline = r.count++, n.__pipeline = r;
    }, e.wrapStageHandler = function(t, n) {
      return gt(t) && (t = {
        overallReset: t,
        seriesType: VR(t)
      }), t.uid = Ic("stageHandler"), n && (t.visualType = n), t;
    }, e;
  })()
);
function LR(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function OR(e) {
  return e.overallProgress && IR;
}
function IR() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function RR() {
  this.agent && this.agent.dirty();
}
function NR(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function FR(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = Ae(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? yt(t, function(n, i) {
    return tw(i);
  }) : BR;
}
var BR = tw(0);
function tw(e) {
  return function(t, n) {
    var i = n.data, r = n.resetDefines[e];
    if (r && r.dataEach)
      for (var a = t.start; a < t.end; a++)
        r.dataEach(i, a);
    else r && r.progress && r.progress(t, i);
  };
}
function zR(e) {
  return e.data.count();
}
function VR(e) {
  qu = null;
  try {
    e(Fs, ew);
  } catch {
  }
  return qu;
}
var Fs = {}, ew = {}, qu;
nw(Fs, ep);
nw(ew, Ax);
Fs.eachSeriesByType = Fs.eachRawSeriesByType = function(e) {
  qu = e;
};
Fs.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (qu = e.subType);
};
function nw(e, t) {
  for (var n in t.prototype)
    e[n] = ye;
}
var H = St.darkColor, $R = H.background, Io = function() {
  return {
    axisLine: {
      lineStyle: {
        color: H.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: H.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [H.backgroundTint, H.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: H.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: H.axisLabel
    },
    axisName: {}
  };
}, D0 = {
  label: {
    color: H.secondary
  },
  itemStyle: {
    borderColor: H.borderTint
  },
  dividerLineStyle: {
    color: H.border
  }
}, iw = {
  darkMode: !0,
  color: H.theme,
  backgroundColor: $R,
  axisPointer: {
    lineStyle: {
      color: H.border
    },
    crossStyle: {
      color: H.borderShade
    },
    label: {
      color: H.tertiary
    }
  },
  legend: {
    textStyle: {
      color: H.secondary
    },
    pageTextStyle: {
      color: H.tertiary
    }
  },
  textStyle: {
    color: H.secondary
  },
  title: {
    textStyle: {
      color: H.primary
    },
    subtextStyle: {
      color: H.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: H.accent50
    }
  },
  tooltip: {
    backgroundColor: H.neutral20,
    defaultBorderColor: H.border,
    textStyle: {
      color: H.tertiary
    }
  },
  dataZoom: {
    borderColor: H.accent10,
    textStyle: {
      color: H.tertiary
    },
    brushStyle: {
      color: H.backgroundTint
    },
    handleStyle: {
      color: H.neutral00,
      borderColor: H.accent20
    },
    moveHandleStyle: {
      color: H.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: H.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: H.accent30
      },
      areaStyle: {
        color: H.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: H.accent50
      },
      areaStyle: {
        color: H.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: H.secondary
    },
    handleStyle: {
      borderColor: H.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: H.accent10
    },
    label: {
      color: H.tertiary
    },
    controlStyle: {
      color: H.accent30,
      borderColor: H.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: H.neutral00,
      borderColor: H.neutral20
    },
    dayLabel: {
      color: H.tertiary
    },
    monthLabel: {
      color: H.secondary
    },
    yearLabel: {
      color: H.secondary
    }
  },
  matrix: {
    x: D0,
    y: D0,
    backgroundColor: {
      borderColor: H.axisLine
    },
    body: {
      itemStyle: {
        borderColor: H.borderTint
      }
    }
  },
  timeAxis: Io(),
  logAxis: Io(),
  valueAxis: Io(),
  categoryAxis: Io(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: H.theme
  },
  gauge: {
    title: {
      color: H.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, H.neutral05]]
      }
    },
    axisLabel: {
      color: H.axisLabel
    },
    detail: {
      color: H.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: H.background
    }
  },
  radar: (function() {
    var e = Io();
    return e.axisName = {
      color: H.axisLabel
    }, e.axisLine.lineStyle.color = H.neutral20, e;
  })(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: H.neutral20,
        textStyle: {
          color: H.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: H.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: H.background
    }
  },
  map: {
    itemStyle: {
      borderColor: H.border,
      areaColor: H.neutral10
    },
    label: {
      color: H.tertiary
    },
    emphasis: {
      label: {
        color: H.primary
      },
      itemStyle: {
        areaColor: H.highlight
      }
    },
    select: {
      label: {
        color: H.primary
      },
      itemStyle: {
        areaColor: H.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: H.border,
      areaColor: H.neutral10
    },
    emphasis: {
      label: {
        color: H.primary
      },
      itemStyle: {
        areaColor: H.highlight
      }
    },
    select: {
      label: {
        color: H.primary
      },
      itemStyle: {
        color: H.highlight
      }
    }
  }
};
iw.categoryAxis.splitLine.show = !1;
var HR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var n = {}, i = {}, r = {};
      if (K(t)) {
        var a = Gn(t);
        n.mainType = a.main || null, n.subType = a.sub || null;
      } else {
        var o = ["Index", "Name", "Id"], s = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        P(t, function(l, u) {
          for (var c = !1, h = 0; h < o.length; h++) {
            var d = o[h], f = u.lastIndexOf(d);
            if (f > 0 && f === u.length - d.length) {
              var v = u.slice(0, f);
              v !== "data" && (n.mainType = v, n[d.toLowerCase()] = l, c = !0);
            }
          }
          s.hasOwnProperty(u) && (i[u] = l, c = !0), c || (r[u] = l);
        });
      }
      return {
        cptQuery: n,
        dataQuery: i,
        otherQuery: r
      };
    }, e.prototype.filter = function(t, n) {
      var i = this.eventInfo;
      if (!i)
        return !0;
      var r = i.targetEl, a = i.packedEvent, o = i.model, s = i.view;
      if (!o || !s)
        return !0;
      var l = n.cptQuery, u = n.dataQuery;
      return c(l, o, "mainType") && c(l, o, "subType") && c(l, o, "index", "componentIndex") && c(l, o, "name") && c(l, o, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!s.filterForExposedEvent || s.filterForExposedEvent(t, n.otherQuery, r, a));
      function c(h, d, f, v) {
        return h[f] == null || d[v || f] === h[f];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  })()
), Af = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], T0 = Af.concat(["symbolKeepAspect"]), YR = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var n = e.getData();
    if (e.legendIcon && n.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var i = {}, r = {}, a = !1, o = 0; o < Af.length; o++) {
      var s = Af[o], l = e.get(s);
      gt(l) ? (a = !0, r[s] = l) : i[s] = l;
    }
    if (i.symbol = i.symbol || e.defaultSymbol, n.setVisual($({
      legendIcon: e.legendIcon || i.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, i)), t.isSeriesFiltered(e))
      return;
    var u = jt(r);
    function c(h, d) {
      for (var f = e.getRawValue(d), v = e.getDataParams(d), g = 0; g < u.length; g++) {
        var p = u[g];
        h.setItemVisual(d, p, r[p](f, v));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, WR = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var n = e.getData();
    function i(r, a) {
      for (var o = r.getItemModel(a), s = 0; s < T0.length; s++) {
        var l = T0[s], u = o.getShallow(l, !0);
        u != null && r.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: n.hasItemOption ? i : null
    };
  }
};
function UR(e, t, n) {
  switch (n) {
    case "color":
      var i = e.getItemVisual(t, "style");
      return i[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, n);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + n);
  }
}
function GR(e, t) {
  switch (t) {
    case "color":
      var n = e.getVisual("style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Ca(e, t, n, i, r) {
  var a = e + t;
  n.isSilent(a) || (process.env.NODE_ENV !== "production" && Di("event " + a + " is deprecated."), i.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(o) {
    for (var s = o.seriesIndex, l = o.option.selectedMap, u = r.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === s) {
        var h = o.getData(), d = Xs(h, r.fromActionPayload);
        n.trigger(a, {
          type: a,
          seriesId: o.id,
          name: U(d) ? h.getName(d[0]) : h.getName(d),
          selected: K(l) ? l : $({}, l)
        });
      }
  }));
}
function jR(e, t, n) {
  e.on("selectchanged", function(i) {
    var r = n.getModel();
    i.isFromClick ? (Ca("map", "selectchanged", t, r, i), Ca("pie", "selectchanged", t, r, i)) : i.fromAction === "select" ? (Ca("map", "selected", t, r, i), Ca("pie", "selected", t, r, i)) : i.fromAction === "unselect" && (Ca("map", "unselected", t, r, i), Ca("pie", "unselected", t, r, i));
  });
}
function is(e, t, n) {
  for (var i; e && !(t(e) && (i = e, n)); )
    e = e.__hostTarget || e.parent;
  return i;
}
var XR = Math.round(Math.random() * 9), qR = typeof Object.defineProperty == "function", ZR = (function() {
  function e() {
    this._id = "__ec_inner_" + XR++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, n) {
    var i = this._guard(t);
    return qR ? Object.defineProperty(i, this._id, {
      value: n,
      enumerable: !1,
      configurable: !0
    }) : i[this._id] = n, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
})(), KR = It.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var n = t.cx, i = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(n, i - a), e.lineTo(n + r, i + a), e.lineTo(n - r, i + a), e.closePath();
  }
}), QR = It.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var n = t.cx, i = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(n, i - a), e.lineTo(n + r, i), e.lineTo(n, i + a), e.lineTo(n - r, i), e.closePath();
  }
}), JR = It.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var n = t.x, i = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), o = r / 2, s = o * o / (a - o), l = i - a + o + s, u = Math.asin(s / o), c = Math.cos(u) * o, h = Math.sin(u), d = Math.cos(u), f = o * 0.6, v = o * 0.7;
    e.moveTo(n - c, l + s), e.arc(n, l, o, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(n + c - h * f, l + s + d * f, n, i - v, n, i), e.bezierCurveTo(n, i - v, n - c + h * f, l + s + d * f, n - c, l + s), e.closePath();
  }
}), tN = It.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var n = t.height, i = t.width, r = t.x, a = t.y, o = i / 3 * 2;
    e.moveTo(r, a), e.lineTo(r + o, a + n), e.lineTo(r, a + n / 4 * 3), e.lineTo(r - o, a + n), e.lineTo(r, a), e.closePath();
  }
}), eN = {
  line: vo,
  rect: be,
  roundRect: be,
  square: be,
  circle: Ec,
  diamond: QR,
  pin: JR,
  arrow: tN,
  triangle: KR
}, nN = {
  line: function(e, t, n, i, r) {
    r.x1 = e, r.y1 = t + i / 2, r.x2 = e + n, r.y2 = t + i / 2;
  },
  rect: function(e, t, n, i, r) {
    r.x = e, r.y = t, r.width = n, r.height = i;
  },
  roundRect: function(e, t, n, i, r) {
    r.x = e, r.y = t, r.width = n, r.height = i, r.r = Math.min(n, i) / 4;
  },
  square: function(e, t, n, i, r) {
    var a = Math.min(n, i);
    r.x = e, r.y = t, r.width = a, r.height = a;
  },
  circle: function(e, t, n, i, r) {
    r.cx = e + n / 2, r.cy = t + i / 2, r.r = Math.min(n, i) / 2;
  },
  diamond: function(e, t, n, i, r) {
    r.cx = e + n / 2, r.cy = t + i / 2, r.width = n, r.height = i;
  },
  pin: function(e, t, n, i, r) {
    r.x = e + n / 2, r.y = t + i / 2, r.width = n, r.height = i;
  },
  arrow: function(e, t, n, i, r) {
    r.x = e + n / 2, r.y = t + i / 2, r.width = n, r.height = i;
  },
  triangle: function(e, t, n, i, r) {
    r.cx = e + n / 2, r.cy = t + i / 2, r.width = n, r.height = i;
  }
}, Ef = {};
P(eN, function(e, t) {
  Ef[t] = new e();
});
var iN = It.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, n) {
    var i = p1(e, t, n), r = this.shape;
    return r && r.symbolType === "pin" && t.position === "inside" && (i.y = n.y + n.height * 0.4), i;
  },
  buildPath: function(e, t, n) {
    var i = t.symbolType;
    if (i !== "none") {
      var r = Ef[i];
      r || (i = "rect", r = Ef[i]), nN[i](t.x, t.y, t.width, t.height, r.shape), r.buildPath(e, r.shape, n);
    }
  }
});
function rN(e, t) {
  if (this.type !== "image") {
    var n = this.style;
    this.__isEmptyBrush ? (n.stroke = e, n.fill = t || St.color.neutral00, n.lineWidth = 2) : this.shape.symbolType === "line" ? n.stroke = e : n.fill = e, this.markRedraw();
  }
}
function rw(e, t, n, i, r, a, o) {
  var s = e.indexOf("empty") === 0;
  s && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = ax(e.slice(8), new it(t, n, i, r), o ? "center" : "cover") : e.indexOf("path://") === 0 ? l = Wv(e.slice(7), {}, new it(t, n, i, r), o ? "center" : "cover") : l = new iN({
    shape: {
      symbolType: e,
      x: t,
      y: n,
      width: i,
      height: r
    }
  }), l.__isEmptyBrush = s, l.setColor = rN, a && l.setColor(a), l;
}
function aN(e, t) {
  if (e != null)
    return U(e) || (e = [e, e]), [Ve(e[0], t[0]) || 0, Ve(J(e[1], e[0]), t[1]) || 0];
}
function Wr(e) {
  return isFinite(e);
}
function oN(e, t, n) {
  var i = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, o = t.y2 == null ? 0 : t.y2;
  t.global || (i = i * n.width + n.x, r = r * n.width + n.x, a = a * n.height + n.y, o = o * n.height + n.y), i = Wr(i) ? i : 0, r = Wr(r) ? r : 1, a = Wr(a) ? a : 0, o = Wr(o) ? o : 0;
  var s = e.createLinearGradient(i, a, r, o);
  return s;
}
function sN(e, t, n) {
  var i = n.width, r = n.height, a = Math.min(i, r), o = t.x == null ? 0.5 : t.x, s = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (o = o * i + n.x, s = s * r + n.y, l = l * a), o = Wr(o) ? o : 0.5, s = Wr(s) ? s : 0.5, l = l >= 0 && Wr(l) ? l : 0.5;
  var u = e.createRadialGradient(o, s, 0, o, s, l);
  return u;
}
function Lf(e, t, n) {
  for (var i = t.type === "radial" ? sN(e, t, n) : oN(e, t, n), r = t.colorStops, a = 0; a < r.length; a++)
    i.addColorStop(r[a].offset, r[a].color);
  return i;
}
function lN(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var n = 0; n < e.length; n++)
    if (e[n] !== t[n])
      return !0;
  return !1;
}
function Vl(e) {
  return parseInt(e, 10);
}
function $l(e, t, n) {
  var i = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], o = ["paddingRight", "paddingBottom"][t];
  if (n[i] != null && n[i] !== "auto")
    return parseFloat(n[i]);
  var s = document.defaultView.getComputedStyle(e);
  return (e[r] || Vl(s[i]) || Vl(e.style[i])) - (Vl(s[a]) || 0) - (Vl(s[o]) || 0) | 0;
}
function uN(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : Xt(e) ? [e] : U(e) ? e : null;
}
function aw(e) {
  var t = e.style, n = t.lineDash && t.lineWidth > 0 && uN(t.lineDash, t.lineWidth), i = t.lineDashOffset;
  if (n) {
    var r = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    r && r !== 1 && (n = yt(n, function(a) {
      return a / r;
    }), i /= r);
  }
  return [n, i];
}
var cN = new oo(!0);
function Zu(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function k0(e) {
  return typeof e == "string" && e !== "none";
}
function Ku(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function C0(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var n = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = n;
  } else
    e.fill();
}
function P0(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var n = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = n;
  } else
    e.stroke();
}
function Of(e, t, n) {
  var i = P1(t.image, t.__image, n);
  if (Cc(i)) {
    var r = e.createPattern(i, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && r && r.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * hA), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
    }
    return r;
  }
}
function hN(e, t, n, i) {
  var r, a = Zu(n), o = Ku(n), s = n.strokePercent, l = s < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || cN, h = t.__dirty;
  if (!i) {
    var d = n.fill, f = n.stroke, v = o && !!d.colorStops, g = a && !!f.colorStops, p = o && !!d.image, _ = a && !!f.image, m = void 0, y = void 0, b = void 0, x = void 0, w = void 0;
    (v || g) && (w = t.getBoundingRect()), v && (m = h ? Lf(e, d, w) : t.__canvasFillGradient, t.__canvasFillGradient = m), g && (y = h ? Lf(e, f, w) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = y), p && (b = h || !t.__canvasFillPattern ? Of(e, d, t) : t.__canvasFillPattern, t.__canvasFillPattern = b), _ && (x = h || !t.__canvasStrokePattern ? Of(e, f, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = x), v ? e.fillStyle = m : p && (b ? e.fillStyle = b : o = !1), g ? e.strokeStyle = y : _ && (x ? e.strokeStyle = x : a = !1);
  }
  var M = t.getGlobalScale();
  c.setScale(M[0], M[1], t.segmentIgnoreThreshold);
  var D, T;
  e.setLineDash && n.lineDash && (r = aw(t), D = r[0], T = r[1]);
  var C = !0;
  (u || h & Na) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), C = !1), c.reset(), t.buildPath(c, t.shape, i), c.toStatic(), t.pathUpdated()), C && c.rebuildPath(e, l ? s : 1), D && (e.setLineDash(D), e.lineDashOffset = T), i || (n.strokeFirst ? (a && P0(e, n), o && C0(e, n)) : (o && C0(e, n), a && P0(e, n))), D && e.setLineDash([]);
}
function dN(e, t, n) {
  var i = t.__image = P1(n.image, t.__image, t, t.onload);
  if (!(!i || !Cc(i))) {
    var r = n.x || 0, a = n.y || 0, o = t.getWidth(), s = t.getHeight(), l = i.width / i.height;
    if (o == null && s != null ? o = s * l : s == null && o != null ? s = o / l : o == null && s == null && (o = i.width, s = i.height), n.sWidth && n.sHeight) {
      var u = n.sx || 0, c = n.sy || 0;
      e.drawImage(i, u, c, n.sWidth, n.sHeight, r, a, o, s);
    } else if (n.sx && n.sy) {
      var u = n.sx, c = n.sy, h = o - u, d = s - c;
      e.drawImage(i, u, c, h, d, r, a, o, s);
    } else
      e.drawImage(i, r, a, o, s);
  }
}
function fN(e, t, n) {
  var i, r = n.text;
  if (r != null && (r += ""), r) {
    e.font = n.font || tr, e.textAlign = n.textAlign, e.textBaseline = n.textBaseline;
    var a = void 0, o = void 0;
    e.setLineDash && n.lineDash && (i = aw(t), a = i[0], o = i[1]), a && (e.setLineDash(a), e.lineDashOffset = o), n.strokeFirst ? (Zu(n) && e.strokeText(r, n.x, n.y), Ku(n) && e.fillText(r, n.x, n.y)) : (Ku(n) && e.fillText(r, n.x, n.y), Zu(n) && e.strokeText(r, n.x, n.y)), a && e.setLineDash([]);
  }
}
var A0 = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], E0 = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function ow(e, t, n, i, r) {
  var a = !1;
  if (!i && (n = n || {}, t === n))
    return !1;
  if (i || t.opacity !== n.opacity) {
    Ye(e, r), a = !0;
    var o = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(o) ? ta.opacity : o;
  }
  (i || t.blend !== n.blend) && (a || (Ye(e, r), a = !0), e.globalCompositeOperation = t.blend || ta.blend);
  for (var s = 0; s < A0.length; s++) {
    var l = A0[s];
    (i || t[l] !== n[l]) && (a || (Ye(e, r), a = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (i || t.shadowColor !== n.shadowColor) && (a || (Ye(e, r), a = !0), e.shadowColor = t.shadowColor || ta.shadowColor), a;
}
function L0(e, t, n, i, r) {
  var a = Bs(t, r.inHover), o = i ? null : n && Bs(n, r.inHover) || {};
  if (a === o)
    return !1;
  var s = ow(e, a, o, i, r);
  if ((i || a.fill !== o.fill) && (s || (Ye(e, r), s = !0), k0(a.fill) && (e.fillStyle = a.fill)), (i || a.stroke !== o.stroke) && (s || (Ye(e, r), s = !0), k0(a.stroke) && (e.strokeStyle = a.stroke)), (i || a.opacity !== o.opacity) && (s || (Ye(e, r), s = !0), e.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (s || (Ye(e, r), s = !0), e.lineWidth = u);
  }
  for (var c = 0; c < E0.length; c++) {
    var h = E0[c], d = h[0];
    (i || a[d] !== o[d]) && (s || (Ye(e, r), s = !0), e[d] = a[d] || h[1]);
  }
  return s;
}
function vN(e, t, n, i, r) {
  return ow(e, Bs(t, r.inHover), n && Bs(n, r.inHover), i, r);
}
function sw(e, t) {
  var n = t.transform, i = e.dpr || 1;
  n ? e.setTransform(i * n[0], i * n[1], i * n[2], i * n[3], i * n[4], i * n[5]) : e.setTransform(i, 0, 0, i, 0, 0);
}
function pN(e, t, n) {
  for (var i = !1, r = 0; r < e.length; r++) {
    var a = e[r];
    i = i || a.isZeroArea(), sw(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  n.allClipped = i;
}
function gN(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var O0 = 1, I0 = 2, R0 = 3, N0 = 4;
function _N(e) {
  var t = Ku(e), n = Zu(e);
  return !(e.lineDash || !(+t ^ +n) || t && typeof e.fill != "string" || n && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function Ye(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function Bs(e, t) {
  return t && e.__hoverStyle || e.style;
}
function lw(e, t) {
  Ur(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Ur(e, t, n, i) {
  var r = t.transform;
  if (!t.shouldBePainted(n.viewWidth, n.viewHeight, !1, !1)) {
    t.__dirty &= ~Ze, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, o = n.prevElClipPaths, s = !1, l = !1;
  if ((!o || lN(a, o)) && (o && o.length && (Ye(e, n), e.restore(), l = s = !0, n.prevElClipPaths = null, n.allClipped = !1, n.prevEl = null), a && a.length && (Ye(e, n), e.save(), pN(a, e, n), s = !0), n.prevElClipPaths = a), n.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = n.prevEl;
  u || (l = s = !0);
  var c = t instanceof It && t.autoBatch && _N(t.style);
  s || gN(r, u.transform) ? (Ye(e, n), sw(e, t)) : c || Ye(e, n);
  var h = Bs(t, n.inHover);
  t instanceof It ? (n.lastDrawType !== O0 && (l = !0, n.lastDrawType = O0), L0(e, t, u, l, n), (!c || !n.batchFill && !n.batchStroke) && e.beginPath(), hN(e, t, h, c), c && (n.batchFill = h.fill || "", n.batchStroke = h.stroke || "")) : t instanceof Fu ? (n.lastDrawType !== R0 && (l = !0, n.lastDrawType = R0), L0(e, t, u, l, n), fN(e, t, h)) : t instanceof ua ? (n.lastDrawType !== I0 && (l = !0, n.lastDrawType = I0), vN(e, t, u, l, n), dN(e, t, h)) : t.getTemporalDisplayables && (n.lastDrawType !== N0 && (l = !0, n.lastDrawType = N0), mN(e, t, n)), c && i && Ye(e, n), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), n.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function mN(e, t, n) {
  var i = t.getDisplayables(), r = t.getTemporalDisplayables();
  e.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: n.viewWidth,
    viewHeight: n.viewHeight,
    inHover: n.inHover
  }, o, s;
  for (o = t.getCursor(), s = i.length; o < s; o++) {
    var l = i[o];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ur(e, l, a, o === s - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = r.length; u < c; u++) {
    var l = r[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Ur(e, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var cd = new ZR(), F0 = new io(100), B0 = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function z0(e, t) {
  if (e === "none")
    return null;
  var n = t.getDevicePixelRatio(), i = t.getZr(), r = i.painter.type === "svg";
  e.dirty && cd.delete(e);
  var a = cd.get(e);
  if (a)
    return a;
  var o = Qt(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  o.backgroundColor === "none" && (o.backgroundColor = null);
  var s = {
    repeat: "repeat"
  };
  return l(s), s.rotation = o.rotation, s.scaleX = s.scaleY = r ? 1 : 1 / n, cd.set(e, s), e.dirty = !1, s;
  function l(u) {
    for (var c = [n], h = !0, d = 0; d < B0.length; ++d) {
      var f = o[B0[d]];
      if (f != null && !U(f) && !K(f) && !Xt(f) && typeof f != "boolean") {
        h = !1;
        break;
      }
      c.push(f);
    }
    var v;
    if (h) {
      v = c.join(",") + (r ? "-svg" : "");
      var g = F0.get(v);
      g && (r ? u.svgElement = g : u.image = g);
    }
    var p = cw(o.dashArrayX), _ = yN(o.dashArrayY), m = uw(o.symbol), y = bN(p), b = hw(_), x = !r && Mi.createCanvas(), w = r && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, M = T(), D;
    x && (x.width = M.width * n, x.height = M.height * n, D = x.getContext("2d")), C(), h && F0.put(v, x || w), u.image = x, u.svgElement = w, u.svgWidth = M.width, u.svgHeight = M.height;
    function T() {
      for (var k = 1, E = 0, A = y.length; E < A; ++E)
        k = U_(k, y[E]);
      for (var L = 1, E = 0, A = m.length; E < A; ++E)
        L = U_(L, m[E].length);
      k *= L;
      var R = b * y.length * m.length;
      if (process.env.NODE_ENV !== "production") {
        var N = function(V) {
          console.warn("Calculated decal size is greater than " + V + " due to decal option settings so " + V + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + V + " to be larger to avoid incontinuity.");
        };
        k > o.maxTileWidth && N("maxTileWidth"), R > o.maxTileHeight && N("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(k, o.maxTileWidth)),
        height: Math.max(1, Math.min(R, o.maxTileHeight))
      };
    }
    function C() {
      D && (D.clearRect(0, 0, x.width, x.height), o.backgroundColor && (D.fillStyle = o.backgroundColor, D.fillRect(0, 0, x.width, x.height)));
      for (var k = 0, E = 0; E < _.length; ++E)
        k += _[E];
      if (k <= 0)
        return;
      for (var A = -b, L = 0, R = 0, N = 0; A < M.height; ) {
        if (L % 2 === 0) {
          for (var V = R / 2 % m.length, q = 0, W = 0, Z = 0; q < M.width * 2; ) {
            for (var bt = 0, E = 0; E < p[N].length; ++E)
              bt += p[N][E];
            if (bt <= 0)
              break;
            if (W % 2 === 0) {
              var et = (1 - o.symbolSize) * 0.5, at = q + p[N][W] * et, ht = A + _[L] * et, Ht = p[N][W] * o.symbolSize, Rt = _[L] * o.symbolSize, Oe = Z / 2 % m[V].length;
              Ue(at, ht, Ht, Rt, m[V][Oe]);
            }
            q += p[N][W], ++Z, ++W, W === p[N].length && (W = 0);
          }
          ++N, N === p.length && (N = 0);
        }
        A += _[L], ++R, ++L, L === _.length && (L = 0);
      }
      function Ue(De, oe, nt, _t, or) {
        var Te = r ? 1 : n, Hp = rw(or, De * Te, oe * Te, nt * Te, _t * Te, o.color, o.symbolKeepAspect);
        if (r) {
          var Yp = i.painter.renderOneToVNode(Hp);
          Yp && w.children.push(Yp);
        } else
          lw(D, Hp);
      }
    }
  }
}
function uw(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (K(e))
    return [[e]];
  for (var t = !0, n = 0; n < e.length; ++n)
    if (!K(e[n])) {
      t = !1;
      break;
    }
  if (t)
    return uw([e]);
  for (var i = [], n = 0; n < e.length; ++n)
    K(e[n]) ? i.push([e[n]]) : i.push(e[n]);
  return i;
}
function cw(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if (Xt(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var n = !0, i = 0; i < e.length; ++i)
    if (!Xt(e[i])) {
      n = !1;
      break;
    }
  if (n)
    return cw([e]);
  for (var r = [], i = 0; i < e.length; ++i)
    if (Xt(e[i])) {
      var t = Math.ceil(e[i]);
      r.push([t, t]);
    } else {
      var t = yt(e[i], function(s) {
        return Math.ceil(s);
      });
      t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
    }
  return r;
}
function yN(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if (Xt(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var n = yt(e, function(i) {
    return Math.ceil(i);
  });
  return e.length % 2 ? n.concat(n) : n;
}
function bN(e) {
  return yt(e, function(t) {
    return hw(t);
  });
}
function hw(e) {
  for (var t = 0, n = 0; n < e.length; ++n)
    t += e[n];
  return e.length % 2 === 1 ? t * 2 : t;
}
function xN(e, t) {
  e.eachRawSeries(function(n) {
    if (!e.isSeriesFiltered(n)) {
      var i = n.getData();
      i.hasItemVisual() && i.each(function(o) {
        var s = i.getItemVisual(o, "decal");
        if (s) {
          var l = i.ensureUniqueItemVisual(o, "style");
          l.decal = z0(s, t);
        }
      });
      var r = i.getVisual("decal");
      if (r) {
        var a = i.getVisual("style");
        a.decal = z0(r, t);
      }
    }
  });
}
var xn = new En(), Qu = {};
function wN(e, t) {
  process.env.NODE_ENV !== "production" && Qu[e] && qt("Already has an implementation of " + e + "."), Qu[e] = t;
}
function SN(e) {
  return process.env.NODE_ENV !== "production" && (Qu[e] || qt("Implementation of " + e + " doesn't exists.")), Qu[e];
}
var MN = 1, DN = 800, TN = 900, kN = 1e3, CN = 2e3, PN = 5e3, dw = 1e3, AN = 1100, ap = 2e3, fw = 3e3, EN = 4e3, Bc = 4500, LN = 4600, ON = 5e3, IN = 6e3, vw = 7e3, RN = {
  PROCESSOR: {
    FILTER: kN,
    SERIES_FILTER: DN,
    STATISTIC: PN
  },
  VISUAL: {
    LAYOUT: dw,
    PROGRESSIVE_LAYOUT: AN,
    GLOBAL: ap,
    CHART: fw,
    POST_CHART_LAYOUT: LN,
    COMPONENT: EN,
    BRUSH: ON,
    CHART_ITEM: Bc,
    ARIA: IN,
    DECAL: vw
  }
}, ne = "__flagInMainProcess", Hl = "__mainProcessVersion", ue = "__pendingUpdate", hd = "__needsUpdateStatus", V0 = /^[a-zA-Z0-9_]+$/, dd = "__connectUpdateStatus", $0 = 0, NN = 1, FN = 2;
function pw(e) {
  return function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    if (this.isDisposed()) {
      Ne(this.id);
      return;
    }
    return _w(this, e, t);
  };
}
function gw(e) {
  return function() {
    for (var t = [], n = 0; n < arguments.length; n++)
      t[n] = arguments[n];
    return _w(this, e, t);
  };
}
function _w(e, t, n) {
  return n[0] = n[0] && n[0].toLowerCase(), En.prototype[t].apply(e, n);
}
var mw = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  })(En)
), yw = mw.prototype;
yw.on = gw("on");
yw.off = gw("off");
var Lr, fd, Yl, oi, Wl, vd, pd, Pa, Aa, H0, Y0, gd, W0, Ul, U0, bw, nn, G0, Ea, xw = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(n, i, r) {
      var a = e.call(this, new HR()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, a._dom = n;
      var o = "canvas", s = "auto", l = !1;
      if (a[Hl] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          tt.hasGlobalWindow ? window : global
        );
        u && (o = J(u.__ECHARTS__DEFAULT__RENDERER__, o), s = J(u.__ECHARTS__DEFAULT__COARSE_POINTER, s), l = J(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      r.ssr;
      var c = a._zr = H_(n, {
        renderer: r.renderer || o,
        devicePixelRatio: r.devicePixelRatio,
        width: r.width,
        height: r.height,
        ssr: r.ssr,
        useDirtyRect: J(r.useDirtyRect, l),
        useCoarsePointer: J(r.useCoarsePointer, s),
        pointerSize: r.pointerSize
      });
      a._ssr = r.ssr, a._throttledZrFlush = qx(Tt(c.flush, c), 17), a._updateTheme(i), a._locale = FI(r.locale || px), a._coordSysMgr = new Rc();
      var h = a._api = U0(a);
      function d(f, v) {
        return f.__prio - v.__prio;
      }
      return eu(ec, d), eu(Rf, d), a._scheduler = new Jx(a, h, Rf, ec), a._messageCenter = new mw(), a._initEvents(), a.resize = Tt(a.resize, a), c.animation.on("frame", a._onframe, a), H0(c, a), Y0(c, a), Yd(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        G0(this);
        var n = this._scheduler;
        if (this[ue]) {
          var i = this[ue].silent;
          this[ne] = !0, Ea(this);
          try {
            Lr(this), oi.update.call(this, null, this[ue].updateParams);
          } catch (l) {
            throw this[ne] = !1, this[ue] = null, l;
          }
          this._zr.flush(), this[ne] = !1, this[ue] = null, Pa.call(this, i), Aa.call(this, i);
        } else if (n.unfinished) {
          var r = MN, a = this._model, o = this._api;
          n.unfinished = !1;
          do {
            var s = +/* @__PURE__ */ new Date();
            n.performSeriesTasks(a), n.performDataProcessorTasks(a), vd(this, a), n.performVisualTasks(a), Ul(this, this._model, o, "remain", {}), r -= +/* @__PURE__ */ new Date() - s;
          } while (r > 0 && n.unfinished);
          n.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(n, i, r) {
      if (this[ne]) {
        process.env.NODE_ENV !== "production" && qt("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      var a, o, s;
      if (X(i) && (r = i.lazyUpdate, a = i.silent, o = i.replaceMerge, s = i.transition, i = i.notMerge), this[ne] = !0, Ea(this), !this._model || i) {
        var l = new b5(this._api), u = this._theme, c = this._model = new ep();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(n, {
        replaceMerge: o
      }, Nf);
      var h = {
        seriesTransition: s,
        optionChanged: !0
      };
      if (r)
        this[ue] = {
          silent: a,
          updateParams: h
        }, this[ne] = !1, this.getZr().wakeUp();
      else {
        try {
          Lr(this), oi.update.call(this, null, h);
        } catch (d) {
          throw this[ue] = null, this[ne] = !1, d;
        }
        this._ssr || this._zr.flush(), this[ue] = null, this[ne] = !1, Pa.call(this, a), Aa.call(this, a);
      }
    }, t.prototype.setTheme = function(n, i) {
      if (this[ne]) {
        process.env.NODE_ENV !== "production" && qt("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      var r = this._model;
      if (r) {
        var a = i && i.silent, o = null;
        this[ue] && (a == null && (a = this[ue].silent), o = this[ue].updateParams, this[ue] = null), this[ne] = !0, Ea(this);
        try {
          this._updateTheme(n), r.setTheme(this._theme), Lr(this), oi.update.call(this, {
            type: "setTheme"
          }, o);
        } catch (s) {
          throw this[ne] = !1, s;
        }
        this[ne] = !1, Pa.call(this, a), Aa.call(this, a);
      }
    }, t.prototype._updateTheme = function(n) {
      K(n) && (n = ww[n]), n && (n = ft(n), n && Lx(n, !0), this._theme = n);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || tt.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(n) {
      return process.env.NODE_ENV !== "production" && he("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(n);
    }, t.prototype.renderToCanvas = function(n) {
      n = n || {};
      var i = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && i.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return i.getRenderedCanvas({
        backgroundColor: n.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: n.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(n) {
      n = n || {};
      var i = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && i.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return i.renderToString({
        useViewBox: n.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var n = this._zr, i = n.storage.getDisplayList();
      return P(i, function(r) {
        r.stopAnimation(null, !0);
      }), n.painter.toDataURL();
    }, t.prototype.getDataURL = function(n) {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      n = n || {};
      var i = n.excludeComponents, r = this._model, a = [], o = this;
      P(i, function(l) {
        r.eachComponent({
          mainType: l
        }, function(u) {
          var c = o._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var s = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(n).toDataURL("image/" + (n && n.type || "png"));
      return P(a, function(l) {
        l.group.ignore = !1;
      }), s;
    }, t.prototype.getConnectedDataURL = function(n) {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      var i = n.type === "svg", r = this.group, a = Math.min, o = Math.max, s = 1 / 0;
      if (j0[r]) {
        var l = s, u = s, c = -s, h = -s, d = [], f = n && n.pixelRatio || this.getDevicePixelRatio();
        P(ms, function(y, b) {
          if (y.group === r) {
            var x = i ? y.getZr().painter.getSvgDom().innerHTML : y.renderToCanvas(ft(n)), w = y.getDom().getBoundingClientRect();
            l = a(w.left, l), u = a(w.top, u), c = o(w.right, c), h = o(w.bottom, h), d.push({
              dom: x,
              left: w.left,
              top: w.top
            });
          }
        }), l *= f, u *= f, c *= f, h *= f;
        var v = c - l, g = h - u, p = Mi.createCanvas(), _ = H_(p, {
          renderer: i ? "svg" : "canvas"
        });
        if (_.resize({
          width: v,
          height: g
        }), i) {
          var m = "";
          return P(d, function(y) {
            var b = y.left - l, x = y.top - u;
            m += '<g transform="translate(' + b + "," + x + ')">' + y.dom + "</g>";
          }), _.painter.getSvgRoot().innerHTML = m, n.connectedBackgroundColor && _.painter.setBackgroundColor(n.connectedBackgroundColor), _.refreshImmediately(), _.painter.toDataURL();
        } else
          return n.connectedBackgroundColor && _.add(new be({
            shape: {
              x: 0,
              y: 0,
              width: v,
              height: g
            },
            style: {
              fill: n.connectedBackgroundColor
            }
          })), P(d, function(y) {
            var b = new ua({
              style: {
                x: y.left * f - l,
                y: y.top * f - u,
                image: y.dom
              }
            });
            _.add(b);
          }), _.refreshImmediately(), p.toDataURL("image/" + (n && n.type || "png"));
      } else
        return this.getDataURL(n);
    }, t.prototype.convertToPixel = function(n, i, r) {
      return Wl(this, "convertToPixel", n, i, r);
    }, t.prototype.convertToLayout = function(n, i, r) {
      return Wl(this, "convertToLayout", n, i, r);
    }, t.prototype.convertFromPixel = function(n, i, r) {
      return Wl(this, "convertFromPixel", n, i, r);
    }, t.prototype.containPixel = function(n, i) {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      var r = this._model, a, o = Ih(r, n);
      return P(o, function(s, l) {
        l.indexOf("Models") >= 0 && P(s, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(i);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? a = a || h.containPoint(i, u) : process.env.NODE_ENV !== "production" && un(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && un(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(n, i) {
      var r = this._model, a = Ih(r, n, {
        defaultMainType: "series"
      }), o = a.seriesModel;
      process.env.NODE_ENV !== "production" && (o || un("There is no specified series model"));
      var s = o.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? s.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? UR(s, l, i) : GR(s, i);
    }, t.prototype.getViewOfComponentModel = function(n) {
      return this._componentsMap[n.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(n) {
      return this._chartsMap[n.__viewId];
    }, t.prototype._initEvents = function() {
      var n = this;
      P(BN, function(r) {
        var a = function(o) {
          var s = n.getModel(), l = o.target, u, c = r === "globalout";
          if (c ? u = {} : l && is(l, function(g) {
            var p = Bt(g);
            if (p && p.dataIndex != null) {
              var _ = p.dataModel || s.getSeriesByIndex(p.seriesIndex);
              return u = _ && _.getDataParams(p.dataIndex, p.dataType, l) || {}, !0;
            } else if (p.eventData)
              return u = $({}, p.eventData), !0;
          }, !0), u) {
            var h = u.componentType, d = u.componentIndex;
            (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", d = u.seriesIndex);
            var f = h && d != null && s.getComponent(h, d), v = f && n[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(f && v) && un("model or view can not be found by params"), u.event = o, u.type = r, n._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: f,
              view: v
            }, n.trigger(r, u);
          }
        };
        a.zrEventfulCallAtLast = !0, n._zr.on(r, a, n);
      });
      var i = this._messageCenter;
      P(If, function(r, a) {
        i.on(a, function(o) {
          n.trigger(a, o);
        });
      }), jR(i, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      this._disposed = !0;
      var n = this.getDom();
      n && T1(this.getDom(), sp, "");
      var i = this, r = i._api, a = i._model;
      P(i._componentsViews, function(o) {
        o.dispose(a, r);
      }), P(i._chartsViews, function(o) {
        o.dispose(a, r);
      }), i._zr.dispose(), i._dom = i._model = i._chartsMap = i._componentsMap = i._chartsViews = i._componentsViews = i._scheduler = i._api = i._zr = i._throttledZrFlush = i._theme = i._coordSysMgr = i._messageCenter = null, delete ms[i.id];
    }, t.prototype.resize = function(n) {
      if (this[ne]) {
        process.env.NODE_ENV !== "production" && qt("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      this._zr.resize(n);
      var i = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!i) {
        var r = i.resetOption("media"), a = n && n.silent;
        this[ue] && (a == null && (a = this[ue].silent), r = !0, this[ue] = null), this[ne] = !0, Ea(this);
        try {
          r && Lr(this), oi.update.call(this, {
            type: "resize",
            animation: $({
              // Disable animation
              duration: 0
            }, n && n.animation)
          });
        } catch (o) {
          throw this[ne] = !1, o;
        }
        this[ne] = !1, Pa.call(this, a), Aa.call(this, a);
      }
    }, t.prototype.showLoading = function(n, i) {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      if (X(n) && (i = n, n = ""), n = n || "default", this.hideLoading(), !Ff[n]) {
        process.env.NODE_ENV !== "production" && un("Loading effects " + n + " not exists.");
        return;
      }
      var r = Ff[n](this._api, i), a = this._zr;
      this._loadingFX = r, a.add(r);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(n) {
      var i = $({}, n);
      return i.type = tc[n.type], i;
    }, t.prototype.dispatchAction = function(n, i) {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      if (X(i) || (i = {
        silent: !!i
      }), !!Ju[n.type] && this._model) {
        if (this[ne]) {
          this._pendingActions.push(n);
          return;
        }
        var r = i.silent;
        pd.call(this, n, r);
        var a = i.flush;
        a ? this._zr.flush() : a !== !1 && tt.browser.weChat && this._throttledZrFlush(), Pa.call(this, r), Aa.call(this, r);
      }
    }, t.prototype.updateLabelLayout = function() {
      xn.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(n) {
      if (this._disposed) {
        Ne(this.id);
        return;
      }
      var i = n.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(i);
      process.env.NODE_ENV !== "production" && Q(n.data && a), a.appendData(n), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = (function() {
      Lr = function(h) {
        var d = h._scheduler;
        d.restorePipelines(h._model), d.prepareStageTasks(), fd(h, !0), fd(h, !1), d.plan();
      }, fd = function(h, d) {
        for (var f = h._model, v = h._scheduler, g = d ? h._componentsViews : h._chartsViews, p = d ? h._componentsMap : h._chartsMap, _ = h._zr, m = h._api, y = 0; y < g.length; y++)
          g[y].__alive = !1;
        d ? f.eachComponent(function(w, M) {
          w !== "series" && b(M);
        }) : f.eachSeries(b);
        function b(w) {
          var M = w.__requireNewView;
          w.__requireNewView = !1;
          var D = "_ec_" + w.id + "_" + w.type, T = !M && p[D];
          if (!T) {
            var C = Gn(w.type), k = d ? Ti.getClass(C.main, C.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Zi.getClass(C.sub)
            );
            process.env.NODE_ENV !== "production" && Q(k, C.sub + " does not exist."), T = new k(), T.init(f, m), p[D] = T, g.push(T), _.add(T.group);
          }
          w.__viewId = T.__id = D, T.__alive = !0, T.__model = w, T.group.__ecComponentInfo = {
            mainType: w.mainType,
            index: w.componentIndex
          }, !d && v.prepareView(T, w, f, m);
        }
        for (var y = 0; y < g.length; ) {
          var x = g[y];
          x.__alive ? y++ : (!d && x.renderTask.dispose(), _.remove(x.group), x.dispose(f, m), g.splice(y, 1), p[x.__id] === x && delete p[x.__id], x.__id = x.group.__ecComponentInfo = null);
        }
      }, Yl = function(h, d, f, v, g) {
        var p = h._model;
        if (p.setUpdatePayload(f), !v) {
          P([].concat(h._componentsViews).concat(h._chartsViews), x);
          return;
        }
        var _ = {};
        _[v + "Id"] = f[v + "Id"], _[v + "Index"] = f[v + "Index"], _[v + "Name"] = f[v + "Name"];
        var m = {
          mainType: v,
          query: _
        };
        g && (m.subType = g);
        var y = f.excludeSeriesId, b;
        y != null && (b = st(), P(Ae(y), function(w) {
          var M = Mn(w, null);
          M != null && b.set(M, !0);
        })), p && p.eachComponent(m, function(w) {
          var M = b && b.get(w.id) != null;
          if (!M)
            if (Tm(f))
              if (w instanceof ir)
                f.type === ea && !f.notBlur && !w.get(["emphasis", "disabled"]) && vO(w, f, h._api);
              else {
                var D = Rv(w.mainType, w.componentIndex, f.name, h._api), T = D.focusSelf, C = D.dispatchers;
                f.type === ea && T && !f.notBlur && gf(w.mainType, w.componentIndex, h._api), C && P(C, function(k) {
                  f.type === ea ? Vu(k) : $u(k);
                });
              }
            else _f(f) && w instanceof ir && (_O(w, f, h._api), wm(w), nn(h));
        }, h), p && p.eachComponent(m, function(w) {
          var M = b && b.get(w.id) != null;
          M || x(h[v === "series" ? "_chartsMap" : "_componentsMap"][w.__viewId]);
        }, h);
        function x(w) {
          w && w.__alive && w[d] && w[d](w.__model, p, h._api, f);
        }
      }, oi = {
        prepareAndUpdate: function(h) {
          Lr(this), oi.update.call(this, h, h && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, d) {
          var f = this._model, v = this._api, g = this._zr, p = this._coordSysMgr, _ = this._scheduler;
          if (f) {
            f.setUpdatePayload(h), _.restoreData(f, h), _.performSeriesTasks(f), p.create(f, v), _.performDataProcessorTasks(f, h), vd(this, f), p.update(f, v), i(f), _.performVisualTasks(f, h);
            var m = f.get("backgroundColor") || "transparent";
            g.setBackgroundColor(m);
            var y = f.get("darkMode");
            y != null && y !== "auto" && g.setDarkMode(y), gd(this, f, v, h, d), xn.trigger("afterupdate", f, v);
          }
        },
        updateTransform: function(h) {
          var d = this, f = this._model, v = this._api;
          if (f) {
            f.setUpdatePayload(h);
            var g = [];
            f.eachComponent(function(_, m) {
              if (_ !== "series") {
                var y = d.getViewOfComponentModel(m);
                if (y && y.__alive)
                  if (y.updateTransform) {
                    var b = y.updateTransform(m, f, v, h);
                    b && b.update && g.push(y);
                  } else
                    g.push(y);
              }
            });
            var p = st();
            f.eachSeries(function(_) {
              var m = d._chartsMap[_.__viewId];
              if (m.updateTransform) {
                var y = m.updateTransform(_, f, v, h);
                y && y.update && p.set(_.uid, 1);
              } else
                p.set(_.uid, 1);
            }), i(f), this._scheduler.performVisualTasks(f, h, {
              setDirty: !0,
              dirtyMap: p
            }), Ul(this, f, v, h, {}, p), xn.trigger("afterupdate", f, v);
          }
        },
        updateView: function(h) {
          var d = this._model;
          d && (d.setUpdatePayload(h), Zi.markUpdateMethod(h, "updateView"), i(d), this._scheduler.performVisualTasks(d, h, {
            setDirty: !0
          }), gd(this, d, this._api, h, {}), xn.trigger("afterupdate", d, this._api));
        },
        updateVisual: function(h) {
          var d = this, f = this._model;
          f && (f.setUpdatePayload(h), f.eachSeries(function(v) {
            v.getData().clearAllVisual();
          }), Zi.markUpdateMethod(h, "updateVisual"), i(f), this._scheduler.performVisualTasks(f, h, {
            visualType: "visual",
            setDirty: !0
          }), f.eachComponent(function(v, g) {
            if (v !== "series") {
              var p = d.getViewOfComponentModel(g);
              p && p.__alive && p.updateVisual(g, f, d._api, h);
            }
          }), f.eachSeries(function(v) {
            var g = d._chartsMap[v.__viewId];
            g.updateVisual(v, f, d._api, h);
          }), xn.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(h) {
          oi.update.call(this, h);
        }
      };
      function n(h, d, f, v, g) {
        if (h._disposed) {
          Ne(h.id);
          return;
        }
        for (var p = h._model, _ = h._coordSysMgr.getCoordinateSystems(), m, y = Ih(p, f), b = 0; b < _.length; b++) {
          var x = _[b];
          if (x[d] && (m = x[d](p, y, v, g)) != null)
            return m;
        }
        process.env.NODE_ENV !== "production" && un("No coordinate system that supports " + d + " found by the given finder.");
      }
      Wl = n, vd = function(h, d) {
        var f = h._chartsMap, v = h._scheduler;
        d.eachSeries(function(g) {
          v.updateStreamModes(g, f[g.__viewId]);
        });
      }, pd = function(h, d) {
        var f = this, v = this.getModel(), g = h.type, p = h.escapeConnect, _ = Ju[g], m = (_.update || "update").split(":"), y = m.pop(), b = m[0] != null && Gn(m[0]);
        this[ne] = !0, Ea(this);
        var x = [h], w = !1;
        h.batch && (w = !0, x = yt(h.batch, function(N) {
          return N = Qt($({}, N), h), N.batch = null, N;
        }));
        var M = [], D, T = [], C = _.nonRefinedEventType, k = _f(h), E = Tm(h);
        if (E && j1(this._api), P(x, function(N) {
          var V = _.action(N, v, f._api);
          if (_.refineEvent ? T.push(V) : D = V, D = D || $({}, N), D.type = C, M.push(D), E) {
            var q = Tv(h), W = q.queryOptionMap, Z = q.mainTypeSpecified, bt = Z ? W.keys()[0] : "series";
            Yl(f, y, N, bt), nn(f);
          } else k ? (Yl(f, y, N, "series"), nn(f)) : b && Yl(f, y, N, b.main, b.sub);
        }), y !== "none" && !E && !k && !b)
          try {
            this[ue] ? (Lr(this), oi.update.call(this, h), this[ue] = null) : oi[y].call(this, h);
          } catch (N) {
            throw this[ne] = !1, N;
          }
        if (w ? D = {
          type: C,
          escapeConnect: p,
          batch: M
        } : D = M[0], this[ne] = !1, !d) {
          var A = void 0;
          if (_.refineEvent) {
            var L = _.refineEvent(T, h, v, this._api).eventContent;
            Q(X(L)), A = Qt({
              type: _.refinedEventType
            }, L), A.fromAction = h.type, A.fromActionPayload = h, A.escapeConnect = !0;
          }
          var R = this._messageCenter;
          R.trigger(D.type, D), A && R.trigger(A.type, A);
        }
      }, Pa = function(h) {
        for (var d = this._pendingActions; d.length; ) {
          var f = d.shift();
          pd.call(this, f, h);
        }
      }, Aa = function(h) {
        !h && this.trigger("updated");
      }, H0 = function(h, d) {
        h.on("rendered", function(f) {
          d.trigger("rendered", f), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !d[ue] && !d._scheduler.unfinished && !d._pendingActions.length && d.trigger("finished");
        });
      }, Y0 = function(h, d) {
        h.on("mouseover", function(f) {
          var v = f.target, g = is(v, so);
          g && (pO(g, f, d._api), nn(d));
        }).on("mouseout", function(f) {
          var v = f.target, g = is(v, so);
          g && (gO(g, f, d._api), nn(d));
        }).on("click", function(f) {
          var v = f.target, g = is(v, function(m) {
            return Bt(m).dataIndex != null;
          }, !0);
          if (g) {
            var p = g.selected ? "unselect" : "select", _ = Bt(g);
            d._api.dispatchAction({
              type: p,
              dataType: _.dataType,
              dataIndexInside: _.dataIndex,
              seriesIndex: _.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function i(h) {
        h.clearColorPalette(), h.eachSeries(function(d) {
          d.clearColorPalette();
        });
      }
      function r(h) {
        var d = [], f = [], v = !1;
        if (h.eachComponent(function(m, y) {
          var b = y.get("zlevel") || 0, x = y.get("z") || 0, w = y.getZLevelKey();
          v = v || !!w, (m === "series" ? f : d).push({
            zlevel: b,
            z: x,
            idx: y.componentIndex,
            type: m,
            key: w
          });
        }), v) {
          var g = d.concat(f), p, _;
          eu(g, function(m, y) {
            return m.zlevel === y.zlevel ? m.z - y.z : m.zlevel - y.zlevel;
          }), P(g, function(m) {
            var y = h.getComponent(m.type, m.idx), b = m.zlevel, x = m.key;
            p != null && (b = Math.max(p, b)), x ? (b === p && x !== _ && b++, _ = x) : _ && (b === p && b++, _ = ""), p = b, y.setZLevel(b);
          });
        }
      }
      gd = function(h, d, f, v, g) {
        r(d), W0(h, d, f, v, g), P(h._chartsViews, function(p) {
          p.__alive = !1;
        }), Ul(h, d, f, v, g), P(h._chartsViews, function(p) {
          p.__alive || p.remove(d, f);
        });
      }, W0 = function(h, d, f, v, g, p) {
        P(p || h._componentsViews, function(_) {
          var m = _.__model;
          u(m, _), _.render(m, d, f, v), l(m, _), c(m, _);
        });
      }, Ul = function(h, d, f, v, g, p) {
        var _ = h._scheduler;
        g = $(g || {}, {
          updatedSeries: d.getSeries()
        }), xn.trigger("series:beforeupdate", d, f, g);
        var m = !1;
        d.eachSeries(function(y) {
          var b = h._chartsMap[y.__viewId];
          b.__alive = !0;
          var x = b.renderTask;
          _.updatePayload(x, v), u(y, b), p && p.get(y.uid) && x.dirty(), x.perform(_.getPerformArgs(x)) && (m = !0), b.group.silent = !!y.get("silent"), s(y, b), wm(y);
        }), _.unfinished = m || _.unfinished, xn.trigger("series:layoutlabels", d, f, g), xn.trigger("series:transition", d, f, g), d.eachSeries(function(y) {
          var b = h._chartsMap[y.__viewId];
          l(y, b), c(y, b);
        }), o(h, d), xn.trigger("series:afterupdate", d, f, g);
      }, nn = function(h) {
        h[hd] = !0, h.getZr().wakeUp();
      }, Ea = function(h) {
        h[Hl] = (h[Hl] + 1) % 1e3;
      }, G0 = function(h) {
        h[hd] && (h.getZr().storage.traverse(function(d) {
          gs(d) || a(d);
        }), h[hd] = !1);
      };
      function a(h) {
        for (var d = [], f = h.currentStates, v = 0; v < f.length; v++) {
          var g = f[v];
          g === "emphasis" || g === "blur" || g === "select" || d.push(g);
        }
        h.selected && h.states.select && d.push("select"), h.hoverState === Lv && h.states.emphasis ? d.push("emphasis") : h.hoverState === Ev && h.states.blur && d.push("blur"), h.useStates(d);
      }
      function o(h, d) {
        var f = h._zr, v = f.storage, g = 0;
        v.traverse(function(p) {
          p.isGroup || g++;
        }), g > d.get("hoverLayerThreshold") && !tt.node && !tt.worker && d.eachSeries(function(p) {
          if (!p.preventUsingHoverLayer) {
            var _ = h._chartsMap[p.__viewId];
            _.__alive && _.eachRendered(function(m) {
              m.states.emphasis && (m.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function s(h, d) {
        var f = h.get("blendMode") || null;
        d.eachRendered(function(v) {
          v.isGroup || (v.style.blend = f);
        });
      }
      function l(h, d) {
        if (!h.preventAutoZ) {
          var f = Is(h);
          d.eachRendered(function(v) {
            return hx(v, f.z, f.zlevel), !0;
          });
        }
      }
      function u(h, d) {
        d.eachRendered(function(f) {
          if (!gs(f)) {
            var v = f.getTextContent(), g = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), g && g.stateTransition && (g.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(h, d) {
        var f = h.getModel("stateAnimation"), v = h.isAnimationEnabled(), g = f.get("duration"), p = g > 0 ? {
          duration: g,
          delay: f.get("delay"),
          easing: f.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        d.eachRendered(function(_) {
          if (_.states && _.states.emphasis) {
            if (gs(_))
              return;
            if (_ instanceof It && MO(_), _.__dirty) {
              var m = _.prevStates;
              m && _.useStates(m);
            }
            if (v) {
              _.stateTransition = p;
              var y = _.getTextContent(), b = _.getTextGuideLine();
              y && (y.stateTransition = p), b && (b.stateTransition = p);
            }
            _.__dirty && a(_);
          }
        });
      }
      U0 = function(h) {
        return new /** @class */
        ((function(d) {
          ae(f, d);
          function f() {
            return d !== null && d.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(v) {
            for (; v; ) {
              var g = v.__ecComponentInfo;
              if (g != null)
                return h._model.getComponent(g.mainType, g.index);
              v = v.parent;
            }
          }, f.prototype.enterEmphasis = function(v, g) {
            Vu(v, g), nn(h);
          }, f.prototype.leaveEmphasis = function(v, g) {
            $u(v, g), nn(h);
          }, f.prototype.enterBlur = function(v) {
            fO(v), nn(h);
          }, f.prototype.leaveBlur = function(v) {
            Y1(v), nn(h);
          }, f.prototype.enterSelect = function(v) {
            W1(v), nn(h);
          }, f.prototype.leaveSelect = function(v) {
            U1(v), nn(h);
          }, f.prototype.getModel = function() {
            return h.getModel();
          }, f.prototype.getViewOfComponentModel = function(v) {
            return h.getViewOfComponentModel(v);
          }, f.prototype.getViewOfSeriesModel = function(v) {
            return h.getViewOfSeriesModel(v);
          }, f.prototype.getMainProcessVersion = function() {
            return h[Hl];
          }, f;
        })(Ax))(h);
      }, bw = function(h) {
        function d(f, v) {
          for (var g = 0; g < f.length; g++) {
            var p = f[g];
            p[dd] = v;
          }
        }
        P(tc, function(f, v) {
          h._messageCenter.on(v, function(g) {
            if (j0[h.group] && h[dd] !== $0) {
              if (g && g.escapeConnect)
                return;
              var p = h.makeActionFromEvent(g), _ = [];
              P(ms, function(m) {
                m !== h && m.group === h.group && _.push(m);
              }), d(_, $0), P(_, function(m) {
                m[dd] !== NN && m.dispatchAction(p);
              }), d(_, FN);
            }
          });
        });
      };
    })(), t;
  })(En)
), op = xw.prototype;
op.on = pw("on");
op.off = pw("off");
op.one = function(e, t, n) {
  var i = this;
  Di("ECharts#one is deprecated.");
  function r() {
    for (var a = [], o = 0; o < arguments.length; o++)
      a[o] = arguments[o];
    t && t.apply && t.apply(this, a), i.off(e, r);
  }
  this.on.call(this, e, r, n);
};
var BN = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function Ne(e) {
  process.env.NODE_ENV !== "production" && un("Instance " + e + " has been disposed");
}
var Ju = {}, tc = {}, If = {}, Rf = [], Nf = [], ec = [], ww = {}, Ff = {}, ms = {}, j0 = {}, zN = +/* @__PURE__ */ new Date() - 0, sp = "_echarts_instance_";
function VN(e, t, n) {
  {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var i = $N(e);
    if (i)
      return process.env.NODE_ENV !== "production" && un("There is a chart instance already initialized on the dom."), i;
    process.env.NODE_ENV !== "production" && no(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && !n || !e.clientHeight && !n) && un("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var r = new xw(e, t, n);
  return r.id = "ec_" + zN++, ms[r.id] = r, T1(e, sp, r.id), bw(r), xn.trigger("afterinit", r), r;
}
function $N(e) {
  return ms[eL(e, sp)];
}
function Sw(e, t) {
  ww[e] = t;
}
function Mw(e) {
  zt(Nf, e) < 0 && Nf.push(e);
}
function Dw(e, t) {
  up(Rf, e, t, CN);
}
function HN(e) {
  lp("afterinit", e);
}
function YN(e) {
  lp("afterupdate", e);
}
function lp(e, t) {
  xn.on(e, t);
}
function ha(e, t, n) {
  var i, r, a, o, s;
  gt(t) && (n = t, t = ""), X(e) ? (i = e.type, r = e.event, o = e.update, s = e.publishNonRefinedEvent, n || (n = e.action), a = e.refineEvent) : (i = e, r = t);
  function l(c) {
    return c.toLowerCase();
  }
  r = l(r || i);
  var u = a ? l(i) : r;
  Ju[i] || (Q(V0.test(i) && V0.test(r)), a && Q(r !== i), Ju[i] = {
    actionType: i,
    refinedEventType: r,
    nonRefinedEventType: u,
    update: o,
    action: n,
    refineEvent: a
  }, If[r] = 1, a && s && (If[u] = 1), process.env.NODE_ENV !== "production" && tc[u] && qt(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), tc[u] = i);
}
function WN(e, t) {
  Rc.register(e, t);
}
function UN(e, t) {
  up(ec, e, t, dw, "layout");
}
function da(e, t) {
  up(ec, e, t, fw, "visual");
}
var X0 = [];
function up(e, t, n, i, r) {
  if ((gt(t) || X(t)) && (n = t, t = i), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    P(e, function(o) {
      Q(o.__raw !== n);
    });
  }
  if (!(zt(X0, n) >= 0)) {
    X0.push(n);
    var a = Jx.wrapStageHandler(n, r);
    a.__prio = t, a.__raw = n, e.push(a);
  }
}
function Tw(e, t) {
  Ff[e] = t;
}
function GN(e, t, n) {
  var i = SN("registerMap");
  i && i(e, t, n);
}
var jN = K5;
da(ap, CR);
da(Bc, PR);
da(Bc, AR);
da(ap, YR);
da(Bc, WR);
da(vw, xN);
Mw(Lx);
Dw(TN, L5);
Tw("default", ER);
ha({
  type: ea,
  event: ea,
  update: ea
}, ye);
ha({
  type: ou,
  event: ou,
  update: ou
}, ye);
ha({
  type: Bu,
  event: Ov,
  update: Bu,
  action: ye,
  refineEvent: cp,
  publishNonRefinedEvent: !0
});
ha({
  type: vf,
  event: Ov,
  update: vf,
  action: ye,
  refineEvent: cp,
  publishNonRefinedEvent: !0
});
ha({
  type: zu,
  event: Ov,
  update: zu,
  action: ye,
  refineEvent: cp,
  publishNonRefinedEvent: !0
});
function cp(e, t, n, i) {
  return {
    eventContent: {
      selected: mO(n),
      isFromClick: t.isFromClick || !1
    }
  };
}
Sw("default", {});
Sw("dark", iw);
function Ro(e) {
  return e == null ? 0 : e.length || 1;
}
function q0(e) {
  return e;
}
var XN = (
  /** @class */
  (function() {
    function e(t, n, i, r, a, o) {
      this._old = t, this._new = n, this._oldKeyGetter = i || q0, this._newKeyGetter = r || q0, this.context = a, this._diffModeMultiple = o === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, n = this._new, i = {}, r = new Array(t.length), a = new Array(n.length);
      this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(n, i, a, "_newKeyGetter");
      for (var o = 0; o < t.length; o++) {
        var s = r[o], l = i[s], u = Ro(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (i[s] = l[0]), this._update && this._update(c, o);
        } else u === 1 ? (i[s] = null, this._update && this._update(l, o)) : this._remove && this._remove(o);
      }
      this._performRestAdd(a, i);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, n = this._new, i = {}, r = {}, a = [], o = [];
      this._initIndexMap(t, i, a, "_oldKeyGetter"), this._initIndexMap(n, r, o, "_newKeyGetter");
      for (var s = 0; s < a.length; s++) {
        var l = a[s], u = i[l], c = r[l], h = Ro(u), d = Ro(c);
        if (h > 1 && d === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), r[l] = null;
        else if (h === 1 && d > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), r[l] = null;
        else if (h === 1 && d === 1)
          this._update && this._update(c, u), r[l] = null;
        else if (h > 1 && d > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), r[l] = null;
        else if (h > 1)
          for (var f = 0; f < h; f++)
            this._remove && this._remove(u[f]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(o, r);
    }, e.prototype._performRestAdd = function(t, n) {
      for (var i = 0; i < t.length; i++) {
        var r = t[i], a = n[r], o = Ro(a);
        if (o > 1)
          for (var s = 0; s < o; s++)
            this._add && this._add(a[s]);
        else o === 1 && this._add && this._add(a);
        n[r] = null;
      }
    }, e.prototype._initIndexMap = function(t, n, i, r) {
      for (var a = this._diffModeMultiple, o = 0; o < t.length; o++) {
        var s = "_ec_" + this[r](t[o], o);
        if (a || (i[o] = s), !!n) {
          var l = n[s], u = Ro(l);
          u === 0 ? (n[s] = o, a && i.push(s)) : u === 1 ? n[s] = [l, o] : l.push(o);
        }
      }
    }, e;
  })()
), qN = (
  /** @class */
  (function() {
    function e(t, n) {
      this._encode = t, this._schema = n;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  })()
);
function ZN(e, t) {
  var n = {}, i = n.encode = {}, r = st(), a = [], o = [], s = {};
  P(e.dimensions, function(d) {
    var f = e.getDimensionInfo(d), v = f.coordDim;
    if (v) {
      process.env.NODE_ENV !== "production" && Q(Sf.get(v) == null);
      var g = f.coordDimIndex;
      _d(i, v)[g] = d, f.isExtraCoord || (r.set(v, 1), QN(f.type) && (a[0] = d), _d(s, v)[g] = e.getDimensionIndex(f.name)), f.defaultTooltip && o.push(d);
    }
    Sf.each(function(p, _) {
      var m = _d(i, _), y = f.otherDims[_];
      y != null && y !== !1 && (m[y] = f.name);
    });
  });
  var l = [], u = {};
  r.each(function(d, f) {
    var v = i[f];
    u[f] = v[0], l = l.concat(v);
  }), n.dataDimsOnCoord = l, n.dataDimIndicesOnCoord = yt(l, function(d) {
    return e.getDimensionInfo(d).storeDimIndex;
  }), n.encodeFirstDimNotExtra = u;
  var c = i.label;
  c && c.length && (a = c.slice());
  var h = i.tooltip;
  return h && h.length ? o = h.slice() : o.length || (o = a.slice()), i.defaultedLabel = a, i.defaultedTooltip = o, n.userOutput = new qN(s, t), n;
}
function _d(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function KN(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function QN(e) {
  return !(e === "ordinal" || e === "time");
}
var cu = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.otherDims = {}, t != null && $(this, t);
    }
    return e;
  })()
), JN = Wt(), tF = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, kw = (
  /** @class */
  (function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = Aw(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return J(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var n = this.source.dimensionsDefine;
      if (n)
        return n[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, n = Ix(this.source), i = !Ew(t), r = "", a = [], o = 0, s = 0; o < t; o++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[s];
        if (h && h.storeDimIndex === o)
          l = n ? h.name : null, u = h.type, c = h.ordinalMeta, s++;
        else {
          var d = this.getSourceDimension(o);
          d && (l = n ? d.name : null, u = d.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), n && l != null && (!h || !h.isCalculationCoord) && (r += i ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += tF[u] || "f", c && (r += c.uid), r += "$";
      }
      var f = this.source, v = [f.seriesLayoutBy, f.startIndex, r].join("$$");
      return {
        dimensions: a,
        hash: v
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], n = 0, i = 0; n < this._fullDimCount; n++) {
        var r = void 0, a = this.dimensions[i];
        if (a && a.storeDimIndex === n)
          a.isCalculationCoord || (r = a.name), i++;
        else {
          var o = this.getSourceDimension(n);
          o && (r = o.name);
        }
        t.push(r);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  })()
);
function Cw(e) {
  return e instanceof kw;
}
function Pw(e) {
  for (var t = st(), n = 0; n < (e || []).length; n++) {
    var i = e[n], r = X(i) ? i.name : i;
    r != null && t.get(r) == null && t.set(r, n);
  }
  return t;
}
function Aw(e) {
  var t = JN(e);
  return t.dimNameMap || (t.dimNameMap = Pw(e.dimensionsDefine));
}
function Ew(e) {
  return e > 30;
}
var No = X, Ni = yt, eF = typeof Int32Array > "u" ? Array : Int32Array, nF = "e\0\0", Z0 = -1, iF = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], rF = ["_approximateExtent"], K0, Gl, Fo, La, md, Bo, yd, Bf = (
  /** @class */
  (function() {
    function e(t, n) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var i, r = !1;
      Cw(t) ? (i = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = !0, i = t), i = i || ["x", "y"];
      for (var a = {}, o = [], s = {}, l = !1, u = {}, c = 0; c < i.length; c++) {
        var h = i[c], d = K(h) ? new cu({
          name: h
        }) : h instanceof cu ? h : new cu(h), f = d.name;
        d.type = d.type || "float", d.coordDim || (d.coordDim = f, d.coordDimIndex = 0);
        var v = d.otherDims = d.otherDims || {};
        o.push(f), a[f] = d, u[f] != null && (l = !0), d.createInvertedIndices && (s[f] = []);
        var g = c;
        Xt(d.storeDimIndex) && (g = d.storeDimIndex), v.itemName === 0 && (this._nameDimIdx = g), v.itemId === 0 && (this._idDimIdx = g), process.env.NODE_ENV !== "production" && Q(r || d.storeDimIndex >= 0), r && (d.storeDimIndex = c);
      }
      if (this.dimensions = o, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = n, this._invertedIndicesMap = s, this._dimOmitted) {
        var p = this._dimIdxToName = st();
        P(o, function(_) {
          p.set(a[_].storeDimIndex, _);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var n = this._recognizeDimIndex(t);
      if (n == null)
        return t;
      if (n = t, !this._dimOmitted)
        return this.dimensions[n];
      var i = this._dimIdxToName.get(n);
      if (i != null)
        return i;
      var r = this._schema.getSourceDimension(n);
      if (r)
        return r.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var n = this._recognizeDimIndex(t);
      if (n != null)
        return n;
      if (t == null)
        return -1;
      var i = this._getDimInfo(t);
      return i ? i.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if (Xt(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var n = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && n == null)
        throw new Error("Unknown dimension " + t);
      return n;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var n = this._dimInfos;
      this._getDimInfo = t ? function(i) {
        return n.hasOwnProperty(i) ? n[i] : void 0;
      } : function(i) {
        return n[i];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, n) {
      var i = this._dimSummary;
      if (n == null)
        return i.encodeFirstDimNotExtra[t];
      var r = i.encode[t];
      return r ? r[n] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var n = this._dimSummary, i = n.encode[t];
      return (i || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, n, i) {
      var r = this, a;
      if (t instanceof Df && (a = t), !a) {
        var o = this.dimensions, s = np(t) || We(t) ? new Rx(t, o.length) : t;
        a = new Df();
        var l = Ni(o, function(u) {
          return {
            type: r._dimInfos[u].type,
            property: u
          };
        });
        a.initData(s, l, i);
      }
      this._store = a, this._nameList = (n || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = ZN(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var n = this._store.appendData(t);
      this._doInit(n[0], n[1]);
    }, e.prototype.appendValues = function(t, n) {
      var i = this._store.appendValues(t, n && n.length), r = i.start, a = i.end, o = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), n)
        for (var s = r; s < a; s++) {
          var l = s - r;
          this._nameList[s] = n[l], o && yd(this, s);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, n = this.dimensions, i = 0; i < n.length; i++) {
        var r = this._dimInfos[n[i]];
        r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== xi && !t.fillStorage;
    }, e.prototype._doInit = function(t, n) {
      if (!(t >= n)) {
        var i = this._store, r = i.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, o = this._idList, s = r.getSource().sourceFormat, l = s === Qe;
        if (l && !r.pure)
          for (var u = [], c = t; c < n; c++) {
            var h = r.getItem(c, u);
            if (!this.hasItemOption && WE(h) && (this.hasItemOption = !0), h) {
              var d = h.name;
              a[c] == null && d != null && (a[c] = Mn(d, null));
              var f = h.id;
              o[c] == null && f != null && (o[c] = Mn(f, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < n; c++)
            yd(this, c);
        K0(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, n) {
      n = this.getDimension(n), this._approximateExtent[n] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, n) {
      No(t) ? $(this._calculationInfo, t) : this._calculationInfo[t] = n;
    }, e.prototype.getName = function(t) {
      var n = this.getRawIndex(t), i = this._nameList[n];
      return i == null && this._nameDimIdx != null && (i = Fo(this, this._nameDimIdx, n)), i == null && (i = ""), i;
    }, e.prototype._getCategory = function(t, n) {
      var i = this._store.get(t, n), r = this._store.getOrdinalMeta(t);
      return r ? r.categories[i] : i;
    }, e.prototype.getId = function(t) {
      return Gl(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, n) {
      var i = this._store, r = this._dimInfos[t];
      if (r)
        return i.get(r.storeDimIndex, n);
    }, e.prototype.getByRawIndex = function(t, n) {
      var i = this._store, r = this._dimInfos[t];
      if (r)
        return i.getByRawIndex(r.storeDimIndex, n);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, n) {
      var i = this, r = this._store;
      return U(t) ? r.getValues(Ni(t, function(a) {
        return i._getStoreDimIndex(a);
      }), n) : r.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var n = this._dimSummary.dataDimIndicesOnCoord, i = 0, r = n.length; i < r; i++)
        if (isNaN(this._store.get(n[i], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var n = 0, i = this._store.count(); n < i; n++)
        if (this.getName(n) === t)
          return n;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, n) {
      var i = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !i)
        throw new Error("Do not supported yet");
      var r = i && i[n];
      return r == null || isNaN(r) ? Z0 : r;
    }, e.prototype.each = function(t, n, i) {
      gt(t) && (i = n, n = t, t = []);
      var r = i || this, a = Ni(La(t), this._getStoreDimIndex, this);
      this._store.each(a, r ? Tt(n, r) : n);
    }, e.prototype.filterSelf = function(t, n, i) {
      gt(t) && (i = n, n = t, t = []);
      var r = i || this, a = Ni(La(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, r ? Tt(n, r) : n), this;
    }, e.prototype.selectRange = function(t) {
      var n = this, i = {}, r = jt(t);
      return P(r, function(a) {
        var o = n._getStoreDimIndex(a);
        i[o] = t[a];
      }), this._store = this._store.selectRange(i), this;
    }, e.prototype.mapArray = function(t, n, i) {
      gt(t) && (i = n, n = t, t = []), i = i || this;
      var r = [];
      return this.each(t, function() {
        r.push(n && n.apply(this, arguments));
      }, i), r;
    }, e.prototype.map = function(t, n, i, r) {
      var a = i || r || this, o = Ni(La(t), this._getStoreDimIndex, this), s = Bo(this);
      return s._store = this._store.map(o, a ? Tt(n, a) : n), s;
    }, e.prototype.modify = function(t, n, i, r) {
      var a = this, o = i || r || this;
      process.env.NODE_ENV !== "production" && P(La(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var s = Ni(La(t), this._getStoreDimIndex, this);
      this._store.modify(s, o ? Tt(n, o) : n);
    }, e.prototype.downSample = function(t, n, i, r) {
      var a = Bo(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), n, i, r), a;
    }, e.prototype.minmaxDownSample = function(t, n) {
      var i = Bo(this);
      return i._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), n), i;
    }, e.prototype.lttbDownSample = function(t, n) {
      var i = Bo(this);
      return i._store = this._store.lttbDownSample(this._getStoreDimIndex(t), n), i;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var n = this.hostModel, i = this.getRawDataItem(t);
      return new Gt(i, n, n && n.ecModel);
    }, e.prototype.diff = function(t) {
      var n = this;
      return new XN(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(i) {
        return Gl(t, i);
      }, function(i) {
        return Gl(n, i);
      });
    }, e.prototype.getVisual = function(t) {
      var n = this._visual;
      return n && n[t];
    }, e.prototype.setVisual = function(t, n) {
      this._visual = this._visual || {}, No(t) ? $(this._visual, t) : this._visual[t] = n;
    }, e.prototype.getItemVisual = function(t, n) {
      var i = this._itemVisuals[t], r = i && i[n];
      return r ?? this.getVisual(n);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, n) {
      var i = this._itemVisuals, r = i[t];
      r || (r = i[t] = {});
      var a = r[n];
      return a == null && (a = this.getVisual(n), U(a) ? a = a.slice() : No(a) && (a = $({}, a)), r[n] = a), a;
    }, e.prototype.setItemVisual = function(t, n, i) {
      var r = this._itemVisuals[t] || {};
      this._itemVisuals[t] = r, No(n) ? $(r, n) : r[n] = i;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, n) {
      No(t) ? $(this._layout, t) : this._layout[t] = n;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, n, i) {
      this._itemLayouts[t] = i ? $(this._itemLayouts[t] || {}, n) : n;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, n) {
      var i = this.hostModel && this.hostModel.seriesIndex;
      iO(i, this.dataType, t, n), this._graphicEls[t] = n;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, n) {
      P(this._graphicEls, function(i, r) {
        i && t && t.call(n, i, r);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : Ni(this.dimensions, this._getDimInfo, this), this.hostModel)), md(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, n) {
      var i = this[t];
      gt(i) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var r = i.apply(this, arguments);
        return n.apply(this, [r].concat(yv(arguments)));
      });
    }, e.internalField = (function() {
      K0 = function(t) {
        var n = t._invertedIndicesMap;
        P(n, function(i, r) {
          var a = t._dimInfos[r], o = a.ordinalMeta, s = t._store;
          if (o) {
            i = n[r] = new eF(o.categories.length);
            for (var l = 0; l < i.length; l++)
              i[l] = Z0;
            for (var l = 0; l < s.count(); l++)
              i[s.get(a.storeDimIndex, l)] = l;
          }
        });
      }, Fo = function(t, n, i) {
        return Mn(t._getCategory(n, i), null);
      }, Gl = function(t, n) {
        var i = t._idList[n];
        return i == null && t._idDimIdx != null && (i = Fo(t, t._idDimIdx, n)), i == null && (i = nF + n), i;
      }, La = function(t) {
        return U(t) || (t = t != null ? [t] : []), t;
      }, Bo = function(t) {
        var n = new e(t._schema ? t._schema : Ni(t.dimensions, t._getDimInfo, t), t.hostModel);
        return md(n, t), n;
      }, md = function(t, n) {
        P(iF.concat(n.__wrappedMethods || []), function(i) {
          n.hasOwnProperty(i) && (t[i] = n[i]);
        }), t.__wrappedMethods = n.__wrappedMethods, P(rF, function(i) {
          t[i] = ft(n[i]);
        }), t._calculationInfo = $({}, n._calculationInfo);
      }, yd = function(t, n) {
        var i = t._nameList, r = t._idList, a = t._nameDimIdx, o = t._idDimIdx, s = i[n], l = r[n];
        if (s == null && a != null && (i[n] = s = Fo(t, a, n)), l == null && o != null && (r[n] = l = Fo(t, o, n)), l == null && s != null) {
          var u = t._nameRepeatCount, c = u[s] = (u[s] || 0) + 1;
          l = s, c > 1 && (l += "__ec__" + c), r[n] = l;
        }
      };
    })(), e;
  })()
);
function Lw(e, t) {
  np(e) || (e = ip(e)), t = t || {};
  var n = t.coordDimensions || [], i = t.dimensionsDefine || e.dimensionsDefine || [], r = st(), a = [], o = oF(e, n, i, t.dimensionsCount), s = t.canOmitUnusedDimensions && Ew(o), l = i === e.dimensionsDefine, u = l ? Aw(e) : Pw(i), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, o));
  for (var h = st(c), d = new Vx(o), f = 0; f < d.length; f++)
    d[f] = -1;
  function v(T) {
    var C = d[T];
    if (C < 0) {
      var k = i[T], E = X(k) ? k : {
        name: k
      }, A = new cu(), L = E.name;
      L != null && u.get(L) != null && (A.name = A.displayName = L), E.type != null && (A.type = E.type), E.displayName != null && (A.displayName = E.displayName);
      var R = a.length;
      return d[T] = R, A.storeDimIndex = T, a.push(A), A;
    }
    return a[C];
  }
  if (!s)
    for (var f = 0; f < o; f++)
      v(f);
  h.each(function(T, C) {
    var k = Ae(T).slice();
    if (k.length === 1 && !K(k[0]) && k[0] < 0) {
      h.set(C, !1);
      return;
    }
    var E = h.set(C, []);
    P(k, function(A, L) {
      var R = K(A) ? u.get(A) : A;
      R != null && R < o && (E[L] = R, p(v(R), C, L));
    });
  });
  var g = 0;
  P(n, function(T) {
    var C, k, E, A;
    if (K(T))
      C = T, A = {};
    else {
      A = T, C = A.name;
      var L = A.ordinalMeta;
      A.ordinalMeta = null, A = $({}, A), A.ordinalMeta = L, k = A.dimsDef, E = A.otherDims, A.name = A.coordDim = A.coordDimIndex = A.dimsDef = A.otherDims = null;
    }
    var R = h.get(C);
    if (R !== !1) {
      if (R = Ae(R), !R.length)
        for (var N = 0; N < (k && k.length || 1); N++) {
          for (; g < o && v(g).coordDim != null; )
            g++;
          g < o && R.push(g++);
        }
      P(R, function(V, q) {
        var W = v(V);
        if (l && A.type != null && (W.type = A.type), p(Qt(W, A), C, q), W.name == null && k) {
          var Z = k[q];
          !X(Z) && (Z = {
            name: Z
          }), W.name = W.displayName = Z.name, W.defaultTooltip = Z.defaultTooltip;
        }
        E && Qt(W.otherDims, E);
      });
    }
  });
  function p(T, C, k) {
    Sf.get(C) != null ? T.otherDims[C] = k : (T.coordDim = C, T.coordDimIndex = k, r.set(C, !0));
  }
  var _ = t.generateCoord, m = t.generateCoordCount, y = m != null;
  m = _ ? m || 1 : 0;
  var b = _ || "value";
  function x(T) {
    T.name == null && (T.name = T.coordDim);
  }
  if (s)
    P(a, function(T) {
      x(T);
    }), a.sort(function(T, C) {
      return T.storeDimIndex - C.storeDimIndex;
    });
  else
    for (var w = 0; w < o; w++) {
      var M = v(w), D = M.coordDim;
      D == null && (M.coordDim = sF(b, r, y), M.coordDimIndex = 0, (!_ || m <= 0) && (M.isExtraCoord = !0), m--), x(M), M.type == null && (Px(e, w) === Ge.Must || M.isExtraCoord && (M.otherDims.itemName != null || M.otherDims.seriesName != null)) && (M.type = "ordinal");
    }
  return aF(a), new kw({
    source: e,
    dimensions: a,
    fullDimensionCount: o,
    dimensionOmitted: s
  });
}
function aF(e) {
  for (var t = st(), n = 0; n < e.length; n++) {
    var i = e[n], r = i.name, a = t.get(r) || 0;
    a > 0 && (i.name = r + (a - 1)), a++, t.set(r, a);
  }
}
function oF(e, t, n, i) {
  var r = Math.max(e.dimensionsDetectedCount || 1, t.length, n.length, i || 0);
  return P(t, function(a) {
    var o;
    X(a) && (o = a.dimsDef) && (r = Math.max(r, o.length));
  }), r;
}
function sF(e, t, n) {
  if (n || t.hasKey(e)) {
    for (var i = 0; t.hasKey(e + i); )
      i++;
    e += i;
  }
  return t.set(e, !0), e;
}
var lF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = st(), this.categoryAxisMap = st(), this.coordSysName = t;
    }
    return e;
  })()
);
function uF(e) {
  var t = e.get("coordinateSystem"), n = new lF(t), i = cF[t];
  if (i)
    return i(e, n, n.axisMap, n.categoryAxisMap), n;
}
var cF = {
  cartesian2d: function(e, t, n, i) {
    var r = e.getReferringComponents("xAxis", zi).models[0], a = e.getReferringComponents("yAxis", zi).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error('xAxis "' + er(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + er(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], n.set("x", r), n.set("y", a), Oa(r) && (i.set("x", r), t.firstCategoryDimIndex = 0), Oa(a) && (i.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, n, i) {
    var r = e.getReferringComponents("singleAxis", zi).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], n.set("single", r), Oa(r) && (i.set("single", r), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, n, i) {
    var r = e.getReferringComponents("polar", zi).models[0], a = r.findAxisModel("radiusAxis"), o = r.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!o)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], n.set("radius", a), n.set("angle", o), Oa(a) && (i.set("radius", a), t.firstCategoryDimIndex = 0), Oa(o) && (i.set("angle", o), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, n, i) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, n, i) {
    var r = e.ecModel, a = r.getComponent("parallel", e.get("parallelIndex")), o = t.coordSysDims = a.dimensions.slice();
    P(a.parallelAxisIndex, function(s, l) {
      var u = r.getComponent("parallelAxis", s), c = o[l];
      n.set(c, u), Oa(u) && (i.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(e, t, n, i) {
    var r = e.getReferringComponents("matrix", zi).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = r.getDimensionModel("x"), o = r.getDimensionModel("y");
    n.set("x", a), n.set("y", o), i.set("x", a), i.set("y", o);
  }
};
function Oa(e) {
  return e.get("type") === "category";
}
function hF(e, t, n) {
  n = n || {};
  var i = n.byIndex, r = n.stackedCoordDimension, a, o, s;
  dF(t) ? a = t : (o = t.schema, a = o.dimensions, s = t.store);
  var l = !!(e && e.get("stack")), u, c, h, d;
  if (P(a, function(m, y) {
    K(m) && (a[y] = m = {
      name: m
    }), l && !m.isExtraCoord && (!i && !u && m.ordinalMeta && (u = m), !c && m.type !== "ordinal" && m.type !== "time" && (!r || r === m.coordDim) && (c = m));
  }), c && !i && !u && (i = !0), c) {
    h = "__\0ecstackresult_" + e.id, d = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var f = c.coordDim, v = c.type, g = 0;
    P(a, function(m) {
      m.coordDim === f && g++;
    });
    var p = {
      name: h,
      coordDim: f,
      coordDimIndex: g,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, _ = {
      name: d,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: d,
      coordDimIndex: g + 1,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    o ? (s && (p.storeDimIndex = s.ensureCalculationDimension(d, v), _.storeDimIndex = s.ensureCalculationDimension(h, v)), o.appendCalculationDimension(p), o.appendCalculationDimension(_)) : (a.push(p), a.push(_));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: i,
    stackedOverDimension: d,
    stackResultDimension: h
  };
}
function dF(e) {
  return !Cw(e.schema);
}
function fF(e, t) {
  var n = e.get("coordinateSystem"), i = Rc.get(n), r;
  return t && t.coordSysDims && (r = yt(t.coordSysDims, function(a) {
    var o = {
      name: a
    }, s = t.axisMap.get(a);
    if (s) {
      var l = s.get("type");
      o.type = KN(l);
    }
    return o;
  })), r || (r = i && (i.getDimensionsInfo ? i.getDimensionsInfo() : i.dimensions.slice()) || ["x", "y"]), r;
}
function vF(e, t, n) {
  var i, r;
  return n && P(e, function(a, o) {
    var s = a.coordDim, l = n.categoryAxisMap.get(s);
    l && (i == null && (i = o), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (r = !0);
  }), !r && i != null && (e[i].otherDims.itemName = 0), i;
}
function pF(e, t, n) {
  n = n || {};
  var i = t.getSourceManager(), r, a = !1;
  e ? (a = !0, r = ip(e)) : (r = i.getSource(), a = r.sourceFormat === Qe);
  var o = uF(t), s = fF(t, o), l = n.useEncodeDefaulter, u = gt(l) ? l : l ? Pe(a5, s, t) : null, c = {
    coordDimensions: s,
    generateCoord: n.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, h = Lw(r, c), d = vF(h.dimensions, n.createInvertedIndices, o), f = a ? null : i.getSharedDataStore(h), v = hF(t, {
    schema: h,
    store: f
  }), g = new Bf(h, t);
  g.setCalculationInfo(v);
  var p = d != null && gF(r) ? function(_, m, y, b) {
    return b === d ? y : this.defaultDimValueGetter(_, m, y, b);
  } : null;
  return g.hasItemOption = !1, g.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? r : f,
    null,
    p
  ), g;
}
function gF(e) {
  if (e.sourceFormat === Qe) {
    var t = _F(e.data || []);
    return !U(js(t));
  }
}
function _F(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
function Ow(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function mF(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function yF(e) {
  return e.type === "category" && mF(e.getLabelModel()) === 0;
}
function nc(e) {
  return e === "middle" || e === "center";
}
var Q0 = [], bF = {
  registerPreprocessor: Mw,
  registerProcessor: Dw,
  registerPostInit: HN,
  registerPostUpdate: YN,
  registerUpdateLifecycle: lp,
  registerAction: ha,
  registerCoordinateSystem: WN,
  registerLayout: UN,
  registerVisual: da,
  registerTransform: jN,
  registerLoading: Tw,
  registerMap: GN,
  registerImpl: wN,
  PRIORITY: RN,
  ComponentModel: Pt,
  ComponentView: Ti,
  SeriesModel: ir,
  ChartView: Zi,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    Pt.registerClass(e);
  },
  registerComponentView: function(e) {
    Ti.registerClass(e);
  },
  registerSeriesModel: function(e) {
    ir.registerClass(e);
  },
  registerChartView: function(e) {
    Zi.registerClass(e);
  },
  registerCustomSeries: function(e, t) {
  },
  registerSubTypeDefaulter: function(e, t) {
    Pt.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    LE(e, t);
  }
};
function hp(e) {
  if (U(e)) {
    P(e, function(t) {
      hp(t);
    });
    return;
  }
  zt(Q0, e) >= 0 || (Q0.push(e), gt(e) && (e = {
    install: e
  }), e.install(bF));
}
Wt();
Wt();
var J0 = {
  estimate: 1,
  determine: 2
};
function xF(e) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: e
  };
}
var ty = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], wF = 1, ic = 2, Iw = wF | ic;
function rc(e, t, n) {
  n = n || Iw, t ? e.dirty |= n : e.dirty &= ~n;
}
function Rw(e, t) {
  return t = t || Iw, e.dirty == null || !!(e.dirty & t);
}
function rr(e) {
  if (e)
    return Rw(e) && SF(e, e.label, e), e;
}
function SF(e, t, n) {
  var i = t.getComputedTransform();
  e.transform = qv(e.transform, i);
  var r = e.localRect = Os(e.localRect, t.getBoundingRect()), a = t.style, o = a.margin, s = n && n.marginForce, l = n && n.minMarginForce, u = n && n.marginDefault, c = a.__marginType;
  c == null && u && (o = u, c = Ya.textMargin);
  for (var h = 0; h < 4; h++)
    bd[h] = c === Ya.minMargin && l && l[h] != null ? l[h] : s && s[h] != null ? s[h] : o ? o[h] : 0;
  c === Ya.textMargin && bf(r, bd, !1, !1);
  var d = e.rect = Os(e.rect, r);
  return i && d.applyTransform(i), c === Ya.minMargin && bf(d, bd, !1, !1), e.axisAligned = Xv(i), (e.label = e.label || {}).ignore = t.ignore, rc(e, !1), rc(e, !0, ic), e;
}
var bd = [0, 0, 0, 0];
function MF(e, t, n) {
  return e.transform = qv(e.transform, n), e.localRect = Os(e.localRect, t), e.rect = Os(e.rect, t), n && e.rect.applyTransform(n), e.axisAligned = Xv(n), e.obb = void 0, (e.label = e.label || {}).ignore = !1, e;
}
function DF(e, t) {
  if (e) {
    e.label.x += t.x, e.label.y += t.y, e.label.markRedraw();
    var n = e.transform;
    n && (n[4] += t.x, n[5] += t.y);
    var i = e.rect;
    i && (i.x += t.x, i.y += t.y);
    var r = e.obb;
    r && r.fromBoundingRect(e.localRect, n);
  }
}
function ey(e, t) {
  for (var n = 0; n < ty.length; n++) {
    var i = ty[n];
    e[i] == null && (e[i] = t[i]);
  }
  return rr(e);
}
function ny(e) {
  var t = e.obb;
  return (!t || Rw(e, ic)) && (e.obb = t = t || new nx(), t.fromBoundingRect(e.localRect, e.transform), rc(e, !1, ic)), t;
}
function TF(e) {
  var t = [];
  e.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function n(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var i = 0; i < e.length; i++) {
    var r = rr(e[i]);
    if (!r.label.ignore) {
      for (var a = r.label, o = r.labelLine, s = !1, l = 0; l < t.length; l++)
        if (dp(r, t[l], null, {
          touchThreshold: 0.05
        })) {
          s = !0;
          break;
        }
      s ? (n(a), o && n(o)) : t.push(r);
    }
  }
}
function dp(e, t, n, i) {
  return !e || !t || e.label && e.label.ignore || t.label && t.label.ignore || !e.rect.intersect(t.rect, n, i) ? !1 : e.axisAligned && t.axisAligned ? !0 : ny(e).intersect(ny(t), n, i);
}
var kF = null;
function CF() {
  return kF;
}
var PF = "expandAxisBreak", Wi = Math.PI, AF = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], EF = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], ac = Wt(), Nw = Wt(), LF = (
  /** @class */
  (function() {
    function e(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return e.prototype.ensureRecord = function(t) {
      var n = t.axis.dim, i = t.componentIndex, r = this.recordMap, a = r[n] || (r[n] = []);
      return a[i] || (a[i] = {
        ready: {}
      });
    }, e;
  })()
);
function OF(e, t, n, i) {
  var r = n.axis, a = t.ensureRecord(n), o = [], s, l = fp(e.axisName) && nc(e.nameLocation);
  P(i, function(v) {
    var g = rr(v);
    if (!(!g || g.label.ignore)) {
      o.push(g);
      var p = a.transGroup;
      l && (p.transform ? Gs(zo, p.transform) : wv(zo), g.transform && hs(zo, zo, g.transform), it.copy(jl, g.localRect), jl.applyTransform(zo), s ? s.union(jl) : it.copy(s = new it(0, 0, 0, 0), jl));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (o.sort(function(v, g) {
    return Math.abs(v.label[u] - c) - Math.abs(g.label[u] - c);
  }), l && s) {
    var h = r.getExtent(), d = Math.min(h[0], h[1]), f = Math.max(h[0], h[1]) - d;
    s.union(new it(d, 0, f, 1));
  }
  a.stOccupiedRect = s, a.labelInfoList = o;
}
var zo = qn(), jl = new it(0, 0, 0, 0), IF = function(e, t, n, i, r, a) {
  if (nc(e.nameLocation)) {
    var o = a.stOccupiedRect;
    o && Fw(MF({}, o, a.transGroup.transform), i, r);
  } else
    RF(a.labelInfoList, a.dirVec, i, r);
};
function Fw(e, t, n) {
  var i = new Lt();
  dp(e, t, i, {
    direction: Math.atan2(n.y, n.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && DF(t, i);
}
function RF(e, t, n, i) {
  for (var r = Lt.dot(i, t) >= 0, a = 0, o = e.length; a < o; a++) {
    var s = e[r ? a : o - 1 - a];
    s.label.ignore || Fw(s, n, i);
  }
}
var na = (
  /** @class */
  (function() {
    function e(t, n, i, r) {
      this.group = new Dn(), this._axisModel = t, this._api = n, this._local = {}, this._shared = r || new LF(IF), this._resetCfgDetermined(i);
    }
    return e.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var n = this._shared.ensureRecord(this._axisModel).ready;
        Q(!n.axisLine && !n.axisTickLabelDetermine), n.axisName = n.axisTickLabelEstimate = !1;
      }
      var i = this._cfg.raw;
      i.position = t.position, i.labelOffset = t.labelOffset, this._resetCfgDetermined(i);
    }, e.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, e.prototype._resetCfgDetermined = function(t) {
      var n = this._axisModel, i = n.getDefaultOption ? n.getDefaultOption() : {}, r = J(t.axisName, n.get("name")), a = n.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = J(t.defaultNameMoveOverlap, !0));
      var o = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: J(t.nameDirection, 1),
        tickDirection: J(t.tickDirection, 1),
        labelDirection: J(t.labelDirection, 1),
        labelOffset: J(t.labelOffset, 0),
        silent: J(t.silent, !0),
        axisName: r,
        nameLocation: Zr(n.get("nameLocation"), i.nameLocation, "end"),
        shouldNameMoveOverlap: fp(r) && a,
        optionHideOverlap: n.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: n.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (Q(o.position != null), Q(o.rotation != null)), this._cfg = o;
      var s = new Dn({
        x: o.position[0],
        y: o.position[1],
        rotation: o.rotation
      });
      s.updateTransform(), this._transformGroup = s;
      var l = this._shared.ensureRecord(n);
      l.transGroup = this._transformGroup, l.dirVec = new Lt(Math.cos(-o.rotation), Math.sin(-o.rotation));
    }, e.prototype.build = function(t, n) {
      var i = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), P(NF, function(r) {
        t[r] && FF[r](i._cfg, i._local, i._shared, i._axisModel, i.group, i._transformGroup, i._api, n || {});
      }), this;
    }, e.innerTextLayout = function(t, n, i) {
      var r = y1(n - t), a, o;
      return Iu(r) ? (o = i > 0 ? "top" : "bottom", a = "center") : Iu(r - Wi) ? (o = i > 0 ? "bottom" : "top", a = "center") : (o = "middle", r > 0 && r < Wi ? a = i > 0 ? "right" : "left" : a = i > 0 ? "left" : "right"), {
        rotation: r,
        textAlign: a,
        textVerticalAlign: o
      };
    }, e.makeAxisEventDataBase = function(t) {
      var n = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return n[t.mainType + "Index"] = t.componentIndex, n;
    }, e.isLabelSilent = function(t) {
      var n = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || n && n.show);
    }, e;
  })()
), NF = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], FF = {
  axisLine: function(e, t, n, i, r, a, o) {
    if (process.env.NODE_ENV !== "production") {
      var s = n.ensureRecord(i).ready;
      Q(!s.axisLine), s.axisLine = !0;
    }
    var l = i.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, e.raw.axisLineAutoShow != null && (l = !!e.raw.axisLineAutoShow)), !!l) {
      var u = i.axis.getExtent(), c = a.transform, h = [u[0], 0], d = [u[1], 0], f = h[0] > d[0];
      c && (Ke(h, h, c), Ke(d, d, c));
      var v = $({
        lineCap: "round"
      }, i.getModel(["axisLine", "lineStyle"]).getLineStyle()), g = {
        strokeContainThreshold: e.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: v
      };
      if (i.get(["axisLine", "breakLine"]) && i.axis.scale.hasBreaks())
        CF().buildAxisBreakLine(i, r, a, g);
      else {
        var p = new vo($({
          shape: {
            x1: h[0],
            y1: h[1],
            x2: d[0],
            y2: d[1]
          }
        }, g));
        Uv(p.shape, p.style.lineWidth), p.anid = "line", r.add(p);
      }
      var _ = i.get(["axisLine", "symbol"]);
      if (_ != null) {
        var m = i.get(["axisLine", "symbolSize"]);
        K(_) && (_ = [_, _]), (K(m) || Xt(m)) && (m = [m, m]);
        var y = aN(i.get(["axisLine", "symbolOffset"]) || 0, m), b = m[0], x = m[1];
        P([{
          rotate: e.rotation + Math.PI / 2,
          offset: y[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: y[1],
          r: Math.sqrt((h[0] - d[0]) * (h[0] - d[0]) + (h[1] - d[1]) * (h[1] - d[1]))
        }], function(w, M) {
          if (_[M] !== "none" && _[M] != null) {
            var D = rw(_[M], -b / 2, -x / 2, b, x, v.stroke, !0), T = w.r + w.offset, C = f ? d : h;
            D.attr({
              rotation: w.rotate,
              x: C[0] + T * Math.cos(e.rotation),
              y: C[1] - T * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(D);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(e, t, n, i, r, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = n.ensureRecord(i).ready;
      Q(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = ry(t, r, s);
    u && iy(e, t, n, i, r, a, o, J0.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(e, t, n, i, r, a, o, s) {
    if (process.env.NODE_ENV !== "production") {
      var l = n.ensureRecord(i).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = ry(t, r, s);
    u && iy(e, t, n, i, r, a, o, J0.determine);
    var c = $F(e, r, a, i);
    VF(e, t.labelLayoutList, c), HF(e, r, a, i, e.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(e, t, n, i, r, a, o, s) {
    var l = n.ensureRecord(i);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      Q(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (r.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = e.axisName;
    if (fp(c)) {
      var h = e.nameLocation, d = e.nameDirection, f = i.getModel("nameTextStyle"), v = i.get("nameGap") || 0, g = i.axis.getExtent(), p = i.axis.inverse ? -1 : 1, _ = new Lt(0, 0), m = new Lt(0, 0);
      h === "start" ? (_.x = g[0] - p * v, m.x = -p) : h === "end" ? (_.x = g[1] + p * v, m.x = p) : (_.x = (g[0] + g[1]) / 2, _.y = e.labelOffset + d * v, m.y = d);
      var y = qn();
      m.transform(Mv(y, y, e.rotation));
      var b = i.get("nameRotate");
      b != null && (b = b * Wi / 180);
      var x, w;
      nc(h) ? x = na.innerTextLayout(
        e.rotation,
        b ?? e.rotation,
        // Adapt to axis.
        d
      ) : (x = BF(e.rotation, h, b || 0, g), w = e.raw.axisNameAvailableWidth, w != null && (w = Math.abs(w / Math.sin(x.rotation)), !isFinite(w) && (w = null)));
      var M = f.getFont(), D = i.get("nameTruncate", !0) || {}, T = D.ellipsis, C = er(e.raw.nameTruncateMaxWidth, D.maxWidth, w), k = s.nameMarginLevel || 0, E = new gn({
        x: _.x,
        y: _.y,
        rotation: x.rotation,
        silent: na.isLabelSilent(i),
        style: oa(f, {
          text: c,
          font: M,
          overflow: "truncate",
          width: C,
          ellipsis: T,
          fill: f.getTextColor() || i.get(["axisLine", "lineStyle", "color"]),
          align: f.get("align") || x.textAlign,
          verticalAlign: f.get("verticalAlign") || x.textVerticalAlign
        }),
        z2: 1
      });
      if (jv({
        el: E,
        componentModel: i,
        itemName: c
      }), E.__fullText = c, E.anid = "name", i.get("triggerEvent")) {
        var A = na.makeAxisEventDataBase(i);
        A.targetType = "axisName", A.name = c, Bt(E).eventData = A;
      }
      a.add(E), E.updateTransform(), t.nameEl = E;
      var L = l.nameLayout = rr({
        label: E,
        priority: E.z2,
        defaultAttr: {
          ignore: E.ignore
        },
        marginDefault: nc(h) ? AF[k] : EF[k]
      });
      if (l.nameLocation = h, r.add(E), E.decomposeTransform(), e.shouldNameMoveOverlap && L) {
        var R = n.ensureRecord(i);
        process.env.NODE_ENV !== "production" && Q(R.labelInfoList), n.resolveAxisNameOverlap(e, n, i, L, m, R);
      }
    }
  }
};
function iy(e, t, n, i, r, a, o, s) {
  zw(t) || YF(e, t, r, s, i, o);
  var l = t.labelLayoutList;
  WF(e, i, l, a), e.rotation;
  var u = e.optionHideOverlap;
  zF(i, l, u), u && TF(
    // Filter the already ignored labels by the previous overlap resolving methods.
    qe(l, function(c) {
      return c && !c.label.ignore;
    })
  ), OF(e, n, i, l);
}
function BF(e, t, n, i) {
  var r = y1(n - e), a, o, s = i[0] > i[1], l = t === "start" && !s || t !== "start" && s;
  return Iu(r - Wi / 2) ? (o = l ? "bottom" : "top", a = "center") : Iu(r - Wi * 1.5) ? (o = l ? "top" : "bottom", a = "center") : (o = "middle", r < Wi * 1.5 && r > Wi / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: r,
    textAlign: a,
    textVerticalAlign: o
  };
}
function zF(e, t, n) {
  if (yF(e.axis))
    return;
  function i(s, l, u) {
    var c = rr(t[l]), h = rr(t[u]);
    if (!(!c || !h)) {
      if (s === !1 || c.suggestIgnore) {
        rs(c.label);
        return;
      }
      if (h.suggestIgnore) {
        rs(h.label);
        return;
      }
      var d = 0.1;
      if (!n) {
        var f = [0, 0, 0, 0];
        c = ey({
          marginForce: f
        }, c), h = ey({
          marginForce: f
        }, h);
      }
      dp(c, h, null, {
        touchThreshold: d
      }) && rs(s ? h.label : c.label);
    }
  }
  var r = e.get(["axisLabel", "showMinLabel"]), a = e.get(["axisLabel", "showMaxLabel"]), o = t.length;
  i(r, 0, 1), i(a, o - 1, o - 2);
}
function VF(e, t, n) {
  e.showMinorTicks || P(t, function(i) {
    if (i && i.label.ignore)
      for (var r = 0; r < n.length; r++) {
        var a = n[r], o = Nw(a), s = ac(i.label);
        if (o.tickValue != null && !o.onBand && o.tickValue === s.tickValue) {
          rs(a);
          return;
        }
      }
  });
}
function rs(e) {
  e && (e.ignore = !0);
}
function Bw(e, t, n, i, r) {
  for (var a = [], o = [], s = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    o[0] = u, o[1] = 0, s[0] = u, s[1] = n, t && (Ke(o, o, t), Ke(s, s, t));
    var c = new vo({
      shape: {
        x1: o[0],
        y1: o[1],
        x2: s[0],
        y2: s[1]
      },
      style: i,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    Uv(c.shape, c.style.lineWidth), c.anid = r + "_" + e[l].tickValue, a.push(c);
    var h = Nw(c);
    h.onBand = !!e[l].onBand, h.tickValue = e[l].tickValue;
  }
  return a;
}
function $F(e, t, n, i) {
  var r = i.axis, a = i.getModel("axisTick"), o = a.get("show");
  if (o === "auto" && (o = !0, e.raw.axisTickAutoShow != null && (o = !!e.raw.axisTickAutoShow)), !o || r.scale.isBlank())
    return [];
  for (var s = a.getModel("lineStyle"), l = e.tickDirection * a.get("length"), u = r.getTicksCoords(), c = Bw(u, n.transform, l, Qt(s.getLineStyle(), {
    stroke: i.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), h = 0; h < c.length; h++)
    t.add(c[h]);
  return c;
}
function HF(e, t, n, i, r) {
  var a = i.axis, o = i.getModel("minorTick");
  if (!(!e.showMinorTicks || a.scale.isBlank())) {
    var s = a.getMinorTicksCoords();
    if (s.length)
      for (var l = o.getModel("lineStyle"), u = r * o.get("length"), c = Qt(l.getLineStyle(), Qt(i.getModel("axisTick").getLineStyle(), {
        stroke: i.get(["axisLine", "lineStyle", "color"])
      })), h = 0; h < s.length; h++)
        for (var d = Bw(s[h], n.transform, u, c, "minorticks_" + h), f = 0; f < d.length; f++)
          t.add(d[f]);
  }
}
function ry(e, t, n) {
  if (zw(e)) {
    var i = e.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && Q(e.labelGroup && i);
    var r = i.out.noPxChangeTryDetermine;
    if (n.noPxChange) {
      for (var a = !0, o = 0; o < r.length; o++)
        a = a && r[o]();
      if (a)
        return !1;
    }
    r.length && (t.remove(e.labelGroup), zf(e, null, null, null));
  }
  return !0;
}
function YF(e, t, n, i, r, a) {
  var o = r.axis, s = er(e.raw.axisLabelShow, r.get(["axisLabel", "show"])), l = new Dn();
  n.add(l);
  var u = xF(i);
  if (!s || o.scale.isBlank()) {
    zf(t, [], l, u);
    return;
  }
  var c = r.getModel("axisLabel"), h = o.getViewLabels(u), d = (er(e.raw.labelRotate, c.get("rotate")) || 0) * Wi / 180, f = na.innerTextLayout(e.rotation, d, e.labelDirection), v = r.getCategories && r.getCategories(!0), g = [], p = r.get("triggerEvent"), _ = 1 / 0, m = -1 / 0;
  P(h, function(b, x) {
    var w, M = o.scale.type === "ordinal" ? o.scale.getRawOrdinalNumber(b.tickValue) : b.tickValue, D = b.formattedLabel, T = b.rawLabel, C = c;
    if (v && v[M]) {
      var k = v[M];
      X(k) && k.textStyle && (C = new Gt(k.textStyle, c, r.ecModel));
    }
    var E = C.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), A = C.getShallow("align", !0) || f.textAlign, L = J(C.getShallow("alignMinLabel", !0), A), R = J(C.getShallow("alignMaxLabel", !0), A), N = C.getShallow("verticalAlign", !0) || C.getShallow("baseline", !0) || f.textVerticalAlign, V = J(C.getShallow("verticalAlignMinLabel", !0), N), q = J(C.getShallow("verticalAlignMaxLabel", !0), N), W = 10 + (((w = b.time) === null || w === void 0 ? void 0 : w.level) || 0);
    _ = Math.min(_, W), m = Math.max(m, W);
    var Z = new gn({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: na.isLabelSilent(r),
      z2: W,
      style: oa(C, {
        text: D,
        align: x === 0 ? L : x === h.length - 1 ? R : A,
        verticalAlign: x === 0 ? V : x === h.length - 1 ? q : N,
        fill: gt(E) ? E(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          o.type === "category" ? T : o.type === "value" ? M + "" : M,
          x
        ) : E
      })
    });
    Z.anid = "label_" + M;
    var bt = ac(Z);
    if (bt.break = b.break, bt.tickValue = M, bt.layoutRotation = f.rotation, jv({
      el: Z,
      componentModel: r,
      itemName: D,
      formatterParamsExtra: {
        isTruncated: function() {
          return Z.isTruncated;
        },
        value: T,
        tickIndex: x
      }
    }), p) {
      var et = na.makeAxisEventDataBase(r);
      et.targetType = "axisLabel", et.value = T, et.tickIndex = x, b.break && (et.break = {
        // type: labelItem.break.type,
        start: b.break.parsedBreak.vmin,
        end: b.break.parsedBreak.vmax
      }), o.type === "category" && (et.dataIndex = M), Bt(Z).eventData = et, b.break && GF(r, a, Z, b.break);
    }
    g.push(Z), l.add(Z);
  });
  var y = yt(g, function(b) {
    return {
      label: b,
      priority: ac(b).break ? b.z2 + (m - _ + 1) : b.z2,
      defaultAttr: {
        ignore: b.ignore
      }
    };
  });
  zf(t, y, l, u);
}
function zw(e) {
  return !!e.labelLayoutList;
}
function zf(e, t, n, i) {
  e.labelLayoutList = t, e.labelGroup = n, e.axisLabelsCreationContext = i;
}
function WF(e, t, n, i) {
  var r = t.get(["axisLabel", "margin"]);
  P(n, function(a, o) {
    var s = rr(a);
    if (s) {
      var l = s.label, u = ac(l);
      s.suggestIgnore = l.ignore, l.ignore = !1, uf(si, UF), si.x = t.axis.dataToCoord(u.tickValue), si.y = e.labelOffset + e.labelDirection * r, si.rotation = u.layoutRotation, i.add(si), si.updateTransform(), i.remove(si), si.decomposeTransform(), uf(l, si), l.markRedraw(), rc(s, !0), rr(s);
    }
  });
}
var si = new be(), UF = new be();
function fp(e) {
  return !!e;
}
function GF(e, t, n, i) {
  n.on("click", function(r) {
    var a = {
      type: PF,
      breaks: [{
        start: i.parsedBreak.breakOption.start,
        end: i.parsedBreak.breakOption.end
      }]
    };
    a[e.axis.dim + "AxisIndex"] = e.componentIndex, t.dispatchAction(a);
  });
}
function ay(e, t, n) {
  n = n || {};
  var i = t.axis, r = {}, a = i.getAxesOnZeroOf()[0], o = i.position, s = a ? "onZero" : o, l = i.dim, u = [e.x, e.x + e.width, e.y, e.y + e.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, h = t.get("offset") || 0, d = l === "x" ? [u[2] - h, u[3] + h] : [u[0] - h, u[1] + h];
  if (a) {
    var f = a.toGlobalCoord(a.dataToCoord(0));
    d[c.onZero] = Math.max(Math.min(f, d[1]), d[0]);
  }
  r.position = [l === "y" ? d[c[s]] : u[0], l === "x" ? d[c[s]] : u[3]], r.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  r.labelDirection = r.tickDirection = r.nameDirection = v[o], r.labelOffset = a ? d[c[o]] - d[c.onZero] : 0, t.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), er(n.labelInside, t.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
  var g = t.get(["axisLabel", "rotate"]);
  return r.labelRotate = s === "top" ? -g : g, r.z2 = 1, r;
}
function jF(e, t) {
  var n = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return XF(n, e, t), n.seriesInvolved && ZF(n, e), n;
}
function XF(e, t, n) {
  var i = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", !0) || [], o = [];
  P(n.getCoordinateSystems(), function(s) {
    if (!s.axisPointerEnabled)
      return;
    var l = zs(s.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = s;
    var c = s.model, h = c.getModel("tooltip", i);
    if (P(s.getAxes(), Pe(g, !1, null)), s.getTooltipAxes && i && h.get("show")) {
      var d = h.get("trigger") === "axis", f = h.get(["axisPointer", "type"]) === "cross", v = s.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (d || f) && P(v.baseAxes, Pe(g, f ? "cross" : !0, d)), f && P(v.otherAxes, Pe(g, "cross", !1));
    }
    function g(p, _, m) {
      var y = m.model.getModel("axisPointer", r), b = y.get("show");
      if (!(!b || b === "auto" && !p && !Vf(y))) {
        _ == null && (_ = y.get("triggerTooltip")), y = p ? qF(m, h, r, t, p, _) : y;
        var x = y.get("snap"), w = y.get("triggerEmphasis"), M = zs(m.model), D = _ || x || m.type === "category", T = e.axesInfo[M] = {
          key: M,
          axis: m,
          coordSys: s,
          axisPointerModel: y,
          triggerTooltip: _,
          triggerEmphasis: w,
          involveSeries: D,
          snap: x,
          useHandle: Vf(y),
          seriesModels: [],
          linkGroup: null
        };
        u[M] = T, e.seriesInvolved = e.seriesInvolved || D;
        var C = KF(a, m);
        if (C != null) {
          var k = o[C] || (o[C] = {
            axesInfo: {}
          });
          k.axesInfo[M] = T, k.mapper = a[C].mapper, T.linkGroup = k;
        }
      }
    }
  });
}
function qF(e, t, n, i, r, a) {
  var o = t.getModel("axisPointer"), s = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  P(s, function(d) {
    l[d] = ft(o.get(d));
  }), l.snap = e.type !== "category" && !!a, o.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), r === "cross") {
    var c = o.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var h = l.lineStyle = o.get("crossStyle");
      h && Qt(u, h.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new Gt(l, n, i));
}
function ZF(e, t) {
  t.eachSeries(function(n) {
    var i = n.coordinateSystem, r = n.get(["tooltip", "trigger"], !0), a = n.get(["tooltip", "show"], !0);
    !i || !i.model || r === "none" || r === !1 || r === "item" || a === !1 || n.get(["axisPointer", "show"], !0) === !1 || P(e.coordSysAxesInfo[zs(i.model)], function(o) {
      var s = o.axis;
      i.getAxis(s.dim) === s && (o.seriesModels.push(n), o.seriesDataCount == null && (o.seriesDataCount = 0), o.seriesDataCount += n.getData().count());
    });
  });
}
function KF(e, t) {
  for (var n = t.model, i = t.dim, r = 0; r < e.length; r++) {
    var a = e[r] || {};
    if (xd(a[i + "AxisId"], n.id) || xd(a[i + "AxisIndex"], n.componentIndex) || xd(a[i + "AxisName"], n.name))
      return r;
  }
}
function xd(e, t) {
  return e === "all" || U(e) && zt(e, t) >= 0 || e === t;
}
function QF(e) {
  var t = vp(e);
  if (t) {
    var n = t.axisPointerModel, i = t.axis.scale, r = n.option, a = n.get("status"), o = n.get("value");
    o != null && (o = i.parse(o));
    var s = Vf(n);
    a == null && (r.status = s ? "show" : "hide");
    var l = i.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (o == null || o > l[1]) && (o = l[1]), o < l[0] && (o = l[0]), r.value = o, s && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function vp(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[zs(e)];
}
function JF(e) {
  var t = vp(e);
  return t && t.axisPointerModel;
}
function Vf(e) {
  return !!e.get(["handle", "show"]);
}
function zs(e) {
  return e.type + "||" + e.id;
}
var wd = {}, t4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.prototype.render = function(n, i, r, a) {
      this.axisPointerClass && QF(n), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(n, r, !0);
    }, t.prototype.updateAxisPointer = function(n, i, r, a) {
      this._doUpdateAxisPointerClass(n, r, !1);
    }, t.prototype.remove = function(n, i) {
      var r = this._axisPointer;
      r && r.remove(i);
    }, t.prototype.dispose = function(n, i) {
      this._disposeAxisPointer(i), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(n, i, r) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var o = JF(n);
        o ? (this._axisPointer || (this._axisPointer = new a())).render(n, o, i, r) : this._disposeAxisPointer(i);
      }
    }, t.prototype._disposeAxisPointer = function(n) {
      this._axisPointer && this._axisPointer.dispose(n), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(n, i) {
      if (process.env.NODE_ENV !== "production" && wd[n])
        throw new Error("axisPointer " + n + " exists");
      wd[n] = i;
    }, t.getAxisPointerClass = function(n) {
      return n && wd[n];
    }, t.type = "axis", t;
  })(Ti)
), zr = Wt(), oy = ft, Sd = Tt, e4 = (
  /** @class */
  (function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, n, i, r) {
      var a = n.get("value"), o = n.get("status");
      if (this._axisModel = t, this._axisPointerModel = n, this._api = i, !(!r && this._lastValue === a && this._lastStatus === o)) {
        this._lastValue = a, this._lastStatus = o;
        var s = this._group, l = this._handle;
        if (!o || o === "hide") {
          s && s.hide(), l && l.hide();
          return;
        }
        s && s.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, n, i);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(i), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(t, n);
        if (!s)
          s = this._group = new Dn(), this.createPointerEl(s, u, t, n), this.createLabelEl(s, u, t, n), i.getZr().add(s);
        else {
          var d = Pe(sy, n, h);
          this.updatePointerEl(s, u, d), this.updateLabelEl(s, u, d, n);
        }
        uy(s, n, !0), this._renderHandle(a);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, n) {
      var i = n.get("animation"), r = t.axis, a = r.type === "category", o = n.get("snap");
      if (!o && !a)
        return !1;
      if (i === "auto" || i == null) {
        var s = this.animationThreshold;
        if (a && r.getBandWidth() > s)
          return !0;
        if (o) {
          var l = vp(t).seriesDataCount, u = r.getExtent();
          return Math.abs(u[0] - u[1]) / l > s;
        }
        return !1;
      }
      return i === !0;
    }, e.prototype.makeElOption = function(t, n, i, r, a) {
    }, e.prototype.createPointerEl = function(t, n, i, r) {
      var a = n.pointer;
      if (a) {
        var o = zr(t).pointerEl = new bI[a.type](oy(n.pointer));
        t.add(o);
      }
    }, e.prototype.createLabelEl = function(t, n, i, r) {
      if (n.label) {
        var a = zr(t).labelEl = new gn(oy(n.label));
        t.add(a), ly(a, r);
      }
    }, e.prototype.updatePointerEl = function(t, n, i) {
      var r = zr(t).pointerEl;
      r && n.pointer && (r.setStyle(n.pointer.style), i(r, {
        shape: n.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, n, i, r) {
      var a = zr(t).labelEl;
      a && (a.setStyle(n.label.style), i(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: n.label.x,
        y: n.label.y
      }), ly(a, r));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var n = this._axisPointerModel, i = this._api.getZr(), r = this._handle, a = n.getModel("handle"), o = n.get("status");
        if (!a.get("show") || !o || o === "hide") {
          r && i.remove(r), this._handle = null;
          return;
        }
        var s;
        this._handle || (s = !0, r = this._handle = lx(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Tu(u.event);
          },
          onmousedown: Sd(this._onHandleDragMove, this, 0, 0),
          drift: Sd(this._onHandleDragMove, this),
          ondragend: Sd(this._onHandleDragEnd, this)
        }), i.add(r)), uy(r, n, !1), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        U(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, Zx(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, s);
      }
    }, e.prototype._moveHandleToValue = function(t, n) {
      sy(this._axisPointerModel, !n && this._moveAnimation, this._handle, Md(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, n) {
      var i = this._handle;
      if (i) {
        this._dragging = !0;
        var r = this.updateHandleTransform(Md(i), [t, n], this._axisModel, this._axisPointerModel);
        this._payloadInfo = r, i.stopAnimation(), i.attr(Md(r)), zr(i).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var n = this._payloadInfo, i = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: n.cursorPoint[0],
          y: n.cursorPoint[1],
          tooltipOption: n.tooltipOption,
          axesInfo: [{
            axisDim: i.axis.dim,
            axisIndex: i.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var n = this._axisPointerModel.get("value");
        this._moveHandleToValue(n), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var n = t.getZr(), i = this._group, r = this._handle;
      n && i && (this._lastGraphicKey = null, i && n.remove(i), r && n.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), Pf(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, n, i) {
      return i = i || 0, {
        x: t[i],
        y: t[1 - i],
        width: n[i],
        height: n[1 - i]
      };
    }, e;
  })()
);
function sy(e, t, n, i) {
  Vw(zr(n).lastProp, i) || (zr(n).lastProp = i, t ? Yv(n, i, e) : (n.stopAnimation(), n.attr(i)));
}
function Vw(e, t) {
  if (X(e) && X(t)) {
    var n = !0;
    return P(t, function(i, r) {
      n = n && Vw(e[r], i);
    }), !!n;
  } else
    return e === t;
}
function ly(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function Md(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function uy(e, t, n) {
  var i = t.get("z"), r = t.get("zlevel");
  e && e.traverse(function(a) {
    a.type !== "group" && (i != null && (a.z = i), r != null && (a.zlevel = r), a.silent = n);
  });
}
function n4(e) {
  var t = e.get("type"), n = e.getModel(t + "Style"), i;
  return t === "line" ? (i = n.getLineStyle(), i.fill = null) : t === "shadow" && (i = n.getAreaStyle(), i.stroke = null), i;
}
function i4(e, t, n, i, r) {
  var a = n.get("value"), o = $w(a, t.axis, t.ecModel, n.get("seriesDataIndices"), {
    precision: n.get(["label", "precision"]),
    formatter: n.get(["label", "formatter"])
  }), s = n.getModel("label"), l = Qv(s.get("padding") || 0), u = s.getFont(), c = wE(o, u), h = r.position, d = c.width + l[1] + l[3], f = c.height + l[0] + l[2], v = r.align;
  v === "right" && (h[0] -= d), v === "center" && (h[0] -= d / 2);
  var g = r.verticalAlign;
  g === "bottom" && (h[1] -= f), g === "middle" && (h[1] -= f / 2), r4(h, d, f, i);
  var p = s.get("backgroundColor");
  (!p || p === "auto") && (p = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: oa(s, {
      text: o,
      font: u,
      fill: s.getTextColor(),
      padding: l,
      backgroundColor: p
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function r4(e, t, n, i) {
  var r = i.getWidth(), a = i.getHeight();
  e[0] = Math.min(e[0] + t, r) - t, e[1] = Math.min(e[1] + n, a) - n, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function $w(e, t, n, i, r) {
  e = t.scale.parse(e);
  var a = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: r.precision
  }), o = r.formatter;
  if (o) {
    var s = {
      value: Ow(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    P(i, function(l) {
      var u = n.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && s.seriesData.push(h);
    }), K(o) ? a = o.replace("{value}", a) : gt(o) && (a = o(s));
  }
  return a;
}
function Hw(e, t, n) {
  var i = qn();
  return Mv(i, i, n.rotation), qd(i, i, n.position), Gv([e.dataToCoord(t), (n.labelOffset || 0) + (n.labelDirection || 1) * (n.labelMargin || 0)], i);
}
function a4(e, t, n, i, r, a) {
  var o = na.innerTextLayout(n.rotation, 0, n.labelDirection);
  n.labelMargin = r.get(["label", "margin"]), i4(t, i, r, a, {
    position: Hw(i.axis, e, n),
    align: o.textAlign,
    verticalAlign: o.textVerticalAlign
  });
}
function o4(e, t, n) {
  return n = n || 0, {
    x1: e[n],
    y1: e[1 - n],
    x2: t[n],
    y2: t[1 - n]
  };
}
function s4(e, t, n) {
  return n = n || 0, {
    x: e[n],
    y: e[1 - n],
    width: t[n],
    height: t[1 - n]
  };
}
var l4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(n, i, r, a, o) {
      var s = r.axis, l = s.grid, u = a.get("type"), c = cy(l, s).getOtherAxis(s).getGlobalExtent(), h = s.toGlobalCoord(s.dataToCoord(i, !0));
      if (u && u !== "none") {
        var d = n4(a), f = u4[u](s, h, c);
        f.style = d, n.graphicKey = f.type, n.pointer = f;
      }
      var v = ay(l.getRect(), r);
      a4(i, n, v, r, a, o);
    }, t.prototype.getHandleTransform = function(n, i, r) {
      var a = ay(i.axis.grid.getRect(), i, {
        labelInside: !1
      });
      a.labelMargin = r.get(["handle", "margin"]);
      var o = Hw(i.axis, n, a);
      return {
        x: o[0],
        y: o[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(n, i, r, a) {
      var o = r.axis, s = o.grid, l = o.getGlobalExtent(!0), u = cy(s, o).getOtherAxis(o).getGlobalExtent(), c = o.dim === "x" ? 0 : 1, h = [n.x, n.y];
      h[c] += i[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var d = (u[1] + u[0]) / 2, f = [d, d];
      f[c] = h[c];
      var v = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: n.rotation,
        cursorPoint: f,
        tooltipOption: v[c]
      };
    }, t;
  })(e4)
);
function cy(e, t) {
  var n = {};
  return n[t.dim + "AxisIndex"] = t.index, e.getCartesian(n);
}
var u4 = {
  line: function(e, t, n) {
    var i = o4([t, n[0]], [t, n[1]], hy(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: i
    };
  },
  shadow: function(e, t, n) {
    var i = Math.max(1, e.getBandWidth()), r = n[1] - n[0];
    return {
      type: "Rect",
      shape: s4([t - i / 2, n[0]], [i, r], hy(e))
    };
  }
};
function hy(e) {
  return e.dim === "x" ? 0 : 1;
}
var c4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: St.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: St.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: St.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: St.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: St.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  })(Pt)
), _i = Wt(), h4 = P;
function Yw(e, t, n) {
  if (!tt.node) {
    var i = t.getZr();
    _i(i).records || (_i(i).records = {}), d4(i, t);
    var r = _i(i).records[e] || (_i(i).records[e] = {});
    r.handler = n;
  }
}
function d4(e, t) {
  if (_i(e).initialized)
    return;
  _i(e).initialized = !0, n("click", Pe(dy, "click")), n("mousemove", Pe(dy, "mousemove")), n("globalout", v4);
  function n(i, r) {
    e.on(i, function(a) {
      var o = p4(t);
      h4(_i(e).records, function(s) {
        s && r(s, a, o.dispatchAction);
      }), f4(o.pendings, t);
    });
  }
}
function f4(e, t) {
  var n = e.showTip.length, i = e.hideTip.length, r;
  n ? r = e.showTip[n - 1] : i && (r = e.hideTip[i - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
}
function v4(e, t, n) {
  e.handler("leave", null, n);
}
function dy(e, t, n, i) {
  t.handler(e, n, i);
}
function p4(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, n = function(i) {
    var r = t[i.type];
    r ? r.push(i) : (i.dispatchAction = n, e.dispatchAction(i));
  };
  return {
    dispatchAction: n,
    pendings: t
  };
}
function $f(e, t) {
  if (!tt.node) {
    var n = t.getZr(), i = (_i(n).records || {})[e];
    i && (_i(n).records[e] = null);
  }
}
var g4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.prototype.render = function(n, i, r) {
      var a = i.getComponent("tooltip"), o = n.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      Yw("axisPointer", r, function(s, l, u) {
        o !== "none" && (s === "leave" || o.indexOf(s) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: s,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(n, i) {
      $f("axisPointer", i);
    }, t.prototype.dispose = function(n, i) {
      $f("axisPointer", i);
    }, t.type = "axisPointer", t;
  })(Ti)
);
function Ww(e, t) {
  var n = [], i = e.seriesIndex, r;
  if (i == null || !(r = t.getSeriesByIndex(i)))
    return {
      point: []
    };
  var a = r.getData(), o = Xs(a, e);
  if (o == null || o < 0 || U(o))
    return {
      point: []
    };
  var s = a.getItemGraphicEl(o), l = r.coordinateSystem;
  if (r.getTooltipPosition)
    n = r.getTooltipPosition(o) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, d = u.dim, f = h === "x" || h === "radius" ? 1 : 0, v = a.mapDimension(d), g = [];
      g[f] = a.get(v, o), g[1 - f] = a.get(a.getCalculationInfo("stackResultDimension"), o), n = l.dataToPoint(g) || [];
    } else
      n = l.dataToPoint(a.getValues(yt(l.dimensions, function(_) {
        return a.mapDimension(_);
      }), o)) || [];
  else if (s) {
    var p = s.getBoundingRect().clone();
    p.applyTransform(s.transform), n = [p.x + p.width / 2, p.y + p.height / 2];
  }
  return {
    point: n,
    el: s
  };
}
var fy = Wt();
function _4(e, t, n) {
  var i = e.currTrigger, r = [e.x, e.y], a = e, o = e.dispatchAction || Tt(n.dispatchAction, n), s = t.getComponent("axisPointer").coordSysAxesInfo;
  if (s) {
    hu(r) && (r = Ww({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = hu(r), u = a.axesInfo, c = s.axesInfo, h = i === "leave" || hu(r), d = {}, f = {}, v = {
      list: [],
      map: {}
    }, g = {
      showPointer: Pe(y4, f),
      showTooltip: Pe(b4, v)
    };
    P(s.coordSysMap, function(_, m) {
      var y = l || _.containPoint(r);
      P(s.coordSysAxesInfo[m], function(b, x) {
        var w = b.axis, M = M4(u, b);
        if (!h && y && (!u || M)) {
          var D = M && M.value;
          D == null && !l && (D = w.pointToData(r)), D != null && vy(b, D, g, !1, d);
        }
      });
    });
    var p = {};
    return P(c, function(_, m) {
      var y = _.linkGroup;
      y && !f[m] && P(y.axesInfo, function(b, x) {
        var w = f[x];
        if (b !== _ && w) {
          var M = w.value;
          y.mapper && (M = _.axis.scale.parse(y.mapper(M, py(b), py(_)))), p[_.key] = M;
        }
      });
    }), P(p, function(_, m) {
      vy(c[m], _, g, !0, d);
    }), x4(f, c, d), w4(v, r, e, o), S4(c, o, n), d;
  }
}
function vy(e, t, n, i, r) {
  var a = e.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!e.involveSeries) {
      n.showPointer(e, t);
      return;
    }
    var o = m4(t, e), s = o.payloadBatch, l = o.snapToValue;
    s[0] && r.seriesIndex == null && $(r, s[0]), !i && e.snap && a.containData(l) && l != null && (t = l), n.showPointer(e, t, s), n.showTooltip(e, o, l);
  }
}
function m4(e, t) {
  var n = t.axis, i = n.dim, r = e, a = [], o = Number.MAX_VALUE, s = -1;
  return P(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(i), h, d;
    if (l.getAxisTooltipData) {
      var f = l.getAxisTooltipData(c, e, n);
      d = f.dataIndices, h = f.nestestValue;
    } else {
      if (d = l.indicesOfNearest(
        i,
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        n.type === "category" ? 0.5 : null
      ), !d.length)
        return;
      h = l.getData().get(c[0], d[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var v = e - h, g = Math.abs(v);
      g <= o && ((g < o || v >= 0 && s < 0) && (o = g, s = v, r = h, a.length = 0), P(d, function(p) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: p,
          dataIndex: l.getData().getRawIndex(p)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: r
  };
}
function y4(e, t, n, i) {
  e[t.key] = {
    value: n,
    payloadBatch: i
  };
}
function b4(e, t, n, i) {
  var r = n.payloadBatch, a = t.axis, o = a.model, s = t.axisPointerModel;
  if (!(!t.triggerTooltip || !r.length)) {
    var l = t.coordSys.model, u = zs(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: o.componentIndex,
      axisType: o.type,
      axisId: o.id,
      value: i,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: s.get(["label", "precision"]),
        formatter: s.get(["label", "formatter"])
      },
      seriesDataIndices: r.slice()
    });
  }
}
function x4(e, t, n) {
  var i = n.axesInfo = [];
  P(t, function(r, a) {
    var o = r.axisPointerModel.option, s = e[a];
    s ? (!r.useHandle && (o.status = "show"), o.value = s.value, o.seriesDataIndices = (s.payloadBatch || []).slice()) : !r.useHandle && (o.status = "hide"), o.status === "show" && i.push({
      axisDim: r.axis.dim,
      axisIndex: r.axis.model.componentIndex,
      value: o.value
    });
  });
}
function w4(e, t, n, i) {
  if (hu(t) || !e.list.length) {
    i({
      type: "hideTip"
    });
    return;
  }
  var r = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  i({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: n.tooltipOption,
    position: n.position,
    dataIndexInside: r.dataIndexInside,
    dataIndex: r.dataIndex,
    seriesIndex: r.seriesIndex,
    dataByCoordSys: e.list
  });
}
function S4(e, t, n) {
  var i = n.getZr(), r = "axisPointerLastHighlights", a = fy(i)[r] || {}, o = fy(i)[r] = {};
  P(e, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && P(h.seriesDataIndices, function(d) {
      var f = d.seriesIndex + " | " + d.dataIndex;
      o[f] = d;
    });
  });
  var s = [], l = [];
  P(a, function(u, c) {
    !o[c] && l.push(u);
  }), P(o, function(u, c) {
    !a[c] && s.push(u);
  }), l.length && n.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), s.length && n.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: s
  });
}
function M4(e, t) {
  for (var n = 0; n < (e || []).length; n++) {
    var i = e[n];
    if (t.axis.dim === i.axisDim && t.axis.model.componentIndex === i.axisIndex)
      return i;
  }
}
function py(e) {
  var t = e.axis.model, n = {}, i = n.axisDim = e.axis.dim;
  return n.axisIndex = n[i + "AxisIndex"] = t.componentIndex, n.axisName = n[i + "AxisName"] = t.name, n.axisId = n[i + "AxisId"] = t.id, n;
}
function hu(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function D4(e) {
  t4.registerAxisPointerClass("CartesianAxisPointer", l4), e.registerComponentModel(c4), e.registerComponentView(g4), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var n = t.axisPointer.link;
      n && !U(n) && (t.axisPointer.link = [n]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, n) {
    t.getComponent("axisPointer").coordSysAxesInfo = jF(t, n);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, _4);
}
function T4(e, t, n) {
  var i = e.target;
  i.x += t, i.y += n, i.dirty();
}
function k4(e, t, n, i) {
  var r = e.target, a = e.zoomLimit, o = e.zoom = e.zoom || 1;
  o *= t, o = pp(o, a);
  var s = o / e.zoom;
  e.zoom = o, Uw(r, n, i, s), r.dirty();
}
function C4(e, t, n, i, r, a) {
  var o = new it(0, 0, 0, 0);
  i.enable(e.get("roam"), {
    api: t,
    zInfo: {
      component: e
    },
    triggerInfo: {
      roamTrigger: e.get("roamTrigger"),
      isInSelf: function(u, c, h) {
        return o.copy(n.getBoundingRect()), o.applyTransform(n.getComputedTransform()), o.contain(c, h);
      },
      isInClip: function(u, c, h) {
        return !0;
      }
    }
  }), r.zoomLimit = e.get("scaleLimit");
  var s = e.coordinateSystem;
  r.zoom = s ? s.getZoom() : 1;
  var l = e.subType + "Roam";
  i.off("pan").off("zoom").on("pan", function(u) {
    T4(r, u.dx, u.dy), t.dispatchAction({
      seriesId: e.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    k4(r, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: e.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function gy(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function P4(e, t, n) {
  var i = e.getZoom(), r = e.getCenter(), a = t.zoom, o = e.projectedToPoint ? e.projectedToPoint(r) : e.dataToPoint(r);
  return t.dx != null && t.dy != null && (o[0] -= t.dx, o[1] -= t.dy, e.setCenter(gy(e, o))), a != null && (a = pp(i * a, n) / i, Uw(e, t.originX, t.originY, a), e.updateTransform(), e.setCenter(gy(e, o)), e.setZoom(a * i)), {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
function Uw(e, t, n, i) {
  e.x -= (t - e.x) * (i - 1), e.y -= (n - e.y) * (i - 1), e.scaleX *= i, e.scaleY *= i;
}
function pp(e, t) {
  if (t) {
    var n = t.min || 0, i = t.max || 1 / 0;
    e = Math.max(Math.min(i, e), n);
  }
  return e;
}
var _y = Ke, A4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(n, i) {
      var r = e.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Hr(), r._rawTransformable = new Hr(), r.name = n, r._opt = i, r;
    }
    return t.prototype.setBoundingRect = function(n, i, r, a) {
      return this._rect = new it(n, i, r, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(n, i, r, a) {
      this._transformTo(n, i, r, a), this._viewRect = new it(n, i, r, a);
    }, t.prototype._transformTo = function(n, i, r, a) {
      var o = this.getBoundingRect(), s = this._rawTransformable;
      s.transform = o.calculateTransform(new it(n, i, r, a));
      var l = s.parent;
      s.parent = null, s.decomposeTransform(), s.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(n) {
      var i = this._opt;
      i && i.api && i.ecModel && i.ecModel.getShallow("legacyViewCoordSysCenterBase") && n && (n = [Ve(n[0], i.api.getWidth()), Ve(n[1], i.api.getWidth())]), this._centerOption = ft(n), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(n) {
      this._zoom = pp(n || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var n = this.getBoundingRect(), i = n.x + n.width / 2, r = n.y + n.height / 2;
      return [i, r];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var n = this._centerOption, i = this._rect;
      n && i && (this._center = [Ve(n[0], i.width, i.x), Ve(n[1], i.height, i.y)]);
      var r = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, o = this.getDefaultCenter(), s = this.getCenter(), l = this.getZoom();
      s = Ke([], s, r), o = Ke([], o, r), a.originX = s[0], a.originY = s[1], a.x = o[0] - s[0], a.y = o[1] - s[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var n = this._roamTransformable, i = this._rawTransformable;
      i.parent = n, n.updateTransform(), i.updateTransform(), Sv(this.transform || (this.transform = []), i.transform || qn()), this._rawTransform = i.getLocalTransform(), this.invTransform = this.invTransform || [], Gs(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var n = this._rawTransformable, i = this._roamTransformable, r = new Hr();
      return r.transform = i.transform, r.decomposeTransform(), {
        roam: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        },
        raw: {
          x: n.x,
          y: n.y,
          scaleX: n.scaleX,
          scaleY: n.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var n = this.getBoundingRect().clone();
      return n.applyTransform(this.transform), n;
    }, t.prototype.dataToPoint = function(n, i, r) {
      var a = i ? this._rawTransform : this.transform;
      return r = r || [], a ? _y(r, n, a) : dA(r, n);
    }, t.prototype.pointToData = function(n, i, r) {
      r = r || [];
      var a = this.invTransform;
      return a ? _y(r, n, a) : (r[0] = n[0], r[1] = n[1], r);
    }, t.prototype.convertToPixel = function(n, i, r) {
      var a = my(i);
      return a === this ? a.dataToPoint(r) : null;
    }, t.prototype.convertFromPixel = function(n, i, r) {
      var a = my(i);
      return a === this ? a.pointToData(r) : null;
    }, t.prototype.containPoint = function(n) {
      return this.getViewRectAfterRoam().contain(n[0], n[1]);
    }, t.dimensions = ["x", "y"], t;
  })(Hr)
);
function my(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var E4 = Wt();
function yy(e, t) {
  return !!E4(e)[t];
}
ha({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, ye);
var L4 = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function O4(e, t, n) {
  var i = t.getComponentByElement(e.topTarget);
  if (!i || i === n || L4.hasOwnProperty(i.mainType))
    return !1;
  var r = i.coordinateSystem;
  if (!r || r.model === n)
    return !1;
  var a = Is(i), o = Is(n);
  return !((a.zlevel - o.zlevel || a.z - o.z) <= 0);
}
var I4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(n) {
      var i = e.call(this) || this;
      i._zr = n;
      var r = Tt(i._mousedownHandler, i), a = Tt(i._mousemoveHandler, i), o = Tt(i._mouseupHandler, i), s = Tt(i._mousewheelHandler, i), l = Tt(i._pinchHandler, i);
      return i.enable = function(u, c) {
        var h = c.zInfo, d = Is(h.component), f = d.z, v = d.zlevel, g = {
          component: h.component,
          z: f,
          zlevel: v,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: J(h.z2, -1 / 0)
        }, p = $({}, c.triggerInfo);
        this._opt = Qt($({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: g,
          triggerInfo: p
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && ($o(n, "mousedown", r, g), $o(n, "mousemove", a, g), $o(n, "mouseup", o, g)), (u === !0 || u === "scale" || u === "zoom") && ($o(n, "mousewheel", s, g), $o(n, "pinch", l, g)));
      }, i.disable = function() {
        this._enabled = !1, Ho(n, "mousedown", r), Ho(n, "mousemove", a), Ho(n, "mouseup", o), Ho(n, "mousewheel", s), Ho(n, "pinch", l);
      }, i;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(n, i, r) {
      var a = this._opt, o = a.zInfoParsed;
      if (O4(n, a.api, o.component))
        return !1;
      var s = a.triggerInfo, l = s.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = s.isInSelf(n, i, r)), u && s.isInClip && !s.isInClip(n, i, r) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(n, i, r, a) {
      var o = n.target;
      if (!o && this._checkPointer(n, i, r))
        return "grab";
      if (a)
        return o && o.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(n) {
      if (!(g_(n) || Vo(n))) {
        for (var i = n.target; i; ) {
          if (i.draggable)
            return;
          i = i.__hostTarget || i.parent;
        }
        var r = n.offsetX, a = n.offsetY;
        this._checkPointer(n, r, a) && (this._x = r, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(n) {
      var i = this._zr;
      if (!(n.gestureEvent === "pinch" || yy(i, "globalPan") || Vo(n))) {
        var r = n.offsetX, a = n.offsetY;
        if (!this._dragging || !du("moveOnMouseMove", n, this._opt)) {
          var o = this._decideCursorStyle(n, r, a, !1);
          o && i.setCursorStyle(o);
          return;
        }
        i.setCursorStyle("grabbing");
        var s = this._x, l = this._y, u = r - s, c = a - l;
        this._x = r, this._y = a, this._opt.preventDefaultMouseMove && Tu(n.event), n.__ecRoamConsumed = !0, by(this, "pan", "moveOnMouseMove", n, {
          dx: u,
          dy: c,
          oldX: s,
          oldY: l,
          newX: r,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(n) {
      if (!Vo(n)) {
        var i = this._zr;
        if (!g_(n)) {
          this._dragging = !1;
          var r = this._decideCursorStyle(n, n.offsetX, n.offsetY, !0);
          r && i.setCursorStyle(r);
        }
      }
    }, t.prototype._mousewheelHandler = function(n) {
      if (!Vo(n)) {
        var i = du("zoomOnMouseWheel", n, this._opt), r = du("moveOnMouseWheel", n, this._opt), a = n.wheelDelta, o = Math.abs(a), s = n.offsetX, l = n.offsetY;
        if (!(a === 0 || !i && !r)) {
          if (i) {
            var u = o > 3 ? 1.4 : o > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", n, {
              scale: c,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (r) {
            var h = Math.abs(a), d = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", n, {
              scrollDelta: d,
              originX: s,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(n) {
      if (!(yy(this._zr, "globalPan") || Vo(n))) {
        var i = n.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, n, {
          scale: i,
          originX: n.pinchX,
          originY: n.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(n, i, r, a, o) {
      n._checkPointer(a, o.originX, o.originY) && (Tu(a.event), a.__ecRoamConsumed = !0, by(n, i, r, a, o));
    }, t;
  })(En)
);
function Vo(e) {
  return e.__ecRoamConsumed;
}
var R4 = Wt();
function zc(e) {
  var t = R4(e);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function $o(e, t, n, i) {
  for (var r = zc(e), a = r.roam, o = a[t] = a[t] || [], s = 0; s < o.length; s++) {
    var l = o[s].zInfoParsed;
    if ((l.zlevel - i.zlevel || l.z - i.z || l.z2 - i.z2) <= 0)
      break;
  }
  o.splice(s, 0, {
    listener: n,
    zInfoParsed: i
  }), N4(e, t);
}
function Ho(e, t, n) {
  for (var i = zc(e), r = i.roam[t] || [], a = 0; a < r.length; a++)
    if (r[a].listener === n) {
      r.splice(a, 1), r.length || F4(e, t);
      return;
    }
}
function N4(e, t) {
  var n = zc(e);
  n.uniform[t] || e.on(t, n.uniform[t] = function(i) {
    var r = n.roam[t];
    if (r)
      for (var a = 0; a < r.length; a++)
        r[a].listener(i);
  });
}
function F4(e, t) {
  var n = zc(e), i = n.uniform;
  i[t] && (e.off(t, i[t]), i[t] = null);
}
function by(e, t, n, i, r) {
  r.isAvailableBehavior = Tt(du, null, n, i), e.trigger(t, r);
}
function du(e, t, n) {
  var i = n[e];
  return !e || i && (!K(i) || t.event[i + "Key"]);
}
var B4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: St.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: St.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: St.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: St.color.tertiary,
        fontSize: 14
      }
    }, t;
  })(Pt)
);
function Gw(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function jw(e) {
  if (tt.domSupported) {
    for (var t = document.documentElement.style, n = 0, i = e.length; n < i; n++)
      if (e[n] in t)
        return e[n];
  }
}
var Xw = jw(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), z4 = jw(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function qw(e, t) {
  if (!e)
    return t;
  t = mx(t, !0);
  var n = e.indexOf(t);
  return e = n === -1 ? t : "-" + e.slice(0, n) + "-" + t, e.toLowerCase();
}
function V4(e, t) {
  var n = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return n ? n[t] : null;
}
var $4 = qw(z4, "transition"), gp = qw(Xw, "transform"), H4 = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (tt.transform3dSupported ? "will-change:transform;" : "");
function Y4(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function W4(e, t, n) {
  if (!K(n) || n === "inside")
    return "";
  var i = e.get("backgroundColor"), r = e.get("borderWidth");
  t = Rs(t);
  var a = Y4(n), o = Math.max(Math.round(r) * 1.5, 6), s = "", l = gp + ":", u;
  zt(["left", "right"], a) > -1 ? (s += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (s += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = o + r, d = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), f = Math.round(((d - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (d - h) / 2) * 100) / 100;
  s += ";" + a + ":-" + f + "px";
  var v = t + " solid " + r + "px;", g = ["position:absolute;width:" + o + "px;height:" + o + "px;z-index:-1;", s + ";" + l + ";", "border-bottom:" + v, "border-right:" + v, "background-color:" + i + ";"];
  return '<div style="' + g.join("") + '"></div>';
}
function U4(e, t, n) {
  var i = "cubic-bezier(0.23,1,0.32,1)", r = "", a = "";
  return n && (r = " " + e / 2 + "s " + i, a = "opacity" + r + ",visibility" + r), t || (r = " " + e + "s " + i, a += (a.length ? "," : "") + (tt.transformSupported ? "" + gp + r : ",left" + r + ",top" + r)), $4 + ":" + a;
}
function xy(e, t, n) {
  var i = e.toFixed(0) + "px", r = t.toFixed(0) + "px";
  if (!tt.transformSupported)
    return n ? "top:" + r + ";left:" + i + ";" : [["top", r], ["left", i]];
  var a = tt.transform3dSupported, o = "translate" + (a ? "3d" : "") + "(" + i + "," + r + (a ? ",0" : "") + ")";
  return n ? "top:0;left:0;" + gp + ":" + o + ";" : [["top", 0], ["left", 0], [Xw, o]];
}
function G4(e) {
  var t = [], n = e.get("fontSize"), i = e.getTextColor();
  i && t.push("color:" + i), t.push("font:" + e.getFont());
  var r = J(e.get("lineHeight"), Math.round(n * 3 / 2));
  n && t.push("line-height:" + r + "px");
  var a = e.get("textShadowColor"), o = e.get("textShadowBlur") || 0, s = e.get("textShadowOffsetX") || 0, l = e.get("textShadowOffsetY") || 0;
  return a && o && t.push("text-shadow:" + s + "px " + l + "px " + o + "px " + a), P(["decoration", "align"], function(u) {
    var c = e.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function j4(e, t, n, i) {
  var r = [], a = e.get("transitionDuration"), o = e.get("backgroundColor"), s = e.get("shadowBlur"), l = e.get("shadowColor"), u = e.get("shadowOffsetX"), c = e.get("shadowOffsetY"), h = e.getModel("textStyle"), d = jx(e, "html"), f = u + "px " + c + "px " + s + "px " + l;
  return r.push("box-shadow:" + f), t && a > 0 && r.push(U4(a, n, i)), o && r.push("background-color:" + o), P(["width", "color", "radius"], function(v) {
    var g = "border-" + v, p = mx(g), _ = e.get(p);
    _ != null && r.push(g + ":" + _ + (v === "color" ? "" : "px"));
  }), r.push(G4(h)), d != null && r.push("padding:" + Qv(d).join("px ") + "px"), r.join(";") + ";";
}
function wy(e, t, n, i, r) {
  var a = t && t.painter;
  if (n) {
    var o = a && a.getViewportRoot();
    o && wA(e, o, n, i, r);
  } else {
    e[0] = i, e[1] = r;
    var s = a && a.getViewportRootOffset();
    s && (e[0] += s.offsetLeft, e[1] += s.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var X4 = (
  /** @class */
  (function() {
    function e(t, n) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, tt.wxa)
        return null;
      var i = document.createElement("div");
      i.domBelongToZr = !0, this.el = i;
      var r = this._zr = t.getZr(), a = n.appendTo, o = a && (K(a) ? document.querySelector(a) : no(a) ? a : gt(a) && a(t.getDom()));
      wy(this._styleCoord, r, o, t.getWidth() / 2, t.getHeight() / 2), (o || t.getDom()).appendChild(i), this._api = t, this._container = o;
      var s = this;
      i.onmouseenter = function() {
        s._enterable && (clearTimeout(s._hideTimeout), s._show = !0), s._inContent = !0;
      }, i.onmousemove = function(l) {
        if (l = l || window.event, !s._enterable) {
          var u = r.handler, c = r.painter.getViewportRoot();
          an(c, l, !0), u.dispatch("mousemove", l);
        }
      }, i.onmouseleave = function() {
        s._inContent = !1, s._enterable && s._show && s.hideLater(s._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var n = this._api.getDom(), i = V4(n, "position"), r = n.style;
        r.position !== "absolute" && i !== "absolute" && (r.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, n) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var i = this.el, r = i.style, a = this._styleCoord;
      i.innerHTML ? r.cssText = H4 + j4(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + xy(a[0], a[1], !0) + ("border-color:" + Rs(n) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, n, i, r, a) {
      var o = this.el;
      if (t == null) {
        o.innerHTML = "";
        return;
      }
      var s = "";
      if (K(a) && i.get("trigger") === "item" && !Gw(i) && (s = W4(i, r, a)), K(t))
        o.innerHTML = t + s;
      else if (t) {
        o.innerHTML = "", U(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          no(t[l]) && t[l].parentNode !== o && o.appendChild(t[l]);
        if (s && o.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = s, o.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, e.prototype.moveTo = function(t, n) {
      if (this.el) {
        var i = this._styleCoord;
        if (wy(i, this._zr, this._container, t, n), i[0] != null && i[1] != null) {
          var r = this.el.style, a = xy(i[0], i[1]);
          P(a, function(o) {
            r[o[0]] = o[1];
          });
        }
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], n = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), n * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, n = this.el.style;
      this._enableDisplayTransition ? (n.visibility = "hidden", n.opacity = "0") : n.display = "none", tt.transform3dSupported && (n.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Tt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      SA(t && t.painter && t.painter.getViewportRoot(), this._container);
      var n = this.el;
      if (n) {
        n.onmouseenter = n.onmousemove = n.onmouseleave = null;
        var i = n.parentNode;
        i && i.removeChild(n);
      }
      this.el = this._container = null;
    }, e;
  })()
), q4 = (
  /** @class */
  (function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), My(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var n = t.get("alwaysShowContent");
      n && this._moveIfResized(), this._alwaysShowContent = n;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, n, i, r, a) {
      var o = this;
      X(t) && $e(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var s = i.getModel("textStyle");
      this.el = new gn({
        style: {
          rich: n.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: r,
          textShadowColor: s.get("textShadowColor"),
          fill: i.get(["textStyle", "color"]),
          padding: jx(i, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: i.get("z")
      }), P(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        o.el.style[u] = i.get(u);
      }), P(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        o.el.style[u] = s.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, n = this.el.getBoundingRect(), i = Sy(t.style);
      return [n.width + i.left + i.right, n.height + i.top + i.bottom];
    }, e.prototype.moveTo = function(t, n) {
      var i = this.el;
      if (i) {
        var r = this._styleCoord;
        My(r, this._zr, t, n), t = r[0], n = r[1];
        var a = i.style, o = Bi(a.borderWidth || 0), s = Sy(a);
        i.x = t + o + s.left, i.y = n + o + s.top, i.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], n = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), n * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Tt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  })()
);
function Bi(e) {
  return Math.max(0, e);
}
function Sy(e) {
  var t = Bi(e.shadowBlur || 0), n = Bi(e.shadowOffsetX || 0), i = Bi(e.shadowOffsetY || 0);
  return {
    left: Bi(t - n),
    right: Bi(t + n),
    top: Bi(t - i),
    bottom: Bi(t + i)
  };
}
function My(e, t, n, i) {
  e[0] = n, e[1] = i, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var Z4 = new be({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), K4 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.prototype.init = function(n, i) {
      if (!(tt.node || !i.getDom())) {
        var r = n.getComponent("tooltip"), a = this._renderMode = nL(r.get("renderMode"));
        this._tooltipContent = a === "richText" ? new q4(i) : new X4(i, {
          appendTo: r.get("appendToBody", !0) ? "body" : r.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(n, i, r) {
      if (!(tt.node || !r.getDom())) {
        this.group.removeAll(), this._tooltipModel = n, this._ecModel = i, this._api = r;
        var a = this._tooltipContent;
        a.update(n), a.setEnterable(n.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && n.get("transitionDuration") ? Zx(this, "_updatePosition", 50, "fixRate") : Pf(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var n = this._tooltipModel, i = n.get("triggerOn");
      Yw("itemTooltip", this._api, Tt(function(r, a, o) {
        i !== "none" && (i.indexOf(r) >= 0 ? this._tryShow(a, o) : r === "leave" && this._hide(o));
      }, this));
    }, t.prototype._keepShow = function() {
      var n = this._tooltipModel, i = this._ecModel, r = this._api, a = n.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var o = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !r.isDisposed() && o.manuallyShowTip(n, i, r, {
            x: o._lastX,
            y: o._lastY,
            dataByCoordSys: o._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(n, i, r, a) {
      if (!(a.from === this.uid || tt.node || !r.getDom())) {
        var o = Dy(a, r);
        this._ticket = "";
        var s = a.dataByCoordSys, l = e3(a, i, r);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = Z4;
          c.x = a.x, c.y = a.y, c.update(), Bt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, o);
        } else if (s)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: s,
            tooltipOption: a.tooltipOption
          }, o);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(n, i, r, a))
            return;
          var h = Ww(a, i), d = h.point[0], f = h.point[1];
          d != null && f != null && this._tryShow({
            offsetX: d,
            offsetY: f,
            target: h.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, o);
        } else a.x != null && a.y != null && (r.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: r.getZr().findHover(a.x, a.y).target
        }, o));
      }
    }, t.prototype.manuallyHideTip = function(n, i, r, a) {
      var o = this._tooltipContent;
      this._tooltipModel && o.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(Dy(a, r));
    }, t.prototype._manuallyAxisShowTip = function(n, i, r, a) {
      var o = a.seriesIndex, s = a.dataIndex, l = i.getComponent("axisPointer").coordSysAxesInfo;
      if (!(o == null || s == null || l == null)) {
        var u = i.getSeriesByIndex(o);
        if (u) {
          var c = u.getData(), h = Yo([c.getItemModel(s), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return r.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: o,
              dataIndex: s,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(n, i) {
      var r = n.target, a = this._tooltipModel;
      if (a) {
        this._lastX = n.offsetX, this._lastY = n.offsetY;
        var o = n.dataByCoordSys;
        if (o && o.length)
          this._showAxisTooltip(o, n);
        else if (r) {
          var s = Bt(r);
          if (s.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          is(r, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (Bt(c).dataIndex != null ? l = c : Bt(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(n, l, i) : u ? this._showComponentItemTooltip(n, u, i) : this._hide(i);
        } else
          this._lastDataByCoordSys = null, this._hide(i);
      }
    }, t.prototype._showOrMove = function(n, i) {
      var r = n.get("showDelay");
      i = Tt(i, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(i, r) : i();
    }, t.prototype._showAxisTooltip = function(n, i) {
      var r = this._ecModel, a = this._tooltipModel, o = [i.offsetX, i.offsetY], s = Yo([i.tooltipOption], a), l = this._renderMode, u = [], c = sa("section", {
        blocks: [],
        noHeader: !0
      }), h = [], d = new ud();
      P(n, function(m) {
        P(m.dataByAxis, function(y) {
          var b = r.getComponent(y.axisDim + "Axis", y.axisIndex), x = y.value;
          if (!(!b || x == null)) {
            var w = $w(x, b.axis, r, y.seriesDataIndices, y.valueLabelOpt), M = sa("section", {
              header: w,
              noHeader: !Un(w),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(M), P(y.seriesDataIndices, function(D) {
              var T = r.getSeriesByIndex(D.seriesIndex), C = D.dataIndexInside, k = T.getDataParams(C);
              if (!(k.dataIndex < 0)) {
                k.axisDim = y.axisDim, k.axisIndex = y.axisIndex, k.axisType = y.axisType, k.axisId = y.axisId, k.axisValue = Ow(b.axis, {
                  value: x
                }), k.axisValueLabel = w, k.marker = d.makeTooltipMarker("item", Rs(k.color), l);
                var E = h0(T.formatTooltip(C, !0, null)), A = E.frag;
                if (A) {
                  var L = Yo([T], a).get("valueFormatter");
                  M.blocks.push(L ? $({
                    valueFormatter: L
                  }, A) : A);
                }
                E.text && h.push(E.text), u.push(k);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var f = i.position, v = s.get("order"), g = g0(c, d, l, v, r.get("useUTC"), s.get("textStyle"));
      g && h.unshift(g);
      var p = l === "richText" ? `

` : "<br/>", _ = h.join(p);
      this._showOrMove(s, function() {
        this._updateContentNotChangedOnAxis(n, u) ? this._updatePosition(s, f, o[0], o[1], this._tooltipContent, u) : this._showTooltipContent(s, _, u, Math.random() + "", o[0], o[1], f, null, d);
      });
    }, t.prototype._showSeriesItemTooltip = function(n, i, r) {
      var a = this._ecModel, o = Bt(i), s = o.seriesIndex, l = a.getSeriesByIndex(s), u = o.dataModel || l, c = o.dataIndex, h = o.dataType, d = u.getData(h), f = this._renderMode, v = n.positionDefault, g = Yo([d.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, v ? {
        position: v
      } : null), p = g.get("trigger");
      if (!(p != null && p !== "item")) {
        var _ = u.getDataParams(c, h), m = new ud();
        _.marker = m.makeTooltipMarker("item", Rs(_.color), f);
        var y = h0(u.formatTooltip(c, !1, h)), b = g.get("order"), x = g.get("valueFormatter"), w = y.frag, M = w ? g0(x ? $({
          valueFormatter: x
        }, w) : w, m, f, b, a.get("useUTC"), g.get("textStyle")) : y.text, D = "item_" + u.name + "_" + c;
        this._showOrMove(g, function() {
          this._showTooltipContent(g, M, _, D, n.offsetX, n.offsetY, n.position, n.target, m);
        }), r({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: d.getRawIndex(c),
          seriesIndex: s,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(n, i, r) {
      var a = this._renderMode === "html", o = Bt(i), s = o.tooltipConfig, l = s.option || {}, u = l.encodeHTMLContent;
      if (K(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = ft(l), l.content = Be(l.content));
      var h = [l], d = this._ecModel.getComponent(o.componentMainType, o.componentIndex);
      d && h.push(d), h.push({
        formatter: l.content
      });
      var f = n.positionDefault, v = Yo(h, this._tooltipModel, f ? {
        position: f
      } : null), g = v.get("content"), p = Math.random() + "", _ = new ud();
      this._showOrMove(v, function() {
        var m = ft(v.get("formatterParams") || {});
        this._showTooltipContent(v, g, m, p, n.offsetX, n.offsetY, n.position, i, _);
      }), r({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(n, i, r, a, o, s, l, u, c) {
      if (this._ticket = "", !(!n.get("showContent") || !n.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(n.get("enterable"));
        var d = n.get("formatter");
        l = l || n.get("position");
        var f = i, v = this._getNearestPoint([o, s], r, n.get("trigger"), n.get("borderColor"), n.get("defaultBorderColor", !0)), g = v.color;
        if (d)
          if (K(d)) {
            var p = n.ecModel.get("useUTC"), _ = U(r) ? r[0] : r, m = _ && _.axisType && _.axisType.indexOf("time") >= 0;
            f = d, m && (f = _x(_.axisValue, f, p)), f = yx(f, r, !0);
          } else if (gt(d)) {
            var y = Tt(function(b, x) {
              b === this._ticket && (h.setContent(x, c, n, g, l), this._updatePosition(n, l, o, s, h, r, u));
            }, this);
            this._ticket = a, f = d(r, a, y);
          } else
            f = d;
        h.setContent(f, c, n, g, l), h.show(n, g), this._updatePosition(n, l, o, s, h, r, u);
      }
    }, t.prototype._getNearestPoint = function(n, i, r, a, o) {
      if (r === "axis" || U(i))
        return {
          color: a || o
        };
      if (!U(i))
        return {
          color: a || i.color || i.borderColor
        };
    }, t.prototype._updatePosition = function(n, i, r, a, o, s, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      i = i || n.get("position");
      var h = o.getSize(), d = n.get("align"), f = n.get("verticalAlign"), v = l && l.getBoundingRect().clone();
      if (l && v.applyTransform(l.transform), gt(i) && (i = i([r, a], s, o.el, v, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), U(i))
        r = Ve(i[0], u), a = Ve(i[1], c);
      else if (X(i)) {
        var g = i;
        g.width = h[0], g.height = h[1];
        var p = Jv(g, {
          width: u,
          height: c
        });
        r = p.x, a = p.y, d = null, f = null;
      } else if (K(i) && l) {
        var _ = t3(i, v, h, n.get("borderWidth"));
        r = _[0], a = _[1];
      } else {
        var _ = Q4(r, a, o, u, c, d ? null : 20, f ? null : 20);
        r = _[0], a = _[1];
      }
      if (d && (r -= Ty(d) ? h[0] / 2 : d === "right" ? h[0] : 0), f && (a -= Ty(f) ? h[1] / 2 : f === "bottom" ? h[1] : 0), Gw(n)) {
        var _ = J4(r, a, o, u, c);
        r = _[0], a = _[1];
      }
      o.moveTo(r, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(n, i) {
      var r = this._lastDataByCoordSys, a = this._cbParamsList, o = !!r && r.length === n.length;
      return o && P(r, function(s, l) {
        var u = s.dataByAxis || [], c = n[l] || {}, h = c.dataByAxis || [];
        o = o && u.length === h.length, o && P(u, function(d, f) {
          var v = h[f] || {}, g = d.seriesDataIndices || [], p = v.seriesDataIndices || [];
          o = o && d.value === v.value && d.axisType === v.axisType && d.axisId === v.axisId && g.length === p.length, o && P(g, function(_, m) {
            var y = p[m];
            o = o && _.seriesIndex === y.seriesIndex && _.dataIndex === y.dataIndex;
          }), a && P(d.seriesDataIndices, function(_) {
            var m = _.seriesIndex, y = i[m], b = a[m];
            y && b && b.data !== y.data && (o = !1);
          });
        });
      }), this._lastDataByCoordSys = n, this._cbParamsList = i, !!o;
    }, t.prototype._hide = function(n) {
      this._lastDataByCoordSys = null, n({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(n, i) {
      tt.node || !i.getDom() || (Pf(this, "_updatePosition"), this._tooltipContent.dispose(), $f("itemTooltip", i));
    }, t.type = "tooltip", t;
  })(Ti)
);
function Yo(e, t, n) {
  var i = t.ecModel, r;
  n ? (r = new Gt(n, i, i), r = new Gt(t.option, r, i)) : r = t;
  for (var a = e.length - 1; a >= 0; a--) {
    var o = e[a];
    o && (o instanceof Gt && (o = o.get("tooltip", !0)), K(o) && (o = {
      formatter: o
    }), o && (r = new Gt(o, r, i)));
  }
  return r;
}
function Dy(e, t) {
  return e.dispatchAction || Tt(t.dispatchAction, t);
}
function Q4(e, t, n, i, r, a, o) {
  var s = n.getSize(), l = s[0], u = s[1];
  return a != null && (e + l + a + 2 > i ? e -= l + a : e += a), o != null && (t + u + o > r ? t -= u + o : t += o), [e, t];
}
function J4(e, t, n, i, r) {
  var a = n.getSize(), o = a[0], s = a[1];
  return e = Math.min(e + o, i) - o, t = Math.min(t + s, r) - s, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function t3(e, t, n, i) {
  var r = n[0], a = n[1], o = Math.ceil(Math.SQRT2 * i) + 8, s = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      s = t.x + u / 2 - r / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      s = t.x + u / 2 - r / 2, l = t.y - a - o;
      break;
    case "bottom":
      s = t.x + u / 2 - r / 2, l = t.y + c + o;
      break;
    case "left":
      s = t.x - r - o, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      s = t.x + u + o, l = t.y + c / 2 - a / 2;
  }
  return [s, l];
}
function Ty(e) {
  return e === "center" || e === "middle";
}
function e3(e, t, n) {
  var i = Tv(e).queryOptionMap, r = i.keys()[0];
  if (!(!r || r === "series")) {
    var a = qs(t, r, i.get(r), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), o = a.models[0];
    if (o) {
      var s = n.getViewOfComponentModel(o), l;
      if (s.group.traverse(function(u) {
        var c = Bt(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: r,
          componentIndex: o.componentIndex,
          el: l
        };
    }
  }
}
function n3(e) {
  hp(D4), e.registerComponentModel(B4), e.registerComponentView(K4), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, ye), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, ye);
}
var Vs = P, i3 = X, oc = -1, _p = (
  /** @class */
  (function() {
    function e(t) {
      var n = t.mappingMethod, i = t.type, r = this.option = ft(t);
      this.type = i, this.mappingMethod = n, this._normalizeData = o3[n];
      var a = e.visualHandlers[i];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[n], n === "piecewise" ? (Dd(r), r3(r)) : n === "category" ? r.categories ? a3(r) : Dd(r, !0) : (Q(n !== "linear" || r.dataExtent), Dd(r));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var n = this._normalizeData(t);
      return this._normalizedToVisual(n, t);
    }, e.prototype.getNormalizer = function() {
      return Tt(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return jt(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, n, i) {
      X(t) ? P(t, n, i) : n.call(i, t);
    }, e.mapVisual = function(t, n, i) {
      var r, a = U(t) ? [] : X(t) ? {} : (r = !0, null);
      return e.eachVisual(t, function(o, s) {
        var l = n.call(i, o, s);
        r ? a = l : a[s] = l;
      }), a;
    }, e.retrieveVisuals = function(t) {
      var n = {}, i;
      return t && Vs(e.visualHandlers, function(r, a) {
        t.hasOwnProperty(a) && (n[a] = t[a], i = !0);
      }), i ? n : null;
    }, e.prepareVisualTypes = function(t) {
      if (U(t))
        t = t.slice();
      else if (i3(t)) {
        var n = [];
        Vs(t, function(i, r) {
          n.push(r);
        }), t = n;
      } else
        return [];
      return t.sort(function(i, r) {
        return r === "color" && i !== "color" && i.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, n) {
      return n === "color" ? !!(t && t.indexOf(n) === 0) : t === n;
    }, e.findPieceIndex = function(t, n, i) {
      for (var r, a = 1 / 0, o = 0, s = n.length; o < s; o++) {
        var l = n[o].value;
        if (l != null) {
          if (l === t || K(l) && l === t + "")
            return o;
          i && d(l, o);
        }
      }
      for (var o = 0, s = n.length; o < s; o++) {
        var u = n[o], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (ql(h[1], t, c[1]))
              return o;
          } else if (c[1] === 1 / 0) {
            if (ql(h[0], c[0], t))
              return o;
          } else if (ql(h[0], c[0], t) && ql(h[1], t, c[1]))
            return o;
          i && d(c[0], o), i && d(c[1], o);
        }
      }
      if (i)
        return t === 1 / 0 ? n.length - 1 : t === -1 / 0 ? 0 : r;
      function d(f, v) {
        var g = Math.abs(f - t);
        g < a && (a = g, r = v);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: Wo("color"),
        getColorMapper: function() {
          var t = this.option;
          return Tt(t.mappingMethod === "category" ? function(n, i) {
            return !i && (n = this._normalizeData(n)), as.call(this, n);
          } : function(n, i, r) {
            var a = !!r;
            return !i && (n = this._normalizeData(n)), r = xh(n, t.parsedVisual, r), a ? r : Qr(r, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return Qr(xh(t, this.option.parsedVisual), "rgba");
          },
          category: as,
          piecewise: function(t, n) {
            var i = Yf.call(this, n);
            return i == null && (i = Qr(xh(t, this.option.parsedVisual), "rgba")), i;
          },
          fixed: Fr
        }
      },
      colorHue: Xl(function(t, n) {
        return qa(t, n);
      }),
      colorSaturation: Xl(function(t, n) {
        return qa(t, null, n);
      }),
      colorLightness: Xl(function(t, n) {
        return qa(t, null, null, n);
      }),
      colorAlpha: Xl(function(t, n) {
        return rE(t, n);
      }),
      decal: {
        applyVisual: Wo("decal"),
        _normalizedToVisual: {
          linear: null,
          category: as,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: Wo("opacity"),
        _normalizedToVisual: Hf([0, 1])
      },
      liftZ: {
        applyVisual: Wo("liftZ"),
        _normalizedToVisual: {
          linear: Fr,
          category: Fr,
          piecewise: Fr,
          fixed: Fr
        }
      },
      symbol: {
        applyVisual: function(t, n, i) {
          var r = this.mapValueToVisual(t);
          i("symbol", r);
        },
        _normalizedToVisual: {
          linear: ky,
          category: as,
          piecewise: function(t, n) {
            var i = Yf.call(this, n);
            return i == null && (i = ky.call(this, t)), i;
          },
          fixed: Fr
        }
      },
      symbolSize: {
        applyVisual: Wo("symbolSize"),
        _normalizedToVisual: Hf([0, 1])
      }
    }, e;
  })()
);
function r3(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, P(t, function(n, i) {
    n.originIndex = i, n.visual != null && (e.hasSpecialVisual = !0);
  });
}
function a3(e) {
  var t = e.categories, n = e.categoryMap = {}, i = e.visual;
  if (Vs(t, function(o, s) {
    n[o] = s;
  }), !U(i)) {
    var r = [];
    X(i) ? Vs(i, function(o, s) {
      var l = n[s];
      r[l ?? oc] = o;
    }) : r[oc] = i, i = Zw(e, r);
  }
  for (var a = t.length - 1; a >= 0; a--)
    i[a] == null && (delete n[t[a]], t.pop());
}
function Dd(e, t) {
  var n = e.visual, i = [];
  X(n) ? Vs(n, function(a) {
    i.push(a);
  }) : n != null && i.push(n);
  var r = {
    color: 1,
    symbol: 1
  };
  !t && i.length === 1 && !r.hasOwnProperty(e.type) && (i[1] = i[0]), Zw(e, i);
}
function Xl(e) {
  return {
    applyVisual: function(t, n, i) {
      var r = this.mapValueToVisual(t);
      i("color", e(n("color"), r));
    },
    _normalizedToVisual: Hf([0, 1])
  };
}
function ky(e) {
  var t = this.option.visual;
  return t[Math.round(Es(e, [0, 1], [0, t.length - 1]))] || {};
}
function Wo(e) {
  return function(t, n, i) {
    i(e, this.mapValueToVisual(t));
  };
}
function as(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== oc ? e % t.length : e];
}
function Fr() {
  return this.option.visual[0];
}
function Hf(e) {
  return {
    linear: function(t) {
      return Es(t, e, this.option.visual);
    },
    category: as,
    piecewise: function(t, n) {
      var i = Yf.call(this, n);
      return i == null && (i = Es(t, e, this.option.visual)), i;
    },
    fixed: Fr
  };
}
function Yf(e) {
  var t = this.option, n = t.pieceList;
  if (t.hasSpecialVisual) {
    var i = _p.findPieceIndex(e, n), r = n[i];
    if (r && r.visual)
      return r.visual[this.type];
  }
}
function Zw(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = yt(t, function(n) {
    var i = bi(n);
    return !i && process.env.NODE_ENV !== "production" && un("'" + n + "' is an illegal color, fallback to '#000000'", !0), i || [0, 0, 0, 1];
  })), t;
}
var o3 = {
  linear: function(e) {
    return Es(e, this.option.dataExtent, [0, 1]);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, n = _p.findPieceIndex(e, t, !0);
    if (n != null)
      return Es(n, [0, t.length - 1], [0, 1]);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? oc;
  },
  fixed: ye
};
function ql(e, t, n) {
  return e ? t <= n : t < n;
}
var s3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, n;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: St.size.m,
      backgroundColor: St.color.transparent,
      borderColor: St.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: St.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: St.color.quaternary
      }
    }, t;
  })(Pt)
), l3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.prototype.render = function(n, i, r) {
      if (this.group.removeAll(), !!n.get("show")) {
        var a = this.group, o = n.getModel("textStyle"), s = n.getModel("subtextStyle"), l = n.get("textAlign"), u = J(n.get("textBaseline"), n.get("textVerticalAlign")), c = new gn({
          style: oa(o, {
            text: n.get("text"),
            fill: o.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), d = n.get("subtext"), f = new gn({
          style: oa(s, {
            text: d,
            fill: s.getTextColor(),
            y: h.height + n.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), v = n.get("link"), g = n.get("sublink"), p = n.get("triggerEvent", !0);
        c.silent = !v && !p, f.silent = !g && !p, v && c.on("click", function() {
          Um(v, "_" + n.get("target"));
        }), g && f.on("click", function() {
          Um(g, "_" + n.get("subtarget"));
        }), Bt(c).eventData = Bt(f).eventData = p ? {
          componentType: "title",
          componentIndex: n.componentIndex
        } : null, a.add(c), d && a.add(f);
        var _ = a.getBoundingRect(), m = n.getBoxLayoutParams();
        m.width = _.width, m.height = _.height;
        var y = xx(n, r), b = Jv(m, y.refContainer, n.get("padding"));
        l || (l = n.get("left") || n.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = n.get("top") || n.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), a.x = b.x, a.y = b.y, a.markRedraw();
        var x = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(x), f.setStyle(x), _ = a.getBoundingRect();
        var w = b.margin, M = n.getItemStyle(["color", "opacity"]);
        M.fill = n.get("backgroundColor");
        var D = new be({
          shape: {
            x: _.x - w[3],
            y: _.y - w[0],
            width: _.width + w[1] + w[3],
            height: _.height + w[0] + w[2],
            r: n.get("borderRadius")
          },
          style: M,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(D);
      }
    }, t.type = "title", t;
  })(Ti)
);
function u3(e) {
  e.registerComponentModel(s3), e.registerComponentView(l3);
}
var vn = Wt();
function c3(e) {
  var t = e.mainData, n = e.datas;
  n || (n = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, Kw(t, n, e), P(n, function(i) {
    P(t.TRANSFERABLE_METHODS, function(r) {
      i.wrapMethod(r, Pe(h3, e));
    });
  }), t.wrapMethod("cloneShallow", Pe(f3, e)), P(t.CHANGABLE_METHODS, function(i) {
    t.wrapMethod(i, Pe(d3, e));
  }), Q(n[t.dataType] === t);
}
function h3(e, t) {
  if (g3(this)) {
    var n = $({}, vn(this).datas);
    n[this.dataType] = t, Kw(t, n, e);
  } else
    mp(t, this.dataType, vn(this).mainData, e);
  return t;
}
function d3(e, t) {
  return e.struct && e.struct.update(), t;
}
function f3(e, t) {
  return P(vn(t).datas, function(n, i) {
    n !== t && mp(n.cloneShallow(), i, t, e);
  }), t;
}
function v3(e) {
  var t = vn(this).mainData;
  return e == null || t == null ? t : vn(t).datas[e];
}
function p3() {
  var e = vn(this).mainData;
  return e == null ? [{
    data: e
  }] : yt(jt(vn(e).datas), function(t) {
    return {
      type: t,
      data: vn(e).datas[t]
    };
  });
}
function g3(e) {
  return vn(e).mainData === e;
}
function Kw(e, t, n) {
  vn(e).datas = {}, P(t, function(i, r) {
    mp(i, r, e, n);
  });
}
function mp(e, t, n, i) {
  vn(n).datas[t] = e, vn(e).mainData = n, e.dataType = t, i.struct && (e[i.structAttr] = i.struct, i.struct[i.datasAttr[t]] = e), e.getLinkedData = v3, e.getLinkedDataAll = p3;
}
function Ia(e) {
  return "_EC_" + e;
}
var _3 = (
  /** @class */
  (function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, n) {
      t = t == null ? "" + n : "" + t;
      var i = this._nodesMap;
      if (i[Ia(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var r = new Br(t, n);
      return r.hostGraph = this, this.nodes.push(r), i[Ia(t)] = r, r;
    }, e.prototype.getNodeByIndex = function(t) {
      var n = this.data.getRawIndex(t);
      return this.nodes[n];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[Ia(t)];
    }, e.prototype.addEdge = function(t, n, i) {
      var r = this._nodesMap, a = this._edgesMap;
      if (Xt(t) && (t = this.nodes[t]), Xt(n) && (n = this.nodes[n]), t instanceof Br || (t = r[Ia(t)]), n instanceof Br || (n = r[Ia(n)]), !(!t || !n)) {
        var o = t.id + "-" + n.id, s = new Qw(t, n, i);
        return s.hostGraph = this, this._directed && (t.outEdges.push(s), n.inEdges.push(s)), t.edges.push(s), t !== n && n.edges.push(s), this.edges.push(s), a[o] = s, s;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var n = this.edgeData.getRawIndex(t);
      return this.edges[n];
    }, e.prototype.getEdge = function(t, n) {
      t instanceof Br && (t = t.id), n instanceof Br && (n = n.id);
      var i = this._edgesMap;
      return this._directed ? i[t + "-" + n] : i[t + "-" + n] || i[n + "-" + t];
    }, e.prototype.eachNode = function(t, n) {
      for (var i = this.nodes, r = i.length, a = 0; a < r; a++)
        i[a].dataIndex >= 0 && t.call(n, i[a], a);
    }, e.prototype.eachEdge = function(t, n) {
      for (var i = this.edges, r = i.length, a = 0; a < r; a++)
        i[a].dataIndex >= 0 && i[a].node1.dataIndex >= 0 && i[a].node2.dataIndex >= 0 && t.call(n, i[a], a);
    }, e.prototype.breadthFirstTraverse = function(t, n, i, r) {
      if (n instanceof Br || (n = this._nodesMap[Ia(n)]), !!n) {
        for (var a = i === "out" ? "outEdges" : i === "in" ? "inEdges" : "edges", o = 0; o < this.nodes.length; o++)
          this.nodes[o].__visited = !1;
        if (!t.call(r, n, null))
          for (var s = [n]; s.length; )
            for (var l = s.shift(), u = l[a], o = 0; o < u.length; o++) {
              var c = u[o], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (t.call(r, h, l))
                  return;
                s.push(h), h.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, n = this.edgeData, i = this.nodes, r = this.edges, a = 0, o = i.length; a < o; a++)
        i[a].dataIndex = -1;
      for (var a = 0, o = t.count(); a < o; a++)
        i[t.getRawIndex(a)].dataIndex = a;
      n.filterSelf(function(s) {
        var l = r[n.getRawIndex(s)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, o = r.length; a < o; a++)
        r[a].dataIndex = -1;
      for (var a = 0, o = n.count(); a < o; a++)
        r[n.getRawIndex(a)].dataIndex = a;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), n = this.nodes, i = this.edges, r = 0; r < n.length; r++)
        t.addNode(n[r].id, n[r].dataIndex);
      for (var r = 0; r < i.length; r++) {
        var a = i[r];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, e;
  })()
), Br = (
  /** @class */
  (function() {
    function e(t, n) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = n ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var n = this.hostGraph, i = n.data.getItemModel(this.dataIndex);
        return i.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, n = 0; n < this.edges.length; n++) {
        var i = this.edges[n];
        i.dataIndex < 0 || (t.edge.push(i.dataIndex), t.node.push(i.node1.dataIndex, i.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = st(), n = st(), i = 0, r = this.edges.length; i < r; i++) {
        var a = this.edges[i];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var o = [a.node1], s = [a.node2], l = 0; l < o.length; ) {
            var u = o[l];
            l++, n.set(u.dataIndex, !0);
            for (var c = u.inEdges, h = 0, d = c.length, f = void 0, v = void 0; h < d; h++)
              f = c[h], v = f.dataIndex, v >= 0 && !t.hasKey(v) && (t.set(v, !0), o.push(f.node1));
          }
          for (l = 0; l < s.length; ) {
            var g = s[l];
            l++, n.set(g.dataIndex, !0);
            for (var p = g.outEdges, h = 0, _ = p.length, m = void 0, y = void 0; h < _; h++)
              m = p[h], y = m.dataIndex, y >= 0 && !t.hasKey(y) && (t.set(y, !0), s.push(m.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: n.keys()
      };
    }, e;
  })()
), Qw = (
  /** @class */
  (function() {
    function e(t, n, i) {
      this.dataIndex = -1, this.node1 = t, this.node2 = n, this.dataIndex = i ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var n = this.hostGraph, i = n.edgeData.getItemModel(this.dataIndex);
        return i.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = st(), n = st();
      t.set(this.dataIndex, !0);
      for (var i = [this.node1], r = [this.node2], a = 0; a < i.length; ) {
        var o = i[a];
        a++, n.set(o.dataIndex, !0);
        for (var s = o.inEdges, l = 0, u = s.length, c = void 0, h = void 0; l < u; l++)
          c = o.inEdges[l], h = c.dataIndex, h >= 0 && !t.hasKey(h) && (t.set(h, !0), i.push(c.node1));
      }
      for (a = 0; a < r.length; ) {
        var d = r[a];
        a++, n.set(d.dataIndex, !0);
        for (var f = d.outEdges, l = 0, u = f.length, v = void 0, g = void 0; l < u; l++)
          v = d.outEdges[l], g = v.dataIndex, g >= 0 && !t.hasKey(g) && (t.set(g, !0), r.push(v.node2));
      }
      return {
        edge: t.keys(),
        node: n.keys()
      };
    }, e;
  })()
);
function Jw(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(n) {
      var i = this[e][t];
      return i.getStore().get(i.getDimensionIndex(n || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(n, i) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, n, i);
    },
    getVisual: function(n) {
      return this[e][t].getItemVisual(this.dataIndex, n);
    },
    setLayout: function(n, i) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, n, i);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
An(Br, Jw("hostGraph", "data"));
An(Qw, Jw("hostGraph", "edgeData"));
function m3(e, t, n, i, r) {
  for (var a = new _3(i), o = 0; o < e.length; o++)
    a.addNode(er(
      // Id, name, dataIndex
      e[o].id,
      e[o].name,
      o
    ), o);
  for (var s = [], l = [], u = 0, o = 0; o < t.length; o++) {
    var c = t[o], h = c.source, d = c.target;
    a.addEdge(h, d, u) && (l.push(c), s.push(er(Mn(c.id, null), h + " > " + d)), u++);
  }
  var f = n.get("coordinateSystem"), v;
  if (f === "cartesian2d" || f === "polar" || f === "matrix")
    v = pF(e, n);
  else {
    var g = Rc.get(f), p = g ? g.dimensions || [] : [];
    zt(p, "value") < 0 && p.concat(["value"]);
    var _ = Lw(e, {
      coordDimensions: p,
      encodeDefine: n.getEncode()
    }).dimensions;
    v = new Bf(_, n), v.initData(e);
  }
  var m = new Bf(["value"], n);
  return m.initData(l, s), r && r(v, m), c3({
    mainData: v,
    struct: a,
    structAttr: "graph",
    datas: {
      node: v,
      edge: m
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var y3 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  })()
), b3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t(n) {
      return e.call(this, n) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new y3();
    }, t.prototype.buildPath = function(n, i) {
      var r = i.extent;
      n.moveTo(i.x1, i.y1), n.bezierCurveTo(i.cpx1, i.cpy1, i.cpx2, i.cpy2, i.x2, i.y2), i.orient === "vertical" ? (n.lineTo(i.x2 + r, i.y2), n.bezierCurveTo(i.cpx2 + r, i.cpy2, i.cpx1 + r, i.cpy1, i.x1 + r, i.y1)) : (n.lineTo(i.x2, i.y2 + r), n.bezierCurveTo(i.cpx2, i.cpy2 + r, i.cpx1, i.cpy1 + r, i.x1, i.y1 + r)), n.closePath();
    }, t.prototype.highlight = function() {
      Vu(this);
    }, t.prototype.downplay = function() {
      $u(this);
    }, t;
  })(It)
), x3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n._mainGroup = new Dn(), n._focusAdjacencyDisabled = !1, n;
    }
    return t.prototype.init = function(n, i) {
      this._controller = new I4(i.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(n, i, r) {
      var a = this, o = n.getGraph(), s = this._mainGroup, l = n.layoutInfo, u = l.width, c = l.height, h = n.getData(), d = n.getData("edge"), f = n.get("orient");
      this._model = n, s.removeAll(), s.x = l.x, s.y = l.y, this._updateViewCoordSys(n, r), C4(n, r, s, this._controller, this._controllerHost), o.eachEdge(function(v) {
        var g = new b3(), p = Bt(g);
        p.dataIndex = v.dataIndex, p.seriesIndex = n.seriesIndex, p.dataType = "edge";
        var _ = v.getModel(), m = _.getModel("lineStyle"), y = m.get("curveness"), b = v.node1.getLayout(), x = v.node1.getModel(), w = x.get("localX"), M = x.get("localY"), D = v.node2.getLayout(), T = v.node2.getModel(), C = T.get("localX"), k = T.get("localY"), E = v.getLayout(), A, L, R, N, V, q, W, Z;
        g.shape.extent = Math.max(1, E.dy), g.shape.orient = f, f === "vertical" ? (A = (w != null ? w * u : b.x) + E.sy, L = (M != null ? M * c : b.y) + b.dy, R = (C != null ? C * u : D.x) + E.ty, N = k != null ? k * c : D.y, V = A, q = L * (1 - y) + N * y, W = R, Z = L * y + N * (1 - y)) : (A = (w != null ? w * u : b.x) + b.dx, L = (M != null ? M * c : b.y) + E.sy, R = C != null ? C * u : D.x, N = (k != null ? k * c : D.y) + E.ty, V = A * (1 - y) + R * y, q = L, W = A * y + R * (1 - y), Z = N), g.setShape({
          x1: A,
          y1: L,
          x2: R,
          y2: N,
          cpx1: V,
          cpy1: q,
          cpx2: W,
          cpy2: Z
        }), g.useStyle(m.getItemStyle()), Cy(g.style, f, v);
        var bt = "" + _.get("value"), et = Bm(_, "edgeLabel");
        Fm(g, et, {
          labelFetcher: {
            getFormattedLabel: function(Ht, Rt, Oe, Ue, De, oe) {
              return n.getFormattedLabel(
                Ht,
                Rt,
                "edge",
                Ue,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Zr(De, et.normal && et.normal.get("formatter"), bt),
                oe
              );
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: bt
        }), g.setTextConfig({
          position: "inside"
        });
        var at = _.getModel("emphasis");
        Dm(g, _, "lineStyle", function(Ht) {
          var Rt = Ht.getItemStyle();
          return Cy(Rt, f, v), Rt;
        }), s.add(g), d.setItemGraphicEl(v.dataIndex, g);
        var ht = at.get("focus");
        Sm(g, ht === "adjacency" ? v.getAdjacentDataIndices() : ht === "trajectory" ? v.getTrajectoryDataIndices() : ht, at.get("blurScope"), at.get("disabled"));
      }), o.eachNode(function(v) {
        var g = v.getLayout(), p = v.getModel(), _ = p.get("localX"), m = p.get("localY"), y = p.getModel("emphasis"), b = p.get(["itemStyle", "borderRadius"]) || 0, x = new be({
          shape: {
            x: _ != null ? _ * u : g.x,
            y: m != null ? m * c : g.y,
            width: g.dx,
            height: g.dy,
            r: b
          },
          style: p.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Fm(x, Bm(p), {
          labelFetcher: {
            getFormattedLabel: function(M, D) {
              return n.getFormattedLabel(M, D, "node");
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: v.id
        }), x.disableLabelAnimation = !0, x.setStyle("fill", v.getVisual("color")), x.setStyle("decal", v.getVisual("style").decal), Dm(x, p), s.add(x), h.setItemGraphicEl(v.dataIndex, x), Bt(x).dataType = "node";
        var w = y.get("focus");
        Sm(x, w === "adjacency" ? v.getAdjacentDataIndices() : w === "trajectory" ? v.getTrajectoryDataIndices() : w, y.get("blurScope"), y.get("disabled"));
      }), h.eachItemGraphicEl(function(v, g) {
        var p = h.getItemModel(g);
        p.get("draggable") && (v.drift = function(_, m) {
          a._focusAdjacencyDisabled = !0, this.shape.x += _, this.shape.y += m, this.dirty(), r.dispatchAction({
            type: "dragNode",
            seriesId: n.id,
            dataIndex: h.getRawIndex(g),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, v.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, v.draggable = !0, v.cursor = "move");
      }), !this._data && n.isAnimationEnabled() && s.setClipPath(w3(s.getBoundingRect(), n, function() {
        s.removeClipPath();
      })), this._data = n.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(n, i) {
      var r = n.layoutInfo, a = r.width, o = r.height, s = n.coordinateSystem = new A4(null, {
        api: i,
        ecModel: n.ecModel
      });
      s.zoomLimit = n.get("scaleLimit"), s.setBoundingRect(0, 0, a, o), s.setCenter(n.get("center")), s.setZoom(n.get("zoom")), this._controllerHost.target.attr({
        x: s.x,
        y: s.y,
        scaleX: s.scaleX,
        scaleY: s.scaleY
      });
    }, t.type = "sankey", t;
  })(Zi)
);
function Cy(e, t, n) {
  switch (e.fill) {
    case "source":
      e.fill = n.node1.getVisual("color"), e.decal = n.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = n.node2.getVisual("color"), e.decal = n.node2.getVisual("style").decal;
      break;
    case "gradient":
      var i = n.node1.getVisual("color"), r = n.node2.getVisual("color");
      K(i) && K(r) && (e.fill = new ex(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: i,
        offset: 0
      }, {
        color: r,
        offset: 1
      }]));
  }
}
function w3(e, t, n) {
  var i = new be({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return ix(i, {
    shape: {
      width: e.width + 20
    }
  }, t, n), i;
}
var S3 = (
  /** @class */
  (function(e) {
    ae(t, e);
    function t() {
      var n = e !== null && e.apply(this, arguments) || this;
      return n.type = t.type, n;
    }
    return t.prototype.getInitialData = function(n, i) {
      var r = n.edges || n.links || [], a = n.data || n.nodes || [], o = n.levels || [];
      this.levelModels = [];
      for (var s = this.levelModels, l = 0; l < o.length; l++)
        if (o[l].depth != null && o[l].depth >= 0)
          s[o[l].depth] = new Gt(o[l], this, i);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = m3(a, r, this, !0, c);
      return u.data;
      function c(h, d) {
        h.wrapMethod("getItemModel", function(f, v) {
          var g = f.parentModel, p = g.getData().getItemLayout(v);
          if (p) {
            var _ = p.depth, m = g.levelModels[_];
            m && (f.parentModel = m);
          }
          return f;
        }), d.wrapMethod("getItemModel", function(f, v) {
          var g = f.parentModel, p = g.getGraph().getEdgeByIndex(v), _ = p.node1.getLayout();
          if (_) {
            var m = _.depth, y = g.levelModels[m];
            y && (f.parentModel = y);
          }
          return f;
        });
      }
    }, t.prototype.setNodePosition = function(n, i) {
      var r = this.option.data || this.option.nodes, a = r[n];
      a.localX = i[0], a.localY = i[1];
    }, t.prototype.setCenter = function(n) {
      this.option.center = n;
    }, t.prototype.setZoom = function(n) {
      this.option.zoom = n;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(n, i, r) {
      function a(f) {
        return isNaN(f) || f == null;
      }
      if (r === "edge") {
        var o = this.getDataParams(n, r), s = o.data, l = o.value, u = s.source + " -- " + s.target;
        return sa("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(n), h = c.getLayout().value, d = this.getDataParams(n, r).data.name;
        return sa("nameValue", {
          name: d != null ? d + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(n, i) {
      var r = e.prototype.getDataParams.call(this, n, i);
      if (r.value == null && i === "node") {
        var a = this.getGraph().getNodeByIndex(n), o = a.getLayout().value;
        r.value = o;
      }
      return r;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: St.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: St.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  })(ir)
);
function M3(e, t) {
  e.eachSeriesByType("sankey", function(n) {
    var i = n.get("nodeWidth"), r = n.get("nodeGap"), a = xx(n, t).refContainer, o = Jv(n.getBoxLayoutParams(), a);
    n.layoutInfo = o;
    var s = o.width, l = o.height, u = n.getGraph(), c = u.nodes, h = u.edges;
    T3(c);
    var d = qe(c, function(p) {
      return p.getLayout().value === 0;
    }), f = d.length !== 0 ? 0 : n.get("layoutIterations"), v = n.get("orient"), g = n.get("nodeAlign");
    D3(c, h, i, r, s, l, f, v, g);
  });
}
function D3(e, t, n, i, r, a, o, s, l) {
  k3(e, t, n, r, a, s, l), E3(e, t, a, r, i, o, s), V3(e, s);
}
function T3(e) {
  P(e, function(t) {
    var n = Ki(t.outEdges, sc), i = Ki(t.inEdges, sc), r = t.getValue() || 0, a = Math.max(n, i, r);
    t.setLayout({
      value: a
    }, !0);
  });
}
function k3(e, t, n, i, r, a, o) {
  for (var s = [], l = [], u = [], c = [], h = 0, d = 0; d < t.length; d++)
    s[d] = 1;
  for (var d = 0; d < e.length; d++)
    l[d] = e[d].inEdges.length, l[d] === 0 && u.push(e[d]);
  for (var f = -1; u.length; ) {
    for (var v = 0; v < u.length; v++) {
      var g = u[v], p = g.hostGraph.data.getRawDataItem(g.dataIndex), _ = p.depth != null && p.depth >= 0;
      _ && p.depth > f && (f = p.depth), g.setLayout({
        depth: _ ? p.depth : h
      }, !0), a === "vertical" ? g.setLayout({
        dy: n
      }, !0) : g.setLayout({
        dx: n
      }, !0);
      for (var m = 0; m < g.outEdges.length; m++) {
        var y = g.outEdges[m], b = t.indexOf(y);
        s[b] = 0;
        var x = y.node2, w = e.indexOf(x);
        --l[w] === 0 && c.indexOf(x) < 0 && c.push(x);
      }
    }
    ++h, u = c, c = [];
  }
  for (var d = 0; d < s.length; d++)
    if (s[d] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var M = f > h - 1 ? f : h - 1;
  o && o !== "left" && C3(e, o, a, M);
  var D = a === "vertical" ? (r - n) / M : (i - n) / M;
  A3(e, D, a);
}
function tS(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function C3(e, t, n, i) {
  if (t === "right") {
    for (var r = [], a = e, o = 0; a.length; ) {
      for (var s = 0; s < a.length; s++) {
        var l = a[s];
        l.setLayout({
          skNodeHeight: o
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          r.indexOf(c.node1) < 0 && r.push(c.node1);
        }
      }
      a = r, r = [], ++o;
    }
    P(e, function(h) {
      tS(h) || h.setLayout({
        depth: Math.max(0, i - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && P3(e, i);
}
function P3(e, t) {
  P(e, function(n) {
    !tS(n) && !n.outEdges.length && n.setLayout({
      depth: t
    }, !0);
  });
}
function A3(e, t, n) {
  P(e, function(i) {
    var r = i.getLayout().depth * t;
    n === "vertical" ? i.setLayout({
      y: r
    }, !0) : i.setLayout({
      x: r
    }, !0);
  });
}
function E3(e, t, n, i, r, a, o) {
  var s = L3(e, o);
  O3(s, t, n, i, r, o), Td(s, r, n, i, o);
  for (var l = 1; a > 0; a--)
    l *= 0.99, I3(s, l, o), Td(s, r, n, i, o), z3(s, l, o), Td(s, r, n, i, o);
}
function L3(e, t) {
  var n = [], i = t === "vertical" ? "y" : "x", r = iL(e, function(a) {
    return a.getLayout()[i];
  });
  return r.keys.sort(function(a, o) {
    return a - o;
  }), P(r.keys, function(a) {
    n.push(r.buckets.get(a));
  }), n;
}
function O3(e, t, n, i, r, a) {
  var o = 1 / 0;
  P(e, function(s) {
    var l = s.length, u = 0;
    P(s, function(h) {
      u += h.getLayout().value;
    });
    var c = a === "vertical" ? (i - (l - 1) * r) / u : (n - (l - 1) * r) / u;
    c < o && (o = c);
  }), P(e, function(s) {
    P(s, function(l, u) {
      var c = l.getLayout().value * o;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), P(t, function(s) {
    var l = +s.getValue() * o;
    s.setLayout({
      dy: l
    }, !0);
  });
}
function Td(e, t, n, i, r) {
  var a = r === "vertical" ? "x" : "y";
  P(e, function(o) {
    o.sort(function(g, p) {
      return g.getLayout()[a] - p.getLayout()[a];
    });
    for (var s, l, u, c = 0, h = o.length, d = r === "vertical" ? "dx" : "dy", f = 0; f < h; f++)
      l = o[f], u = c - l.getLayout()[a], u > 0 && (s = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0)), c = l.getLayout()[a] + l.getLayout()[d] + t;
    var v = r === "vertical" ? i : n;
    if (u = c - t - v, u > 0) {
      s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
        x: s
      }, !0) : l.setLayout({
        y: s
      }, !0), c = s;
      for (var f = h - 2; f >= 0; --f)
        l = o[f], u = l.getLayout()[a] + l.getLayout()[d] + t - c, u > 0 && (s = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
          x: s
        }, !0) : l.setLayout({
          y: s
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function I3(e, t, n) {
  P(e.slice().reverse(), function(i) {
    P(i, function(r) {
      if (r.outEdges.length) {
        var a = Ki(r.outEdges, R3, n) / Ki(r.outEdges, sc);
        if (isNaN(a)) {
          var o = r.outEdges.length;
          a = o ? Ki(r.outEdges, N3, n) / o : 0;
        }
        if (n === "vertical") {
          var s = r.getLayout().x + (a - ar(r, n)) * t;
          r.setLayout({
            x: s
          }, !0);
        } else {
          var l = r.getLayout().y + (a - ar(r, n)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function R3(e, t) {
  return ar(e.node2, t) * e.getValue();
}
function N3(e, t) {
  return ar(e.node2, t);
}
function F3(e, t) {
  return ar(e.node1, t) * e.getValue();
}
function B3(e, t) {
  return ar(e.node1, t);
}
function ar(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function sc(e) {
  return e.getValue();
}
function Ki(e, t, n) {
  for (var i = 0, r = e.length, a = -1; ++a < r; ) {
    var o = +t(e[a], n);
    isNaN(o) || (i += o);
  }
  return i;
}
function z3(e, t, n) {
  P(e, function(i) {
    P(i, function(r) {
      if (r.inEdges.length) {
        var a = Ki(r.inEdges, F3, n) / Ki(r.inEdges, sc);
        if (isNaN(a)) {
          var o = r.inEdges.length;
          a = o ? Ki(r.inEdges, B3, n) / o : 0;
        }
        if (n === "vertical") {
          var s = r.getLayout().x + (a - ar(r, n)) * t;
          r.setLayout({
            x: s
          }, !0);
        } else {
          var l = r.getLayout().y + (a - ar(r, n)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function V3(e, t) {
  var n = t === "vertical" ? "x" : "y";
  P(e, function(i) {
    i.outEdges.sort(function(r, a) {
      return r.node2.getLayout()[n] - a.node2.getLayout()[n];
    }), i.inEdges.sort(function(r, a) {
      return r.node1.getLayout()[n] - a.node1.getLayout()[n];
    });
  }), P(e, function(i) {
    var r = 0, a = 0;
    P(i.outEdges, function(o) {
      o.setLayout({
        sy: r
      }, !0), r += o.getLayout().dy;
    }), P(i.inEdges, function(o) {
      o.setLayout({
        ty: a
      }, !0), a += o.getLayout().dy;
    });
  });
}
function $3(e) {
  e.eachSeriesByType("sankey", function(t) {
    var n = t.getGraph(), i = n.nodes, r = n.edges;
    if (i.length) {
      var a = 1 / 0, o = -1 / 0;
      P(i, function(s) {
        var l = s.getLayout().value;
        l < a && (a = l), l > o && (o = l);
      }), P(i, function(s) {
        var l = new _p({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, o],
          visual: t.get("color")
        }), u = l.mapValueToVisual(s.getLayout().value), c = s.getModel().get(["itemStyle", "color"]);
        c != null ? (s.setVisual("color", c), s.setVisual("style", {
          fill: c
        })) : (s.setVisual("color", u), s.setVisual("style", {
          fill: u
        }));
      });
    }
    r.length && P(r, function(s) {
      var l = s.getModel().get("lineStyle");
      s.setVisual("style", l);
    });
  });
}
function H3(e) {
  e.registerChartView(x3), e.registerSeriesModel(S3), e.registerLayout(M3), e.registerVisual($3), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, n) {
    n.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(i) {
      i.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), e.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, n, i) {
    n.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(r) {
      var a = r.coordinateSystem, o = P4(a, t, r.get("scaleLimit"));
      r.setCenter(o.center), r.setZoom(o.zoom);
    });
  });
}
function Py(e, t, n) {
  var i = Mi.createCanvas(), r = t.getWidth(), a = t.getHeight(), o = i.style;
  return o && (o.position = "absolute", o.left = "0", o.top = "0", o.width = r + "px", o.height = a + "px", i.setAttribute("data-zr-dom-id", e)), i.width = r * n, i.height = a * n, i;
}
var kd = (function(e) {
  At(t, e);
  function t(n, i, r) {
    var a = e.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var o;
    r = r || Ou, typeof n == "string" ? o = Py(n, i, r) : X(n) && (o = n, n = o.id), a.id = n, a.dom = o;
    var s = o.style;
    return s && (Zb(o), o.onselectstart = function() {
      return !1;
    }, s.padding = "0", s.margin = "0", s.borderWidth = "0"), a.painter = i, a.dpr = r, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var n = this.dpr;
    this.domBack = Py("back-" + this.id, this.painter, n), this.ctxBack = this.domBack.getContext("2d"), n !== 1 && this.ctxBack.scale(n, n);
  }, t.prototype.createRepaintRects = function(n, i, r, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var o = [], s = this.maxRepaintRectCount, l = !1, u = new it(0, 0, 0, 0);
    function c(m) {
      if (!(!m.isFinite() || m.isZero()))
        if (o.length === 0) {
          var y = new it(0, 0, 0, 0);
          y.copy(m), o.push(y);
        } else {
          for (var b = !1, x = 1 / 0, w = 0, M = 0; M < o.length; ++M) {
            var D = o[M];
            if (D.intersect(m)) {
              var T = new it(0, 0, 0, 0);
              T.copy(D), T.union(m), o[M] = T, b = !0;
              break;
            } else if (l) {
              u.copy(m), u.union(D);
              var C = m.width * m.height, k = D.width * D.height, E = u.width * u.height, A = E - C - k;
              A < x && (x = A, w = M);
            }
          }
          if (l && (o[w].union(m), b = !0), !b) {
            var y = new it(0, 0, 0, 0);
            y.copy(m), o.push(y);
          }
          l || (l = o.length >= s);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var d = n[h];
      if (d) {
        var f = d.shouldBePainted(r, a, !0, !0), v = d.__isRendered && (d.__dirty & Ze || !f) ? d.getPrevPaintRect() : null;
        v && c(v);
        var g = f && (d.__dirty & Ze || !d.__isRendered) ? d.getPaintRect() : null;
        g && c(g);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var d = i[h], f = d && d.shouldBePainted(r, a, !0, !0);
      if (d && (!f || !d.__zr) && d.__isRendered) {
        var v = d.getPrevPaintRect();
        v && c(v);
      }
    }
    var p;
    do {
      p = !1;
      for (var h = 0; h < o.length; ) {
        if (o[h].isZero()) {
          o.splice(h, 1);
          continue;
        }
        for (var _ = h + 1; _ < o.length; )
          o[h].intersect(o[_]) ? (p = !0, o[h].union(o[_]), o.splice(_, 1)) : _++;
        h++;
      }
    } while (p);
    return this._paintRects = o, o;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(n, i) {
    var r = this.dpr, a = this.dom, o = a.style, s = this.domBack;
    o && (o.width = n + "px", o.height = i + "px"), a.width = n * r, a.height = i * r, s && (s.width = n * r, s.height = i * r, r !== 1 && this.ctxBack.scale(r, r));
  }, t.prototype.clear = function(n, i, r) {
    var a = this.dom, o = this.ctx, s = a.width, l = a.height;
    i = i || this.clearColor;
    var u = this.motionBlur && !n, c = this.lastFrameAlpha, h = this.dpr, d = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, s / h, l / h));
    var f = this.domBack;
    function v(g, p, _, m) {
      if (o.clearRect(g, p, _, m), i && i !== "transparent") {
        var y = void 0;
        if (wc(i)) {
          var b = i.global || i.__width === _ && i.__height === m;
          y = b && i.__canvasGradient || Lf(o, i, {
            x: 0,
            y: 0,
            width: _,
            height: m
          }), i.__canvasGradient = y, i.__width = _, i.__height = m;
        } else aA(i) && (i.scaleX = i.scaleX || h, i.scaleY = i.scaleY || h, y = Of(o, i, {
          dirty: function() {
            d.setUnpainted(), d.painter.refresh();
          }
        }));
        o.save(), o.fillStyle = y || i, o.fillRect(g, p, _, m), o.restore();
      }
      u && (o.save(), o.globalAlpha = c, o.drawImage(f, g, p, _, m), o.restore());
    }
    !r || u ? v(0, 0, s, l) : r.length && P(r, function(g) {
      v(g.x * h, g.y * h, g.width * h, g.height * h);
    });
  }, t;
})(En), Ay = 1e5, Or = 314159, Zl = 0.01, Y3 = 1e-3;
function W3(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function U3(e, t) {
  var n = document.createElement("div");
  return n.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", n;
}
var G3 = (function() {
  function e(t, n, i, r) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = i = $({}, i || {}), this.dpr = i.devicePixelRatio || Ou, this._singleCanvas = a, this.root = t;
    var o = t.style;
    o && (Zb(t), t.innerHTML = ""), this.storage = n;
    var s = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, h = c.width, d = c.height;
      i.width != null && (h = i.width), i.height != null && (d = i.height), this.dpr = i.devicePixelRatio || 1, c.width = h * this.dpr, c.height = d * this.dpr, this._width = h, this._height = d;
      var f = new kd(c, this, this.dpr);
      f.__builtin__ = !0, f.initContext(), l[Or] = f, f.zlevel = Or, s.push(Or), this._domRoot = t;
    } else {
      this._width = $l(t, 0, i), this._height = $l(t, 1, i);
      var u = this._domRoot = U3(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var n = this.storage.getDisplayList(!0), i = this._prevDisplayList, r = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(n, i, t, this._redrawId);
    for (var a = 0; a < r.length; a++) {
      var o = r[a], s = this._layers[o];
      if (!s.__builtin__ && s.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        s.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = n.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var n = t.length, i = this._hoverlayer;
    if (i && i.clear(), !!n) {
      for (var r = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, o = 0; o < n; o++) {
        var s = t[o];
        s.__inHover && (i || (i = this._hoverlayer = this.getLayer(Ay)), a || (a = i.ctx, a.save()), Ur(a, s, r, o === n - 1));
      }
      a && a.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(Ay);
  }, e.prototype.paintOne = function(t, n) {
    lw(t, n);
  }, e.prototype._paintList = function(t, n, i, r) {
    if (this._redrawId === r) {
      i = i || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, n, i), o = a.finished, s = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), s && this._paintHoverList(t), o)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        ku(function() {
          l._paintList(t, n, i, r);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(Or).ctx, n = this._domRoot.width, i = this._domRoot.height;
    t.clearRect(0, 0, n, i), this.eachBuiltinLayer(function(r) {
      r.virtual && t.drawImage(r.dom, 0, 0, n, i);
    });
  }, e.prototype._doPaintList = function(t, n, i) {
    for (var r = this, a = [], o = this._opts.useDirtyRect, s = 0; s < this._zlevelList.length; s++) {
      var l = this._zlevelList[s], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || i) && a.push(u);
    }
    for (var c = !0, h = !1, d = function(g) {
      var p = a[g], _ = p.ctx, m = o && p.createRepaintRects(t, n, f._width, f._height), y = i ? p.__startIndex : p.__drawIndex, b = !i && p.incremental && Date.now, x = b && Date.now(), w = p.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
      if (p.__startIndex === p.__endIndex)
        p.clear(!1, w, m);
      else if (y === p.__startIndex) {
        var M = t[y];
        (!M.incremental || !M.notClear || i) && p.clear(!1, w, m);
      }
      y === -1 && (console.error("For some unknown reason. drawIndex is -1"), y = p.__startIndex);
      var D, T = function(A) {
        var L = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: r._width,
          viewHeight: r._height
        };
        for (D = y; D < p.__endIndex; D++) {
          var R = t[D];
          if (R.__inHover && (h = !0), r._doPaintEl(R, p, o, A, L, D === p.__endIndex - 1), b) {
            var N = Date.now() - x;
            if (N > 15)
              break;
          }
        }
        L.prevElClipPaths && _.restore();
      };
      if (m)
        if (m.length === 0)
          D = p.__endIndex;
        else
          for (var C = f.dpr, k = 0; k < m.length; ++k) {
            var E = m[k];
            _.save(), _.beginPath(), _.rect(E.x * C, E.y * C, E.width * C, E.height * C), _.clip(), T(E), _.restore();
          }
      else
        _.save(), T(), _.restore();
      p.__drawIndex = D, p.__drawIndex < p.__endIndex && (c = !1);
    }, f = this, v = 0; v < a.length; v++)
      d(v);
    return tt.wxa && P(this._layers, function(g) {
      g && g.ctx && g.ctx.draw && g.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, e.prototype._doPaintEl = function(t, n, i, r, a, o) {
    var s = n.ctx;
    if (i) {
      var l = t.getPaintRect();
      (!r || l && l.intersect(r)) && (Ur(s, t, a, o), t.setPrevPaintRect(l));
    } else
      Ur(s, t, a, o);
  }, e.prototype.getLayer = function(t, n) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Or);
    var i = this._layers[t];
    return i || (i = new kd("zr_" + t, this, this.dpr), i.zlevel = t, i.__builtin__ = !0, this._layerConfig[t] ? re(i, this._layerConfig[t], !0) : this._layerConfig[t - Zl] && re(i, this._layerConfig[t - Zl], !0), n && (i.virtual = n), this.insertLayer(t, i), i.initContext()), i;
  }, e.prototype.insertLayer = function(t, n) {
    var i = this._layers, r = this._zlevelList, a = r.length, o = this._domRoot, s = null, l = -1;
    if (i[t]) {
      process.env.NODE_ENV !== "production" && qr("ZLevel " + t + " has been used already");
      return;
    }
    if (!W3(n)) {
      process.env.NODE_ENV !== "production" && qr("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > r[0]) {
      for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++)
        ;
      s = i[r[l]];
    }
    if (r.splice(l + 1, 0, t), i[t] = n, !n.virtual)
      if (s) {
        var u = s.dom;
        u.nextSibling ? o.insertBefore(n.dom, u.nextSibling) : o.appendChild(n.dom);
      } else
        o.firstChild ? o.insertBefore(n.dom, o.firstChild) : o.appendChild(n.dom);
    n.painter || (n.painter = this);
  }, e.prototype.eachLayer = function(t, n) {
    for (var i = this._zlevelList, r = 0; r < i.length; r++) {
      var a = i[r];
      t.call(n, this._layers[a], a);
    }
  }, e.prototype.eachBuiltinLayer = function(t, n) {
    for (var i = this._zlevelList, r = 0; r < i.length; r++) {
      var a = i[r], o = this._layers[a];
      o.__builtin__ && t.call(n, o, a);
    }
  }, e.prototype.eachOtherLayer = function(t, n) {
    for (var i = this._zlevelList, r = 0; r < i.length; r++) {
      var a = i[r], o = this._layers[a];
      o.__builtin__ || t.call(n, o, a);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(h, d) {
      h.__dirty = h.__used = !1;
    });
    function n(h) {
      a && (a.__endIndex !== h && (a.__dirty = !0), a.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var i = 1; i < t.length; i++) {
        var r = t[i];
        if (r.zlevel !== t[i - 1].zlevel || r.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, o = 0, s, l;
    for (l = 0; l < t.length; l++) {
      var r = t[l], u = r.zlevel, c = void 0;
      s !== u && (s = u, o = 0), r.incremental ? (c = this.getLayer(u + Y3, this._needsManuallyCompositing), c.incremental = !0, o = 1) : c = this.getLayer(u + (o > 0 ? Zl : 0), this._needsManuallyCompositing), c.__builtin__ || qr("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, n(l), a = c), r.__dirty & Ze && !r.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    n(l), this.eachBuiltinLayer(function(h, d) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, P(this._layers, function(n) {
      n.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, n) {
    if (n) {
      var i = this._layerConfig;
      i[t] ? re(i[t], n, !0) : i[t] = n;
      for (var r = 0; r < this._zlevelList.length; r++) {
        var a = this._zlevelList[r];
        if (a === t || a === t + Zl) {
          var o = this._layers[a];
          re(o, i[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var n = this._layers, i = this._zlevelList, r = n[t];
    r && (r.dom.parentNode.removeChild(r.dom), delete n[t], i.splice(zt(i, t), 1));
  }, e.prototype.resize = function(t, n) {
    if (this._domRoot.style) {
      var i = this._domRoot;
      i.style.display = "none";
      var r = this._opts, a = this.root;
      if (t != null && (r.width = t), n != null && (r.height = n), t = $l(a, 0, r), n = $l(a, 1, r), i.style.display = "", this._width !== t || n !== this._height) {
        i.style.width = t + "px", i.style.height = n + "px";
        for (var o in this._layers)
          this._layers.hasOwnProperty(o) && this._layers[o].resize(t, n);
        this.refresh(!0);
      }
      this._width = t, this._height = n;
    } else {
      if (t == null || n == null)
        return;
      this._width = t, this._height = n, this.getLayer(Or).resize(t, n);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var n = this._layers[t];
    n && n.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Or].dom;
    var n = new kd("image", this, t.pixelRatio || this.dpr);
    n.initContext(), n.clear(!1, t.backgroundColor || this._backgroundColor);
    var i = n.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var r = n.dom.width, a = n.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? i.drawImage(h.dom, 0, 0, r, a) : h.renderToCanvas && (i.save(), h.renderToCanvas(i), i.restore());
      });
    } else
      for (var o = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, s = this.storage.getDisplayList(!0), l = 0, u = s.length; l < u; l++) {
        var c = s[l];
        Ur(i, c, o, l === u - 1);
      }
    return n.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
})();
function j3(e) {
  e.registerPainter("canvas", G3);
}
const X3 = { class: "chart-container" }, q3 = {
  key: 1,
  class: "chart-wrapper"
}, Z3 = /* @__PURE__ */ Me({
  __name: "SankeyChart",
  props: {
    data: { default: () => ({ nodes: [], links: [] }) },
    title: { default: "" },
    height: { default: "500px" },
    nodeColors: { default: () => ({}) },
    useGradient: { type: Boolean, default: !0 },
    nodeGap: { default: 20 }
  },
  setup(e) {
    hp([n3, u3, H3, j3]);
    const t = e, n = pt(null), i = pt(!0), r = pt(!1);
    let a = null;
    const o = {
      animation: { duration: 1e3, easing: "cubicOut" },
      margins: { left: "2%", right: "2%", top: "2%", bottom: "2%" },
      node: { width: 70, gap: 20, align: "left", iterations: 64 },
      style: {
        shadowBlur: 4,
        shadowColor: "rgba(139, 92, 246, 0.15)"
      }
    }, s = [
      "#C67DFF",
      // Primary light
      "#8b5cf6",
      // Primary medium
      "#a855f7",
      // Bright purple
      "#7c3aed",
      // Vibrant purple
      "#5d4b93",
      // Primary dark
      "#9333ea"
      // Deep purple
    ], l = () => {
      const p = t.data.links.filter(
        (b) => b.source && b.target && typeof b.value == "number"
      ), _ = Math.max(...p.map((b) => b.value), 1), m = Math.max(1, _ * 0.01), y = p.map((b) => ({
        ...b,
        originalValue: b.value,
        value: b.value < _ * 0.01 ? m : b.value
      }));
      return {
        nodes: t.data.nodes.filter((b) => b.name),
        links: y
      };
    }, u = (p) => p.map((_, m) => ({
      ..._,
      itemStyle: {
        color: t.nodeColors[_.name] || s[m % s.length],
        borderRadius: 8
      }
    })), c = (p) => (_) => {
      if (_.dataType === "node") {
        const M = p.filter((C) => C.target === _.name), D = p.filter((C) => C.source === _.name), T = M.length > 0 ? M.reduce((C, k) => C + (k.originalValue || k.value), 0) : D.reduce((C, k) => C + (k.originalValue || k.value), 0);
        return `<div style="font-weight: 600; margin-bottom: 4px; color: #f1f5f9;">${_.name}</div><div style="color: #e2e8f0; font-size: 12px;">Count: ${T.toLocaleString()}</div>`;
      }
      const y = _.data?.source || _.source || "Unknown", b = _.data?.target || _.target || "Unknown", x = _.data?.originalValue || _.data?.value || _.value || 0, w = _.data?.label || `${x.toLocaleString()}`;
      return `<div style="font-weight: 600; margin-bottom: 4px; color: #f1f5f9;">${y}  ${b}</div><div style="color: #e2e8f0; font-size: 12px;">Flow: ${w}</div>`;
    }, h = () => {
      if (!(!a || !t.data.nodes?.length || !t.data.links?.length))
        try {
          const { nodes: p, links: _ } = l(), m = u(p), y = {
            tooltip: {
              trigger: "item",
              triggerOn: "mousemove",
              formatter: c(_),
              backgroundColor: "rgba(15, 23, 42, 0.95)",
              borderColor: "rgba(148, 163, 184, 0.2)",
              borderWidth: 1,
              borderRadius: 8,
              padding: [10, 14],
              textStyle: {
                color: "#f1f5f9",
                fontSize: 13,
                fontFamily: "'DM Sans', sans-serif",
                fontWeight: 500
              },
              shadowBlur: 10,
              shadowColor: "rgba(0, 0, 0, 0.3)"
            },
            series: [
              {
                type: "sankey",
                data: m,
                links: _,
                emphasis: { focus: "adjacency" },
                levels: [
                  {
                    depth: 0,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  },
                  {
                    depth: 1,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  }
                ],
                lineStyle: {
                  color: t.useGradient ? "gradient" : "source",
                  curveness: 0.5,
                  opacity: 0.6
                },
                itemStyle: o.style,
                label: {
                  show: !0,
                  position: "inside",
                  color: "#ffffff",
                  fontWeight: 600,
                  fontSize: 12,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (b) => {
                    const x = b.name || "";
                    return x.length > 15 ? `${x.substring(0, 15)}...` : x;
                  }
                },
                edgeLabel: {
                  show: !0,
                  fontSize: 11,
                  color: "#475569",
                  fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (b) => {
                    const x = b.data?.originalValue || b.value || 0;
                    return b.data?.label || `${x.toLocaleString()}`;
                  }
                },
                nodeAlign: o.node.align,
                nodeGap: t.nodeGap,
                nodeWidth: o.node.width,
                layoutIterations: o.node.iterations,
                orient: "horizontal",
                draggable: !1,
                ...o.margins
              }
            ],
            backgroundColor: "transparent",
            animation: !0,
            animationDuration: o.animation.duration,
            animationEasing: o.animation.easing
          };
          a.setOption(y);
        } catch (p) {
          console.error("Error setting Sankey chart options:", p), r.value = !0;
        }
    }, d = async () => {
      if (n.value)
        try {
          a = VN(n.value), h(), window.addEventListener("resize", v);
        } catch (p) {
          console.error("Error initializing Sankey chart:", p), r.value = !0;
        } finally {
          i.value = !1;
        }
    }, f = async (p = 40) => {
      await Hy();
      for (let _ = 0; _ < p; _++) {
        if (n.value?.clientWidth && n.value.clientWidth > 0 && n.value?.clientHeight && n.value.clientHeight > 0)
          return await d();
        await new Promise((m) => setTimeout(m, 50));
      }
      await d(), setTimeout(v, 50);
    }, v = () => a?.resize(), g = () => {
      window.removeEventListener("resize", v), a && (a.dispose(), a = null);
    };
    return Cn(() => n.value && f()), KS(g), Pn(() => t.data, h, { deep: !0 }), (p, _) => (O(), I("div", X3, [
      r.value ? (O(), I("div", {
        key: 0,
        class: "error-state",
        style: jr({ height: e.height })
      }, [..._[0] || (_[0] = [
        Kt('<div class="error-content" data-v-6c6d201e><svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-6c6d201e><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-6c6d201e></path></svg><p class="error-title" data-v-6c6d201e>Chart could not be loaded</p><p class="error-description" data-v-6c6d201e>Please check the data format.</p></div>', 1)
      ])], 4)) : (O(), I("div", q3, [
        Wp(S("div", {
          ref_key: "chartEl",
          ref: n,
          class: "chart-content",
          style: jr({ height: e.height })
        }, null, 4), [
          [Up, !i.value]
        ]),
        Wp(S("div", {
          class: "loading-state",
          style: jr({ height: e.height })
        }, [..._[1] || (_[1] = [
          Kt('<div class="loading-container" data-v-6c6d201e><div class="sankey-loader" data-v-6c6d201e><div class="flow flow-1" data-v-6c6d201e></div><div class="flow flow-2" data-v-6c6d201e></div><div class="flow flow-3" data-v-6c6d201e></div><div class="flow flow-4" data-v-6c6d201e></div></div><p class="loading-text" data-v-6c6d201e>Loading Sankey diagram...</p></div>', 1)
        ])], 4), [
          [Up, i.value]
        ])
      ]))
    ]));
  }
}), po = /* @__PURE__ */ de(Z3, [["__scopeId", "data-v-6c6d201e"]]), K3 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: po
}, Symbol.toStringTag, { value: "Module" }));
var eS;
function z() {
  return eS.apply(null, arguments);
}
function Q3(e) {
  eS = e;
}
function Tn(e) {
  return e instanceof Array || Object.prototype.toString.call(e) === "[object Array]";
}
function ia(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Object]";
}
function xt(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function yp(e) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(e).length === 0;
  var t;
  for (t in e)
    if (xt(e, t))
      return !1;
  return !0;
}
function Fe(e) {
  return e === void 0;
}
function ki(e) {
  return typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]";
}
function Ks(e) {
  return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
}
function nS(e, t) {
  var n = [], i, r = e.length;
  for (i = 0; i < r; ++i)
    n.push(t(e[i], i));
  return n;
}
function Ui(e, t) {
  for (var n in t)
    xt(t, n) && (e[n] = t[n]);
  return xt(t, "toString") && (e.toString = t.toString), xt(t, "valueOf") && (e.valueOf = t.valueOf), e;
}
function ei(e, t, n, i) {
  return DS(e, t, n, i, !0).utc();
}
function J3() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function rt(e) {
  return e._pf == null && (e._pf = J3()), e._pf;
}
var Wf;
Array.prototype.some ? Wf = Array.prototype.some : Wf = function(e) {
  var t = Object(this), n = t.length >>> 0, i;
  for (i = 0; i < n; i++)
    if (i in t && e.call(this, t[i], i, t))
      return !0;
  return !1;
};
function bp(e) {
  var t = null, n = !1, i = e._d && !isNaN(e._d.getTime());
  if (i && (t = rt(e), n = Wf.call(t.parsedDateParts, function(r) {
    return r != null;
  }), i = t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && n), e._strict && (i = i && t.charsLeftOver === 0 && t.unusedTokens.length === 0 && t.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(e))
    e._isValid = i;
  else
    return i;
  return e._isValid;
}
function Vc(e) {
  var t = ei(NaN);
  return e != null ? Ui(rt(t), e) : rt(t).userInvalidated = !0, t;
}
var Ey = z.momentProperties = [], Cd = !1;
function xp(e, t) {
  var n, i, r, a = Ey.length;
  if (Fe(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), Fe(t._i) || (e._i = t._i), Fe(t._f) || (e._f = t._f), Fe(t._l) || (e._l = t._l), Fe(t._strict) || (e._strict = t._strict), Fe(t._tzm) || (e._tzm = t._tzm), Fe(t._isUTC) || (e._isUTC = t._isUTC), Fe(t._offset) || (e._offset = t._offset), Fe(t._pf) || (e._pf = rt(t)), Fe(t._locale) || (e._locale = t._locale), a > 0)
    for (n = 0; n < a; n++)
      i = Ey[n], r = t[i], Fe(r) || (e[i] = r);
  return e;
}
function Qs(e) {
  xp(this, e), this._d = new Date(e._d != null ? e._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Cd === !1 && (Cd = !0, z.updateOffset(this), Cd = !1);
}
function kn(e) {
  return e instanceof Qs || e != null && e._isAMomentObject != null;
}
function iS(e) {
  z.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + e);
}
function _n(e, t) {
  var n = !0;
  return Ui(function() {
    if (z.deprecationHandler != null && z.deprecationHandler(null, e), n) {
      var i = [], r, a, o, s = arguments.length;
      for (a = 0; a < s; a++) {
        if (r = "", typeof arguments[a] == "object") {
          r += `
[` + a + "] ";
          for (o in arguments[0])
            xt(arguments[0], o) && (r += o + ": " + arguments[0][o] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[a];
        i.push(r);
      }
      iS(
        e + `
Arguments: ` + Array.prototype.slice.call(i).join("") + `
` + new Error().stack
      ), n = !1;
    }
    return t.apply(this, arguments);
  }, t);
}
var Ly = {};
function rS(e, t) {
  z.deprecationHandler != null && z.deprecationHandler(e, t), Ly[e] || (iS(t), Ly[e] = !0);
}
z.suppressDeprecationWarnings = !1;
z.deprecationHandler = null;
function ni(e) {
  return typeof Function < "u" && e instanceof Function || Object.prototype.toString.call(e) === "[object Function]";
}
function tB(e) {
  var t, n;
  for (n in e)
    xt(e, n) && (t = e[n], ni(t) ? this[n] = t : this["_" + n] = t);
  this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function Uf(e, t) {
  var n = Ui({}, e), i;
  for (i in t)
    xt(t, i) && (ia(e[i]) && ia(t[i]) ? (n[i] = {}, Ui(n[i], e[i]), Ui(n[i], t[i])) : t[i] != null ? n[i] = t[i] : delete n[i]);
  for (i in e)
    xt(e, i) && !xt(t, i) && ia(e[i]) && (n[i] = Ui({}, n[i]));
  return n;
}
function wp(e) {
  e != null && this.set(e);
}
var Gf;
Object.keys ? Gf = Object.keys : Gf = function(e) {
  var t, n = [];
  for (t in e)
    xt(e, t) && n.push(t);
  return n;
};
var eB = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function nB(e, t, n) {
  var i = this._calendar[e] || this._calendar.sameElse;
  return ni(i) ? i.call(t, n) : i;
}
function Jn(e, t, n) {
  var i = "" + Math.abs(e), r = t - i.length, a = e >= 0;
  return (a ? n ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + i;
}
var Sp = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, Kl = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Pd = {}, Ka = {};
function j(e, t, n, i) {
  var r = i;
  typeof i == "string" && (r = function() {
    return this[i]();
  }), e && (Ka[e] = r), t && (Ka[t[0]] = function() {
    return Jn(r.apply(this, arguments), t[1], t[2]);
  }), n && (Ka[n] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      e
    );
  });
}
function iB(e) {
  return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "");
}
function rB(e) {
  var t = e.match(Sp), n, i;
  for (n = 0, i = t.length; n < i; n++)
    Ka[t[n]] ? t[n] = Ka[t[n]] : t[n] = iB(t[n]);
  return function(r) {
    var a = "", o;
    for (o = 0; o < i; o++)
      a += ni(t[o]) ? t[o].call(r, e) : t[o];
    return a;
  };
}
function fu(e, t) {
  return e.isValid() ? (t = aS(t, e.localeData()), Pd[t] = Pd[t] || rB(t), Pd[t](e)) : e.localeData().invalidDate();
}
function aS(e, t) {
  var n = 5;
  function i(r) {
    return t.longDateFormat(r) || r;
  }
  for (Kl.lastIndex = 0; n >= 0 && Kl.test(e); )
    e = e.replace(
      Kl,
      i
    ), Kl.lastIndex = 0, n -= 1;
  return e;
}
var aB = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function oB(e) {
  var t = this._longDateFormat[e], n = this._longDateFormat[e.toUpperCase()];
  return t || !n ? t : (this._longDateFormat[e] = n.match(Sp).map(function(i) {
    return i === "MMMM" || i === "MM" || i === "DD" || i === "dddd" ? i.slice(1) : i;
  }).join(""), this._longDateFormat[e]);
}
var sB = "Invalid date";
function lB() {
  return this._invalidDate;
}
var uB = "%d", cB = /\d{1,2}/;
function hB(e) {
  return this._ordinal.replace("%d", e);
}
var dB = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function fB(e, t, n, i) {
  var r = this._relativeTime[n];
  return ni(r) ? r(e, t, n, i) : r.replace(/%d/i, e);
}
function vB(e, t) {
  var n = this._relativeTime[e > 0 ? "future" : "past"];
  return ni(n) ? n(t) : n.replace(/%s/i, t);
}
var Oy = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function mn(e) {
  return typeof e == "string" ? Oy[e] || Oy[e.toLowerCase()] : void 0;
}
function Mp(e) {
  var t = {}, n, i;
  for (i in e)
    xt(e, i) && (n = mn(i), n && (t[n] = e[i]));
  return t;
}
var pB = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function gB(e) {
  var t = [], n;
  for (n in e)
    xt(e, n) && t.push({ unit: n, priority: pB[n] });
  return t.sort(function(i, r) {
    return i.priority - r.priority;
  }), t;
}
var oS = /\d/, Je = /\d\d/, sS = /\d{3}/, Dp = /\d{4}/, $c = /[+-]?\d{6}/, $t = /\d\d?/, lS = /\d\d\d\d?/, uS = /\d\d\d\d\d\d?/, Hc = /\d{1,3}/, Tp = /\d{1,4}/, Yc = /[+-]?\d{1,6}/, go = /\d+/, Wc = /[+-]?\d+/, _B = /Z|[+-]\d\d:?\d\d/gi, Uc = /Z|[+-]\d\d(?::?\d\d)?/gi, mB = /[+-]?\d+(\.\d{1,3})?/, Js = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, _o = /^[1-9]\d?/, kp = /^([1-9]\d|\d)/, lc;
lc = {};
function Y(e, t, n) {
  lc[e] = ni(t) ? t : function(i, r) {
    return i && n ? n : t;
  };
}
function yB(e, t) {
  return xt(lc, e) ? lc[e](t._strict, t._locale) : new RegExp(bB(e));
}
function bB(e) {
  return wi(
    e.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(t, n, i, r, a) {
        return n || i || r || a;
      }
    )
  );
}
function wi(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function dn(e) {
  return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
}
function vt(e) {
  var t = +e, n = 0;
  return t !== 0 && isFinite(t) && (n = dn(t)), n;
}
var jf = {};
function Et(e, t) {
  var n, i = t, r;
  for (typeof e == "string" && (e = [e]), ki(t) && (i = function(a, o) {
    o[t] = vt(a);
  }), r = e.length, n = 0; n < r; n++)
    jf[e[n]] = i;
}
function tl(e, t) {
  Et(e, function(n, i, r, a) {
    r._w = r._w || {}, t(n, r._w, r, a);
  });
}
function xB(e, t, n) {
  t != null && xt(jf, e) && jf[e](t, n._a, n, e);
}
function Gc(e) {
  return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
}
var xe = 0, mi = 1, Wn = 2, le = 3, Sn = 4, yi = 5, Gr = 6, wB = 7, SB = 8;
j("Y", 0, 0, function() {
  var e = this.year();
  return e <= 9999 ? Jn(e, 4) : "+" + e;
});
j(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
j(0, ["YYYY", 4], 0, "year");
j(0, ["YYYYY", 5], 0, "year");
j(0, ["YYYYYY", 6, !0], 0, "year");
Y("Y", Wc);
Y("YY", $t, Je);
Y("YYYY", Tp, Dp);
Y("YYYYY", Yc, $c);
Y("YYYYYY", Yc, $c);
Et(["YYYYY", "YYYYYY"], xe);
Et("YYYY", function(e, t) {
  t[xe] = e.length === 2 ? z.parseTwoDigitYear(e) : vt(e);
});
Et("YY", function(e, t) {
  t[xe] = z.parseTwoDigitYear(e);
});
Et("Y", function(e, t) {
  t[xe] = parseInt(e, 10);
});
function ys(e) {
  return Gc(e) ? 366 : 365;
}
z.parseTwoDigitYear = function(e) {
  return vt(e) + (vt(e) > 68 ? 1900 : 2e3);
};
var cS = mo("FullYear", !0);
function MB() {
  return Gc(this.year());
}
function mo(e, t) {
  return function(n) {
    return n != null ? (hS(this, e, n), z.updateOffset(this, t), this) : $s(this, e);
  };
}
function $s(e, t) {
  if (!e.isValid())
    return NaN;
  var n = e._d, i = e._isUTC;
  switch (t) {
    case "Milliseconds":
      return i ? n.getUTCMilliseconds() : n.getMilliseconds();
    case "Seconds":
      return i ? n.getUTCSeconds() : n.getSeconds();
    case "Minutes":
      return i ? n.getUTCMinutes() : n.getMinutes();
    case "Hours":
      return i ? n.getUTCHours() : n.getHours();
    case "Date":
      return i ? n.getUTCDate() : n.getDate();
    case "Day":
      return i ? n.getUTCDay() : n.getDay();
    case "Month":
      return i ? n.getUTCMonth() : n.getMonth();
    case "FullYear":
      return i ? n.getUTCFullYear() : n.getFullYear();
    default:
      return NaN;
  }
}
function hS(e, t, n) {
  var i, r, a, o, s;
  if (!(!e.isValid() || isNaN(n))) {
    switch (i = e._d, r = e._isUTC, t) {
      case "Milliseconds":
        return void (r ? i.setUTCMilliseconds(n) : i.setMilliseconds(n));
      case "Seconds":
        return void (r ? i.setUTCSeconds(n) : i.setSeconds(n));
      case "Minutes":
        return void (r ? i.setUTCMinutes(n) : i.setMinutes(n));
      case "Hours":
        return void (r ? i.setUTCHours(n) : i.setHours(n));
      case "Date":
        return void (r ? i.setUTCDate(n) : i.setDate(n));
      // case 'Day': // Not real
      //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
      // case 'Month': // Not used because we need to pass two variables
      //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
      case "FullYear":
        break;
      // See below ...
      default:
        return;
    }
    a = n, o = e.month(), s = e.date(), s = s === 29 && o === 1 && !Gc(a) ? 28 : s, r ? i.setUTCFullYear(a, o, s) : i.setFullYear(a, o, s);
  }
}
function DB(e) {
  return e = mn(e), ni(this[e]) ? this[e]() : this;
}
function TB(e, t) {
  if (typeof e == "object") {
    e = Mp(e);
    var n = gB(e), i, r = n.length;
    for (i = 0; i < r; i++)
      this[n[i].unit](e[n[i].unit]);
  } else if (e = mn(e), ni(this[e]))
    return this[e](t);
  return this;
}
function kB(e, t) {
  return (e % t + t) % t;
}
var Jt;
Array.prototype.indexOf ? Jt = Array.prototype.indexOf : Jt = function(e) {
  var t;
  for (t = 0; t < this.length; ++t)
    if (this[t] === e)
      return t;
  return -1;
};
function Cp(e, t) {
  if (isNaN(e) || isNaN(t))
    return NaN;
  var n = kB(t, 12);
  return e += (t - n) / 12, n === 1 ? Gc(e) ? 29 : 28 : 31 - n % 7 % 2;
}
j("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
j("MMM", 0, 0, function(e) {
  return this.localeData().monthsShort(this, e);
});
j("MMMM", 0, 0, function(e) {
  return this.localeData().months(this, e);
});
Y("M", $t, _o);
Y("MM", $t, Je);
Y("MMM", function(e, t) {
  return t.monthsShortRegex(e);
});
Y("MMMM", function(e, t) {
  return t.monthsRegex(e);
});
Et(["M", "MM"], function(e, t) {
  t[mi] = vt(e) - 1;
});
Et(["MMM", "MMMM"], function(e, t, n, i) {
  var r = n._locale.monthsParse(e, i, n._strict);
  r != null ? t[mi] = r : rt(n).invalidMonth = e;
});
var CB = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), dS = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), fS = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, PB = Js, AB = Js;
function EB(e, t) {
  return e ? Tn(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || fS).test(t) ? "format" : "standalone"][e.month()] : Tn(this._months) ? this._months : this._months.standalone;
}
function LB(e, t) {
  return e ? Tn(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[fS.test(t) ? "format" : "standalone"][e.month()] : Tn(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function OB(e, t, n) {
  var i, r, a, o = e.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], i = 0; i < 12; ++i)
      a = ei([2e3, i]), this._shortMonthsParse[i] = this.monthsShort(
        a,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[i] = this.months(a, "").toLocaleLowerCase();
  return n ? t === "MMM" ? (r = Jt.call(this._shortMonthsParse, o), r !== -1 ? r : null) : (r = Jt.call(this._longMonthsParse, o), r !== -1 ? r : null) : t === "MMM" ? (r = Jt.call(this._shortMonthsParse, o), r !== -1 ? r : (r = Jt.call(this._longMonthsParse, o), r !== -1 ? r : null)) : (r = Jt.call(this._longMonthsParse, o), r !== -1 ? r : (r = Jt.call(this._shortMonthsParse, o), r !== -1 ? r : null));
}
function IB(e, t, n) {
  var i, r, a;
  if (this._monthsParseExact)
    return OB.call(this, e, t, n);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), i = 0; i < 12; i++) {
    if (r = ei([2e3, i]), n && !this._longMonthsParse[i] && (this._longMonthsParse[i] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[i] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !n && !this._monthsParse[i] && (a = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[i] = new RegExp(a.replace(".", ""), "i")), n && t === "MMMM" && this._longMonthsParse[i].test(e))
      return i;
    if (n && t === "MMM" && this._shortMonthsParse[i].test(e))
      return i;
    if (!n && this._monthsParse[i].test(e))
      return i;
  }
}
function vS(e, t) {
  if (!e.isValid())
    return e;
  if (typeof t == "string") {
    if (/^\d+$/.test(t))
      t = vt(t);
    else if (t = e.localeData().monthsParse(t), !ki(t))
      return e;
  }
  var n = t, i = e.date();
  return i = i < 29 ? i : Math.min(i, Cp(e.year(), n)), e._isUTC ? e._d.setUTCMonth(n, i) : e._d.setMonth(n, i), e;
}
function pS(e) {
  return e != null ? (vS(this, e), z.updateOffset(this, !0), this) : $s(this, "Month");
}
function RB() {
  return Cp(this.year(), this.month());
}
function NB(e) {
  return this._monthsParseExact ? (xt(this, "_monthsRegex") || gS.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (xt(this, "_monthsShortRegex") || (this._monthsShortRegex = PB), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function FB(e) {
  return this._monthsParseExact ? (xt(this, "_monthsRegex") || gS.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (xt(this, "_monthsRegex") || (this._monthsRegex = AB), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex);
}
function gS() {
  function e(l, u) {
    return u.length - l.length;
  }
  var t = [], n = [], i = [], r, a, o, s;
  for (r = 0; r < 12; r++)
    a = ei([2e3, r]), o = wi(this.monthsShort(a, "")), s = wi(this.months(a, "")), t.push(o), n.push(s), i.push(s), i.push(o);
  t.sort(e), n.sort(e), i.sort(e), this._monthsRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + n.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function BB(e, t, n, i, r, a, o) {
  var s;
  return e < 100 && e >= 0 ? (s = new Date(e + 400, t, n, i, r, a, o), isFinite(s.getFullYear()) && s.setFullYear(e)) : s = new Date(e, t, n, i, r, a, o), s;
}
function Hs(e) {
  var t, n;
  return e < 100 && e >= 0 ? (n = Array.prototype.slice.call(arguments), n[0] = e + 400, t = new Date(Date.UTC.apply(null, n)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t;
}
function uc(e, t, n) {
  var i = 7 + t - n, r = (7 + Hs(e, 0, i).getUTCDay() - t) % 7;
  return -r + i - 1;
}
function _S(e, t, n, i, r) {
  var a = (7 + n - i) % 7, o = uc(e, i, r), s = 1 + 7 * (t - 1) + a + o, l, u;
  return s <= 0 ? (l = e - 1, u = ys(l) + s) : s > ys(e) ? (l = e + 1, u = s - ys(e)) : (l = e, u = s), {
    year: l,
    dayOfYear: u
  };
}
function Ys(e, t, n) {
  var i = uc(e.year(), t, n), r = Math.floor((e.dayOfYear() - i - 1) / 7) + 1, a, o;
  return r < 1 ? (o = e.year() - 1, a = r + Si(o, t, n)) : r > Si(e.year(), t, n) ? (a = r - Si(e.year(), t, n), o = e.year() + 1) : (o = e.year(), a = r), {
    week: a,
    year: o
  };
}
function Si(e, t, n) {
  var i = uc(e, t, n), r = uc(e + 1, t, n);
  return (ys(e) - i + r) / 7;
}
j("w", ["ww", 2], "wo", "week");
j("W", ["WW", 2], "Wo", "isoWeek");
Y("w", $t, _o);
Y("ww", $t, Je);
Y("W", $t, _o);
Y("WW", $t, Je);
tl(
  ["w", "ww", "W", "WW"],
  function(e, t, n, i) {
    t[i.substr(0, 1)] = vt(e);
  }
);
function zB(e) {
  return Ys(e, this._week.dow, this._week.doy).week;
}
var VB = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function $B() {
  return this._week.dow;
}
function HB() {
  return this._week.doy;
}
function YB(e) {
  var t = this.localeData().week(this);
  return e == null ? t : this.add((e - t) * 7, "d");
}
function WB(e) {
  var t = Ys(this, 1, 4).week;
  return e == null ? t : this.add((e - t) * 7, "d");
}
j("d", 0, "do", "day");
j("dd", 0, 0, function(e) {
  return this.localeData().weekdaysMin(this, e);
});
j("ddd", 0, 0, function(e) {
  return this.localeData().weekdaysShort(this, e);
});
j("dddd", 0, 0, function(e) {
  return this.localeData().weekdays(this, e);
});
j("e", 0, 0, "weekday");
j("E", 0, 0, "isoWeekday");
Y("d", $t);
Y("e", $t);
Y("E", $t);
Y("dd", function(e, t) {
  return t.weekdaysMinRegex(e);
});
Y("ddd", function(e, t) {
  return t.weekdaysShortRegex(e);
});
Y("dddd", function(e, t) {
  return t.weekdaysRegex(e);
});
tl(["dd", "ddd", "dddd"], function(e, t, n, i) {
  var r = n._locale.weekdaysParse(e, i, n._strict);
  r != null ? t.d = r : rt(n).invalidWeekday = e;
});
tl(["d", "e", "E"], function(e, t, n, i) {
  t[i] = vt(e);
});
function UB(e, t) {
  return typeof e != "string" ? e : isNaN(e) ? (e = t.weekdaysParse(e), typeof e == "number" ? e : null) : parseInt(e, 10);
}
function GB(e, t) {
  return typeof e == "string" ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e;
}
function Pp(e, t) {
  return e.slice(t, 7).concat(e.slice(0, t));
}
var jB = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), mS = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), XB = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), qB = Js, ZB = Js, KB = Js;
function QB(e, t) {
  var n = Tn(this._weekdays) ? this._weekdays : this._weekdays[e && e !== !0 && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
  return e === !0 ? Pp(n, this._week.dow) : e ? n[e.day()] : n;
}
function JB(e) {
  return e === !0 ? Pp(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort;
}
function tz(e) {
  return e === !0 ? Pp(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin;
}
function ez(e, t, n) {
  var i, r, a, o = e.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], i = 0; i < 7; ++i)
      a = ei([2e3, 1]).day(i), this._minWeekdaysParse[i] = this.weekdaysMin(
        a,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[i] = this.weekdaysShort(
        a,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[i] = this.weekdays(a, "").toLocaleLowerCase();
  return n ? t === "dddd" ? (r = Jt.call(this._weekdaysParse, o), r !== -1 ? r : null) : t === "ddd" ? (r = Jt.call(this._shortWeekdaysParse, o), r !== -1 ? r : null) : (r = Jt.call(this._minWeekdaysParse, o), r !== -1 ? r : null) : t === "dddd" ? (r = Jt.call(this._weekdaysParse, o), r !== -1 || (r = Jt.call(this._shortWeekdaysParse, o), r !== -1) ? r : (r = Jt.call(this._minWeekdaysParse, o), r !== -1 ? r : null)) : t === "ddd" ? (r = Jt.call(this._shortWeekdaysParse, o), r !== -1 || (r = Jt.call(this._weekdaysParse, o), r !== -1) ? r : (r = Jt.call(this._minWeekdaysParse, o), r !== -1 ? r : null)) : (r = Jt.call(this._minWeekdaysParse, o), r !== -1 || (r = Jt.call(this._weekdaysParse, o), r !== -1) ? r : (r = Jt.call(this._shortWeekdaysParse, o), r !== -1 ? r : null));
}
function nz(e, t, n) {
  var i, r, a;
  if (this._weekdaysParseExact)
    return ez.call(this, e, t, n);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), i = 0; i < 7; i++) {
    if (r = ei([2e3, 1]).day(i), n && !this._fullWeekdaysParse[i] && (this._fullWeekdaysParse[i] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[i] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[i] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[i] || (a = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[i] = new RegExp(a.replace(".", ""), "i")), n && t === "dddd" && this._fullWeekdaysParse[i].test(e))
      return i;
    if (n && t === "ddd" && this._shortWeekdaysParse[i].test(e))
      return i;
    if (n && t === "dd" && this._minWeekdaysParse[i].test(e))
      return i;
    if (!n && this._weekdaysParse[i].test(e))
      return i;
  }
}
function iz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = $s(this, "Day");
  return e != null ? (e = UB(e, this.localeData()), this.add(e - t, "d")) : t;
}
function rz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return e == null ? t : this.add(e - t, "d");
}
function az(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    var t = GB(e, this.localeData());
    return this.day(this.day() % 7 ? t : t - 7);
  } else
    return this.day() || 7;
}
function oz(e) {
  return this._weekdaysParseExact ? (xt(this, "_weekdaysRegex") || Ap.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (xt(this, "_weekdaysRegex") || (this._weekdaysRegex = qB), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function sz(e) {
  return this._weekdaysParseExact ? (xt(this, "_weekdaysRegex") || Ap.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (xt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = ZB), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function lz(e) {
  return this._weekdaysParseExact ? (xt(this, "_weekdaysRegex") || Ap.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (xt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = KB), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Ap() {
  function e(c, h) {
    return h.length - c.length;
  }
  var t = [], n = [], i = [], r = [], a, o, s, l, u;
  for (a = 0; a < 7; a++)
    o = ei([2e3, 1]).day(a), s = wi(this.weekdaysMin(o, "")), l = wi(this.weekdaysShort(o, "")), u = wi(this.weekdays(o, "")), t.push(s), n.push(l), i.push(u), r.push(s), r.push(l), r.push(u);
  t.sort(e), n.sort(e), i.sort(e), r.sort(e), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + n.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function Ep() {
  return this.hours() % 12 || 12;
}
function uz() {
  return this.hours() || 24;
}
j("H", ["HH", 2], 0, "hour");
j("h", ["hh", 2], 0, Ep);
j("k", ["kk", 2], 0, uz);
j("hmm", 0, 0, function() {
  return "" + Ep.apply(this) + Jn(this.minutes(), 2);
});
j("hmmss", 0, 0, function() {
  return "" + Ep.apply(this) + Jn(this.minutes(), 2) + Jn(this.seconds(), 2);
});
j("Hmm", 0, 0, function() {
  return "" + this.hours() + Jn(this.minutes(), 2);
});
j("Hmmss", 0, 0, function() {
  return "" + this.hours() + Jn(this.minutes(), 2) + Jn(this.seconds(), 2);
});
function yS(e, t) {
  j(e, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      t
    );
  });
}
yS("a", !0);
yS("A", !1);
function bS(e, t) {
  return t._meridiemParse;
}
Y("a", bS);
Y("A", bS);
Y("H", $t, kp);
Y("h", $t, _o);
Y("k", $t, _o);
Y("HH", $t, Je);
Y("hh", $t, Je);
Y("kk", $t, Je);
Y("hmm", lS);
Y("hmmss", uS);
Y("Hmm", lS);
Y("Hmmss", uS);
Et(["H", "HH"], le);
Et(["k", "kk"], function(e, t, n) {
  var i = vt(e);
  t[le] = i === 24 ? 0 : i;
});
Et(["a", "A"], function(e, t, n) {
  n._isPm = n._locale.isPM(e), n._meridiem = e;
});
Et(["h", "hh"], function(e, t, n) {
  t[le] = vt(e), rt(n).bigHour = !0;
});
Et("hmm", function(e, t, n) {
  var i = e.length - 2;
  t[le] = vt(e.substr(0, i)), t[Sn] = vt(e.substr(i)), rt(n).bigHour = !0;
});
Et("hmmss", function(e, t, n) {
  var i = e.length - 4, r = e.length - 2;
  t[le] = vt(e.substr(0, i)), t[Sn] = vt(e.substr(i, 2)), t[yi] = vt(e.substr(r)), rt(n).bigHour = !0;
});
Et("Hmm", function(e, t, n) {
  var i = e.length - 2;
  t[le] = vt(e.substr(0, i)), t[Sn] = vt(e.substr(i));
});
Et("Hmmss", function(e, t, n) {
  var i = e.length - 4, r = e.length - 2;
  t[le] = vt(e.substr(0, i)), t[Sn] = vt(e.substr(i, 2)), t[yi] = vt(e.substr(r));
});
function cz(e) {
  return (e + "").toLowerCase().charAt(0) === "p";
}
var hz = /[ap]\.?m?\.?/i, dz = mo("Hours", !0);
function fz(e, t, n) {
  return e > 11 ? n ? "pm" : "PM" : n ? "am" : "AM";
}
var xS = {
  calendar: eB,
  longDateFormat: aB,
  invalidDate: sB,
  ordinal: uB,
  dayOfMonthOrdinalParse: cB,
  relativeTime: dB,
  months: CB,
  monthsShort: dS,
  week: VB,
  weekdays: jB,
  weekdaysMin: XB,
  weekdaysShort: mS,
  meridiemParse: hz
}, Yt = {}, Uo = {}, Ws;
function vz(e, t) {
  var n, i = Math.min(e.length, t.length);
  for (n = 0; n < i; n += 1)
    if (e[n] !== t[n])
      return n;
  return i;
}
function Iy(e) {
  return e && e.toLowerCase().replace("_", "-");
}
function pz(e) {
  for (var t = 0, n, i, r, a; t < e.length; ) {
    for (a = Iy(e[t]).split("-"), n = a.length, i = Iy(e[t + 1]), i = i ? i.split("-") : null; n > 0; ) {
      if (r = jc(a.slice(0, n).join("-")), r)
        return r;
      if (i && i.length >= n && vz(a, i) >= n - 1)
        break;
      n--;
    }
    t++;
  }
  return Ws;
}
function gz(e) {
  return !!(e && e.match("^[^/\\\\]*$"));
}
function jc(e) {
  var t = null, n;
  if (Yt[e] === void 0 && typeof module < "u" && module && module.exports && gz(e))
    try {
      t = Ws._abbr, n = require, n("./locale/" + e), Qi(t);
    } catch {
      Yt[e] = null;
    }
  return Yt[e];
}
function Qi(e, t) {
  var n;
  return e && (Fe(t) ? n = Ai(e) : n = Lp(e, t), n ? Ws = n : typeof console < "u" && console.warn && console.warn(
    "Locale " + e + " not found. Did you forget to load it?"
  )), Ws._abbr;
}
function Lp(e, t) {
  if (t !== null) {
    var n, i = xS;
    if (t.abbr = e, Yt[e] != null)
      rS(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), i = Yt[e]._config;
    else if (t.parentLocale != null)
      if (Yt[t.parentLocale] != null)
        i = Yt[t.parentLocale]._config;
      else if (n = jc(t.parentLocale), n != null)
        i = n._config;
      else
        return Uo[t.parentLocale] || (Uo[t.parentLocale] = []), Uo[t.parentLocale].push({
          name: e,
          config: t
        }), null;
    return Yt[e] = new wp(Uf(i, t)), Uo[e] && Uo[e].forEach(function(r) {
      Lp(r.name, r.config);
    }), Qi(e), Yt[e];
  } else
    return delete Yt[e], null;
}
function _z(e, t) {
  if (t != null) {
    var n, i, r = xS;
    Yt[e] != null && Yt[e].parentLocale != null ? Yt[e].set(Uf(Yt[e]._config, t)) : (i = jc(e), i != null && (r = i._config), t = Uf(r, t), i == null && (t.abbr = e), n = new wp(t), n.parentLocale = Yt[e], Yt[e] = n), Qi(e);
  } else
    Yt[e] != null && (Yt[e].parentLocale != null ? (Yt[e] = Yt[e].parentLocale, e === Qi() && Qi(e)) : Yt[e] != null && delete Yt[e]);
  return Yt[e];
}
function Ai(e) {
  var t;
  if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e)
    return Ws;
  if (!Tn(e)) {
    if (t = jc(e), t)
      return t;
    e = [e];
  }
  return pz(e);
}
function mz() {
  return Gf(Yt);
}
function Op(e) {
  var t, n = e._a;
  return n && rt(e).overflow === -2 && (t = n[mi] < 0 || n[mi] > 11 ? mi : n[Wn] < 1 || n[Wn] > Cp(n[xe], n[mi]) ? Wn : n[le] < 0 || n[le] > 24 || n[le] === 24 && (n[Sn] !== 0 || n[yi] !== 0 || n[Gr] !== 0) ? le : n[Sn] < 0 || n[Sn] > 59 ? Sn : n[yi] < 0 || n[yi] > 59 ? yi : n[Gr] < 0 || n[Gr] > 999 ? Gr : -1, rt(e)._overflowDayOfYear && (t < xe || t > Wn) && (t = Wn), rt(e)._overflowWeeks && t === -1 && (t = wB), rt(e)._overflowWeekday && t === -1 && (t = SB), rt(e).overflow = t), e;
}
var yz = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, bz = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, xz = /Z|[+-]\d\d(?::?\d\d)?/, Ql = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Ad = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], wz = /^\/?Date\((-?\d+)/i, Sz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Mz = {
  UT: 0,
  GMT: 0,
  EDT: -240,
  EST: -300,
  CDT: -300,
  CST: -360,
  MDT: -360,
  MST: -420,
  PDT: -420,
  PST: -480
};
function wS(e) {
  var t, n, i = e._i, r = yz.exec(i) || bz.exec(i), a, o, s, l, u = Ql.length, c = Ad.length;
  if (r) {
    for (rt(e).iso = !0, t = 0, n = u; t < n; t++)
      if (Ql[t][1].exec(r[1])) {
        o = Ql[t][0], a = Ql[t][2] !== !1;
        break;
      }
    if (o == null) {
      e._isValid = !1;
      return;
    }
    if (r[3]) {
      for (t = 0, n = c; t < n; t++)
        if (Ad[t][1].exec(r[3])) {
          s = (r[2] || " ") + Ad[t][0];
          break;
        }
      if (s == null) {
        e._isValid = !1;
        return;
      }
    }
    if (!a && s != null) {
      e._isValid = !1;
      return;
    }
    if (r[4])
      if (xz.exec(r[4]))
        l = "Z";
      else {
        e._isValid = !1;
        return;
      }
    e._f = o + (s || "") + (l || ""), Rp(e);
  } else
    e._isValid = !1;
}
function Dz(e, t, n, i, r, a) {
  var o = [
    Tz(e),
    dS.indexOf(t),
    parseInt(n, 10),
    parseInt(i, 10),
    parseInt(r, 10)
  ];
  return a && o.push(parseInt(a, 10)), o;
}
function Tz(e) {
  var t = parseInt(e, 10);
  return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t;
}
function kz(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Cz(e, t, n) {
  if (e) {
    var i = mS.indexOf(e), r = new Date(
      t[0],
      t[1],
      t[2]
    ).getDay();
    if (i !== r)
      return rt(n).weekdayMismatch = !0, n._isValid = !1, !1;
  }
  return !0;
}
function Pz(e, t, n) {
  if (e)
    return Mz[e];
  if (t)
    return 0;
  var i = parseInt(n, 10), r = i % 100, a = (i - r) / 100;
  return a * 60 + r;
}
function SS(e) {
  var t = Sz.exec(kz(e._i)), n;
  if (t) {
    if (n = Dz(
      t[4],
      t[3],
      t[2],
      t[5],
      t[6],
      t[7]
    ), !Cz(t[1], n, e))
      return;
    e._a = n, e._tzm = Pz(t[8], t[9], t[10]), e._d = Hs.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), rt(e).rfc2822 = !0;
  } else
    e._isValid = !1;
}
function Az(e) {
  var t = wz.exec(e._i);
  if (t !== null) {
    e._d = /* @__PURE__ */ new Date(+t[1]);
    return;
  }
  if (wS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  if (SS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  e._strict ? e._isValid = !1 : z.createFromInputFallback(e);
}
z.createFromInputFallback = _n(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(e) {
    e._d = /* @__PURE__ */ new Date(e._i + (e._useUTC ? " UTC" : ""));
  }
);
function Fa(e, t, n) {
  return e ?? t ?? n;
}
function Ez(e) {
  var t = new Date(z.now());
  return e._useUTC ? [
    t.getUTCFullYear(),
    t.getUTCMonth(),
    t.getUTCDate()
  ] : [t.getFullYear(), t.getMonth(), t.getDate()];
}
function Ip(e) {
  var t, n, i = [], r, a, o;
  if (!e._d) {
    for (r = Ez(e), e._w && e._a[Wn] == null && e._a[mi] == null && Lz(e), e._dayOfYear != null && (o = Fa(e._a[xe], r[xe]), (e._dayOfYear > ys(o) || e._dayOfYear === 0) && (rt(e)._overflowDayOfYear = !0), n = Hs(o, 0, e._dayOfYear), e._a[mi] = n.getUTCMonth(), e._a[Wn] = n.getUTCDate()), t = 0; t < 3 && e._a[t] == null; ++t)
      e._a[t] = i[t] = r[t];
    for (; t < 7; t++)
      e._a[t] = i[t] = e._a[t] == null ? t === 2 ? 1 : 0 : e._a[t];
    e._a[le] === 24 && e._a[Sn] === 0 && e._a[yi] === 0 && e._a[Gr] === 0 && (e._nextDay = !0, e._a[le] = 0), e._d = (e._useUTC ? Hs : BB).apply(
      null,
      i
    ), a = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[le] = 24), e._w && typeof e._w.d < "u" && e._w.d !== a && (rt(e).weekdayMismatch = !0);
  }
}
function Lz(e) {
  var t, n, i, r, a, o, s, l, u;
  t = e._w, t.GG != null || t.W != null || t.E != null ? (a = 1, o = 4, n = Fa(
    t.GG,
    e._a[xe],
    Ys(Vt(), 1, 4).year
  ), i = Fa(t.W, 1), r = Fa(t.E, 1), (r < 1 || r > 7) && (l = !0)) : (a = e._locale._week.dow, o = e._locale._week.doy, u = Ys(Vt(), a, o), n = Fa(t.gg, e._a[xe], u.year), i = Fa(t.w, u.week), t.d != null ? (r = t.d, (r < 0 || r > 6) && (l = !0)) : t.e != null ? (r = t.e + a, (t.e < 0 || t.e > 6) && (l = !0)) : r = a), i < 1 || i > Si(n, a, o) ? rt(e)._overflowWeeks = !0 : l != null ? rt(e)._overflowWeekday = !0 : (s = _S(n, i, r, a, o), e._a[xe] = s.year, e._dayOfYear = s.dayOfYear);
}
z.ISO_8601 = function() {
};
z.RFC_2822 = function() {
};
function Rp(e) {
  if (e._f === z.ISO_8601) {
    wS(e);
    return;
  }
  if (e._f === z.RFC_2822) {
    SS(e);
    return;
  }
  e._a = [], rt(e).empty = !0;
  var t = "" + e._i, n, i, r, a, o, s = t.length, l = 0, u, c;
  for (r = aS(e._f, e._locale).match(Sp) || [], c = r.length, n = 0; n < c; n++)
    a = r[n], i = (t.match(yB(a, e)) || [])[0], i && (o = t.substr(0, t.indexOf(i)), o.length > 0 && rt(e).unusedInput.push(o), t = t.slice(
      t.indexOf(i) + i.length
    ), l += i.length), Ka[a] ? (i ? rt(e).empty = !1 : rt(e).unusedTokens.push(a), xB(a, i, e)) : e._strict && !i && rt(e).unusedTokens.push(a);
  rt(e).charsLeftOver = s - l, t.length > 0 && rt(e).unusedInput.push(t), e._a[le] <= 12 && rt(e).bigHour === !0 && e._a[le] > 0 && (rt(e).bigHour = void 0), rt(e).parsedDateParts = e._a.slice(0), rt(e).meridiem = e._meridiem, e._a[le] = Oz(
    e._locale,
    e._a[le],
    e._meridiem
  ), u = rt(e).era, u !== null && (e._a[xe] = e._locale.erasConvertYear(u, e._a[xe])), Ip(e), Op(e);
}
function Oz(e, t, n) {
  var i;
  return n == null ? t : e.meridiemHour != null ? e.meridiemHour(t, n) : (e.isPM != null && (i = e.isPM(n), i && t < 12 && (t += 12), !i && t === 12 && (t = 0)), t);
}
function Iz(e) {
  var t, n, i, r, a, o, s = !1, l = e._f.length;
  if (l === 0) {
    rt(e).invalidFormat = !0, e._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    a = 0, o = !1, t = xp({}, e), e._useUTC != null && (t._useUTC = e._useUTC), t._f = e._f[r], Rp(t), bp(t) && (o = !0), a += rt(t).charsLeftOver, a += rt(t).unusedTokens.length * 10, rt(t).score = a, s ? a < i && (i = a, n = t) : (i == null || a < i || o) && (i = a, n = t, o && (s = !0));
  Ui(e, n || t);
}
function Rz(e) {
  if (!e._d) {
    var t = Mp(e._i), n = t.day === void 0 ? t.date : t.day;
    e._a = nS(
      [t.year, t.month, n, t.hour, t.minute, t.second, t.millisecond],
      function(i) {
        return i && parseInt(i, 10);
      }
    ), Ip(e);
  }
}
function Nz(e) {
  var t = new Qs(Op(MS(e)));
  return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t;
}
function MS(e) {
  var t = e._i, n = e._f;
  return e._locale = e._locale || Ai(e._l), t === null || n === void 0 && t === "" ? Vc({ nullInput: !0 }) : (typeof t == "string" && (e._i = t = e._locale.preparse(t)), kn(t) ? new Qs(Op(t)) : (Ks(t) ? e._d = t : Tn(n) ? Iz(e) : n ? Rp(e) : Fz(e), bp(e) || (e._d = null), e));
}
function Fz(e) {
  var t = e._i;
  Fe(t) ? e._d = new Date(z.now()) : Ks(t) ? e._d = new Date(t.valueOf()) : typeof t == "string" ? Az(e) : Tn(t) ? (e._a = nS(t.slice(0), function(n) {
    return parseInt(n, 10);
  }), Ip(e)) : ia(t) ? Rz(e) : ki(t) ? e._d = new Date(t) : z.createFromInputFallback(e);
}
function DS(e, t, n, i, r) {
  var a = {};
  return (t === !0 || t === !1) && (i = t, t = void 0), (n === !0 || n === !1) && (i = n, n = void 0), (ia(e) && yp(e) || Tn(e) && e.length === 0) && (e = void 0), a._isAMomentObject = !0, a._useUTC = a._isUTC = r, a._l = n, a._i = e, a._f = t, a._strict = i, Nz(a);
}
function Vt(e, t, n, i) {
  return DS(e, t, n, i, !1);
}
var Bz = _n(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Vt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e < this ? this : e : Vc();
  }
), zz = _n(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Vt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e > this ? this : e : Vc();
  }
);
function TS(e, t) {
  var n, i;
  if (t.length === 1 && Tn(t[0]) && (t = t[0]), !t.length)
    return Vt();
  for (n = t[0], i = 1; i < t.length; ++i)
    (!t[i].isValid() || t[i][e](n)) && (n = t[i]);
  return n;
}
function Vz() {
  var e = [].slice.call(arguments, 0);
  return TS("isBefore", e);
}
function $z() {
  var e = [].slice.call(arguments, 0);
  return TS("isAfter", e);
}
var Hz = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, Go = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function Yz(e) {
  var t, n = !1, i, r = Go.length;
  for (t in e)
    if (xt(e, t) && !(Jt.call(Go, t) !== -1 && (e[t] == null || !isNaN(e[t]))))
      return !1;
  for (i = 0; i < r; ++i)
    if (e[Go[i]]) {
      if (n)
        return !1;
      parseFloat(e[Go[i]]) !== vt(e[Go[i]]) && (n = !0);
    }
  return !0;
}
function Wz() {
  return this._isValid;
}
function Uz() {
  return In(NaN);
}
function Xc(e) {
  var t = Mp(e), n = t.year || 0, i = t.quarter || 0, r = t.month || 0, a = t.week || t.isoWeek || 0, o = t.day || 0, s = t.hour || 0, l = t.minute || 0, u = t.second || 0, c = t.millisecond || 0;
  this._isValid = Yz(t), this._milliseconds = +c + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  s * 1e3 * 60 * 60, this._days = +o + a * 7, this._months = +r + i * 3 + n * 12, this._data = {}, this._locale = Ai(), this._bubble();
}
function vu(e) {
  return e instanceof Xc;
}
function Xf(e) {
  return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e);
}
function Gz(e, t, n) {
  var i = Math.min(e.length, t.length), r = Math.abs(e.length - t.length), a = 0, o;
  for (o = 0; o < i; o++)
    vt(e[o]) !== vt(t[o]) && a++;
  return a + r;
}
function kS(e, t) {
  j(e, 0, 0, function() {
    var n = this.utcOffset(), i = "+";
    return n < 0 && (n = -n, i = "-"), i + Jn(~~(n / 60), 2) + t + Jn(~~n % 60, 2);
  });
}
kS("Z", ":");
kS("ZZ", "");
Y("Z", Uc);
Y("ZZ", Uc);
Et(["Z", "ZZ"], function(e, t, n) {
  n._useUTC = !0, n._tzm = Np(Uc, e);
});
var jz = /([\+\-]|\d\d)/gi;
function Np(e, t) {
  var n = (t || "").match(e), i, r, a;
  return n === null ? null : (i = n[n.length - 1] || [], r = (i + "").match(jz) || ["-", 0, 0], a = +(r[1] * 60) + vt(r[2]), a === 0 ? 0 : r[0] === "+" ? a : -a);
}
function Fp(e, t) {
  var n, i;
  return t._isUTC ? (n = t.clone(), i = (kn(e) || Ks(e) ? e.valueOf() : Vt(e).valueOf()) - n.valueOf(), n._d.setTime(n._d.valueOf() + i), z.updateOffset(n, !1), n) : Vt(e).local();
}
function qf(e) {
  return -Math.round(e._d.getTimezoneOffset());
}
z.updateOffset = function() {
};
function Xz(e, t, n) {
  var i = this._offset || 0, r;
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    if (typeof e == "string") {
      if (e = Np(Uc, e), e === null)
        return this;
    } else Math.abs(e) < 16 && !n && (e = e * 60);
    return !this._isUTC && t && (r = qf(this)), this._offset = e, this._isUTC = !0, r != null && this.add(r, "m"), i !== e && (!t || this._changeInProgress ? AS(
      this,
      In(e - i, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, z.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? i : qf(this);
}
function qz(e, t) {
  return e != null ? (typeof e != "string" && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset();
}
function Zz(e) {
  return this.utcOffset(0, e);
}
function Kz(e) {
  return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(qf(this), "m")), this;
}
function Qz() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var e = Np(_B, this._i);
    e != null ? this.utcOffset(e) : this.utcOffset(0, !0);
  }
  return this;
}
function Jz(e) {
  return this.isValid() ? (e = e ? Vt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 === 0) : !1;
}
function tV() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function eV() {
  if (!Fe(this._isDSTShifted))
    return this._isDSTShifted;
  var e = {}, t;
  return xp(e, this), e = MS(e), e._a ? (t = e._isUTC ? ei(e._a) : Vt(e._a), this._isDSTShifted = this.isValid() && Gz(e._a, t.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function nV() {
  return this.isValid() ? !this._isUTC : !1;
}
function iV() {
  return this.isValid() ? this._isUTC : !1;
}
function CS() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var rV = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, aV = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function In(e, t) {
  var n = e, i = null, r, a, o;
  return vu(e) ? n = {
    ms: e._milliseconds,
    d: e._days,
    M: e._months
  } : ki(e) || !isNaN(+e) ? (n = {}, t ? n[t] = +e : n.milliseconds = +e) : (i = rV.exec(e)) ? (r = i[1] === "-" ? -1 : 1, n = {
    y: 0,
    d: vt(i[Wn]) * r,
    h: vt(i[le]) * r,
    m: vt(i[Sn]) * r,
    s: vt(i[yi]) * r,
    ms: vt(Xf(i[Gr] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (i = aV.exec(e)) ? (r = i[1] === "-" ? -1 : 1, n = {
    y: Ir(i[2], r),
    M: Ir(i[3], r),
    w: Ir(i[4], r),
    d: Ir(i[5], r),
    h: Ir(i[6], r),
    m: Ir(i[7], r),
    s: Ir(i[8], r)
  }) : n == null ? n = {} : typeof n == "object" && ("from" in n || "to" in n) && (o = oV(
    Vt(n.from),
    Vt(n.to)
  ), n = {}, n.ms = o.milliseconds, n.M = o.months), a = new Xc(n), vu(e) && xt(e, "_locale") && (a._locale = e._locale), vu(e) && xt(e, "_isValid") && (a._isValid = e._isValid), a;
}
In.fn = Xc.prototype;
In.invalid = Uz;
function Ir(e, t) {
  var n = e && parseFloat(e.replace(",", "."));
  return (isNaN(n) ? 0 : n) * t;
}
function Ry(e, t) {
  var n = {};
  return n.months = t.month() - e.month() + (t.year() - e.year()) * 12, e.clone().add(n.months, "M").isAfter(t) && --n.months, n.milliseconds = +t - +e.clone().add(n.months, "M"), n;
}
function oV(e, t) {
  var n;
  return e.isValid() && t.isValid() ? (t = Fp(t, e), e.isBefore(t) ? n = Ry(e, t) : (n = Ry(t, e), n.milliseconds = -n.milliseconds, n.months = -n.months), n) : { milliseconds: 0, months: 0 };
}
function PS(e, t) {
  return function(n, i) {
    var r, a;
    return i !== null && !isNaN(+i) && (rS(
      t,
      "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), a = n, n = i, i = a), r = In(n, i), AS(this, r, e), this;
  };
}
function AS(e, t, n, i) {
  var r = t._milliseconds, a = Xf(t._days), o = Xf(t._months);
  e.isValid() && (i = i ?? !0, o && vS(e, $s(e, "Month") + o * n), a && hS(e, "Date", $s(e, "Date") + a * n), r && e._d.setTime(e._d.valueOf() + r * n), i && z.updateOffset(e, a || o));
}
var sV = PS(1, "add"), lV = PS(-1, "subtract");
function ES(e) {
  return typeof e == "string" || e instanceof String;
}
function uV(e) {
  return kn(e) || Ks(e) || ES(e) || ki(e) || hV(e) || cV(e) || e === null || e === void 0;
}
function cV(e) {
  var t = ia(e) && !yp(e), n = !1, i = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, a, o = i.length;
  for (r = 0; r < o; r += 1)
    a = i[r], n = n || xt(e, a);
  return t && n;
}
function hV(e) {
  var t = Tn(e), n = !1;
  return t && (n = e.filter(function(i) {
    return !ki(i) && ES(e);
  }).length === 0), t && n;
}
function dV(e) {
  var t = ia(e) && !yp(e), n = !1, i = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, a;
  for (r = 0; r < i.length; r += 1)
    a = i[r], n = n || xt(e, a);
  return t && n;
}
function fV(e, t) {
  var n = e.diff(t, "days", !0);
  return n < -6 ? "sameElse" : n < -1 ? "lastWeek" : n < 0 ? "lastDay" : n < 1 ? "sameDay" : n < 2 ? "nextDay" : n < 7 ? "nextWeek" : "sameElse";
}
function vV(e, t) {
  arguments.length === 1 && (arguments[0] ? uV(arguments[0]) ? (e = arguments[0], t = void 0) : dV(arguments[0]) && (t = arguments[0], e = void 0) : (e = void 0, t = void 0));
  var n = e || Vt(), i = Fp(n, this).startOf("day"), r = z.calendarFormat(this, i) || "sameElse", a = t && (ni(t[r]) ? t[r].call(this, n) : t[r]);
  return this.format(
    a || this.localeData().calendar(r, this, Vt(n))
  );
}
function pV() {
  return new Qs(this);
}
function gV(e, t) {
  var n = kn(e) ? e : Vt(e);
  return this.isValid() && n.isValid() ? (t = mn(t) || "millisecond", t === "millisecond" ? this.valueOf() > n.valueOf() : n.valueOf() < this.clone().startOf(t).valueOf()) : !1;
}
function _V(e, t) {
  var n = kn(e) ? e : Vt(e);
  return this.isValid() && n.isValid() ? (t = mn(t) || "millisecond", t === "millisecond" ? this.valueOf() < n.valueOf() : this.clone().endOf(t).valueOf() < n.valueOf()) : !1;
}
function mV(e, t, n, i) {
  var r = kn(e) ? e : Vt(e), a = kn(t) ? t : Vt(t);
  return this.isValid() && r.isValid() && a.isValid() ? (i = i || "()", (i[0] === "(" ? this.isAfter(r, n) : !this.isBefore(r, n)) && (i[1] === ")" ? this.isBefore(a, n) : !this.isAfter(a, n))) : !1;
}
function yV(e, t) {
  var n = kn(e) ? e : Vt(e), i;
  return this.isValid() && n.isValid() ? (t = mn(t) || "millisecond", t === "millisecond" ? this.valueOf() === n.valueOf() : (i = n.valueOf(), this.clone().startOf(t).valueOf() <= i && i <= this.clone().endOf(t).valueOf())) : !1;
}
function bV(e, t) {
  return this.isSame(e, t) || this.isAfter(e, t);
}
function xV(e, t) {
  return this.isSame(e, t) || this.isBefore(e, t);
}
function wV(e, t, n) {
  var i, r, a;
  if (!this.isValid())
    return NaN;
  if (i = Fp(e, this), !i.isValid())
    return NaN;
  switch (r = (i.utcOffset() - this.utcOffset()) * 6e4, t = mn(t), t) {
    case "year":
      a = pu(this, i) / 12;
      break;
    case "month":
      a = pu(this, i);
      break;
    case "quarter":
      a = pu(this, i) / 3;
      break;
    case "second":
      a = (this - i) / 1e3;
      break;
    // 1000
    case "minute":
      a = (this - i) / 6e4;
      break;
    // 1000 * 60
    case "hour":
      a = (this - i) / 36e5;
      break;
    // 1000 * 60 * 60
    case "day":
      a = (this - i - r) / 864e5;
      break;
    // 1000 * 60 * 60 * 24, negate dst
    case "week":
      a = (this - i - r) / 6048e5;
      break;
    // 1000 * 60 * 60 * 24 * 7, negate dst
    default:
      a = this - i;
  }
  return n ? a : dn(a);
}
function pu(e, t) {
  if (e.date() < t.date())
    return -pu(t, e);
  var n = (t.year() - e.year()) * 12 + (t.month() - e.month()), i = e.clone().add(n, "months"), r, a;
  return t - i < 0 ? (r = e.clone().add(n - 1, "months"), a = (t - i) / (i - r)) : (r = e.clone().add(n + 1, "months"), a = (t - i) / (r - i)), -(n + a) || 0;
}
z.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
z.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function SV() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function MV(e) {
  if (!this.isValid())
    return null;
  var t = e !== !0, n = t ? this.clone().utc() : this;
  return n.year() < 0 || n.year() > 9999 ? fu(
    n,
    t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : ni(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", fu(n, "Z")) : fu(
    n,
    t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function DV() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var e = "moment", t = "", n, i, r, a;
  return this.isLocal() || (e = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", t = "Z"), n = "[" + e + '("]', i = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", a = t + '[")]', this.format(n + i + r + a);
}
function TV(e) {
  e || (e = this.isUtc() ? z.defaultFormatUtc : z.defaultFormat);
  var t = fu(this, e);
  return this.localeData().postformat(t);
}
function kV(e, t) {
  return this.isValid() && (kn(e) && e.isValid() || Vt(e).isValid()) ? In({ to: this, from: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function CV(e) {
  return this.from(Vt(), e);
}
function PV(e, t) {
  return this.isValid() && (kn(e) && e.isValid() || Vt(e).isValid()) ? In({ from: this, to: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function AV(e) {
  return this.to(Vt(), e);
}
function LS(e) {
  var t;
  return e === void 0 ? this._locale._abbr : (t = Ai(e), t != null && (this._locale = t), this);
}
var OS = _n(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(e) {
    return e === void 0 ? this.localeData() : this.locale(e);
  }
);
function IS() {
  return this._locale;
}
var cc = 1e3, Qa = 60 * cc, hc = 60 * Qa, RS = (365 * 400 + 97) * 24 * hc;
function Ja(e, t) {
  return (e % t + t) % t;
}
function NS(e, t, n) {
  return e < 100 && e >= 0 ? new Date(e + 400, t, n) - RS : new Date(e, t, n).valueOf();
}
function FS(e, t, n) {
  return e < 100 && e >= 0 ? Date.UTC(e + 400, t, n) - RS : Date.UTC(e, t, n);
}
function EV(e) {
  var t, n;
  if (e = mn(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (n = this._isUTC ? FS : NS, e) {
    case "year":
      t = n(this.year(), 0, 1);
      break;
    case "quarter":
      t = n(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      t = n(this.year(), this.month(), 1);
      break;
    case "week":
      t = n(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      t = n(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      t = n(this.year(), this.month(), this.date());
      break;
    case "hour":
      t = this._d.valueOf(), t -= Ja(
        t + (this._isUTC ? 0 : this.utcOffset() * Qa),
        hc
      );
      break;
    case "minute":
      t = this._d.valueOf(), t -= Ja(t, Qa);
      break;
    case "second":
      t = this._d.valueOf(), t -= Ja(t, cc);
      break;
  }
  return this._d.setTime(t), z.updateOffset(this, !0), this;
}
function LV(e) {
  var t, n;
  if (e = mn(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (n = this._isUTC ? FS : NS, e) {
    case "year":
      t = n(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      t = n(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      t = n(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      t = n(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      t = n(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      t = n(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      t = this._d.valueOf(), t += hc - Ja(
        t + (this._isUTC ? 0 : this.utcOffset() * Qa),
        hc
      ) - 1;
      break;
    case "minute":
      t = this._d.valueOf(), t += Qa - Ja(t, Qa) - 1;
      break;
    case "second":
      t = this._d.valueOf(), t += cc - Ja(t, cc) - 1;
      break;
  }
  return this._d.setTime(t), z.updateOffset(this, !0), this;
}
function OV() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function IV() {
  return Math.floor(this.valueOf() / 1e3);
}
function RV() {
  return new Date(this.valueOf());
}
function NV() {
  var e = this;
  return [
    e.year(),
    e.month(),
    e.date(),
    e.hour(),
    e.minute(),
    e.second(),
    e.millisecond()
  ];
}
function FV() {
  var e = this;
  return {
    years: e.year(),
    months: e.month(),
    date: e.date(),
    hours: e.hours(),
    minutes: e.minutes(),
    seconds: e.seconds(),
    milliseconds: e.milliseconds()
  };
}
function BV() {
  return this.isValid() ? this.toISOString() : null;
}
function zV() {
  return bp(this);
}
function VV() {
  return Ui({}, rt(this));
}
function $V() {
  return rt(this).overflow;
}
function HV() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
j("N", 0, 0, "eraAbbr");
j("NN", 0, 0, "eraAbbr");
j("NNN", 0, 0, "eraAbbr");
j("NNNN", 0, 0, "eraName");
j("NNNNN", 0, 0, "eraNarrow");
j("y", ["y", 1], "yo", "eraYear");
j("y", ["yy", 2], 0, "eraYear");
j("y", ["yyy", 3], 0, "eraYear");
j("y", ["yyyy", 4], 0, "eraYear");
Y("N", Bp);
Y("NN", Bp);
Y("NNN", Bp);
Y("NNNN", JV);
Y("NNNNN", t6);
Et(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(e, t, n, i) {
    var r = n._locale.erasParse(e, i, n._strict);
    r ? rt(n).era = r : rt(n).invalidEra = e;
  }
);
Y("y", go);
Y("yy", go);
Y("yyy", go);
Y("yyyy", go);
Y("yo", e6);
Et(["y", "yy", "yyy", "yyyy"], xe);
Et(["yo"], function(e, t, n, i) {
  var r;
  n._locale._eraYearOrdinalRegex && (r = e.match(n._locale._eraYearOrdinalRegex)), n._locale.eraYearOrdinalParse ? t[xe] = n._locale.eraYearOrdinalParse(e, r) : t[xe] = parseInt(e, 10);
});
function YV(e, t) {
  var n, i, r, a = this._eras || Ai("en")._eras;
  for (n = 0, i = a.length; n < i; ++n) {
    switch (typeof a[n].since) {
      case "string":
        r = z(a[n].since).startOf("day"), a[n].since = r.valueOf();
        break;
    }
    switch (typeof a[n].until) {
      case "undefined":
        a[n].until = 1 / 0;
        break;
      case "string":
        r = z(a[n].until).startOf("day").valueOf(), a[n].until = r.valueOf();
        break;
    }
  }
  return a;
}
function WV(e, t, n) {
  var i, r, a = this.eras(), o, s, l;
  for (e = e.toUpperCase(), i = 0, r = a.length; i < r; ++i)
    if (o = a[i].name.toUpperCase(), s = a[i].abbr.toUpperCase(), l = a[i].narrow.toUpperCase(), n)
      switch (t) {
        case "N":
        case "NN":
        case "NNN":
          if (s === e)
            return a[i];
          break;
        case "NNNN":
          if (o === e)
            return a[i];
          break;
        case "NNNNN":
          if (l === e)
            return a[i];
          break;
      }
    else if ([o, s, l].indexOf(e) >= 0)
      return a[i];
}
function UV(e, t) {
  var n = e.since <= e.until ? 1 : -1;
  return t === void 0 ? z(e.since).year() : z(e.since).year() + (t - e.offset) * n;
}
function GV() {
  var e, t, n, i = this.localeData().eras();
  for (e = 0, t = i.length; e < t; ++e)
    if (n = this.clone().startOf("day").valueOf(), i[e].since <= n && n <= i[e].until || i[e].until <= n && n <= i[e].since)
      return i[e].name;
  return "";
}
function jV() {
  var e, t, n, i = this.localeData().eras();
  for (e = 0, t = i.length; e < t; ++e)
    if (n = this.clone().startOf("day").valueOf(), i[e].since <= n && n <= i[e].until || i[e].until <= n && n <= i[e].since)
      return i[e].narrow;
  return "";
}
function XV() {
  var e, t, n, i = this.localeData().eras();
  for (e = 0, t = i.length; e < t; ++e)
    if (n = this.clone().startOf("day").valueOf(), i[e].since <= n && n <= i[e].until || i[e].until <= n && n <= i[e].since)
      return i[e].abbr;
  return "";
}
function qV() {
  var e, t, n, i, r = this.localeData().eras();
  for (e = 0, t = r.length; e < t; ++e)
    if (n = r[e].since <= r[e].until ? 1 : -1, i = this.clone().startOf("day").valueOf(), r[e].since <= i && i <= r[e].until || r[e].until <= i && i <= r[e].since)
      return (this.year() - z(r[e].since).year()) * n + r[e].offset;
  return this.year();
}
function ZV(e) {
  return xt(this, "_erasNameRegex") || zp.call(this), e ? this._erasNameRegex : this._erasRegex;
}
function KV(e) {
  return xt(this, "_erasAbbrRegex") || zp.call(this), e ? this._erasAbbrRegex : this._erasRegex;
}
function QV(e) {
  return xt(this, "_erasNarrowRegex") || zp.call(this), e ? this._erasNarrowRegex : this._erasRegex;
}
function Bp(e, t) {
  return t.erasAbbrRegex(e);
}
function JV(e, t) {
  return t.erasNameRegex(e);
}
function t6(e, t) {
  return t.erasNarrowRegex(e);
}
function e6(e, t) {
  return t._eraYearOrdinalRegex || go;
}
function zp() {
  var e = [], t = [], n = [], i = [], r, a, o, s, l, u = this.eras();
  for (r = 0, a = u.length; r < a; ++r)
    o = wi(u[r].name), s = wi(u[r].abbr), l = wi(u[r].narrow), t.push(o), e.push(s), n.push(l), i.push(o), i.push(s), i.push(l);
  this._erasRegex = new RegExp("^(" + i.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + n.join("|") + ")",
    "i"
  );
}
j(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
j(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function qc(e, t) {
  j(0, [e, e.length], 0, t);
}
qc("gggg", "weekYear");
qc("ggggg", "weekYear");
qc("GGGG", "isoWeekYear");
qc("GGGGG", "isoWeekYear");
Y("G", Wc);
Y("g", Wc);
Y("GG", $t, Je);
Y("gg", $t, Je);
Y("GGGG", Tp, Dp);
Y("gggg", Tp, Dp);
Y("GGGGG", Yc, $c);
Y("ggggg", Yc, $c);
tl(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(e, t, n, i) {
    t[i.substr(0, 2)] = vt(e);
  }
);
tl(["gg", "GG"], function(e, t, n, i) {
  t[i] = z.parseTwoDigitYear(e);
});
function n6(e) {
  return BS.call(
    this,
    e,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function i6(e) {
  return BS.call(
    this,
    e,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function r6() {
  return Si(this.year(), 1, 4);
}
function a6() {
  return Si(this.isoWeekYear(), 1, 4);
}
function o6() {
  var e = this.localeData()._week;
  return Si(this.year(), e.dow, e.doy);
}
function s6() {
  var e = this.localeData()._week;
  return Si(this.weekYear(), e.dow, e.doy);
}
function BS(e, t, n, i, r) {
  var a;
  return e == null ? Ys(this, i, r).year : (a = Si(e, i, r), t > a && (t = a), l6.call(this, e, t, n, i, r));
}
function l6(e, t, n, i, r) {
  var a = _S(e, t, n, i, r), o = Hs(a.year, 0, a.dayOfYear);
  return this.year(o.getUTCFullYear()), this.month(o.getUTCMonth()), this.date(o.getUTCDate()), this;
}
j("Q", 0, "Qo", "quarter");
Y("Q", oS);
Et("Q", function(e, t) {
  t[mi] = (vt(e) - 1) * 3;
});
function u6(e) {
  return e == null ? Math.ceil((this.month() + 1) / 3) : this.month((e - 1) * 3 + this.month() % 3);
}
j("D", ["DD", 2], "Do", "date");
Y("D", $t, _o);
Y("DD", $t, Je);
Y("Do", function(e, t) {
  return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient;
});
Et(["D", "DD"], Wn);
Et("Do", function(e, t) {
  t[Wn] = vt(e.match($t)[0]);
});
var zS = mo("Date", !0);
j("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
Y("DDD", Hc);
Y("DDDD", sS);
Et(["DDD", "DDDD"], function(e, t, n) {
  n._dayOfYear = vt(e);
});
function c6(e) {
  var t = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return e == null ? t : this.add(e - t, "d");
}
j("m", ["mm", 2], 0, "minute");
Y("m", $t, kp);
Y("mm", $t, Je);
Et(["m", "mm"], Sn);
var h6 = mo("Minutes", !1);
j("s", ["ss", 2], 0, "second");
Y("s", $t, kp);
Y("ss", $t, Je);
Et(["s", "ss"], yi);
var d6 = mo("Seconds", !1);
j("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
j(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
j(0, ["SSS", 3], 0, "millisecond");
j(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
j(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
j(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
j(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
j(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
j(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
Y("S", Hc, oS);
Y("SS", Hc, Je);
Y("SSS", Hc, sS);
var Gi, VS;
for (Gi = "SSSS"; Gi.length <= 9; Gi += "S")
  Y(Gi, go);
function f6(e, t) {
  t[Gr] = vt(("0." + e) * 1e3);
}
for (Gi = "S"; Gi.length <= 9; Gi += "S")
  Et(Gi, f6);
VS = mo("Milliseconds", !1);
j("z", 0, 0, "zoneAbbr");
j("zz", 0, 0, "zoneName");
function v6() {
  return this._isUTC ? "UTC" : "";
}
function p6() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var B = Qs.prototype;
B.add = sV;
B.calendar = vV;
B.clone = pV;
B.diff = wV;
B.endOf = LV;
B.format = TV;
B.from = kV;
B.fromNow = CV;
B.to = PV;
B.toNow = AV;
B.get = DB;
B.invalidAt = $V;
B.isAfter = gV;
B.isBefore = _V;
B.isBetween = mV;
B.isSame = yV;
B.isSameOrAfter = bV;
B.isSameOrBefore = xV;
B.isValid = zV;
B.lang = OS;
B.locale = LS;
B.localeData = IS;
B.max = zz;
B.min = Bz;
B.parsingFlags = VV;
B.set = TB;
B.startOf = EV;
B.subtract = lV;
B.toArray = NV;
B.toObject = FV;
B.toDate = RV;
B.toISOString = MV;
B.inspect = DV;
typeof Symbol < "u" && Symbol.for != null && (B[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
B.toJSON = BV;
B.toString = SV;
B.unix = IV;
B.valueOf = OV;
B.creationData = HV;
B.eraName = GV;
B.eraNarrow = jV;
B.eraAbbr = XV;
B.eraYear = qV;
B.year = cS;
B.isLeapYear = MB;
B.weekYear = n6;
B.isoWeekYear = i6;
B.quarter = B.quarters = u6;
B.month = pS;
B.daysInMonth = RB;
B.week = B.weeks = YB;
B.isoWeek = B.isoWeeks = WB;
B.weeksInYear = o6;
B.weeksInWeekYear = s6;
B.isoWeeksInYear = r6;
B.isoWeeksInISOWeekYear = a6;
B.date = zS;
B.day = B.days = iz;
B.weekday = rz;
B.isoWeekday = az;
B.dayOfYear = c6;
B.hour = B.hours = dz;
B.minute = B.minutes = h6;
B.second = B.seconds = d6;
B.millisecond = B.milliseconds = VS;
B.utcOffset = Xz;
B.utc = Zz;
B.local = Kz;
B.parseZone = Qz;
B.hasAlignedHourOffset = Jz;
B.isDST = tV;
B.isLocal = nV;
B.isUtcOffset = iV;
B.isUtc = CS;
B.isUTC = CS;
B.zoneAbbr = v6;
B.zoneName = p6;
B.dates = _n(
  "dates accessor is deprecated. Use date instead.",
  zS
);
B.months = _n(
  "months accessor is deprecated. Use month instead",
  pS
);
B.years = _n(
  "years accessor is deprecated. Use year instead",
  cS
);
B.zone = _n(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  qz
);
B.isDSTShifted = _n(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  eV
);
function g6(e) {
  return Vt(e * 1e3);
}
function _6() {
  return Vt.apply(null, arguments).parseZone();
}
function $S(e) {
  return e;
}
var wt = wp.prototype;
wt.calendar = nB;
wt.longDateFormat = oB;
wt.invalidDate = lB;
wt.ordinal = hB;
wt.preparse = $S;
wt.postformat = $S;
wt.relativeTime = fB;
wt.pastFuture = vB;
wt.set = tB;
wt.eras = YV;
wt.erasParse = WV;
wt.erasConvertYear = UV;
wt.erasAbbrRegex = KV;
wt.erasNameRegex = ZV;
wt.erasNarrowRegex = QV;
wt.months = EB;
wt.monthsShort = LB;
wt.monthsParse = IB;
wt.monthsRegex = FB;
wt.monthsShortRegex = NB;
wt.week = zB;
wt.firstDayOfYear = HB;
wt.firstDayOfWeek = $B;
wt.weekdays = QB;
wt.weekdaysMin = tz;
wt.weekdaysShort = JB;
wt.weekdaysParse = nz;
wt.weekdaysRegex = oz;
wt.weekdaysShortRegex = sz;
wt.weekdaysMinRegex = lz;
wt.isPM = cz;
wt.meridiem = fz;
function dc(e, t, n, i) {
  var r = Ai(), a = ei().set(i, t);
  return r[n](a, e);
}
function HS(e, t, n) {
  if (ki(e) && (t = e, e = void 0), e = e || "", t != null)
    return dc(e, t, n, "month");
  var i, r = [];
  for (i = 0; i < 12; i++)
    r[i] = dc(e, i, n, "month");
  return r;
}
function Vp(e, t, n, i) {
  typeof e == "boolean" ? (ki(t) && (n = t, t = void 0), t = t || "") : (t = e, n = t, e = !1, ki(t) && (n = t, t = void 0), t = t || "");
  var r = Ai(), a = e ? r._week.dow : 0, o, s = [];
  if (n != null)
    return dc(t, (n + a) % 7, i, "day");
  for (o = 0; o < 7; o++)
    s[o] = dc(t, (o + a) % 7, i, "day");
  return s;
}
function m6(e, t) {
  return HS(e, t, "months");
}
function y6(e, t) {
  return HS(e, t, "monthsShort");
}
function b6(e, t, n) {
  return Vp(e, t, n, "weekdays");
}
function x6(e, t, n) {
  return Vp(e, t, n, "weekdaysShort");
}
function w6(e, t, n) {
  return Vp(e, t, n, "weekdaysMin");
}
Qi("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(e) {
    var t = e % 10, n = vt(e % 100 / 10) === 1 ? "th" : t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th";
    return e + n;
  }
});
z.lang = _n(
  "moment.lang is deprecated. Use moment.locale instead.",
  Qi
);
z.langData = _n(
  "moment.langData is deprecated. Use moment.localeData instead.",
  Ai
);
var li = Math.abs;
function S6() {
  var e = this._data;
  return this._milliseconds = li(this._milliseconds), this._days = li(this._days), this._months = li(this._months), e.milliseconds = li(e.milliseconds), e.seconds = li(e.seconds), e.minutes = li(e.minutes), e.hours = li(e.hours), e.months = li(e.months), e.years = li(e.years), this;
}
function YS(e, t, n, i) {
  var r = In(t, n);
  return e._milliseconds += i * r._milliseconds, e._days += i * r._days, e._months += i * r._months, e._bubble();
}
function M6(e, t) {
  return YS(this, e, t, 1);
}
function D6(e, t) {
  return YS(this, e, t, -1);
}
function Ny(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e);
}
function T6() {
  var e = this._milliseconds, t = this._days, n = this._months, i = this._data, r, a, o, s, l;
  return e >= 0 && t >= 0 && n >= 0 || e <= 0 && t <= 0 && n <= 0 || (e += Ny(Zf(n) + t) * 864e5, t = 0, n = 0), i.milliseconds = e % 1e3, r = dn(e / 1e3), i.seconds = r % 60, a = dn(r / 60), i.minutes = a % 60, o = dn(a / 60), i.hours = o % 24, t += dn(o / 24), l = dn(WS(t)), n += l, t -= Ny(Zf(l)), s = dn(n / 12), n %= 12, i.days = t, i.months = n, i.years = s, this;
}
function WS(e) {
  return e * 4800 / 146097;
}
function Zf(e) {
  return e * 146097 / 4800;
}
function k6(e) {
  if (!this.isValid())
    return NaN;
  var t, n, i = this._milliseconds;
  if (e = mn(e), e === "month" || e === "quarter" || e === "year")
    switch (t = this._days + i / 864e5, n = this._months + WS(t), e) {
      case "month":
        return n;
      case "quarter":
        return n / 3;
      case "year":
        return n / 12;
    }
  else
    switch (t = this._days + Math.round(Zf(this._months)), e) {
      case "week":
        return t / 7 + i / 6048e5;
      case "day":
        return t + i / 864e5;
      case "hour":
        return t * 24 + i / 36e5;
      case "minute":
        return t * 1440 + i / 6e4;
      case "second":
        return t * 86400 + i / 1e3;
      // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(t * 864e5) + i;
      default:
        throw new Error("Unknown unit " + e);
    }
}
function Ei(e) {
  return function() {
    return this.as(e);
  };
}
var US = Ei("ms"), C6 = Ei("s"), P6 = Ei("m"), A6 = Ei("h"), E6 = Ei("d"), L6 = Ei("w"), O6 = Ei("M"), I6 = Ei("Q"), R6 = Ei("y"), N6 = US;
function F6() {
  return In(this);
}
function B6(e) {
  return e = mn(e), this.isValid() ? this[e + "s"]() : NaN;
}
function fa(e) {
  return function() {
    return this.isValid() ? this._data[e] : NaN;
  };
}
var z6 = fa("milliseconds"), V6 = fa("seconds"), $6 = fa("minutes"), H6 = fa("hours"), Y6 = fa("days"), W6 = fa("months"), U6 = fa("years");
function G6() {
  return dn(this.days() / 7);
}
var di = Math.round, Wa = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function j6(e, t, n, i, r) {
  return r.relativeTime(t || 1, !!n, e, i);
}
function X6(e, t, n, i) {
  var r = In(e).abs(), a = di(r.as("s")), o = di(r.as("m")), s = di(r.as("h")), l = di(r.as("d")), u = di(r.as("M")), c = di(r.as("w")), h = di(r.as("y")), d = a <= n.ss && ["s", a] || a < n.s && ["ss", a] || o <= 1 && ["m"] || o < n.m && ["mm", o] || s <= 1 && ["h"] || s < n.h && ["hh", s] || l <= 1 && ["d"] || l < n.d && ["dd", l];
  return n.w != null && (d = d || c <= 1 && ["w"] || c < n.w && ["ww", c]), d = d || u <= 1 && ["M"] || u < n.M && ["MM", u] || h <= 1 && ["y"] || ["yy", h], d[2] = t, d[3] = +e > 0, d[4] = i, j6.apply(null, d);
}
function q6(e) {
  return e === void 0 ? di : typeof e == "function" ? (di = e, !0) : !1;
}
function Z6(e, t) {
  return Wa[e] === void 0 ? !1 : t === void 0 ? Wa[e] : (Wa[e] = t, e === "s" && (Wa.ss = t - 1), !0);
}
function K6(e, t) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var n = !1, i = Wa, r, a;
  return typeof e == "object" && (t = e, e = !1), typeof e == "boolean" && (n = e), typeof t == "object" && (i = Object.assign({}, Wa, t), t.s != null && t.ss == null && (i.ss = t.s - 1)), r = this.localeData(), a = X6(this, !n, i, r), n && (a = r.pastFuture(+this, a)), r.postformat(a);
}
var Ed = Math.abs;
function Ra(e) {
  return (e > 0) - (e < 0) || +e;
}
function Zc() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var e = Ed(this._milliseconds) / 1e3, t = Ed(this._days), n = Ed(this._months), i, r, a, o, s = this.asSeconds(), l, u, c, h;
  return s ? (i = dn(e / 60), r = dn(i / 60), e %= 60, i %= 60, a = dn(n / 12), n %= 12, o = e ? e.toFixed(3).replace(/\.?0+$/, "") : "", l = s < 0 ? "-" : "", u = Ra(this._months) !== Ra(s) ? "-" : "", c = Ra(this._days) !== Ra(s) ? "-" : "", h = Ra(this._milliseconds) !== Ra(s) ? "-" : "", l + "P" + (a ? u + a + "Y" : "") + (n ? u + n + "M" : "") + (t ? c + t + "D" : "") + (r || i || e ? "T" : "") + (r ? h + r + "H" : "") + (i ? h + i + "M" : "") + (e ? h + o + "S" : "")) : "P0D";
}
var mt = Xc.prototype;
mt.isValid = Wz;
mt.abs = S6;
mt.add = M6;
mt.subtract = D6;
mt.as = k6;
mt.asMilliseconds = US;
mt.asSeconds = C6;
mt.asMinutes = P6;
mt.asHours = A6;
mt.asDays = E6;
mt.asWeeks = L6;
mt.asMonths = O6;
mt.asQuarters = I6;
mt.asYears = R6;
mt.valueOf = N6;
mt._bubble = T6;
mt.clone = F6;
mt.get = B6;
mt.milliseconds = z6;
mt.seconds = V6;
mt.minutes = $6;
mt.hours = H6;
mt.days = Y6;
mt.weeks = G6;
mt.months = W6;
mt.years = U6;
mt.humanize = K6;
mt.toISOString = Zc;
mt.toString = Zc;
mt.toJSON = Zc;
mt.locale = LS;
mt.localeData = IS;
mt.toIsoString = _n(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  Zc
);
mt.lang = OS;
j("X", 0, 0, "unix");
j("x", 0, 0, "valueOf");
Y("x", Wc);
Y("X", mB);
Et("X", function(e, t, n) {
  n._d = new Date(parseFloat(e) * 1e3);
});
Et("x", function(e, t, n) {
  n._d = new Date(vt(e));
});
z.version = "2.30.1";
Q3(Vt);
z.fn = B;
z.min = Vz;
z.max = $z;
z.now = Hz;
z.utc = ei;
z.unix = g6;
z.months = m6;
z.isDate = Ks;
z.locale = Qi;
z.invalid = Vc;
z.duration = In;
z.isMoment = kn;
z.weekdays = b6;
z.parseZone = _6;
z.localeData = Ai;
z.isDuration = vu;
z.monthsShort = y6;
z.weekdaysMin = w6;
z.defineLocale = Lp;
z.updateLocale = _z;
z.locales = mz;
z.weekdaysShort = x6;
z.normalizeUnits = mn;
z.relativeTimeRounding = q6;
z.relativeTimeThreshold = Z6;
z.calendarFormat = fV;
z.prototype = B;
z.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const Q6 = async (e, t, n) => ({
  total_checkin_init: 1250,
  total_checkin_initiated: 1500,
  total_checkin_init_abandoned: 120,
  total_checkin_started: 1130,
  total_checkin_completed: 980,
  total_checkin_closed: 920,
  total_checkin_unrecovered: 50,
  checkin_by_day: [
    {
      date: "2024-11-24",
      checkin_initiated_count: 500,
      checkin_init_count: 420,
      checkin_started_count: 380,
      checkin_completed_count: 320,
      checkin_closed_count: 310
    },
    {
      date: "2024-11-25",
      checkin_initiated_count: 520,
      checkin_init_count: 450,
      checkin_started_count: 400,
      checkin_completed_count: 350,
      checkin_closed_count: 330
    },
    {
      date: "2024-11-26",
      checkin_initiated_count: 480,
      checkin_init_count: 380,
      checkin_started_count: 350,
      checkin_completed_count: 310,
      checkin_closed_count: 280
    }
  ]
}), J6 = async (e, t, n) => ({
  total_checkin_failed: 150,
  failed_by_step_by_day: [
    {
      date: "2024-11-24",
      steps: [
        { step_name: "get_seatmap", failed_count: 15 },
        { step_name: "save_missing_info", failed_count: 8 }
      ]
    },
    {
      date: "2024-11-25",
      steps: [
        { step_name: "get_seatmap", failed_count: 20 },
        { step_name: "checkin_segments", failed_count: 12 }
      ]
    },
    {
      date: "2024-11-26",
      steps: [
        { step_name: "assign_seat", failed_count: 10 },
        { step_name: "get_seatmap", failed_count: 18 }
      ]
    }
  ],
  unrecovered_by_step: [
    { step_name: "get_seatmap", count: 35 },
    { step_name: "save_missing_info", count: 12 },
    { step_name: "checkin_segments", count: 8 }
  ]
}), t$ = async (e, t, n) => ({
  total_faq_events: 4250,
  total_documents_found: 3890,
  total_airline_information_retrieved: 1520,
  total_booking_info_retrieved: 980,
  total_flight_status_retrieved: 1390,
  faq_by_day: [
    {
      date: "2024-11-24",
      faq_events_count: 850,
      documents_found_count: 780,
      airline_information_retrieved_count: 304,
      booking_info_retrieved_count: 196,
      flight_status_retrieved_count: 280
    },
    {
      date: "2024-11-25",
      faq_events_count: 920,
      documents_found_count: 845,
      airline_information_retrieved_count: 328,
      booking_info_retrieved_count: 212,
      flight_status_retrieved_count: 305
    },
    {
      date: "2024-11-26",
      faq_events_count: 780,
      documents_found_count: 715,
      airline_information_retrieved_count: 280,
      booking_info_retrieved_count: 180,
      flight_status_retrieved_count: 255
    },
    {
      date: "2024-11-27",
      faq_events_count: 890,
      documents_found_count: 820,
      airline_information_retrieved_count: 320,
      booking_info_retrieved_count: 198,
      flight_status_retrieved_count: 302
    },
    {
      date: "2024-11-28",
      faq_events_count: 810,
      documents_found_count: 730,
      airline_information_retrieved_count: 288,
      booking_info_retrieved_count: 194,
      flight_status_retrieved_count: 248
    }
  ]
}), e$ = async (e, t, n) => ({
  total_seller_conversations: 2850,
  total_sell_started: 2340,
  total_sell_get_quote: 1890,
  total_sell_booking_created: 1250,
  total_sell_success: 980,
  total_value_sell_success: 245680.5,
  seller_by_day: [
    {
      date: "2024-11-24",
      seller_conversations: 580,
      sell_started_count: 475,
      sell_get_quote_count: 385,
      sell_booking_created_count: 255,
      sell_success_count: 198,
      daily_value_sell_success: 49520.25
    },
    {
      date: "2024-11-25",
      seller_conversations: 620,
      sell_started_count: 510,
      sell_get_quote_count: 412,
      sell_booking_created_count: 275,
      sell_success_count: 215,
      daily_value_sell_success: 53890
    },
    {
      date: "2024-11-26",
      seller_conversations: 540,
      sell_started_count: 445,
      sell_get_quote_count: 358,
      sell_booking_created_count: 235,
      sell_success_count: 182,
      daily_value_sell_success: 45620.5
    },
    {
      date: "2024-11-27",
      seller_conversations: 590,
      sell_started_count: 485,
      sell_get_quote_count: 392,
      sell_booking_created_count: 260,
      sell_success_count: 202,
      daily_value_sell_success: 50580.75
    },
    {
      date: "2024-11-28",
      seller_conversations: 520,
      sell_started_count: 425,
      sell_get_quote_count: 343,
      sell_booking_created_count: 225,
      sell_success_count: 183,
      daily_value_sell_success: 46069
    }
  ]
}), n$ = async (e, t, n) => ({
  total_sell_failed: 270,
  failed_by_reason_by_day: [
    {
      date: "2024-11-24",
      reasons: [
        { reason: "payment_processing", failed_count: 12 },
        { reason: "seat_selection", failed_count: 8 },
        { reason: "booking_validation", failed_count: 5 }
      ]
    },
    {
      date: "2024-11-25",
      reasons: [
        { reason: "payment_processing", failed_count: 15 },
        { reason: "flight_availability", failed_count: 10 },
        { reason: "timeout", failed_count: 6 }
      ]
    },
    {
      date: "2024-11-26",
      reasons: [
        { reason: "rejected", failed_count: 18 },
        { reason: "passenger_data", failed_count: 9 },
        { reason: "system_error", failed_count: 4 }
      ]
    },
    {
      date: "2024-11-27",
      reasons: [
        { reason: "payment_processing", failed_count: 14 },
        { reason: "seat_selection", failed_count: 11 },
        { reason: "booking_validation", failed_count: 7 }
      ]
    },
    {
      date: "2024-11-28",
      reasons: [
        { reason: "rejected", failed_count: 16 },
        { reason: "flight_availability", failed_count: 8 },
        { reason: "timeout", failed_count: 5 }
      ]
    }
  ]
}), i$ = async (e, t, n) => ({
  total_checkin_initiated: 1850,
  total_record_locator_init: 1620,
  total_record_locator_started: 1450,
  total_record_locator_completed: 1180,
  total_record_locator_closed: 1050,
  total_record_locator_failed: 95,
  total_record_locator_abandoned: 175,
  total_record_locator_init_abandoned: 170,
  total_record_locator_create_payment: 320,
  total_record_locator_create_payment_failed: 28,
  record_locator_by_day: [
    {
      date: "2024-11-24",
      checkin_initiated: 380,
      record_locator_init_count: 335,
      record_locator_started_count: 298,
      record_locator_completed_count: 242,
      record_locator_closed_count: 218,
      record_locator_failed_count: 18,
      record_locator_abandoned_count: 38,
      record_locator_create_payment_count: 65,
      record_locator_create_payment_failed_count: 5
    },
    {
      date: "2024-11-25",
      checkin_initiated: 410,
      record_locator_init_count: 358,
      record_locator_started_count: 320,
      record_locator_completed_count: 265,
      record_locator_closed_count: 238,
      record_locator_failed_count: 22,
      record_locator_abandoned_count: 33,
      record_locator_create_payment_count: 72,
      record_locator_create_payment_failed_count: 6
    },
    {
      date: "2024-11-26",
      checkin_initiated: 345,
      record_locator_init_count: 302,
      record_locator_started_count: 270,
      record_locator_completed_count: 218,
      record_locator_closed_count: 192,
      record_locator_failed_count: 15,
      record_locator_abandoned_count: 37,
      record_locator_create_payment_count: 58,
      record_locator_create_payment_failed_count: 5
    },
    {
      date: "2024-11-27",
      checkin_initiated: 385,
      record_locator_init_count: 340,
      record_locator_started_count: 305,
      record_locator_completed_count: 248,
      record_locator_closed_count: 220,
      record_locator_failed_count: 20,
      record_locator_abandoned_count: 37,
      record_locator_create_payment_count: 68,
      record_locator_create_payment_failed_count: 7
    },
    {
      date: "2024-11-28",
      checkin_initiated: 330,
      record_locator_init_count: 285,
      record_locator_started_count: 257,
      record_locator_completed_count: 207,
      record_locator_closed_count: 182,
      record_locator_failed_count: 20,
      record_locator_abandoned_count: 30,
      record_locator_create_payment_count: 57,
      record_locator_create_payment_failed_count: 5
    }
  ]
}), r$ = async (e, t, n) => ({
  total_booking_initiated: 2450,
  total_booking_started: 2180,
  total_payment_initiated: 1520,
  total_not_found: 185,
  total_cancelled: 142,
  total_no_pending_balance: 98,
  total_errors: 65,
  total_payment_success: 1280,
  total_payment_failed: 240,
  booking_manager_by_day: [
    {
      date: "2024-11-24",
      booking_initiated_count: 485,
      booking_started_count: 432,
      payment_initiated_count: 302,
      not_found_count: 38,
      cancelled_count: 28,
      no_pending_balance_count: 19,
      error_count: 12,
      payment_success_count: 255,
      payment_failed_count: 47
    },
    {
      date: "2024-11-25",
      booking_initiated_count: 520,
      booking_started_count: 468,
      payment_initiated_count: 328,
      not_found_count: 42,
      cancelled_count: 32,
      no_pending_balance_count: 22,
      error_count: 15,
      payment_success_count: 278,
      payment_failed_count: 50
    },
    {
      date: "2024-11-26",
      booking_initiated_count: 445,
      booking_started_count: 395,
      payment_initiated_count: 275,
      not_found_count: 32,
      cancelled_count: 25,
      no_pending_balance_count: 17,
      error_count: 11,
      payment_success_count: 232,
      payment_failed_count: 43
    },
    {
      date: "2024-11-27",
      booking_initiated_count: 510,
      booking_started_count: 452,
      payment_initiated_count: 318,
      not_found_count: 38,
      cancelled_count: 30,
      no_pending_balance_count: 21,
      error_count: 14,
      payment_success_count: 268,
      payment_failed_count: 50
    },
    {
      date: "2024-11-28",
      booking_initiated_count: 490,
      booking_started_count: 433,
      payment_initiated_count: 297,
      not_found_count: 35,
      cancelled_count: 27,
      no_pending_balance_count: 19,
      error_count: 13,
      payment_success_count: 247,
      payment_failed_count: 50
    }
  ]
}), a$ = async (e, t, n) => ({
  total_disruption_conversations: 1850,
  total_disruption_initiated: 1620,
  total_voluntary: 890,
  total_involuntary: 520,
  total_accepted: 385,
  total_confirmed: 680,
  total_sell_success: 520,
  total_sell_failed: 85,
  total_finished: 520,
  total_payment_success: 520,
  disruption_by_day: [
    {
      date: "2024-11-24",
      disruption_conversations: 380,
      disruption_initiated_count: 335,
      voluntary_count: 185,
      involuntary_count: 108,
      accepted_count: 80,
      confirmed_count: 142,
      sell_success_count: 108,
      sell_failed_count: 18
    },
    {
      date: "2024-11-25",
      disruption_conversations: 410,
      disruption_initiated_count: 358,
      voluntary_count: 198,
      involuntary_count: 115,
      accepted_count: 85,
      confirmed_count: 152,
      sell_success_count: 115,
      sell_failed_count: 20
    },
    {
      date: "2024-11-26",
      disruption_conversations: 345,
      disruption_initiated_count: 302,
      voluntary_count: 165,
      involuntary_count: 98,
      accepted_count: 72,
      confirmed_count: 128,
      sell_success_count: 98,
      sell_failed_count: 15
    },
    {
      date: "2024-11-27",
      disruption_conversations: 385,
      disruption_initiated_count: 340,
      voluntary_count: 188,
      involuntary_count: 110,
      accepted_count: 82,
      confirmed_count: 145,
      sell_success_count: 110,
      sell_failed_count: 18
    },
    {
      date: "2024-11-28",
      disruption_conversations: 330,
      disruption_initiated_count: 285,
      voluntary_count: 154,
      involuntary_count: 89,
      accepted_count: 66,
      confirmed_count: 113,
      sell_success_count: 89,
      sell_failed_count: 14
    }
  ]
}), GS = async (e, t, n) => ({
  total_surveys_sent: 2450,
  total_responses: 1680,
  response_rate: 68.6,
  nps_score: 42,
  promoters: 890,
  passives: 520,
  detractors: 270,
  nps_by_day: [
    {
      date: "2024-11-24",
      surveys_sent: 490,
      responses: 336,
      promoters: 178,
      passives: 104,
      detractors: 54,
      nps_score: 37
    },
    {
      date: "2024-11-25",
      surveys_sent: 520,
      responses: 358,
      promoters: 192,
      passives: 110,
      detractors: 56,
      nps_score: 38
    },
    {
      date: "2024-11-26",
      surveys_sent: 445,
      responses: 305,
      promoters: 165,
      passives: 95,
      detractors: 45,
      nps_score: 39
    },
    {
      date: "2024-11-27",
      surveys_sent: 510,
      responses: 352,
      promoters: 188,
      passives: 108,
      detractors: 56,
      nps_score: 38
    },
    {
      date: "2024-11-28",
      surveys_sent: 485,
      responses: 329,
      promoters: 167,
      passives: 103,
      detractors: 59,
      nps_score: 33
    }
  ]
}), o$ = async (e, t, n) => ({
  segments_table: [
    {
      departure_airport: "BOG",
      conexion_airport: "None",
      arrival_airport: "MDE",
      segment_init_count: 450,
      segment_started_count: 385,
      segment_completed_count: 342,
      segment_closed_count: 318
    },
    {
      departure_airport: "MDE",
      conexion_airport: "None",
      arrival_airport: "BOG",
      segment_init_count: 420,
      segment_started_count: 365,
      segment_completed_count: 320,
      segment_closed_count: 298
    },
    {
      departure_airport: "BOG",
      conexion_airport: "CTG",
      arrival_airport: "MIA",
      segment_init_count: 280,
      segment_started_count: 245,
      segment_completed_count: 218,
      segment_closed_count: 195
    },
    {
      departure_airport: "MIA",
      conexion_airport: "BOG",
      arrival_airport: "MDE",
      segment_init_count: 195,
      segment_started_count: 172,
      segment_completed_count: 152,
      segment_closed_count: 138
    },
    {
      departure_airport: "CLO",
      conexion_airport: "None",
      arrival_airport: "BOG",
      segment_init_count: 320,
      segment_started_count: 278,
      segment_completed_count: 245,
      segment_closed_count: 225
    },
    {
      departure_airport: "BOG",
      conexion_airport: "None",
      arrival_airport: "CLO",
      segment_init_count: 335,
      segment_started_count: 292,
      segment_completed_count: 258,
      segment_closed_count: 238
    },
    {
      departure_airport: "CTG",
      conexion_airport: "None",
      arrival_airport: "BOG",
      segment_init_count: 185,
      segment_started_count: 162,
      segment_completed_count: 142,
      segment_closed_count: 128
    },
    {
      departure_airport: "BOG",
      conexion_airport: "None",
      arrival_airport: "BOG",
      segment_init_count: 145,
      segment_started_count: 128,
      segment_completed_count: 115,
      segment_closed_count: 105
    }
  ]
}), lt = (e) => e == null ? "0" : new Intl.NumberFormat("en-US").format(e), Fy = (e, t = "USD") => e == null ? "$0.00" : new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: t,
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(e), s$ = { class: "booking-manager-card" }, l$ = { class: "card-header" }, u$ = { class: "header-content" }, c$ = {
  key: 0,
  class: "payment-success-badge"
}, h$ = { class: "badge-value" }, d$ = {
  key: 0,
  class: "loading-state"
}, f$ = {
  key: 1,
  class: "error-state"
}, v$ = { class: "error-content" }, p$ = { class: "error-description" }, g$ = {
  key: 2,
  class: "card-body"
}, _$ = { class: "chart-section" }, m$ = { class: "chart-wrapper" }, y$ = {
  key: 0,
  class: "table-section"
}, b$ = { class: "table-wrapper" }, x$ = { class: "data-table" }, w$ = { class: "table-body" }, S$ = { class: "table-cell font-medium" }, M$ = { class: "table-cell text-center" }, D$ = { class: "table-cell text-center" }, T$ = { class: "percentage-text" }, k$ = { class: "table-cell text-center" }, C$ = { class: "table-cell" }, P$ = { class: "badges-container" }, A$ = { class: "badge badge-success" }, E$ = { class: "badge badge-error" }, L$ = { class: "table-cell" }, O$ = { class: "badges-container" }, I$ = { class: "badge badge-error" }, R$ = { class: "badge badge-warning" }, N$ = { class: "badge badge-yellow" }, F$ = { class: "badge badge-error" }, B$ = {
  key: 1,
  class: "empty-state"
}, z$ = /* @__PURE__ */ Me({
  __name: "BookingManager",
  props: {
    dates: { default: () => [new Date(Date.now() - 720 * 60 * 60 * 1e3), /* @__PURE__ */ new Date()] },
    airline_name: { default: "default_airline" }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt(null), r = pt({
      total_booking_initiated: 0,
      total_booking_started: 0,
      total_payment_initiated: 0,
      total_not_found: 0,
      total_cancelled: 0,
      total_no_pending_balance: 0,
      total_errors: 0,
      total_payment_success: 0,
      total_payment_failed: 0,
      booking_manager_by_day: []
    }), a = ut(() => {
      const u = r.value, c = u.total_booking_initiated || 0, h = u.total_booking_started || 0, d = u.total_payment_initiated || 0, f = u.total_not_found || 0, v = u.total_cancelled || 0, g = u.total_no_pending_balance || 0, p = u.total_errors || 0, _ = u.total_payment_success || 0, m = u.total_payment_failed || 0, y = Math.max(0, c - h), b = Math.max(0, h - d - f - v - g - p), x = (D, T) => {
        const C = T > 0 ? Math.round(D / T * 100) : 0;
        return `${D.toLocaleString()} (${C}%)`;
      }, w = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Payment Initiated" },
        { name: "Not Found" },
        { name: "Cancelled" },
        { name: "No Pending Balance" },
        { name: "Errors" },
        { name: "Payment Success" },
        { name: "Payment Failed" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], M = [];
      return h > 0 && M.push({
        source: "Initiated",
        target: "Started",
        value: h,
        label: x(h, c)
      }), y > 0 && M.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: y,
        label: x(y, c)
      }), d > 0 && M.push({
        source: "Started",
        target: "Payment Initiated",
        value: d,
        label: x(d, h)
      }), f > 0 && M.push({
        source: "Started",
        target: "Not Found",
        value: f,
        label: x(f, h)
      }), v > 0 && M.push({
        source: "Started",
        target: "Cancelled",
        value: v,
        label: x(v, h)
      }), g > 0 && M.push({
        source: "Started",
        target: "No Pending Balance",
        value: g,
        label: x(g, h)
      }), p > 0 && M.push({
        source: "Started",
        target: "Errors",
        value: p,
        label: x(p, h)
      }), b > 0 && M.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: b,
        label: x(b, h)
      }), _ > 0 && M.push({
        source: "Payment Initiated",
        target: "Payment Success",
        value: _,
        label: x(_, d)
      }), m > 0 && M.push({
        source: "Payment Initiated",
        target: "Payment Failed",
        value: m,
        label: x(m, d)
      }), { nodes: w, links: M };
    }), o = {
      Initiated: "#DBEAFE",
      Started: "#93C5FD",
      "Payment Initiated": "#FED7AA",
      "Not Found": "#FECACA",
      Cancelled: "#FED7AA",
      "No Pending Balance": "#FEF08A",
      Errors: "#FCA5A5",
      "Payment Success": "#86EFAC",
      "Payment Failed": "#FCA5A5",
      "Abandoned (Init)": "#FEE2E2",
      "Abandoned (Start)": "#FEE2E2"
    }, s = (u, c) => !c || c === 0 ? "0%" : `${Math.round(u / c * 100)}%`, l = async () => {
      try {
        n.value = !0, i.value = null;
        const [u, c] = t.dates.map((d) => z(d).format("YYYY-MM-DD")), h = await r$(t.airline_name, u, c);
        r.value = h, r.value.booking_manager_by_day && r.value.booking_manager_by_day.sort(
          (d, f) => new Date(d.date).getTime() - new Date(f.date).getTime()
        );
      } catch (u) {
        console.error("Error fetching booking manager metrics:", u), i.value = u.message || "Failed to load booking manager metrics";
      } finally {
        n.value = !1;
      }
    };
    return Cn(l), Pn(
      () => t.dates,
      (u) => {
        u?.[0] && u?.[1] && l();
      },
      { deep: !0 }
    ), (u, c) => (O(), I("article", s$, [
      S("header", l$, [
        S("div", u$, [
          c[1] || (c[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "Booking Manager Metrics"),
            S("p", { class: "card-subtitle" }, "Booking manager workflow tracking and analysis")
          ], -1)),
          n.value ? ct("", !0) : (O(), I("div", c$, [
            c[0] || (c[0] = S("p", { class: "badge-label" }, "Payment Success", -1)),
            S("p", h$, F(G(lt)(r.value.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      n.value ? (O(), I("div", d$, [...c[2] || (c[2] = [
        Kt('<div class="loading-container" data-v-9cadd7ab><div class="chart-flow-loader" data-v-9cadd7ab><div class="flow-line flow-1" data-v-9cadd7ab></div><div class="flow-line flow-2" data-v-9cadd7ab></div><div class="flow-line flow-3" data-v-9cadd7ab></div><div class="flow-line flow-4" data-v-9cadd7ab></div><div class="flow-line flow-5" data-v-9cadd7ab></div></div><p class="loading-text" data-v-9cadd7ab>Loading booking data...</p></div>', 1)
      ])])) : i.value ? (O(), I("div", f$, [
        S("div", v$, [
          c[3] || (c[3] = S("div", { class: "error-icon-wrapper" }, [
            S("svg", {
              class: "error-icon",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
            }, [
              S("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              })
            ])
          ], -1)),
          c[4] || (c[4] = S("p", { class: "error-title" }, "Error loading data", -1)),
          S("p", p$, F(i.value), 1),
          S("button", {
            onClick: l,
            class: "retry-button"
          }, " Retry ")
        ])
      ])) : (O(), I("div", g$, [
        S("section", _$, [
          S("div", m$, [
            Ee(po, {
              data: a.value,
              "node-colors": o,
              height: "500px",
              "node-gap": 15
            }, null, 8, ["data"])
          ])
        ]),
        r.value.booking_manager_by_day && r.value.booking_manager_by_day.length > 0 ? (O(), I("section", y$, [
          c[6] || (c[6] = S("div", { class: "section-header" }, [
            S("h4", { class: "section-title" }, "Daily Overview")
          ], -1)),
          S("div", b$, [
            S("table", x$, [
              c[5] || (c[5] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Initiated"),
                  S("th", { class: "table-header" }, "Started"),
                  S("th", { class: "table-header" }, "Payment Initiated"),
                  S("th", { class: "table-header" }, "Payment Results"),
                  S("th", { class: "table-header" }, "Outcomes")
                ])
              ], -1)),
              S("tbody", w$, [
                (O(!0), I(Ft, null, fe(r.value.booking_manager_by_day, (h) => (O(), I("tr", {
                  key: h.date,
                  class: "table-row"
                }, [
                  S("td", S$, F(G(z)(h.date).format("DD/MM/YYYY")), 1),
                  S("td", M$, F(G(lt)(h.booking_initiated_count)), 1),
                  S("td", D$, [
                    gu(F(G(lt)(h.booking_started_count)) + " ", 1),
                    S("span", T$, " (" + F(s(h.booking_started_count, h.booking_initiated_count)) + ") ", 1)
                  ]),
                  S("td", k$, F(G(lt)(h.payment_initiated_count)), 1),
                  S("td", C$, [
                    S("div", P$, [
                      S("span", A$, " Success: " + F(h.payment_success_count ? G(lt)(h.payment_success_count) : "N/A"), 1),
                      S("span", E$, " Failed: " + F(h.payment_failed_count ? G(lt)(h.payment_failed_count) : "N/A"), 1)
                    ])
                  ]),
                  S("td", L$, [
                    S("div", O$, [
                      S("span", I$, " Not Found: " + F(h.not_found_count ? G(lt)(h.not_found_count) : "N/A"), 1),
                      S("span", R$, " Cancelled: " + F(h.cancelled_count ? G(lt)(h.cancelled_count) : "N/A"), 1),
                      S("span", N$, " No Balance: " + F(h.no_pending_balance_count ? G(lt)(h.no_pending_balance_count) : "N/A"), 1),
                      S("span", F$, " Errors: " + F(h.error_count ? G(lt)(h.error_count) : "N/A"), 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (O(), I("section", B$, [...c[7] || (c[7] = [
          Kt('<div class="empty-state-content" data-v-9cadd7ab><div class="empty-icon-wrapper" data-v-9cadd7ab><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-9cadd7ab><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" data-v-9cadd7ab></path></svg></div><p class="empty-title" data-v-9cadd7ab>No booking manager data available</p><p class="empty-description" data-v-9cadd7ab>No booking manager data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), V$ = /* @__PURE__ */ de(z$, [["__scopeId", "data-v-9cadd7ab"]]), $$ = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: V$
}, Symbol.toStringTag, { value: "Module" })), H$ = { class: "checkin-metrics-card" }, Y$ = {
  key: 0,
  class: "loading-state"
}, W$ = {
  key: 1,
  class: "card-body"
}, U$ = {
  key: 0,
  class: "chart-section"
}, G$ = { class: "chart-wrapper" }, j$ = {
  key: 1,
  class: "table-section"
}, X$ = { class: "table-wrapper" }, q$ = { class: "data-table" }, Z$ = { class: "table-body" }, K$ = { class: "table-cell font-medium" }, Q$ = { class: "table-cell text-center" }, J$ = { class: "table-cell text-center" }, tH = { class: "table-cell text-center" }, eH = { class: "table-cell text-center" }, nH = { class: "table-cell text-center" }, iH = { class: "table-cell text-center" }, rH = { class: "table-cell text-left" }, aH = {
  key: 0,
  class: "failed-steps"
}, oH = { class: "step-name" }, sH = { class: "step-count" }, lH = {
  key: 1,
  class: "empty-cell"
}, uH = {
  key: 2,
  class: "empty-state"
}, cH = {
  __name: "Checkin",
  props: {
    dates: {
      type: Array,
      required: !0
    },
    airline_name: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt([]), r = pt({
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }), a = pt({
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }), o = ut(() => {
      const v = {
        // Main flow progression - from blue to purple to green
        "Checkin Init": "#93C5FD",
        // Blue for started state
        "Booking retrive": "#C7D2FE",
        // Light purple
        "Booking retrive success": "#A5B4FC",
        // Medium purple for success
        "Number of Passengers": "#8B8CF6",
        // Medium purple
        Completed: "#A7F3D0",
        // Light green
        "Closed with BP": "#7BE39E",
        // Green for success
        // Abandoned states - progressive yellow/orange
        "Abandoned (Init)": "#FCA5A5",
        // Light red
        "Abandoned (Started)": "#F87171",
        // Medium red
        "Abandoned (Flow)": "#EF4444",
        // Darker red
        "BP Error": "#EF4444",
        // Darker red for boarding pass error
        // Failed states - progressive red intensity
        Unrecovered: "#F87171"
        // Medium red for main unrecovered node
      };
      return (a.value.unrecovered_by_step || []).forEach((p) => {
        const m = p.step_name.replace(/_/g, " ").split(" ").map((b) => b.charAt(0).toUpperCase() + b.slice(1)).join(" "), y = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        v[m] = y[m] || "#DC2626";
      }), v;
    }), s = (v, g) => !g || g === 0 ? "0%" : `${Math.round(v / g * 100)}%`, l = (v, g) => {
      const p = lt(v), _ = s(v, g);
      return `${p} (${_})`;
    }, u = (v) => v.reduce((g, p) => g + p.failed_count, 0), c = {
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }, h = {
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }, d = ut(() => {
      const v = [], g = [];
      if (!r.value.total_checkin_initiated)
        return { nodes: v, links: g };
      v.push({ name: "Checkin Init" }), v.push({ name: "Booking retrive" }), v.push({ name: "Booking retrive success" }), v.push({ name: "Number of Passengers" }), v.push({ name: "Completed" }), v.push({ name: "Closed with BP" });
      const p = r.value.total_checkin_initiated, _ = r.value.total_checkin_init, m = r.value.total_checkin_init_abandoned, y = _ - m, b = r.value.total_checkin_started, x = r.value.total_checkin_completed, w = r.value.total_checkin_closed, M = a.value.unrecovered_by_step || [], D = M.reduce((E, A) => E + A.count, 0);
      if (console.log(JSON.stringify(r.value)), _ > 0) {
        const E = Math.round(_ / p * 100);
        g.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: _,
          label: `${_.toLocaleString()} (${E}%)`
        });
      }
      const T = p - _;
      if (T > 0) {
        const E = Math.round(T / p * 100);
        v.push({ name: "Abandoned (Init)" }), g.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: T,
          label: `${T.toLocaleString()} (${E}%)`
        });
      }
      if (m > 0) {
        const E = Math.round(m / p * 100);
        v.push({ name: "Abandoned (Started)" }), g.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: m,
          label: `${m.toLocaleString()} (${E}%)`
        });
      }
      if (y > 0) {
        const E = Math.round(y / p * 100);
        g.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: y,
          label: `${y.toLocaleString()} (${E}%)`
        });
      }
      if (b > 0) {
        const E = Math.round(b / p * 100);
        g.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: b,
          label: `${b.toLocaleString()} (${E}%)`
        });
      }
      if (x > 0) {
        const E = Math.round(x / b * 100);
        g.push({
          source: "Number of Passengers",
          target: "Completed",
          value: x,
          label: `${x.toLocaleString()} (${E}%)`
        });
      }
      if (M.length > 0 && D > 0) {
        v.push({ name: "Unrecovered" });
        const E = Math.round(D / b * 100);
        g.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: D,
          label: `${D.toLocaleString()} (${E}%)`
        }), M.forEach((A) => {
          const R = A.step_name.replace(/_/g, " ").split(" ").map((V) => V.charAt(0).toUpperCase() + V.slice(1)).join(" "), N = Math.round(A.count / b * 100);
          v.push({ name: R }), g.push({
            source: "Unrecovered",
            target: R,
            value: A.count,
            label: `${A.count.toLocaleString()} (${N}%)`
          });
        });
      }
      const C = b - (x + D);
      if (C > 0) {
        const E = Math.round(C / b * 100);
        v.push({ name: "Abandoned (Flow)" }), g.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: C,
          label: `${C.toLocaleString()} (${E}%)`
        });
      }
      const k = x - w;
      if (k > 0) {
        const E = Math.round(k / b * 100);
        v.push({ name: "BP Error" }), g.push({
          source: "Completed",
          target: "BP Error",
          value: k,
          label: `${k.toLocaleString()} (${E}%)`
        });
      }
      if (w > 0) {
        const E = Math.round(w / b * 100);
        g.push({
          source: "Completed",
          target: "Closed with BP",
          value: w,
          label: `${w.toLocaleString()} (${E}%)`
        });
      }
      return console.log(JSON.stringify(v)), console.log(JSON.stringify(g)), { nodes: v, links: g };
    }), f = async () => {
      n.value = !0;
      try {
        const [v, g] = t.dates.map((m) => z(m).format("YYYY-MM-DD")), [p, _] = await Promise.all([
          Q6(t.airline_name, v, g),
          J6(t.airline_name, v, g)
        ]);
        r.value = p, a.value = _, i.value = [...p.checkin_by_day].map((m) => {
          const y = _.failed_by_step_by_day.find(
            (b) => b.date === m.date
          );
          return {
            ...m,
            failed_steps: y?.steps || []
          };
        }), i.value.sort((m, y) => new Date(m.date) - new Date(y.date));
      } catch (v) {
        console.error("Error fetching check-in metrics:", v), r.value = c, a.value = h;
      } finally {
        n.value = !1;
      }
    };
    return Cn(f), Pn(
      () => t.dates,
      (v) => {
        v?.[0] && v?.[1] && f();
      },
      { deep: !0 }
    ), (v, g) => (O(), I("article", H$, [
      g[3] || (g[3] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Check-in Metrics"),
          S("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      n.value ? (O(), I("div", Y$, [...g[0] || (g[0] = [
        Kt('<div class="loading-container" data-v-c3af3972><div class="chart-flow-loader" data-v-c3af3972><div class="flow-line flow-1" data-v-c3af3972></div><div class="flow-line flow-2" data-v-c3af3972></div><div class="flow-line flow-3" data-v-c3af3972></div><div class="flow-line flow-4" data-v-c3af3972></div><div class="flow-line flow-5" data-v-c3af3972></div></div><p class="loading-text" data-v-c3af3972>Loading check-in data...</p></div>', 1)
      ])])) : (O(), I("div", W$, [
        d.value.nodes.length > 0 ? (O(), I("section", U$, [
          S("div", G$, [
            Ee(po, {
              data: d.value,
              height: "500px",
              "node-colors": o.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : ct("", !0),
        i.value && i.value.length > 0 ? (O(), I("section", j$, [
          S("div", X$, [
            S("table", q$, [
              g[1] || (g[1] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Checkin Init"),
                  S("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  S("th", { class: "table-header" }, "Number of Passengers"),
                  S("th", { class: "table-header" }, "Completed (%)"),
                  S("th", { class: "table-header" }, "Closed with BP (%)"),
                  S("th", { class: "table-header" }, "Failed (%)"),
                  S("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              S("tbody", Z$, [
                (O(!0), I(Ft, null, fe(i.value, (p) => (O(), I("tr", {
                  key: p.date,
                  class: "table-row"
                }, [
                  S("td", K$, F(G(z)(p.date).format("DD/MM/YYYY")), 1),
                  S("td", Q$, F(G(lt)(p.checkin_initiated_count)), 1),
                  S("td", J$, F(l(p.checkin_init_count, p.checkin_initiated_count)), 1),
                  S("td", tH, F(G(lt)(p.checkin_started_count)), 1),
                  S("td", eH, F(l(p.checkin_completed_count, p.checkin_started_count)), 1),
                  S("td", nH, F(l(p.checkin_closed_count, p.checkin_started_count)), 1),
                  S("td", iH, F(l(u(p.failed_steps), p.checkin_started_count)), 1),
                  S("td", rH, [
                    p.failed_steps && p.failed_steps.length > 0 ? (O(), I("div", aH, [
                      (O(!0), I(Ft, null, fe(p.failed_steps, (_) => (O(), I("div", {
                        key: _.step_name,
                        class: "failed-step-item"
                      }, [
                        S("span", oH, F(_.step_name.replace(/_/g, " ")) + ":", 1),
                        S("span", sH, F(_.failed_count), 1)
                      ]))), 128))
                    ])) : (O(), I("div", lH, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (O(), I("section", uH, [...g[2] || (g[2] = [
          Kt('<div class="empty-state-content" data-v-c3af3972><div class="empty-icon-wrapper" data-v-c3af3972><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-c3af3972><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-c3af3972></path></svg></div><p class="empty-title" data-v-c3af3972>No check-in data available</p><p class="empty-description" data-v-c3af3972>Try adjusting the date range or check your filters to see check-in performance data.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}, hH = /* @__PURE__ */ de(cH, [["__scopeId", "data-v-c3af3972"]]), dH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: hH
}, Symbol.toStringTag, { value: "Module" })), fH = { class: "checkin-segments-card" }, vH = {
  key: 0,
  class: "loading-state"
}, pH = {
  key: 1,
  class: "card-body"
}, gH = {
  key: 0,
  class: "table-section"
}, _H = { class: "table-wrapper" }, mH = { class: "data-table" }, yH = { class: "table-body" }, bH = { class: "table-cell font-medium text-center" }, xH = { class: "airport-badge" }, wH = { class: "table-cell text-center" }, SH = {
  key: 0,
  class: "airport-badge connection"
}, MH = {
  key: 1,
  class: "empty-connection"
}, DH = { class: "table-cell text-center" }, TH = { class: "airport-badge" }, kH = { class: "table-cell text-center" }, CH = {
  key: 0,
  class: "trip-badge roundtrip"
}, PH = {
  key: 1,
  class: "trip-badge oneway"
}, AH = { class: "table-cell text-center" }, EH = { class: "table-cell text-center" }, LH = { class: "percentage-value" }, OH = { class: "table-cell text-center" }, IH = { class: "percentage-value" }, RH = { class: "table-cell text-center" }, NH = { class: "percentage-value success" }, FH = {
  key: 1,
  class: "empty-state"
}, BH = /* @__PURE__ */ Me({
  __name: "checkinSegments",
  props: {
    dates: { default: () => [new Date(Date.now() - 720 * 60 * 60 * 1e3), /* @__PURE__ */ new Date()] },
    airline_name: { default: "default_airline" }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt([]), r = (l, u) => !u || u === 0 || !l ? "0%" : `${Math.round(l / u * 100)}%`, a = (l) => !l || l === "None" ? "-" : String(l).trim().replace(/_[0-9]+$/i, ""), o = (l) => {
      const u = a(l?.departure_airport), c = a(l?.arrival_airport);
      return u === "-" || c === "-" ? !1 : u === c;
    }, s = async () => {
      n.value = !0;
      try {
        const [l, u] = t.dates.map((h) => z(h).format("YYYY-MM-DD")), c = await o$(t.airline_name, l, u);
        i.value = Array.isArray(c?.segments_table) ? c.segments_table : [];
      } catch (l) {
        console.error("Error fetching checkin segments:", l), i.value = [];
      } finally {
        n.value = !1;
      }
    };
    return Cn(s), Pn(
      () => t.dates,
      (l) => {
        l?.[0] && l?.[1] && s();
      },
      { deep: !0 }
    ), (l, u) => (O(), I("article", fH, [
      u[5] || (u[5] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Checkin Segments"),
          S("p", { class: "card-subtitle" }, "Breakdown by flight segment with connection when applicable")
        ])
      ], -1)),
      n.value ? (O(), I("div", vH, [...u[0] || (u[0] = [
        Kt('<div class="loading-container" data-v-3e0aa204><div class="chart-flow-loader" data-v-3e0aa204><div class="flow-line flow-1" data-v-3e0aa204></div><div class="flow-line flow-2" data-v-3e0aa204></div><div class="flow-line flow-3" data-v-3e0aa204></div><div class="flow-line flow-4" data-v-3e0aa204></div><div class="flow-line flow-5" data-v-3e0aa204></div></div><p class="loading-text" data-v-3e0aa204>Loading segment data...</p></div>', 1)
      ])])) : (O(), I("div", pH, [
        i.value.length > 0 ? (O(), I("section", gH, [
          S("div", _H, [
            S("table", mH, [
              u[3] || (u[3] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Departure"),
                  S("th", { class: "table-header" }, "Connection"),
                  S("th", { class: "table-header" }, "Arrival"),
                  S("th", { class: "table-header" }, "Trip"),
                  S("th", { class: "table-header" }, "Init"),
                  S("th", { class: "table-header" }, "Started (%)"),
                  S("th", { class: "table-header" }, "Completed (%)"),
                  S("th", { class: "table-header" }, "Closed (%)")
                ])
              ], -1)),
              S("tbody", yH, [
                (O(!0), I(Ft, null, fe(i.value, (c, h) => (O(), I("tr", {
                  key: h,
                  class: "table-row"
                }, [
                  S("td", bH, [
                    S("span", xH, F(a(c.departure_airport)), 1)
                  ]),
                  S("td", wH, [
                    a(c.conexion_airport) !== "-" ? (O(), I("span", SH, F(a(c.conexion_airport)), 1)) : (O(), I("span", MH, "-"))
                  ]),
                  S("td", DH, [
                    S("span", TH, F(a(c.arrival_airport)), 1)
                  ]),
                  S("td", kH, [
                    o(c) ? (O(), I("span", CH, [...u[1] || (u[1] = [
                      S("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        S("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                        })
                      ], -1),
                      gu(" Roundtrip ", -1)
                    ])])) : (O(), I("span", PH, [...u[2] || (u[2] = [
                      S("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        S("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M14 5l7 7m0 0l-7 7m7-7H3"
                        })
                      ], -1),
                      gu(" One way ", -1)
                    ])]))
                  ]),
                  S("td", AH, F(G(lt)(c.segment_init_count)), 1),
                  S("td", EH, [
                    S("span", LH, F(r(c.segment_started_count, c.segment_init_count)), 1)
                  ]),
                  S("td", OH, [
                    S("span", IH, F(r(c.segment_completed_count, c.segment_init_count)), 1)
                  ]),
                  S("td", RH, [
                    S("span", NH, F(r(c.segment_closed_count, c.segment_init_count)), 1)
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (O(), I("section", FH, [...u[4] || (u[4] = [
          Kt('<div class="empty-state-content" data-v-3e0aa204><div class="empty-icon-wrapper" data-v-3e0aa204><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-3e0aa204><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-3e0aa204></path></svg></div><p class="empty-title" data-v-3e0aa204>No segment data available</p><p class="empty-description" data-v-3e0aa204>No flight segment data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), zH = /* @__PURE__ */ de(BH, [["__scopeId", "data-v-3e0aa204"]]), VH = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: zH
}, Symbol.toStringTag, { value: "Module" })), $H = { class: "disruption-metrics-card" }, HH = { class: "card-header" }, YH = { class: "header-content" }, WH = {
  key: 0,
  class: "payment-success-badge"
}, UH = { class: "badge-value" }, GH = {
  key: 0,
  class: "loading-state"
}, jH = {
  key: 1,
  class: "card-body"
}, XH = { class: "chart-section" }, qH = { class: "chart-wrapper" }, ZH = {
  key: 1,
  class: "empty-chart"
}, KH = {
  key: 0,
  class: "table-section"
}, QH = { class: "table-wrapper" }, JH = { class: "data-table" }, tY = { class: "table-body" }, eY = { class: "table-cell font-medium text-center" }, nY = { class: "table-cell text-center" }, iY = { class: "table-cell text-center" }, rY = { class: "percentage-text" }, aY = { class: "table-cell text-center" }, oY = { class: "abandoned-value" }, sY = { class: "table-cell" }, lY = { class: "badges-container badges-wrap" }, uY = { class: "badge badge-vol" }, cY = { class: "badge badge-confirm" }, hY = { class: "badge badge-not-confirm" }, dY = { class: "badge badge-reject" }, fY = { class: "badge badge-not-paid" }, vY = { class: "badge badge-success" }, pY = { class: "table-cell" }, gY = { class: "badges-container badges-wrap" }, _Y = { class: "badge badge-inv" }, mY = { class: "badge badge-human" }, yY = { class: "badge badge-accept" }, bY = {
  key: 1,
  class: "empty-state"
}, xY = /* @__PURE__ */ Me({
  __name: "Disruption",
  props: {
    dates: { default: () => [new Date(Date.now() - 720 * 60 * 60 * 1e3), /* @__PURE__ */ new Date()] },
    airline_name: { default: "default_airline" }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt([]), r = pt({
      total_disruption_conversations: 0,
      total_disruption_initiated: 0,
      total_voluntary: 0,
      total_involuntary: 0,
      total_accepted: 0,
      total_confirmed: 0,
      total_sell_success: 0,
      total_sell_failed: 0,
      total_finished: 0,
      total_payment_success: 0,
      disruption_by_day: []
    }), a = (c, h) => !h || h === 0 ? "0%" : `${Math.round(c / h * 100)}%`, o = ut(() => {
      const c = r.value, h = c.total_disruption_conversations || 0, d = c.total_disruption_initiated || 0, f = c.total_voluntary || 0, v = c.total_involuntary || 0, g = c.total_accepted || 0, p = c.total_confirmed || 0, _ = c.total_sell_success || 0, m = c.total_sell_failed || 0, y = Math.max(0, h - d), b = Math.max(0, d - f - v), x = Math.max(0, v - g), w = Math.max(0, f - p), M = m, D = Math.max(0, p - _ - M), T = (E, A) => {
        const L = A > 0 ? Math.round(E / A * 100) : 0;
        return `${E.toLocaleString()} (${L}%)`;
      }, C = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Voluntary" },
        { name: "Confirmed" },
        { name: "Paid" },
        { name: "Not Paid" },
        { name: "Rejected" },
        { name: "Not Confirmed" },
        { name: "Involuntary" },
        { name: "Accepted" },
        { name: "Redirect to Human" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], k = [];
      return d > 0 && k.push({
        source: "Initiated",
        target: "Started",
        value: d,
        label: T(d, h)
      }), y > 0 && k.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: y,
        label: T(y, h)
      }), f > 0 && k.push({
        source: "Started",
        target: "Voluntary",
        value: f,
        label: T(f, h)
      }), v > 0 && k.push({
        source: "Started",
        target: "Involuntary",
        value: v,
        label: T(v, h)
      }), b > 0 && k.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: b,
        label: T(b, h)
      }), g > 0 && k.push({
        source: "Involuntary",
        target: "Accepted",
        value: g,
        label: T(g, h)
      }), x > 0 && k.push({
        source: "Involuntary",
        target: "Redirect to Human",
        value: x,
        label: T(x, h)
      }), p > 0 && k.push({
        source: "Voluntary",
        target: "Confirmed",
        value: p,
        label: T(p, h)
      }), w > 0 && k.push({
        source: "Voluntary",
        target: "Not Confirmed",
        value: w,
        label: T(w, h)
      }), _ > 0 && k.push({
        source: "Confirmed",
        target: "Paid",
        value: _,
        label: T(_, h)
      }), M > 0 && k.push({
        source: "Confirmed",
        target: "Rejected",
        value: M,
        label: T(M, h)
      }), D > 0 && k.push({
        source: "Confirmed",
        target: "Not Paid",
        value: D,
        label: T(D, h)
      }), { nodes: C, links: k };
    }), s = {
      Initiated: "#E5E7EB",
      Started: "#DBEAFE",
      "Abandoned (Start)": "#FEE2E2",
      Voluntary: "#FED7AA",
      Involuntary: "#E9D5FF",
      "Abandoned (Init)": "#FEE2E2",
      Accepted: "#86EFAC",
      "Redirect to Human": "#FCA5A5",
      Confirmed: "#BFDBFE",
      "Not Confirmed": "#FED7AA",
      Paid: "#86EFAC",
      Rejected: "#FCA5A5",
      "Not Paid": "#FED7AA"
    }, l = {
      total_disruption_conversations: 0,
      total_disruption_initiated: 0,
      total_voluntary: 0,
      total_involuntary: 0,
      total_accepted: 0,
      total_confirmed: 0,
      total_sell_success: 0,
      total_sell_failed: 0,
      total_finished: 0,
      total_payment_success: 0,
      disruption_by_day: []
    }, u = async () => {
      n.value = !0;
      try {
        const [c, h] = t.dates.map((f) => z(f).format("YYYY-MM-DD")), d = await a$(t.airline_name, c, h);
        r.value = d, i.value = [...d.disruption_by_day], i.value.sort((f, v) => new Date(f.date).getTime() - new Date(v.date).getTime());
      } catch (c) {
        console.error("Error fetching disruption metrics:", c), r.value = l, i.value = [];
      } finally {
        n.value = !1;
      }
    };
    return Cn(u), Pn(
      () => t.dates,
      (c) => {
        c?.[0] && c?.[1] && u();
      },
      { deep: !0 }
    ), (c, h) => (O(), I("article", $H, [
      S("header", HH, [
        S("div", YH, [
          h[1] || (h[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "Disruption Metrics"),
            S("p", { class: "card-subtitle" }, "Disruption workflow performance and completion tracking")
          ], -1)),
          n.value ? ct("", !0) : (O(), I("div", WH, [
            h[0] || (h[0] = S("p", { class: "badge-label" }, "Payment Success", -1)),
            S("p", UH, F(G(lt)(r.value.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      n.value ? (O(), I("div", GH, [...h[2] || (h[2] = [
        Kt('<div class="loading-container" data-v-5b1b32df><div class="chart-flow-loader" data-v-5b1b32df><div class="flow-line flow-1" data-v-5b1b32df></div><div class="flow-line flow-2" data-v-5b1b32df></div><div class="flow-line flow-3" data-v-5b1b32df></div><div class="flow-line flow-4" data-v-5b1b32df></div><div class="flow-line flow-5" data-v-5b1b32df></div></div><p class="loading-text" data-v-5b1b32df>Loading disruption data...</p></div>', 1)
      ])])) : (O(), I("div", jH, [
        S("section", XH, [
          S("div", qH, [
            o.value.nodes.length > 0 && o.value.links.length > 0 ? (O(), Wy(po, {
              key: 0,
              data: o.value,
              "node-colors": s,
              height: "500px"
            }, null, 8, ["data"])) : (O(), I("div", ZH, [...h[3] || (h[3] = [
              S("p", { class: "empty-chart-text" }, "No disruption data available for visualization", -1)
            ])]))
          ])
        ]),
        i.value && i.value.length > 0 ? (O(), I("section", KH, [
          h[5] || (h[5] = Kt('<div class="section-header" data-v-5b1b32df><h4 class="section-title" data-v-5b1b32df>Daily Overview</h4></div><div class="legend-container" data-v-5b1b32df><p class="legend-title" data-v-5b1b32df>Legend</p><div class="legend-items" data-v-5b1b32df><div class="legend-group" data-v-5b1b32df><span class="legend-label" data-v-5b1b32df>Voluntary:</span><span class="badge badge-vol" data-v-5b1b32df>VOL</span></div><div class="legend-group" data-v-5b1b32df><span class="legend-label" data-v-5b1b32df>Involuntary:</span><span class="badge badge-inv" data-v-5b1b32df>INV</span></div><div class="legend-note" data-v-5b1b32df><span data-v-5b1b32df>Vol=Voluntary</span><span data-v-5b1b32df></span><span data-v-5b1b32df>Inv=Involuntary</span></div></div></div>', 2)),
          S("div", QH, [
            S("table", JH, [
              h[4] || (h[4] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Initiated"),
                  S("th", { class: "table-header" }, "Started"),
                  S("th", { class: "table-header" }, "Abandoned (%)"),
                  S("th", { class: "table-header" }, "Voluntary"),
                  S("th", { class: "table-header" }, "Involuntary")
                ])
              ], -1)),
              S("tbody", tY, [
                (O(!0), I(Ft, null, fe(i.value, (d) => (O(), I("tr", {
                  key: d.date,
                  class: "table-row"
                }, [
                  S("td", eY, F(G(z)(d.date).format("DD/MM")), 1),
                  S("td", nY, F(G(lt)(d.disruption_conversations)), 1),
                  S("td", iY, [
                    gu(F(G(lt)(d.disruption_initiated_count)) + " ", 1),
                    S("span", rY, " (" + F(a(d.disruption_initiated_count, d.disruption_conversations)) + ") ", 1)
                  ]),
                  S("td", aY, [
                    S("span", oY, F(G(lt)(d.disruption_initiated_count - d.voluntary_count - d.involuntary_count)) + " (" + F(a(d.disruption_initiated_count - d.voluntary_count - d.involuntary_count, d.disruption_conversations)) + ") ", 1)
                  ]),
                  S("td", sY, [
                    S("div", lY, [
                      S("span", uY, " VOL " + F(G(lt)(d.voluntary_count)) + " (" + F(a(d.voluntary_count, d.disruption_conversations)) + ") ", 1),
                      S("span", cY, " Confirm " + F(G(lt)(d.confirmed_count)) + " (" + F(a(d.confirmed_count, d.disruption_conversations)) + ") ", 1),
                      S("span", hY, " Not Confirm " + F(G(lt)(d.voluntary_count - d.confirmed_count)) + " (" + F(a(d.voluntary_count - d.confirmed_count, d.disruption_conversations)) + ") ", 1),
                      S("span", dY, " Reject " + F(G(lt)(d.sell_failed_count)) + " (" + F(a(d.sell_failed_count, d.disruption_conversations)) + ") ", 1),
                      S("span", fY, " Not Paid " + F(G(lt)(Math.max(0, d.confirmed_count - d.sell_success_count - d.sell_failed_count))) + " (" + F(a(Math.max(0, d.confirmed_count - d.sell_success_count - d.sell_failed_count), d.disruption_conversations)) + ") ", 1),
                      S("span", vY, " Finish " + F(G(lt)(d.sell_success_count)) + " (" + F(a(d.sell_success_count, d.disruption_conversations)) + ") ", 1)
                    ])
                  ]),
                  S("td", pY, [
                    S("div", gY, [
                      S("span", _Y, " INV " + F(G(lt)(d.involuntary_count)) + " (" + F(a(d.involuntary_count, d.disruption_conversations)) + ") ", 1),
                      S("span", mY, " Human " + F(G(lt)(d.involuntary_count - d.accepted_count)) + " (" + F(a(d.involuntary_count - d.accepted_count, d.disruption_conversations)) + ") ", 1),
                      S("span", yY, " Accept " + F(G(lt)(d.accepted_count)) + " (" + F(a(d.accepted_count, d.disruption_conversations)) + ") ", 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : (O(), I("section", bY, [...h[6] || (h[6] = [
          Kt('<div class="empty-state-content" data-v-5b1b32df><div class="empty-icon-wrapper" data-v-5b1b32df><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-5b1b32df><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" data-v-5b1b32df></path></svg></div><p class="empty-title" data-v-5b1b32df>No disruption data available</p><p class="empty-description" data-v-5b1b32df>No disruption data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), wY = /* @__PURE__ */ de(xY, [["__scopeId", "data-v-5b1b32df"]]), SY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: wY
}, Symbol.toStringTag, { value: "Module" })), MY = { class: "faq-metrics-card" }, DY = {
  key: 0,
  class: "card-body"
}, TY = { class: "kpi-grid" }, kY = { class: "kpi-card kpi-purple" }, CY = { class: "kpi-value" }, PY = { class: "kpi-card kpi-blue" }, AY = { class: "kpi-value" }, EY = { class: "kpi-card kpi-green" }, LY = { class: "kpi-value" }, OY = { class: "kpi-card kpi-orange" }, IY = { class: "kpi-value" }, RY = { class: "kpi-card kpi-cyan" }, NY = { class: "kpi-value" }, FY = {
  key: 0,
  class: "chart-section"
}, BY = { class: "chart-wrapper" }, zY = {
  key: 1,
  class: "empty-state"
}, VY = {
  key: 1,
  class: "loading-state"
}, $Y = /* @__PURE__ */ Me({
  __name: "FAQ",
  props: {
    dates: { default: () => [new Date(Date.now() - 720 * 60 * 60 * 1e3), /* @__PURE__ */ new Date()] },
    airline_name: { default: "default_airline" }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt({ labels: [], datasets: [] }), r = pt({
      total_faq_events: 0,
      total_documents_found: 0,
      total_airline_information_retrieved: 0,
      total_booking_info_retrieved: 0,
      total_flight_status_retrieved: 0,
      faq_by_day: []
    }), a = ut(() => ({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12
            }
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: "rgba(255, 255, 255, 0.95)",
          titleColor: "#1e293b",
          bodyColor: "#64748b",
          borderColor: "rgba(0, 0, 0, 0.1)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'Space Grotesk', sans-serif",
            size: 14,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 13
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: "#64748b"
          }
        },
        y: {
          type: "linear",
          display: !0,
          position: "left",
          beginAtZero: !0,
          grid: {
            color: "rgba(0, 0, 0, 0.05)"
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: "#64748b"
          }
        }
      },
      interaction: {
        mode: "nearest",
        axis: "x",
        intersect: !1
      }
    })), o = async () => {
      try {
        n.value = !0;
        const s = z(t.dates[0]).format("YYYY-MM-DD"), l = z(t.dates[1]).format("YYYY-MM-DD"), u = await t$(t.airline_name, s, l);
        r.value = u;
        const c = u?.faq_by_day || [];
        if (c.length > 0) {
          const h = c.map((g) => z(g.date).format("MMM DD")), d = c.map((g) => g.airline_information_retrieved_count || 0), f = c.map((g) => g.flight_status_retrieved_count || 0), v = c.map((g) => g.booking_info_retrieved_count || 0);
          i.value = {
            labels: h,
            datasets: [
              {
                label: "Airline Information",
                data: d,
                borderColor: "#8b5cf6",
                backgroundColor: "rgba(139, 92, 246, 0.1)",
                borderWidth: 2,
                fill: !0,
                tension: 0.4,
                pointBackgroundColor: "#8b5cf6",
                pointBorderColor: "#7c3aed",
                pointBorderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6
              },
              {
                label: "Flight Status",
                data: f,
                borderColor: "#06b6d4",
                backgroundColor: "rgba(6, 182, 212, 0.1)",
                borderWidth: 2,
                fill: !0,
                tension: 0.4,
                pointBackgroundColor: "#06b6d4",
                pointBorderColor: "#0891b2",
                pointBorderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6
              },
              {
                label: "Booking Information",
                data: v,
                borderColor: "#f59e0b",
                backgroundColor: "rgba(245, 158, 11, 0.1)",
                borderWidth: 2,
                fill: !0,
                tension: 0.4,
                pointBackgroundColor: "#f59e0b",
                pointBorderColor: "#d97706",
                pointBorderWidth: 2,
                pointRadius: 4,
                pointHoverRadius: 6
              }
            ]
          };
        } else
          i.value = { labels: [], datasets: [] };
      } catch (s) {
        console.error("Error fetching FAQ metrics data:", s), i.value = { labels: [], datasets: [] }, r.value = {
          total_faq_events: 0,
          total_documents_found: 0,
          total_airline_information_retrieved: 0,
          total_booking_info_retrieved: 0,
          total_flight_status_retrieved: 0,
          faq_by_day: []
        };
      } finally {
        n.value = !1;
      }
    };
    return Cn(o), Pn(
      () => t.dates,
      (s) => {
        s?.[0] && s?.[1] && o();
      },
      { deep: !0 }
    ), (s, l) => (O(), I("article", MY, [
      l[7] || (l[7] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "FAQ Metrics"),
          S("p", { class: "card-subtitle" }, "Daily FAQ consultation and retrieval metrics")
        ])
      ], -1)),
      n.value ? (O(), I("div", VY, [...l[6] || (l[6] = [
        Kt('<div class="loading-container" data-v-0b1deebb><div class="chart-bars-loader" data-v-0b1deebb><div class="bar bar-1" data-v-0b1deebb></div><div class="bar bar-2" data-v-0b1deebb></div><div class="bar bar-3" data-v-0b1deebb></div><div class="bar bar-4" data-v-0b1deebb></div><div class="bar bar-5" data-v-0b1deebb></div></div><p class="loading-text" data-v-0b1deebb>Loading FAQ metrics...</p></div>', 1)
      ])])) : (O(), I("div", DY, [
        S("div", TY, [
          S("div", kY, [
            l[0] || (l[0] = S("p", { class: "kpi-label" }, "Total FAQ", -1)),
            S("p", CY, F(G(lt)(r.value.total_faq_events)), 1)
          ]),
          S("div", PY, [
            l[1] || (l[1] = S("p", { class: "kpi-label" }, "Documents Found", -1)),
            S("p", AY, F(G(lt)(r.value.total_documents_found)), 1)
          ]),
          S("div", EY, [
            l[2] || (l[2] = S("p", { class: "kpi-label" }, "Airline Info", -1)),
            S("p", LY, F(G(lt)(r.value.total_airline_information_retrieved)), 1)
          ]),
          S("div", OY, [
            l[3] || (l[3] = S("p", { class: "kpi-label" }, "Booking Info", -1)),
            S("p", IY, F(G(lt)(r.value.total_booking_info_retrieved)), 1)
          ]),
          S("div", RY, [
            l[4] || (l[4] = S("p", { class: "kpi-label" }, "Flight Status", -1)),
            S("p", NY, F(G(lt)(r.value.total_flight_status_retrieved)), 1)
          ])
        ]),
        i.value.labels && i.value.labels.length ? (O(), I("section", FY, [
          S("div", BY, [
            Ee(pv, {
              data: i.value,
              options: a.value
            }, null, 8, ["data", "options"])
          ])
        ])) : (O(), I("section", zY, [...l[5] || (l[5] = [
          Kt('<div class="empty-state-content" data-v-0b1deebb><div class="empty-icon-wrapper" data-v-0b1deebb><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-0b1deebb><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" data-v-0b1deebb></path></svg></div><p class="empty-title" data-v-0b1deebb>No FAQ data available</p><p class="empty-description" data-v-0b1deebb>No FAQ consultation data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), HY = /* @__PURE__ */ de($Y, [["__scopeId", "data-v-0b1deebb"]]), YY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: HY
}, Symbol.toStringTag, { value: "Module" }));
function $p(e, t) {
  return O(), I("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    S("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z"
    })
  ]);
}
const WY = { class: "messages-per-agent-card" }, UY = {
  key: 0,
  class: "card-body"
}, GY = {
  key: 0,
  class: "chart-section"
}, jY = {
  key: 1,
  class: "empty-state"
}, XY = { class: "empty-state-content" }, qY = { class: "empty-icon-wrapper" }, ZY = {
  key: 1,
  class: "loading-state"
}, KY = /* @__PURE__ */ Me({
  __name: "MessagesPerAgent",
  props: {
    data: { default: () => ({ labels: [], datasets: [] }) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 }
  },
  setup(e) {
    const t = e, n = ut(() => t.data), i = ut(() => t.options);
    return (r, a) => (O(), I("article", WY, [
      a[3] || (a[3] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Messages per Agent"),
          S("p", { class: "card-subtitle" }, "Agent interaction trends over time")
        ])
      ], -1)),
      e.loading ? (O(), I("div", ZY, [...a[2] || (a[2] = [
        Kt('<div class="loading-container" data-v-cebb94f7><div class="chart-lines-loader" data-v-cebb94f7><div class="line line-1" data-v-cebb94f7></div><div class="line line-2" data-v-cebb94f7></div><div class="line line-3" data-v-cebb94f7></div><div class="line line-4" data-v-cebb94f7></div><div class="line line-5" data-v-cebb94f7></div></div><p class="loading-text" data-v-cebb94f7>Loading chart data...</p></div>', 1)
      ])])) : (O(), I("div", UY, [
        n.value.labels && n.value.labels.length ? (O(), I("section", GY, [
          Ee(pv, {
            data: n.value,
            options: i.value
          }, null, 8, ["data", "options"])
        ])) : (O(), I("section", jY, [
          S("div", XY, [
            S("div", qY, [
              Ee(G($p), { class: "empty-icon" })
            ]),
            a[0] || (a[0] = S("p", { class: "empty-title" }, "No agent interactions data", -1)),
            a[1] || (a[1] = S("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), QY = /* @__PURE__ */ de(KY, [["__scopeId", "data-v-cebb94f7"]]), JY = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: QY
}, Symbol.toStringTag, { value: "Module" })), t8 = { class: "record-locator-card" }, e8 = {
  key: 0,
  class: "loading-state"
}, n8 = {
  key: 1,
  class: "card-body"
}, i8 = {
  key: 0,
  class: "chart-section"
}, r8 = { class: "chart-wrapper" }, a8 = {
  key: 1,
  class: "table-section"
}, o8 = { class: "table-wrapper" }, s8 = { class: "data-table" }, l8 = { class: "table-header-row" }, u8 = {
  key: 0,
  class: "table-header"
}, c8 = {
  key: 1,
  class: "table-header"
}, h8 = { class: "table-body" }, d8 = { class: "table-cell font-medium" }, f8 = { class: "table-cell text-center" }, v8 = { class: "table-cell text-center" }, p8 = { class: "table-cell text-center" }, g8 = { class: "table-cell text-center" }, _8 = { class: "table-cell text-center success-value" }, m8 = { class: "table-cell text-center failed-value" }, y8 = { class: "table-cell text-center warning-value" }, b8 = {
  key: 0,
  class: "table-cell text-center"
}, x8 = {
  key: 1,
  class: "table-cell text-center failed-value"
}, w8 = {
  key: 2,
  class: "empty-state"
}, S8 = /* @__PURE__ */ Me({
  __name: "RecordLocator",
  props: {
    dates: { default: () => [new Date(Date.now() - 720 * 60 * 60 * 1e3), /* @__PURE__ */ new Date()] },
    airline_name: { default: "default_airline" }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt([]), r = ut(() => (t.airline_name || "").toLowerCase() === "avianca"), a = pt({
      total_checkin_initiated: 0,
      total_record_locator_init: 0,
      total_record_locator_started: 0,
      total_record_locator_completed: 0,
      total_record_locator_closed: 0,
      total_record_locator_failed: 0,
      total_record_locator_abandoned: 0,
      total_record_locator_init_abandoned: 0,
      record_locator_by_day: []
    }), o = ut(() => ({
      // Main flow progression - from blue to cyan to green
      "Checkin Init": "#93C5FD",
      // Blue for started state
      "Booking retrive": "#67E8F9",
      // Light cyan
      "Checkin Started": "#22D3EE",
      // Medium cyan
      "Checkin Completed": "#A7F3D0",
      // Light green
      "Checkin Closed": "#7BE39E",
      // Green for success
      // Abandoned states - progressive red
      "Abandoned (Init)": "#FCA5A5",
      // Light red
      "Abandoned (Started)": "#F87171",
      // Medium red
      "Abandoned (Flow)": "#EF4444",
      // Darker red
      // Failed states
      "Checkin Failed": "#F87171"
      // Medium red for main failed node
    })), s = (d, f) => !f || f === 0 ? "0%" : `${Math.round(d / f * 100)}%`, l = (d, f) => {
      const v = lt(d), g = s(d, f);
      return `${v} (${g})`;
    }, u = {
      total_checkin_initiated: 0,
      total_record_locator_init: 0,
      total_record_locator_started: 0,
      total_record_locator_completed: 0,
      total_record_locator_closed: 0,
      total_record_locator_failed: 0,
      total_record_locator_abandoned: 0,
      total_record_locator_init_abandoned: 0,
      record_locator_by_day: []
    }, c = ut(() => {
      const d = [], f = [];
      if (!a.value.total_checkin_initiated)
        return { nodes: d, links: f };
      d.push({ name: "Checkin Init" }), d.push({ name: "Booking retrive" }), d.push({ name: "Checkin Started" }), d.push({ name: "Checkin Completed" }), d.push({ name: "Checkin Closed" });
      const v = a.value.total_checkin_initiated, g = a.value.total_record_locator_init, p = a.value.total_record_locator_started, _ = a.value.total_record_locator_completed, m = a.value.total_record_locator_closed, y = a.value.total_record_locator_failed, b = a.value.total_record_locator_abandoned, x = a.value.total_record_locator_init_abandoned;
      if (g > 0) {
        const M = Math.round(g / v * 100);
        f.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: g,
          label: `${g.toLocaleString()} (${M}%)`
        });
      }
      const w = v - g;
      if (w > 0) {
        const M = Math.round(w / v * 100);
        d.push({ name: "Abandoned (Init)" }), f.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: w,
          label: `${w.toLocaleString()} (${M}%)`
        });
      }
      if (p > 0) {
        const M = Math.round(p / v * 100);
        f.push({
          source: "Booking retrive",
          target: "Checkin Started",
          value: p,
          label: `${p.toLocaleString()} (${M}%)`
        });
      }
      if (x > 0) {
        const M = Math.round(x / v * 100);
        d.push({ name: "Abandoned (Started)" }), f.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: x,
          label: `${x.toLocaleString()} (${M}%)`
        });
      }
      if (_ > 0) {
        const M = Math.round(_ / p * 100);
        f.push({
          source: "Checkin Started",
          target: "Checkin Completed",
          value: _,
          label: `${_.toLocaleString()} (${M}%)`
        });
      }
      if (m > 0) {
        const M = Math.round(m / p * 100);
        f.push({
          source: "Checkin Completed",
          target: "Checkin Closed",
          value: m,
          label: `${m.toLocaleString()} (${M}%)`
        });
      }
      if (y > 0) {
        const M = Math.round(y / p * 100);
        d.push({ name: "Checkin Failed" }), f.push({
          source: "Checkin Started",
          target: "Checkin Failed",
          value: y,
          label: `${y.toLocaleString()} (${M}%)`
        });
      }
      if (b > 0) {
        const M = Math.round(b / p * 100);
        d.push({ name: "Abandoned (Flow)" }), f.push({
          source: "Checkin Started",
          target: "Abandoned (Flow)",
          value: b,
          label: `${b.toLocaleString()} (${M}%)`
        });
      }
      return { nodes: d, links: f };
    }), h = async () => {
      n.value = !0;
      try {
        const [d, f] = t.dates.map((g) => z(g).format("YYYY-MM-DD")), v = await i$(t.airline_name, d, f);
        a.value = v, i.value = [...v.record_locator_by_day], i.value.sort((g, p) => new Date(g.date).getTime() - new Date(p.date).getTime());
      } catch (d) {
        console.error("Error fetching record locator metrics:", d), a.value = u;
      } finally {
        n.value = !1;
      }
    };
    return Cn(h), Pn(
      () => t.dates,
      (d) => {
        d?.[0] && d?.[1] && h();
      },
      { deep: !0 }
    ), (d, f) => (O(), I("article", t8, [
      f[10] || (f[10] = S("header", { class: "card-header" }, [
        S("div", { class: "header-content" }, [
          S("h3", { class: "card-title" }, "Checkin by Record Locator Metrics"),
          S("p", { class: "card-subtitle" }, "Checkin by record locator retrieval and completion analysis")
        ])
      ], -1)),
      n.value ? (O(), I("div", e8, [...f[0] || (f[0] = [
        Kt('<div class="loading-container" data-v-4c618569><div class="chart-flow-loader" data-v-4c618569><div class="flow-line flow-1" data-v-4c618569></div><div class="flow-line flow-2" data-v-4c618569></div><div class="flow-line flow-3" data-v-4c618569></div><div class="flow-line flow-4" data-v-4c618569></div><div class="flow-line flow-5" data-v-4c618569></div></div><p class="loading-text" data-v-4c618569>Loading record locator data...</p></div>', 1)
      ])])) : (O(), I("div", n8, [
        c.value.nodes.length > 0 ? (O(), I("section", i8, [
          S("div", r8, [
            Ee(po, {
              data: c.value,
              height: "500px",
              "node-colors": o.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : ct("", !0),
        i.value && i.value.length > 0 ? (O(), I("section", a8, [
          S("div", o8, [
            S("table", s8, [
              S("thead", null, [
                S("tr", l8, [
                  f[1] || (f[1] = S("th", { class: "table-header" }, "Date", -1)),
                  f[2] || (f[2] = S("th", { class: "table-header" }, "Checkin Init", -1)),
                  f[3] || (f[3] = S("th", { class: "table-header" }, "Booking Retrieve (%)", -1)),
                  f[4] || (f[4] = S("th", { class: "table-header" }, "Checkin Started", -1)),
                  f[5] || (f[5] = S("th", { class: "table-header" }, "Checkin Completed (%)", -1)),
                  f[6] || (f[6] = S("th", { class: "table-header" }, "Checkin Closed (%)", -1)),
                  f[7] || (f[7] = S("th", { class: "table-header" }, "Checkin Failed (%)", -1)),
                  f[8] || (f[8] = S("th", { class: "table-header" }, "Abandoned (%)", -1)),
                  r.value ? (O(), I("th", u8, "Create Payment")) : ct("", !0),
                  r.value ? (O(), I("th", c8, "Failed Payment")) : ct("", !0)
                ])
              ]),
              S("tbody", h8, [
                (O(!0), I(Ft, null, fe(i.value, (v) => (O(), I("tr", {
                  key: v.date,
                  class: "table-row"
                }, [
                  S("td", d8, F(G(z)(v.date).format("DD/MM/YYYY")), 1),
                  S("td", f8, F(G(lt)(v.checkin_initiated)), 1),
                  S("td", v8, F(l(v.record_locator_init_count, v.checkin_initiated)), 1),
                  S("td", p8, F(G(lt)(v.record_locator_started_count)), 1),
                  S("td", g8, F(l(v.record_locator_completed_count, v.record_locator_started_count)), 1),
                  S("td", _8, F(l(v.record_locator_closed_count, v.record_locator_started_count)), 1),
                  S("td", m8, F(l(v.record_locator_failed_count, v.record_locator_started_count)), 1),
                  S("td", y8, F(l(v.record_locator_abandoned_count, v.record_locator_started_count)), 1),
                  r.value ? (O(), I("td", b8, F(G(lt)(v.record_locator_create_payment_count)), 1)) : ct("", !0),
                  r.value ? (O(), I("td", x8, F(G(lt)(v.record_locator_create_payment_failed_count)), 1)) : ct("", !0)
                ]))), 128))
              ])
            ])
          ])
        ])) : (O(), I("section", w8, [...f[9] || (f[9] = [
          Kt('<div class="empty-state-content" data-v-4c618569><div class="empty-icon-wrapper" data-v-4c618569><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-4c618569><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" data-v-4c618569></path></svg></div><p class="empty-title" data-v-4c618569>No record locator data available</p><p class="empty-description" data-v-4c618569>No record locator data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), M8 = /* @__PURE__ */ de(S8, [["__scopeId", "data-v-4c618569"]]), D8 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: M8
}, Symbol.toStringTag, { value: "Module" })), T8 = { class: "seller-metrics-card" }, k8 = { class: "card-header" }, C8 = { class: "header-content" }, P8 = { class: "total-sales-badge" }, A8 = { class: "badge-value" }, E8 = {
  key: 0,
  class: "loading-state"
}, L8 = {
  key: 1,
  class: "card-body"
}, O8 = {
  key: 0,
  class: "chart-section"
}, I8 = { class: "chart-wrapper" }, R8 = {
  key: 1,
  class: "empty-state"
}, N8 = {
  key: 2,
  class: "table-section"
}, F8 = { class: "table-wrapper" }, B8 = { class: "data-table" }, z8 = { class: "table-body" }, V8 = { class: "table-cell font-medium" }, $8 = { class: "table-cell text-center" }, H8 = { class: "table-cell text-center" }, Y8 = { class: "table-cell text-center" }, W8 = { class: "table-cell text-center" }, U8 = { class: "table-cell text-center" }, G8 = { class: "table-cell text-center success-value" }, j8 = { class: "table-cell text-left" }, X8 = {
  key: 0,
  class: "failed-reasons"
}, q8 = { class: "reason-name" }, Z8 = { class: "reason-count" }, K8 = {
  key: 1,
  class: "empty-cell"
}, Q8 = /* @__PURE__ */ Me({
  __name: "Seller",
  props: {
    dates: { default: () => [new Date(Date.now() - 720 * 60 * 60 * 1e3), /* @__PURE__ */ new Date()] },
    airline_name: { default: "default_airline" }
  },
  setup(e) {
    const t = e, n = pt(!0), i = pt([]), r = pt({
      total_seller_conversations: 0,
      total_sell_started: 0,
      total_sell_get_quote: 0,
      total_sell_booking_created: 0,
      total_sell_success: 0,
      total_value_sell_success: 0,
      seller_by_day: []
    }), a = pt({
      total_sell_failed: 0,
      failed_by_reason_by_day: []
    }), o = ut(() => {
      const {
        total_seller_conversations: v = 0,
        total_sell_started: g = 0,
        total_sell_booking_created: p = 0,
        total_sell_success: _ = 0
      } = r.value, { failed_by_reason_by_day: m = [] } = a.value;
      if (v === 0) return { nodes: [], links: [] };
      const y = [
        { name: "Sell Initiated", value: v },
        { name: "Sell Started", value: g },
        { name: "Booking Created", value: p },
        { name: "Sell Success", value: _ }
      ], b = [], x = v - g;
      if (x > 0) {
        const T = Math.round(x / v * 100);
        y.push({ name: "Abandoned (Init)", value: x }), b.push({
          source: "Sell Initiated",
          target: "Abandoned (Init)",
          value: x,
          label: `${x.toLocaleString()} (${T}%)`
        });
      }
      if (g > 0) {
        const T = Math.round(g / v * 100);
        b.push({
          source: "Sell Initiated",
          target: "Sell Started",
          value: g,
          label: `${g.toLocaleString()} (${T}%)`
        });
      }
      const w = m.reduce((T, C) => (C.reasons && Array.isArray(C.reasons) && C.reasons.forEach((k) => {
        const E = k.reason, A = k.failed_count;
        T[E] = (T[E] || 0) + A;
      }), T), {});
      if (p > 0) {
        const T = Math.round(p / v * 100);
        b.push({
          source: "Sell Started",
          target: "Booking Created",
          value: p,
          label: `${p.toLocaleString()} (${T}%)`
        });
      }
      if (_ > 0) {
        const T = Math.round(_ / v * 100);
        b.push({
          source: "Booking Created",
          target: "Sell Success",
          value: _,
          label: `${_.toLocaleString()} (${T}%)`
        });
      }
      const M = g - p;
      if (M > 0) {
        const T = Math.round(M / v * 100);
        y.push({ name: "Failed at Booking", value: M }), b.push({
          source: "Sell Started",
          target: "Failed at Booking",
          value: M,
          label: `${M.toLocaleString()} (${T}%)`
        });
      }
      if (Object.keys(w).length > 0) {
        const T = Object.values(w).reduce((k, E) => k + E, 0), C = M - T;
        if (Object.entries(w).filter(([, k]) => k > 0).sort(([, k], [, E]) => E - k).forEach(([k, E]) => {
          const A = Math.round(E / v * 100);
          y.push({ name: `Failed: ${k}`, value: E }), b.push({
            source: "Failed at Booking",
            target: `Failed: ${k}`,
            value: E,
            label: `${E.toLocaleString()} (${A}%)`
          });
        }), C > 0) {
          const k = Math.round(C / v * 100);
          y.push({ name: "Failed: Without Reason", value: C }), b.push({
            source: "Failed at Booking",
            target: "Failed: Without Reason",
            value: C,
            label: `${C.toLocaleString()} (${k}%)`
          });
        }
      }
      const D = p - _;
      if (D > 0) {
        const T = Math.round(D / v * 100);
        y.push({ name: "Failed at Completion", value: D }), b.push({
          source: "Booking Created",
          target: "Failed at Completion",
          value: D,
          label: `${D.toLocaleString()} (${T}%)`
        });
      }
      return { nodes: y, links: b };
    }), s = {
      "Sell Initiated": "#DBEAFE",
      "Abandoned (Init)": "#FEE2E2",
      "Sell Started": "#93C5FD",
      "Get Quote": "#C7D2FE",
      "Booking Created": "#8B8CF6",
      "Sell Success": "#7BE39E",
      "Sell Failed": "#FCA5A5",
      "Failed at Quote": "#FCA5A5",
      "Failed at Booking": "#F87171",
      "Failed at Completion": "#EF4444",
      "Failed: rejected": "#F87171",
      "Failed: payment_processing": "#EF4444",
      "Failed: seat_selection": "#F87171",
      "Failed: booking_validation": "#EF4444",
      "Failed: flight_availability": "#DC2626",
      "Failed: passenger_data": "#F87171",
      "Failed: system_error": "#DC2626",
      "Failed: timeout": "#EF4444",
      "Failed: Without Reason": "#F87171"
    }, l = ut(() => s), u = (v, g) => !g || g === 0 ? "0%" : `${Math.round(v / g * 100)}%`, c = (v, g) => {
      const p = lt(v), _ = u(v, g);
      return `${p} (${_})`;
    }, h = {
      total_seller_conversations: 0,
      total_sell_started: 0,
      total_sell_get_quote: 0,
      total_sell_booking_created: 0,
      total_sell_success: 0,
      total_value_sell_success: 0,
      seller_by_day: []
    }, d = {
      total_sell_failed: 0,
      failed_by_reason_by_day: []
    }, f = async () => {
      n.value = !0;
      try {
        const [v, g] = t.dates.map((m) => z(m).format("YYYY-MM-DD")), [p, _] = await Promise.all([
          e$(t.airline_name, v, g),
          n$(t.airline_name, v, g)
        ]);
        r.value = p, a.value = _, i.value = [...p.seller_by_day], _.failed_by_reason_by_day.forEach((m) => {
          const y = i.value.findIndex((b) => b.date === m.date);
          y !== -1 ? i.value[y] = { ...i.value[y], reasons: m.reasons } : i.value.push({
            date: m.date,
            seller_conversations: 0,
            sell_started_count: 0,
            sell_get_quote_count: 0,
            sell_booking_created_count: 0,
            sell_success_count: 0,
            daily_value_sell_success: 0,
            reasons: m.reasons
          });
        }), i.value.sort((m, y) => new Date(m.date).getTime() - new Date(y.date).getTime());
      } catch (v) {
        console.error("Error fetching seller metrics:", v), r.value = h, a.value = d;
      } finally {
        n.value = !1;
      }
    };
    return Cn(f), Pn(
      () => t.dates,
      (v) => {
        v?.[0] && v?.[1] && f();
      },
      { deep: !0 }
    ), (v, g) => (O(), I("article", T8, [
      S("header", k8, [
        S("div", C8, [
          g[1] || (g[1] = S("div", { class: "title-section" }, [
            S("h3", { class: "card-title" }, "Seller Metrics"),
            S("p", { class: "card-subtitle" }, "Sales performance and failure analysis")
          ], -1)),
          S("div", P8, [
            g[0] || (g[0] = S("p", { class: "badge-label" }, "Total Sales Value", -1)),
            S("p", A8, F(G(Fy)(r.value.total_value_sell_success)), 1)
          ])
        ])
      ]),
      n.value ? (O(), I("div", E8, [...g[2] || (g[2] = [
        Kt('<div class="loading-container" data-v-bb161442><div class="chart-flow-loader" data-v-bb161442><div class="flow-line flow-1" data-v-bb161442></div><div class="flow-line flow-2" data-v-bb161442></div><div class="flow-line flow-3" data-v-bb161442></div><div class="flow-line flow-4" data-v-bb161442></div><div class="flow-line flow-5" data-v-bb161442></div></div><p class="loading-text" data-v-bb161442>Loading sales data...</p></div>', 1)
      ])])) : (O(), I("div", L8, [
        o.value.nodes.length > 0 ? (O(), I("section", O8, [
          S("div", I8, [
            Ee(po, {
              data: o.value,
              "node-colors": l.value,
              title: "",
              height: "320px"
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : (O(), I("section", R8, [...g[3] || (g[3] = [
          Kt('<div class="empty-state-content" data-v-bb161442><div class="empty-icon-wrapper" data-v-bb161442><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-bb161442><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-bb161442></path></svg></div><p class="empty-title" data-v-bb161442>No sales data available</p><p class="empty-description" data-v-bb161442>No sales data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])])),
        i.value && i.value.length > 0 ? (O(), I("section", N8, [
          S("div", F8, [
            S("table", B8, [
              g[4] || (g[4] = S("thead", null, [
                S("tr", { class: "table-header-row" }, [
                  S("th", { class: "table-header" }, "Date"),
                  S("th", { class: "table-header" }, "Sell Initiated"),
                  S("th", { class: "table-header" }, "Sell Started"),
                  S("th", { class: "table-header" }, "Get Quote"),
                  S("th", { class: "table-header" }, "Booking Created"),
                  S("th", { class: "table-header" }, "Sell Success"),
                  S("th", { class: "table-header" }, "Total Sales Value"),
                  S("th", { class: "table-header" }, "Failed")
                ])
              ], -1)),
              S("tbody", z8, [
                (O(!0), I(Ft, null, fe(i.value, (p) => (O(), I("tr", {
                  key: p.date,
                  class: "table-row"
                }, [
                  S("td", V8, F(G(z)(p.date).format("DD/MM/YYYY")), 1),
                  S("td", $8, F(G(lt)(p.seller_conversations || 0)), 1),
                  S("td", H8, F(c(p.sell_started_count, p.seller_conversations || p.sell_started_count)), 1),
                  S("td", Y8, F(c(p.sell_get_quote_count, p.seller_conversations || p.sell_started_count)), 1),
                  S("td", W8, F(c(p.sell_booking_created_count, p.seller_conversations || p.sell_started_count)), 1),
                  S("td", U8, F(c(p.sell_success_count, p.seller_conversations || p.sell_started_count)), 1),
                  S("td", G8, F(G(Fy)(p.daily_value_sell_success)), 1),
                  S("td", j8, [
                    p.reasons && p.reasons.length > 0 ? (O(), I("div", X8, [
                      (O(!0), I(Ft, null, fe(p.reasons, (_) => (O(), I("div", {
                        key: _.reason,
                        class: "failed-reason-item"
                      }, [
                        S("span", q8, F(_.reason) + ":", 1),
                        S("span", Z8, F(_.failed_count), 1)
                      ]))), 128))
                    ])) : (O(), I("div", K8, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ])
        ])) : ct("", !0)
      ]))
    ]));
  }
}), J8 = /* @__PURE__ */ de(Q8, [["__scopeId", "data-v-bb161442"]]), tW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: J8
}, Symbol.toStringTag, { value: "Module" })), eW = { class: "glass-card rounded-2xl p-6 w-full border border-purple-200/20 shadow-glass transition-all duration-300 hover:shadow-glass-lg" }, nW = { class: "flex items-center gap-4 mb-6" }, iW = {
  key: 0,
  class: "stats-badge"
}, rW = { class: "text-xs font-semibold text-white" }, aW = {
  key: 0,
  class: "flex justify-center items-center py-12"
}, oW = { class: "tooltip-content" }, sW = { class: "tooltip-title" }, lW = { class: "tooltip-stats" }, uW = { class: "tooltip-stat-row" }, cW = { class: "tooltip-value" }, hW = { class: "tooltip-stat-row" }, dW = { class: "tooltip-value" }, fW = { class: "tooltip-stat-row" }, vW = { class: "tooltip-value" }, pW = { class: "tooltip-stat-row" }, gW = { class: "tooltip-value" }, _W = { class: "tooltip-stat-row" }, mW = { class: "tooltip-value" }, yW = { class: "tooltip-stat-row" }, bW = { class: "tooltip-value" }, xW = {
  key: 2,
  class: "empty-state"
}, wW = { class: "empty-icon-wrapper" }, By = 400, jo = 60, zy = 90, Vy = 120, SW = {
  __name: "npsDailyMetrics",
  props: {
    dates: {
      type: Array,
      required: !0
    },
    airline_name: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = pt(null), i = pt(!0), r = pt(null), a = pt({
      visible: !1,
      x: 0,
      y: 0,
      date: "",
      min: "",
      max: "",
      q1: "",
      avg: "",
      q3: "",
      median: ""
    }), o = ut(() => {
      if (!n.value || !n.value.nps_by_day) return 800;
      const f = n.value.nps_by_day.length;
      return Math.max(800, jo * 2 + f * Vy);
    }), s = (f, v) => {
      const p = (f - 1) / 9;
      return jo + v - p * v;
    }, l = (f) => f ? z(f).format("DD-MM-YYYY") : "", u = ut(() => {
      if (!n.value || !n.value.nps_by_day || n.value.nps_by_day.length === 0)
        return [];
      const f = [], v = By - jo - zy;
      return n.value.nps_by_day.forEach((g, p) => {
        const _ = g.min_score || 0, m = g.q1_score || 0, y = g.median_score || 0, b = g.q3_score || 0, x = g.max_score || 0, w = g.average_score || 0;
        f.push({
          label: l(g.date),
          responseCount: g.nps_responses_count || 0,
          isTotal: !1,
          open: m,
          // Q1 as open
          high: x,
          // Max as high
          low: _,
          // Min as low
          close: b,
          // Q3 as close
          median: y,
          average: w,
          openY: s(m, v),
          highY: s(x, v),
          lowY: s(_, v),
          closeY: s(b, v),
          medianY: s(y, v),
          averageY: w > 0 ? s(w, v) : null,
          centerX: jo + (p + 1) * Vy
        });
      }), f;
    }), c = (f, v) => {
      if (!r.value || !v || v.horizontal) return;
      const g = r.value.getBoundingClientRect(), p = f.clientX, _ = f.clientY, m = 140, y = 160, b = 10, x = 15;
      let w = p - g.left - m / 2, M = _ - g.top - y - x;
      w = Math.max(b, Math.min(w, g.width - m - b)), M < b && (M = _ - g.top + x), M = Math.max(b, Math.min(M, g.height - y - b)), a.value = {
        visible: !0,
        x: w,
        y: M,
        date: v.label || "",
        min: v.low !== void 0 ? v.low.toFixed(1) : "N/A",
        max: v.high !== void 0 ? v.high.toFixed(1) : "N/A",
        q1: v.open !== void 0 ? v.open.toFixed(1) : "N/A",
        avg: v.average !== void 0 && v.average > 0 ? v.average.toFixed(1) : "N/A",
        q3: v.close !== void 0 ? v.close.toFixed(1) : "N/A",
        median: v.median !== void 0 ? v.median.toFixed(1) : "N/A"
      };
    }, h = () => {
      a.value.visible = !1;
    }, d = async () => {
      try {
        i.value = !0;
        const f = z(t.dates[0]).format("YYYY-MM-DD"), v = z(t.dates[1]).format("YYYY-MM-DD"), g = await GS(t.airline_name, f, v);
        console.log("NPS Daily Data received:", g), n.value = g;
      } catch (f) {
        console.error("Error fetching NPS daily data:", f), n.value = null;
      } finally {
        i.value = !1;
      }
    };
    return Cn(async () => d()), Pn(() => t.dates, async () => t.dates[0] && t.dates[1] && d()), (f, v) => (O(), I("article", eW, [
      S("header", nW, [
        v[0] || (v[0] = S("div", { class: "w-1.5 h-12 bg-gradient-purple-pink rounded-full" }, null, -1)),
        v[1] || (v[1] = S("div", { class: "flex-1" }, [
          S("h3", { class: "font-display font-bold text-xl text-gray-800 dark:text-gray-100" }, " NPS Daily Metrics "),
          S("p", { class: "text-sm text-gray-500 dark:text-gray-400 font-sans" }, " Daily NPS Distribution ")
        ], -1)),
        n.value && n.value.nps_by_day && n.value.nps_by_day.length > 0 ? (O(), I("div", iW, [
          S("span", rW, F(n.value.nps_by_day.length) + " days ", 1)
        ])) : ct("", !0)
      ]),
      i.value ? (O(), I("div", aW, [...v[2] || (v[2] = [
        S("div", { class: "loading-spinner" }, null, -1)
      ])])) : n.value && n.value.nps_by_day && n.value.nps_by_day.length > 0 ? (O(), I("div", {
        key: 1,
        class: "chart-wrapper",
        ref_key: "chartContainerRef",
        ref: r
      }, [
        u.value && u.value.length > 0 ? (O(), Wy(Hb, {
          key: 0,
          "candlestick-data": u.value,
          "chart-width": o.value,
          "chart-height": By,
          "chart-margin": jo,
          "chart-bottom-margin": zy,
          "show-legend": !0,
          rotation: 0,
          "candle-width": 30,
          onCandleHover: c,
          onCandleLeave: h
        }, null, 8, ["candlestick-data", "chart-width"])) : ct("", !0),
        a.value.visible ? (O(), I("div", {
          key: 1,
          class: "tooltip-overlay",
          style: jr({
            left: `${a.value.x}px`,
            top: `${a.value.y}px`
          })
        }, [
          S("div", oW, [
            S("div", sW, F(a.value.date), 1),
            v[9] || (v[9] = S("div", { class: "tooltip-divider" }, null, -1)),
            S("div", lW, [
              S("div", uW, [
                v[3] || (v[3] = S("span", { class: "tooltip-label tooltip-min" }, "Min:", -1)),
                S("span", cW, F(a.value.min), 1)
              ]),
              S("div", hW, [
                v[4] || (v[4] = S("span", { class: "tooltip-label tooltip-q1" }, "Q1:", -1)),
                S("span", dW, F(a.value.q1), 1)
              ]),
              S("div", fW, [
                v[5] || (v[5] = S("span", { class: "tooltip-label tooltip-median" }, "Median:", -1)),
                S("span", vW, F(a.value.median), 1)
              ]),
              S("div", pW, [
                v[6] || (v[6] = S("span", { class: "tooltip-label tooltip-avg" }, "Avg:", -1)),
                S("span", gW, F(a.value.avg), 1)
              ]),
              S("div", _W, [
                v[7] || (v[7] = S("span", { class: "tooltip-label tooltip-q3" }, "Q3:", -1)),
                S("span", mW, F(a.value.q3), 1)
              ]),
              S("div", yW, [
                v[8] || (v[8] = S("span", { class: "tooltip-label tooltip-max" }, "Max:", -1)),
                S("span", bW, F(a.value.max), 1)
              ])
            ])
          ])
        ], 4)) : ct("", !0)
      ], 512)) : (O(), I("div", xW, [
        S("div", wW, [
          Ee(G($p), { class: "w-8 h-8 text-purple-400" })
        ]),
        v[10] || (v[10] = S("p", { class: "text-gray-600 dark:text-gray-300 text-center text-sm font-medium mb-1" }, " No daily NPS data for the selected period ", -1)),
        v[11] || (v[11] = S("span", { class: "text-xs text-gray-400 dark:text-gray-500" }, " Try adjusting the date range or check your filters ", -1))
      ]))
    ]));
  }
}, jS = /* @__PURE__ */ de(SW, [["__scopeId", "data-v-afb536d9"]]), MW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: jS
}, Symbol.toStringTag, { value: "Module" })), DW = { class: "glass-card rounded-2xl p-6 w-full border border-purple-200/20 shadow-glass transition-all duration-300 hover:shadow-glass-lg" }, TW = { class: "flex items-center gap-4 mb-6" }, kW = {
  key: 0,
  class: "stats-badge"
}, CW = { class: "text-xs font-semibold text-white" }, PW = {
  key: 0,
  class: "flex justify-center items-center py-12"
}, AW = {
  key: 1,
  class: "histogram-container"
}, EW = {
  key: 2,
  class: "empty-state"
}, LW = { class: "empty-icon-wrapper" }, OW = 500, IW = 60, RW = 80, NW = {
  __name: "npsOverviewMetrics",
  props: {
    dates: {
      type: Array,
      required: !0
    },
    airline_name: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    const t = e, n = pt(null), i = pt(!0), r = ut(() => Math.max(600, window.innerWidth * 0.85)), a = async () => {
      try {
        i.value = !0;
        const o = z(t.dates[0]).format("YYYY-MM-DD"), s = z(t.dates[1]).format("YYYY-MM-DD"), l = await GS(t.airline_name, o, s);
        console.log("NPS Overview Data received:", l), n.value = l;
      } catch (o) {
        console.error("Error fetching NPS overview data:", o), n.value = null;
      } finally {
        i.value = !1;
      }
    };
    return Cn(async () => a()), Pn(() => t.dates, async () => t.dates[0] && t.dates[1] && a()), (o, s) => (O(), I("article", DW, [
      S("header", TW, [
        s[0] || (s[0] = S("div", { class: "w-1.5 h-12 bg-gradient-cyan-purple rounded-full" }, null, -1)),
        s[1] || (s[1] = S("div", { class: "flex-1" }, [
          S("h3", { class: "font-display font-bold text-xl text-gray-800 dark:text-gray-100" }, " NPS Overview Metrics "),
          S("p", { class: "text-sm text-gray-500 dark:text-gray-400 font-sans" }, " Overall NPS Distribution ")
        ], -1)),
        n.value && n.value.total_nps_responses > 0 ? (O(), I("div", kW, [
          S("span", CW, F(n.value.total_nps_responses) + " responses ", 1)
        ])) : ct("", !0)
      ]),
      i.value ? (O(), I("div", PW, [...s[2] || (s[2] = [
        S("div", { class: "loading-spinner" }, null, -1)
      ])])) : n.value && n.value.total_nps_responses > 0 ? (O(), I("div", AW, [
        Ee(Yb, {
          histogram: n.value.histogram || [],
          "min-score": n.value.min_score || 0,
          "max-score": n.value.max_score || 0,
          "q1-score": n.value.q1_score || 0,
          "median-score": n.value.median_score || 0,
          "q3-score": n.value.q3_score || 0,
          "average-score": n.value.average_score || 0,
          "chart-width": r.value,
          "chart-height": OW,
          "chart-margin": IW,
          "chart-bottom-margin": RW
        }, null, 8, ["histogram", "min-score", "max-score", "q1-score", "median-score", "q3-score", "average-score", "chart-width"])
      ])) : (O(), I("div", EW, [
        S("div", LW, [
          Ee(G($p), { class: "w-8 h-8 text-purple-400" })
        ]),
        s[3] || (s[3] = S("p", { class: "text-gray-600 dark:text-gray-300 text-center text-sm font-medium mb-1" }, " No NPS data for the selected period ", -1)),
        s[4] || (s[4] = S("span", { class: "text-xs text-gray-400 dark:text-gray-500" }, " Try adjusting the date range or check your filters ", -1))
      ]))
    ]));
  }
}, XS = /* @__PURE__ */ de(NW, [["__scopeId", "data-v-c45c6d23"]]), FW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: XS
}, Symbol.toStringTag, { value: "Module" })), BW = { class: "nps-metrics-container" }, zW = { class: "flex flex-col gap-6" }, VW = {
  __name: "npsMetrics",
  props: {
    dates: {
      type: Array,
      required: !0
    },
    airline_name: {
      type: String,
      required: !0
    }
  },
  setup(e) {
    return (t, n) => (O(), I("div", BW, [
      n[0] || (n[0] = Kt('<header class="nps-header glass rounded-2xl p-6 mb-6 border border-purple-200/20 shadow-glass" data-v-aa9793fe><div class="flex items-center gap-4" data-v-aa9793fe><div class="icon-wrapper bg-gradient-primary p-3 rounded-xl shadow-purple-sm" data-v-aa9793fe><svg class="w-6 h-6 text-white" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-aa9793fe><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-aa9793fe></path></svg></div><div data-v-aa9793fe><h1 class="font-display text-2xl font-bold gradient-text" data-v-aa9793fe>NPS Analytics Dashboard</h1><p class="text-sm text-gray-500 dark:text-gray-400 font-sans" data-v-aa9793fe>Net Promoter Score Metrics &amp; Insights</p></div></div></header>', 1)),
      S("div", zW, [
        Ee(XS, {
          dates: e.dates,
          airline_name: e.airline_name
        }, null, 8, ["dates", "airline_name"]),
        Ee(jS, {
          dates: e.dates,
          airline_name: e.airline_name
        }, null, 8, ["dates", "airline_name"])
      ])
    ]));
  }
}, $W = /* @__PURE__ */ de(VW, [["__scopeId", "data-v-aa9793fe"]]), HW = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  default: $W
}, Symbol.toStringTag, { value: "Module" })), qW = {
  install(e) {
    e.component("KiutChartBar", () => Promise.resolve().then(() => Zk)), e.component("KiutChartLine", () => Promise.resolve().then(() => Jk)), e.component("KiutPieChart", () => Promise.resolve().then(() => iC)), e.component("KiutBoxplotChart", () => Promise.resolve().then(() => FC)), e.component("KiutCandlestickChart", () => Promise.resolve().then(() => uP)), e.component("KiutHistogramChart", () => Promise.resolve().then(() => YP)), e.component("KiutSankeyChart", () => Promise.resolve().then(() => K3)), e.component("KiutBookingManager", () => Promise.resolve().then(() => $$)), e.component("KiutCheckin", () => Promise.resolve().then(() => dH)), e.component("KiutCheckinSegments", () => Promise.resolve().then(() => VH)), e.component("KiutDisruption", () => Promise.resolve().then(() => SY)), e.component("KiutFAQ", () => Promise.resolve().then(() => YY)), e.component("KiutMessagesPerAgent", () => Promise.resolve().then(() => JY)), e.component("KiutRecordLocator", () => Promise.resolve().then(() => D8)), e.component("KiutSeller", () => Promise.resolve().then(() => tW)), e.component("KiutNpsDailyMetrics", () => Promise.resolve().then(() => MW)), e.component("KiutNpsMetrics", () => Promise.resolve().then(() => HW)), e.component("KiutNpsOverviewMetrics", () => Promise.resolve().then(() => FW));
  }
};
export {
  V$ as BookingManager,
  NC as BoxplotChart,
  Hb as CandlestickChart,
  qk as ChartBar,
  pv as ChartLine,
  hH as Checkin,
  zH as CheckinSegments,
  wY as Disruption,
  HY as FAQ,
  Yb as HistogramChart,
  QY as MessagesPerAgent,
  jS as NpsDailyMetrics,
  $W as NpsMetrics,
  XS as NpsOverviewMetrics,
  nC as PieChart,
  M8 as RecordLocator,
  po as SankeyChart,
  J8 as Seller,
  qW as default
};
//# sourceMappingURL=kiut-ui.es.js.map
