import { defineComponent as le, shallowRef as X_, h as Rd, ref as gi, onMounted as tv, onUnmounted as j_, watch as ns, toRaw as Nd, nextTick as q_, version as i2, isProxy as Z_, computed as q, toRef as ye, createElementBlock as I, openBlock as A, createVNode as fe, unref as X, normalizeStyle as qr, createCommentVNode as Q, createElementVNode as x, toDisplayString as R, Fragment as Rt, renderList as ce, onBeforeUnmount as n2, createStaticVNode as Nt, withDirectives as jp, vShow as qp, createBlock as Re, createTextVNode as _u } from "vue";
function jo(e) {
  return e + 0.5 | 0;
}
const Yn = (e, t, i) => Math.max(Math.min(e, i), t);
function Zs(e) {
  return Yn(jo(e * 2.55), 0, 255);
}
function Zn(e) {
  return Yn(jo(e * 255), 0, 255);
}
function gn(e) {
  return Yn(jo(e / 2.55) / 100, 0, 1);
}
function Zp(e) {
  return Yn(jo(e * 100), 0, 100);
}
const ni = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9, A: 10, B: 11, C: 12, D: 13, E: 14, F: 15, a: 10, b: 11, c: 12, d: 13, e: 14, f: 15 }, Fd = [..."0123456789ABCDEF"], r2 = (e) => Fd[e & 15], a2 = (e) => Fd[(e & 240) >> 4] + Fd[e & 15], rl = (e) => (e & 240) >> 4 === (e & 15), s2 = (e) => rl(e.r) && rl(e.g) && rl(e.b) && rl(e.a);
function o2(e) {
  var t = e.length, i;
  return e[0] === "#" && (t === 4 || t === 5 ? i = {
    r: 255 & ni[e[1]] * 17,
    g: 255 & ni[e[2]] * 17,
    b: 255 & ni[e[3]] * 17,
    a: t === 5 ? ni[e[4]] * 17 : 255
  } : (t === 7 || t === 9) && (i = {
    r: ni[e[1]] << 4 | ni[e[2]],
    g: ni[e[3]] << 4 | ni[e[4]],
    b: ni[e[5]] << 4 | ni[e[6]],
    a: t === 9 ? ni[e[7]] << 4 | ni[e[8]] : 255
  })), i;
}
const l2 = (e, t) => e < 255 ? t(e) : "";
function u2(e) {
  var t = s2(e) ? r2 : a2;
  return e ? "#" + t(e.r) + t(e.g) + t(e.b) + l2(e.a, t) : void 0;
}
const c2 = /^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;
function K_(e, t, i) {
  const n = t * Math.min(i, 1 - i), r = (a, s = (a + e / 30) % 12) => i - n * Math.max(Math.min(s - 3, 9 - s, 1), -1);
  return [r(0), r(8), r(4)];
}
function h2(e, t, i) {
  const n = (r, a = (r + e / 60) % 6) => i - i * t * Math.max(Math.min(a, 4 - a, 1), 0);
  return [n(5), n(3), n(1)];
}
function d2(e, t, i) {
  const n = K_(e, 1, 0.5);
  let r;
  for (t + i > 1 && (r = 1 / (t + i), t *= r, i *= r), r = 0; r < 3; r++)
    n[r] *= 1 - t - i, n[r] += t;
  return n;
}
function f2(e, t, i, n, r) {
  return e === r ? (t - i) / n + (t < i ? 6 : 0) : t === r ? (i - e) / n + 2 : (e - t) / n + 4;
}
function ev(e) {
  const i = e.r / 255, n = e.g / 255, r = e.b / 255, a = Math.max(i, n, r), s = Math.min(i, n, r), o = (a + s) / 2;
  let l, u, c;
  return a !== s && (c = a - s, u = o > 0.5 ? c / (2 - a - s) : c / (a + s), l = f2(i, n, r, c, a), l = l * 60 + 0.5), [l | 0, u || 0, o];
}
function iv(e, t, i, n) {
  return (Array.isArray(t) ? e(t[0], t[1], t[2]) : e(t, i, n)).map(Zn);
}
function nv(e, t, i) {
  return iv(K_, e, t, i);
}
function v2(e, t, i) {
  return iv(d2, e, t, i);
}
function p2(e, t, i) {
  return iv(h2, e, t, i);
}
function Q_(e) {
  return (e % 360 + 360) % 360;
}
function g2(e) {
  const t = c2.exec(e);
  let i = 255, n;
  if (!t)
    return;
  t[5] !== n && (i = t[6] ? Zs(+t[5]) : Zn(+t[5]));
  const r = Q_(+t[2]), a = +t[3] / 100, s = +t[4] / 100;
  return t[1] === "hwb" ? n = v2(r, a, s) : t[1] === "hsv" ? n = p2(r, a, s) : n = nv(r, a, s), {
    r: n[0],
    g: n[1],
    b: n[2],
    a: i
  };
}
function m2(e, t) {
  var i = ev(e);
  i[0] = Q_(i[0] + t), i = nv(i), e.r = i[0], e.g = i[1], e.b = i[2];
}
function y2(e) {
  if (!e)
    return;
  const t = ev(e), i = t[0], n = Zp(t[1]), r = Zp(t[2]);
  return e.a < 255 ? `hsla(${i}, ${n}%, ${r}%, ${gn(e.a)})` : `hsl(${i}, ${n}%, ${r}%)`;
}
const Kp = {
  x: "dark",
  Z: "light",
  Y: "re",
  X: "blu",
  W: "gr",
  V: "medium",
  U: "slate",
  A: "ee",
  T: "ol",
  S: "or",
  B: "ra",
  C: "lateg",
  D: "ights",
  R: "in",
  Q: "turquois",
  E: "hi",
  P: "ro",
  O: "al",
  N: "le",
  M: "de",
  L: "yello",
  F: "en",
  K: "ch",
  G: "arks",
  H: "ea",
  I: "ightg",
  J: "wh"
}, Qp = {
  OiceXe: "f0f8ff",
  antiquewEte: "faebd7",
  aqua: "ffff",
  aquamarRe: "7fffd4",
  azuY: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "0",
  blanKedOmond: "ffebcd",
  Xe: "ff",
  XeviTet: "8a2be2",
  bPwn: "a52a2a",
  burlywood: "deb887",
  caMtXe: "5f9ea0",
  KartYuse: "7fff00",
  KocTate: "d2691e",
  cSO: "ff7f50",
  cSnflowerXe: "6495ed",
  cSnsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "ffff",
  xXe: "8b",
  xcyan: "8b8b",
  xgTMnPd: "b8860b",
  xWay: "a9a9a9",
  xgYF: "6400",
  xgYy: "a9a9a9",
  xkhaki: "bdb76b",
  xmagFta: "8b008b",
  xTivegYF: "556b2f",
  xSange: "ff8c00",
  xScEd: "9932cc",
  xYd: "8b0000",
  xsOmon: "e9967a",
  xsHgYF: "8fbc8f",
  xUXe: "483d8b",
  xUWay: "2f4f4f",
  xUgYy: "2f4f4f",
  xQe: "ced1",
  xviTet: "9400d3",
  dAppRk: "ff1493",
  dApskyXe: "bfff",
  dimWay: "696969",
  dimgYy: "696969",
  dodgerXe: "1e90ff",
  fiYbrick: "b22222",
  flSOwEte: "fffaf0",
  foYstWAn: "228b22",
  fuKsia: "ff00ff",
  gaRsbSo: "dcdcdc",
  ghostwEte: "f8f8ff",
  gTd: "ffd700",
  gTMnPd: "daa520",
  Way: "808080",
  gYF: "8000",
  gYFLw: "adff2f",
  gYy: "808080",
  honeyMw: "f0fff0",
  hotpRk: "ff69b4",
  RdianYd: "cd5c5c",
  Rdigo: "4b0082",
  ivSy: "fffff0",
  khaki: "f0e68c",
  lavFMr: "e6e6fa",
  lavFMrXsh: "fff0f5",
  lawngYF: "7cfc00",
  NmoncEffon: "fffacd",
  ZXe: "add8e6",
  ZcSO: "f08080",
  Zcyan: "e0ffff",
  ZgTMnPdLw: "fafad2",
  ZWay: "d3d3d3",
  ZgYF: "90ee90",
  ZgYy: "d3d3d3",
  ZpRk: "ffb6c1",
  ZsOmon: "ffa07a",
  ZsHgYF: "20b2aa",
  ZskyXe: "87cefa",
  ZUWay: "778899",
  ZUgYy: "778899",
  ZstAlXe: "b0c4de",
  ZLw: "ffffe0",
  lime: "ff00",
  limegYF: "32cd32",
  lRF: "faf0e6",
  magFta: "ff00ff",
  maPon: "800000",
  VaquamarRe: "66cdaa",
  VXe: "cd",
  VScEd: "ba55d3",
  VpurpN: "9370db",
  VsHgYF: "3cb371",
  VUXe: "7b68ee",
  VsprRggYF: "fa9a",
  VQe: "48d1cc",
  VviTetYd: "c71585",
  midnightXe: "191970",
  mRtcYam: "f5fffa",
  mistyPse: "ffe4e1",
  moccasR: "ffe4b5",
  navajowEte: "ffdead",
  navy: "80",
  Tdlace: "fdf5e6",
  Tive: "808000",
  TivedBb: "6b8e23",
  Sange: "ffa500",
  SangeYd: "ff4500",
  ScEd: "da70d6",
  pOegTMnPd: "eee8aa",
  pOegYF: "98fb98",
  pOeQe: "afeeee",
  pOeviTetYd: "db7093",
  papayawEp: "ffefd5",
  pHKpuff: "ffdab9",
  peru: "cd853f",
  pRk: "ffc0cb",
  plum: "dda0dd",
  powMrXe: "b0e0e6",
  purpN: "800080",
  YbeccapurpN: "663399",
  Yd: "ff0000",
  Psybrown: "bc8f8f",
  PyOXe: "4169e1",
  saddNbPwn: "8b4513",
  sOmon: "fa8072",
  sandybPwn: "f4a460",
  sHgYF: "2e8b57",
  sHshell: "fff5ee",
  siFna: "a0522d",
  silver: "c0c0c0",
  skyXe: "87ceeb",
  UXe: "6a5acd",
  UWay: "708090",
  UgYy: "708090",
  snow: "fffafa",
  sprRggYF: "ff7f",
  stAlXe: "4682b4",
  tan: "d2b48c",
  teO: "8080",
  tEstN: "d8bfd8",
  tomato: "ff6347",
  Qe: "40e0d0",
  viTet: "ee82ee",
  JHt: "f5deb3",
  wEte: "ffffff",
  wEtesmoke: "f5f5f5",
  Lw: "ffff00",
  LwgYF: "9acd32"
};
function _2() {
  const e = {}, t = Object.keys(Qp), i = Object.keys(Kp);
  let n, r, a, s, o;
  for (n = 0; n < t.length; n++) {
    for (s = o = t[n], r = 0; r < i.length; r++)
      a = i[r], o = o.replace(a, Kp[a]);
    a = parseInt(Qp[s], 16), e[o] = [a >> 16 & 255, a >> 8 & 255, a & 255];
  }
  return e;
}
let al;
function b2(e) {
  al || (al = _2(), al.transparent = [0, 0, 0, 0]);
  const t = al[e.toLowerCase()];
  return t && {
    r: t[0],
    g: t[1],
    b: t[2],
    a: t.length === 4 ? t[3] : 255
  };
}
const x2 = /^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;
function w2(e) {
  const t = x2.exec(e);
  let i = 255, n, r, a;
  if (t) {
    if (t[7] !== n) {
      const s = +t[7];
      i = t[8] ? Zs(s) : Yn(s * 255, 0, 255);
    }
    return n = +t[1], r = +t[3], a = +t[5], n = 255 & (t[2] ? Zs(n) : Yn(n, 0, 255)), r = 255 & (t[4] ? Zs(r) : Yn(r, 0, 255)), a = 255 & (t[6] ? Zs(a) : Yn(a, 0, 255)), {
      r: n,
      g: r,
      b: a,
      a: i
    };
  }
}
function S2(e) {
  return e && (e.a < 255 ? `rgba(${e.r}, ${e.g}, ${e.b}, ${gn(e.a)})` : `rgb(${e.r}, ${e.g}, ${e.b})`);
}
const th = (e) => e <= 31308e-7 ? e * 12.92 : Math.pow(e, 1 / 2.4) * 1.055 - 0.055, ma = (e) => e <= 0.04045 ? e / 12.92 : Math.pow((e + 0.055) / 1.055, 2.4);
function M2(e, t, i) {
  const n = ma(gn(e.r)), r = ma(gn(e.g)), a = ma(gn(e.b));
  return {
    r: Zn(th(n + i * (ma(gn(t.r)) - n))),
    g: Zn(th(r + i * (ma(gn(t.g)) - r))),
    b: Zn(th(a + i * (ma(gn(t.b)) - a))),
    a: e.a + i * (t.a - e.a)
  };
}
function sl(e, t, i) {
  if (e) {
    let n = ev(e);
    n[t] = Math.max(0, Math.min(n[t] + n[t] * i, t === 0 ? 360 : 1)), n = nv(n), e.r = n[0], e.g = n[1], e.b = n[2];
  }
}
function J_(e, t) {
  return e && Object.assign(t || {}, e);
}
function Jp(e) {
  var t = { r: 0, g: 0, b: 0, a: 255 };
  return Array.isArray(e) ? e.length >= 3 && (t = { r: e[0], g: e[1], b: e[2], a: 255 }, e.length > 3 && (t.a = Zn(e[3]))) : (t = J_(e, { r: 0, g: 0, b: 0, a: 1 }), t.a = Zn(t.a)), t;
}
function k2(e) {
  return e.charAt(0) === "r" ? w2(e) : g2(e);
}
class So {
  constructor(t) {
    if (t instanceof So)
      return t;
    const i = typeof t;
    let n;
    i === "object" ? n = Jp(t) : i === "string" && (n = o2(t) || b2(t) || k2(t)), this._rgb = n, this._valid = !!n;
  }
  get valid() {
    return this._valid;
  }
  get rgb() {
    var t = J_(this._rgb);
    return t && (t.a = gn(t.a)), t;
  }
  set rgb(t) {
    this._rgb = Jp(t);
  }
  rgbString() {
    return this._valid ? S2(this._rgb) : void 0;
  }
  hexString() {
    return this._valid ? u2(this._rgb) : void 0;
  }
  hslString() {
    return this._valid ? y2(this._rgb) : void 0;
  }
  mix(t, i) {
    if (t) {
      const n = this.rgb, r = t.rgb;
      let a;
      const s = i === a ? 0.5 : i, o = 2 * s - 1, l = n.a - r.a, u = ((o * l === -1 ? o : (o + l) / (1 + o * l)) + 1) / 2;
      a = 1 - u, n.r = 255 & u * n.r + a * r.r + 0.5, n.g = 255 & u * n.g + a * r.g + 0.5, n.b = 255 & u * n.b + a * r.b + 0.5, n.a = s * n.a + (1 - s) * r.a, this.rgb = n;
    }
    return this;
  }
  interpolate(t, i) {
    return t && (this._rgb = M2(this._rgb, t._rgb, i)), this;
  }
  clone() {
    return new So(this.rgb);
  }
  alpha(t) {
    return this._rgb.a = Zn(t), this;
  }
  clearer(t) {
    const i = this._rgb;
    return i.a *= 1 - t, this;
  }
  greyscale() {
    const t = this._rgb, i = jo(t.r * 0.3 + t.g * 0.59 + t.b * 0.11);
    return t.r = t.g = t.b = i, this;
  }
  opaquer(t) {
    const i = this._rgb;
    return i.a *= 1 + t, this;
  }
  negate() {
    const t = this._rgb;
    return t.r = 255 - t.r, t.g = 255 - t.g, t.b = 255 - t.b, this;
  }
  lighten(t) {
    return sl(this._rgb, 2, t), this;
  }
  darken(t) {
    return sl(this._rgb, 2, -t), this;
  }
  saturate(t) {
    return sl(this._rgb, 1, t), this;
  }
  desaturate(t) {
    return sl(this._rgb, 1, -t), this;
  }
  rotate(t) {
    return m2(this._rgb, t), this;
  }
}
function sn() {
}
const D2 = /* @__PURE__ */ (() => {
  let e = 0;
  return () => e++;
})();
function kt(e) {
  return e == null;
}
function ae(e) {
  if (Array.isArray && Array.isArray(e))
    return !0;
  const t = Object.prototype.toString.call(e);
  return t.slice(0, 7) === "[object" && t.slice(-6) === "Array]";
}
function vt(e) {
  return e !== null && Object.prototype.toString.call(e) === "[object Object]";
}
function Ce(e) {
  return (typeof e == "number" || e instanceof Number) && isFinite(+e);
}
function Fi(e, t) {
  return Ce(e) ? e : t;
}
function ct(e, t) {
  return typeof e > "u" ? t : e;
}
const T2 = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 : +e / t, tb = (e, t) => typeof e == "string" && e.endsWith("%") ? parseFloat(e) / 100 * t : +e;
function zt(e, t, i) {
  if (e && typeof e.call == "function")
    return e.apply(i, t);
}
function Ct(e, t, i, n) {
  let r, a, s;
  if (ae(e))
    for (a = e.length, r = 0; r < a; r++)
      t.call(i, e[r], r);
  else if (vt(e))
    for (s = Object.keys(e), a = s.length, r = 0; r < a; r++)
      t.call(i, e[s[r]], s[r]);
}
function bu(e, t) {
  let i, n, r, a;
  if (!e || !t || e.length !== t.length)
    return !1;
  for (i = 0, n = e.length; i < n; ++i)
    if (r = e[i], a = t[i], r.datasetIndex !== a.datasetIndex || r.index !== a.index)
      return !1;
  return !0;
}
function xu(e) {
  if (ae(e))
    return e.map(xu);
  if (vt(e)) {
    const t = /* @__PURE__ */ Object.create(null), i = Object.keys(e), n = i.length;
    let r = 0;
    for (; r < n; ++r)
      t[i[r]] = xu(e[i[r]]);
    return t;
  }
  return e;
}
function eb(e) {
  return [
    "__proto__",
    "prototype",
    "constructor"
  ].indexOf(e) === -1;
}
function C2(e, t, i, n) {
  if (!eb(e))
    return;
  const r = t[e], a = i[e];
  vt(r) && vt(a) ? Mo(r, a, n) : t[e] = xu(a);
}
function Mo(e, t, i) {
  const n = ae(t) ? t : [
    t
  ], r = n.length;
  if (!vt(e))
    return e;
  i = i || {};
  const a = i.merger || C2;
  let s;
  for (let o = 0; o < r; ++o) {
    if (s = n[o], !vt(s))
      continue;
    const l = Object.keys(s);
    for (let u = 0, c = l.length; u < c; ++u)
      a(l[u], e, s, i);
  }
  return e;
}
function lo(e, t) {
  return Mo(e, t, {
    merger: E2
  });
}
function E2(e, t, i) {
  if (!eb(e))
    return;
  const n = t[e], r = i[e];
  vt(n) && vt(r) ? lo(n, r) : Object.prototype.hasOwnProperty.call(t, e) || (t[e] = xu(r));
}
const tg = {
  // Chart.helpers.core resolveObjectKey should resolve empty key to root object
  "": (e) => e,
  // default resolvers
  x: (e) => e.x,
  y: (e) => e.y
};
function A2(e) {
  const t = e.split("."), i = [];
  let n = "";
  for (const r of t)
    n += r, n.endsWith("\\") ? n = n.slice(0, -1) + "." : (i.push(n), n = "");
  return i;
}
function P2(e) {
  const t = A2(e);
  return (i) => {
    for (const n of t) {
      if (n === "")
        break;
      i = i && i[n];
    }
    return i;
  };
}
function sa(e, t) {
  return (tg[t] || (tg[t] = P2(t)))(e);
}
function rv(e) {
  return e.charAt(0).toUpperCase() + e.slice(1);
}
const ko = (e) => typeof e < "u", ir = (e) => typeof e == "function", eg = (e, t) => {
  if (e.size !== t.size)
    return !1;
  for (const i of e)
    if (!t.has(i))
      return !1;
  return !0;
};
function L2(e) {
  return e.type === "mouseup" || e.type === "click" || e.type === "contextmenu";
}
const Et = Math.PI, Xt = 2 * Et, O2 = Xt + Et, wu = Number.POSITIVE_INFINITY, I2 = Et / 180, he = Et / 2, ur = Et / 4, ig = Et * 2 / 3, ib = Math.log10, qi = Math.sign;
function uo(e, t, i) {
  return Math.abs(e - t) < i;
}
function ng(e) {
  const t = Math.round(e);
  e = uo(e, t, e / 1e3) ? t : e;
  const i = Math.pow(10, Math.floor(ib(e))), n = e / i;
  return (n <= 1 ? 1 : n <= 2 ? 2 : n <= 5 ? 5 : 10) * i;
}
function R2(e) {
  const t = [], i = Math.sqrt(e);
  let n;
  for (n = 1; n < i; n++)
    e % n === 0 && (t.push(n), t.push(e / n));
  return i === (i | 0) && t.push(i), t.sort((r, a) => r - a).pop(), t;
}
function N2(e) {
  return typeof e == "symbol" || typeof e == "object" && e !== null && !(Symbol.toPrimitive in e || "toString" in e || "valueOf" in e);
}
function Do(e) {
  return !N2(e) && !isNaN(parseFloat(e)) && isFinite(e);
}
function F2(e, t) {
  const i = Math.round(e);
  return i - t <= e && i + t >= e;
}
function B2(e, t, i) {
  let n, r, a;
  for (n = 0, r = e.length; n < r; n++)
    a = e[n][i], isNaN(a) || (t.min = Math.min(t.min, a), t.max = Math.max(t.max, a));
}
function mn(e) {
  return e * (Et / 180);
}
function $2(e) {
  return e * (180 / Et);
}
function rg(e) {
  if (!Ce(e))
    return;
  let t = 1, i = 0;
  for (; Math.round(e * t) / t !== e; )
    t *= 10, i++;
  return i;
}
function nb(e, t) {
  const i = t.x - e.x, n = t.y - e.y, r = Math.sqrt(i * i + n * n);
  let a = Math.atan2(n, i);
  return a < -0.5 * Et && (a += Xt), {
    angle: a,
    distance: r
  };
}
function Bd(e, t) {
  return Math.sqrt(Math.pow(t.x - e.x, 2) + Math.pow(t.y - e.y, 2));
}
function z2(e, t) {
  return (e - t + O2) % Xt - Et;
}
function qe(e) {
  return (e % Xt + Xt) % Xt;
}
function To(e, t, i, n) {
  const r = qe(e), a = qe(t), s = qe(i), o = qe(a - r), l = qe(s - r), u = qe(r - a), c = qe(r - s);
  return r === a || r === s || n && a === s || o > l && u < c;
}
function Se(e, t, i) {
  return Math.max(t, Math.min(i, e));
}
function V2(e) {
  return Se(e, -32768, 32767);
}
function yn(e, t, i, n = 1e-6) {
  return e >= Math.min(t, i) - n && e <= Math.max(t, i) + n;
}
function av(e, t, i) {
  i = i || ((s) => e[s] < t);
  let n = e.length - 1, r = 0, a;
  for (; n - r > 1; )
    a = r + n >> 1, i(a) ? r = a : n = a;
  return {
    lo: r,
    hi: n
  };
}
const Hr = (e, t, i, n) => av(e, i, n ? (r) => {
  const a = e[r][t];
  return a < i || a === i && e[r + 1][t] === i;
} : (r) => e[r][t] < i), H2 = (e, t, i) => av(e, i, (n) => e[n][t] >= i);
function Y2(e, t, i) {
  let n = 0, r = e.length;
  for (; n < r && e[n] < t; )
    n++;
  for (; r > n && e[r - 1] > i; )
    r--;
  return n > 0 || r < e.length ? e.slice(n, r) : e;
}
const rb = [
  "push",
  "pop",
  "shift",
  "splice",
  "unshift"
];
function W2(e, t) {
  if (e._chartjs) {
    e._chartjs.listeners.push(t);
    return;
  }
  Object.defineProperty(e, "_chartjs", {
    configurable: !0,
    enumerable: !1,
    value: {
      listeners: [
        t
      ]
    }
  }), rb.forEach((i) => {
    const n = "_onData" + rv(i), r = e[i];
    Object.defineProperty(e, i, {
      configurable: !0,
      enumerable: !1,
      value(...a) {
        const s = r.apply(this, a);
        return e._chartjs.listeners.forEach((o) => {
          typeof o[n] == "function" && o[n](...a);
        }), s;
      }
    });
  });
}
function ag(e, t) {
  const i = e._chartjs;
  if (!i)
    return;
  const n = i.listeners, r = n.indexOf(t);
  r !== -1 && n.splice(r, 1), !(n.length > 0) && (rb.forEach((a) => {
    delete e[a];
  }), delete e._chartjs);
}
function ab(e) {
  const t = new Set(e);
  return t.size === e.length ? e : Array.from(t);
}
const sb = (function() {
  return typeof window > "u" ? function(e) {
    return e();
  } : window.requestAnimationFrame;
})();
function ob(e, t) {
  let i = [], n = !1;
  return function(...r) {
    i = r, n || (n = !0, sb.call(window, () => {
      n = !1, e.apply(t, i);
    }));
  };
}
function U2(e, t) {
  let i;
  return function(...n) {
    return t ? (clearTimeout(i), i = setTimeout(e, t, n)) : e.apply(this, n), t;
  };
}
const sv = (e) => e === "start" ? "left" : e === "end" ? "right" : "center", xe = (e, t, i) => e === "start" ? t : e === "end" ? i : (t + i) / 2, G2 = (e, t, i, n) => e === (n ? "left" : "right") ? i : e === "center" ? (t + i) / 2 : t;
function X2(e, t, i) {
  const n = t.length;
  let r = 0, a = n;
  if (e._sorted) {
    const { iScale: s, vScale: o, _parsed: l } = e, u = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null, c = s.axis, { min: h, max: d, minDefined: f, maxDefined: v } = s.getUserBounds();
    if (f) {
      if (r = Math.min(
        // @ts-expect-error Need to type _parsed
        Hr(l, c, h).lo,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? n : Hr(t, c, s.getPixelForValue(h)).lo
      ), u) {
        const m = l.slice(0, r + 1).reverse().findIndex((p) => !kt(p[o.axis]));
        r -= Math.max(0, m);
      }
      r = Se(r, 0, n - 1);
    }
    if (v) {
      let m = Math.max(
        // @ts-expect-error Need to type _parsed
        Hr(l, s.axis, d, !0).hi + 1,
        // @ts-expect-error Need to fix types on _lookupByKey
        i ? 0 : Hr(t, c, s.getPixelForValue(d), !0).hi + 1
      );
      if (u) {
        const p = l.slice(m - 1).findIndex((g) => !kt(g[o.axis]));
        m += Math.max(0, p);
      }
      a = Se(m, r, n) - r;
    } else
      a = n - r;
  }
  return {
    start: r,
    count: a
  };
}
function j2(e) {
  const { xScale: t, yScale: i, _scaleRanges: n } = e, r = {
    xmin: t.min,
    xmax: t.max,
    ymin: i.min,
    ymax: i.max
  };
  if (!n)
    return e._scaleRanges = r, !0;
  const a = n.xmin !== t.min || n.xmax !== t.max || n.ymin !== i.min || n.ymax !== i.max;
  return Object.assign(n, r), a;
}
const ol = (e) => e === 0 || e === 1, sg = (e, t, i) => -(Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * Xt / i)), og = (e, t, i) => Math.pow(2, -10 * e) * Math.sin((e - t) * Xt / i) + 1, co = {
  linear: (e) => e,
  easeInQuad: (e) => e * e,
  easeOutQuad: (e) => -e * (e - 2),
  easeInOutQuad: (e) => (e /= 0.5) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1),
  easeInCubic: (e) => e * e * e,
  easeOutCubic: (e) => (e -= 1) * e * e + 1,
  easeInOutCubic: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2),
  easeInQuart: (e) => e * e * e * e,
  easeOutQuart: (e) => -((e -= 1) * e * e * e - 1),
  easeInOutQuart: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2),
  easeInQuint: (e) => e * e * e * e * e,
  easeOutQuint: (e) => (e -= 1) * e * e * e * e + 1,
  easeInOutQuint: (e) => (e /= 0.5) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2),
  easeInSine: (e) => -Math.cos(e * he) + 1,
  easeOutSine: (e) => Math.sin(e * he),
  easeInOutSine: (e) => -0.5 * (Math.cos(Et * e) - 1),
  easeInExpo: (e) => e === 0 ? 0 : Math.pow(2, 10 * (e - 1)),
  easeOutExpo: (e) => e === 1 ? 1 : -Math.pow(2, -10 * e) + 1,
  easeInOutExpo: (e) => ol(e) ? e : e < 0.5 ? 0.5 * Math.pow(2, 10 * (e * 2 - 1)) : 0.5 * (-Math.pow(2, -10 * (e * 2 - 1)) + 2),
  easeInCirc: (e) => e >= 1 ? e : -(Math.sqrt(1 - e * e) - 1),
  easeOutCirc: (e) => Math.sqrt(1 - (e -= 1) * e),
  easeInOutCirc: (e) => (e /= 0.5) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1),
  easeInElastic: (e) => ol(e) ? e : sg(e, 0.075, 0.3),
  easeOutElastic: (e) => ol(e) ? e : og(e, 0.075, 0.3),
  easeInOutElastic(e) {
    return ol(e) ? e : e < 0.5 ? 0.5 * sg(e * 2, 0.1125, 0.45) : 0.5 + 0.5 * og(e * 2 - 1, 0.1125, 0.45);
  },
  easeInBack(e) {
    return e * e * ((1.70158 + 1) * e - 1.70158);
  },
  easeOutBack(e) {
    return (e -= 1) * e * ((1.70158 + 1) * e + 1.70158) + 1;
  },
  easeInOutBack(e) {
    let t = 1.70158;
    return (e /= 0.5) < 1 ? 0.5 * (e * e * (((t *= 1.525) + 1) * e - t)) : 0.5 * ((e -= 2) * e * (((t *= 1.525) + 1) * e + t) + 2);
  },
  easeInBounce: (e) => 1 - co.easeOutBounce(1 - e),
  easeOutBounce(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  easeInOutBounce: (e) => e < 0.5 ? co.easeInBounce(e * 2) * 0.5 : co.easeOutBounce(e * 2 - 1) * 0.5 + 0.5
};
function ov(e) {
  if (e && typeof e == "object") {
    const t = e.toString();
    return t === "[object CanvasPattern]" || t === "[object CanvasGradient]";
  }
  return !1;
}
function lg(e) {
  return ov(e) ? e : new So(e);
}
function eh(e) {
  return ov(e) ? e : new So(e).saturate(0.5).darken(0.1).hexString();
}
const q2 = [
  "x",
  "y",
  "borderWidth",
  "radius",
  "tension"
], Z2 = [
  "color",
  "borderColor",
  "backgroundColor"
];
function K2(e) {
  e.set("animation", {
    delay: void 0,
    duration: 1e3,
    easing: "easeOutQuart",
    fn: void 0,
    from: void 0,
    loop: void 0,
    to: void 0,
    type: void 0
  }), e.describe("animation", {
    _fallback: !1,
    _indexable: !1,
    _scriptable: (t) => t !== "onProgress" && t !== "onComplete" && t !== "fn"
  }), e.set("animations", {
    colors: {
      type: "color",
      properties: Z2
    },
    numbers: {
      type: "number",
      properties: q2
    }
  }), e.describe("animations", {
    _fallback: "animation"
  }), e.set("transitions", {
    active: {
      animation: {
        duration: 400
      }
    },
    resize: {
      animation: {
        duration: 0
      }
    },
    show: {
      animations: {
        colors: {
          from: "transparent"
        },
        visible: {
          type: "boolean",
          duration: 0
        }
      }
    },
    hide: {
      animations: {
        colors: {
          to: "transparent"
        },
        visible: {
          type: "boolean",
          easing: "linear",
          fn: (t) => t | 0
        }
      }
    }
  });
}
function Q2(e) {
  e.set("layout", {
    autoPadding: !0,
    padding: {
      top: 0,
      right: 0,
      bottom: 0,
      left: 0
    }
  });
}
const ug = /* @__PURE__ */ new Map();
function J2(e, t) {
  t = t || {};
  const i = e + JSON.stringify(t);
  let n = ug.get(i);
  return n || (n = new Intl.NumberFormat(e, t), ug.set(i, n)), n;
}
function lv(e, t, i) {
  return J2(t, i).format(e);
}
const tM = {
  values(e) {
    return ae(e) ? e : "" + e;
  },
  numeric(e, t, i) {
    if (e === 0)
      return "0";
    const n = this.chart.options.locale;
    let r, a = e;
    if (i.length > 1) {
      const u = Math.max(Math.abs(i[0].value), Math.abs(i[i.length - 1].value));
      (u < 1e-4 || u > 1e15) && (r = "scientific"), a = eM(e, i);
    }
    const s = ib(Math.abs(a)), o = isNaN(s) ? 1 : Math.max(Math.min(-1 * Math.floor(s), 20), 0), l = {
      notation: r,
      minimumFractionDigits: o,
      maximumFractionDigits: o
    };
    return Object.assign(l, this.options.ticks.format), lv(e, n, l);
  }
};
function eM(e, t) {
  let i = t.length > 3 ? t[2].value - t[1].value : t[1].value - t[0].value;
  return Math.abs(i) >= 1 && e !== Math.floor(e) && (i = e - Math.floor(e)), i;
}
var lb = {
  formatters: tM
};
function iM(e) {
  e.set("scale", {
    display: !0,
    offset: !1,
    reverse: !1,
    beginAtZero: !1,
    bounds: "ticks",
    clip: !0,
    grace: 0,
    grid: {
      display: !0,
      lineWidth: 1,
      drawOnChartArea: !0,
      drawTicks: !0,
      tickLength: 8,
      tickWidth: (t, i) => i.lineWidth,
      tickColor: (t, i) => i.color,
      offset: !1
    },
    border: {
      display: !0,
      dash: [],
      dashOffset: 0,
      width: 1
    },
    title: {
      display: !1,
      text: "",
      padding: {
        top: 4,
        bottom: 4
      }
    },
    ticks: {
      minRotation: 0,
      maxRotation: 50,
      mirror: !1,
      textStrokeWidth: 0,
      textStrokeColor: "",
      padding: 3,
      display: !0,
      autoSkip: !0,
      autoSkipPadding: 3,
      labelOffset: 0,
      callback: lb.formatters.values,
      minor: {},
      major: {},
      align: "center",
      crossAlign: "near",
      showLabelBackdrop: !1,
      backdropColor: "rgba(255, 255, 255, 0.75)",
      backdropPadding: 2
    }
  }), e.route("scale.ticks", "color", "", "color"), e.route("scale.grid", "color", "", "borderColor"), e.route("scale.border", "color", "", "borderColor"), e.route("scale.title", "color", "", "color"), e.describe("scale", {
    _fallback: !1,
    _scriptable: (t) => !t.startsWith("before") && !t.startsWith("after") && t !== "callback" && t !== "parser",
    _indexable: (t) => t !== "borderDash" && t !== "tickBorderDash" && t !== "dash"
  }), e.describe("scales", {
    _fallback: "scale"
  }), e.describe("scale.ticks", {
    _scriptable: (t) => t !== "backdropPadding" && t !== "callback",
    _indexable: (t) => t !== "backdropPadding"
  });
}
const oa = /* @__PURE__ */ Object.create(null), $d = /* @__PURE__ */ Object.create(null);
function ho(e, t) {
  if (!t)
    return e;
  const i = t.split(".");
  for (let n = 0, r = i.length; n < r; ++n) {
    const a = i[n];
    e = e[a] || (e[a] = /* @__PURE__ */ Object.create(null));
  }
  return e;
}
function ih(e, t, i) {
  return typeof t == "string" ? Mo(ho(e, t), i) : Mo(ho(e, ""), t);
}
class nM {
  constructor(t, i) {
    this.animation = void 0, this.backgroundColor = "rgba(0,0,0,0.1)", this.borderColor = "rgba(0,0,0,0.1)", this.color = "#666", this.datasets = {}, this.devicePixelRatio = (n) => n.chart.platform.getDevicePixelRatio(), this.elements = {}, this.events = [
      "mousemove",
      "mouseout",
      "click",
      "touchstart",
      "touchmove"
    ], this.font = {
      family: "'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",
      size: 12,
      style: "normal",
      lineHeight: 1.2,
      weight: null
    }, this.hover = {}, this.hoverBackgroundColor = (n, r) => eh(r.backgroundColor), this.hoverBorderColor = (n, r) => eh(r.borderColor), this.hoverColor = (n, r) => eh(r.color), this.indexAxis = "x", this.interaction = {
      mode: "nearest",
      intersect: !0,
      includeInvisible: !1
    }, this.maintainAspectRatio = !0, this.onHover = null, this.onClick = null, this.parsing = !0, this.plugins = {}, this.responsive = !0, this.scale = void 0, this.scales = {}, this.showLine = !0, this.drawActiveElementsOnTop = !0, this.describe(t), this.apply(i);
  }
  set(t, i) {
    return ih(this, t, i);
  }
  get(t) {
    return ho(this, t);
  }
  describe(t, i) {
    return ih($d, t, i);
  }
  override(t, i) {
    return ih(oa, t, i);
  }
  route(t, i, n, r) {
    const a = ho(this, t), s = ho(this, n), o = "_" + i;
    Object.defineProperties(a, {
      [o]: {
        value: a[i],
        writable: !0
      },
      [i]: {
        enumerable: !0,
        get() {
          const l = this[o], u = s[r];
          return vt(l) ? Object.assign({}, u, l) : ct(l, u);
        },
        set(l) {
          this[o] = l;
        }
      }
    });
  }
  apply(t) {
    t.forEach((i) => i(this));
  }
}
var ne = /* @__PURE__ */ new nM({
  _scriptable: (e) => !e.startsWith("on"),
  _indexable: (e) => e !== "events",
  hover: {
    _fallback: "interaction"
  },
  interaction: {
    _scriptable: !1,
    _indexable: !1
  }
}, [
  K2,
  Q2,
  iM
]);
function rM(e) {
  return !e || kt(e.size) || kt(e.family) ? null : (e.style ? e.style + " " : "") + (e.weight ? e.weight + " " : "") + e.size + "px " + e.family;
}
function cg(e, t, i, n, r) {
  let a = t[r];
  return a || (a = t[r] = e.measureText(r).width, i.push(r)), a > n && (n = a), n;
}
function cr(e, t, i) {
  const n = e.currentDevicePixelRatio, r = i !== 0 ? Math.max(i / 2, 0.5) : 0;
  return Math.round((t - r) * n) / n + r;
}
function hg(e, t) {
  !t && !e || (t = t || e.getContext("2d"), t.save(), t.resetTransform(), t.clearRect(0, 0, e.width, e.height), t.restore());
}
function zd(e, t, i, n) {
  ub(e, t, i, n, null);
}
function ub(e, t, i, n, r) {
  let a, s, o, l, u, c, h, d;
  const f = t.pointStyle, v = t.rotation, m = t.radius;
  let p = (v || 0) * I2;
  if (f && typeof f == "object" && (a = f.toString(), a === "[object HTMLImageElement]" || a === "[object HTMLCanvasElement]")) {
    e.save(), e.translate(i, n), e.rotate(p), e.drawImage(f, -f.width / 2, -f.height / 2, f.width, f.height), e.restore();
    return;
  }
  if (!(isNaN(m) || m <= 0)) {
    switch (e.beginPath(), f) {
      // Default includes circle
      default:
        r ? e.ellipse(i, n, r / 2, m, 0, 0, Xt) : e.arc(i, n, m, 0, Xt), e.closePath();
        break;
      case "triangle":
        c = r ? r / 2 : m, e.moveTo(i + Math.sin(p) * c, n - Math.cos(p) * m), p += ig, e.lineTo(i + Math.sin(p) * c, n - Math.cos(p) * m), p += ig, e.lineTo(i + Math.sin(p) * c, n - Math.cos(p) * m), e.closePath();
        break;
      case "rectRounded":
        u = m * 0.516, l = m - u, s = Math.cos(p + ur) * l, h = Math.cos(p + ur) * (r ? r / 2 - u : l), o = Math.sin(p + ur) * l, d = Math.sin(p + ur) * (r ? r / 2 - u : l), e.arc(i - h, n - o, u, p - Et, p - he), e.arc(i + d, n - s, u, p - he, p), e.arc(i + h, n + o, u, p, p + he), e.arc(i - d, n + s, u, p + he, p + Et), e.closePath();
        break;
      case "rect":
        if (!v) {
          l = Math.SQRT1_2 * m, c = r ? r / 2 : l, e.rect(i - c, n - l, 2 * c, 2 * l);
          break;
        }
        p += ur;
      /* falls through */
      case "rectRot":
        h = Math.cos(p) * (r ? r / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - o), e.lineTo(i + d, n - s), e.lineTo(i + h, n + o), e.lineTo(i - d, n + s), e.closePath();
        break;
      case "crossRot":
        p += ur;
      /* falls through */
      case "cross":
        h = Math.cos(p) * (r ? r / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + d, n - s), e.lineTo(i - d, n + s);
        break;
      case "star":
        h = Math.cos(p) * (r ? r / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + d, n - s), e.lineTo(i - d, n + s), p += ur, h = Math.cos(p) * (r ? r / 2 : m), s = Math.cos(p) * m, o = Math.sin(p) * m, d = Math.sin(p) * (r ? r / 2 : m), e.moveTo(i - h, n - o), e.lineTo(i + h, n + o), e.moveTo(i + d, n - s), e.lineTo(i - d, n + s);
        break;
      case "line":
        s = r ? r / 2 : Math.cos(p) * m, o = Math.sin(p) * m, e.moveTo(i - s, n - o), e.lineTo(i + s, n + o);
        break;
      case "dash":
        e.moveTo(i, n), e.lineTo(i + Math.cos(p) * (r ? r / 2 : m), n + Math.sin(p) * m);
        break;
      case !1:
        e.closePath();
        break;
    }
    e.fill(), t.borderWidth > 0 && e.stroke();
  }
}
function Co(e, t, i) {
  return i = i || 0.5, !t || e && e.x > t.left - i && e.x < t.right + i && e.y > t.top - i && e.y < t.bottom + i;
}
function gc(e, t) {
  e.save(), e.beginPath(), e.rect(t.left, t.top, t.right - t.left, t.bottom - t.top), e.clip();
}
function mc(e) {
  e.restore();
}
function aM(e, t, i, n, r) {
  if (!t)
    return e.lineTo(i.x, i.y);
  if (r === "middle") {
    const a = (t.x + i.x) / 2;
    e.lineTo(a, t.y), e.lineTo(a, i.y);
  } else r === "after" != !!n ? e.lineTo(t.x, i.y) : e.lineTo(i.x, t.y);
  e.lineTo(i.x, i.y);
}
function sM(e, t, i, n) {
  if (!t)
    return e.lineTo(i.x, i.y);
  e.bezierCurveTo(n ? t.cp1x : t.cp2x, n ? t.cp1y : t.cp2y, n ? i.cp2x : i.cp1x, n ? i.cp2y : i.cp1y, i.x, i.y);
}
function oM(e, t) {
  t.translation && e.translate(t.translation[0], t.translation[1]), kt(t.rotation) || e.rotate(t.rotation), t.color && (e.fillStyle = t.color), t.textAlign && (e.textAlign = t.textAlign), t.textBaseline && (e.textBaseline = t.textBaseline);
}
function lM(e, t, i, n, r) {
  if (r.strikethrough || r.underline) {
    const a = e.measureText(n), s = t - a.actualBoundingBoxLeft, o = t + a.actualBoundingBoxRight, l = i - a.actualBoundingBoxAscent, u = i + a.actualBoundingBoxDescent, c = r.strikethrough ? (l + u) / 2 : u;
    e.strokeStyle = e.fillStyle, e.beginPath(), e.lineWidth = r.decorationWidth || 2, e.moveTo(s, c), e.lineTo(o, c), e.stroke();
  }
}
function uM(e, t) {
  const i = e.fillStyle;
  e.fillStyle = t.color, e.fillRect(t.left, t.top, t.width, t.height), e.fillStyle = i;
}
function Eo(e, t, i, n, r, a = {}) {
  const s = ae(t) ? t : [
    t
  ], o = a.strokeWidth > 0 && a.strokeColor !== "";
  let l, u;
  for (e.save(), e.font = r.string, oM(e, a), l = 0; l < s.length; ++l)
    u = s[l], a.backdrop && uM(e, a.backdrop), o && (a.strokeColor && (e.strokeStyle = a.strokeColor), kt(a.strokeWidth) || (e.lineWidth = a.strokeWidth), e.strokeText(u, i, n, a.maxWidth)), e.fillText(u, i, n, a.maxWidth), lM(e, i, n, u, a), n += Number(r.lineHeight);
  e.restore();
}
function Su(e, t) {
  const { x: i, y: n, w: r, h: a, radius: s } = t;
  e.arc(i + s.topLeft, n + s.topLeft, s.topLeft, 1.5 * Et, Et, !0), e.lineTo(i, n + a - s.bottomLeft), e.arc(i + s.bottomLeft, n + a - s.bottomLeft, s.bottomLeft, Et, he, !0), e.lineTo(i + r - s.bottomRight, n + a), e.arc(i + r - s.bottomRight, n + a - s.bottomRight, s.bottomRight, he, 0, !0), e.lineTo(i + r, n + s.topRight), e.arc(i + r - s.topRight, n + s.topRight, s.topRight, 0, -he, !0), e.lineTo(i + s.topLeft, n);
}
const cM = /^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/, hM = /^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;
function dM(e, t) {
  const i = ("" + e).match(cM);
  if (!i || i[1] === "normal")
    return t * 1.2;
  switch (e = +i[2], i[3]) {
    case "px":
      return e;
    case "%":
      e /= 100;
      break;
  }
  return t * e;
}
const fM = (e) => +e || 0;
function uv(e, t) {
  const i = {}, n = vt(t), r = n ? Object.keys(t) : t, a = vt(e) ? n ? (s) => ct(e[s], e[t[s]]) : (s) => e[s] : () => e;
  for (const s of r)
    i[s] = fM(a(s));
  return i;
}
function cb(e) {
  return uv(e, {
    top: "y",
    right: "x",
    bottom: "y",
    left: "x"
  });
}
function ja(e) {
  return uv(e, [
    "topLeft",
    "topRight",
    "bottomLeft",
    "bottomRight"
  ]);
}
function yi(e) {
  const t = cb(e);
  return t.width = t.left + t.right, t.height = t.top + t.bottom, t;
}
function Me(e, t) {
  e = e || {}, t = t || ne.font;
  let i = ct(e.size, t.size);
  typeof i == "string" && (i = parseInt(i, 10));
  let n = ct(e.style, t.style);
  n && !("" + n).match(hM) && (console.warn('Invalid font style specified: "' + n + '"'), n = void 0);
  const r = {
    family: ct(e.family, t.family),
    lineHeight: dM(ct(e.lineHeight, t.lineHeight), i),
    size: i,
    style: n,
    weight: ct(e.weight, t.weight),
    string: ""
  };
  return r.string = rM(r), r;
}
function ll(e, t, i, n) {
  let r, a, s;
  for (r = 0, a = e.length; r < a; ++r)
    if (s = e[r], s !== void 0 && s !== void 0)
      return s;
}
function vM(e, t, i) {
  const { min: n, max: r } = e, a = tb(t, (r - n) / 2), s = (o, l) => i && o === 0 ? 0 : o + l;
  return {
    min: s(n, -Math.abs(a)),
    max: s(r, a)
  };
}
function ca(e, t) {
  return Object.assign(Object.create(e), t);
}
function cv(e, t = [
  ""
], i, n, r = () => e[0]) {
  const a = i || e;
  typeof n > "u" && (n = vb("_fallback", e));
  const s = {
    [Symbol.toStringTag]: "Object",
    _cacheable: !0,
    _scopes: e,
    _rootScopes: a,
    _fallback: n,
    _getTarget: r,
    override: (o) => cv([
      o,
      ...e
    ], t, a, n)
  };
  return new Proxy(s, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(o, l) {
      return delete o[l], delete o._keys, delete e[0][l], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(o, l) {
      return db(o, l, () => wM(l, t, e, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(o, l) {
      return Reflect.getOwnPropertyDescriptor(o._scopes[0], l);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e[0]);
    },
    /**
    * A trap for the in operator.
    */
    has(o, l) {
      return fg(o).includes(l);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys(o) {
      return fg(o);
    },
    /**
    * A trap for setting property values.
    */
    set(o, l, u) {
      const c = o._storage || (o._storage = r());
      return o[l] = c[l] = u, delete o._keys, !0;
    }
  });
}
function rs(e, t, i, n) {
  const r = {
    _cacheable: !1,
    _proxy: e,
    _context: t,
    _subProxy: i,
    _stack: /* @__PURE__ */ new Set(),
    _descriptors: hb(e, n),
    setContext: (a) => rs(e, a, i, n),
    override: (a) => rs(e.override(a), t, i, n)
  };
  return new Proxy(r, {
    /**
    * A trap for the delete operator.
    */
    deleteProperty(a, s) {
      return delete a[s], delete e[s], !0;
    },
    /**
    * A trap for getting property values.
    */
    get(a, s, o) {
      return db(a, s, () => gM(a, s, o));
    },
    /**
    * A trap for Object.getOwnPropertyDescriptor.
    * Also used by Object.hasOwnProperty.
    */
    getOwnPropertyDescriptor(a, s) {
      return a._descriptors.allKeys ? Reflect.has(e, s) ? {
        enumerable: !0,
        configurable: !0
      } : void 0 : Reflect.getOwnPropertyDescriptor(e, s);
    },
    /**
    * A trap for Object.getPrototypeOf.
    */
    getPrototypeOf() {
      return Reflect.getPrototypeOf(e);
    },
    /**
    * A trap for the in operator.
    */
    has(a, s) {
      return Reflect.has(e, s);
    },
    /**
    * A trap for Object.getOwnPropertyNames and Object.getOwnPropertySymbols.
    */
    ownKeys() {
      return Reflect.ownKeys(e);
    },
    /**
    * A trap for setting property values.
    */
    set(a, s, o) {
      return e[s] = o, delete a[s], !0;
    }
  });
}
function hb(e, t = {
  scriptable: !0,
  indexable: !0
}) {
  const { _scriptable: i = t.scriptable, _indexable: n = t.indexable, _allKeys: r = t.allKeys } = e;
  return {
    allKeys: r,
    scriptable: i,
    indexable: n,
    isScriptable: ir(i) ? i : () => i,
    isIndexable: ir(n) ? n : () => n
  };
}
const pM = (e, t) => e ? e + rv(t) : t, hv = (e, t) => vt(t) && e !== "adapters" && (Object.getPrototypeOf(t) === null || t.constructor === Object);
function db(e, t, i) {
  if (Object.prototype.hasOwnProperty.call(e, t) || t === "constructor")
    return e[t];
  const n = i();
  return e[t] = n, n;
}
function gM(e, t, i) {
  const { _proxy: n, _context: r, _subProxy: a, _descriptors: s } = e;
  let o = n[t];
  return ir(o) && s.isScriptable(t) && (o = mM(t, o, e, i)), ae(o) && o.length && (o = yM(t, o, e, s.isIndexable)), hv(t, o) && (o = rs(o, r, a && a[t], s)), o;
}
function mM(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: s, _stack: o } = i;
  if (o.has(e))
    throw new Error("Recursion detected: " + Array.from(o).join("->") + "->" + e);
  o.add(e);
  let l = t(a, s || n);
  return o.delete(e), hv(e, l) && (l = dv(r._scopes, r, e, l)), l;
}
function yM(e, t, i, n) {
  const { _proxy: r, _context: a, _subProxy: s, _descriptors: o } = i;
  if (typeof a.index < "u" && n(e))
    return t[a.index % t.length];
  if (vt(t[0])) {
    const l = t, u = r._scopes.filter((c) => c !== l);
    t = [];
    for (const c of l) {
      const h = dv(u, r, e, c);
      t.push(rs(h, a, s && s[e], o));
    }
  }
  return t;
}
function fb(e, t, i) {
  return ir(e) ? e(t, i) : e;
}
const _M = (e, t) => e === !0 ? t : typeof e == "string" ? sa(t, e) : void 0;
function bM(e, t, i, n, r) {
  for (const a of t) {
    const s = _M(i, a);
    if (s) {
      e.add(s);
      const o = fb(s._fallback, i, r);
      if (typeof o < "u" && o !== i && o !== n)
        return o;
    } else if (s === !1 && typeof n < "u" && i !== n)
      return null;
  }
  return !1;
}
function dv(e, t, i, n) {
  const r = t._rootScopes, a = fb(t._fallback, i, n), s = [
    ...e,
    ...r
  ], o = /* @__PURE__ */ new Set();
  o.add(n);
  let l = dg(o, s, i, a || i, n);
  return l === null || typeof a < "u" && a !== i && (l = dg(o, s, a, l, n), l === null) ? !1 : cv(Array.from(o), [
    ""
  ], r, a, () => xM(t, i, n));
}
function dg(e, t, i, n, r) {
  for (; i; )
    i = bM(e, t, i, n, r);
  return i;
}
function xM(e, t, i) {
  const n = e._getTarget();
  t in n || (n[t] = {});
  const r = n[t];
  return ae(r) && vt(i) ? i : r || {};
}
function wM(e, t, i, n) {
  let r;
  for (const a of t)
    if (r = vb(pM(a, e), i), typeof r < "u")
      return hv(e, r) ? dv(i, n, e, r) : r;
}
function vb(e, t) {
  for (const i of t) {
    if (!i)
      continue;
    const n = i[e];
    if (typeof n < "u")
      return n;
  }
}
function fg(e) {
  let t = e._keys;
  return t || (t = e._keys = SM(e._scopes)), t;
}
function SM(e) {
  const t = /* @__PURE__ */ new Set();
  for (const i of e)
    for (const n of Object.keys(i).filter((r) => !r.startsWith("_")))
      t.add(n);
  return Array.from(t);
}
const MM = Number.EPSILON || 1e-14, as = (e, t) => t < e.length && !e[t].skip && e[t], pb = (e) => e === "x" ? "y" : "x";
function kM(e, t, i, n) {
  const r = e.skip ? t : e, a = t, s = i.skip ? t : i, o = Bd(a, r), l = Bd(s, a);
  let u = o / (o + l), c = l / (o + l);
  u = isNaN(u) ? 0 : u, c = isNaN(c) ? 0 : c;
  const h = n * u, d = n * c;
  return {
    previous: {
      x: a.x - h * (s.x - r.x),
      y: a.y - h * (s.y - r.y)
    },
    next: {
      x: a.x + d * (s.x - r.x),
      y: a.y + d * (s.y - r.y)
    }
  };
}
function DM(e, t, i) {
  const n = e.length;
  let r, a, s, o, l, u = as(e, 0);
  for (let c = 0; c < n - 1; ++c)
    if (l = u, u = as(e, c + 1), !(!l || !u)) {
      if (uo(t[c], 0, MM)) {
        i[c] = i[c + 1] = 0;
        continue;
      }
      r = i[c] / t[c], a = i[c + 1] / t[c], o = Math.pow(r, 2) + Math.pow(a, 2), !(o <= 9) && (s = 3 / Math.sqrt(o), i[c] = r * s * t[c], i[c + 1] = a * s * t[c]);
    }
}
function TM(e, t, i = "x") {
  const n = pb(i), r = e.length;
  let a, s, o, l = as(e, 0);
  for (let u = 0; u < r; ++u) {
    if (s = o, o = l, l = as(e, u + 1), !o)
      continue;
    const c = o[i], h = o[n];
    s && (a = (c - s[i]) / 3, o[`cp1${i}`] = c - a, o[`cp1${n}`] = h - a * t[u]), l && (a = (l[i] - c) / 3, o[`cp2${i}`] = c + a, o[`cp2${n}`] = h + a * t[u]);
  }
}
function CM(e, t = "x") {
  const i = pb(t), n = e.length, r = Array(n).fill(0), a = Array(n);
  let s, o, l, u = as(e, 0);
  for (s = 0; s < n; ++s)
    if (o = l, l = u, u = as(e, s + 1), !!l) {
      if (u) {
        const c = u[t] - l[t];
        r[s] = c !== 0 ? (u[i] - l[i]) / c : 0;
      }
      a[s] = o ? u ? qi(r[s - 1]) !== qi(r[s]) ? 0 : (r[s - 1] + r[s]) / 2 : r[s - 1] : r[s];
    }
  DM(e, r, a), TM(e, a, t);
}
function ul(e, t, i) {
  return Math.max(Math.min(e, i), t);
}
function EM(e, t) {
  let i, n, r, a, s, o = Co(e[0], t);
  for (i = 0, n = e.length; i < n; ++i)
    s = a, a = o, o = i < n - 1 && Co(e[i + 1], t), a && (r = e[i], s && (r.cp1x = ul(r.cp1x, t.left, t.right), r.cp1y = ul(r.cp1y, t.top, t.bottom)), o && (r.cp2x = ul(r.cp2x, t.left, t.right), r.cp2y = ul(r.cp2y, t.top, t.bottom)));
}
function AM(e, t, i, n, r) {
  let a, s, o, l;
  if (t.spanGaps && (e = e.filter((u) => !u.skip)), t.cubicInterpolationMode === "monotone")
    CM(e, r);
  else {
    let u = n ? e[e.length - 1] : e[0];
    for (a = 0, s = e.length; a < s; ++a)
      o = e[a], l = kM(u, o, e[Math.min(a + 1, s - (n ? 0 : 1)) % s], t.tension), o.cp1x = l.previous.x, o.cp1y = l.previous.y, o.cp2x = l.next.x, o.cp2y = l.next.y, u = o;
  }
  t.capBezierPoints && EM(e, i);
}
function fv() {
  return typeof window < "u" && typeof document < "u";
}
function vv(e) {
  let t = e.parentNode;
  return t && t.toString() === "[object ShadowRoot]" && (t = t.host), t;
}
function Mu(e, t, i) {
  let n;
  return typeof e == "string" ? (n = parseInt(e, 10), e.indexOf("%") !== -1 && (n = n / 100 * t.parentNode[i])) : n = e, n;
}
const yc = (e) => e.ownerDocument.defaultView.getComputedStyle(e, null);
function PM(e, t) {
  return yc(e).getPropertyValue(t);
}
const LM = [
  "top",
  "right",
  "bottom",
  "left"
];
function Zr(e, t, i) {
  const n = {};
  i = i ? "-" + i : "";
  for (let r = 0; r < 4; r++) {
    const a = LM[r];
    n[a] = parseFloat(e[t + "-" + a + i]) || 0;
  }
  return n.width = n.left + n.right, n.height = n.top + n.bottom, n;
}
const OM = (e, t, i) => (e > 0 || t > 0) && (!i || !i.shadowRoot);
function IM(e, t) {
  const i = e.touches, n = i && i.length ? i[0] : e, { offsetX: r, offsetY: a } = n;
  let s = !1, o, l;
  if (OM(r, a, e.target))
    o = r, l = a;
  else {
    const u = t.getBoundingClientRect();
    o = n.clientX - u.left, l = n.clientY - u.top, s = !0;
  }
  return {
    x: o,
    y: l,
    box: s
  };
}
function Fr(e, t) {
  if ("native" in e)
    return e;
  const { canvas: i, currentDevicePixelRatio: n } = t, r = yc(i), a = r.boxSizing === "border-box", s = Zr(r, "padding"), o = Zr(r, "border", "width"), { x: l, y: u, box: c } = IM(e, i), h = s.left + (c && o.left), d = s.top + (c && o.top);
  let { width: f, height: v } = t;
  return a && (f -= s.width + o.width, v -= s.height + o.height), {
    x: Math.round((l - h) / f * i.width / n),
    y: Math.round((u - d) / v * i.height / n)
  };
}
function RM(e, t, i) {
  let n, r;
  if (t === void 0 || i === void 0) {
    const a = e && vv(e);
    if (!a)
      t = e.clientWidth, i = e.clientHeight;
    else {
      const s = a.getBoundingClientRect(), o = yc(a), l = Zr(o, "border", "width"), u = Zr(o, "padding");
      t = s.width - u.width - l.width, i = s.height - u.height - l.height, n = Mu(o.maxWidth, a, "clientWidth"), r = Mu(o.maxHeight, a, "clientHeight");
    }
  }
  return {
    width: t,
    height: i,
    maxWidth: n || wu,
    maxHeight: r || wu
  };
}
const Wn = (e) => Math.round(e * 10) / 10;
function NM(e, t, i, n) {
  const r = yc(e), a = Zr(r, "margin"), s = Mu(r.maxWidth, e, "clientWidth") || wu, o = Mu(r.maxHeight, e, "clientHeight") || wu, l = RM(e, t, i);
  let { width: u, height: c } = l;
  if (r.boxSizing === "content-box") {
    const d = Zr(r, "border", "width"), f = Zr(r, "padding");
    u -= f.width + d.width, c -= f.height + d.height;
  }
  return u = Math.max(0, u - a.width), c = Math.max(0, n ? u / n : c - a.height), u = Wn(Math.min(u, s, l.maxWidth)), c = Wn(Math.min(c, o, l.maxHeight)), u && !c && (c = Wn(u / 2)), (t !== void 0 || i !== void 0) && n && l.height && c > l.height && (c = l.height, u = Wn(Math.floor(c * n))), {
    width: u,
    height: c
  };
}
function vg(e, t, i) {
  const n = t || 1, r = Wn(e.height * n), a = Wn(e.width * n);
  e.height = Wn(e.height), e.width = Wn(e.width);
  const s = e.canvas;
  return s.style && (i || !s.style.height && !s.style.width) && (s.style.height = `${e.height}px`, s.style.width = `${e.width}px`), e.currentDevicePixelRatio !== n || s.height !== r || s.width !== a ? (e.currentDevicePixelRatio = n, s.height = r, s.width = a, e.ctx.setTransform(n, 0, 0, n, 0, 0), !0) : !1;
}
const FM = (function() {
  let e = !1;
  try {
    const t = {
      get passive() {
        return e = !0, !1;
      }
    };
    fv() && (window.addEventListener("test", null, t), window.removeEventListener("test", null, t));
  } catch {
  }
  return e;
})();
function pg(e, t) {
  const i = PM(e, t), n = i && i.match(/^(\d+)(\.\d+)?px$/);
  return n ? +n[1] : void 0;
}
function Br(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: e.y + i * (t.y - e.y)
  };
}
function BM(e, t, i, n) {
  return {
    x: e.x + i * (t.x - e.x),
    y: n === "middle" ? i < 0.5 ? e.y : t.y : n === "after" ? i < 1 ? e.y : t.y : i > 0 ? t.y : e.y
  };
}
function $M(e, t, i, n) {
  const r = {
    x: e.cp2x,
    y: e.cp2y
  }, a = {
    x: t.cp1x,
    y: t.cp1y
  }, s = Br(e, r, i), o = Br(r, a, i), l = Br(a, t, i), u = Br(s, o, i), c = Br(o, l, i);
  return Br(u, c, i);
}
const zM = function(e, t) {
  return {
    x(i) {
      return e + e + t - i;
    },
    setWidth(i) {
      t = i;
    },
    textAlign(i) {
      return i === "center" ? i : i === "right" ? "left" : "right";
    },
    xPlus(i, n) {
      return i - n;
    },
    leftForLtr(i, n) {
      return i - n;
    }
  };
}, VM = function() {
  return {
    x(e) {
      return e;
    },
    setWidth(e) {
    },
    textAlign(e) {
      return e;
    },
    xPlus(e, t) {
      return e + t;
    },
    leftForLtr(e, t) {
      return e;
    }
  };
};
function qa(e, t, i) {
  return e ? zM(t, i) : VM();
}
function gb(e, t) {
  let i, n;
  (t === "ltr" || t === "rtl") && (i = e.canvas.style, n = [
    i.getPropertyValue("direction"),
    i.getPropertyPriority("direction")
  ], i.setProperty("direction", t, "important"), e.prevTextDirection = n);
}
function mb(e, t) {
  t !== void 0 && (delete e.prevTextDirection, e.canvas.style.setProperty("direction", t[0], t[1]));
}
function yb(e) {
  return e === "angle" ? {
    between: To,
    compare: z2,
    normalize: qe
  } : {
    between: yn,
    compare: (t, i) => t - i,
    normalize: (t) => t
  };
}
function gg({ start: e, end: t, count: i, loop: n, style: r }) {
  return {
    start: e % i,
    end: t % i,
    loop: n && (t - e + 1) % i === 0,
    style: r
  };
}
function HM(e, t, i) {
  const { property: n, start: r, end: a } = i, { between: s, normalize: o } = yb(n), l = t.length;
  let { start: u, end: c, loop: h } = e, d, f;
  if (h) {
    for (u += l, c += l, d = 0, f = l; d < f && s(o(t[u % l][n]), r, a); ++d)
      u--, c--;
    u %= l, c %= l;
  }
  return c < u && (c += l), {
    start: u,
    end: c,
    loop: h,
    style: e.style
  };
}
function _b(e, t, i) {
  if (!i)
    return [
      e
    ];
  const { property: n, start: r, end: a } = i, s = t.length, { compare: o, between: l, normalize: u } = yb(n), { start: c, end: h, loop: d, style: f } = HM(e, t, i), v = [];
  let m = !1, p = null, g, y, _;
  const b = () => l(r, _, g) && o(r, _) !== 0, w = () => o(a, g) === 0 || l(a, _, g), S = () => m || b(), M = () => !m || w();
  for (let k = c, T = c; k <= h; ++k)
    y = t[k % s], !y.skip && (g = u(y[n]), g !== _ && (m = l(g, r, a), p === null && S() && (p = o(g, r) === 0 ? k : T), p !== null && M() && (v.push(gg({
      start: p,
      end: k,
      loop: d,
      count: s,
      style: f
    })), p = null), T = k, _ = g));
  return p !== null && v.push(gg({
    start: p,
    end: h,
    loop: d,
    count: s,
    style: f
  })), v;
}
function bb(e, t) {
  const i = [], n = e.segments;
  for (let r = 0; r < n.length; r++) {
    const a = _b(n[r], e.points, t);
    a.length && i.push(...a);
  }
  return i;
}
function YM(e, t, i, n) {
  let r = 0, a = t - 1;
  if (i && !n)
    for (; r < t && !e[r].skip; )
      r++;
  for (; r < t && e[r].skip; )
    r++;
  for (r %= t, i && (a += r); a > r && e[a % t].skip; )
    a--;
  return a %= t, {
    start: r,
    end: a
  };
}
function WM(e, t, i, n) {
  const r = e.length, a = [];
  let s = t, o = e[t], l;
  for (l = t + 1; l <= i; ++l) {
    const u = e[l % r];
    u.skip || u.stop ? o.skip || (n = !1, a.push({
      start: t % r,
      end: (l - 1) % r,
      loop: n
    }), t = s = u.stop ? l : null) : (s = l, o.skip && (t = l)), o = u;
  }
  return s !== null && a.push({
    start: t % r,
    end: s % r,
    loop: n
  }), a;
}
function UM(e, t) {
  const i = e.points, n = e.options.spanGaps, r = i.length;
  if (!r)
    return [];
  const a = !!e._loop, { start: s, end: o } = YM(i, r, a, n);
  if (n === !0)
    return mg(e, [
      {
        start: s,
        end: o,
        loop: a
      }
    ], i, t);
  const l = o < s ? o + r : o, u = !!e._fullLoop && s === 0 && o === r - 1;
  return mg(e, WM(i, s, l, u), i, t);
}
function mg(e, t, i, n) {
  return !n || !n.setContext || !i ? t : GM(e, t, i, n);
}
function GM(e, t, i, n) {
  const r = e._chart.getContext(), a = yg(e.options), { _datasetIndex: s, options: { spanGaps: o } } = e, l = i.length, u = [];
  let c = a, h = t[0].start, d = h;
  function f(v, m, p, g) {
    const y = o ? -1 : 1;
    if (v !== m) {
      for (v += l; i[v % l].skip; )
        v -= y;
      for (; i[m % l].skip; )
        m += y;
      v % l !== m % l && (u.push({
        start: v % l,
        end: m % l,
        loop: p,
        style: g
      }), c = g, h = m % l);
    }
  }
  for (const v of t) {
    h = o ? h : v.start;
    let m = i[h % l], p;
    for (d = h + 1; d <= v.end; d++) {
      const g = i[d % l];
      p = yg(n.setContext(ca(r, {
        type: "segment",
        p0: m,
        p1: g,
        p0DataIndex: (d - 1) % l,
        p1DataIndex: d % l,
        datasetIndex: s
      }))), XM(p, c) && f(h, d - 1, v.loop, c), m = g, c = p;
    }
    h < d - 1 && f(h, d - 1, v.loop, c);
  }
  return u;
}
function yg(e) {
  return {
    backgroundColor: e.backgroundColor,
    borderCapStyle: e.borderCapStyle,
    borderDash: e.borderDash,
    borderDashOffset: e.borderDashOffset,
    borderJoinStyle: e.borderJoinStyle,
    borderWidth: e.borderWidth,
    borderColor: e.borderColor
  };
}
function XM(e, t) {
  if (!t)
    return !1;
  const i = [], n = function(r, a) {
    return ov(a) ? (i.includes(a) || i.push(a), i.indexOf(a)) : a;
  };
  return JSON.stringify(e, n) !== JSON.stringify(t, n);
}
function cl(e, t, i) {
  return e.options.clip ? e[i] : t[i];
}
function jM(e, t) {
  const { xScale: i, yScale: n } = e;
  return i && n ? {
    left: cl(i, t, "left"),
    right: cl(i, t, "right"),
    top: cl(n, t, "top"),
    bottom: cl(n, t, "bottom")
  } : t;
}
function xb(e, t) {
  const i = t._clip;
  if (i.disabled)
    return !1;
  const n = jM(t, e.chartArea);
  return {
    left: i.left === !1 ? 0 : n.left - (i.left === !0 ? 0 : i.left),
    right: i.right === !1 ? e.width : n.right + (i.right === !0 ? 0 : i.right),
    top: i.top === !1 ? 0 : n.top - (i.top === !0 ? 0 : i.top),
    bottom: i.bottom === !1 ? e.height : n.bottom + (i.bottom === !0 ? 0 : i.bottom)
  };
}
let qM = class {
  constructor() {
    this._request = null, this._charts = /* @__PURE__ */ new Map(), this._running = !1, this._lastDate = void 0;
  }
  _notify(t, i, n, r) {
    const a = i.listeners[r], s = i.duration;
    a.forEach((o) => o({
      chart: t,
      initial: i.initial,
      numSteps: s,
      currentStep: Math.min(n - i.start, s)
    }));
  }
  _refresh() {
    this._request || (this._running = !0, this._request = sb.call(window, () => {
      this._update(), this._request = null, this._running && this._refresh();
    }));
  }
  _update(t = Date.now()) {
    let i = 0;
    this._charts.forEach((n, r) => {
      if (!n.running || !n.items.length)
        return;
      const a = n.items;
      let s = a.length - 1, o = !1, l;
      for (; s >= 0; --s)
        l = a[s], l._active ? (l._total > n.duration && (n.duration = l._total), l.tick(t), o = !0) : (a[s] = a[a.length - 1], a.pop());
      o && (r.draw(), this._notify(r, n, t, "progress")), a.length || (n.running = !1, this._notify(r, n, t, "complete"), n.initial = !1), i += a.length;
    }), this._lastDate = t, i === 0 && (this._running = !1);
  }
  _getAnims(t) {
    const i = this._charts;
    let n = i.get(t);
    return n || (n = {
      running: !1,
      initial: !0,
      items: [],
      listeners: {
        complete: [],
        progress: []
      }
    }, i.set(t, n)), n;
  }
  listen(t, i, n) {
    this._getAnims(t).listeners[i].push(n);
  }
  add(t, i) {
    !i || !i.length || this._getAnims(t).items.push(...i);
  }
  has(t) {
    return this._getAnims(t).items.length > 0;
  }
  start(t) {
    const i = this._charts.get(t);
    i && (i.running = !0, i.start = Date.now(), i.duration = i.items.reduce((n, r) => Math.max(n, r._duration), 0), this._refresh());
  }
  running(t) {
    if (!this._running)
      return !1;
    const i = this._charts.get(t);
    return !(!i || !i.running || !i.items.length);
  }
  stop(t) {
    const i = this._charts.get(t);
    if (!i || !i.items.length)
      return;
    const n = i.items;
    let r = n.length - 1;
    for (; r >= 0; --r)
      n[r].cancel();
    i.items = [], this._notify(t, i, Date.now(), "complete");
  }
  remove(t) {
    return this._charts.delete(t);
  }
};
var dn = /* @__PURE__ */ new qM();
const _g = "transparent", ZM = {
  boolean(e, t, i) {
    return i > 0.5 ? t : e;
  },
  color(e, t, i) {
    const n = lg(e || _g), r = n.valid && lg(t || _g);
    return r && r.valid ? r.mix(n, i).hexString() : t;
  },
  number(e, t, i) {
    return e + (t - e) * i;
  }
};
let KM = class {
  constructor(t, i, n, r) {
    const a = i[n];
    r = ll([
      t.to,
      r,
      a,
      t.from
    ]);
    const s = ll([
      t.from,
      a,
      r
    ]);
    this._active = !0, this._fn = t.fn || ZM[t.type || typeof s], this._easing = co[t.easing] || co.linear, this._start = Math.floor(Date.now() + (t.delay || 0)), this._duration = this._total = Math.floor(t.duration), this._loop = !!t.loop, this._target = i, this._prop = n, this._from = s, this._to = r, this._promises = void 0;
  }
  active() {
    return this._active;
  }
  update(t, i, n) {
    if (this._active) {
      this._notify(!1);
      const r = this._target[this._prop], a = n - this._start, s = this._duration - a;
      this._start = n, this._duration = Math.floor(Math.max(s, t.duration)), this._total += a, this._loop = !!t.loop, this._to = ll([
        t.to,
        i,
        r,
        t.from
      ]), this._from = ll([
        t.from,
        r,
        i
      ]);
    }
  }
  cancel() {
    this._active && (this.tick(Date.now()), this._active = !1, this._notify(!1));
  }
  tick(t) {
    const i = t - this._start, n = this._duration, r = this._prop, a = this._from, s = this._loop, o = this._to;
    let l;
    if (this._active = a !== o && (s || i < n), !this._active) {
      this._target[r] = o, this._notify(!0);
      return;
    }
    if (i < 0) {
      this._target[r] = a;
      return;
    }
    l = i / n % 2, l = s && l > 1 ? 2 - l : l, l = this._easing(Math.min(1, Math.max(0, l))), this._target[r] = this._fn(a, o, l);
  }
  wait() {
    const t = this._promises || (this._promises = []);
    return new Promise((i, n) => {
      t.push({
        res: i,
        rej: n
      });
    });
  }
  _notify(t) {
    const i = t ? "res" : "rej", n = this._promises || [];
    for (let r = 0; r < n.length; r++)
      n[r][i]();
  }
};
class wb {
  constructor(t, i) {
    this._chart = t, this._properties = /* @__PURE__ */ new Map(), this.configure(i);
  }
  configure(t) {
    if (!vt(t))
      return;
    const i = Object.keys(ne.animation), n = this._properties;
    Object.getOwnPropertyNames(t).forEach((r) => {
      const a = t[r];
      if (!vt(a))
        return;
      const s = {};
      for (const o of i)
        s[o] = a[o];
      (ae(a.properties) && a.properties || [
        r
      ]).forEach((o) => {
        (o === r || !n.has(o)) && n.set(o, s);
      });
    });
  }
  _animateOptions(t, i) {
    const n = i.options, r = JM(t, n);
    if (!r)
      return [];
    const a = this._createAnimations(r, n);
    return n.$shared && QM(t.options.$animations, n).then(() => {
      t.options = n;
    }, () => {
    }), a;
  }
  _createAnimations(t, i) {
    const n = this._properties, r = [], a = t.$animations || (t.$animations = {}), s = Object.keys(i), o = Date.now();
    let l;
    for (l = s.length - 1; l >= 0; --l) {
      const u = s[l];
      if (u.charAt(0) === "$")
        continue;
      if (u === "options") {
        r.push(...this._animateOptions(t, i));
        continue;
      }
      const c = i[u];
      let h = a[u];
      const d = n.get(u);
      if (h)
        if (d && h.active()) {
          h.update(d, c, o);
          continue;
        } else
          h.cancel();
      if (!d || !d.duration) {
        t[u] = c;
        continue;
      }
      a[u] = h = new KM(d, t, u, c), r.push(h);
    }
    return r;
  }
  update(t, i) {
    if (this._properties.size === 0) {
      Object.assign(t, i);
      return;
    }
    const n = this._createAnimations(t, i);
    if (n.length)
      return dn.add(this._chart, n), !0;
  }
}
function QM(e, t) {
  const i = [], n = Object.keys(t);
  for (let r = 0; r < n.length; r++) {
    const a = e[n[r]];
    a && a.active() && i.push(a.wait());
  }
  return Promise.all(i);
}
function JM(e, t) {
  if (!t)
    return;
  let i = e.options;
  if (!i) {
    e.options = t;
    return;
  }
  return i.$shared && (e.options = i = Object.assign({}, i, {
    $shared: !1,
    $animations: {}
  })), i;
}
function bg(e, t) {
  const i = e && e.options || {}, n = i.reverse, r = i.min === void 0 ? t : 0, a = i.max === void 0 ? t : 0;
  return {
    start: n ? a : r,
    end: n ? r : a
  };
}
function tk(e, t, i) {
  if (i === !1)
    return !1;
  const n = bg(e, i), r = bg(t, i);
  return {
    top: r.end,
    right: n.end,
    bottom: r.start,
    left: n.start
  };
}
function ek(e) {
  let t, i, n, r;
  return vt(e) ? (t = e.top, i = e.right, n = e.bottom, r = e.left) : t = i = n = r = e, {
    top: t,
    right: i,
    bottom: n,
    left: r,
    disabled: e === !1
  };
}
function Sb(e, t) {
  const i = [], n = e._getSortedDatasetMetas(t);
  let r, a;
  for (r = 0, a = n.length; r < a; ++r)
    i.push(n[r].index);
  return i;
}
function xg(e, t, i, n = {}) {
  const r = e.keys, a = n.mode === "single";
  let s, o, l, u;
  if (t === null)
    return;
  let c = !1;
  for (s = 0, o = r.length; s < o; ++s) {
    if (l = +r[s], l === i) {
      if (c = !0, n.all)
        continue;
      break;
    }
    u = e.values[l], Ce(u) && (a || t === 0 || qi(t) === qi(u)) && (t += u);
  }
  return !c && !n.all ? 0 : t;
}
function ik(e, t) {
  const { iScale: i, vScale: n } = t, r = i.axis === "x" ? "x" : "y", a = n.axis === "x" ? "x" : "y", s = Object.keys(e), o = new Array(s.length);
  let l, u, c;
  for (l = 0, u = s.length; l < u; ++l)
    c = s[l], o[l] = {
      [r]: c,
      [a]: e[c]
    };
  return o;
}
function nh(e, t) {
  const i = e && e.options.stacked;
  return i || i === void 0 && t.stack !== void 0;
}
function nk(e, t, i) {
  return `${e.id}.${t.id}.${i.stack || i.type}`;
}
function rk(e) {
  const { min: t, max: i, minDefined: n, maxDefined: r } = e.getUserBounds();
  return {
    min: n ? t : Number.NEGATIVE_INFINITY,
    max: r ? i : Number.POSITIVE_INFINITY
  };
}
function ak(e, t, i) {
  const n = e[t] || (e[t] = {});
  return n[i] || (n[i] = {});
}
function wg(e, t, i, n) {
  for (const r of t.getMatchingVisibleMetas(n).reverse()) {
    const a = e[r.index];
    if (i && a > 0 || !i && a < 0)
      return r.index;
  }
  return null;
}
function Sg(e, t) {
  const { chart: i, _cachedMeta: n } = e, r = i._stacks || (i._stacks = {}), { iScale: a, vScale: s, index: o } = n, l = a.axis, u = s.axis, c = nk(a, s, n), h = t.length;
  let d;
  for (let f = 0; f < h; ++f) {
    const v = t[f], { [l]: m, [u]: p } = v, g = v._stacks || (v._stacks = {});
    d = g[u] = ak(r, c, m), d[o] = p, d._top = wg(d, s, !0, n.type), d._bottom = wg(d, s, !1, n.type);
    const y = d._visualValues || (d._visualValues = {});
    y[o] = p;
  }
}
function rh(e, t) {
  const i = e.scales;
  return Object.keys(i).filter((n) => i[n].axis === t).shift();
}
function sk(e, t) {
  return ca(e, {
    active: !1,
    dataset: void 0,
    datasetIndex: t,
    index: t,
    mode: "default",
    type: "dataset"
  });
}
function ok(e, t, i) {
  return ca(e, {
    active: !1,
    dataIndex: t,
    parsed: void 0,
    raw: void 0,
    element: i,
    index: t,
    mode: "default",
    type: "data"
  });
}
function xs(e, t) {
  const i = e.controller.index, n = e.vScale && e.vScale.axis;
  if (n) {
    t = t || e._parsed;
    for (const r of t) {
      const a = r._stacks;
      if (!a || a[n] === void 0 || a[n][i] === void 0)
        return;
      delete a[n][i], a[n]._visualValues !== void 0 && a[n]._visualValues[i] !== void 0 && delete a[n]._visualValues[i];
    }
  }
}
const ah = (e) => e === "reset" || e === "none", Mg = (e, t) => t ? e : Object.assign({}, e), lk = (e, t, i) => e && !t.hidden && t._stacked && {
  keys: Sb(i, !0),
  values: null
};
class _c {
  static defaults = {};
  static datasetElementType = null;
  static dataElementType = null;
  constructor(t, i) {
    this.chart = t, this._ctx = t.ctx, this.index = i, this._cachedDataOpts = {}, this._cachedMeta = this.getMeta(), this._type = this._cachedMeta.type, this.options = void 0, this._parsing = !1, this._data = void 0, this._objectData = void 0, this._sharedOptions = void 0, this._drawStart = void 0, this._drawCount = void 0, this.enableOptionSharing = !1, this.supportsDecimation = !1, this.$context = void 0, this._syncList = [], this.datasetElementType = new.target.datasetElementType, this.dataElementType = new.target.dataElementType, this.initialize();
  }
  initialize() {
    const t = this._cachedMeta;
    this.configure(), this.linkScales(), t._stacked = nh(t.vScale, t), this.addElements(), this.options.fill && !this.chart.isPluginEnabled("filler") && console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options");
  }
  updateIndex(t) {
    this.index !== t && xs(this._cachedMeta), this.index = t;
  }
  linkScales() {
    const t = this.chart, i = this._cachedMeta, n = this.getDataset(), r = (h, d, f, v) => h === "x" ? d : h === "r" ? v : f, a = i.xAxisID = ct(n.xAxisID, rh(t, "x")), s = i.yAxisID = ct(n.yAxisID, rh(t, "y")), o = i.rAxisID = ct(n.rAxisID, rh(t, "r")), l = i.indexAxis, u = i.iAxisID = r(l, a, s, o), c = i.vAxisID = r(l, s, a, o);
    i.xScale = this.getScaleForId(a), i.yScale = this.getScaleForId(s), i.rScale = this.getScaleForId(o), i.iScale = this.getScaleForId(u), i.vScale = this.getScaleForId(c);
  }
  getDataset() {
    return this.chart.data.datasets[this.index];
  }
  getMeta() {
    return this.chart.getDatasetMeta(this.index);
  }
  getScaleForId(t) {
    return this.chart.scales[t];
  }
  _getOtherScale(t) {
    const i = this._cachedMeta;
    return t === i.iScale ? i.vScale : i.iScale;
  }
  reset() {
    this._update("reset");
  }
  _destroy() {
    const t = this._cachedMeta;
    this._data && ag(this._data, this), t._stacked && xs(t);
  }
  _dataCheck() {
    const t = this.getDataset(), i = t.data || (t.data = []), n = this._data;
    if (vt(i)) {
      const r = this._cachedMeta;
      this._data = ik(i, r);
    } else if (n !== i) {
      if (n) {
        ag(n, this);
        const r = this._cachedMeta;
        xs(r), r._parsed = [];
      }
      i && Object.isExtensible(i) && W2(i, this), this._syncList = [], this._data = i;
    }
  }
  addElements() {
    const t = this._cachedMeta;
    this._dataCheck(), this.datasetElementType && (t.dataset = new this.datasetElementType());
  }
  buildOrUpdateElements(t) {
    const i = this._cachedMeta, n = this.getDataset();
    let r = !1;
    this._dataCheck();
    const a = i._stacked;
    i._stacked = nh(i.vScale, i), i.stack !== n.stack && (r = !0, xs(i), i.stack = n.stack), this._resyncElements(t), (r || a !== i._stacked) && (Sg(this, i._parsed), i._stacked = nh(i.vScale, i));
  }
  configure() {
    const t = this.chart.config, i = t.datasetScopeKeys(this._type), n = t.getOptionScopes(this.getDataset(), i, !0);
    this.options = t.createResolver(n, this.getContext()), this._parsing = this.options.parsing, this._cachedDataOpts = {};
  }
  parse(t, i) {
    const { _cachedMeta: n, _data: r } = this, { iScale: a, _stacked: s } = n, o = a.axis;
    let l = t === 0 && i === r.length ? !0 : n._sorted, u = t > 0 && n._parsed[t - 1], c, h, d;
    if (this._parsing === !1)
      n._parsed = r, n._sorted = !0, d = r;
    else {
      ae(r[t]) ? d = this.parseArrayData(n, r, t, i) : vt(r[t]) ? d = this.parseObjectData(n, r, t, i) : d = this.parsePrimitiveData(n, r, t, i);
      const f = () => h[o] === null || u && h[o] < u[o];
      for (c = 0; c < i; ++c)
        n._parsed[c + t] = h = d[c], l && (f() && (l = !1), u = h);
      n._sorted = l;
    }
    s && Sg(this, d);
  }
  parsePrimitiveData(t, i, n, r) {
    const { iScale: a, vScale: s } = t, o = a.axis, l = s.axis, u = a.getLabels(), c = a === s, h = new Array(r);
    let d, f, v;
    for (d = 0, f = r; d < f; ++d)
      v = d + n, h[d] = {
        [o]: c || a.parse(u[v], v),
        [l]: s.parse(i[v], v)
      };
    return h;
  }
  parseArrayData(t, i, n, r) {
    const { xScale: a, yScale: s } = t, o = new Array(r);
    let l, u, c, h;
    for (l = 0, u = r; l < u; ++l)
      c = l + n, h = i[c], o[l] = {
        x: a.parse(h[0], c),
        y: s.parse(h[1], c)
      };
    return o;
  }
  parseObjectData(t, i, n, r) {
    const { xScale: a, yScale: s } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, u = new Array(r);
    let c, h, d, f;
    for (c = 0, h = r; c < h; ++c)
      d = c + n, f = i[d], u[c] = {
        x: a.parse(sa(f, o), d),
        y: s.parse(sa(f, l), d)
      };
    return u;
  }
  getParsed(t) {
    return this._cachedMeta._parsed[t];
  }
  getDataElement(t) {
    return this._cachedMeta.data[t];
  }
  applyStack(t, i, n) {
    const r = this.chart, a = this._cachedMeta, s = i[t.axis], o = {
      keys: Sb(r, !0),
      values: i._stacks[t.axis]._visualValues
    };
    return xg(o, s, a.index, {
      mode: n
    });
  }
  updateRangeFromParsed(t, i, n, r) {
    const a = n[i.axis];
    let s = a === null ? NaN : a;
    const o = r && n._stacks[i.axis];
    r && o && (r.values = o, s = xg(r, a, this._cachedMeta.index)), t.min = Math.min(t.min, s), t.max = Math.max(t.max, s);
  }
  getMinMax(t, i) {
    const n = this._cachedMeta, r = n._parsed, a = n._sorted && t === n.iScale, s = r.length, o = this._getOtherScale(t), l = lk(i, n, this.chart), u = {
      min: Number.POSITIVE_INFINITY,
      max: Number.NEGATIVE_INFINITY
    }, { min: c, max: h } = rk(o);
    let d, f;
    function v() {
      f = r[d];
      const m = f[o.axis];
      return !Ce(f[t.axis]) || c > m || h < m;
    }
    for (d = 0; d < s && !(!v() && (this.updateRangeFromParsed(u, t, f, l), a)); ++d)
      ;
    if (a) {
      for (d = s - 1; d >= 0; --d)
        if (!v()) {
          this.updateRangeFromParsed(u, t, f, l);
          break;
        }
    }
    return u;
  }
  getAllParsedValues(t) {
    const i = this._cachedMeta._parsed, n = [];
    let r, a, s;
    for (r = 0, a = i.length; r < a; ++r)
      s = i[r][t.axis], Ce(s) && n.push(s);
    return n;
  }
  getMaxOverflow() {
    return !1;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = i.iScale, r = i.vScale, a = this.getParsed(t);
    return {
      label: n ? "" + n.getLabelForValue(a[n.axis]) : "",
      value: r ? "" + r.getLabelForValue(a[r.axis]) : ""
    };
  }
  _update(t) {
    const i = this._cachedMeta;
    this.update(t || "default"), i._clip = ek(ct(this.options.clip, tk(i.xScale, i.yScale, this.getMaxOverflow())));
  }
  update(t) {
  }
  draw() {
    const t = this._ctx, i = this.chart, n = this._cachedMeta, r = n.data || [], a = i.chartArea, s = [], o = this._drawStart || 0, l = this._drawCount || r.length - o, u = this.options.drawActiveElementsOnTop;
    let c;
    for (n.dataset && n.dataset.draw(t, a, o, l), c = o; c < o + l; ++c) {
      const h = r[c];
      h.hidden || (h.active && u ? s.push(h) : h.draw(t, a));
    }
    for (c = 0; c < s.length; ++c)
      s[c].draw(t, a);
  }
  getStyle(t, i) {
    const n = i ? "active" : "default";
    return t === void 0 && this._cachedMeta.dataset ? this.resolveDatasetElementOptions(n) : this.resolveDataElementOptions(t || 0, n);
  }
  getContext(t, i, n) {
    const r = this.getDataset();
    let a;
    if (t >= 0 && t < this._cachedMeta.data.length) {
      const s = this._cachedMeta.data[t];
      a = s.$context || (s.$context = ok(this.getContext(), t, s)), a.parsed = this.getParsed(t), a.raw = r.data[t], a.index = a.dataIndex = t;
    } else
      a = this.$context || (this.$context = sk(this.chart.getContext(), this.index)), a.dataset = r, a.index = a.datasetIndex = this.index;
    return a.active = !!i, a.mode = n, a;
  }
  resolveDatasetElementOptions(t) {
    return this._resolveElementOptions(this.datasetElementType.id, t);
  }
  resolveDataElementOptions(t, i) {
    return this._resolveElementOptions(this.dataElementType.id, i, t);
  }
  _resolveElementOptions(t, i = "default", n) {
    const r = i === "active", a = this._cachedDataOpts, s = t + "-" + i, o = a[s], l = this.enableOptionSharing && ko(n);
    if (o)
      return Mg(o, l);
    const u = this.chart.config, c = u.datasetElementScopeKeys(this._type, t), h = r ? [
      `${t}Hover`,
      "hover",
      t,
      ""
    ] : [
      t,
      ""
    ], d = u.getOptionScopes(this.getDataset(), c), f = Object.keys(ne.elements[t]), v = () => this.getContext(n, r, i), m = u.resolveNamedOptions(d, f, v, h);
    return m.$shared && (m.$shared = l, a[s] = Object.freeze(Mg(m, l))), m;
  }
  _resolveAnimations(t, i, n) {
    const r = this.chart, a = this._cachedDataOpts, s = `animation-${i}`, o = a[s];
    if (o)
      return o;
    let l;
    if (r.options.animation !== !1) {
      const c = this.chart.config, h = c.datasetAnimationScopeKeys(this._type, i), d = c.getOptionScopes(this.getDataset(), h);
      l = c.createResolver(d, this.getContext(t, n, i));
    }
    const u = new wb(r, l && l.animations);
    return l && l._cacheable && (a[s] = Object.freeze(u)), u;
  }
  getSharedOptions(t) {
    if (t.$shared)
      return this._sharedOptions || (this._sharedOptions = Object.assign({}, t));
  }
  includeOptions(t, i) {
    return !i || ah(t) || this.chart._animationsDisabled;
  }
  _getSharedOptions(t, i) {
    const n = this.resolveDataElementOptions(t, i), r = this._sharedOptions, a = this.getSharedOptions(n), s = this.includeOptions(i, a) || a !== r;
    return this.updateSharedOptions(a, i, n), {
      sharedOptions: a,
      includeOptions: s
    };
  }
  updateElement(t, i, n, r) {
    ah(r) ? Object.assign(t, n) : this._resolveAnimations(i, r).update(t, n);
  }
  updateSharedOptions(t, i, n) {
    t && !ah(i) && this._resolveAnimations(void 0, i).update(t, n);
  }
  _setStyle(t, i, n, r) {
    t.active = r;
    const a = this.getStyle(i, r);
    this._resolveAnimations(i, n, r).update(t, {
      options: !r && this.getSharedOptions(a) || a
    });
  }
  removeHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !1);
  }
  setHoverStyle(t, i, n) {
    this._setStyle(t, n, "active", !0);
  }
  _removeDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !1);
  }
  _setDatasetHoverStyle() {
    const t = this._cachedMeta.dataset;
    t && this._setStyle(t, void 0, "active", !0);
  }
  _resyncElements(t) {
    const i = this._data, n = this._cachedMeta.data;
    for (const [o, l, u] of this._syncList)
      this[o](l, u);
    this._syncList = [];
    const r = n.length, a = i.length, s = Math.min(a, r);
    s && this.parse(0, s), a > r ? this._insertElements(r, a - r, t) : a < r && this._removeElements(a, r - a);
  }
  _insertElements(t, i, n = !0) {
    const r = this._cachedMeta, a = r.data, s = t + i;
    let o;
    const l = (u) => {
      for (u.length += i, o = u.length - 1; o >= s; o--)
        u[o] = u[o - i];
    };
    for (l(a), o = t; o < s; ++o)
      a[o] = new this.dataElementType();
    this._parsing && l(r._parsed), this.parse(t, i), n && this.updateElements(a, t, i, "reset");
  }
  updateElements(t, i, n, r) {
  }
  _removeElements(t, i) {
    const n = this._cachedMeta;
    if (this._parsing) {
      const r = n._parsed.splice(t, i);
      n._stacked && xs(n, r);
    }
    n.data.splice(t, i);
  }
  _sync(t) {
    if (this._parsing)
      this._syncList.push(t);
    else {
      const [i, n, r] = t;
      this[i](n, r);
    }
    this.chart._dataChanges.push([
      this.index,
      ...t
    ]);
  }
  _onDataPush() {
    const t = arguments.length;
    this._sync([
      "_insertElements",
      this.getDataset().data.length - t,
      t
    ]);
  }
  _onDataPop() {
    this._sync([
      "_removeElements",
      this._cachedMeta.data.length - 1,
      1
    ]);
  }
  _onDataShift() {
    this._sync([
      "_removeElements",
      0,
      1
    ]);
  }
  _onDataSplice(t, i) {
    i && this._sync([
      "_removeElements",
      t,
      i
    ]);
    const n = arguments.length - 2;
    n && this._sync([
      "_insertElements",
      t,
      n
    ]);
  }
  _onDataUnshift() {
    this._sync([
      "_insertElements",
      0,
      arguments.length
    ]);
  }
}
function uk(e, t) {
  if (!e._cache.$bar) {
    const i = e.getMatchingVisibleMetas(t);
    let n = [];
    for (let r = 0, a = i.length; r < a; r++)
      n = n.concat(i[r].controller.getAllParsedValues(e));
    e._cache.$bar = ab(n.sort((r, a) => r - a));
  }
  return e._cache.$bar;
}
function ck(e) {
  const t = e.iScale, i = uk(t, e.type);
  let n = t._length, r, a, s, o;
  const l = () => {
    s === 32767 || s === -32768 || (ko(o) && (n = Math.min(n, Math.abs(s - o) || n)), o = s);
  };
  for (r = 0, a = i.length; r < a; ++r)
    s = t.getPixelForValue(i[r]), l();
  for (o = void 0, r = 0, a = t.ticks.length; r < a; ++r)
    s = t.getPixelForTick(r), l();
  return n;
}
function hk(e, t, i, n) {
  const r = i.barThickness;
  let a, s;
  return kt(r) ? (a = t.min * i.categoryPercentage, s = i.barPercentage) : (a = r * n, s = 1), {
    chunk: a / n,
    ratio: s,
    start: t.pixels[e] - a / 2
  };
}
function dk(e, t, i, n) {
  const r = t.pixels, a = r[e];
  let s = e > 0 ? r[e - 1] : null, o = e < r.length - 1 ? r[e + 1] : null;
  const l = i.categoryPercentage;
  s === null && (s = a - (o === null ? t.end - t.start : o - a)), o === null && (o = a + a - s);
  const u = a - (a - Math.min(s, o)) / 2 * l;
  return {
    chunk: Math.abs(o - s) / 2 * l / n,
    ratio: i.barPercentage,
    start: u
  };
}
function fk(e, t, i, n) {
  const r = i.parse(e[0], n), a = i.parse(e[1], n), s = Math.min(r, a), o = Math.max(r, a);
  let l = s, u = o;
  Math.abs(s) > Math.abs(o) && (l = o, u = s), t[i.axis] = u, t._custom = {
    barStart: l,
    barEnd: u,
    start: r,
    end: a,
    min: s,
    max: o
  };
}
function Mb(e, t, i, n) {
  return ae(e) ? fk(e, t, i, n) : t[i.axis] = i.parse(e, n), t;
}
function kg(e, t, i, n) {
  const r = e.iScale, a = e.vScale, s = r.getLabels(), o = r === a, l = [];
  let u, c, h, d;
  for (u = i, c = i + n; u < c; ++u)
    d = t[u], h = {}, h[r.axis] = o || r.parse(s[u], u), l.push(Mb(d, h, a, u));
  return l;
}
function sh(e) {
  return e && e.barStart !== void 0 && e.barEnd !== void 0;
}
function vk(e, t, i) {
  return e !== 0 ? qi(e) : (t.isHorizontal() ? 1 : -1) * (t.min >= i ? 1 : -1);
}
function pk(e) {
  let t, i, n, r, a;
  return e.horizontal ? (t = e.base > e.x, i = "left", n = "right") : (t = e.base < e.y, i = "bottom", n = "top"), t ? (r = "end", a = "start") : (r = "start", a = "end"), {
    start: i,
    end: n,
    reverse: t,
    top: r,
    bottom: a
  };
}
function gk(e, t, i, n) {
  let r = t.borderSkipped;
  const a = {};
  if (!r) {
    e.borderSkipped = a;
    return;
  }
  if (r === !0) {
    e.borderSkipped = {
      top: !0,
      right: !0,
      bottom: !0,
      left: !0
    };
    return;
  }
  const { start: s, end: o, reverse: l, top: u, bottom: c } = pk(e);
  r === "middle" && i && (e.enableBorderRadius = !0, (i._top || 0) === n ? r = u : (i._bottom || 0) === n ? r = c : (a[Dg(c, s, o, l)] = !0, r = u)), a[Dg(r, s, o, l)] = !0, e.borderSkipped = a;
}
function Dg(e, t, i, n) {
  return n ? (e = mk(e, t, i), e = Tg(e, i, t)) : e = Tg(e, t, i), e;
}
function mk(e, t, i) {
  return e === t ? i : e === i ? t : e;
}
function Tg(e, t, i) {
  return e === "start" ? t : e === "end" ? i : e;
}
function yk(e, { inflateAmount: t }, i) {
  e.inflateAmount = t === "auto" ? i === 1 ? 0.33 : 0 : t;
}
class _k extends _c {
  static id = "bar";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "bar",
    categoryPercentage: 0.8,
    barPercentage: 0.9,
    grouped: !0,
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "base",
          "width",
          "height"
        ]
      }
    }
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category",
        offset: !0,
        grid: {
          offset: !0
        }
      },
      _value_: {
        type: "linear",
        beginAtZero: !0
      }
    }
  };
  parsePrimitiveData(t, i, n, r) {
    return kg(t, i, n, r);
  }
  parseArrayData(t, i, n, r) {
    return kg(t, i, n, r);
  }
  parseObjectData(t, i, n, r) {
    const { iScale: a, vScale: s } = t, { xAxisKey: o = "x", yAxisKey: l = "y" } = this._parsing, u = a.axis === "x" ? o : l, c = s.axis === "x" ? o : l, h = [];
    let d, f, v, m;
    for (d = n, f = n + r; d < f; ++d)
      m = i[d], v = {}, v[a.axis] = a.parse(sa(m, u), d), h.push(Mb(sa(m, c), v, s, d));
    return h;
  }
  updateRangeFromParsed(t, i, n, r) {
    super.updateRangeFromParsed(t, i, n, r);
    const a = n._custom;
    a && i === this._cachedMeta.vScale && (t.min = Math.min(t.min, a.min), t.max = Math.max(t.max, a.max));
  }
  getMaxOverflow() {
    return 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, { iScale: n, vScale: r } = i, a = this.getParsed(t), s = a._custom, o = sh(s) ? "[" + s.start + ", " + s.end + "]" : "" + r.getLabelForValue(a[r.axis]);
    return {
      label: "" + n.getLabelForValue(a[n.axis]),
      value: o
    };
  }
  initialize() {
    this.enableOptionSharing = !0, super.initialize();
    const t = this._cachedMeta;
    t.stack = this.getDataset().stack;
  }
  update(t) {
    const i = this._cachedMeta;
    this.updateElements(i.data, 0, i.data.length, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { index: s, _cachedMeta: { vScale: o } } = this, l = o.getBasePixel(), u = o.isHorizontal(), c = this._getRuler(), { sharedOptions: h, includeOptions: d } = this._getSharedOptions(i, r);
    for (let f = i; f < i + n; f++) {
      const v = this.getParsed(f), m = a || kt(v[o.axis]) ? {
        base: l,
        head: l
      } : this._calculateBarValuePixels(f), p = this._calculateBarIndexPixels(f, c), g = (v._stacks || {})[o.axis], y = {
        horizontal: u,
        base: m.base,
        enableBorderRadius: !g || sh(v._custom) || s === g._top || s === g._bottom,
        x: u ? m.head : p.center,
        y: u ? p.center : m.head,
        height: u ? p.size : Math.abs(m.size),
        width: u ? Math.abs(m.size) : p.size
      };
      d && (y.options = h || this.resolveDataElementOptions(f, t[f].active ? "active" : r));
      const _ = y.options || t[f].options;
      gk(y, _, g, s), yk(y, _, c.ratio), this.updateElement(t[f], f, y, r);
    }
  }
  _getStacks(t, i) {
    const { iScale: n } = this._cachedMeta, r = n.getMatchingVisibleMetas(this._type).filter((c) => c.controller.options.grouped), a = n.options.stacked, s = [], o = this._cachedMeta.controller.getParsed(i), l = o && o[n.axis], u = (c) => {
      const h = c._parsed.find((f) => f[n.axis] === l), d = h && h[c.vScale.axis];
      if (kt(d) || isNaN(d))
        return !0;
    };
    for (const c of r)
      if (!(i !== void 0 && u(c)) && ((a === !1 || s.indexOf(c.stack) === -1 || a === void 0 && c.stack === void 0) && s.push(c.stack), c.index === t))
        break;
    return s.length || s.push(void 0), s;
  }
  _getStackCount(t) {
    return this._getStacks(void 0, t).length;
  }
  _getAxisCount() {
    return this._getAxis().length;
  }
  getFirstScaleIdForIndexAxis() {
    const t = this.chart.scales, i = this.chart.options.indexAxis;
    return Object.keys(t).filter((n) => t[n].axis === i).shift();
  }
  _getAxis() {
    const t = {}, i = this.getFirstScaleIdForIndexAxis();
    for (const n of this.chart.data.datasets)
      t[ct(this.chart.options.indexAxis === "x" ? n.xAxisID : n.yAxisID, i)] = !0;
    return Object.keys(t);
  }
  _getStackIndex(t, i, n) {
    const r = this._getStacks(t, n), a = i !== void 0 ? r.indexOf(i) : -1;
    return a === -1 ? r.length - 1 : a;
  }
  _getRuler() {
    const t = this.options, i = this._cachedMeta, n = i.iScale, r = [];
    let a, s;
    for (a = 0, s = i.data.length; a < s; ++a)
      r.push(n.getPixelForValue(this.getParsed(a)[n.axis], a));
    const o = t.barThickness;
    return {
      min: o || ck(i),
      pixels: r,
      start: n._startPixel,
      end: n._endPixel,
      stackCount: this._getStackCount(),
      scale: n,
      grouped: t.grouped,
      ratio: o ? 1 : t.categoryPercentage * t.barPercentage
    };
  }
  _calculateBarValuePixels(t) {
    const { _cachedMeta: { vScale: i, _stacked: n, index: r }, options: { base: a, minBarLength: s } } = this, o = a || 0, l = this.getParsed(t), u = l._custom, c = sh(u);
    let h = l[i.axis], d = 0, f = n ? this.applyStack(i, l, n) : h, v, m;
    f !== h && (d = f - h, f = h), c && (h = u.barStart, f = u.barEnd - u.barStart, h !== 0 && qi(h) !== qi(u.barEnd) && (d = 0), d += h);
    const p = !kt(a) && !c ? a : d;
    let g = i.getPixelForValue(p);
    if (this.chart.getDataVisibility(t) ? v = i.getPixelForValue(d + f) : v = g, m = v - g, Math.abs(m) < s) {
      m = vk(m, i, o) * s, h === o && (g -= m / 2);
      const y = i.getPixelForDecimal(0), _ = i.getPixelForDecimal(1), b = Math.min(y, _), w = Math.max(y, _);
      g = Math.max(Math.min(g, w), b), v = g + m, n && !c && (l._stacks[i.axis]._visualValues[r] = i.getValueForPixel(v) - i.getValueForPixel(g));
    }
    if (g === i.getPixelForValue(o)) {
      const y = qi(m) * i.getLineWidthForValue(o) / 2;
      g += y, m -= y;
    }
    return {
      size: m,
      base: g,
      head: v,
      center: v + m / 2
    };
  }
  _calculateBarIndexPixels(t, i) {
    const n = i.scale, r = this.options, a = r.skipNull, s = ct(r.maxBarThickness, 1 / 0);
    let o, l;
    const u = this._getAxisCount();
    if (i.grouped) {
      const c = a ? this._getStackCount(t) : i.stackCount, h = r.barThickness === "flex" ? dk(t, i, r, c * u) : hk(t, i, r, c * u), d = this.chart.options.indexAxis === "x" ? this.getDataset().xAxisID : this.getDataset().yAxisID, f = this._getAxis().indexOf(ct(d, this.getFirstScaleIdForIndexAxis())), v = this._getStackIndex(this.index, this._cachedMeta.stack, a ? t : void 0) + f;
      o = h.start + h.chunk * v + h.chunk / 2, l = Math.min(s, h.chunk * h.ratio);
    } else
      o = n.getPixelForValue(this.getParsed(t)[n.axis], t), l = Math.min(s, i.min * i.ratio);
    return {
      base: o - l / 2,
      head: o + l / 2,
      center: o,
      size: l
    };
  }
  draw() {
    const t = this._cachedMeta, i = t.vScale, n = t.data, r = n.length;
    let a = 0;
    for (; a < r; ++a)
      this.getParsed(a)[i.axis] !== null && !n[a].hidden && n[a].draw(this._ctx);
  }
}
function bk(e, t, i) {
  let n = 1, r = 1, a = 0, s = 0;
  if (t < Xt) {
    const o = e, l = o + t, u = Math.cos(o), c = Math.sin(o), h = Math.cos(l), d = Math.sin(l), f = (_, b, w) => To(_, o, l, !0) ? 1 : Math.max(b, b * i, w, w * i), v = (_, b, w) => To(_, o, l, !0) ? -1 : Math.min(b, b * i, w, w * i), m = f(0, u, h), p = f(he, c, d), g = v(Et, u, h), y = v(Et + he, c, d);
    n = (m - g) / 2, r = (p - y) / 2, a = -(m + g) / 2, s = -(p + y) / 2;
  }
  return {
    ratioX: n,
    ratioY: r,
    offsetX: a,
    offsetY: s
  };
}
class xk extends _c {
  static id = "doughnut";
  static defaults = {
    datasetElementType: !1,
    dataElementType: "arc",
    animation: {
      animateRotate: !0,
      animateScale: !1
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "circumference",
          "endAngle",
          "innerRadius",
          "outerRadius",
          "startAngle",
          "x",
          "y",
          "offset",
          "borderWidth",
          "spacing"
        ]
      }
    },
    cutout: "50%",
    rotation: 0,
    circumference: 360,
    radius: "100%",
    spacing: 0,
    indexAxis: "r"
  };
  static descriptors = {
    _scriptable: (t) => t !== "spacing",
    _indexable: (t) => t !== "spacing" && !t.startsWith("borderDash") && !t.startsWith("hoverBorderDash")
  };
  static overrides = {
    aspectRatio: 1,
    plugins: {
      legend: {
        labels: {
          generateLabels(t) {
            const i = t.data, { labels: { pointStyle: n, textAlign: r, color: a, useBorderRadius: s, borderRadius: o } } = t.legend.options;
            return i.labels.length && i.datasets.length ? i.labels.map((l, u) => {
              const h = t.getDatasetMeta(0).controller.getStyle(u);
              return {
                text: l,
                fillStyle: h.backgroundColor,
                fontColor: a,
                hidden: !t.getDataVisibility(u),
                lineDash: h.borderDash,
                lineDashOffset: h.borderDashOffset,
                lineJoin: h.borderJoinStyle,
                lineWidth: h.borderWidth,
                strokeStyle: h.borderColor,
                textAlign: r,
                pointStyle: n,
                borderRadius: s && (o || h.borderRadius),
                index: u
              };
            }) : [];
          }
        },
        onClick(t, i, n) {
          n.chart.toggleDataVisibility(i.index), n.chart.update();
        }
      }
    }
  };
  constructor(t, i) {
    super(t, i), this.enableOptionSharing = !0, this.innerRadius = void 0, this.outerRadius = void 0, this.offsetX = void 0, this.offsetY = void 0;
  }
  linkScales() {
  }
  parse(t, i) {
    const n = this.getDataset().data, r = this._cachedMeta;
    if (this._parsing === !1)
      r._parsed = n;
    else {
      let a = (l) => +n[l];
      if (vt(n[t])) {
        const { key: l = "value" } = this._parsing;
        a = (u) => +sa(n[u], l);
      }
      let s, o;
      for (s = t, o = t + i; s < o; ++s)
        r._parsed[s] = a(s);
    }
  }
  _getRotation() {
    return mn(this.options.rotation - 90);
  }
  _getCircumference() {
    return mn(this.options.circumference);
  }
  _getRotationExtents() {
    let t = Xt, i = -Xt;
    for (let n = 0; n < this.chart.data.datasets.length; ++n)
      if (this.chart.isDatasetVisible(n) && this.chart.getDatasetMeta(n).type === this._type) {
        const r = this.chart.getDatasetMeta(n).controller, a = r._getRotation(), s = r._getCircumference();
        t = Math.min(t, a), i = Math.max(i, a + s);
      }
    return {
      rotation: t,
      circumference: i - t
    };
  }
  update(t) {
    const i = this.chart, { chartArea: n } = i, r = this._cachedMeta, a = r.data, s = this.getMaxBorderWidth() + this.getMaxOffset(a) + this.options.spacing, o = Math.max((Math.min(n.width, n.height) - s) / 2, 0), l = Math.min(T2(this.options.cutout, o), 1), u = this._getRingWeight(this.index), { circumference: c, rotation: h } = this._getRotationExtents(), { ratioX: d, ratioY: f, offsetX: v, offsetY: m } = bk(h, c, l), p = (n.width - s) / d, g = (n.height - s) / f, y = Math.max(Math.min(p, g) / 2, 0), _ = tb(this.options.radius, y), b = Math.max(_ * l, 0), w = (_ - b) / this._getVisibleDatasetWeightTotal();
    this.offsetX = v * _, this.offsetY = m * _, r.total = this.calculateTotal(), this.outerRadius = _ - w * this._getRingWeightOffset(this.index), this.innerRadius = Math.max(this.outerRadius - w * u, 0), this.updateElements(a, 0, a.length, t);
  }
  _circumference(t, i) {
    const n = this.options, r = this._cachedMeta, a = this._getCircumference();
    return i && n.animation.animateRotate || !this.chart.getDataVisibility(t) || r._parsed[t] === null || r.data[t].hidden ? 0 : this.calculateCircumference(r._parsed[t] * a / Xt);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", s = this.chart, o = s.chartArea, u = s.options.animation, c = (o.left + o.right) / 2, h = (o.top + o.bottom) / 2, d = a && u.animateScale, f = d ? 0 : this.innerRadius, v = d ? 0 : this.outerRadius, { sharedOptions: m, includeOptions: p } = this._getSharedOptions(i, r);
    let g = this._getRotation(), y;
    for (y = 0; y < i; ++y)
      g += this._circumference(y, a);
    for (y = i; y < i + n; ++y) {
      const _ = this._circumference(y, a), b = t[y], w = {
        x: c + this.offsetX,
        y: h + this.offsetY,
        startAngle: g,
        endAngle: g + _,
        circumference: _,
        outerRadius: v,
        innerRadius: f
      };
      p && (w.options = m || this.resolveDataElementOptions(y, b.active ? "active" : r)), g += _, this.updateElement(b, y, w, r);
    }
  }
  calculateTotal() {
    const t = this._cachedMeta, i = t.data;
    let n = 0, r;
    for (r = 0; r < i.length; r++) {
      const a = t._parsed[r];
      a !== null && !isNaN(a) && this.chart.getDataVisibility(r) && !i[r].hidden && (n += Math.abs(a));
    }
    return n;
  }
  calculateCircumference(t) {
    const i = this._cachedMeta.total;
    return i > 0 && !isNaN(t) ? Xt * (Math.abs(t) / i) : 0;
  }
  getLabelAndValue(t) {
    const i = this._cachedMeta, n = this.chart, r = n.data.labels || [], a = lv(i._parsed[t], n.options.locale);
    return {
      label: r[t] || "",
      value: a
    };
  }
  getMaxBorderWidth(t) {
    let i = 0;
    const n = this.chart;
    let r, a, s, o, l;
    if (!t) {
      for (r = 0, a = n.data.datasets.length; r < a; ++r)
        if (n.isDatasetVisible(r)) {
          s = n.getDatasetMeta(r), t = s.data, o = s.controller;
          break;
        }
    }
    if (!t)
      return 0;
    for (r = 0, a = t.length; r < a; ++r)
      l = o.resolveDataElementOptions(r), l.borderAlign !== "inner" && (i = Math.max(i, l.borderWidth || 0, l.hoverBorderWidth || 0));
    return i;
  }
  getMaxOffset(t) {
    let i = 0;
    for (let n = 0, r = t.length; n < r; ++n) {
      const a = this.resolveDataElementOptions(n);
      i = Math.max(i, a.offset || 0, a.hoverOffset || 0);
    }
    return i;
  }
  _getRingWeightOffset(t) {
    let i = 0;
    for (let n = 0; n < t; ++n)
      this.chart.isDatasetVisible(n) && (i += this._getRingWeight(n));
    return i;
  }
  _getRingWeight(t) {
    return Math.max(ct(this.chart.data.datasets[t].weight, 1), 0);
  }
  _getVisibleDatasetWeightTotal() {
    return this._getRingWeightOffset(this.chart.data.datasets.length) || 1;
  }
}
class wk extends _c {
  static id = "line";
  static defaults = {
    datasetElementType: "line",
    dataElementType: "point",
    showLine: !0,
    spanGaps: !1
  };
  static overrides = {
    scales: {
      _index_: {
        type: "category"
      },
      _value_: {
        type: "linear"
      }
    }
  };
  initialize() {
    this.enableOptionSharing = !0, this.supportsDecimation = !0, super.initialize();
  }
  update(t) {
    const i = this._cachedMeta, { dataset: n, data: r = [], _dataset: a } = i, s = this.chart._animationsDisabled;
    let { start: o, count: l } = X2(i, r, s);
    this._drawStart = o, this._drawCount = l, j2(i) && (o = 0, l = r.length), n._chart = this.chart, n._datasetIndex = this.index, n._decimated = !!a._decimated, n.points = r;
    const u = this.resolveDatasetElementOptions(t);
    this.options.showLine || (u.borderWidth = 0), u.segment = this.options.segment, this.updateElement(n, void 0, {
      animated: !s,
      options: u
    }, t), this.updateElements(r, o, l, t);
  }
  updateElements(t, i, n, r) {
    const a = r === "reset", { iScale: s, vScale: o, _stacked: l, _dataset: u } = this._cachedMeta, { sharedOptions: c, includeOptions: h } = this._getSharedOptions(i, r), d = s.axis, f = o.axis, { spanGaps: v, segment: m } = this.options, p = Do(v) ? v : Number.POSITIVE_INFINITY, g = this.chart._animationsDisabled || a || r === "none", y = i + n, _ = t.length;
    let b = i > 0 && this.getParsed(i - 1);
    for (let w = 0; w < _; ++w) {
      const S = t[w], M = g ? S : {};
      if (w < i || w >= y) {
        M.skip = !0;
        continue;
      }
      const k = this.getParsed(w), T = kt(k[f]), D = M[d] = s.getPixelForValue(k[d], w), C = M[f] = a || T ? o.getBasePixel() : o.getPixelForValue(l ? this.applyStack(o, k, l) : k[f], w);
      M.skip = isNaN(D) || isNaN(C) || T, M.stop = w > 0 && Math.abs(k[d] - b[d]) > p, m && (M.parsed = k, M.raw = u.data[w]), h && (M.options = c || this.resolveDataElementOptions(w, S.active ? "active" : r)), g || this.updateElement(S, w, M, r), b = k;
    }
  }
  getMaxOverflow() {
    const t = this._cachedMeta, i = t.dataset, n = i.options && i.options.borderWidth || 0, r = t.data || [];
    if (!r.length)
      return n;
    const a = r[0].size(this.resolveDataElementOptions(0)), s = r[r.length - 1].size(this.resolveDataElementOptions(r.length - 1));
    return Math.max(n, a, s) / 2;
  }
  draw() {
    const t = this._cachedMeta;
    t.dataset.updateControlPoints(this.chart.chartArea, t.iScale.axis), super.draw();
  }
}
class Sk extends xk {
  static id = "pie";
  static defaults = {
    cutout: 0,
    rotation: 0,
    circumference: 360,
    radius: "100%"
  };
}
function hr() {
  throw new Error("This method is not implemented: Check that a complete date adapter is provided.");
}
class pv {
  /**
  * Override default date adapter methods.
  * Accepts type parameter to define options type.
  * @example
  * Chart._adapters._date.override<{myAdapterOption: string}>({
  *   init() {
  *     console.log(this.options.myAdapterOption);
  *   }
  * })
  */
  static override(t) {
    Object.assign(pv.prototype, t);
  }
  options;
  constructor(t) {
    this.options = t || {};
  }
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  init() {
  }
  formats() {
    return hr();
  }
  parse() {
    return hr();
  }
  format() {
    return hr();
  }
  add() {
    return hr();
  }
  diff() {
    return hr();
  }
  startOf() {
    return hr();
  }
  endOf() {
    return hr();
  }
}
var Mk = {
  _date: pv
};
function kk(e, t, i, n) {
  const { controller: r, data: a, _sorted: s } = e, o = r._cachedMeta.iScale, l = e.dataset && e.dataset.options ? e.dataset.options.spanGaps : null;
  if (o && t === o.axis && t !== "r" && s && a.length) {
    const u = o._reversePixels ? H2 : Hr;
    if (n) {
      if (r._sharedOptions) {
        const c = a[0], h = typeof c.getRange == "function" && c.getRange(t);
        if (h) {
          const d = u(a, t, i - h), f = u(a, t, i + h);
          return {
            lo: d.lo,
            hi: f.hi
          };
        }
      }
    } else {
      const c = u(a, t, i);
      if (l) {
        const { vScale: h } = r._cachedMeta, { _parsed: d } = e, f = d.slice(0, c.lo + 1).reverse().findIndex((m) => !kt(m[h.axis]));
        c.lo -= Math.max(0, f);
        const v = d.slice(c.hi).findIndex((m) => !kt(m[h.axis]));
        c.hi += Math.max(0, v);
      }
      return c;
    }
  }
  return {
    lo: 0,
    hi: a.length - 1
  };
}
function bc(e, t, i, n, r) {
  const a = e.getSortedVisibleDatasetMetas(), s = i[t];
  for (let o = 0, l = a.length; o < l; ++o) {
    const { index: u, data: c } = a[o], { lo: h, hi: d } = kk(a[o], t, s, r);
    for (let f = h; f <= d; ++f) {
      const v = c[f];
      v.skip || n(v, u, f);
    }
  }
}
function Dk(e) {
  const t = e.indexOf("x") !== -1, i = e.indexOf("y") !== -1;
  return function(n, r) {
    const a = t ? Math.abs(n.x - r.x) : 0, s = i ? Math.abs(n.y - r.y) : 0;
    return Math.sqrt(Math.pow(a, 2) + Math.pow(s, 2));
  };
}
function oh(e, t, i, n, r) {
  const a = [];
  return !r && !e.isPointInArea(t) || bc(e, i, t, function(o, l, u) {
    !r && !Co(o, e.chartArea, 0) || o.inRange(t.x, t.y, n) && a.push({
      element: o,
      datasetIndex: l,
      index: u
    });
  }, !0), a;
}
function Tk(e, t, i, n) {
  let r = [];
  function a(s, o, l) {
    const { startAngle: u, endAngle: c } = s.getProps([
      "startAngle",
      "endAngle"
    ], n), { angle: h } = nb(s, {
      x: t.x,
      y: t.y
    });
    To(h, u, c) && r.push({
      element: s,
      datasetIndex: o,
      index: l
    });
  }
  return bc(e, i, t, a), r;
}
function Ck(e, t, i, n, r, a) {
  let s = [];
  const o = Dk(i);
  let l = Number.POSITIVE_INFINITY;
  function u(c, h, d) {
    const f = c.inRange(t.x, t.y, r);
    if (n && !f)
      return;
    const v = c.getCenterPoint(r);
    if (!(!!a || e.isPointInArea(v)) && !f)
      return;
    const p = o(t, v);
    p < l ? (s = [
      {
        element: c,
        datasetIndex: h,
        index: d
      }
    ], l = p) : p === l && s.push({
      element: c,
      datasetIndex: h,
      index: d
    });
  }
  return bc(e, i, t, u), s;
}
function lh(e, t, i, n, r, a) {
  return !a && !e.isPointInArea(t) ? [] : i === "r" && !n ? Tk(e, t, i, r) : Ck(e, t, i, n, r, a);
}
function Cg(e, t, i, n, r) {
  const a = [], s = i === "x" ? "inXRange" : "inYRange";
  let o = !1;
  return bc(e, i, t, (l, u, c) => {
    l[s] && l[s](t[i], r) && (a.push({
      element: l,
      datasetIndex: u,
      index: c
    }), o = o || l.inRange(t.x, t.y, r));
  }), n && !o ? [] : a;
}
var Ek = {
  modes: {
    index(e, t, i, n) {
      const r = Fr(t, e), a = i.axis || "x", s = i.includeInvisible || !1, o = i.intersect ? oh(e, r, a, n, s) : lh(e, r, a, !1, n, s), l = [];
      return o.length ? (e.getSortedVisibleDatasetMetas().forEach((u) => {
        const c = o[0].index, h = u.data[c];
        h && !h.skip && l.push({
          element: h,
          datasetIndex: u.index,
          index: c
        });
      }), l) : [];
    },
    dataset(e, t, i, n) {
      const r = Fr(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      let o = i.intersect ? oh(e, r, a, n, s) : lh(e, r, a, !1, n, s);
      if (o.length > 0) {
        const l = o[0].datasetIndex, u = e.getDatasetMeta(l).data;
        o = [];
        for (let c = 0; c < u.length; ++c)
          o.push({
            element: u[c],
            datasetIndex: l,
            index: c
          });
      }
      return o;
    },
    point(e, t, i, n) {
      const r = Fr(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      return oh(e, r, a, n, s);
    },
    nearest(e, t, i, n) {
      const r = Fr(t, e), a = i.axis || "xy", s = i.includeInvisible || !1;
      return lh(e, r, a, i.intersect, n, s);
    },
    x(e, t, i, n) {
      const r = Fr(t, e);
      return Cg(e, r, "x", i.intersect, n);
    },
    y(e, t, i, n) {
      const r = Fr(t, e);
      return Cg(e, r, "y", i.intersect, n);
    }
  }
};
const kb = [
  "left",
  "top",
  "right",
  "bottom"
];
function ws(e, t) {
  return e.filter((i) => i.pos === t);
}
function Eg(e, t) {
  return e.filter((i) => kb.indexOf(i.pos) === -1 && i.box.axis === t);
}
function Ss(e, t) {
  return e.sort((i, n) => {
    const r = t ? n : i, a = t ? i : n;
    return r.weight === a.weight ? r.index - a.index : r.weight - a.weight;
  });
}
function Ak(e) {
  const t = [];
  let i, n, r, a, s, o;
  for (i = 0, n = (e || []).length; i < n; ++i)
    r = e[i], { position: a, options: { stack: s, stackWeight: o = 1 } } = r, t.push({
      index: i,
      box: r,
      pos: a,
      horizontal: r.isHorizontal(),
      weight: r.weight,
      stack: s && a + s,
      stackWeight: o
    });
  return t;
}
function Pk(e) {
  const t = {};
  for (const i of e) {
    const { stack: n, pos: r, stackWeight: a } = i;
    if (!n || !kb.includes(r))
      continue;
    const s = t[n] || (t[n] = {
      count: 0,
      placed: 0,
      weight: 0,
      size: 0
    });
    s.count++, s.weight += a;
  }
  return t;
}
function Lk(e, t) {
  const i = Pk(e), { vBoxMaxWidth: n, hBoxMaxHeight: r } = t;
  let a, s, o;
  for (a = 0, s = e.length; a < s; ++a) {
    o = e[a];
    const { fullSize: l } = o.box, u = i[o.stack], c = u && o.stackWeight / u.weight;
    o.horizontal ? (o.width = c ? c * n : l && t.availableWidth, o.height = r) : (o.width = n, o.height = c ? c * r : l && t.availableHeight);
  }
  return i;
}
function Ok(e) {
  const t = Ak(e), i = Ss(t.filter((u) => u.box.fullSize), !0), n = Ss(ws(t, "left"), !0), r = Ss(ws(t, "right")), a = Ss(ws(t, "top"), !0), s = Ss(ws(t, "bottom")), o = Eg(t, "x"), l = Eg(t, "y");
  return {
    fullSize: i,
    leftAndTop: n.concat(a),
    rightAndBottom: r.concat(l).concat(s).concat(o),
    chartArea: ws(t, "chartArea"),
    vertical: n.concat(r).concat(l),
    horizontal: a.concat(s).concat(o)
  };
}
function Ag(e, t, i, n) {
  return Math.max(e[i], t[i]) + Math.max(e[n], t[n]);
}
function Db(e, t) {
  e.top = Math.max(e.top, t.top), e.left = Math.max(e.left, t.left), e.bottom = Math.max(e.bottom, t.bottom), e.right = Math.max(e.right, t.right);
}
function Ik(e, t, i, n) {
  const { pos: r, box: a } = i, s = e.maxPadding;
  if (!vt(r)) {
    i.size && (e[r] -= i.size);
    const h = n[i.stack] || {
      size: 0,
      count: 1
    };
    h.size = Math.max(h.size, i.horizontal ? a.height : a.width), i.size = h.size / h.count, e[r] += i.size;
  }
  a.getPadding && Db(s, a.getPadding());
  const o = Math.max(0, t.outerWidth - Ag(s, e, "left", "right")), l = Math.max(0, t.outerHeight - Ag(s, e, "top", "bottom")), u = o !== e.w, c = l !== e.h;
  return e.w = o, e.h = l, i.horizontal ? {
    same: u,
    other: c
  } : {
    same: c,
    other: u
  };
}
function Rk(e) {
  const t = e.maxPadding;
  function i(n) {
    const r = Math.max(t[n] - e[n], 0);
    return e[n] += r, r;
  }
  e.y += i("top"), e.x += i("left"), i("right"), i("bottom");
}
function Nk(e, t) {
  const i = t.maxPadding;
  function n(r) {
    const a = {
      left: 0,
      top: 0,
      right: 0,
      bottom: 0
    };
    return r.forEach((s) => {
      a[s] = Math.max(t[s], i[s]);
    }), a;
  }
  return n(e ? [
    "left",
    "right"
  ] : [
    "top",
    "bottom"
  ]);
}
function Ks(e, t, i, n) {
  const r = [];
  let a, s, o, l, u, c;
  for (a = 0, s = e.length, u = 0; a < s; ++a) {
    o = e[a], l = o.box, l.update(o.width || t.w, o.height || t.h, Nk(o.horizontal, t));
    const { same: h, other: d } = Ik(t, i, o, n);
    u |= h && r.length, c = c || d, l.fullSize || r.push(o);
  }
  return u && Ks(r, t, i, n) || c;
}
function hl(e, t, i, n, r) {
  e.top = i, e.left = t, e.right = t + n, e.bottom = i + r, e.width = n, e.height = r;
}
function Pg(e, t, i, n) {
  const r = i.padding;
  let { x: a, y: s } = t;
  for (const o of e) {
    const l = o.box, u = n[o.stack] || {
      placed: 0,
      weight: 1
    }, c = o.stackWeight / u.weight || 1;
    if (o.horizontal) {
      const h = t.w * c, d = u.size || l.height;
      ko(u.start) && (s = u.start), l.fullSize ? hl(l, r.left, s, i.outerWidth - r.right - r.left, d) : hl(l, t.left + u.placed, s, h, d), u.start = s, u.placed += h, s = l.bottom;
    } else {
      const h = t.h * c, d = u.size || l.width;
      ko(u.start) && (a = u.start), l.fullSize ? hl(l, a, r.top, d, i.outerHeight - r.bottom - r.top) : hl(l, a, t.top + u.placed, d, h), u.start = a, u.placed += h, a = l.right;
    }
  }
  t.x = a, t.y = s;
}
var pi = {
  addBox(e, t) {
    e.boxes || (e.boxes = []), t.fullSize = t.fullSize || !1, t.position = t.position || "top", t.weight = t.weight || 0, t._layers = t._layers || function() {
      return [
        {
          z: 0,
          draw(i) {
            t.draw(i);
          }
        }
      ];
    }, e.boxes.push(t);
  },
  removeBox(e, t) {
    const i = e.boxes ? e.boxes.indexOf(t) : -1;
    i !== -1 && e.boxes.splice(i, 1);
  },
  configure(e, t, i) {
    t.fullSize = i.fullSize, t.position = i.position, t.weight = i.weight;
  },
  update(e, t, i, n) {
    if (!e)
      return;
    const r = yi(e.options.layout.padding), a = Math.max(t - r.width, 0), s = Math.max(i - r.height, 0), o = Ok(e.boxes), l = o.vertical, u = o.horizontal;
    Ct(e.boxes, (m) => {
      typeof m.beforeLayout == "function" && m.beforeLayout();
    });
    const c = l.reduce((m, p) => p.box.options && p.box.options.display === !1 ? m : m + 1, 0) || 1, h = Object.freeze({
      outerWidth: t,
      outerHeight: i,
      padding: r,
      availableWidth: a,
      availableHeight: s,
      vBoxMaxWidth: a / 2 / c,
      hBoxMaxHeight: s / 2
    }), d = Object.assign({}, r);
    Db(d, yi(n));
    const f = Object.assign({
      maxPadding: d,
      w: a,
      h: s,
      x: r.left,
      y: r.top
    }, r), v = Lk(l.concat(u), h);
    Ks(o.fullSize, f, h, v), Ks(l, f, h, v), Ks(u, f, h, v) && Ks(l, f, h, v), Rk(f), Pg(o.leftAndTop, f, h, v), f.x += f.w, f.y += f.h, Pg(o.rightAndBottom, f, h, v), e.chartArea = {
      left: f.left,
      top: f.top,
      right: f.left + f.w,
      bottom: f.top + f.h,
      height: f.h,
      width: f.w
    }, Ct(o.chartArea, (m) => {
      const p = m.box;
      Object.assign(p, e.chartArea), p.update(f.w, f.h, {
        left: 0,
        top: 0,
        right: 0,
        bottom: 0
      });
    });
  }
};
class Tb {
  acquireContext(t, i) {
  }
  releaseContext(t) {
    return !1;
  }
  addEventListener(t, i, n) {
  }
  removeEventListener(t, i, n) {
  }
  getDevicePixelRatio() {
    return 1;
  }
  getMaximumSize(t, i, n, r) {
    return i = Math.max(0, i || t.width), n = n || t.height, {
      width: i,
      height: Math.max(0, r ? Math.floor(i / r) : n)
    };
  }
  isAttached(t) {
    return !0;
  }
  updateConfig(t) {
  }
}
class Fk extends Tb {
  acquireContext(t) {
    return t && t.getContext && t.getContext("2d") || null;
  }
  updateConfig(t) {
    t.options.animation = !1;
  }
}
const iu = "$chartjs", Bk = {
  touchstart: "mousedown",
  touchmove: "mousemove",
  touchend: "mouseup",
  pointerenter: "mouseenter",
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointerleave: "mouseout",
  pointerout: "mouseout"
}, Lg = (e) => e === null || e === "";
function $k(e, t) {
  const i = e.style, n = e.getAttribute("height"), r = e.getAttribute("width");
  if (e[iu] = {
    initial: {
      height: n,
      width: r,
      style: {
        display: i.display,
        height: i.height,
        width: i.width
      }
    }
  }, i.display = i.display || "block", i.boxSizing = i.boxSizing || "border-box", Lg(r)) {
    const a = pg(e, "width");
    a !== void 0 && (e.width = a);
  }
  if (Lg(n))
    if (e.style.height === "")
      e.height = e.width / (t || 2);
    else {
      const a = pg(e, "height");
      a !== void 0 && (e.height = a);
    }
  return e;
}
const Cb = FM ? {
  passive: !0
} : !1;
function zk(e, t, i) {
  e && e.addEventListener(t, i, Cb);
}
function Vk(e, t, i) {
  e && e.canvas && e.canvas.removeEventListener(t, i, Cb);
}
function Hk(e, t) {
  const i = Bk[e.type] || e.type, { x: n, y: r } = Fr(e, t);
  return {
    type: i,
    chart: t,
    native: e,
    x: n !== void 0 ? n : null,
    y: r !== void 0 ? r : null
  };
}
function ku(e, t) {
  for (const i of e)
    if (i === t || i.contains(t))
      return !0;
}
function Yk(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let s = !1;
    for (const o of a)
      s = s || ku(o.addedNodes, n), s = s && !ku(o.removedNodes, n);
    s && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
function Wk(e, t, i) {
  const n = e.canvas, r = new MutationObserver((a) => {
    let s = !1;
    for (const o of a)
      s = s || ku(o.removedNodes, n), s = s && !ku(o.addedNodes, n);
    s && i();
  });
  return r.observe(document, {
    childList: !0,
    subtree: !0
  }), r;
}
const Ao = /* @__PURE__ */ new Map();
let Og = 0;
function Eb() {
  const e = window.devicePixelRatio;
  e !== Og && (Og = e, Ao.forEach((t, i) => {
    i.currentDevicePixelRatio !== e && t();
  }));
}
function Uk(e, t) {
  Ao.size || window.addEventListener("resize", Eb), Ao.set(e, t);
}
function Gk(e) {
  Ao.delete(e), Ao.size || window.removeEventListener("resize", Eb);
}
function Xk(e, t, i) {
  const n = e.canvas, r = n && vv(n);
  if (!r)
    return;
  const a = ob((o, l) => {
    const u = r.clientWidth;
    i(o, l), u < r.clientWidth && i();
  }, window), s = new ResizeObserver((o) => {
    const l = o[0], u = l.contentRect.width, c = l.contentRect.height;
    u === 0 && c === 0 || a(u, c);
  });
  return s.observe(r), Uk(e, a), s;
}
function uh(e, t, i) {
  i && i.disconnect(), t === "resize" && Gk(e);
}
function jk(e, t, i) {
  const n = e.canvas, r = ob((a) => {
    e.ctx !== null && i(Hk(a, e));
  }, e);
  return zk(n, t, r), r;
}
class qk extends Tb {
  acquireContext(t, i) {
    const n = t && t.getContext && t.getContext("2d");
    return n && n.canvas === t ? ($k(t, i), n) : null;
  }
  releaseContext(t) {
    const i = t.canvas;
    if (!i[iu])
      return !1;
    const n = i[iu].initial;
    [
      "height",
      "width"
    ].forEach((a) => {
      const s = n[a];
      kt(s) ? i.removeAttribute(a) : i.setAttribute(a, s);
    });
    const r = n.style || {};
    return Object.keys(r).forEach((a) => {
      i.style[a] = r[a];
    }), i.width = i.width, delete i[iu], !0;
  }
  addEventListener(t, i, n) {
    this.removeEventListener(t, i);
    const r = t.$proxies || (t.$proxies = {}), s = {
      attach: Yk,
      detach: Wk,
      resize: Xk
    }[i] || jk;
    r[i] = s(t, i, n);
  }
  removeEventListener(t, i) {
    const n = t.$proxies || (t.$proxies = {}), r = n[i];
    if (!r)
      return;
    ({
      attach: uh,
      detach: uh,
      resize: uh
    }[i] || Vk)(t, i, r), n[i] = void 0;
  }
  getDevicePixelRatio() {
    return window.devicePixelRatio;
  }
  getMaximumSize(t, i, n, r) {
    return NM(t, i, n, r);
  }
  isAttached(t) {
    const i = t && vv(t);
    return !!(i && i.isConnected);
  }
}
function Zk(e) {
  return !fv() || typeof OffscreenCanvas < "u" && e instanceof OffscreenCanvas ? Fk : qk;
}
let Pn = class {
  static defaults = {};
  static defaultRoutes = void 0;
  x;
  y;
  active = !1;
  options;
  $animations;
  tooltipPosition(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  hasValue() {
    return Do(this.x) && Do(this.y);
  }
  getProps(t, i) {
    const n = this.$animations;
    if (!i || !n)
      return this;
    const r = {};
    return t.forEach((a) => {
      r[a] = n[a] && n[a].active() ? n[a]._to : this[a];
    }), r;
  }
};
function Kk(e, t) {
  const i = e.options.ticks, n = Qk(e), r = Math.min(i.maxTicksLimit || n, n), a = i.major.enabled ? tD(t) : [], s = a.length, o = a[0], l = a[s - 1], u = [];
  if (s > r)
    return eD(t, u, a, s / r), u;
  const c = Jk(a, t, r);
  if (s > 0) {
    let h, d;
    const f = s > 1 ? Math.round((l - o) / (s - 1)) : null;
    for (dl(t, u, c, kt(f) ? 0 : o - f, o), h = 0, d = s - 1; h < d; h++)
      dl(t, u, c, a[h], a[h + 1]);
    return dl(t, u, c, l, kt(f) ? t.length : l + f), u;
  }
  return dl(t, u, c), u;
}
function Qk(e) {
  const t = e.options.offset, i = e._tickSize(), n = e._length / i + (t ? 0 : 1), r = e._maxLength / i;
  return Math.floor(Math.min(n, r));
}
function Jk(e, t, i) {
  const n = iD(e), r = t.length / i;
  if (!n)
    return Math.max(r, 1);
  const a = R2(n);
  for (let s = 0, o = a.length - 1; s < o; s++) {
    const l = a[s];
    if (l > r)
      return l;
  }
  return Math.max(r, 1);
}
function tD(e) {
  const t = [];
  let i, n;
  for (i = 0, n = e.length; i < n; i++)
    e[i].major && t.push(i);
  return t;
}
function eD(e, t, i, n) {
  let r = 0, a = i[0], s;
  for (n = Math.ceil(n), s = 0; s < e.length; s++)
    s === a && (t.push(e[s]), r++, a = i[r * n]);
}
function dl(e, t, i, n, r) {
  const a = ct(n, 0), s = Math.min(ct(r, e.length), e.length);
  let o = 0, l, u, c;
  for (i = Math.ceil(i), r && (l = r - n, i = l / Math.floor(l / i)), c = a; c < 0; )
    o++, c = Math.round(a + o * i);
  for (u = Math.max(a, 0); u < s; u++)
    u === c && (t.push(e[u]), o++, c = Math.round(a + o * i));
}
function iD(e) {
  const t = e.length;
  let i, n;
  if (t < 2)
    return !1;
  for (n = e[0], i = 1; i < t; ++i)
    if (e[i] - e[i - 1] !== n)
      return !1;
  return n;
}
const nD = (e) => e === "left" ? "right" : e === "right" ? "left" : e, Ig = (e, t, i) => t === "top" || t === "left" ? e[t] + i : e[t] - i, Rg = (e, t) => Math.min(t || e, e);
function Ng(e, t) {
  const i = [], n = e.length / t, r = e.length;
  let a = 0;
  for (; a < r; a += n)
    i.push(e[Math.floor(a)]);
  return i;
}
function rD(e, t, i) {
  const n = e.ticks.length, r = Math.min(t, n - 1), a = e._startPixel, s = e._endPixel, o = 1e-6;
  let l = e.getPixelForTick(r), u;
  if (!(i && (n === 1 ? u = Math.max(l - a, s - l) : t === 0 ? u = (e.getPixelForTick(1) - l) / 2 : u = (l - e.getPixelForTick(r - 1)) / 2, l += r < t ? u : -u, l < a - o || l > s + o)))
    return l;
}
function aD(e, t) {
  Ct(e, (i) => {
    const n = i.gc, r = n.length / 2;
    let a;
    if (r > t) {
      for (a = 0; a < r; ++a)
        delete i.data[n[a]];
      n.splice(0, r);
    }
  });
}
function Ms(e) {
  return e.drawTicks ? e.tickLength : 0;
}
function Fg(e, t) {
  if (!e.display)
    return 0;
  const i = Me(e.font, t), n = yi(e.padding);
  return (ae(e.text) ? e.text.length : 1) * i.lineHeight + n.height;
}
function sD(e, t) {
  return ca(e, {
    scale: t,
    type: "scale"
  });
}
function oD(e, t, i) {
  return ca(e, {
    tick: i,
    index: t,
    type: "tick"
  });
}
function lD(e, t, i) {
  let n = sv(e);
  return (i && t !== "right" || !i && t === "right") && (n = nD(n)), n;
}
function uD(e, t, i, n) {
  const { top: r, left: a, bottom: s, right: o, chart: l } = e, { chartArea: u, scales: c } = l;
  let h = 0, d, f, v;
  const m = s - r, p = o - a;
  if (e.isHorizontal()) {
    if (f = xe(n, a, o), vt(i)) {
      const g = Object.keys(i)[0], y = i[g];
      v = c[g].getPixelForValue(y) + m - t;
    } else i === "center" ? v = (u.bottom + u.top) / 2 + m - t : v = Ig(e, i, t);
    d = o - a;
  } else {
    if (vt(i)) {
      const g = Object.keys(i)[0], y = i[g];
      f = c[g].getPixelForValue(y) - p + t;
    } else i === "center" ? f = (u.left + u.right) / 2 - p + t : f = Ig(e, i, t);
    v = xe(n, s, r), h = i === "left" ? -he : he;
  }
  return {
    titleX: f,
    titleY: v,
    maxWidth: d,
    rotation: h
  };
}
class ds extends Pn {
  constructor(t) {
    super(), this.id = t.id, this.type = t.type, this.options = void 0, this.ctx = t.ctx, this.chart = t.chart, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this._margins = {
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, this.maxWidth = void 0, this.maxHeight = void 0, this.paddingTop = void 0, this.paddingBottom = void 0, this.paddingLeft = void 0, this.paddingRight = void 0, this.axis = void 0, this.labelRotation = void 0, this.min = void 0, this.max = void 0, this._range = void 0, this.ticks = [], this._gridLineItems = null, this._labelItems = null, this._labelSizes = null, this._length = 0, this._maxLength = 0, this._longestTextCache = {}, this._startPixel = void 0, this._endPixel = void 0, this._reversePixels = !1, this._userMax = void 0, this._userMin = void 0, this._suggestedMax = void 0, this._suggestedMin = void 0, this._ticksLength = 0, this._borderValue = 0, this._cache = {}, this._dataLimitsCached = !1, this.$context = void 0;
  }
  init(t) {
    this.options = t.setContext(this.getContext()), this.axis = t.axis, this._userMin = this.parse(t.min), this._userMax = this.parse(t.max), this._suggestedMin = this.parse(t.suggestedMin), this._suggestedMax = this.parse(t.suggestedMax);
  }
  parse(t, i) {
    return t;
  }
  getUserBounds() {
    let { _userMin: t, _userMax: i, _suggestedMin: n, _suggestedMax: r } = this;
    return t = Fi(t, Number.POSITIVE_INFINITY), i = Fi(i, Number.NEGATIVE_INFINITY), n = Fi(n, Number.POSITIVE_INFINITY), r = Fi(r, Number.NEGATIVE_INFINITY), {
      min: Fi(t, n),
      max: Fi(i, r),
      minDefined: Ce(t),
      maxDefined: Ce(i)
    };
  }
  getMinMax(t) {
    let { min: i, max: n, minDefined: r, maxDefined: a } = this.getUserBounds(), s;
    if (r && a)
      return {
        min: i,
        max: n
      };
    const o = this.getMatchingVisibleMetas();
    for (let l = 0, u = o.length; l < u; ++l)
      s = o[l].controller.getMinMax(this, t), r || (i = Math.min(i, s.min)), a || (n = Math.max(n, s.max));
    return i = a && i > n ? n : i, n = r && i > n ? i : n, {
      min: Fi(i, Fi(n, i)),
      max: Fi(n, Fi(i, n))
    };
  }
  getPadding() {
    return {
      left: this.paddingLeft || 0,
      top: this.paddingTop || 0,
      right: this.paddingRight || 0,
      bottom: this.paddingBottom || 0
    };
  }
  getTicks() {
    return this.ticks;
  }
  getLabels() {
    const t = this.chart.data;
    return this.options.labels || (this.isHorizontal() ? t.xLabels : t.yLabels) || t.labels || [];
  }
  getLabelItems(t = this.chart.chartArea) {
    return this._labelItems || (this._labelItems = this._computeLabelItems(t));
  }
  beforeLayout() {
    this._cache = {}, this._dataLimitsCached = !1;
  }
  beforeUpdate() {
    zt(this.options.beforeUpdate, [
      this
    ]);
  }
  update(t, i, n) {
    const { beginAtZero: r, grace: a, ticks: s } = this.options, o = s.sampleSize;
    this.beforeUpdate(), this.maxWidth = t, this.maxHeight = i, this._margins = n = Object.assign({
      left: 0,
      right: 0,
      top: 0,
      bottom: 0
    }, n), this.ticks = null, this._labelSizes = null, this._gridLineItems = null, this._labelItems = null, this.beforeSetDimensions(), this.setDimensions(), this.afterSetDimensions(), this._maxLength = this.isHorizontal() ? this.width + n.left + n.right : this.height + n.top + n.bottom, this._dataLimitsCached || (this.beforeDataLimits(), this.determineDataLimits(), this.afterDataLimits(), this._range = vM(this, a, r), this._dataLimitsCached = !0), this.beforeBuildTicks(), this.ticks = this.buildTicks() || [], this.afterBuildTicks();
    const l = o < this.ticks.length;
    this._convertTicksToLabels(l ? Ng(this.ticks, o) : this.ticks), this.configure(), this.beforeCalculateLabelRotation(), this.calculateLabelRotation(), this.afterCalculateLabelRotation(), s.display && (s.autoSkip || s.source === "auto") && (this.ticks = Kk(this, this.ticks), this._labelSizes = null, this.afterAutoSkip()), l && this._convertTicksToLabels(this.ticks), this.beforeFit(), this.fit(), this.afterFit(), this.afterUpdate();
  }
  configure() {
    let t = this.options.reverse, i, n;
    this.isHorizontal() ? (i = this.left, n = this.right) : (i = this.top, n = this.bottom, t = !t), this._startPixel = i, this._endPixel = n, this._reversePixels = t, this._length = n - i, this._alignToPixels = this.options.alignToPixels;
  }
  afterUpdate() {
    zt(this.options.afterUpdate, [
      this
    ]);
  }
  beforeSetDimensions() {
    zt(this.options.beforeSetDimensions, [
      this
    ]);
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = 0, this.right = this.width) : (this.height = this.maxHeight, this.top = 0, this.bottom = this.height), this.paddingLeft = 0, this.paddingTop = 0, this.paddingRight = 0, this.paddingBottom = 0;
  }
  afterSetDimensions() {
    zt(this.options.afterSetDimensions, [
      this
    ]);
  }
  _callHooks(t) {
    this.chart.notifyPlugins(t, this.getContext()), zt(this.options[t], [
      this
    ]);
  }
  beforeDataLimits() {
    this._callHooks("beforeDataLimits");
  }
  determineDataLimits() {
  }
  afterDataLimits() {
    this._callHooks("afterDataLimits");
  }
  beforeBuildTicks() {
    this._callHooks("beforeBuildTicks");
  }
  buildTicks() {
    return [];
  }
  afterBuildTicks() {
    this._callHooks("afterBuildTicks");
  }
  beforeTickToLabelConversion() {
    zt(this.options.beforeTickToLabelConversion, [
      this
    ]);
  }
  generateTickLabels(t) {
    const i = this.options.ticks;
    let n, r, a;
    for (n = 0, r = t.length; n < r; n++)
      a = t[n], a.label = zt(i.callback, [
        a.value,
        n,
        t
      ], this);
  }
  afterTickToLabelConversion() {
    zt(this.options.afterTickToLabelConversion, [
      this
    ]);
  }
  beforeCalculateLabelRotation() {
    zt(this.options.beforeCalculateLabelRotation, [
      this
    ]);
  }
  calculateLabelRotation() {
    const t = this.options, i = t.ticks, n = Rg(this.ticks.length, t.ticks.maxTicksLimit), r = i.minRotation || 0, a = i.maxRotation;
    let s = r, o, l, u;
    if (!this._isVisible() || !i.display || r >= a || n <= 1 || !this.isHorizontal()) {
      this.labelRotation = r;
      return;
    }
    const c = this._getLabelSizes(), h = c.widest.width, d = c.highest.height, f = Se(this.chart.width - h, 0, this.maxWidth);
    o = t.offset ? this.maxWidth / n : f / (n - 1), h + 6 > o && (o = f / (n - (t.offset ? 0.5 : 1)), l = this.maxHeight - Ms(t.grid) - i.padding - Fg(t.title, this.chart.options.font), u = Math.sqrt(h * h + d * d), s = $2(Math.min(Math.asin(Se((c.highest.height + 6) / o, -1, 1)), Math.asin(Se(l / u, -1, 1)) - Math.asin(Se(d / u, -1, 1)))), s = Math.max(r, Math.min(a, s))), this.labelRotation = s;
  }
  afterCalculateLabelRotation() {
    zt(this.options.afterCalculateLabelRotation, [
      this
    ]);
  }
  afterAutoSkip() {
  }
  beforeFit() {
    zt(this.options.beforeFit, [
      this
    ]);
  }
  fit() {
    const t = {
      width: 0,
      height: 0
    }, { chart: i, options: { ticks: n, title: r, grid: a } } = this, s = this._isVisible(), o = this.isHorizontal();
    if (s) {
      const l = Fg(r, i.options.font);
      if (o ? (t.width = this.maxWidth, t.height = Ms(a) + l) : (t.height = this.maxHeight, t.width = Ms(a) + l), n.display && this.ticks.length) {
        const { first: u, last: c, widest: h, highest: d } = this._getLabelSizes(), f = n.padding * 2, v = mn(this.labelRotation), m = Math.cos(v), p = Math.sin(v);
        if (o) {
          const g = n.mirror ? 0 : p * h.width + m * d.height;
          t.height = Math.min(this.maxHeight, t.height + g + f);
        } else {
          const g = n.mirror ? 0 : m * h.width + p * d.height;
          t.width = Math.min(this.maxWidth, t.width + g + f);
        }
        this._calculatePadding(u, c, p, m);
      }
    }
    this._handleMargins(), o ? (this.width = this._length = i.width - this._margins.left - this._margins.right, this.height = t.height) : (this.width = t.width, this.height = this._length = i.height - this._margins.top - this._margins.bottom);
  }
  _calculatePadding(t, i, n, r) {
    const { ticks: { align: a, padding: s }, position: o } = this.options, l = this.labelRotation !== 0, u = o !== "top" && this.axis === "x";
    if (this.isHorizontal()) {
      const c = this.getPixelForTick(0) - this.left, h = this.right - this.getPixelForTick(this.ticks.length - 1);
      let d = 0, f = 0;
      l ? u ? (d = r * t.width, f = n * i.height) : (d = n * t.height, f = r * i.width) : a === "start" ? f = i.width : a === "end" ? d = t.width : a !== "inner" && (d = t.width / 2, f = i.width / 2), this.paddingLeft = Math.max((d - c + s) * this.width / (this.width - c), 0), this.paddingRight = Math.max((f - h + s) * this.width / (this.width - h), 0);
    } else {
      let c = i.height / 2, h = t.height / 2;
      a === "start" ? (c = 0, h = t.height) : a === "end" && (c = i.height, h = 0), this.paddingTop = c + s, this.paddingBottom = h + s;
    }
  }
  _handleMargins() {
    this._margins && (this._margins.left = Math.max(this.paddingLeft, this._margins.left), this._margins.top = Math.max(this.paddingTop, this._margins.top), this._margins.right = Math.max(this.paddingRight, this._margins.right), this._margins.bottom = Math.max(this.paddingBottom, this._margins.bottom));
  }
  afterFit() {
    zt(this.options.afterFit, [
      this
    ]);
  }
  isHorizontal() {
    const { axis: t, position: i } = this.options;
    return i === "top" || i === "bottom" || t === "x";
  }
  isFullSize() {
    return this.options.fullSize;
  }
  _convertTicksToLabels(t) {
    this.beforeTickToLabelConversion(), this.generateTickLabels(t);
    let i, n;
    for (i = 0, n = t.length; i < n; i++)
      kt(t[i].label) && (t.splice(i, 1), n--, i--);
    this.afterTickToLabelConversion();
  }
  _getLabelSizes() {
    let t = this._labelSizes;
    if (!t) {
      const i = this.options.ticks.sampleSize;
      let n = this.ticks;
      i < n.length && (n = Ng(n, i)), this._labelSizes = t = this._computeLabelSizes(n, n.length, this.options.ticks.maxTicksLimit);
    }
    return t;
  }
  _computeLabelSizes(t, i, n) {
    const { ctx: r, _longestTextCache: a } = this, s = [], o = [], l = Math.floor(i / Rg(i, n));
    let u = 0, c = 0, h, d, f, v, m, p, g, y, _, b, w;
    for (h = 0; h < i; h += l) {
      if (v = t[h].label, m = this._resolveTickFontOptions(h), r.font = p = m.string, g = a[p] = a[p] || {
        data: {},
        gc: []
      }, y = m.lineHeight, _ = b = 0, !kt(v) && !ae(v))
        _ = cg(r, g.data, g.gc, _, v), b = y;
      else if (ae(v))
        for (d = 0, f = v.length; d < f; ++d)
          w = v[d], !kt(w) && !ae(w) && (_ = cg(r, g.data, g.gc, _, w), b += y);
      s.push(_), o.push(b), u = Math.max(_, u), c = Math.max(b, c);
    }
    aD(a, i);
    const S = s.indexOf(u), M = o.indexOf(c), k = (T) => ({
      width: s[T] || 0,
      height: o[T] || 0
    });
    return {
      first: k(0),
      last: k(i - 1),
      widest: k(S),
      highest: k(M),
      widths: s,
      heights: o
    };
  }
  getLabelForValue(t) {
    return t;
  }
  getPixelForValue(t, i) {
    return NaN;
  }
  getValueForPixel(t) {
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getPixelForDecimal(t) {
    this._reversePixels && (t = 1 - t);
    const i = this._startPixel + t * this._length;
    return V2(this._alignToPixels ? cr(this.chart, i, 0) : i);
  }
  getDecimalForPixel(t) {
    const i = (t - this._startPixel) / this._length;
    return this._reversePixels ? 1 - i : i;
  }
  getBasePixel() {
    return this.getPixelForValue(this.getBaseValue());
  }
  getBaseValue() {
    const { min: t, max: i } = this;
    return t < 0 && i < 0 ? i : t > 0 && i > 0 ? t : 0;
  }
  getContext(t) {
    const i = this.ticks || [];
    if (t >= 0 && t < i.length) {
      const n = i[t];
      return n.$context || (n.$context = oD(this.getContext(), t, n));
    }
    return this.$context || (this.$context = sD(this.chart.getContext(), this));
  }
  _tickSize() {
    const t = this.options.ticks, i = mn(this.labelRotation), n = Math.abs(Math.cos(i)), r = Math.abs(Math.sin(i)), a = this._getLabelSizes(), s = t.autoSkipPadding || 0, o = a ? a.widest.width + s : 0, l = a ? a.highest.height + s : 0;
    return this.isHorizontal() ? l * n > o * r ? o / n : l / r : l * r < o * n ? l / n : o / r;
  }
  _isVisible() {
    const t = this.options.display;
    return t !== "auto" ? !!t : this.getMatchingVisibleMetas().length > 0;
  }
  _computeGridLineItems(t) {
    const i = this.axis, n = this.chart, r = this.options, { grid: a, position: s, border: o } = r, l = a.offset, u = this.isHorizontal(), h = this.ticks.length + (l ? 1 : 0), d = Ms(a), f = [], v = o.setContext(this.getContext()), m = v.display ? v.width : 0, p = m / 2, g = function(B) {
      return cr(n, B, m);
    };
    let y, _, b, w, S, M, k, T, D, C, P, L;
    if (s === "top")
      y = g(this.bottom), M = this.bottom - d, T = y - p, C = g(t.top) + p, L = t.bottom;
    else if (s === "bottom")
      y = g(this.top), C = t.top, L = g(t.bottom) - p, M = y + p, T = this.top + d;
    else if (s === "left")
      y = g(this.right), S = this.right - d, k = y - p, D = g(t.left) + p, P = t.right;
    else if (s === "right")
      y = g(this.left), D = t.left, P = g(t.right) - p, S = y + p, k = this.left + d;
    else if (i === "x") {
      if (s === "center")
        y = g((t.top + t.bottom) / 2 + 0.5);
      else if (vt(s)) {
        const B = Object.keys(s)[0], G = s[B];
        y = g(this.chart.scales[B].getPixelForValue(G));
      }
      C = t.top, L = t.bottom, M = y + p, T = M + d;
    } else if (i === "y") {
      if (s === "center")
        y = g((t.left + t.right) / 2);
      else if (vt(s)) {
        const B = Object.keys(s)[0], G = s[B];
        y = g(this.chart.scales[B].getPixelForValue(G));
      }
      S = y - p, k = S - d, D = t.left, P = t.right;
    }
    const O = ct(r.ticks.maxTicksLimit, h), N = Math.max(1, Math.ceil(h / O));
    for (_ = 0; _ < h; _ += N) {
      const B = this.getContext(_), G = a.setContext(B), V = o.setContext(B), F = G.lineWidth, $ = G.color, Z = V.dash || [], j = V.dashOffset, it = G.tickWidth, st = G.tickColor, wt = G.tickBorderDash || [], Tt = G.tickBorderDashOffset;
      b = rD(this, _, l), b !== void 0 && (w = cr(n, b, F), u ? S = k = D = P = w : M = T = C = L = w, f.push({
        tx1: S,
        ty1: M,
        tx2: k,
        ty2: T,
        x1: D,
        y1: C,
        x2: P,
        y2: L,
        width: F,
        color: $,
        borderDash: Z,
        borderDashOffset: j,
        tickWidth: it,
        tickColor: st,
        tickBorderDash: wt,
        tickBorderDashOffset: Tt
      }));
    }
    return this._ticksLength = h, this._borderValue = y, f;
  }
  _computeLabelItems(t) {
    const i = this.axis, n = this.options, { position: r, ticks: a } = n, s = this.isHorizontal(), o = this.ticks, { align: l, crossAlign: u, padding: c, mirror: h } = a, d = Ms(n.grid), f = d + c, v = h ? -c : f, m = -mn(this.labelRotation), p = [];
    let g, y, _, b, w, S, M, k, T, D, C, P, L = "middle";
    if (r === "top")
      S = this.bottom - v, M = this._getXAxisLabelAlignment();
    else if (r === "bottom")
      S = this.top + v, M = this._getXAxisLabelAlignment();
    else if (r === "left") {
      const N = this._getYAxisLabelAlignment(d);
      M = N.textAlign, w = N.x;
    } else if (r === "right") {
      const N = this._getYAxisLabelAlignment(d);
      M = N.textAlign, w = N.x;
    } else if (i === "x") {
      if (r === "center")
        S = (t.top + t.bottom) / 2 + f;
      else if (vt(r)) {
        const N = Object.keys(r)[0], B = r[N];
        S = this.chart.scales[N].getPixelForValue(B) + f;
      }
      M = this._getXAxisLabelAlignment();
    } else if (i === "y") {
      if (r === "center")
        w = (t.left + t.right) / 2 - f;
      else if (vt(r)) {
        const N = Object.keys(r)[0], B = r[N];
        w = this.chart.scales[N].getPixelForValue(B);
      }
      M = this._getYAxisLabelAlignment(d).textAlign;
    }
    i === "y" && (l === "start" ? L = "top" : l === "end" && (L = "bottom"));
    const O = this._getLabelSizes();
    for (g = 0, y = o.length; g < y; ++g) {
      _ = o[g], b = _.label;
      const N = a.setContext(this.getContext(g));
      k = this.getPixelForTick(g) + a.labelOffset, T = this._resolveTickFontOptions(g), D = T.lineHeight, C = ae(b) ? b.length : 1;
      const B = C / 2, G = N.color, V = N.textStrokeColor, F = N.textStrokeWidth;
      let $ = M;
      s ? (w = k, M === "inner" && (g === y - 1 ? $ = this.options.reverse ? "left" : "right" : g === 0 ? $ = this.options.reverse ? "right" : "left" : $ = "center"), r === "top" ? u === "near" || m !== 0 ? P = -C * D + D / 2 : u === "center" ? P = -O.highest.height / 2 - B * D + D : P = -O.highest.height + D / 2 : u === "near" || m !== 0 ? P = D / 2 : u === "center" ? P = O.highest.height / 2 - B * D : P = O.highest.height - C * D, h && (P *= -1), m !== 0 && !N.showLabelBackdrop && (w += D / 2 * Math.sin(m))) : (S = k, P = (1 - C) * D / 2);
      let Z;
      if (N.showLabelBackdrop) {
        const j = yi(N.backdropPadding), it = O.heights[g], st = O.widths[g];
        let wt = P - j.top, Tt = 0 - j.left;
        switch (L) {
          case "middle":
            wt -= it / 2;
            break;
          case "bottom":
            wt -= it;
            break;
        }
        switch (M) {
          case "center":
            Tt -= st / 2;
            break;
          case "right":
            Tt -= st;
            break;
          case "inner":
            g === y - 1 ? Tt -= st : g > 0 && (Tt -= st / 2);
            break;
        }
        Z = {
          left: Tt,
          top: wt,
          width: st + j.width,
          height: it + j.height,
          color: N.backdropColor
        };
      }
      p.push({
        label: b,
        font: T,
        textOffset: P,
        options: {
          rotation: m,
          color: G,
          strokeColor: V,
          strokeWidth: F,
          textAlign: $,
          textBaseline: L,
          translation: [
            w,
            S
          ],
          backdrop: Z
        }
      });
    }
    return p;
  }
  _getXAxisLabelAlignment() {
    const { position: t, ticks: i } = this.options;
    if (-mn(this.labelRotation))
      return t === "top" ? "left" : "right";
    let r = "center";
    return i.align === "start" ? r = "left" : i.align === "end" ? r = "right" : i.align === "inner" && (r = "inner"), r;
  }
  _getYAxisLabelAlignment(t) {
    const { position: i, ticks: { crossAlign: n, mirror: r, padding: a } } = this.options, s = this._getLabelSizes(), o = t + a, l = s.widest.width;
    let u, c;
    return i === "left" ? r ? (c = this.right + a, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c += l)) : (c = this.right - o, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c = this.left)) : i === "right" ? r ? (c = this.left + a, n === "near" ? u = "right" : n === "center" ? (u = "center", c -= l / 2) : (u = "left", c -= l)) : (c = this.left + o, n === "near" ? u = "left" : n === "center" ? (u = "center", c += l / 2) : (u = "right", c = this.right)) : u = "right", {
      textAlign: u,
      x: c
    };
  }
  _computeLabelArea() {
    if (this.options.ticks.mirror)
      return;
    const t = this.chart, i = this.options.position;
    if (i === "left" || i === "right")
      return {
        top: 0,
        left: this.left,
        bottom: t.height,
        right: this.right
      };
    if (i === "top" || i === "bottom")
      return {
        top: this.top,
        left: 0,
        bottom: this.bottom,
        right: t.width
      };
  }
  drawBackground() {
    const { ctx: t, options: { backgroundColor: i }, left: n, top: r, width: a, height: s } = this;
    i && (t.save(), t.fillStyle = i, t.fillRect(n, r, a, s), t.restore());
  }
  getLineWidthForValue(t) {
    const i = this.options.grid;
    if (!this._isVisible() || !i.display)
      return 0;
    const r = this.ticks.findIndex((a) => a.value === t);
    return r >= 0 ? i.setContext(this.getContext(r)).lineWidth : 0;
  }
  drawGrid(t) {
    const i = this.options.grid, n = this.ctx, r = this._gridLineItems || (this._gridLineItems = this._computeGridLineItems(t));
    let a, s;
    const o = (l, u, c) => {
      !c.width || !c.color || (n.save(), n.lineWidth = c.width, n.strokeStyle = c.color, n.setLineDash(c.borderDash || []), n.lineDashOffset = c.borderDashOffset, n.beginPath(), n.moveTo(l.x, l.y), n.lineTo(u.x, u.y), n.stroke(), n.restore());
    };
    if (i.display)
      for (a = 0, s = r.length; a < s; ++a) {
        const l = r[a];
        i.drawOnChartArea && o({
          x: l.x1,
          y: l.y1
        }, {
          x: l.x2,
          y: l.y2
        }, l), i.drawTicks && o({
          x: l.tx1,
          y: l.ty1
        }, {
          x: l.tx2,
          y: l.ty2
        }, {
          color: l.tickColor,
          width: l.tickWidth,
          borderDash: l.tickBorderDash,
          borderDashOffset: l.tickBorderDashOffset
        });
      }
  }
  drawBorder() {
    const { chart: t, ctx: i, options: { border: n, grid: r } } = this, a = n.setContext(this.getContext()), s = n.display ? a.width : 0;
    if (!s)
      return;
    const o = r.setContext(this.getContext(0)).lineWidth, l = this._borderValue;
    let u, c, h, d;
    this.isHorizontal() ? (u = cr(t, this.left, s) - s / 2, c = cr(t, this.right, o) + o / 2, h = d = l) : (h = cr(t, this.top, s) - s / 2, d = cr(t, this.bottom, o) + o / 2, u = c = l), i.save(), i.lineWidth = a.width, i.strokeStyle = a.color, i.beginPath(), i.moveTo(u, h), i.lineTo(c, d), i.stroke(), i.restore();
  }
  drawLabels(t) {
    if (!this.options.ticks.display)
      return;
    const n = this.ctx, r = this._computeLabelArea();
    r && gc(n, r);
    const a = this.getLabelItems(t);
    for (const s of a) {
      const o = s.options, l = s.font, u = s.label, c = s.textOffset;
      Eo(n, u, 0, c, l, o);
    }
    r && mc(n);
  }
  drawTitle() {
    const { ctx: t, options: { position: i, title: n, reverse: r } } = this;
    if (!n.display)
      return;
    const a = Me(n.font), s = yi(n.padding), o = n.align;
    let l = a.lineHeight / 2;
    i === "bottom" || i === "center" || vt(i) ? (l += s.bottom, ae(n.text) && (l += a.lineHeight * (n.text.length - 1))) : l += s.top;
    const { titleX: u, titleY: c, maxWidth: h, rotation: d } = uD(this, l, i, o);
    Eo(t, n.text, 0, 0, a, {
      color: n.color,
      maxWidth: h,
      rotation: d,
      textAlign: lD(o, i, r),
      textBaseline: "middle",
      translation: [
        u,
        c
      ]
    });
  }
  draw(t) {
    this._isVisible() && (this.drawBackground(), this.drawGrid(t), this.drawBorder(), this.drawTitle(), this.drawLabels(t));
  }
  _layers() {
    const t = this.options, i = t.ticks && t.ticks.z || 0, n = ct(t.grid && t.grid.z, -1), r = ct(t.border && t.border.z, 0);
    return !this._isVisible() || this.draw !== ds.prototype.draw ? [
      {
        z: i,
        draw: (a) => {
          this.draw(a);
        }
      }
    ] : [
      {
        z: n,
        draw: (a) => {
          this.drawBackground(), this.drawGrid(a), this.drawTitle();
        }
      },
      {
        z: r,
        draw: () => {
          this.drawBorder();
        }
      },
      {
        z: i,
        draw: (a) => {
          this.drawLabels(a);
        }
      }
    ];
  }
  getMatchingVisibleMetas(t) {
    const i = this.chart.getSortedVisibleDatasetMetas(), n = this.axis + "AxisID", r = [];
    let a, s;
    for (a = 0, s = i.length; a < s; ++a) {
      const o = i[a];
      o[n] === this.id && (!t || o.type === t) && r.push(o);
    }
    return r;
  }
  _resolveTickFontOptions(t) {
    const i = this.options.ticks.setContext(this.getContext(t));
    return Me(i.font);
  }
  _maxDigits() {
    const t = this._resolveTickFontOptions(0).lineHeight;
    return (this.isHorizontal() ? this.width : this.height) / t;
  }
}
class fl {
  constructor(t, i, n) {
    this.type = t, this.scope = i, this.override = n, this.items = /* @__PURE__ */ Object.create(null);
  }
  isForType(t) {
    return Object.prototype.isPrototypeOf.call(this.type.prototype, t.prototype);
  }
  register(t) {
    const i = Object.getPrototypeOf(t);
    let n;
    dD(i) && (n = this.register(i));
    const r = this.items, a = t.id, s = this.scope + "." + a;
    if (!a)
      throw new Error("class does not have id: " + t);
    return a in r || (r[a] = t, cD(t, s, n), this.override && ne.override(t.id, t.overrides)), s;
  }
  get(t) {
    return this.items[t];
  }
  unregister(t) {
    const i = this.items, n = t.id, r = this.scope;
    n in i && delete i[n], r && n in ne[r] && (delete ne[r][n], this.override && delete oa[n]);
  }
}
function cD(e, t, i) {
  const n = Mo(/* @__PURE__ */ Object.create(null), [
    i ? ne.get(i) : {},
    ne.get(t),
    e.defaults
  ]);
  ne.set(t, n), e.defaultRoutes && hD(t, e.defaultRoutes), e.descriptors && ne.describe(t, e.descriptors);
}
function hD(e, t) {
  Object.keys(t).forEach((i) => {
    const n = i.split("."), r = n.pop(), a = [
      e
    ].concat(n).join("."), s = t[i].split("."), o = s.pop(), l = s.join(".");
    ne.route(a, r, l, o);
  });
}
function dD(e) {
  return "id" in e && "defaults" in e;
}
class fD {
  constructor() {
    this.controllers = new fl(_c, "datasets", !0), this.elements = new fl(Pn, "elements"), this.plugins = new fl(Object, "plugins"), this.scales = new fl(ds, "scales"), this._typedRegistries = [
      this.controllers,
      this.scales,
      this.elements
    ];
  }
  add(...t) {
    this._each("register", t);
  }
  remove(...t) {
    this._each("unregister", t);
  }
  addControllers(...t) {
    this._each("register", t, this.controllers);
  }
  addElements(...t) {
    this._each("register", t, this.elements);
  }
  addPlugins(...t) {
    this._each("register", t, this.plugins);
  }
  addScales(...t) {
    this._each("register", t, this.scales);
  }
  getController(t) {
    return this._get(t, this.controllers, "controller");
  }
  getElement(t) {
    return this._get(t, this.elements, "element");
  }
  getPlugin(t) {
    return this._get(t, this.plugins, "plugin");
  }
  getScale(t) {
    return this._get(t, this.scales, "scale");
  }
  removeControllers(...t) {
    this._each("unregister", t, this.controllers);
  }
  removeElements(...t) {
    this._each("unregister", t, this.elements);
  }
  removePlugins(...t) {
    this._each("unregister", t, this.plugins);
  }
  removeScales(...t) {
    this._each("unregister", t, this.scales);
  }
  _each(t, i, n) {
    [
      ...i
    ].forEach((r) => {
      const a = n || this._getRegistryForType(r);
      n || a.isForType(r) || a === this.plugins && r.id ? this._exec(t, a, r) : Ct(r, (s) => {
        const o = n || this._getRegistryForType(s);
        this._exec(t, o, s);
      });
    });
  }
  _exec(t, i, n) {
    const r = rv(t);
    zt(n["before" + r], [], n), i[t](n), zt(n["after" + r], [], n);
  }
  _getRegistryForType(t) {
    for (let i = 0; i < this._typedRegistries.length; i++) {
      const n = this._typedRegistries[i];
      if (n.isForType(t))
        return n;
    }
    return this.plugins;
  }
  _get(t, i, n) {
    const r = i.get(t);
    if (r === void 0)
      throw new Error('"' + t + '" is not a registered ' + n + ".");
    return r;
  }
}
var Wi = /* @__PURE__ */ new fD();
class vD {
  constructor() {
    this._init = void 0;
  }
  notify(t, i, n, r) {
    if (i === "beforeInit" && (this._init = this._createDescriptors(t, !0), this._notify(this._init, t, "install")), this._init === void 0)
      return;
    const a = r ? this._descriptors(t).filter(r) : this._descriptors(t), s = this._notify(a, t, i, n);
    return i === "afterDestroy" && (this._notify(a, t, "stop"), this._notify(this._init, t, "uninstall"), this._init = void 0), s;
  }
  _notify(t, i, n, r) {
    r = r || {};
    for (const a of t) {
      const s = a.plugin, o = s[n], l = [
        i,
        r,
        a.options
      ];
      if (zt(o, l, s) === !1 && r.cancelable)
        return !1;
    }
    return !0;
  }
  invalidate() {
    kt(this._cache) || (this._oldCache = this._cache, this._cache = void 0);
  }
  _descriptors(t) {
    if (this._cache)
      return this._cache;
    const i = this._cache = this._createDescriptors(t);
    return this._notifyStateChanges(t), i;
  }
  _createDescriptors(t, i) {
    const n = t && t.config, r = ct(n.options && n.options.plugins, {}), a = pD(n);
    return r === !1 && !i ? [] : mD(t, a, r, i);
  }
  _notifyStateChanges(t) {
    const i = this._oldCache || [], n = this._cache, r = (a, s) => a.filter((o) => !s.some((l) => o.plugin.id === l.plugin.id));
    this._notify(r(i, n), t, "stop"), this._notify(r(n, i), t, "start");
  }
}
function pD(e) {
  const t = {}, i = [], n = Object.keys(Wi.plugins.items);
  for (let a = 0; a < n.length; a++)
    i.push(Wi.getPlugin(n[a]));
  const r = e.plugins || [];
  for (let a = 0; a < r.length; a++) {
    const s = r[a];
    i.indexOf(s) === -1 && (i.push(s), t[s.id] = !0);
  }
  return {
    plugins: i,
    localIds: t
  };
}
function gD(e, t) {
  return !t && e === !1 ? null : e === !0 ? {} : e;
}
function mD(e, { plugins: t, localIds: i }, n, r) {
  const a = [], s = e.getContext();
  for (const o of t) {
    const l = o.id, u = gD(n[l], r);
    u !== null && a.push({
      plugin: o,
      options: yD(e.config, {
        plugin: o,
        local: i[l]
      }, u, s)
    });
  }
  return a;
}
function yD(e, { plugin: t, local: i }, n, r) {
  const a = e.pluginScopeKeys(t), s = e.getOptionScopes(n, a);
  return i && t.defaults && s.push(t.defaults), e.createResolver(s, r, [
    ""
  ], {
    scriptable: !1,
    indexable: !1,
    allKeys: !0
  });
}
function Vd(e, t) {
  const i = ne.datasets[e] || {};
  return ((t.datasets || {})[e] || {}).indexAxis || t.indexAxis || i.indexAxis || "x";
}
function _D(e, t) {
  let i = e;
  return e === "_index_" ? i = t : e === "_value_" && (i = t === "x" ? "y" : "x"), i;
}
function bD(e, t) {
  return e === t ? "_index_" : "_value_";
}
function Bg(e) {
  if (e === "x" || e === "y" || e === "r")
    return e;
}
function xD(e) {
  if (e === "top" || e === "bottom")
    return "x";
  if (e === "left" || e === "right")
    return "y";
}
function Hd(e, ...t) {
  if (Bg(e))
    return e;
  for (const i of t) {
    const n = i.axis || xD(i.position) || e.length > 1 && Bg(e[0].toLowerCase());
    if (n)
      return n;
  }
  throw new Error(`Cannot determine type of '${e}' axis. Please provide 'axis' or 'position' option.`);
}
function $g(e, t, i) {
  if (i[t + "AxisID"] === e)
    return {
      axis: t
    };
}
function wD(e, t) {
  if (t.data && t.data.datasets) {
    const i = t.data.datasets.filter((n) => n.xAxisID === e || n.yAxisID === e);
    if (i.length)
      return $g(e, "x", i[0]) || $g(e, "y", i[0]);
  }
  return {};
}
function SD(e, t) {
  const i = oa[e.type] || {
    scales: {}
  }, n = t.scales || {}, r = Vd(e.type, t), a = /* @__PURE__ */ Object.create(null);
  return Object.keys(n).forEach((s) => {
    const o = n[s];
    if (!vt(o))
      return console.error(`Invalid scale configuration for scale: ${s}`);
    if (o._proxy)
      return console.warn(`Ignoring resolver passed as options for scale: ${s}`);
    const l = Hd(s, o, wD(s, e), ne.scales[o.type]), u = bD(l, r), c = i.scales || {};
    a[s] = lo(/* @__PURE__ */ Object.create(null), [
      {
        axis: l
      },
      o,
      c[l],
      c[u]
    ]);
  }), e.data.datasets.forEach((s) => {
    const o = s.type || e.type, l = s.indexAxis || Vd(o, t), c = (oa[o] || {}).scales || {};
    Object.keys(c).forEach((h) => {
      const d = _D(h, l), f = s[d + "AxisID"] || d;
      a[f] = a[f] || /* @__PURE__ */ Object.create(null), lo(a[f], [
        {
          axis: d
        },
        n[f],
        c[h]
      ]);
    });
  }), Object.keys(a).forEach((s) => {
    const o = a[s];
    lo(o, [
      ne.scales[o.type],
      ne.scale
    ]);
  }), a;
}
function Ab(e) {
  const t = e.options || (e.options = {});
  t.plugins = ct(t.plugins, {}), t.scales = SD(e, t);
}
function Pb(e) {
  return e = e || {}, e.datasets = e.datasets || [], e.labels = e.labels || [], e;
}
function MD(e) {
  return e = e || {}, e.data = Pb(e.data), Ab(e), e;
}
const zg = /* @__PURE__ */ new Map(), Lb = /* @__PURE__ */ new Set();
function vl(e, t) {
  let i = zg.get(e);
  return i || (i = t(), zg.set(e, i), Lb.add(i)), i;
}
const ks = (e, t, i) => {
  const n = sa(t, i);
  n !== void 0 && e.add(n);
};
class kD {
  constructor(t) {
    this._config = MD(t), this._scopeCache = /* @__PURE__ */ new Map(), this._resolverCache = /* @__PURE__ */ new Map();
  }
  get platform() {
    return this._config.platform;
  }
  get type() {
    return this._config.type;
  }
  set type(t) {
    this._config.type = t;
  }
  get data() {
    return this._config.data;
  }
  set data(t) {
    this._config.data = Pb(t);
  }
  get options() {
    return this._config.options;
  }
  set options(t) {
    this._config.options = t;
  }
  get plugins() {
    return this._config.plugins;
  }
  update() {
    const t = this._config;
    this.clearCache(), Ab(t);
  }
  clearCache() {
    this._scopeCache.clear(), this._resolverCache.clear();
  }
  datasetScopeKeys(t) {
    return vl(t, () => [
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetAnimationScopeKeys(t, i) {
    return vl(`${t}.transition.${i}`, () => [
      [
        `datasets.${t}.transitions.${i}`,
        `transitions.${i}`
      ],
      [
        `datasets.${t}`,
        ""
      ]
    ]);
  }
  datasetElementScopeKeys(t, i) {
    return vl(`${t}-${i}`, () => [
      [
        `datasets.${t}.elements.${i}`,
        `datasets.${t}`,
        `elements.${i}`,
        ""
      ]
    ]);
  }
  pluginScopeKeys(t) {
    const i = t.id, n = this.type;
    return vl(`${n}-plugin-${i}`, () => [
      [
        `plugins.${i}`,
        ...t.additionalOptionScopes || []
      ]
    ]);
  }
  _cachedScopes(t, i) {
    const n = this._scopeCache;
    let r = n.get(t);
    return (!r || i) && (r = /* @__PURE__ */ new Map(), n.set(t, r)), r;
  }
  getOptionScopes(t, i, n) {
    const { options: r, type: a } = this, s = this._cachedScopes(t, n), o = s.get(i);
    if (o)
      return o;
    const l = /* @__PURE__ */ new Set();
    i.forEach((c) => {
      t && (l.add(t), c.forEach((h) => ks(l, t, h))), c.forEach((h) => ks(l, r, h)), c.forEach((h) => ks(l, oa[a] || {}, h)), c.forEach((h) => ks(l, ne, h)), c.forEach((h) => ks(l, $d, h));
    });
    const u = Array.from(l);
    return u.length === 0 && u.push(/* @__PURE__ */ Object.create(null)), Lb.has(i) && s.set(i, u), u;
  }
  chartOptionScopes() {
    const { options: t, type: i } = this;
    return [
      t,
      oa[i] || {},
      ne.datasets[i] || {},
      {
        type: i
      },
      ne,
      $d
    ];
  }
  resolveNamedOptions(t, i, n, r = [
    ""
  ]) {
    const a = {
      $shared: !0
    }, { resolver: s, subPrefixes: o } = Vg(this._resolverCache, t, r);
    let l = s;
    if (TD(s, i)) {
      a.$shared = !1, n = ir(n) ? n() : n;
      const u = this.createResolver(t, n, o);
      l = rs(s, n, u);
    }
    for (const u of i)
      a[u] = l[u];
    return a;
  }
  createResolver(t, i, n = [
    ""
  ], r) {
    const { resolver: a } = Vg(this._resolverCache, t, n);
    return vt(i) ? rs(a, i, void 0, r) : a;
  }
}
function Vg(e, t, i) {
  let n = e.get(t);
  n || (n = /* @__PURE__ */ new Map(), e.set(t, n));
  const r = i.join();
  let a = n.get(r);
  return a || (a = {
    resolver: cv(t, i),
    subPrefixes: i.filter((o) => !o.toLowerCase().includes("hover"))
  }, n.set(r, a)), a;
}
const DD = (e) => vt(e) && Object.getOwnPropertyNames(e).some((t) => ir(e[t]));
function TD(e, t) {
  const { isScriptable: i, isIndexable: n } = hb(e);
  for (const r of t) {
    const a = i(r), s = n(r), o = (s || a) && e[r];
    if (a && (ir(o) || DD(o)) || s && ae(o))
      return !0;
  }
  return !1;
}
var CD = "4.5.1";
const ED = [
  "top",
  "bottom",
  "left",
  "right",
  "chartArea"
];
function Hg(e, t) {
  return e === "top" || e === "bottom" || ED.indexOf(e) === -1 && t === "x";
}
function Yg(e, t) {
  return function(i, n) {
    return i[e] === n[e] ? i[t] - n[t] : i[e] - n[e];
  };
}
function Wg(e) {
  const t = e.chart, i = t.options.animation;
  t.notifyPlugins("afterRender"), zt(i && i.onComplete, [
    e
  ], t);
}
function AD(e) {
  const t = e.chart, i = t.options.animation;
  zt(i && i.onProgress, [
    e
  ], t);
}
function Ob(e) {
  return fv() && typeof e == "string" ? e = document.getElementById(e) : e && e.length && (e = e[0]), e && e.canvas && (e = e.canvas), e;
}
const nu = {}, Ug = (e) => {
  const t = Ob(e);
  return Object.values(nu).filter((i) => i.canvas === t).pop();
};
function PD(e, t, i) {
  const n = Object.keys(e);
  for (const r of n) {
    const a = +r;
    if (a >= t) {
      const s = e[r];
      delete e[r], (i > 0 || a > t) && (e[a + i] = s);
    }
  }
}
function LD(e, t, i, n) {
  return !i || e.type === "mouseout" ? null : n ? t : e;
}
let fs = class {
  static defaults = ne;
  static instances = nu;
  static overrides = oa;
  static registry = Wi;
  static version = CD;
  static getChart = Ug;
  static register(...t) {
    Wi.add(...t), Gg();
  }
  static unregister(...t) {
    Wi.remove(...t), Gg();
  }
  constructor(t, i) {
    const n = this.config = new kD(i), r = Ob(t), a = Ug(r);
    if (a)
      throw new Error("Canvas is already in use. Chart with ID '" + a.id + "' must be destroyed before the canvas with ID '" + a.canvas.id + "' can be reused.");
    const s = n.createResolver(n.chartOptionScopes(), this.getContext());
    this.platform = new (n.platform || Zk(r))(), this.platform.updateConfig(n);
    const o = this.platform.acquireContext(r, s.aspectRatio), l = o && o.canvas, u = l && l.height, c = l && l.width;
    if (this.id = D2(), this.ctx = o, this.canvas = l, this.width = c, this.height = u, this._options = s, this._aspectRatio = this.aspectRatio, this._layers = [], this._metasets = [], this._stacks = void 0, this.boxes = [], this.currentDevicePixelRatio = void 0, this.chartArea = void 0, this._active = [], this._lastEvent = void 0, this._listeners = {}, this._responsiveListeners = void 0, this._sortedMetasets = [], this.scales = {}, this._plugins = new vD(), this.$proxies = {}, this._hiddenIndices = {}, this.attached = !1, this._animationsDisabled = void 0, this.$context = void 0, this._doResize = U2((h) => this.update(h), s.resizeDelay || 0), this._dataChanges = [], nu[this.id] = this, !o || !l) {
      console.error("Failed to create chart: can't acquire context from the given item");
      return;
    }
    dn.listen(this, "complete", Wg), dn.listen(this, "progress", AD), this._initialize(), this.attached && this.update();
  }
  get aspectRatio() {
    const { options: { aspectRatio: t, maintainAspectRatio: i }, width: n, height: r, _aspectRatio: a } = this;
    return kt(t) ? i && a ? a : r ? n / r : null : t;
  }
  get data() {
    return this.config.data;
  }
  set data(t) {
    this.config.data = t;
  }
  get options() {
    return this._options;
  }
  set options(t) {
    this.config.options = t;
  }
  get registry() {
    return Wi;
  }
  _initialize() {
    return this.notifyPlugins("beforeInit"), this.options.responsive ? this.resize() : vg(this, this.options.devicePixelRatio), this.bindEvents(), this.notifyPlugins("afterInit"), this;
  }
  clear() {
    return hg(this.canvas, this.ctx), this;
  }
  stop() {
    return dn.stop(this), this;
  }
  resize(t, i) {
    dn.running(this) ? this._resizeBeforeDraw = {
      width: t,
      height: i
    } : this._resize(t, i);
  }
  _resize(t, i) {
    const n = this.options, r = this.canvas, a = n.maintainAspectRatio && this.aspectRatio, s = this.platform.getMaximumSize(r, t, i, a), o = n.devicePixelRatio || this.platform.getDevicePixelRatio(), l = this.width ? "resize" : "attach";
    this.width = s.width, this.height = s.height, this._aspectRatio = this.aspectRatio, vg(this, o, !0) && (this.notifyPlugins("resize", {
      size: s
    }), zt(n.onResize, [
      this,
      s
    ], this), this.attached && this._doResize(l) && this.render());
  }
  ensureScalesHaveIDs() {
    const i = this.options.scales || {};
    Ct(i, (n, r) => {
      n.id = r;
    });
  }
  buildOrUpdateScales() {
    const t = this.options, i = t.scales, n = this.scales, r = Object.keys(n).reduce((s, o) => (s[o] = !1, s), {});
    let a = [];
    i && (a = a.concat(Object.keys(i).map((s) => {
      const o = i[s], l = Hd(s, o), u = l === "r", c = l === "x";
      return {
        options: o,
        dposition: u ? "chartArea" : c ? "bottom" : "left",
        dtype: u ? "radialLinear" : c ? "category" : "linear"
      };
    }))), Ct(a, (s) => {
      const o = s.options, l = o.id, u = Hd(l, o), c = ct(o.type, s.dtype);
      (o.position === void 0 || Hg(o.position, u) !== Hg(s.dposition)) && (o.position = s.dposition), r[l] = !0;
      let h = null;
      if (l in n && n[l].type === c)
        h = n[l];
      else {
        const d = Wi.getScale(c);
        h = new d({
          id: l,
          type: c,
          ctx: this.ctx,
          chart: this
        }), n[h.id] = h;
      }
      h.init(o, t);
    }), Ct(r, (s, o) => {
      s || delete n[o];
    }), Ct(n, (s) => {
      pi.configure(this, s, s.options), pi.addBox(this, s);
    });
  }
  _updateMetasets() {
    const t = this._metasets, i = this.data.datasets.length, n = t.length;
    if (t.sort((r, a) => r.index - a.index), n > i) {
      for (let r = i; r < n; ++r)
        this._destroyDatasetMeta(r);
      t.splice(i, n - i);
    }
    this._sortedMetasets = t.slice(0).sort(Yg("order", "index"));
  }
  _removeUnreferencedMetasets() {
    const { _metasets: t, data: { datasets: i } } = this;
    t.length > i.length && delete this._stacks, t.forEach((n, r) => {
      i.filter((a) => a === n._dataset).length === 0 && this._destroyDatasetMeta(r);
    });
  }
  buildOrUpdateControllers() {
    const t = [], i = this.data.datasets;
    let n, r;
    for (this._removeUnreferencedMetasets(), n = 0, r = i.length; n < r; n++) {
      const a = i[n];
      let s = this.getDatasetMeta(n);
      const o = a.type || this.config.type;
      if (s.type && s.type !== o && (this._destroyDatasetMeta(n), s = this.getDatasetMeta(n)), s.type = o, s.indexAxis = a.indexAxis || Vd(o, this.options), s.order = a.order || 0, s.index = n, s.label = "" + a.label, s.visible = this.isDatasetVisible(n), s.controller)
        s.controller.updateIndex(n), s.controller.linkScales();
      else {
        const l = Wi.getController(o), { datasetElementType: u, dataElementType: c } = ne.datasets[o];
        Object.assign(l, {
          dataElementType: Wi.getElement(c),
          datasetElementType: u && Wi.getElement(u)
        }), s.controller = new l(this, n), t.push(s.controller);
      }
    }
    return this._updateMetasets(), t;
  }
  _resetElements() {
    Ct(this.data.datasets, (t, i) => {
      this.getDatasetMeta(i).controller.reset();
    }, this);
  }
  reset() {
    this._resetElements(), this.notifyPlugins("reset");
  }
  update(t) {
    const i = this.config;
    i.update();
    const n = this._options = i.createResolver(i.chartOptionScopes(), this.getContext()), r = this._animationsDisabled = !n.animation;
    if (this._updateScales(), this._checkEventBindings(), this._updateHiddenIndices(), this._plugins.invalidate(), this.notifyPlugins("beforeUpdate", {
      mode: t,
      cancelable: !0
    }) === !1)
      return;
    const a = this.buildOrUpdateControllers();
    this.notifyPlugins("beforeElementsUpdate");
    let s = 0;
    for (let u = 0, c = this.data.datasets.length; u < c; u++) {
      const { controller: h } = this.getDatasetMeta(u), d = !r && a.indexOf(h) === -1;
      h.buildOrUpdateElements(d), s = Math.max(+h.getMaxOverflow(), s);
    }
    s = this._minPadding = n.layout.autoPadding ? s : 0, this._updateLayout(s), r || Ct(a, (u) => {
      u.reset();
    }), this._updateDatasets(t), this.notifyPlugins("afterUpdate", {
      mode: t
    }), this._layers.sort(Yg("z", "_idx"));
    const { _active: o, _lastEvent: l } = this;
    l ? this._eventHandler(l, !0) : o.length && this._updateHoverStyles(o, o, !0), this.render();
  }
  _updateScales() {
    Ct(this.scales, (t) => {
      pi.removeBox(this, t);
    }), this.ensureScalesHaveIDs(), this.buildOrUpdateScales();
  }
  _checkEventBindings() {
    const t = this.options, i = new Set(Object.keys(this._listeners)), n = new Set(t.events);
    (!eg(i, n) || !!this._responsiveListeners !== t.responsive) && (this.unbindEvents(), this.bindEvents());
  }
  _updateHiddenIndices() {
    const { _hiddenIndices: t } = this, i = this._getUniformDataChanges() || [];
    for (const { method: n, start: r, count: a } of i) {
      const s = n === "_removeElements" ? -a : a;
      PD(t, r, s);
    }
  }
  _getUniformDataChanges() {
    const t = this._dataChanges;
    if (!t || !t.length)
      return;
    this._dataChanges = [];
    const i = this.data.datasets.length, n = (a) => new Set(t.filter((s) => s[0] === a).map((s, o) => o + "," + s.splice(1).join(","))), r = n(0);
    for (let a = 1; a < i; a++)
      if (!eg(r, n(a)))
        return;
    return Array.from(r).map((a) => a.split(",")).map((a) => ({
      method: a[1],
      start: +a[2],
      count: +a[3]
    }));
  }
  _updateLayout(t) {
    if (this.notifyPlugins("beforeLayout", {
      cancelable: !0
    }) === !1)
      return;
    pi.update(this, this.width, this.height, t);
    const i = this.chartArea, n = i.width <= 0 || i.height <= 0;
    this._layers = [], Ct(this.boxes, (r) => {
      n && r.position === "chartArea" || (r.configure && r.configure(), this._layers.push(...r._layers()));
    }, this), this._layers.forEach((r, a) => {
      r._idx = a;
    }), this.notifyPlugins("afterLayout");
  }
  _updateDatasets(t) {
    if (this.notifyPlugins("beforeDatasetsUpdate", {
      mode: t,
      cancelable: !0
    }) !== !1) {
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this.getDatasetMeta(i).controller.configure();
      for (let i = 0, n = this.data.datasets.length; i < n; ++i)
        this._updateDataset(i, ir(t) ? t({
          datasetIndex: i
        }) : t);
      this.notifyPlugins("afterDatasetsUpdate", {
        mode: t
      });
    }
  }
  _updateDataset(t, i) {
    const n = this.getDatasetMeta(t), r = {
      meta: n,
      index: t,
      mode: i,
      cancelable: !0
    };
    this.notifyPlugins("beforeDatasetUpdate", r) !== !1 && (n.controller._update(i), r.cancelable = !1, this.notifyPlugins("afterDatasetUpdate", r));
  }
  render() {
    this.notifyPlugins("beforeRender", {
      cancelable: !0
    }) !== !1 && (dn.has(this) ? this.attached && !dn.running(this) && dn.start(this) : (this.draw(), Wg({
      chart: this
    })));
  }
  draw() {
    let t;
    if (this._resizeBeforeDraw) {
      const { width: n, height: r } = this._resizeBeforeDraw;
      this._resizeBeforeDraw = null, this._resize(n, r);
    }
    if (this.clear(), this.width <= 0 || this.height <= 0 || this.notifyPlugins("beforeDraw", {
      cancelable: !0
    }) === !1)
      return;
    const i = this._layers;
    for (t = 0; t < i.length && i[t].z <= 0; ++t)
      i[t].draw(this.chartArea);
    for (this._drawDatasets(); t < i.length; ++t)
      i[t].draw(this.chartArea);
    this.notifyPlugins("afterDraw");
  }
  _getSortedDatasetMetas(t) {
    const i = this._sortedMetasets, n = [];
    let r, a;
    for (r = 0, a = i.length; r < a; ++r) {
      const s = i[r];
      (!t || s.visible) && n.push(s);
    }
    return n;
  }
  getSortedVisibleDatasetMetas() {
    return this._getSortedDatasetMetas(!0);
  }
  _drawDatasets() {
    if (this.notifyPlugins("beforeDatasetsDraw", {
      cancelable: !0
    }) === !1)
      return;
    const t = this.getSortedVisibleDatasetMetas();
    for (let i = t.length - 1; i >= 0; --i)
      this._drawDataset(t[i]);
    this.notifyPlugins("afterDatasetsDraw");
  }
  _drawDataset(t) {
    const i = this.ctx, n = {
      meta: t,
      index: t.index,
      cancelable: !0
    }, r = xb(this, t);
    this.notifyPlugins("beforeDatasetDraw", n) !== !1 && (r && gc(i, r), t.controller.draw(), r && mc(i), n.cancelable = !1, this.notifyPlugins("afterDatasetDraw", n));
  }
  isPointInArea(t) {
    return Co(t, this.chartArea, this._minPadding);
  }
  getElementsAtEventForMode(t, i, n, r) {
    const a = Ek.modes[i];
    return typeof a == "function" ? a(this, t, n, r) : [];
  }
  getDatasetMeta(t) {
    const i = this.data.datasets[t], n = this._metasets;
    let r = n.filter((a) => a && a._dataset === i).pop();
    return r || (r = {
      type: null,
      data: [],
      dataset: null,
      controller: null,
      hidden: null,
      xAxisID: null,
      yAxisID: null,
      order: i && i.order || 0,
      index: t,
      _dataset: i,
      _parsed: [],
      _sorted: !1
    }, n.push(r)), r;
  }
  getContext() {
    return this.$context || (this.$context = ca(null, {
      chart: this,
      type: "chart"
    }));
  }
  getVisibleDatasetCount() {
    return this.getSortedVisibleDatasetMetas().length;
  }
  isDatasetVisible(t) {
    const i = this.data.datasets[t];
    if (!i)
      return !1;
    const n = this.getDatasetMeta(t);
    return typeof n.hidden == "boolean" ? !n.hidden : !i.hidden;
  }
  setDatasetVisibility(t, i) {
    const n = this.getDatasetMeta(t);
    n.hidden = !i;
  }
  toggleDataVisibility(t) {
    this._hiddenIndices[t] = !this._hiddenIndices[t];
  }
  getDataVisibility(t) {
    return !this._hiddenIndices[t];
  }
  _updateVisibility(t, i, n) {
    const r = n ? "show" : "hide", a = this.getDatasetMeta(t), s = a.controller._resolveAnimations(void 0, r);
    ko(i) ? (a.data[i].hidden = !n, this.update()) : (this.setDatasetVisibility(t, n), s.update(a, {
      visible: n
    }), this.update((o) => o.datasetIndex === t ? r : void 0));
  }
  hide(t, i) {
    this._updateVisibility(t, i, !1);
  }
  show(t, i) {
    this._updateVisibility(t, i, !0);
  }
  _destroyDatasetMeta(t) {
    const i = this._metasets[t];
    i && i.controller && i.controller._destroy(), delete this._metasets[t];
  }
  _stop() {
    let t, i;
    for (this.stop(), dn.remove(this), t = 0, i = this.data.datasets.length; t < i; ++t)
      this._destroyDatasetMeta(t);
  }
  destroy() {
    this.notifyPlugins("beforeDestroy");
    const { canvas: t, ctx: i } = this;
    this._stop(), this.config.clearCache(), t && (this.unbindEvents(), hg(t, i), this.platform.releaseContext(i), this.canvas = null, this.ctx = null), delete nu[this.id], this.notifyPlugins("afterDestroy");
  }
  toBase64Image(...t) {
    return this.canvas.toDataURL(...t);
  }
  bindEvents() {
    this.bindUserEvents(), this.options.responsive ? this.bindResponsiveEvents() : this.attached = !0;
  }
  bindUserEvents() {
    const t = this._listeners, i = this.platform, n = (a, s) => {
      i.addEventListener(this, a, s), t[a] = s;
    }, r = (a, s, o) => {
      a.offsetX = s, a.offsetY = o, this._eventHandler(a);
    };
    Ct(this.options.events, (a) => n(a, r));
  }
  bindResponsiveEvents() {
    this._responsiveListeners || (this._responsiveListeners = {});
    const t = this._responsiveListeners, i = this.platform, n = (l, u) => {
      i.addEventListener(this, l, u), t[l] = u;
    }, r = (l, u) => {
      t[l] && (i.removeEventListener(this, l, u), delete t[l]);
    }, a = (l, u) => {
      this.canvas && this.resize(l, u);
    };
    let s;
    const o = () => {
      r("attach", o), this.attached = !0, this.resize(), n("resize", a), n("detach", s);
    };
    s = () => {
      this.attached = !1, r("resize", a), this._stop(), this._resize(0, 0), n("attach", o);
    }, i.isAttached(this.canvas) ? o() : s();
  }
  unbindEvents() {
    Ct(this._listeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._listeners = {}, Ct(this._responsiveListeners, (t, i) => {
      this.platform.removeEventListener(this, i, t);
    }), this._responsiveListeners = void 0;
  }
  updateHoverStyle(t, i, n) {
    const r = n ? "set" : "remove";
    let a, s, o, l;
    for (i === "dataset" && (a = this.getDatasetMeta(t[0].datasetIndex), a.controller["_" + r + "DatasetHoverStyle"]()), o = 0, l = t.length; o < l; ++o) {
      s = t[o];
      const u = s && this.getDatasetMeta(s.datasetIndex).controller;
      u && u[r + "HoverStyle"](s.element, s.datasetIndex, s.index);
    }
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t) {
    const i = this._active || [], n = t.map(({ datasetIndex: a, index: s }) => {
      const o = this.getDatasetMeta(a);
      if (!o)
        throw new Error("No dataset found at index " + a);
      return {
        datasetIndex: a,
        element: o.data[s],
        index: s
      };
    });
    !bu(n, i) && (this._active = n, this._lastEvent = null, this._updateHoverStyles(n, i));
  }
  notifyPlugins(t, i, n) {
    return this._plugins.notify(this, t, i, n);
  }
  isPluginEnabled(t) {
    return this._plugins._cache.filter((i) => i.plugin.id === t).length === 1;
  }
  _updateHoverStyles(t, i, n) {
    const r = this.options.hover, a = (l, u) => l.filter((c) => !u.some((h) => c.datasetIndex === h.datasetIndex && c.index === h.index)), s = a(i, t), o = n ? t : a(t, i);
    s.length && this.updateHoverStyle(s, r.mode, !1), o.length && r.mode && this.updateHoverStyle(o, r.mode, !0);
  }
  _eventHandler(t, i) {
    const n = {
      event: t,
      replay: i,
      cancelable: !0,
      inChartArea: this.isPointInArea(t)
    }, r = (s) => (s.options.events || this.options.events).includes(t.native.type);
    if (this.notifyPlugins("beforeEvent", n, r) === !1)
      return;
    const a = this._handleEvent(t, i, n.inChartArea);
    return n.cancelable = !1, this.notifyPlugins("afterEvent", n, r), (a || n.changed) && this.render(), this;
  }
  _handleEvent(t, i, n) {
    const { _active: r = [], options: a } = this, s = i, o = this._getActiveElements(t, r, n, s), l = L2(t), u = LD(t, this._lastEvent, n, l);
    n && (this._lastEvent = null, zt(a.onHover, [
      t,
      o,
      this
    ], this), l && zt(a.onClick, [
      t,
      o,
      this
    ], this));
    const c = !bu(o, r);
    return (c || i) && (this._active = o, this._updateHoverStyles(o, r, i)), this._lastEvent = u, c;
  }
  _getActiveElements(t, i, n, r) {
    if (t.type === "mouseout")
      return [];
    if (!n)
      return i;
    const a = this.options.hover;
    return this.getElementsAtEventForMode(t, a.mode, a, r);
  }
};
function Gg() {
  return Ct(fs.instances, (e) => e._plugins.invalidate());
}
function OD(e, t, i) {
  const { startAngle: n, x: r, y: a, outerRadius: s, innerRadius: o, options: l } = t, { borderWidth: u, borderJoinStyle: c } = l, h = Math.min(u / s, qe(n - i));
  if (e.beginPath(), e.arc(r, a, s - u / 2, n + h / 2, i - h / 2), o > 0) {
    const d = Math.min(u / o, qe(n - i));
    e.arc(r, a, o + u / 2, i - d / 2, n + d / 2, !0);
  } else {
    const d = Math.min(u / 2, s * qe(n - i));
    if (c === "round")
      e.arc(r, a, d, i - Et / 2, n + Et / 2, !0);
    else if (c === "bevel") {
      const f = 2 * d * d, v = -f * Math.cos(i + Et / 2) + r, m = -f * Math.sin(i + Et / 2) + a, p = f * Math.cos(n + Et / 2) + r, g = f * Math.sin(n + Et / 2) + a;
      e.lineTo(v, m), e.lineTo(p, g);
    }
  }
  e.closePath(), e.moveTo(0, 0), e.rect(0, 0, e.canvas.width, e.canvas.height), e.clip("evenodd");
}
function ID(e, t, i) {
  const { startAngle: n, pixelMargin: r, x: a, y: s, outerRadius: o, innerRadius: l } = t;
  let u = r / o;
  e.beginPath(), e.arc(a, s, o, n - u, i + u), l > r ? (u = r / l, e.arc(a, s, l, i + u, n - u, !0)) : e.arc(a, s, r, i + he, n - he), e.closePath(), e.clip();
}
function RD(e) {
  return uv(e, [
    "outerStart",
    "outerEnd",
    "innerStart",
    "innerEnd"
  ]);
}
function ND(e, t, i, n) {
  const r = RD(e.options.borderRadius), a = (i - t) / 2, s = Math.min(a, n * t / 2), o = (l) => {
    const u = (i - Math.min(a, l)) * n / 2;
    return Se(l, 0, Math.min(a, u));
  };
  return {
    outerStart: o(r.outerStart),
    outerEnd: o(r.outerEnd),
    innerStart: Se(r.innerStart, 0, s),
    innerEnd: Se(r.innerEnd, 0, s)
  };
}
function ya(e, t, i, n) {
  return {
    x: i + e * Math.cos(t),
    y: n + e * Math.sin(t)
  };
}
function Du(e, t, i, n, r, a) {
  const { x: s, y: o, startAngle: l, pixelMargin: u, innerRadius: c } = t, h = Math.max(t.outerRadius + n + i - u, 0), d = c > 0 ? c + n + i + u : 0;
  let f = 0;
  const v = r - l;
  if (n) {
    const N = c > 0 ? c - n : 0, B = h > 0 ? h - n : 0, G = (N + B) / 2, V = G !== 0 ? v * G / (G + n) : v;
    f = (v - V) / 2;
  }
  const m = Math.max(1e-3, v * h - i / Et) / h, p = (v - m) / 2, g = l + p + f, y = r - p - f, { outerStart: _, outerEnd: b, innerStart: w, innerEnd: S } = ND(t, d, h, y - g), M = h - _, k = h - b, T = g + _ / M, D = y - b / k, C = d + w, P = d + S, L = g + w / C, O = y - S / P;
  if (e.beginPath(), a) {
    const N = (T + D) / 2;
    if (e.arc(s, o, h, T, N), e.arc(s, o, h, N, D), b > 0) {
      const F = ya(k, D, s, o);
      e.arc(F.x, F.y, b, D, y + he);
    }
    const B = ya(P, y, s, o);
    if (e.lineTo(B.x, B.y), S > 0) {
      const F = ya(P, O, s, o);
      e.arc(F.x, F.y, S, y + he, O + Math.PI);
    }
    const G = (y - S / d + (g + w / d)) / 2;
    if (e.arc(s, o, d, y - S / d, G, !0), e.arc(s, o, d, G, g + w / d, !0), w > 0) {
      const F = ya(C, L, s, o);
      e.arc(F.x, F.y, w, L + Math.PI, g - he);
    }
    const V = ya(M, g, s, o);
    if (e.lineTo(V.x, V.y), _ > 0) {
      const F = ya(M, T, s, o);
      e.arc(F.x, F.y, _, g - he, T);
    }
  } else {
    e.moveTo(s, o);
    const N = Math.cos(T) * h + s, B = Math.sin(T) * h + o;
    e.lineTo(N, B);
    const G = Math.cos(D) * h + s, V = Math.sin(D) * h + o;
    e.lineTo(G, V);
  }
  e.closePath();
}
function FD(e, t, i, n, r) {
  const { fullCircles: a, startAngle: s, circumference: o } = t;
  let l = t.endAngle;
  if (a) {
    Du(e, t, i, n, l, r);
    for (let u = 0; u < a; ++u)
      e.fill();
    isNaN(o) || (l = s + (o % Xt || Xt));
  }
  return Du(e, t, i, n, l, r), e.fill(), l;
}
function BD(e, t, i, n, r) {
  const { fullCircles: a, startAngle: s, circumference: o, options: l } = t, { borderWidth: u, borderJoinStyle: c, borderDash: h, borderDashOffset: d, borderRadius: f } = l, v = l.borderAlign === "inner";
  if (!u)
    return;
  e.setLineDash(h || []), e.lineDashOffset = d, v ? (e.lineWidth = u * 2, e.lineJoin = c || "round") : (e.lineWidth = u, e.lineJoin = c || "bevel");
  let m = t.endAngle;
  if (a) {
    Du(e, t, i, n, m, r);
    for (let p = 0; p < a; ++p)
      e.stroke();
    isNaN(o) || (m = s + (o % Xt || Xt));
  }
  v && ID(e, t, m), l.selfJoin && m - s >= Et && f === 0 && c !== "miter" && OD(e, t, m), a || (Du(e, t, i, n, m, r), e.stroke());
}
class $D extends Pn {
  static id = "arc";
  static defaults = {
    borderAlign: "center",
    borderColor: "#fff",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: void 0,
    borderRadius: 0,
    borderWidth: 2,
    offset: 0,
    spacing: 0,
    angle: void 0,
    circular: !0,
    selfJoin: !1
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash"
  };
  circumference;
  endAngle;
  fullCircles;
  innerRadius;
  outerRadius;
  pixelMargin;
  startAngle;
  constructor(t) {
    super(), this.options = void 0, this.circumference = void 0, this.startAngle = void 0, this.endAngle = void 0, this.innerRadius = void 0, this.outerRadius = void 0, this.pixelMargin = 0, this.fullCircles = 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.getProps([
      "x",
      "y"
    ], n), { angle: a, distance: s } = nb(r, {
      x: t,
      y: i
    }), { startAngle: o, endAngle: l, innerRadius: u, outerRadius: c, circumference: h } = this.getProps([
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius",
      "circumference"
    ], n), d = (this.options.spacing + this.options.borderWidth) / 2, f = ct(h, l - o), v = To(a, o, l) && o !== l, m = f >= Xt || v, p = yn(s, u + d, c + d);
    return m && p;
  }
  getCenterPoint(t) {
    const { x: i, y: n, startAngle: r, endAngle: a, innerRadius: s, outerRadius: o } = this.getProps([
      "x",
      "y",
      "startAngle",
      "endAngle",
      "innerRadius",
      "outerRadius"
    ], t), { offset: l, spacing: u } = this.options, c = (r + a) / 2, h = (s + o + u + l) / 2;
    return {
      x: i + Math.cos(c) * h,
      y: n + Math.sin(c) * h
    };
  }
  tooltipPosition(t) {
    return this.getCenterPoint(t);
  }
  draw(t) {
    const { options: i, circumference: n } = this, r = (i.offset || 0) / 4, a = (i.spacing || 0) / 2, s = i.circular;
    if (this.pixelMargin = i.borderAlign === "inner" ? 0.33 : 0, this.fullCircles = n > Xt ? Math.floor(n / Xt) : 0, n === 0 || this.innerRadius < 0 || this.outerRadius < 0)
      return;
    t.save();
    const o = (this.startAngle + this.endAngle) / 2;
    t.translate(Math.cos(o) * r, Math.sin(o) * r);
    const l = 1 - Math.sin(Math.min(Et, n || 0)), u = r * l;
    t.fillStyle = i.backgroundColor, t.strokeStyle = i.borderColor, FD(t, this, u, a, s), BD(t, this, u, a, s), t.restore();
  }
}
function Ib(e, t, i = t) {
  e.lineCap = ct(i.borderCapStyle, t.borderCapStyle), e.setLineDash(ct(i.borderDash, t.borderDash)), e.lineDashOffset = ct(i.borderDashOffset, t.borderDashOffset), e.lineJoin = ct(i.borderJoinStyle, t.borderJoinStyle), e.lineWidth = ct(i.borderWidth, t.borderWidth), e.strokeStyle = ct(i.borderColor, t.borderColor);
}
function zD(e, t, i) {
  e.lineTo(i.x, i.y);
}
function VD(e) {
  return e.stepped ? aM : e.tension || e.cubicInterpolationMode === "monotone" ? sM : zD;
}
function Rb(e, t, i = {}) {
  const n = e.length, { start: r = 0, end: a = n - 1 } = i, { start: s, end: o } = t, l = Math.max(r, s), u = Math.min(a, o), c = r < s && a < s || r > o && a > o;
  return {
    count: n,
    start: l,
    loop: t.loop,
    ilen: u < l && !c ? n + u - l : u - l
  };
}
function HD(e, t, i, n) {
  const { points: r, options: a } = t, { count: s, start: o, loop: l, ilen: u } = Rb(r, i, n), c = VD(a);
  let { move: h = !0, reverse: d } = n || {}, f, v, m;
  for (f = 0; f <= u; ++f)
    v = r[(o + (d ? u - f : f)) % s], !v.skip && (h ? (e.moveTo(v.x, v.y), h = !1) : c(e, m, v, d, a.stepped), m = v);
  return l && (v = r[(o + (d ? u : 0)) % s], c(e, m, v, d, a.stepped)), !!l;
}
function YD(e, t, i, n) {
  const r = t.points, { count: a, start: s, ilen: o } = Rb(r, i, n), { move: l = !0, reverse: u } = n || {};
  let c = 0, h = 0, d, f, v, m, p, g;
  const y = (b) => (s + (u ? o - b : b)) % a, _ = () => {
    m !== p && (e.lineTo(c, p), e.lineTo(c, m), e.lineTo(c, g));
  };
  for (l && (f = r[y(0)], e.moveTo(f.x, f.y)), d = 0; d <= o; ++d) {
    if (f = r[y(d)], f.skip)
      continue;
    const b = f.x, w = f.y, S = b | 0;
    S === v ? (w < m ? m = w : w > p && (p = w), c = (h * c + b) / ++h) : (_(), e.lineTo(b, w), v = S, h = 0, m = p = w), g = w;
  }
  _();
}
function Yd(e) {
  const t = e.options, i = t.borderDash && t.borderDash.length;
  return !e._decimated && !e._loop && !t.tension && t.cubicInterpolationMode !== "monotone" && !t.stepped && !i ? YD : HD;
}
function WD(e) {
  return e.stepped ? BM : e.tension || e.cubicInterpolationMode === "monotone" ? $M : Br;
}
function UD(e, t, i, n) {
  let r = t._path;
  r || (r = t._path = new Path2D(), t.path(r, i, n) && r.closePath()), Ib(e, t.options), e.stroke(r);
}
function GD(e, t, i, n) {
  const { segments: r, options: a } = t, s = Yd(t);
  for (const o of r)
    Ib(e, a, o.style), e.beginPath(), s(e, t, o, {
      start: i,
      end: i + n - 1
    }) && e.closePath(), e.stroke();
}
const XD = typeof Path2D == "function";
function jD(e, t, i, n) {
  XD && !t.options.segment ? UD(e, t, i, n) : GD(e, t, i, n);
}
class xc extends Pn {
  static id = "line";
  static defaults = {
    borderCapStyle: "butt",
    borderDash: [],
    borderDashOffset: 0,
    borderJoinStyle: "miter",
    borderWidth: 3,
    capBezierPoints: !0,
    cubicInterpolationMode: "default",
    fill: !1,
    spanGaps: !1,
    stepped: !1,
    tension: 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  static descriptors = {
    _scriptable: !0,
    _indexable: (t) => t !== "borderDash" && t !== "fill"
  };
  constructor(t) {
    super(), this.animated = !0, this.options = void 0, this._chart = void 0, this._loop = void 0, this._fullLoop = void 0, this._path = void 0, this._points = void 0, this._segments = void 0, this._decimated = !1, this._pointsUpdated = !1, this._datasetIndex = void 0, t && Object.assign(this, t);
  }
  updateControlPoints(t, i) {
    const n = this.options;
    if ((n.tension || n.cubicInterpolationMode === "monotone") && !n.stepped && !this._pointsUpdated) {
      const r = n.spanGaps ? this._loop : this._fullLoop;
      AM(this._points, n, t, r, i), this._pointsUpdated = !0;
    }
  }
  set points(t) {
    this._points = t, delete this._segments, delete this._path, this._pointsUpdated = !1;
  }
  get points() {
    return this._points;
  }
  get segments() {
    return this._segments || (this._segments = UM(this, this.options.segment));
  }
  first() {
    const t = this.segments, i = this.points;
    return t.length && i[t[0].start];
  }
  last() {
    const t = this.segments, i = this.points, n = t.length;
    return n && i[t[n - 1].end];
  }
  interpolate(t, i) {
    const n = this.options, r = t[i], a = this.points, s = bb(this, {
      property: i,
      start: r,
      end: r
    });
    if (!s.length)
      return;
    const o = [], l = WD(n);
    let u, c;
    for (u = 0, c = s.length; u < c; ++u) {
      const { start: h, end: d } = s[u], f = a[h], v = a[d];
      if (f === v) {
        o.push(f);
        continue;
      }
      const m = Math.abs((r - f[i]) / (v[i] - f[i])), p = l(f, v, m, n.stepped);
      p[i] = t[i], o.push(p);
    }
    return o.length === 1 ? o[0] : o;
  }
  pathSegment(t, i, n) {
    return Yd(this)(t, this, i, n);
  }
  path(t, i, n) {
    const r = this.segments, a = Yd(this);
    let s = this._loop;
    i = i || 0, n = n || this.points.length - i;
    for (const o of r)
      s &= a(t, this, o, {
        start: i,
        end: i + n - 1
      });
    return !!s;
  }
  draw(t, i, n, r) {
    const a = this.options || {};
    (this.points || []).length && a.borderWidth && (t.save(), jD(t, this, n, r), t.restore()), this.animated && (this._pointsUpdated = !1, this._path = void 0);
  }
}
function Xg(e, t, i, n) {
  const r = e.options, { [i]: a } = e.getProps([
    i
  ], n);
  return Math.abs(t - a) < r.radius + r.hitRadius;
}
class qD extends Pn {
  static id = "point";
  parsed;
  skip;
  stop;
  /**
  * @type {any}
  */
  static defaults = {
    borderWidth: 1,
    hitRadius: 1,
    hoverBorderWidth: 1,
    hoverRadius: 4,
    pointStyle: "circle",
    radius: 3,
    rotation: 0
  };
  /**
  * @type {any}
  */
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.parsed = void 0, this.skip = void 0, this.stop = void 0, t && Object.assign(this, t);
  }
  inRange(t, i, n) {
    const r = this.options, { x: a, y: s } = this.getProps([
      "x",
      "y"
    ], n);
    return Math.pow(t - a, 2) + Math.pow(i - s, 2) < Math.pow(r.hitRadius + r.radius, 2);
  }
  inXRange(t, i) {
    return Xg(this, t, "x", i);
  }
  inYRange(t, i) {
    return Xg(this, t, "y", i);
  }
  getCenterPoint(t) {
    const { x: i, y: n } = this.getProps([
      "x",
      "y"
    ], t);
    return {
      x: i,
      y: n
    };
  }
  size(t) {
    t = t || this.options || {};
    let i = t.radius || 0;
    i = Math.max(i, i && t.hoverRadius || 0);
    const n = i && t.borderWidth || 0;
    return (i + n) * 2;
  }
  draw(t, i) {
    const n = this.options;
    this.skip || n.radius < 0.1 || !Co(this, i, this.size(n) / 2) || (t.strokeStyle = n.borderColor, t.lineWidth = n.borderWidth, t.fillStyle = n.backgroundColor, zd(t, n, this.x, this.y));
  }
  getRange() {
    const t = this.options || {};
    return t.radius + t.hitRadius;
  }
}
function Nb(e, t) {
  const { x: i, y: n, base: r, width: a, height: s } = e.getProps([
    "x",
    "y",
    "base",
    "width",
    "height"
  ], t);
  let o, l, u, c, h;
  return e.horizontal ? (h = s / 2, o = Math.min(i, r), l = Math.max(i, r), u = n - h, c = n + h) : (h = a / 2, o = i - h, l = i + h, u = Math.min(n, r), c = Math.max(n, r)), {
    left: o,
    top: u,
    right: l,
    bottom: c
  };
}
function Un(e, t, i, n) {
  return e ? 0 : Se(t, i, n);
}
function ZD(e, t, i) {
  const n = e.options.borderWidth, r = e.borderSkipped, a = cb(n);
  return {
    t: Un(r.top, a.top, 0, i),
    r: Un(r.right, a.right, 0, t),
    b: Un(r.bottom, a.bottom, 0, i),
    l: Un(r.left, a.left, 0, t)
  };
}
function KD(e, t, i) {
  const { enableBorderRadius: n } = e.getProps([
    "enableBorderRadius"
  ]), r = e.options.borderRadius, a = ja(r), s = Math.min(t, i), o = e.borderSkipped, l = n || vt(r);
  return {
    topLeft: Un(!l || o.top || o.left, a.topLeft, 0, s),
    topRight: Un(!l || o.top || o.right, a.topRight, 0, s),
    bottomLeft: Un(!l || o.bottom || o.left, a.bottomLeft, 0, s),
    bottomRight: Un(!l || o.bottom || o.right, a.bottomRight, 0, s)
  };
}
function QD(e) {
  const t = Nb(e), i = t.right - t.left, n = t.bottom - t.top, r = ZD(e, i / 2, n / 2), a = KD(e, i / 2, n / 2);
  return {
    outer: {
      x: t.left,
      y: t.top,
      w: i,
      h: n,
      radius: a
    },
    inner: {
      x: t.left + r.l,
      y: t.top + r.t,
      w: i - r.l - r.r,
      h: n - r.t - r.b,
      radius: {
        topLeft: Math.max(0, a.topLeft - Math.max(r.t, r.l)),
        topRight: Math.max(0, a.topRight - Math.max(r.t, r.r)),
        bottomLeft: Math.max(0, a.bottomLeft - Math.max(r.b, r.l)),
        bottomRight: Math.max(0, a.bottomRight - Math.max(r.b, r.r))
      }
    }
  };
}
function ch(e, t, i, n) {
  const r = t === null, a = i === null, o = e && !(r && a) && Nb(e, n);
  return o && (r || yn(t, o.left, o.right)) && (a || yn(i, o.top, o.bottom));
}
function JD(e) {
  return e.topLeft || e.topRight || e.bottomLeft || e.bottomRight;
}
function tT(e, t) {
  e.rect(t.x, t.y, t.w, t.h);
}
function hh(e, t, i = {}) {
  const n = e.x !== i.x ? -t : 0, r = e.y !== i.y ? -t : 0, a = (e.x + e.w !== i.x + i.w ? t : 0) - n, s = (e.y + e.h !== i.y + i.h ? t : 0) - r;
  return {
    x: e.x + n,
    y: e.y + r,
    w: e.w + a,
    h: e.h + s,
    radius: e.radius
  };
}
class eT extends Pn {
  static id = "bar";
  static defaults = {
    borderSkipped: "start",
    borderWidth: 0,
    borderRadius: 0,
    inflateAmount: "auto",
    pointStyle: void 0
  };
  static defaultRoutes = {
    backgroundColor: "backgroundColor",
    borderColor: "borderColor"
  };
  constructor(t) {
    super(), this.options = void 0, this.horizontal = void 0, this.base = void 0, this.width = void 0, this.height = void 0, this.inflateAmount = void 0, t && Object.assign(this, t);
  }
  draw(t) {
    const { inflateAmount: i, options: { borderColor: n, backgroundColor: r } } = this, { inner: a, outer: s } = QD(this), o = JD(s.radius) ? Su : tT;
    t.save(), (s.w !== a.w || s.h !== a.h) && (t.beginPath(), o(t, hh(s, i, a)), t.clip(), o(t, hh(a, -i, s)), t.fillStyle = n, t.fill("evenodd")), t.beginPath(), o(t, hh(a, i)), t.fillStyle = r, t.fill(), t.restore();
  }
  inRange(t, i, n) {
    return ch(this, t, i, n);
  }
  inXRange(t, i) {
    return ch(this, t, null, i);
  }
  inYRange(t, i) {
    return ch(this, null, t, i);
  }
  getCenterPoint(t) {
    const { x: i, y: n, base: r, horizontal: a } = this.getProps([
      "x",
      "y",
      "base",
      "horizontal"
    ], t);
    return {
      x: a ? (i + r) / 2 : i,
      y: a ? n : (n + r) / 2
    };
  }
  getRange(t) {
    return t === "x" ? this.width / 2 : this.height / 2;
  }
}
function iT(e, t, i) {
  const n = e.segments, r = e.points, a = t.points, s = [];
  for (const o of n) {
    let { start: l, end: u } = o;
    u = wc(l, u, r);
    const c = Wd(i, r[l], r[u], o.loop);
    if (!t.segments) {
      s.push({
        source: o,
        target: c,
        start: r[l],
        end: r[u]
      });
      continue;
    }
    const h = bb(t, c);
    for (const d of h) {
      const f = Wd(i, a[d.start], a[d.end], d.loop), v = _b(o, r, f);
      for (const m of v)
        s.push({
          source: m,
          target: d,
          start: {
            [i]: jg(c, f, "start", Math.max)
          },
          end: {
            [i]: jg(c, f, "end", Math.min)
          }
        });
    }
  }
  return s;
}
function Wd(e, t, i, n) {
  if (n)
    return;
  let r = t[e], a = i[e];
  return e === "angle" && (r = qe(r), a = qe(a)), {
    property: e,
    start: r,
    end: a
  };
}
function nT(e, t) {
  const { x: i = null, y: n = null } = e || {}, r = t.points, a = [];
  return t.segments.forEach(({ start: s, end: o }) => {
    o = wc(s, o, r);
    const l = r[s], u = r[o];
    n !== null ? (a.push({
      x: l.x,
      y: n
    }), a.push({
      x: u.x,
      y: n
    })) : i !== null && (a.push({
      x: i,
      y: l.y
    }), a.push({
      x: i,
      y: u.y
    }));
  }), a;
}
function wc(e, t, i) {
  for (; t > e; t--) {
    const n = i[t];
    if (!isNaN(n.x) && !isNaN(n.y))
      break;
  }
  return t;
}
function jg(e, t, i, n) {
  return e && t ? n(e[i], t[i]) : e ? e[i] : t ? t[i] : 0;
}
function Fb(e, t) {
  let i = [], n = !1;
  return ae(e) ? (n = !0, i = e) : i = nT(e, t), i.length ? new xc({
    points: i,
    options: {
      tension: 0
    },
    _loop: n,
    _fullLoop: n
  }) : null;
}
function qg(e) {
  return e && e.fill !== !1;
}
function rT(e, t, i) {
  let r = e[t].fill;
  const a = [
    t
  ];
  let s;
  if (!i)
    return r;
  for (; r !== !1 && a.indexOf(r) === -1; ) {
    if (!Ce(r))
      return r;
    if (s = e[r], !s)
      return !1;
    if (s.visible)
      return r;
    a.push(r), r = s.fill;
  }
  return !1;
}
function aT(e, t, i) {
  const n = uT(e);
  if (vt(n))
    return isNaN(n.value) ? !1 : n;
  let r = parseFloat(n);
  return Ce(r) && Math.floor(r) === r ? sT(n[0], t, r, i) : [
    "origin",
    "start",
    "end",
    "stack",
    "shape"
  ].indexOf(n) >= 0 && n;
}
function sT(e, t, i, n) {
  return (e === "-" || e === "+") && (i = t + i), i === t || i < 0 || i >= n ? !1 : i;
}
function oT(e, t) {
  let i = null;
  return e === "start" ? i = t.bottom : e === "end" ? i = t.top : vt(e) ? i = t.getPixelForValue(e.value) : t.getBasePixel && (i = t.getBasePixel()), i;
}
function lT(e, t, i) {
  let n;
  return e === "start" ? n = i : e === "end" ? n = t.options.reverse ? t.min : t.max : vt(e) ? n = e.value : n = t.getBaseValue(), n;
}
function uT(e) {
  const t = e.options, i = t.fill;
  let n = ct(i && i.target, i);
  return n === void 0 && (n = !!t.backgroundColor), n === !1 || n === null ? !1 : n === !0 ? "origin" : n;
}
function cT(e) {
  const { scale: t, index: i, line: n } = e, r = [], a = n.segments, s = n.points, o = hT(t, i);
  o.push(Fb({
    x: null,
    y: t.bottom
  }, n));
  for (let l = 0; l < a.length; l++) {
    const u = a[l];
    for (let c = u.start; c <= u.end; c++)
      dT(r, s[c], o);
  }
  return new xc({
    points: r,
    options: {}
  });
}
function hT(e, t) {
  const i = [], n = e.getMatchingVisibleMetas("line");
  for (let r = 0; r < n.length; r++) {
    const a = n[r];
    if (a.index === t)
      break;
    a.hidden || i.unshift(a.dataset);
  }
  return i;
}
function dT(e, t, i) {
  const n = [];
  for (let r = 0; r < i.length; r++) {
    const a = i[r], { first: s, last: o, point: l } = fT(a, t, "x");
    if (!(!l || s && o)) {
      if (s)
        n.unshift(l);
      else if (e.push(l), !o)
        break;
    }
  }
  e.push(...n);
}
function fT(e, t, i) {
  const n = e.interpolate(t, i);
  if (!n)
    return {};
  const r = n[i], a = e.segments, s = e.points;
  let o = !1, l = !1;
  for (let u = 0; u < a.length; u++) {
    const c = a[u], h = s[c.start][i], d = s[c.end][i];
    if (yn(r, h, d)) {
      o = r === h, l = r === d;
      break;
    }
  }
  return {
    first: o,
    last: l,
    point: n
  };
}
class Bb {
  constructor(t) {
    this.x = t.x, this.y = t.y, this.radius = t.radius;
  }
  pathSegment(t, i, n) {
    const { x: r, y: a, radius: s } = this;
    return i = i || {
      start: 0,
      end: Xt
    }, t.arc(r, a, s, i.end, i.start, !0), !n.bounds;
  }
  interpolate(t) {
    const { x: i, y: n, radius: r } = this, a = t.angle;
    return {
      x: i + Math.cos(a) * r,
      y: n + Math.sin(a) * r,
      angle: a
    };
  }
}
function vT(e) {
  const { chart: t, fill: i, line: n } = e;
  if (Ce(i))
    return pT(t, i);
  if (i === "stack")
    return cT(e);
  if (i === "shape")
    return !0;
  const r = gT(e);
  return r instanceof Bb ? r : Fb(r, n);
}
function pT(e, t) {
  const i = e.getDatasetMeta(t);
  return i && e.isDatasetVisible(t) ? i.dataset : null;
}
function gT(e) {
  return (e.scale || {}).getPointPositionForValue ? yT(e) : mT(e);
}
function mT(e) {
  const { scale: t = {}, fill: i } = e, n = oT(i, t);
  if (Ce(n)) {
    const r = t.isHorizontal();
    return {
      x: r ? n : null,
      y: r ? null : n
    };
  }
  return null;
}
function yT(e) {
  const { scale: t, fill: i } = e, n = t.options, r = t.getLabels().length, a = n.reverse ? t.max : t.min, s = lT(i, t, a), o = [];
  if (n.grid.circular) {
    const l = t.getPointPositionForValue(0, a);
    return new Bb({
      x: l.x,
      y: l.y,
      radius: t.getDistanceFromCenterForValue(s)
    });
  }
  for (let l = 0; l < r; ++l)
    o.push(t.getPointPositionForValue(l, s));
  return o;
}
function dh(e, t, i) {
  const n = vT(t), { chart: r, index: a, line: s, scale: o, axis: l } = t, u = s.options, c = u.fill, h = u.backgroundColor, { above: d = h, below: f = h } = c || {}, v = r.getDatasetMeta(a), m = xb(r, v);
  n && s.points.length && (gc(e, i), _T(e, {
    line: s,
    target: n,
    above: d,
    below: f,
    area: i,
    scale: o,
    axis: l,
    clip: m
  }), mc(e));
}
function _T(e, t) {
  const { line: i, target: n, above: r, below: a, area: s, scale: o, clip: l } = t, u = i._loop ? "angle" : t.axis;
  e.save();
  let c = a;
  a !== r && (u === "x" ? (Zg(e, n, s.top), fh(e, {
    line: i,
    target: n,
    color: r,
    scale: o,
    property: u,
    clip: l
  }), e.restore(), e.save(), Zg(e, n, s.bottom)) : u === "y" && (Kg(e, n, s.left), fh(e, {
    line: i,
    target: n,
    color: a,
    scale: o,
    property: u,
    clip: l
  }), e.restore(), e.save(), Kg(e, n, s.right), c = r)), fh(e, {
    line: i,
    target: n,
    color: c,
    scale: o,
    property: u,
    clip: l
  }), e.restore();
}
function Zg(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, s = !1;
  e.beginPath();
  for (const o of n) {
    const { start: l, end: u } = o, c = r[l], h = r[wc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(c.x, i), e.lineTo(c.x, c.y)), s = !!t.pathSegment(e, o, {
      move: s
    }), s ? e.closePath() : e.lineTo(h.x, i);
  }
  e.lineTo(t.first().x, i), e.closePath(), e.clip();
}
function Kg(e, t, i) {
  const { segments: n, points: r } = t;
  let a = !0, s = !1;
  e.beginPath();
  for (const o of n) {
    const { start: l, end: u } = o, c = r[l], h = r[wc(l, u, r)];
    a ? (e.moveTo(c.x, c.y), a = !1) : (e.lineTo(i, c.y), e.lineTo(c.x, c.y)), s = !!t.pathSegment(e, o, {
      move: s
    }), s ? e.closePath() : e.lineTo(i, h.y);
  }
  e.lineTo(i, t.first().y), e.closePath(), e.clip();
}
function fh(e, t) {
  const { line: i, target: n, property: r, color: a, scale: s, clip: o } = t, l = iT(i, n, r);
  for (const { source: u, target: c, start: h, end: d } of l) {
    const { style: { backgroundColor: f = a } = {} } = u, v = n !== !0;
    e.save(), e.fillStyle = f, bT(e, s, o, v && Wd(r, h, d)), e.beginPath();
    const m = !!i.pathSegment(e, u);
    let p;
    if (v) {
      m ? e.closePath() : Qg(e, n, d, r);
      const g = !!n.pathSegment(e, c, {
        move: m,
        reverse: !0
      });
      p = m && g, p || Qg(e, n, h, r);
    }
    e.closePath(), e.fill(p ? "evenodd" : "nonzero"), e.restore();
  }
}
function bT(e, t, i, n) {
  const r = t.chart.chartArea, { property: a, start: s, end: o } = n || {};
  if (a === "x" || a === "y") {
    let l, u, c, h;
    a === "x" ? (l = s, u = r.top, c = o, h = r.bottom) : (l = r.left, u = s, c = r.right, h = o), e.beginPath(), i && (l = Math.max(l, i.left), c = Math.min(c, i.right), u = Math.max(u, i.top), h = Math.min(h, i.bottom)), e.rect(l, u, c - l, h - u), e.clip();
  }
}
function Qg(e, t, i, n) {
  const r = t.interpolate(i, n);
  r && e.lineTo(r.x, r.y);
}
var xT = {
  id: "filler",
  afterDatasetsUpdate(e, t, i) {
    const n = (e.data.datasets || []).length, r = [];
    let a, s, o, l;
    for (s = 0; s < n; ++s)
      a = e.getDatasetMeta(s), o = a.dataset, l = null, o && o.options && o instanceof xc && (l = {
        visible: e.isDatasetVisible(s),
        index: s,
        fill: aT(o, s, n),
        chart: e,
        axis: a.controller.options.indexAxis,
        scale: a.vScale,
        line: o
      }), a.$filler = l, r.push(l);
    for (s = 0; s < n; ++s)
      l = r[s], !(!l || l.fill === !1) && (l.fill = rT(r, s, i.propagate));
  },
  beforeDraw(e, t, i) {
    const n = i.drawTime === "beforeDraw", r = e.getSortedVisibleDatasetMetas(), a = e.chartArea;
    for (let s = r.length - 1; s >= 0; --s) {
      const o = r[s].$filler;
      o && (o.line.updateControlPoints(a, o.axis), n && o.fill && dh(e.ctx, o, a));
    }
  },
  beforeDatasetsDraw(e, t, i) {
    if (i.drawTime !== "beforeDatasetsDraw")
      return;
    const n = e.getSortedVisibleDatasetMetas();
    for (let r = n.length - 1; r >= 0; --r) {
      const a = n[r].$filler;
      qg(a) && dh(e.ctx, a, e.chartArea);
    }
  },
  beforeDatasetDraw(e, t, i) {
    const n = t.meta.$filler;
    !qg(n) || i.drawTime !== "beforeDatasetDraw" || dh(e.ctx, n, e.chartArea);
  },
  defaults: {
    propagate: !0,
    drawTime: "beforeDatasetDraw"
  }
};
const Jg = (e, t) => {
  let { boxHeight: i = t, boxWidth: n = t } = e;
  return e.usePointStyle && (i = Math.min(i, t), n = e.pointStyleWidth || Math.min(n, t)), {
    boxWidth: n,
    boxHeight: i,
    itemHeight: Math.max(t, i)
  };
}, wT = (e, t) => e !== null && t !== null && e.datasetIndex === t.datasetIndex && e.index === t.index;
class tm extends Pn {
  constructor(t) {
    super(), this._added = !1, this.legendHitBoxes = [], this._hoveredItem = null, this.doughnutMode = !1, this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this.legendItems = void 0, this.columnSizes = void 0, this.lineWidths = void 0, this.maxHeight = void 0, this.maxWidth = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.height = void 0, this.width = void 0, this._margins = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i, n) {
    this.maxWidth = t, this.maxHeight = i, this._margins = n, this.setDimensions(), this.buildLabels(), this.fit();
  }
  setDimensions() {
    this.isHorizontal() ? (this.width = this.maxWidth, this.left = this._margins.left, this.right = this.width) : (this.height = this.maxHeight, this.top = this._margins.top, this.bottom = this.height);
  }
  buildLabels() {
    const t = this.options.labels || {};
    let i = zt(t.generateLabels, [
      this.chart
    ], this) || [];
    t.filter && (i = i.filter((n) => t.filter(n, this.chart.data))), t.sort && (i = i.sort((n, r) => t.sort(n, r, this.chart.data))), this.options.reverse && i.reverse(), this.legendItems = i;
  }
  fit() {
    const { options: t, ctx: i } = this;
    if (!t.display) {
      this.width = this.height = 0;
      return;
    }
    const n = t.labels, r = Me(n.font), a = r.size, s = this._computeTitleHeight(), { boxWidth: o, itemHeight: l } = Jg(n, a);
    let u, c;
    i.font = r.string, this.isHorizontal() ? (u = this.maxWidth, c = this._fitRows(s, a, o, l) + 10) : (c = this.maxHeight, u = this._fitCols(s, r, o, l) + 10), this.width = Math.min(u, t.maxWidth || this.maxWidth), this.height = Math.min(c, t.maxHeight || this.maxHeight);
  }
  _fitRows(t, i, n, r) {
    const { ctx: a, maxWidth: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], u = this.lineWidths = [
      0
    ], c = r + o;
    let h = t;
    a.textAlign = "left", a.textBaseline = "middle";
    let d = -1, f = -c;
    return this.legendItems.forEach((v, m) => {
      const p = n + i / 2 + a.measureText(v.text).width;
      (m === 0 || u[u.length - 1] + p + 2 * o > s) && (h += c, u[u.length - (m > 0 ? 0 : 1)] = 0, f += c, d++), l[m] = {
        left: 0,
        top: f,
        row: d,
        width: p,
        height: r
      }, u[u.length - 1] += p + o;
    }), h;
  }
  _fitCols(t, i, n, r) {
    const { ctx: a, maxHeight: s, options: { labels: { padding: o } } } = this, l = this.legendHitBoxes = [], u = this.columnSizes = [], c = s - t;
    let h = o, d = 0, f = 0, v = 0, m = 0;
    return this.legendItems.forEach((p, g) => {
      const { itemWidth: y, itemHeight: _ } = ST(n, i, a, p, r);
      g > 0 && f + _ + 2 * o > c && (h += d + o, u.push({
        width: d,
        height: f
      }), v += d + o, m++, d = f = 0), l[g] = {
        left: v,
        top: f,
        col: m,
        width: y,
        height: _
      }, d = Math.max(d, y), f += _ + o;
    }), h += d, u.push({
      width: d,
      height: f
    }), h;
  }
  adjustHitBoxes() {
    if (!this.options.display)
      return;
    const t = this._computeTitleHeight(), { legendHitBoxes: i, options: { align: n, labels: { padding: r }, rtl: a } } = this, s = qa(a, this.left, this.width);
    if (this.isHorizontal()) {
      let o = 0, l = xe(n, this.left + r, this.right - this.lineWidths[o]);
      for (const u of i)
        o !== u.row && (o = u.row, l = xe(n, this.left + r, this.right - this.lineWidths[o])), u.top += this.top + t + r, u.left = s.leftForLtr(s.x(l), u.width), l += u.width + r;
    } else {
      let o = 0, l = xe(n, this.top + t + r, this.bottom - this.columnSizes[o].height);
      for (const u of i)
        u.col !== o && (o = u.col, l = xe(n, this.top + t + r, this.bottom - this.columnSizes[o].height)), u.top = l, u.left += this.left + r, u.left = s.leftForLtr(s.x(u.left), u.width), l += u.height + r;
    }
  }
  isHorizontal() {
    return this.options.position === "top" || this.options.position === "bottom";
  }
  draw() {
    if (this.options.display) {
      const t = this.ctx;
      gc(t, this), this._draw(), mc(t);
    }
  }
  _draw() {
    const { options: t, columnSizes: i, lineWidths: n, ctx: r } = this, { align: a, labels: s } = t, o = ne.color, l = qa(t.rtl, this.left, this.width), u = Me(s.font), { padding: c } = s, h = u.size, d = h / 2;
    let f;
    this.drawTitle(), r.textAlign = l.textAlign("left"), r.textBaseline = "middle", r.lineWidth = 0.5, r.font = u.string;
    const { boxWidth: v, boxHeight: m, itemHeight: p } = Jg(s, h), g = function(S, M, k) {
      if (isNaN(v) || v <= 0 || isNaN(m) || m < 0)
        return;
      r.save();
      const T = ct(k.lineWidth, 1);
      if (r.fillStyle = ct(k.fillStyle, o), r.lineCap = ct(k.lineCap, "butt"), r.lineDashOffset = ct(k.lineDashOffset, 0), r.lineJoin = ct(k.lineJoin, "miter"), r.lineWidth = T, r.strokeStyle = ct(k.strokeStyle, o), r.setLineDash(ct(k.lineDash, [])), s.usePointStyle) {
        const D = {
          radius: m * Math.SQRT2 / 2,
          pointStyle: k.pointStyle,
          rotation: k.rotation,
          borderWidth: T
        }, C = l.xPlus(S, v / 2), P = M + d;
        ub(r, D, C, P, s.pointStyleWidth && v);
      } else {
        const D = M + Math.max((h - m) / 2, 0), C = l.leftForLtr(S, v), P = ja(k.borderRadius);
        r.beginPath(), Object.values(P).some((L) => L !== 0) ? Su(r, {
          x: C,
          y: D,
          w: v,
          h: m,
          radius: P
        }) : r.rect(C, D, v, m), r.fill(), T !== 0 && r.stroke();
      }
      r.restore();
    }, y = function(S, M, k) {
      Eo(r, k.text, S, M + p / 2, u, {
        strikethrough: k.hidden,
        textAlign: l.textAlign(k.textAlign)
      });
    }, _ = this.isHorizontal(), b = this._computeTitleHeight();
    _ ? f = {
      x: xe(a, this.left + c, this.right - n[0]),
      y: this.top + c + b,
      line: 0
    } : f = {
      x: this.left + c,
      y: xe(a, this.top + b + c, this.bottom - i[0].height),
      line: 0
    }, gb(this.ctx, t.textDirection);
    const w = p + c;
    this.legendItems.forEach((S, M) => {
      r.strokeStyle = S.fontColor, r.fillStyle = S.fontColor;
      const k = r.measureText(S.text).width, T = l.textAlign(S.textAlign || (S.textAlign = s.textAlign)), D = v + d + k;
      let C = f.x, P = f.y;
      l.setWidth(this.width), _ ? M > 0 && C + D + c > this.right && (P = f.y += w, f.line++, C = f.x = xe(a, this.left + c, this.right - n[f.line])) : M > 0 && P + w > this.bottom && (C = f.x = C + i[f.line].width + c, f.line++, P = f.y = xe(a, this.top + b + c, this.bottom - i[f.line].height));
      const L = l.x(C);
      if (g(L, P, S), C = G2(T, C + v + d, _ ? C + D : this.right, t.rtl), y(l.x(C), P, S), _)
        f.x += D + c;
      else if (typeof S.text != "string") {
        const O = u.lineHeight;
        f.y += $b(S, O) + c;
      } else
        f.y += w;
    }), mb(this.ctx, t.textDirection);
  }
  drawTitle() {
    const t = this.options, i = t.title, n = Me(i.font), r = yi(i.padding);
    if (!i.display)
      return;
    const a = qa(t.rtl, this.left, this.width), s = this.ctx, o = i.position, l = n.size / 2, u = r.top + l;
    let c, h = this.left, d = this.width;
    if (this.isHorizontal())
      d = Math.max(...this.lineWidths), c = this.top + u, h = xe(t.align, h, this.right - d);
    else {
      const v = this.columnSizes.reduce((m, p) => Math.max(m, p.height), 0);
      c = u + xe(t.align, this.top, this.bottom - v - t.labels.padding - this._computeTitleHeight());
    }
    const f = xe(o, h, h + d);
    s.textAlign = a.textAlign(sv(o)), s.textBaseline = "middle", s.strokeStyle = i.color, s.fillStyle = i.color, s.font = n.string, Eo(s, i.text, f, c, n);
  }
  _computeTitleHeight() {
    const t = this.options.title, i = Me(t.font), n = yi(t.padding);
    return t.display ? i.lineHeight + n.height : 0;
  }
  _getLegendItemAt(t, i) {
    let n, r, a;
    if (yn(t, this.left, this.right) && yn(i, this.top, this.bottom)) {
      for (a = this.legendHitBoxes, n = 0; n < a.length; ++n)
        if (r = a[n], yn(t, r.left, r.left + r.width) && yn(i, r.top, r.top + r.height))
          return this.legendItems[n];
    }
    return null;
  }
  handleEvent(t) {
    const i = this.options;
    if (!DT(t.type, i))
      return;
    const n = this._getLegendItemAt(t.x, t.y);
    if (t.type === "mousemove" || t.type === "mouseout") {
      const r = this._hoveredItem, a = wT(r, n);
      r && !a && zt(i.onLeave, [
        t,
        r,
        this
      ], this), this._hoveredItem = n, n && !a && zt(i.onHover, [
        t,
        n,
        this
      ], this);
    } else n && zt(i.onClick, [
      t,
      n,
      this
    ], this);
  }
}
function ST(e, t, i, n, r) {
  const a = MT(n, e, t, i), s = kT(r, n, t.lineHeight);
  return {
    itemWidth: a,
    itemHeight: s
  };
}
function MT(e, t, i, n) {
  let r = e.text;
  return r && typeof r != "string" && (r = r.reduce((a, s) => a.length > s.length ? a : s)), t + i.size / 2 + n.measureText(r).width;
}
function kT(e, t, i) {
  let n = e;
  return typeof t.text != "string" && (n = $b(t, i)), n;
}
function $b(e, t) {
  const i = e.text ? e.text.length : 0;
  return t * i;
}
function DT(e, t) {
  return !!((e === "mousemove" || e === "mouseout") && (t.onHover || t.onLeave) || t.onClick && (e === "click" || e === "mouseup"));
}
var gv = {
  id: "legend",
  _element: tm,
  start(e, t, i) {
    const n = e.legend = new tm({
      ctx: e.ctx,
      options: i,
      chart: e
    });
    pi.configure(e, n, i), pi.addBox(e, n);
  },
  stop(e) {
    pi.removeBox(e, e.legend), delete e.legend;
  },
  beforeUpdate(e, t, i) {
    const n = e.legend;
    pi.configure(e, n, i), n.options = i;
  },
  afterUpdate(e) {
    const t = e.legend;
    t.buildLabels(), t.adjustHitBoxes();
  },
  afterEvent(e, t) {
    t.replay || e.legend.handleEvent(t.event);
  },
  defaults: {
    display: !0,
    position: "top",
    align: "center",
    fullSize: !0,
    reverse: !1,
    weight: 1e3,
    onClick(e, t, i) {
      const n = t.datasetIndex, r = i.chart;
      r.isDatasetVisible(n) ? (r.hide(n), t.hidden = !0) : (r.show(n), t.hidden = !1);
    },
    onHover: null,
    onLeave: null,
    labels: {
      color: (e) => e.chart.options.color,
      boxWidth: 40,
      padding: 10,
      generateLabels(e) {
        const t = e.data.datasets, { labels: { usePointStyle: i, pointStyle: n, textAlign: r, color: a, useBorderRadius: s, borderRadius: o } } = e.legend.options;
        return e._getSortedDatasetMetas().map((l) => {
          const u = l.controller.getStyle(i ? 0 : void 0), c = yi(u.borderWidth);
          return {
            text: t[l.index].label,
            fillStyle: u.backgroundColor,
            fontColor: a,
            hidden: !l.visible,
            lineCap: u.borderCapStyle,
            lineDash: u.borderDash,
            lineDashOffset: u.borderDashOffset,
            lineJoin: u.borderJoinStyle,
            lineWidth: (c.width + c.height) / 4,
            strokeStyle: u.borderColor,
            pointStyle: n || u.pointStyle,
            rotation: u.rotation,
            textAlign: r || u.textAlign,
            borderRadius: s && (o || u.borderRadius),
            datasetIndex: l.index
          };
        }, this);
      }
    },
    title: {
      color: (e) => e.chart.options.color,
      display: !1,
      position: "center",
      text: ""
    }
  },
  descriptors: {
    _scriptable: (e) => !e.startsWith("on"),
    labels: {
      _scriptable: (e) => ![
        "generateLabels",
        "filter",
        "sort"
      ].includes(e)
    }
  }
};
class zb extends Pn {
  constructor(t) {
    super(), this.chart = t.chart, this.options = t.options, this.ctx = t.ctx, this._padding = void 0, this.top = void 0, this.bottom = void 0, this.left = void 0, this.right = void 0, this.width = void 0, this.height = void 0, this.position = void 0, this.weight = void 0, this.fullSize = void 0;
  }
  update(t, i) {
    const n = this.options;
    if (this.left = 0, this.top = 0, !n.display) {
      this.width = this.height = this.right = this.bottom = 0;
      return;
    }
    this.width = this.right = t, this.height = this.bottom = i;
    const r = ae(n.text) ? n.text.length : 1;
    this._padding = yi(n.padding);
    const a = r * Me(n.font).lineHeight + this._padding.height;
    this.isHorizontal() ? this.height = a : this.width = a;
  }
  isHorizontal() {
    const t = this.options.position;
    return t === "top" || t === "bottom";
  }
  _drawArgs(t) {
    const { top: i, left: n, bottom: r, right: a, options: s } = this, o = s.align;
    let l = 0, u, c, h;
    return this.isHorizontal() ? (c = xe(o, n, a), h = i + t, u = a - n) : (s.position === "left" ? (c = n + t, h = xe(o, r, i), l = Et * -0.5) : (c = a - t, h = xe(o, i, r), l = Et * 0.5), u = r - i), {
      titleX: c,
      titleY: h,
      maxWidth: u,
      rotation: l
    };
  }
  draw() {
    const t = this.ctx, i = this.options;
    if (!i.display)
      return;
    const n = Me(i.font), a = n.lineHeight / 2 + this._padding.top, { titleX: s, titleY: o, maxWidth: l, rotation: u } = this._drawArgs(a);
    Eo(t, i.text, 0, 0, n, {
      color: i.color,
      maxWidth: l,
      rotation: u,
      textAlign: sv(i.align),
      textBaseline: "middle",
      translation: [
        s,
        o
      ]
    });
  }
}
function TT(e, t) {
  const i = new zb({
    ctx: e.ctx,
    options: t,
    chart: e
  });
  pi.configure(e, i, t), pi.addBox(e, i), e.titleBlock = i;
}
var Vb = {
  id: "title",
  _element: zb,
  start(e, t, i) {
    TT(e, i);
  },
  stop(e) {
    const t = e.titleBlock;
    pi.removeBox(e, t), delete e.titleBlock;
  },
  beforeUpdate(e, t, i) {
    const n = e.titleBlock;
    pi.configure(e, n, i), n.options = i;
  },
  defaults: {
    align: "center",
    display: !1,
    font: {
      weight: "bold"
    },
    fullSize: !0,
    padding: 10,
    position: "top",
    text: "",
    weight: 2e3
  },
  defaultRoutes: {
    color: "color"
  },
  descriptors: {
    _scriptable: !0,
    _indexable: !1
  }
};
const Qs = {
  average(e) {
    if (!e.length)
      return !1;
    let t, i, n = /* @__PURE__ */ new Set(), r = 0, a = 0;
    for (t = 0, i = e.length; t < i; ++t) {
      const o = e[t].element;
      if (o && o.hasValue()) {
        const l = o.tooltipPosition();
        n.add(l.x), r += l.y, ++a;
      }
    }
    return a === 0 || n.size === 0 ? !1 : {
      x: [
        ...n
      ].reduce((o, l) => o + l) / n.size,
      y: r / a
    };
  },
  nearest(e, t) {
    if (!e.length)
      return !1;
    let i = t.x, n = t.y, r = Number.POSITIVE_INFINITY, a, s, o;
    for (a = 0, s = e.length; a < s; ++a) {
      const l = e[a].element;
      if (l && l.hasValue()) {
        const u = l.getCenterPoint(), c = Bd(t, u);
        c < r && (r = c, o = l);
      }
    }
    if (o) {
      const l = o.tooltipPosition();
      i = l.x, n = l.y;
    }
    return {
      x: i,
      y: n
    };
  }
};
function Yi(e, t) {
  return t && (ae(t) ? Array.prototype.push.apply(e, t) : e.push(t)), e;
}
function fn(e) {
  return (typeof e == "string" || e instanceof String) && e.indexOf(`
`) > -1 ? e.split(`
`) : e;
}
function CT(e, t) {
  const { element: i, datasetIndex: n, index: r } = t, a = e.getDatasetMeta(n).controller, { label: s, value: o } = a.getLabelAndValue(r);
  return {
    chart: e,
    label: s,
    parsed: a.getParsed(r),
    raw: e.data.datasets[n].data[r],
    formattedValue: o,
    dataset: a.getDataset(),
    dataIndex: r,
    datasetIndex: n,
    element: i
  };
}
function em(e, t) {
  const i = e.chart.ctx, { body: n, footer: r, title: a } = e, { boxWidth: s, boxHeight: o } = t, l = Me(t.bodyFont), u = Me(t.titleFont), c = Me(t.footerFont), h = a.length, d = r.length, f = n.length, v = yi(t.padding);
  let m = v.height, p = 0, g = n.reduce((b, w) => b + w.before.length + w.lines.length + w.after.length, 0);
  if (g += e.beforeBody.length + e.afterBody.length, h && (m += h * u.lineHeight + (h - 1) * t.titleSpacing + t.titleMarginBottom), g) {
    const b = t.displayColors ? Math.max(o, l.lineHeight) : l.lineHeight;
    m += f * b + (g - f) * l.lineHeight + (g - 1) * t.bodySpacing;
  }
  d && (m += t.footerMarginTop + d * c.lineHeight + (d - 1) * t.footerSpacing);
  let y = 0;
  const _ = function(b) {
    p = Math.max(p, i.measureText(b).width + y);
  };
  return i.save(), i.font = u.string, Ct(e.title, _), i.font = l.string, Ct(e.beforeBody.concat(e.afterBody), _), y = t.displayColors ? s + 2 + t.boxPadding : 0, Ct(n, (b) => {
    Ct(b.before, _), Ct(b.lines, _), Ct(b.after, _);
  }), y = 0, i.font = c.string, Ct(e.footer, _), i.restore(), p += v.width, {
    width: p,
    height: m
  };
}
function ET(e, t) {
  const { y: i, height: n } = t;
  return i < n / 2 ? "top" : i > e.height - n / 2 ? "bottom" : "center";
}
function AT(e, t, i, n) {
  const { x: r, width: a } = n, s = i.caretSize + i.caretPadding;
  if (e === "left" && r + a + s > t.width || e === "right" && r - a - s < 0)
    return !0;
}
function PT(e, t, i, n) {
  const { x: r, width: a } = i, { width: s, chartArea: { left: o, right: l } } = e;
  let u = "center";
  return n === "center" ? u = r <= (o + l) / 2 ? "left" : "right" : r <= a / 2 ? u = "left" : r >= s - a / 2 && (u = "right"), AT(u, e, t, i) && (u = "center"), u;
}
function im(e, t, i) {
  const n = i.yAlign || t.yAlign || ET(e, i);
  return {
    xAlign: i.xAlign || t.xAlign || PT(e, t, i, n),
    yAlign: n
  };
}
function LT(e, t) {
  let { x: i, width: n } = e;
  return t === "right" ? i -= n : t === "center" && (i -= n / 2), i;
}
function OT(e, t, i) {
  let { y: n, height: r } = e;
  return t === "top" ? n += i : t === "bottom" ? n -= r + i : n -= r / 2, n;
}
function nm(e, t, i, n) {
  const { caretSize: r, caretPadding: a, cornerRadius: s } = e, { xAlign: o, yAlign: l } = i, u = r + a, { topLeft: c, topRight: h, bottomLeft: d, bottomRight: f } = ja(s);
  let v = LT(t, o);
  const m = OT(t, l, u);
  return l === "center" ? o === "left" ? v += u : o === "right" && (v -= u) : o === "left" ? v -= Math.max(c, d) + r : o === "right" && (v += Math.max(h, f) + r), {
    x: Se(v, 0, n.width - t.width),
    y: Se(m, 0, n.height - t.height)
  };
}
function pl(e, t, i) {
  const n = yi(i.padding);
  return t === "center" ? e.x + e.width / 2 : t === "right" ? e.x + e.width - n.right : e.x + n.left;
}
function rm(e) {
  return Yi([], fn(e));
}
function IT(e, t, i) {
  return ca(e, {
    tooltip: t,
    tooltipItems: i,
    type: "tooltip"
  });
}
function am(e, t) {
  const i = t && t.dataset && t.dataset.tooltip && t.dataset.tooltip.callbacks;
  return i ? e.override(i) : e;
}
const Hb = {
  beforeTitle: sn,
  title(e) {
    if (e.length > 0) {
      const t = e[0], i = t.chart.data.labels, n = i ? i.length : 0;
      if (this && this.options && this.options.mode === "dataset")
        return t.dataset.label || "";
      if (t.label)
        return t.label;
      if (n > 0 && t.dataIndex < n)
        return i[t.dataIndex];
    }
    return "";
  },
  afterTitle: sn,
  beforeBody: sn,
  beforeLabel: sn,
  label(e) {
    if (this && this.options && this.options.mode === "dataset")
      return e.label + ": " + e.formattedValue || e.formattedValue;
    let t = e.dataset.label || "";
    t && (t += ": ");
    const i = e.formattedValue;
    return kt(i) || (t += i), t;
  },
  labelColor(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      borderColor: i.borderColor,
      backgroundColor: i.backgroundColor,
      borderWidth: i.borderWidth,
      borderDash: i.borderDash,
      borderDashOffset: i.borderDashOffset,
      borderRadius: 0
    };
  },
  labelTextColor() {
    return this.options.bodyColor;
  },
  labelPointStyle(e) {
    const i = e.chart.getDatasetMeta(e.datasetIndex).controller.getStyle(e.dataIndex);
    return {
      pointStyle: i.pointStyle,
      rotation: i.rotation
    };
  },
  afterLabel: sn,
  afterBody: sn,
  beforeFooter: sn,
  footer: sn,
  afterFooter: sn
};
function Fe(e, t, i, n) {
  const r = e[t].call(i, n);
  return typeof r > "u" ? Hb[t].call(i, n) : r;
}
class sm extends Pn {
  static positioners = Qs;
  constructor(t) {
    super(), this.opacity = 0, this._active = [], this._eventPosition = void 0, this._size = void 0, this._cachedAnimations = void 0, this._tooltipItems = [], this.$animations = void 0, this.$context = void 0, this.chart = t.chart, this.options = t.options, this.dataPoints = void 0, this.title = void 0, this.beforeBody = void 0, this.body = void 0, this.afterBody = void 0, this.footer = void 0, this.xAlign = void 0, this.yAlign = void 0, this.x = void 0, this.y = void 0, this.height = void 0, this.width = void 0, this.caretX = void 0, this.caretY = void 0, this.labelColors = void 0, this.labelPointStyles = void 0, this.labelTextColors = void 0;
  }
  initialize(t) {
    this.options = t, this._cachedAnimations = void 0, this.$context = void 0;
  }
  _resolveAnimations() {
    const t = this._cachedAnimations;
    if (t)
      return t;
    const i = this.chart, n = this.options.setContext(this.getContext()), r = n.enabled && i.options.animation && n.animations, a = new wb(this.chart, r);
    return r._cacheable && (this._cachedAnimations = Object.freeze(a)), a;
  }
  getContext() {
    return this.$context || (this.$context = IT(this.chart.getContext(), this, this._tooltipItems));
  }
  getTitle(t, i) {
    const { callbacks: n } = i, r = Fe(n, "beforeTitle", this, t), a = Fe(n, "title", this, t), s = Fe(n, "afterTitle", this, t);
    let o = [];
    return o = Yi(o, fn(r)), o = Yi(o, fn(a)), o = Yi(o, fn(s)), o;
  }
  getBeforeBody(t, i) {
    return rm(Fe(i.callbacks, "beforeBody", this, t));
  }
  getBody(t, i) {
    const { callbacks: n } = i, r = [];
    return Ct(t, (a) => {
      const s = {
        before: [],
        lines: [],
        after: []
      }, o = am(n, a);
      Yi(s.before, fn(Fe(o, "beforeLabel", this, a))), Yi(s.lines, Fe(o, "label", this, a)), Yi(s.after, fn(Fe(o, "afterLabel", this, a))), r.push(s);
    }), r;
  }
  getAfterBody(t, i) {
    return rm(Fe(i.callbacks, "afterBody", this, t));
  }
  getFooter(t, i) {
    const { callbacks: n } = i, r = Fe(n, "beforeFooter", this, t), a = Fe(n, "footer", this, t), s = Fe(n, "afterFooter", this, t);
    let o = [];
    return o = Yi(o, fn(r)), o = Yi(o, fn(a)), o = Yi(o, fn(s)), o;
  }
  _createItems(t) {
    const i = this._active, n = this.chart.data, r = [], a = [], s = [];
    let o = [], l, u;
    for (l = 0, u = i.length; l < u; ++l)
      o.push(CT(this.chart, i[l]));
    return t.filter && (o = o.filter((c, h, d) => t.filter(c, h, d, n))), t.itemSort && (o = o.sort((c, h) => t.itemSort(c, h, n))), Ct(o, (c) => {
      const h = am(t.callbacks, c);
      r.push(Fe(h, "labelColor", this, c)), a.push(Fe(h, "labelPointStyle", this, c)), s.push(Fe(h, "labelTextColor", this, c));
    }), this.labelColors = r, this.labelPointStyles = a, this.labelTextColors = s, this.dataPoints = o, o;
  }
  update(t, i) {
    const n = this.options.setContext(this.getContext()), r = this._active;
    let a, s = [];
    if (!r.length)
      this.opacity !== 0 && (a = {
        opacity: 0
      });
    else {
      const o = Qs[n.position].call(this, r, this._eventPosition);
      s = this._createItems(n), this.title = this.getTitle(s, n), this.beforeBody = this.getBeforeBody(s, n), this.body = this.getBody(s, n), this.afterBody = this.getAfterBody(s, n), this.footer = this.getFooter(s, n);
      const l = this._size = em(this, n), u = Object.assign({}, o, l), c = im(this.chart, n, u), h = nm(n, u, c, this.chart);
      this.xAlign = c.xAlign, this.yAlign = c.yAlign, a = {
        opacity: 1,
        x: h.x,
        y: h.y,
        width: l.width,
        height: l.height,
        caretX: o.x,
        caretY: o.y
      };
    }
    this._tooltipItems = s, this.$context = void 0, a && this._resolveAnimations().update(this, a), t && n.external && n.external.call(this, {
      chart: this.chart,
      tooltip: this,
      replay: i
    });
  }
  drawCaret(t, i, n, r) {
    const a = this.getCaretPosition(t, n, r);
    i.lineTo(a.x1, a.y1), i.lineTo(a.x2, a.y2), i.lineTo(a.x3, a.y3);
  }
  getCaretPosition(t, i, n) {
    const { xAlign: r, yAlign: a } = this, { caretSize: s, cornerRadius: o } = n, { topLeft: l, topRight: u, bottomLeft: c, bottomRight: h } = ja(o), { x: d, y: f } = t, { width: v, height: m } = i;
    let p, g, y, _, b, w;
    return a === "center" ? (b = f + m / 2, r === "left" ? (p = d, g = p - s, _ = b + s, w = b - s) : (p = d + v, g = p + s, _ = b - s, w = b + s), y = p) : (r === "left" ? g = d + Math.max(l, c) + s : r === "right" ? g = d + v - Math.max(u, h) - s : g = this.caretX, a === "top" ? (_ = f, b = _ - s, p = g - s, y = g + s) : (_ = f + m, b = _ + s, p = g + s, y = g - s), w = _), {
      x1: p,
      x2: g,
      x3: y,
      y1: _,
      y2: b,
      y3: w
    };
  }
  drawTitle(t, i, n) {
    const r = this.title, a = r.length;
    let s, o, l;
    if (a) {
      const u = qa(n.rtl, this.x, this.width);
      for (t.x = pl(this, n.titleAlign, n), i.textAlign = u.textAlign(n.titleAlign), i.textBaseline = "middle", s = Me(n.titleFont), o = n.titleSpacing, i.fillStyle = n.titleColor, i.font = s.string, l = 0; l < a; ++l)
        i.fillText(r[l], u.x(t.x), t.y + s.lineHeight / 2), t.y += s.lineHeight + o, l + 1 === a && (t.y += n.titleMarginBottom - o);
    }
  }
  _drawColorBox(t, i, n, r, a) {
    const s = this.labelColors[n], o = this.labelPointStyles[n], { boxHeight: l, boxWidth: u } = a, c = Me(a.bodyFont), h = pl(this, "left", a), d = r.x(h), f = l < c.lineHeight ? (c.lineHeight - l) / 2 : 0, v = i.y + f;
    if (a.usePointStyle) {
      const m = {
        radius: Math.min(u, l) / 2,
        pointStyle: o.pointStyle,
        rotation: o.rotation,
        borderWidth: 1
      }, p = r.leftForLtr(d, u) + u / 2, g = v + l / 2;
      t.strokeStyle = a.multiKeyBackground, t.fillStyle = a.multiKeyBackground, zd(t, m, p, g), t.strokeStyle = s.borderColor, t.fillStyle = s.backgroundColor, zd(t, m, p, g);
    } else {
      t.lineWidth = vt(s.borderWidth) ? Math.max(...Object.values(s.borderWidth)) : s.borderWidth || 1, t.strokeStyle = s.borderColor, t.setLineDash(s.borderDash || []), t.lineDashOffset = s.borderDashOffset || 0;
      const m = r.leftForLtr(d, u), p = r.leftForLtr(r.xPlus(d, 1), u - 2), g = ja(s.borderRadius);
      Object.values(g).some((y) => y !== 0) ? (t.beginPath(), t.fillStyle = a.multiKeyBackground, Su(t, {
        x: m,
        y: v,
        w: u,
        h: l,
        radius: g
      }), t.fill(), t.stroke(), t.fillStyle = s.backgroundColor, t.beginPath(), Su(t, {
        x: p,
        y: v + 1,
        w: u - 2,
        h: l - 2,
        radius: g
      }), t.fill()) : (t.fillStyle = a.multiKeyBackground, t.fillRect(m, v, u, l), t.strokeRect(m, v, u, l), t.fillStyle = s.backgroundColor, t.fillRect(p, v + 1, u - 2, l - 2));
    }
    t.fillStyle = this.labelTextColors[n];
  }
  drawBody(t, i, n) {
    const { body: r } = this, { bodySpacing: a, bodyAlign: s, displayColors: o, boxHeight: l, boxWidth: u, boxPadding: c } = n, h = Me(n.bodyFont);
    let d = h.lineHeight, f = 0;
    const v = qa(n.rtl, this.x, this.width), m = function(k) {
      i.fillText(k, v.x(t.x + f), t.y + d / 2), t.y += d + a;
    }, p = v.textAlign(s);
    let g, y, _, b, w, S, M;
    for (i.textAlign = s, i.textBaseline = "middle", i.font = h.string, t.x = pl(this, p, n), i.fillStyle = n.bodyColor, Ct(this.beforeBody, m), f = o && p !== "right" ? s === "center" ? u / 2 + c : u + 2 + c : 0, b = 0, S = r.length; b < S; ++b) {
      for (g = r[b], y = this.labelTextColors[b], i.fillStyle = y, Ct(g.before, m), _ = g.lines, o && _.length && (this._drawColorBox(i, t, b, v, n), d = Math.max(h.lineHeight, l)), w = 0, M = _.length; w < M; ++w)
        m(_[w]), d = h.lineHeight;
      Ct(g.after, m);
    }
    f = 0, d = h.lineHeight, Ct(this.afterBody, m), t.y -= a;
  }
  drawFooter(t, i, n) {
    const r = this.footer, a = r.length;
    let s, o;
    if (a) {
      const l = qa(n.rtl, this.x, this.width);
      for (t.x = pl(this, n.footerAlign, n), t.y += n.footerMarginTop, i.textAlign = l.textAlign(n.footerAlign), i.textBaseline = "middle", s = Me(n.footerFont), i.fillStyle = n.footerColor, i.font = s.string, o = 0; o < a; ++o)
        i.fillText(r[o], l.x(t.x), t.y + s.lineHeight / 2), t.y += s.lineHeight + n.footerSpacing;
    }
  }
  drawBackground(t, i, n, r) {
    const { xAlign: a, yAlign: s } = this, { x: o, y: l } = t, { width: u, height: c } = n, { topLeft: h, topRight: d, bottomLeft: f, bottomRight: v } = ja(r.cornerRadius);
    i.fillStyle = r.backgroundColor, i.strokeStyle = r.borderColor, i.lineWidth = r.borderWidth, i.beginPath(), i.moveTo(o + h, l), s === "top" && this.drawCaret(t, i, n, r), i.lineTo(o + u - d, l), i.quadraticCurveTo(o + u, l, o + u, l + d), s === "center" && a === "right" && this.drawCaret(t, i, n, r), i.lineTo(o + u, l + c - v), i.quadraticCurveTo(o + u, l + c, o + u - v, l + c), s === "bottom" && this.drawCaret(t, i, n, r), i.lineTo(o + f, l + c), i.quadraticCurveTo(o, l + c, o, l + c - f), s === "center" && a === "left" && this.drawCaret(t, i, n, r), i.lineTo(o, l + h), i.quadraticCurveTo(o, l, o + h, l), i.closePath(), i.fill(), r.borderWidth > 0 && i.stroke();
  }
  _updateAnimationTarget(t) {
    const i = this.chart, n = this.$animations, r = n && n.x, a = n && n.y;
    if (r || a) {
      const s = Qs[t.position].call(this, this._active, this._eventPosition);
      if (!s)
        return;
      const o = this._size = em(this, t), l = Object.assign({}, s, this._size), u = im(i, t, l), c = nm(t, l, u, i);
      (r._to !== c.x || a._to !== c.y) && (this.xAlign = u.xAlign, this.yAlign = u.yAlign, this.width = o.width, this.height = o.height, this.caretX = s.x, this.caretY = s.y, this._resolveAnimations().update(this, c));
    }
  }
  _willRender() {
    return !!this.opacity;
  }
  draw(t) {
    const i = this.options.setContext(this.getContext());
    let n = this.opacity;
    if (!n)
      return;
    this._updateAnimationTarget(i);
    const r = {
      width: this.width,
      height: this.height
    }, a = {
      x: this.x,
      y: this.y
    };
    n = Math.abs(n) < 1e-3 ? 0 : n;
    const s = yi(i.padding), o = this.title.length || this.beforeBody.length || this.body.length || this.afterBody.length || this.footer.length;
    i.enabled && o && (t.save(), t.globalAlpha = n, this.drawBackground(a, t, r, i), gb(t, i.textDirection), a.y += s.top, this.drawTitle(a, t, i), this.drawBody(a, t, i), this.drawFooter(a, t, i), mb(t, i.textDirection), t.restore());
  }
  getActiveElements() {
    return this._active || [];
  }
  setActiveElements(t, i) {
    const n = this._active, r = t.map(({ datasetIndex: o, index: l }) => {
      const u = this.chart.getDatasetMeta(o);
      if (!u)
        throw new Error("Cannot find a dataset at index " + o);
      return {
        datasetIndex: o,
        element: u.data[l],
        index: l
      };
    }), a = !bu(n, r), s = this._positionChanged(r, i);
    (a || s) && (this._active = r, this._eventPosition = i, this._ignoreReplayEvents = !0, this.update(!0));
  }
  handleEvent(t, i, n = !0) {
    if (i && this._ignoreReplayEvents)
      return !1;
    this._ignoreReplayEvents = !1;
    const r = this.options, a = this._active || [], s = this._getActiveElements(t, a, i, n), o = this._positionChanged(s, t), l = i || !bu(s, a) || o;
    return l && (this._active = s, (r.enabled || r.external) && (this._eventPosition = {
      x: t.x,
      y: t.y
    }, this.update(!0, i))), l;
  }
  _getActiveElements(t, i, n, r) {
    const a = this.options;
    if (t.type === "mouseout")
      return [];
    if (!r)
      return i.filter((o) => this.chart.data.datasets[o.datasetIndex] && this.chart.getDatasetMeta(o.datasetIndex).controller.getParsed(o.index) !== void 0);
    const s = this.chart.getElementsAtEventForMode(t, a.mode, a, n);
    return a.reverse && s.reverse(), s;
  }
  _positionChanged(t, i) {
    const { caretX: n, caretY: r, options: a } = this, s = Qs[a.position].call(this, t, i);
    return s !== !1 && (n !== s.x || r !== s.y);
  }
}
var mv = {
  id: "tooltip",
  _element: sm,
  positioners: Qs,
  afterInit(e, t, i) {
    i && (e.tooltip = new sm({
      chart: e,
      options: i
    }));
  },
  beforeUpdate(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  reset(e, t, i) {
    e.tooltip && e.tooltip.initialize(i);
  },
  afterDraw(e) {
    const t = e.tooltip;
    if (t && t._willRender()) {
      const i = {
        tooltip: t
      };
      if (e.notifyPlugins("beforeTooltipDraw", {
        ...i,
        cancelable: !0
      }) === !1)
        return;
      t.draw(e.ctx), e.notifyPlugins("afterTooltipDraw", i);
    }
  },
  afterEvent(e, t) {
    if (e.tooltip) {
      const i = t.replay;
      e.tooltip.handleEvent(t.event, i, t.inChartArea) && (t.changed = !0);
    }
  },
  defaults: {
    enabled: !0,
    external: null,
    position: "average",
    backgroundColor: "rgba(0,0,0,0.8)",
    titleColor: "#fff",
    titleFont: {
      weight: "bold"
    },
    titleSpacing: 2,
    titleMarginBottom: 6,
    titleAlign: "left",
    bodyColor: "#fff",
    bodySpacing: 2,
    bodyFont: {},
    bodyAlign: "left",
    footerColor: "#fff",
    footerSpacing: 2,
    footerMarginTop: 6,
    footerFont: {
      weight: "bold"
    },
    footerAlign: "left",
    padding: 6,
    caretPadding: 2,
    caretSize: 5,
    cornerRadius: 6,
    boxHeight: (e, t) => t.bodyFont.size,
    boxWidth: (e, t) => t.bodyFont.size,
    multiKeyBackground: "#fff",
    displayColors: !0,
    boxPadding: 0,
    borderColor: "rgba(0,0,0,0)",
    borderWidth: 0,
    animation: {
      duration: 400,
      easing: "easeOutQuart"
    },
    animations: {
      numbers: {
        type: "number",
        properties: [
          "x",
          "y",
          "width",
          "height",
          "caretX",
          "caretY"
        ]
      },
      opacity: {
        easing: "linear",
        duration: 200
      }
    },
    callbacks: Hb
  },
  defaultRoutes: {
    bodyFont: "font",
    footerFont: "font",
    titleFont: "font"
  },
  descriptors: {
    _scriptable: (e) => e !== "filter" && e !== "itemSort" && e !== "external",
    _indexable: !1,
    callbacks: {
      _scriptable: !1,
      _indexable: !1
    },
    animation: {
      _fallback: !1
    },
    animations: {
      _fallback: "animation"
    }
  },
  additionalOptionScopes: [
    "interaction"
  ]
};
const RT = (e, t, i, n) => (typeof t == "string" ? (i = e.push(t) - 1, n.unshift({
  index: i,
  label: t
})) : isNaN(t) && (i = null), i);
function NT(e, t, i, n) {
  const r = e.indexOf(t);
  if (r === -1)
    return RT(e, t, i, n);
  const a = e.lastIndexOf(t);
  return r !== a ? i : r;
}
const FT = (e, t) => e === null ? null : Se(Math.round(e), 0, t);
function om(e) {
  const t = this.getLabels();
  return e >= 0 && e < t.length ? t[e] : e;
}
class Yb extends ds {
  static id = "category";
  static defaults = {
    ticks: {
      callback: om
    }
  };
  constructor(t) {
    super(t), this._startValue = void 0, this._valueRange = 0, this._addedLabels = [];
  }
  init(t) {
    const i = this._addedLabels;
    if (i.length) {
      const n = this.getLabels();
      for (const { index: r, label: a } of i)
        n[r] === a && n.splice(r, 1);
      this._addedLabels = [];
    }
    super.init(t);
  }
  parse(t, i) {
    if (kt(t))
      return null;
    const n = this.getLabels();
    return i = isFinite(i) && n[i] === t ? i : NT(n, t, ct(i, t), this._addedLabels), FT(i, n.length - 1);
  }
  determineDataLimits() {
    const { minDefined: t, maxDefined: i } = this.getUserBounds();
    let { min: n, max: r } = this.getMinMax(!0);
    this.options.bounds === "ticks" && (t || (n = 0), i || (r = this.getLabels().length - 1)), this.min = n, this.max = r;
  }
  buildTicks() {
    const t = this.min, i = this.max, n = this.options.offset, r = [];
    let a = this.getLabels();
    a = t === 0 && i === a.length - 1 ? a : a.slice(t, i + 1), this._valueRange = Math.max(a.length - (n ? 0 : 1), 1), this._startValue = this.min - (n ? 0.5 : 0);
    for (let s = t; s <= i; s++)
      r.push({
        value: s
      });
    return r;
  }
  getLabelForValue(t) {
    return om.call(this, t);
  }
  configure() {
    super.configure(), this.isHorizontal() || (this._reversePixels = !this._reversePixels);
  }
  getPixelForValue(t) {
    return typeof t != "number" && (t = this.parse(t)), t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getPixelForTick(t) {
    const i = this.ticks;
    return t < 0 || t > i.length - 1 ? null : this.getPixelForValue(i[t].value);
  }
  getValueForPixel(t) {
    return Math.round(this._startValue + this.getDecimalForPixel(t) * this._valueRange);
  }
  getBasePixel() {
    return this.bottom;
  }
}
function BT(e, t) {
  const i = [], { bounds: r, step: a, min: s, max: o, precision: l, count: u, maxTicks: c, maxDigits: h, includeBounds: d } = e, f = a || 1, v = c - 1, { min: m, max: p } = t, g = !kt(s), y = !kt(o), _ = !kt(u), b = (p - m) / (h + 1);
  let w = ng((p - m) / v / f) * f, S, M, k, T;
  if (w < 1e-14 && !g && !y)
    return [
      {
        value: m
      },
      {
        value: p
      }
    ];
  T = Math.ceil(p / w) - Math.floor(m / w), T > v && (w = ng(T * w / v / f) * f), kt(l) || (S = Math.pow(10, l), w = Math.ceil(w * S) / S), r === "ticks" ? (M = Math.floor(m / w) * w, k = Math.ceil(p / w) * w) : (M = m, k = p), g && y && a && F2((o - s) / a, w / 1e3) ? (T = Math.round(Math.min((o - s) / w, c)), w = (o - s) / T, M = s, k = o) : _ ? (M = g ? s : M, k = y ? o : k, T = u - 1, w = (k - M) / T) : (T = (k - M) / w, uo(T, Math.round(T), w / 1e3) ? T = Math.round(T) : T = Math.ceil(T));
  const D = Math.max(rg(w), rg(M));
  S = Math.pow(10, kt(l) ? D : l), M = Math.round(M * S) / S, k = Math.round(k * S) / S;
  let C = 0;
  for (g && (d && M !== s ? (i.push({
    value: s
  }), M < s && C++, uo(Math.round((M + C * w) * S) / S, s, lm(s, b, e)) && C++) : M < s && C++); C < T; ++C) {
    const P = Math.round((M + C * w) * S) / S;
    if (y && P > o)
      break;
    i.push({
      value: P
    });
  }
  return y && d && k !== o ? i.length && uo(i[i.length - 1].value, o, lm(o, b, e)) ? i[i.length - 1].value = o : i.push({
    value: o
  }) : (!y || k === o) && i.push({
    value: k
  }), i;
}
function lm(e, t, { horizontal: i, minRotation: n }) {
  const r = mn(n), a = (i ? Math.sin(r) : Math.cos(r)) || 1e-3, s = 0.75 * t * ("" + e).length;
  return Math.min(t / a, s);
}
class $T extends ds {
  constructor(t) {
    super(t), this.start = void 0, this.end = void 0, this._startValue = void 0, this._endValue = void 0, this._valueRange = 0;
  }
  parse(t, i) {
    return kt(t) || (typeof t == "number" || t instanceof Number) && !isFinite(+t) ? null : +t;
  }
  handleTickRangeOptions() {
    const { beginAtZero: t } = this.options, { minDefined: i, maxDefined: n } = this.getUserBounds();
    let { min: r, max: a } = this;
    const s = (l) => r = i ? r : l, o = (l) => a = n ? a : l;
    if (t) {
      const l = qi(r), u = qi(a);
      l < 0 && u < 0 ? o(0) : l > 0 && u > 0 && s(0);
    }
    if (r === a) {
      let l = a === 0 ? 1 : Math.abs(a * 0.05);
      o(a + l), t || s(r - l);
    }
    this.min = r, this.max = a;
  }
  getTickLimit() {
    const t = this.options.ticks;
    let { maxTicksLimit: i, stepSize: n } = t, r;
    return n ? (r = Math.ceil(this.max / n) - Math.floor(this.min / n) + 1, r > 1e3 && (console.warn(`scales.${this.id}.ticks.stepSize: ${n} would result generating up to ${r} ticks. Limiting to 1000.`), r = 1e3)) : (r = this.computeTickLimit(), i = i || 11), i && (r = Math.min(i, r)), r;
  }
  computeTickLimit() {
    return Number.POSITIVE_INFINITY;
  }
  buildTicks() {
    const t = this.options, i = t.ticks;
    let n = this.getTickLimit();
    n = Math.max(2, n);
    const r = {
      maxTicks: n,
      bounds: t.bounds,
      min: t.min,
      max: t.max,
      precision: i.precision,
      step: i.stepSize,
      count: i.count,
      maxDigits: this._maxDigits(),
      horizontal: this.isHorizontal(),
      minRotation: i.minRotation || 0,
      includeBounds: i.includeBounds !== !1
    }, a = this._range || this, s = BT(r, a);
    return t.bounds === "ticks" && B2(s, this, "value"), t.reverse ? (s.reverse(), this.start = this.max, this.end = this.min) : (this.start = this.min, this.end = this.max), s;
  }
  configure() {
    const t = this.ticks;
    let i = this.min, n = this.max;
    if (super.configure(), this.options.offset && t.length) {
      const r = (n - i) / Math.max(t.length - 1, 1) / 2;
      i -= r, n += r;
    }
    this._startValue = i, this._endValue = n, this._valueRange = n - i;
  }
  getLabelForValue(t) {
    return lv(t, this.chart.options.locale, this.options.ticks.format);
  }
}
class Wb extends $T {
  static id = "linear";
  static defaults = {
    ticks: {
      callback: lb.formatters.numeric
    }
  };
  determineDataLimits() {
    const { min: t, max: i } = this.getMinMax(!0);
    this.min = Ce(t) ? t : 0, this.max = Ce(i) ? i : 1, this.handleTickRangeOptions();
  }
  computeTickLimit() {
    const t = this.isHorizontal(), i = t ? this.width : this.height, n = mn(this.options.ticks.minRotation), r = (t ? Math.sin(n) : Math.cos(n)) || 1e-3, a = this._resolveTickFontOptions(0);
    return Math.ceil(i / Math.min(40, a.lineHeight / r));
  }
  getPixelForValue(t) {
    return t === null ? NaN : this.getPixelForDecimal((t - this._startValue) / this._valueRange);
  }
  getValueForPixel(t) {
    return this._startValue + this.getDecimalForPixel(t) * this._valueRange;
  }
}
const Sc = {
  millisecond: {
    common: !0,
    size: 1,
    steps: 1e3
  },
  second: {
    common: !0,
    size: 1e3,
    steps: 60
  },
  minute: {
    common: !0,
    size: 6e4,
    steps: 60
  },
  hour: {
    common: !0,
    size: 36e5,
    steps: 24
  },
  day: {
    common: !0,
    size: 864e5,
    steps: 30
  },
  week: {
    common: !1,
    size: 6048e5,
    steps: 4
  },
  month: {
    common: !0,
    size: 2628e6,
    steps: 12
  },
  quarter: {
    common: !1,
    size: 7884e6,
    steps: 4
  },
  year: {
    common: !0,
    size: 3154e7
  }
}, Ue = /* @__PURE__ */ Object.keys(Sc);
function um(e, t) {
  return e - t;
}
function cm(e, t) {
  if (kt(t))
    return null;
  const i = e._adapter, { parser: n, round: r, isoWeekday: a } = e._parseOpts;
  let s = t;
  return typeof n == "function" && (s = n(s)), Ce(s) || (s = typeof n == "string" ? i.parse(s, n) : i.parse(s)), s === null ? null : (r && (s = r === "week" && (Do(a) || a === !0) ? i.startOf(s, "isoWeek", a) : i.startOf(s, r)), +s);
}
function hm(e, t, i, n) {
  const r = Ue.length;
  for (let a = Ue.indexOf(e); a < r - 1; ++a) {
    const s = Sc[Ue[a]], o = s.steps ? s.steps : Number.MAX_SAFE_INTEGER;
    if (s.common && Math.ceil((i - t) / (o * s.size)) <= n)
      return Ue[a];
  }
  return Ue[r - 1];
}
function zT(e, t, i, n, r) {
  for (let a = Ue.length - 1; a >= Ue.indexOf(i); a--) {
    const s = Ue[a];
    if (Sc[s].common && e._adapter.diff(r, n, s) >= t - 1)
      return s;
  }
  return Ue[i ? Ue.indexOf(i) : 0];
}
function VT(e) {
  for (let t = Ue.indexOf(e) + 1, i = Ue.length; t < i; ++t)
    if (Sc[Ue[t]].common)
      return Ue[t];
}
function dm(e, t, i) {
  if (!i)
    e[t] = !0;
  else if (i.length) {
    const { lo: n, hi: r } = av(i, t), a = i[n] >= t ? i[n] : i[r];
    e[a] = !0;
  }
}
function HT(e, t, i, n) {
  const r = e._adapter, a = +r.startOf(t[0].value, n), s = t[t.length - 1].value;
  let o, l;
  for (o = a; o <= s; o = +r.add(o, 1, n))
    l = i[o], l >= 0 && (t[l].major = !0);
  return t;
}
function fm(e, t, i) {
  const n = [], r = {}, a = t.length;
  let s, o;
  for (s = 0; s < a; ++s)
    o = t[s], r[o] = s, n.push({
      value: o,
      major: !1
    });
  return a === 0 || !i ? n : HT(e, n, r, i);
}
class vm extends ds {
  static id = "time";
  static defaults = {
    bounds: "data",
    adapters: {},
    time: {
      parser: !1,
      unit: !1,
      round: !1,
      isoWeekday: !1,
      minUnit: "millisecond",
      displayFormats: {}
    },
    ticks: {
      source: "auto",
      callback: !1,
      major: {
        enabled: !1
      }
    }
  };
  constructor(t) {
    super(t), this._cache = {
      data: [],
      labels: [],
      all: []
    }, this._unit = "day", this._majorUnit = void 0, this._offsets = {}, this._normalized = !1, this._parseOpts = void 0;
  }
  init(t, i = {}) {
    const n = t.time || (t.time = {}), r = this._adapter = new Mk._date(t.adapters.date);
    r.init(i), lo(n.displayFormats, r.formats()), this._parseOpts = {
      parser: n.parser,
      round: n.round,
      isoWeekday: n.isoWeekday
    }, super.init(t), this._normalized = i.normalized;
  }
  parse(t, i) {
    return t === void 0 ? null : cm(this, t);
  }
  beforeLayout() {
    super.beforeLayout(), this._cache = {
      data: [],
      labels: [],
      all: []
    };
  }
  determineDataLimits() {
    const t = this.options, i = this._adapter, n = t.time.unit || "day";
    let { min: r, max: a, minDefined: s, maxDefined: o } = this.getUserBounds();
    function l(u) {
      !s && !isNaN(u.min) && (r = Math.min(r, u.min)), !o && !isNaN(u.max) && (a = Math.max(a, u.max));
    }
    (!s || !o) && (l(this._getLabelBounds()), (t.bounds !== "ticks" || t.ticks.source !== "labels") && l(this.getMinMax(!1))), r = Ce(r) && !isNaN(r) ? r : +i.startOf(Date.now(), n), a = Ce(a) && !isNaN(a) ? a : +i.endOf(Date.now(), n) + 1, this.min = Math.min(r, a - 1), this.max = Math.max(r + 1, a);
  }
  _getLabelBounds() {
    const t = this.getLabelTimestamps();
    let i = Number.POSITIVE_INFINITY, n = Number.NEGATIVE_INFINITY;
    return t.length && (i = t[0], n = t[t.length - 1]), {
      min: i,
      max: n
    };
  }
  buildTicks() {
    const t = this.options, i = t.time, n = t.ticks, r = n.source === "labels" ? this.getLabelTimestamps() : this._generate();
    t.bounds === "ticks" && r.length && (this.min = this._userMin || r[0], this.max = this._userMax || r[r.length - 1]);
    const a = this.min, s = this.max, o = Y2(r, a, s);
    return this._unit = i.unit || (n.autoSkip ? hm(i.minUnit, this.min, this.max, this._getLabelCapacity(a)) : zT(this, o.length, i.minUnit, this.min, this.max)), this._majorUnit = !n.major.enabled || this._unit === "year" ? void 0 : VT(this._unit), this.initOffsets(r), t.reverse && o.reverse(), fm(this, o, this._majorUnit);
  }
  afterAutoSkip() {
    this.options.offsetAfterAutoskip && this.initOffsets(this.ticks.map((t) => +t.value));
  }
  initOffsets(t = []) {
    let i = 0, n = 0, r, a;
    this.options.offset && t.length && (r = this.getDecimalForValue(t[0]), t.length === 1 ? i = 1 - r : i = (this.getDecimalForValue(t[1]) - r) / 2, a = this.getDecimalForValue(t[t.length - 1]), t.length === 1 ? n = a : n = (a - this.getDecimalForValue(t[t.length - 2])) / 2);
    const s = t.length < 3 ? 0.5 : 0.25;
    i = Se(i, 0, s), n = Se(n, 0, s), this._offsets = {
      start: i,
      end: n,
      factor: 1 / (i + 1 + n)
    };
  }
  _generate() {
    const t = this._adapter, i = this.min, n = this.max, r = this.options, a = r.time, s = a.unit || hm(a.minUnit, i, n, this._getLabelCapacity(i)), o = ct(r.ticks.stepSize, 1), l = s === "week" ? a.isoWeekday : !1, u = Do(l) || l === !0, c = {};
    let h = i, d, f;
    if (u && (h = +t.startOf(h, "isoWeek", l)), h = +t.startOf(h, u ? "day" : s), t.diff(n, i, s) > 1e5 * o)
      throw new Error(i + " and " + n + " are too far apart with stepSize of " + o + " " + s);
    const v = r.ticks.source === "data" && this.getDataTimestamps();
    for (d = h, f = 0; d < n; d = +t.add(d, o, s), f++)
      dm(c, d, v);
    return (d === n || r.bounds === "ticks" || f === 1) && dm(c, d, v), Object.keys(c).sort(um).map((m) => +m);
  }
  getLabelForValue(t) {
    const i = this._adapter, n = this.options.time;
    return n.tooltipFormat ? i.format(t, n.tooltipFormat) : i.format(t, n.displayFormats.datetime);
  }
  format(t, i) {
    const r = this.options.time.displayFormats, a = this._unit, s = i || r[a];
    return this._adapter.format(t, s);
  }
  _tickFormatFunction(t, i, n, r) {
    const a = this.options, s = a.ticks.callback;
    if (s)
      return zt(s, [
        t,
        i,
        n
      ], this);
    const o = a.time.displayFormats, l = this._unit, u = this._majorUnit, c = l && o[l], h = u && o[u], d = n[i], f = u && h && d && d.major;
    return this._adapter.format(t, r || (f ? h : c));
  }
  generateTickLabels(t) {
    let i, n, r;
    for (i = 0, n = t.length; i < n; ++i)
      r = t[i], r.label = this._tickFormatFunction(r.value, i, t);
  }
  getDecimalForValue(t) {
    return t === null ? NaN : (t - this.min) / (this.max - this.min);
  }
  getPixelForValue(t) {
    const i = this._offsets, n = this.getDecimalForValue(t);
    return this.getPixelForDecimal((i.start + n) * i.factor);
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return this.min + n * (this.max - this.min);
  }
  _getLabelSize(t) {
    const i = this.options.ticks, n = this.ctx.measureText(t).width, r = mn(this.isHorizontal() ? i.maxRotation : i.minRotation), a = Math.cos(r), s = Math.sin(r), o = this._resolveTickFontOptions(0).size;
    return {
      w: n * a + o * s,
      h: n * s + o * a
    };
  }
  _getLabelCapacity(t) {
    const i = this.options.time, n = i.displayFormats, r = n[i.unit] || n.millisecond, a = this._tickFormatFunction(t, 0, fm(this, [
      t
    ], this._majorUnit), r), s = this._getLabelSize(a), o = Math.floor(this.isHorizontal() ? this.width / s.w : this.height / s.h) - 1;
    return o > 0 ? o : 1;
  }
  getDataTimestamps() {
    let t = this._cache.data || [], i, n;
    if (t.length)
      return t;
    const r = this.getMatchingVisibleMetas();
    if (this._normalized && r.length)
      return this._cache.data = r[0].controller.getAllParsedValues(this);
    for (i = 0, n = r.length; i < n; ++i)
      t = t.concat(r[i].controller.getAllParsedValues(this));
    return this._cache.data = this.normalize(t);
  }
  getLabelTimestamps() {
    const t = this._cache.labels || [];
    let i, n;
    if (t.length)
      return t;
    const r = this.getLabels();
    for (i = 0, n = r.length; i < n; ++i)
      t.push(cm(this, r[i]));
    return this._cache.labels = this._normalized ? t : this.normalize(t);
  }
  normalize(t) {
    return ab(t.sort(um));
  }
}
function gl(e, t, i) {
  let n = 0, r = e.length - 1, a, s, o, l;
  i ? (t >= e[n].pos && t <= e[r].pos && ({ lo: n, hi: r } = Hr(e, "pos", t)), { pos: a, time: o } = e[n], { pos: s, time: l } = e[r]) : (t >= e[n].time && t <= e[r].time && ({ lo: n, hi: r } = Hr(e, "time", t)), { time: a, pos: o } = e[n], { time: s, pos: l } = e[r]);
  const u = s - a;
  return u ? o + (l - o) * (t - a) / u : o;
}
class c7 extends vm {
  static id = "timeseries";
  static defaults = vm.defaults;
  constructor(t) {
    super(t), this._table = [], this._minPos = void 0, this._tableRange = void 0;
  }
  initOffsets() {
    const t = this._getTimestampsForTable(), i = this._table = this.buildLookupTable(t);
    this._minPos = gl(i, this.min), this._tableRange = gl(i, this.max) - this._minPos, super.initOffsets(t);
  }
  buildLookupTable(t) {
    const { min: i, max: n } = this, r = [], a = [];
    let s, o, l, u, c;
    for (s = 0, o = t.length; s < o; ++s)
      u = t[s], u >= i && u <= n && r.push(u);
    if (r.length < 2)
      return [
        {
          time: i,
          pos: 0
        },
        {
          time: n,
          pos: 1
        }
      ];
    for (s = 0, o = r.length; s < o; ++s)
      c = r[s + 1], l = r[s - 1], u = r[s], Math.round((c + l) / 2) !== u && a.push({
        time: u,
        pos: s / (o - 1)
      });
    return a;
  }
  _generate() {
    const t = this.min, i = this.max;
    let n = super.getDataTimestamps();
    return (!n.includes(t) || !n.length) && n.splice(0, 0, t), (!n.includes(i) || n.length === 1) && n.push(i), n.sort((r, a) => r - a);
  }
  _getTimestampsForTable() {
    let t = this._cache.all || [];
    if (t.length)
      return t;
    const i = this.getDataTimestamps(), n = this.getLabelTimestamps();
    return i.length && n.length ? t = this.normalize(i.concat(n)) : t = i.length ? i : n, t = this._cache.all = t, t;
  }
  getDecimalForValue(t) {
    return (gl(this._table, t) - this._minPos) / this._tableRange;
  }
  getValueForPixel(t) {
    const i = this._offsets, n = this.getDecimalForPixel(t) / i.factor - i.end;
    return gl(this._table, n * this._tableRange + this._minPos, !0);
  }
}
const Ub = {
  data: {
    type: Object,
    required: !0
  },
  options: {
    type: Object,
    default: () => ({})
  },
  plugins: {
    type: Array,
    default: () => []
  },
  datasetIdKey: {
    type: String,
    default: "label"
  },
  updateMode: {
    type: String,
    default: void 0
  }
}, YT = {
  ariaLabel: {
    type: String
  },
  ariaDescribedby: {
    type: String
  }
}, WT = {
  type: {
    type: String,
    required: !0
  },
  destroyDelay: {
    type: Number,
    default: 0
    // No delay by default
  },
  ...Ub,
  ...YT
}, UT = i2[0] === "2" ? (e, t) => Object.assign(e, {
  attrs: t
}) : (e, t) => Object.assign(e, t);
function _a(e) {
  return Z_(e) ? Nd(e) : e;
}
function GT(e) {
  let t = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : e;
  return Z_(t) ? new Proxy(e, {}) : e;
}
function XT(e, t) {
  const i = e.options;
  i && t && Object.assign(i, t);
}
function Gb(e, t) {
  e.labels = t;
}
function Xb(e, t, i) {
  const n = [];
  e.datasets = t.map((r) => {
    const a = e.datasets.find((s) => s[i] === r[i]);
    return !a || !r.data || n.includes(a) ? {
      ...r
    } : (n.push(a), Object.assign(a, r), a);
  });
}
function jT(e, t) {
  const i = {
    labels: [],
    datasets: []
  };
  return Gb(i, e.labels), Xb(i, e.datasets, t), i;
}
const qT = le({
  props: WT,
  setup(e, t) {
    let { expose: i, slots: n } = t;
    const r = gi(null), a = X_(null);
    i({
      chart: a
    });
    const s = () => {
      if (!r.value) return;
      const { type: u, data: c, options: h, plugins: d, datasetIdKey: f } = e, v = jT(c, f), m = GT(v, c);
      a.value = new fs(r.value, {
        type: u,
        data: m,
        options: {
          ...h
        },
        plugins: d
      });
    }, o = () => {
      const u = Nd(a.value);
      u && (e.destroyDelay > 0 ? setTimeout(() => {
        u.destroy(), a.value = null;
      }, e.destroyDelay) : (u.destroy(), a.value = null));
    }, l = (u) => {
      u.update(e.updateMode);
    };
    return tv(s), j_(o), ns([
      () => e.options,
      () => e.data
    ], (u, c) => {
      let [h, d] = u, [f, v] = c;
      const m = Nd(a.value);
      if (!m)
        return;
      let p = !1;
      if (h) {
        const g = _a(h), y = _a(f);
        g && g !== y && (XT(m, g), p = !0);
      }
      if (d) {
        const g = _a(d.labels), y = _a(v.labels), _ = _a(d.datasets), b = _a(v.datasets);
        g !== y && (Gb(m.config.data, g), p = !0), _ && _ !== b && (Xb(m.config.data, _, e.datasetIdKey), p = !0);
      }
      p && q_(() => {
        l(m);
      });
    }, {
      deep: !0
    }), () => Rd("canvas", {
      role: "img",
      "aria-label": e.ariaLabel,
      "aria-describedby": e.ariaDescribedby,
      ref: r
    }, [
      Rd("p", {}, [
        n.default ? n.default() : ""
      ])
    ]);
  }
});
function yv(e, t) {
  return fs.register(t), le({
    props: Ub,
    setup(i, n) {
      let { expose: r } = n;
      const a = X_(null), s = (o) => {
        a.value = o?.chart;
      };
      return r({
        chart: a
      }), () => Rd(qT, UT({
        ref: s
      }, {
        type: e,
        ...i
      }));
    }
  });
}
const ZT = /* @__PURE__ */ yv("bar", _k), KT = /* @__PURE__ */ yv("line", wk), QT = /* @__PURE__ */ yv("pie", Sk), pm = {
  // Backgrounds
  bgPrimary: "#f8f9fa",
  bgSecondary: "#ffffff",
  bgCard: "#ffffff",
  bgCardGradientStart: "#ffffff",
  bgCardGradientEnd: "#fafafa",
  bgTable: "#ffffff",
  bgTableHeader: "#f8fafc",
  bgTableHover: "#f8fafc",
  // Text
  textPrimary: "#1e293b",
  textSecondary: "#64748b",
  textMuted: "#94a3b8",
  // Borders & Lines
  borderColor: "rgba(93, 75, 147, 0.1)",
  borderLight: "rgba(0, 0, 0, 0.05)",
  gridLines: "rgba(148, 163, 184, 0.12)",
  // Shadows
  shadowLight: "rgba(0, 0, 0, 0.05)",
  shadowMedium: "rgba(0, 0, 0, 0.08)",
  shadowHeavy: "rgba(0, 0, 0, 0.1)",
  // Charts specific
  tooltipBg: "rgba(15, 23, 42, 0.95)",
  tooltipText: "#f1f5f9",
  tooltipBorder: "rgba(148, 163, 184, 0.2)",
  // Status colors
  success: "#10b981",
  warning: "#f59e0b",
  danger: "#ef4444",
  info: "#3b82f6",
  // Brand colors
  primaryLight: "#c67dff",
  primaryDefault: "#5d4b93",
  primaryDark: "#4a3a75"
}, gm = {
  // Backgrounds
  bgPrimary: "#000000",
  bgSecondary: "#1a1a1d",
  bgCard: "#1a1a1d",
  bgCardGradientStart: "#1a1a1d",
  bgCardGradientEnd: "#0f0f11",
  bgTable: "#1a1a1d",
  bgTableHeader: "#252528",
  bgTableHover: "#252528",
  // Text
  textPrimary: "#f8f9fa",
  textSecondary: "#9ca3af",
  textMuted: "#6b7280",
  // Borders & Lines
  borderColor: "rgba(198, 125, 255, 0.15)",
  borderLight: "rgba(198, 125, 255, 0.08)",
  gridLines: "rgba(198, 125, 255, 0.12)",
  // Shadows
  shadowLight: "rgba(0, 0, 0, 0.3)",
  shadowMedium: "rgba(0, 0, 0, 0.4)",
  shadowHeavy: "rgba(0, 0, 0, 0.5)",
  // Charts specific
  tooltipBg: "rgba(26, 26, 29, 0.98)",
  tooltipText: "#f8f9fa",
  tooltipBorder: "rgba(198, 125, 255, 0.2)",
  // Status colors
  success: "#10b981",
  warning: "#f59e0b",
  danger: "#ef4444",
  info: "#3b82f6",
  // Brand colors
  primaryLight: "#c67dff",
  primaryDefault: "#5d4b93",
  primaryDark: "#4a3a75"
}, JT = [
  "#C67DFF",
  // Purple light
  "#5D4B93",
  // Purple default
  "#73D1D3",
  // Cyan
  "#1EC383",
  // Green
  "#F496A6",
  // Pink
  "#F3A332",
  // Orange
  "#7D8AFA"
  // Blue
];
function _e(e) {
  const t = gi("light");
  let i = null;
  const n = () => typeof document > "u" ? "light" : document.documentElement.classList.contains("dark") ? "dark" : "light", r = q(() => e?.value ? e.value : t.value), a = q(() => r.value === "dark"), s = q(() => a.value ? gm : pm), o = () => {
    typeof document > "u" || (t.value = n(), i = new MutationObserver((u) => {
      for (const c of u)
        c.attributeName === "class" && (t.value = n());
    }), i.observe(document.documentElement, {
      attributes: !0,
      attributeFilter: ["class"]
    }));
  }, l = () => {
    i && (i.disconnect(), i = null);
  };
  return tv(() => {
    o();
  }), j_(() => {
    l();
  }), e && ns(e, () => {
  }), {
    isDark: a,
    currentTheme: r,
    colors: s,
    detectedTheme: t,
    // Export color constants for direct access if needed
    lightColors: pm,
    darkColors: gm,
    chartSeriesColors: JT
  };
}
const tC = { class: "chart-container" }, eC = /* @__PURE__ */ le({
  __name: "ChartBar",
  props: {
    data: {},
    options: {},
    stacked: { type: Boolean },
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    fs.register(
      Yb,
      Wb,
      eT,
      Vb,
      mv,
      gv
    );
    const { isDark: n, colors: r } = _e(ye(i, "theme")), a = i.data, s = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, o = q(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          },
          generateLabels: function(l) {
            return l.data.datasets.map((c, h) => ({
              text: s(c.label || ""),
              fillStyle: Array.isArray(c.backgroundColor) ? c.backgroundColor[0] : c.backgroundColor,
              strokeStyle: Array.isArray(c.borderColor) ? c.borderColor[0] : c.borderColor,
              lineWidth: c.borderWidth,
              hidden: !l.isDatasetVisible(h),
              index: h,
              datasetIndex: h
            }));
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(s(l[0].label)) : "";
            },
            label: function(l) {
              let u = String(s(l.dataset.label || ""));
              return u && (u += ": "), l.parsed.y !== null && (u += l.parsed.y), u;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          stacked: i.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            color: r.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              return s(l);
            }
          }
        },
        x: {
          stacked: i.stacked || !1,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              const u = this.getLabelForValue(l);
              return s(u);
            }
          }
        }
      },
      elements: {
        bar: {
          borderRadius: 8,
          borderWidth: 0
        }
      }
    });
    return t({ isDark: n }), (l, u) => (A(), I("div", tC, [
      fe(X(ZT), {
        data: X(a),
        options: o.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), te = (e, t) => {
  const i = e.__vccOpts || e;
  for (const [n, r] of t)
    i[n] = r;
  return i;
}, jb = /* @__PURE__ */ te(eC, [["__scopeId", "data-v-be0a7bf2"]]), iC = { class: "chart-container" }, nC = /* @__PURE__ */ le({
  __name: "ChartLine",
  props: {
    data: {},
    options: {},
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    fs.register(
      Yb,
      Wb,
      qD,
      xc,
      Vb,
      mv,
      gv,
      xT
    );
    const { isDark: n, colors: r } = _e(ye(i, "theme")), a = i.data, s = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, o = q(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(l) {
              return l.data.datasets.map((c, h) => ({
                text: s(c.label || ""),
                fillStyle: c.backgroundColor,
                strokeStyle: c.borderColor,
                lineWidth: c.borderWidth,
                hidden: !l.isDatasetVisible(h),
                index: h,
                datasetIndex: h
              }));
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(s(l[0].label)) : "";
            },
            label: function(l) {
              let u = String(s(l.dataset.label || ""));
              return u && (u += ": "), l.parsed.y !== null && (u += l.parsed.y), u;
            }
          }
        }
      },
      scales: {
        y: {
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: r.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              return s(l);
            }
          }
        },
        x: {
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 8,
            callback: function(l) {
              const u = this.getLabelForValue(l);
              return s(u);
            }
          }
        }
      },
      elements: {
        line: {
          tension: 0.4,
          borderWidth: 2.5,
          borderCapStyle: "round"
        },
        point: {
          radius: 4,
          hoverRadius: 6,
          borderWidth: 2,
          backgroundColor: n.value ? "#1a1a1d" : "#ffffff",
          hoverBorderWidth: 3
        }
      }
    });
    return t({ isDark: n }), (l, u) => (A(), I("div", iC, [
      fe(X(KT), {
        data: X(a),
        options: o.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), _v = /* @__PURE__ */ te(nC, [["__scopeId", "data-v-c400b486"]]), rC = { class: "chart-container" }, aC = /* @__PURE__ */ le({
  __name: "PieChart",
  props: {
    data: {},
    options: {},
    doughnut: { type: Boolean },
    theme: {}
  },
  setup(e, { expose: t }) {
    const i = e;
    fs.register($D, mv, gv);
    const { isDark: n, colors: r } = _e(ye(i, "theme")), a = i.data, s = (l) => typeof l == "string" ? l.charAt(0).toUpperCase() + l.slice(1).toLowerCase() : l, o = q(() => i.options ? i.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      cutout: i.doughnut ? "60%" : 0,
      plugins: {
        legend: {
          display: !0,
          position: "bottom",
          align: "center",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: r.value.textSecondary,
            padding: 16,
            boxWidth: 14,
            boxHeight: 14,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "circle",
            generateLabels: function(l) {
              const u = l.data;
              return u.labels.length && u.datasets.length ? u.labels.map((c, h) => {
                const d = l.getDatasetMeta(0), f = u.datasets[0], v = f.data[h], m = Array.isArray(f.backgroundColor) ? f.backgroundColor[h] : f.backgroundColor;
                return {
                  text: `${s(c)}: ${v}`,
                  fillStyle: m,
                  hidden: d.data[h]?.hidden || !1,
                  index: h
                };
              }) : [];
            }
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: r.value.tooltipBg,
          titleColor: r.value.tooltipText,
          bodyColor: n.value ? "#d1d5db" : "#e2e8f0",
          borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          displayColors: !0,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          boxPadding: 6,
          callbacks: {
            title: function(l) {
              return l.length > 0 ? String(s(l[0].label)) : "";
            },
            label: function(l) {
              const u = l.label || "", c = l.parsed || 0, h = l.dataset.data.reduce((f, v) => f + v, 0), d = (c / h * 100).toFixed(1);
              return `${s(u)}: ${c} (${d}%)`;
            }
          }
        }
      },
      elements: {
        arc: {
          borderWidth: 2,
          borderColor: n.value ? "#1a1a1d" : "#ffffff",
          hoverOffset: 8
        }
      },
      animation: {
        animateRotate: !0,
        animateScale: !0
      }
    });
    return t({ isDark: n }), (l, u) => (A(), I("div", rC, [
      fe(X(QT), {
        data: X(a),
        options: o.value
      }, null, 8, ["data", "options"])
    ]));
  }
}), qb = /* @__PURE__ */ te(aC, [["__scopeId", "data-v-23a84317"]]), sC = { class: "chart-container" }, oC = ["viewBox"], lC = ["transform"], uC = ["x", "width", "fill", "stroke"], cC = ["fill"], hC = ["x1", "y1", "x2", "y2", "stroke"], dC = ["points", "fill"], fC = ["x1", "y1", "x2", "y2", "stroke"], vC = ["x", "y", "fill"], pC = ["x1", "y1", "x2", "y2", "stroke"], gC = ["points", "fill"], mC = ["transform"], yC = ["y1", "y2"], _C = ["y1", "y2"], bC = ["y1", "y2"], xC = ["y1", "y2"], wC = ["y", "height"], SC = ["y1", "y2"], MC = ["y1", "y2"], kC = ["y1", "y2"], DC = ["y1", "y2"], TC = ["y", "height"], CC = ["cy", "stroke", "onMouseenter"], EC = ["cy", "stroke", "onMouseenter"], AC = ["cy", "stroke", "onMouseenter"], PC = ["cy", "stroke", "onMouseenter"], LC = ["y1", "y2", "onMouseenter"], OC = ["y1", "y2", "onMouseenter"], IC = ["x", "y", "fill"], RC = ["x", "y", "fill"], NC = ["transform"], FC = { transform: "translate(-200, 0)" }, BC = ["stroke"], $C = ["fill"], zC = { transform: "translate(-130, 0)" }, VC = ["stroke"], HC = ["fill"], YC = { transform: "translate(-60, 0)" }, WC = ["stroke"], UC = ["fill"], GC = { transform: "translate(10, 0)" }, XC = ["stroke"], jC = ["fill"], qC = { transform: "translate(80, 0)" }, ZC = ["fill"], KC = { transform: "translate(150, 0)" }, QC = ["fill"], JC = /* @__PURE__ */ le({
  __name: "BoxplotChart",
  props: {
    boxplotData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    showLegend: { type: Boolean, default: !0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = _e(ye(i, "theme")), r = q(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569",
      // Dots
      dotStroke: n.value ? "#1a1a1d" : "#ffffff"
    })), a = gi({
      visible: !1,
      x: 0,
      y: 0,
      text: ""
    }), s = (d) => typeof d == "string" ? d.charAt(0).toUpperCase() + d.slice(1).toLowerCase() : d, o = (d, f) => {
      const v = d.currentTarget.closest("svg");
      if (!v) return;
      const m = v.getBoundingClientRect(), p = v.createSVGPoint();
      p.x = d.clientX - m.left, p.y = d.clientY - m.top, a.value = {
        visible: !0,
        x: p.x,
        y: p.y - 20,
        text: f
      };
    }, l = (d) => {
      if (a.value.visible) {
        const f = d.currentTarget, v = f.getBoundingClientRect(), m = f.createSVGPoint();
        m.x = d.clientX - v.left, m.y = d.clientY - v.top, a.value.x = m.x, a.value.y = m.y - 20;
      }
    }, u = () => {
      a.value.visible = !1;
    }, c = () => {
      a.value.visible = !1;
    }, h = q(() => {
      const d = [], v = i.chartHeight - i.chartMargin - i.chartBottomMargin;
      for (let m = 1; m <= 10; m++) {
        const p = m, g = (p - 1) / 9, y = i.chartMargin + v - g * v;
        d.push({ value: p, y });
      }
      return d;
    });
    return t({ isDark: n }), (d, f) => (A(), I("div", sC, [
      (A(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full boxplot-svg",
        style: qr(`min-height: ${e.chartHeight}px;`),
        onMousemove: l,
        onMouseleave: u
      }, [
        a.value.visible ? (A(), I("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -(a.value.text.length * 6 + 10),
            y: -16,
            width: a.value.text.length * 12 + 20,
            height: "24",
            fill: r.value.tooltipBg,
            rx: "6",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, uC),
          x("text", {
            x: "0",
            y: "0",
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "middle"
          }, R(a.value.text), 9, cC)
        ], 8, lC)) : Q("", !0),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, hC),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, dC),
        (A(!0), I(Rt, null, ce(h.value, (v, m) => (A(), I(Rt, { key: m }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: v.y,
            x2: e.chartMargin,
            y2: v.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, fC),
          x("text", {
            x: e.chartMargin - 12,
            y: v.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, R(v.value), 9, vC)
        ], 64))), 128)),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, pC),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, gC),
        (A(!0), I(Rt, null, ce(e.boxplotData, (v, m) => (A(), I(Rt, { key: m }, [
          x("g", {
            transform: `translate(${v.centerX}, 0)`
          }, [
            v.isTotal ? (A(), I(Rt, { key: 0 }, [
              x("line", {
                x1: 0,
                y1: v.minY,
                x2: 0,
                y2: v.q1Y,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, yC),
              x("line", {
                x1: 0,
                y1: v.q3Y,
                x2: 0,
                y2: v.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, _C),
              x("line", {
                x1: -18,
                y1: v.minY,
                x2: 18,
                y2: v.minY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, bC),
              x("line", {
                x1: -18,
                y1: v.maxY,
                x2: 18,
                y2: v.maxY,
                stroke: "#8b5cf6",
                "stroke-width": "2.5"
              }, null, 8, xC),
              x("rect", {
                x: -24,
                y: v.q3Y,
                width: "48",
                height: v.q1Y - v.q3Y,
                fill: "#8b5cf6",
                "fill-opacity": "0.15",
                stroke: "#8b5cf6",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, wC)
            ], 64)) : (A(), I(Rt, { key: 1 }, [
              x("line", {
                x1: 0,
                y1: v.minY,
                x2: 0,
                y2: v.q1Y,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, SC),
              x("line", {
                x1: 0,
                y1: v.q3Y,
                x2: 0,
                y2: v.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, MC),
              x("line", {
                x1: -18,
                y1: v.minY,
                x2: 18,
                y2: v.minY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, kC),
              x("line", {
                x1: -18,
                y1: v.maxY,
                x2: 18,
                y2: v.maxY,
                stroke: "#C67DFF",
                "stroke-width": "2.5"
              }, null, 8, DC),
              x("rect", {
                x: -24,
                y: v.q3Y,
                width: "48",
                height: v.q1Y - v.q3Y,
                fill: "#C67DFF",
                "fill-opacity": "0.15",
                stroke: "#C67DFF",
                "stroke-width": "2.5",
                rx: "4"
              }, null, 8, TC)
            ], 64)),
            x("circle", {
              cx: 0,
              cy: v.minY,
              r: "6",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => o(p, `Min: ${v.min.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, CC),
            x("circle", {
              cx: 0,
              cy: v.q1Y,
              r: "6",
              fill: "#a855f7",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => o(p, `Q1: ${v.q1.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, EC),
            x("circle", {
              cx: 0,
              cy: v.q3Y,
              r: "6",
              fill: "#7c3aed",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => o(p, `Q3: ${v.q3.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, AC),
            x("circle", {
              cx: 0,
              cy: v.maxY,
              r: "6",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => o(p, `Max: ${v.max.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, PC),
            x("line", {
              x1: -24,
              y1: v.medianY,
              x2: 24,
              y2: v.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3.5",
              class: "hover-line",
              onMouseenter: (p) => o(p, `Median: ${v.median.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, LC),
            v.averageY ? (A(), I("line", {
              key: 2,
              x1: -24,
              y1: v.averageY,
              x2: 24,
              y2: v.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (p) => o(p, `Avg: ${v.average.toFixed(1)}`),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, OC)) : Q("", !0)
          ], 8, mC),
          x("text", {
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, R(s(v.label)), 9, IC),
          v.responseCount ? (A(), I("text", {
            key: 0,
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: r.value.tickText,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + R(v.responseCount), 9, RC)) : Q("", !0)
        ], 64))), 128)),
        e.showLegend ? (A(), I("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [
          x("g", FC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, BC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, $C)
          ]),
          x("g", zC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#a855f7",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, VC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, HC)
          ]),
          x("g", YC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#7c3aed",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, WC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, UC)
          ]),
          x("g", GC, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, XC),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, jC)
          ]),
          x("g", qC, [
            f[0] || (f[0] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, ZC)
          ]),
          x("g", KC, [
            f[1] || (f[1] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, QC)
          ])
        ], 8, NC)) : Q("", !0)
      ], 44, oC))
    ]));
  }
}), tE = /* @__PURE__ */ te(JC, [["__scopeId", "data-v-520c623f"]]), eE = { class: "chart-container" }, iE = ["viewBox"], nE = ["transform"], rE = ["x", "y", "width", "height", "fill", "stroke"], aE = ["y", "fill"], sE = ["y", "fill"], oE = ["x1", "y1", "x2", "y2", "stroke"], lE = ["points", "fill"], uE = ["x1", "y1", "x2", "y2", "stroke"], cE = ["x1", "y1", "x2", "y2", "stroke"], hE = ["x", "y", "fill"], dE = ["x", "y", "fill", "transform"], fE = ["x1", "y1", "x2", "y2", "stroke"], vE = ["points", "fill"], pE = ["transform"], gE = ["y1", "y2", "stroke", "onMouseenter"], mE = ["x", "y", "width", "height", "fill", "stroke", "onMouseenter"], yE = ["x1", "y1", "x2", "y2", "onMouseenter"], _E = ["x1", "y1", "x2", "y2", "onMouseenter"], bE = ["cy", "stroke", "onMouseenter"], xE = ["cy", "stroke", "onMouseenter"], wE = ["x", "y", "fill"], SE = ["x", "y", "fill"], ME = ["transform"], kE = { transform: "translate(-180, 0)" }, DE = ["stroke"], TE = ["fill"], CE = { transform: "translate(-120, 0)" }, EE = ["fill"], AE = { transform: "translate(-60, 0)" }, PE = ["fill"], LE = { transform: "translate(0, 0)" }, OE = ["stroke"], IE = ["fill"], RE = { transform: "translate(60, 0)" }, NE = ["fill"], FE = { transform: "translate(130, 0)" }, BE = ["fill"], $E = /* @__PURE__ */ le({
  __name: "CandlestickChart",
  props: {
    candlestickData: {},
    chartWidth: { default: 800 },
    chartHeight: { default: 400 },
    chartMargin: { default: 70 },
    chartBottomMargin: { default: 90 },
    candleWidth: { default: 35 },
    showLegend: { type: Boolean, default: !0 },
    yAxisLabel: { default: "score" },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = _e(ye(i, "theme")), r = q(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      tooltipTextSecondary: n.value ? "#d1d5db" : "#e2e8f0",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Grid
      gridLine: n.value ? "#374151" : "#e5e7eb",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569",
      // Dots
      dotStroke: n.value ? "#1a1a1d" : "#ffffff"
    })), a = gi({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), s = (d) => typeof d == "string" ? d.charAt(0).toUpperCase() + d.slice(1).toLowerCase() : d, o = (d, f, v) => {
      const m = d.currentTarget.closest("svg");
      if (!m) return;
      const p = m.getBoundingClientRect(), g = m.createSVGPoint();
      g.x = d.clientX - p.left, g.y = d.clientY - p.top;
      let y = s(f.label), _ = "";
      switch (v) {
        case "body":
          _ = `Q1: ${f.q1.toFixed(1)} | Q3: ${f.q3.toFixed(1)}`;
          break;
        case "wick":
          _ = `Min: ${f.low.toFixed(1)} | Max: ${f.high.toFixed(1)}`;
          break;
        case "median":
          _ = `Median: ${f.median.toFixed(1)}`;
          break;
        case "average":
          _ = `Average: ${f.average?.toFixed(1)}`;
          break;
        case "min":
          _ = `Min: ${f.low.toFixed(1)}`;
          break;
        case "max":
          _ = `Max: ${f.high.toFixed(1)}`;
          break;
      }
      const b = Math.max(180, _.length * 7 + 40), w = 48;
      a.value = {
        visible: !0,
        x: g.x,
        y: g.y - 20,
        title: y,
        text: _,
        width: b,
        height: w
      };
    }, l = (d) => {
      if (a.value.visible) {
        const f = d.currentTarget, v = f.getBoundingClientRect(), m = f.createSVGPoint();
        m.x = d.clientX - v.left, m.y = d.clientY - v.top, a.value.x = m.x, a.value.y = m.y - 20;
      }
    }, u = () => {
      a.value.visible = !1;
    }, c = () => {
      a.value.visible = !1;
    }, h = q(() => {
      const d = [], v = i.chartHeight - i.chartMargin - i.chartBottomMargin;
      for (let m = 1; m <= 10; m++) {
        const p = m, g = (p - 1) / 9, y = i.chartMargin + v - g * v;
        d.push({ value: p, y });
      }
      return d;
    });
    return t({ isDark: n }), (d, f) => (A(), I("div", eE, [
      (A(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full candlestick-svg",
        style: qr(`min-height: ${e.chartHeight}px;`),
        onMousemove: l,
        onMouseleave: u
      }, [
        a.value.visible ? (A(), I("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -a.value.width / 2,
            y: -a.value.height - 10,
            width: a.value.width,
            height: a.value.height,
            fill: r.value.tooltipBg,
            rx: "8",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, rE),
          x("text", {
            x: "0",
            y: -a.value.height + 8,
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.title), 9, aE),
          x("text", {
            x: "0",
            y: -a.value.height + 26,
            "text-anchor": "middle",
            fill: r.value.tooltipTextSecondary,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.text), 9, sE)
        ], 8, nE)) : Q("", !0),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, oE),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, lE),
        (A(!0), I(Rt, null, ce(h.value, (v, m) => (A(), I("line", {
          key: `grid-${m}`,
          x1: e.chartMargin,
          y1: v.y,
          x2: e.chartWidth - e.chartMargin,
          y2: v.y,
          stroke: r.value.gridLine,
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, uE))), 128)),
        (A(!0), I(Rt, null, ce(h.value, (v, m) => (A(), I(Rt, { key: m }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: v.y,
            x2: e.chartMargin,
            y2: v.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, cE),
          x("text", {
            x: e.chartMargin - 12,
            y: v.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, R(v.value), 9, hE)
        ], 64))), 128)),
        x("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, R(s(e.yAxisLabel)), 9, dE),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, fE),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, vE),
        (A(!0), I(Rt, null, ce(e.candlestickData, (v, m) => (A(), I(Rt, { key: m }, [
          x("g", {
            transform: `translate(${v.centerX}, 0)`
          }, [
            x("line", {
              x1: 0,
              y1: v.highY,
              x2: 0,
              y2: v.lowY,
              stroke: v.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              class: "hover-line",
              onMouseenter: (p) => o(p, v, "wick"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, gE),
            x("rect", {
              x: -e.candleWidth / 2,
              y: Math.min(v.q1Y, v.q3Y),
              width: e.candleWidth,
              height: Math.abs(v.q3Y - v.q1Y),
              fill: v.isTotal ? "rgba(139, 92, 246, 0.15)" : "rgba(198, 125, 255, 0.15)",
              stroke: v.isTotal ? "#8b5cf6" : "#C67DFF",
              "stroke-width": "2.5",
              rx: "4",
              class: "hover-rect",
              onMouseenter: (p) => o(p, v, "body"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, mE),
            v.medianY ? (A(), I("line", {
              key: 0,
              x1: -e.candleWidth / 2,
              y1: v.medianY,
              x2: e.candleWidth / 2,
              y2: v.medianY,
              stroke: "#8b5cf6",
              "stroke-width": "3",
              class: "hover-line",
              onMouseenter: (p) => o(p, v, "median"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, yE)) : Q("", !0),
            v.averageY ? (A(), I("line", {
              key: 1,
              x1: -e.candleWidth / 2,
              y1: v.averageY,
              x2: e.candleWidth / 2,
              y2: v.averageY,
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4",
              class: "hover-line",
              onMouseenter: (p) => o(p, v, "average"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, _E)) : Q("", !0),
            x("circle", {
              cx: 0,
              cy: v.lowY,
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => o(p, v, "min"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, bE),
            x("circle", {
              cx: 0,
              cy: v.highY,
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "2",
              class: "hover-circle",
              onMouseenter: (p) => o(p, v, "max"),
              onMouseleave: c,
              style: { cursor: "pointer" }
            }, null, 40, xE)
          ], 8, pE),
          x("text", {
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 22,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, R(s(v.label)), 9, wE),
          v.responseCount ? (A(), I("text", {
            key: 0,
            x: v.centerX,
            y: e.chartHeight - e.chartBottomMargin + 38,
            "text-anchor": "middle",
            fill: r.value.tickText,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, " n=" + R(v.responseCount), 9, SE)) : Q("", !0)
        ], 64))), 128)),
        e.showLegend ? (A(), I("g", {
          key: 1,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 35})`
        }, [
          x("g", kE, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#5d4b93",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, DE),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, TE)
          ]),
          x("g", CE, [
            f[0] || (f[0] = x("rect", {
              x: "-6",
              y: "-6",
              width: "12",
              height: "12",
              fill: "rgba(198, 125, 255, 0.15)",
              stroke: "#C67DFF",
              "stroke-width": "1.5",
              rx: "2"
            }, null, -1)),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, EE)
          ]),
          x("g", AE, [
            f[1] || (f[1] = x("rect", {
              x: "-6",
              y: "-6",
              width: "12",
              height: "12",
              fill: "rgba(198, 125, 255, 0.15)",
              stroke: "#C67DFF",
              "stroke-width": "1.5",
              rx: "2"
            }, null, -1)),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, PE)
          ]),
          x("g", LE, [
            x("circle", {
              cx: "0",
              cy: "0",
              r: "5",
              fill: "#C67DFF",
              stroke: r.value.dotStroke,
              "stroke-width": "1.5"
            }, null, 8, OE),
            x("text", {
              x: "10",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, IE)
          ]),
          x("g", RE, [
            f[2] || (f[2] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, NE)
          ]),
          x("g", FE, [
            f[3] || (f[3] = x("line", {
              x1: "0",
              y1: "0",
              x2: "14",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "18",
              y: "4",
              fill: r.value.legendText,
              "font-size": "12",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, BE)
          ])
        ], 8, ME)) : Q("", !0)
      ], 44, iE))
    ]));
  }
}), Zb = /* @__PURE__ */ te($E, [["__scopeId", "data-v-0ecc8ae0"]]), zE = { class: "chart-container" }, VE = ["viewBox"], HE = ["transform"], YE = ["x", "y", "width", "height", "fill", "stroke"], WE = ["y", "fill"], UE = ["y", "fill"], GE = ["x1", "y1", "x2", "y2", "stroke"], XE = ["x1", "y1", "x2", "y2", "stroke"], jE = ["points", "fill"], qE = ["x1", "y1", "x2", "y2", "stroke"], ZE = ["x", "y", "fill"], KE = ["x", "y", "fill", "transform"], QE = ["x1", "y1", "x2", "y2", "stroke"], JE = ["points", "fill"], tA = ["x1", "y1", "x2", "y2", "stroke"], eA = ["x", "y", "fill"], iA = ["x", "y", "fill"], nA = ["d"], rA = ["x", "y", "width", "height", "onMouseenter"], aA = ["x1", "y1", "x2", "y2"], sA = ["x", "y"], oA = ["x1", "y1", "x2", "y2"], lA = ["x", "y"], uA = ["x1", "y1", "x2", "y2"], cA = ["x", "y"], hA = ["x1", "y1", "x2", "y2"], dA = ["x", "y"], fA = ["x1", "y1", "x2", "y2"], vA = ["x", "y"], pA = ["x1", "y1", "x2", "y2"], gA = ["x", "y"], mA = ["transform"], yA = { transform: "translate(-220, 0)" }, _A = ["fill"], bA = { transform: "translate(-140, 0)" }, xA = ["fill"], wA = { transform: "translate(-80, 0)" }, SA = ["fill"], MA = { transform: "translate(-20, 0)" }, kA = ["fill"], DA = { transform: "translate(60, 0)" }, TA = ["fill"], CA = { transform: "translate(130, 0)" }, EA = ["fill"], AA = { transform: "translate(180, 0)" }, PA = ["fill"], LA = /* @__PURE__ */ le({
  __name: "HistogramChart",
  props: {
    histogram: { default: () => [] },
    minScore: { default: 0 },
    maxScore: { default: 0 },
    q1Score: { default: 0 },
    medianScore: { default: 0 },
    q3Score: { default: 0 },
    averageScore: { default: 0 },
    chartWidth: { default: 800 },
    chartHeight: { default: 450 },
    chartMargin: { default: 60 },
    chartBottomMargin: { default: 80 },
    showLegend: { type: Boolean, default: !0 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    const i = e, { isDark: n } = _e(ye(i, "theme")), r = q(() => ({
      // Tooltip
      tooltipBg: n.value ? "rgba(26, 26, 29, 0.98)" : "rgba(15, 23, 42, 0.95)",
      tooltipBorder: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
      tooltipText: n.value ? "#f8f9fa" : "#f1f5f9",
      tooltipTextSecondary: n.value ? "#d1d5db" : "#e2e8f0",
      // Axis
      axis: n.value ? "#9ca3af" : "#475569",
      // Grid
      gridLine: n.value ? "#374151" : "#e5e7eb",
      // Ticks
      tickLine: n.value ? "#4b5563" : "#cbd5e1",
      tickText: n.value ? "#9ca3af" : "#64748b",
      // Labels
      labelText: n.value ? "#d1d5db" : "#475569",
      legendText: n.value ? "#d1d5db" : "#475569"
    })), a = gi({
      visible: !1,
      x: 0,
      y: 0,
      title: "",
      text: "",
      width: 0,
      height: 0
    }), s = q(() => i.chartWidth - i.chartMargin * 2), o = q(() => i.chartHeight - i.chartMargin - i.chartBottomMargin), l = q(() => s.value / 10 * 0.6), u = q(() => !i.histogram || i.histogram.length === 0 ? 1 : Math.max(...i.histogram.map((F) => F.count || 0), 1) + 30), c = q(() => {
      if (!i.histogram || i.histogram.length === 0) return 1;
      const V = i.averageScore || 0;
      let F = 0, $ = 0;
      if (i.histogram.forEach((j) => {
        const it = j.count || 0;
        F += it;
        const st = j.score - V;
        $ += it * (st * st);
      }), F === 0) return 1;
      const Z = $ / F;
      return Math.sqrt(Z) || 1;
    }), h = (V, F, $) => {
      if ($ === 0) return 0;
      const Z = 1 / ($ * Math.sqrt(2 * Math.PI)), j = -0.5 * Math.pow((V - F) / $, 2);
      return Z * Math.exp(j);
    }, d = q(() => {
      if (!i.histogram || i.histogram.length === 0 || i.averageScore === 0 && c.value === 0) return null;
      const V = i.averageScore, F = c.value, $ = [], Z = 100, j = 1, it = 10, st = i.histogram.reduce((At, Ft) => At + (Ft.count || 0), 0);
      if (st === 0) return null;
      let wt = 0;
      for (let At = 0; At <= Z; At++) {
        const Ft = j + (it - j) * (At / Z), at = h(Ft, V, F);
        at > wt && (wt = at);
      }
      const me = o.value * 0.75 / wt * st * 6e-3, Ae = i.chartMargin;
      for (let At = 0; At <= Z; At++) {
        const Ft = j + (it - j) * (At / Z), ft = h(Ft, V, F) * me, Ni = v(Ft);
        if (Ni !== null) {
          let ue = i.chartHeight - i.chartBottomMargin - ft;
          ue = Math.max(ue, Ae), $.push(`${At === 0 ? "M" : "L"} ${Ni} ${ue}`);
        }
      }
      return $.join(" ");
    }), f = q(() => {
      if (!i.histogram || i.histogram.length === 0) return [];
      const V = s.value / 10;
      return i.histogram.map((F, $) => {
        const Z = i.chartMargin + ($ + 0.5) * V, j = F.count > 0 ? F.count / u.value * o.value : 0, it = i.chartHeight - i.chartBottomMargin - j;
        return {
          score: F.score,
          count: F.count,
          x: Z,
          y: it,
          height: j
        };
      });
    }), v = (V) => {
      if (V < 1 || V > 10) return null;
      const F = s.value / 10;
      return i.chartMargin + (V - 0.5) * F;
    }, m = q(() => v(i.minScore)), p = q(() => v(i.maxScore)), g = q(() => v(i.q1Score)), y = q(() => v(i.medianScore)), _ = q(() => v(i.q3Score)), b = q(() => v(i.averageScore)), w = q(() => i.minScore), S = q(() => i.maxScore), M = q(() => i.q1Score), k = q(() => i.medianScore), T = q(() => i.q3Score), D = q(() => i.averageScore), C = q(() => {
      const V = [], F = i.chartMargin - 8, $ = 18;
      g.value !== null && V.push({
        x: g.value,
        y: F,
        value: i.q1Score,
        label: `Q1: ${M.value.toFixed(1)}`,
        color: "#a855f7",
        id: "q1",
        width: 55
      }), y.value !== null && V.push({
        x: y.value,
        y: F - $,
        value: i.medianScore,
        label: `Median: ${k.value.toFixed(1)}`,
        color: "#8b5cf6",
        id: "median",
        width: 90
      }), b.value !== null && V.push({
        x: b.value,
        y: F - $,
        value: i.averageScore,
        label: `Avg: ${D.value.toFixed(1)}`,
        color: "#f97316",
        id: "avg",
        width: 65
      }), _.value !== null && V.push({
        x: _.value,
        y: F,
        value: i.q3Score,
        label: `Q3: ${T.value.toFixed(1)}`,
        color: "#7c3aed",
        id: "q3",
        width: 55
      }), V.sort((it, st) => (it.x || 0) - (st.x || 0));
      const Z = [[], [], []];
      V.forEach((it) => {
        if (it.x === null) return;
        let st = -1;
        for (let wt = 0; wt < Z.length; wt++) {
          let Tt = !1;
          for (const me of Z[wt]) {
            if (me.x === null) continue;
            const Ae = Math.abs(it.x - me.x), At = (it.width + me.width) / 2 + 10;
            if (Ae < At) {
              Tt = !0;
              break;
            }
          }
          if (!Tt) {
            st = wt;
            break;
          }
        }
        st === -1 && (st = Z.length - 1), it.y = F - st * $, Z[st].push(it);
      });
      const j = 15;
      return V.forEach((it) => {
        it.y < j && (it.y = j);
      }), V;
    }), P = (V) => C.value.find(($) => $.id === V)?.y || i.chartMargin - 10, L = q(() => {
      const V = [];
      for (let $ = 0; $ <= 5; $++) {
        const Z = Math.round(u.value / 5 * $), j = i.chartHeight - i.chartBottomMargin - $ / 5 * o.value;
        V.push({ value: Z, y: j });
      }
      return V;
    }), O = (V, F) => {
      const $ = V.currentTarget.closest("svg");
      if (!$) return;
      const Z = $.getBoundingClientRect(), j = $.createSVGPoint();
      j.x = V.clientX - Z.left, j.y = V.clientY - Z.top;
      const it = `Score: ${F.score}`, st = `Count: ${F.count}`, wt = 120, Tt = 48;
      a.value = {
        visible: !0,
        x: j.x,
        y: j.y - 20,
        title: it,
        text: st,
        width: wt,
        height: Tt
      };
    }, N = (V) => {
      if (a.value.visible) {
        const F = V.currentTarget, $ = F.getBoundingClientRect(), Z = F.createSVGPoint();
        Z.x = V.clientX - $.left, Z.y = V.clientY - $.top, a.value.x = Z.x, a.value.y = Z.y - 20;
      }
    }, B = () => {
      a.value.visible = !1;
    }, G = () => {
      a.value.visible = !1;
    };
    return t({ isDark: n }), (V, F) => (A(), I("div", zE, [
      (A(), I("svg", {
        viewBox: `0 0 ${e.chartWidth} ${e.chartHeight}`,
        class: "w-full histogram-svg",
        style: qr(`min-height: ${e.chartHeight}px;`),
        onMousemove: N,
        onMouseleave: B
      }, [
        a.value.visible ? (A(), I("g", {
          key: 0,
          transform: `translate(${a.value.x}, ${a.value.y})`
        }, [
          x("rect", {
            x: -a.value.width / 2,
            y: -a.value.height - 10,
            width: a.value.width,
            height: a.value.height,
            fill: r.value.tooltipBg,
            rx: "8",
            stroke: r.value.tooltipBorder,
            "stroke-width": "1"
          }, null, 8, YE),
          x("text", {
            x: "0",
            y: -a.value.height + 8,
            "text-anchor": "middle",
            fill: r.value.tooltipText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.title), 9, WE),
          x("text", {
            x: "0",
            y: -a.value.height + 26,
            "text-anchor": "middle",
            fill: r.value.tooltipTextSecondary,
            "font-size": "11",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif",
            "dominant-baseline": "hanging"
          }, R(a.value.text), 9, UE)
        ], 8, HE)) : Q("", !0),
        (A(!0), I(Rt, null, ce(L.value, ($, Z) => (A(), I("line", {
          key: `grid-${Z}`,
          x1: e.chartMargin,
          y1: $.y,
          x2: e.chartWidth - e.chartMargin,
          y2: $.y,
          stroke: r.value.gridLine,
          "stroke-width": "1",
          "stroke-dasharray": "4,4",
          opacity: "0.6"
        }, null, 8, GE))), 128)),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartMargin,
          x2: e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, XE),
        x("polygon", {
          points: `${e.chartMargin - 4},${e.chartMargin} ${e.chartMargin + 4},${e.chartMargin} ${e.chartMargin},${e.chartMargin - 10}`,
          fill: r.value.axis
        }, null, 8, jE),
        (A(!0), I(Rt, null, ce(L.value, ($, Z) => (A(), I(Rt, {
          key: `y-tick-${Z}`
        }, [
          x("line", {
            x1: e.chartMargin - 6,
            y1: $.y,
            x2: e.chartMargin,
            y2: $.y,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, qE),
          x("text", {
            x: e.chartMargin - 12,
            y: $.y + 4,
            "text-anchor": "end",
            fill: r.value.tickText,
            "font-size": "12",
            "font-weight": "500",
            "font-family": "'DM Sans', sans-serif"
          }, R($.value), 9, ZE)
        ], 64))), 128)),
        x("text", {
          x: e.chartMargin - 35,
          y: e.chartHeight / 2,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif",
          transform: `rotate(-90, ${e.chartMargin - 35}, ${e.chartHeight / 2})`
        }, " Count ", 8, KE),
        x("line", {
          x1: e.chartMargin,
          y1: e.chartHeight - e.chartBottomMargin,
          x2: e.chartWidth - e.chartMargin,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: r.value.axis,
          "stroke-width": "2"
        }, null, 8, QE),
        x("polygon", {
          points: `${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin - 4} ${e.chartWidth - e.chartMargin},${e.chartHeight - e.chartBottomMargin + 4} ${e.chartWidth - e.chartMargin + 10},${e.chartHeight - e.chartBottomMargin}`,
          fill: r.value.axis
        }, null, 8, JE),
        (A(!0), I(Rt, null, ce(f.value, ($, Z) => (A(), I(Rt, {
          key: `tick-${Z}`
        }, [
          x("line", {
            x1: $.x,
            y1: e.chartHeight - e.chartBottomMargin,
            x2: $.x,
            y2: e.chartHeight - e.chartBottomMargin + 5,
            stroke: r.value.tickLine,
            "stroke-width": "1"
          }, null, 8, tA),
          x("text", {
            x: $.x,
            y: e.chartHeight - e.chartBottomMargin + 20,
            "text-anchor": "middle",
            fill: r.value.labelText,
            "font-size": "13",
            "font-weight": "600",
            "font-family": "'DM Sans', sans-serif"
          }, R($.score), 9, eA)
        ], 64))), 128)),
        x("text", {
          x: e.chartWidth / 2,
          y: e.chartHeight - e.chartBottomMargin + 40,
          "text-anchor": "middle",
          fill: r.value.labelText,
          "font-size": "14",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Score ", 8, iA),
        d.value ? (A(), I("path", {
          key: 1,
          d: d.value,
          fill: "none",
          stroke: "#8b5cf6",
          "stroke-width": "2.5",
          opacity: "0.7",
          class: "gaussian-curve"
        }, null, 8, nA)) : Q("", !0),
        (A(!0), I(Rt, null, ce(f.value, ($, Z) => (A(), I("rect", {
          key: `bar-${Z}`,
          x: $.x - l.value / 2,
          y: $.y,
          width: l.value,
          height: $.height,
          fill: "rgba(198, 125, 255, 0.6)",
          stroke: "#C67DFF",
          "stroke-width": "2",
          rx: "4",
          class: "histogram-bar",
          onMouseenter: (j) => O(j, $),
          onMouseleave: G,
          style: { cursor: "pointer" }
        }, null, 40, rA))), 128)),
        m.value ? (A(), I("line", {
          key: 2,
          x1: m.value,
          y1: e.chartMargin,
          x2: m.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#5d4b93",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, aA)) : Q("", !0),
        m.value ? (A(), I("text", {
          key: 3,
          x: m.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#5d4b93",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Min: " + R(w.value.toFixed(1)), 9, sA)) : Q("", !0),
        g.value ? (A(), I("line", {
          key: 4,
          x1: g.value,
          y1: e.chartMargin,
          x2: g.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#a855f7",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, oA)) : Q("", !0),
        g.value ? (A(), I("text", {
          key: 5,
          x: g.value,
          y: P("q1"),
          "text-anchor": "middle",
          fill: "#a855f7",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q1: " + R(M.value.toFixed(1)), 9, lA)) : Q("", !0),
        y.value ? (A(), I("line", {
          key: 6,
          x1: y.value,
          y1: e.chartMargin,
          x2: y.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#8b5cf6",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, uA)) : Q("", !0),
        y.value ? (A(), I("text", {
          key: 7,
          x: y.value,
          y: P("median"),
          "text-anchor": "middle",
          fill: "#8b5cf6",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Median: " + R(k.value.toFixed(1)), 9, cA)) : Q("", !0),
        b.value ? (A(), I("line", {
          key: 8,
          x1: b.value,
          y1: e.chartMargin,
          x2: b.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#f97316",
          "stroke-width": "3",
          "stroke-dasharray": "6,4",
          opacity: "0.9"
        }, null, 8, hA)) : Q("", !0),
        b.value ? (A(), I("text", {
          key: 9,
          x: b.value,
          y: P("avg"),
          "text-anchor": "middle",
          fill: "#f97316",
          "font-size": "13",
          "font-weight": "700",
          "font-family": "'DM Sans', sans-serif"
        }, " Avg: " + R(D.value.toFixed(1)), 9, dA)) : Q("", !0),
        _.value ? (A(), I("line", {
          key: 10,
          x1: _.value,
          y1: e.chartMargin,
          x2: _.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#7c3aed",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, fA)) : Q("", !0),
        _.value ? (A(), I("text", {
          key: 11,
          x: _.value,
          y: P("q3"),
          "text-anchor": "middle",
          fill: "#7c3aed",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Q3: " + R(T.value.toFixed(1)), 9, vA)) : Q("", !0),
        p.value ? (A(), I("line", {
          key: 12,
          x1: p.value,
          y1: e.chartMargin,
          x2: p.value,
          y2: e.chartHeight - e.chartBottomMargin,
          stroke: "#C67DFF",
          "stroke-width": "2.5",
          "stroke-dasharray": "6,4",
          opacity: "0.8"
        }, null, 8, pA)) : Q("", !0),
        p.value ? (A(), I("text", {
          key: 13,
          x: p.value,
          y: e.chartHeight - e.chartBottomMargin + 60,
          "text-anchor": "middle",
          fill: "#C67DFF",
          "font-size": "12",
          "font-weight": "600",
          "font-family": "'DM Sans', sans-serif"
        }, " Max: " + R(S.value.toFixed(1)), 9, gA)) : Q("", !0),
        e.showLegend ? (A(), I("g", {
          key: 14,
          transform: `translate(${e.chartWidth / 2}, ${e.chartMargin - 50})`
        }, [
          x("g", yA, [
            F[0] || (F[0] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "2.5"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Gaussian ", 8, _A)
          ]),
          x("g", bA, [
            F[1] || (F[1] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#5d4b93",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Min ", 8, xA)
          ]),
          x("g", wA, [
            F[2] || (F[2] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#a855f7",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q1 ", 8, SA)
          ]),
          x("g", MA, [
            F[3] || (F[3] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#8b5cf6",
              "stroke-width": "3",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Median ", 8, kA)
          ]),
          x("g", DA, [
            F[4] || (F[4] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#f97316",
              "stroke-width": "3",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Avg ", 8, TA)
          ]),
          x("g", CA, [
            F[5] || (F[5] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#7c3aed",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Q3 ", 8, EA)
          ]),
          x("g", AA, [
            F[6] || (F[6] = x("line", {
              x1: "0",
              y1: "0",
              x2: "20",
              y2: "0",
              stroke: "#C67DFF",
              "stroke-width": "2.5",
              "stroke-dasharray": "6,4"
            }, null, -1)),
            x("text", {
              x: "24",
              y: "4",
              fill: r.value.legendText,
              "font-size": "11",
              "font-family": "'DM Sans', sans-serif",
              "font-weight": "500"
            }, " Max ", 8, PA)
          ])
        ], 8, mA)) : Q("", !0)
      ], 44, VE))
    ]));
  }
}), Kb = /* @__PURE__ */ te(LA, [["__scopeId", "data-v-e67a4773"]]);
var Ud = function(e, t) {
  return Ud = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, Ud(e, t);
};
function oe(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Ud(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
var OA = /* @__PURE__ */ (function() {
  function e() {
    this.firefox = !1, this.ie = !1, this.edge = !1, this.newEdge = !1, this.weChat = !1;
  }
  return e;
})(), IA = /* @__PURE__ */ (function() {
  function e() {
    this.browser = new OA(), this.node = !1, this.wxa = !1, this.worker = !1, this.svgSupported = !1, this.touchEventsSupported = !1, this.pointerEventsSupported = !1, this.domSupported = !1, this.transformSupported = !1, this.transform3dSupported = !1, this.hasGlobalWindow = typeof window < "u";
  }
  return e;
})(), ot = new IA();
typeof wx == "object" && typeof wx.getSystemInfoSync == "function" ? (ot.wxa = !0, ot.touchEventsSupported = !0) : typeof document > "u" && typeof self < "u" ? ot.worker = !0 : !ot.hasGlobalWindow || "Deno" in window || typeof navigator < "u" && typeof navigator.userAgent == "string" && navigator.userAgent.indexOf("Node.js") > -1 ? (ot.node = !0, ot.svgSupported = !0) : RA(navigator.userAgent, ot);
function RA(e, t) {
  var i = t.browser, n = e.match(/Firefox\/([\d.]+)/), r = e.match(/MSIE\s([\d.]+)/) || e.match(/Trident\/.+?rv:(([\d.]+))/), a = e.match(/Edge?\/([\d.]+)/), s = /micromessenger/i.test(e);
  n && (i.firefox = !0, i.version = n[1]), r && (i.ie = !0, i.version = r[1]), a && (i.edge = !0, i.version = a[1], i.newEdge = +a[1].split(".")[0] > 18), s && (i.weChat = !0), t.svgSupported = typeof SVGRect < "u", t.touchEventsSupported = "ontouchstart" in window && !i.ie && !i.edge, t.pointerEventsSupported = "onpointerdown" in window && (i.edge || i.ie && +i.version >= 11);
  var o = t.domSupported = typeof document < "u";
  if (o) {
    var l = document.documentElement.style;
    t.transform3dSupported = (i.ie && "transition" in l || i.edge || "WebKitCSSMatrix" in window && "m11" in new WebKitCSSMatrix() || "MozPerspective" in l) && !("OTransition" in l), t.transformSupported = t.transform3dSupported || i.ie && +i.version >= 9;
  }
}
var bv = 12, NA = "sans-serif", nr = bv + "px " + NA, FA = 20, BA = 100, $A = "007LLmW'55;N0500LLLLLLLLLL00NNNLzWW\\\\WQb\\0FWLg\\bWb\\WQ\\WrWWQ000CL5LLFLL0LL**F*gLLLL5F0LF\\FFF5.5N";
function zA(e) {
  var t = {};
  if (typeof JSON > "u")
    return t;
  for (var i = 0; i < e.length; i++) {
    var n = String.fromCharCode(i + 32), r = (e.charCodeAt(i) - FA) / BA;
    t[n] = r;
  }
  return t;
}
var VA = zA($A), Tn = {
  createCanvas: function() {
    return typeof document < "u" && document.createElement("canvas");
  },
  measureText: /* @__PURE__ */ (function() {
    var e, t;
    return function(i, n) {
      if (!e) {
        var r = Tn.createCanvas();
        e = r && r.getContext("2d");
      }
      if (e)
        return t !== n && (t = e.font = n || nr), e.measureText(i);
      i = i || "", n = n || nr;
      var a = /((?:\d+)?\.?\d*)px/.exec(n), s = a && +a[1] || bv, o = 0;
      if (n.indexOf("mono") >= 0)
        o = s * i.length;
      else
        for (var l = 0; l < i.length; l++) {
          var u = VA[i[l]];
          o += u == null ? s : u * s;
        }
      return { width: o };
    };
  })(),
  loadImage: function(e, t, i) {
    var n = new Image();
    return n.onload = t, n.onerror = i, n.src = e, n;
  }
}, Qb = ps([
  "Function",
  "RegExp",
  "Date",
  "Error",
  "CanvasGradient",
  "CanvasPattern",
  "Image",
  "Canvas"
], function(e, t) {
  return e["[object " + t + "]"] = !0, e;
}, {}), Jb = ps([
  "Int8",
  "Uint8",
  "Uint8Clamped",
  "Int16",
  "Uint16",
  "Int32",
  "Uint32",
  "Float32",
  "Float64"
], function(e, t) {
  return e["[object " + t + "Array]"] = !0, e;
}, {}), vs = Object.prototype.toString, Mc = Array.prototype, HA = Mc.forEach, YA = Mc.filter, xv = Mc.slice, WA = Mc.map, mm = (function() {
}).constructor, ml = mm ? mm.prototype : null, wv = "__proto__", UA = 2311;
function t1() {
  return UA++;
}
function Kr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  typeof console < "u" && console.error.apply(console, e);
}
function pt(e) {
  if (e == null || typeof e != "object")
    return e;
  var t = e, i = vs.call(e);
  if (i === "[object Array]") {
    if (!fo(e)) {
      t = [];
      for (var n = 0, r = e.length; n < r; n++)
        t[n] = pt(e[n]);
    }
  } else if (Jb[i]) {
    if (!fo(e)) {
      var a = e.constructor;
      if (a.from)
        t = a.from(e);
      else {
        t = new a(e.length);
        for (var n = 0, r = e.length; n < r; n++)
          t[n] = e[n];
      }
    }
  } else if (!Qb[i] && !fo(e) && !ss(e)) {
    t = {};
    for (var s in e)
      e.hasOwnProperty(s) && s !== wv && (t[s] = pt(e[s]));
  }
  return t;
}
function se(e, t, i) {
  if (!tt(t) || !tt(e))
    return i ? pt(t) : e;
  for (var n in t)
    if (t.hasOwnProperty(n) && n !== wv) {
      var r = e[n], a = t[n];
      tt(a) && tt(r) && !K(a) && !K(r) && !ss(a) && !ss(r) && !ym(a) && !ym(r) && !fo(a) && !fo(r) ? se(r, a, i) : (i || !(n in e)) && (e[n] = pt(t[n]));
    }
  return e;
}
function Y(e, t) {
  if (Object.assign)
    Object.assign(e, t);
  else
    for (var i in t)
      t.hasOwnProperty(i) && i !== wv && (e[i] = t[i]);
  return e;
}
function Jt(e, t, i) {
  for (var n = qt(t), r = 0, a = n.length; r < a; r++) {
    var s = n[r];
    e[s] == null && (e[s] = t[s]);
  }
  return e;
}
function Ht(e, t) {
  if (e) {
    if (e.indexOf)
      return e.indexOf(t);
    for (var i = 0, n = e.length; i < n; i++)
      if (e[i] === t)
        return i;
  }
  return -1;
}
function GA(e, t) {
  var i = e.prototype;
  function n() {
  }
  n.prototype = t.prototype, e.prototype = new n();
  for (var r in i)
    i.hasOwnProperty(r) && (e.prototype[r] = i[r]);
  e.prototype.constructor = e, e.superClass = t;
}
function Pi(e, t, i) {
  if (e = "prototype" in e ? e.prototype : e, t = "prototype" in t ? t.prototype : t, Object.getOwnPropertyNames)
    for (var n = Object.getOwnPropertyNames(t), r = 0; r < n.length; r++) {
      var a = n[r];
      a !== "constructor" && e[a] == null && (e[a] = t[a]);
    }
  else
    Jt(e, t);
}
function Xe(e) {
  return !e || typeof e == "string" ? !1 : typeof e.length == "number";
}
function E(e, t, i) {
  if (e && t)
    if (e.forEach && e.forEach === HA)
      e.forEach(t, i);
    else if (e.length === +e.length)
      for (var n = 0, r = e.length; n < r; n++)
        t.call(i, e[n], n, e);
    else
      for (var a in e)
        e.hasOwnProperty(a) && t.call(i, e[a], a, e);
}
function _t(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return Sv(e);
  if (e.map && e.map === WA)
    return e.map(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    n.push(t.call(i, e[r], r, e));
  return n;
}
function ps(e, t, i, n) {
  if (e && t) {
    for (var r = 0, a = e.length; r < a; r++)
      i = t.call(n, i, e[r], r, e);
    return i;
  }
}
function Ke(e, t, i) {
  if (!e)
    return [];
  if (!t)
    return Sv(e);
  if (e.filter && e.filter === YA)
    return e.filter(t, i);
  for (var n = [], r = 0, a = e.length; r < a; r++)
    t.call(i, e[r], r, e) && n.push(e[r]);
  return n;
}
function qt(e) {
  if (!e)
    return [];
  if (Object.keys)
    return Object.keys(e);
  var t = [];
  for (var i in e)
    e.hasOwnProperty(i) && t.push(i);
  return t;
}
function XA(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return function() {
    return e.apply(t, i.concat(xv.call(arguments)));
  };
}
var Dt = ml && mt(ml.bind) ? ml.call.bind(ml.bind) : XA;
function Oe(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return function() {
    return e.apply(this, t.concat(xv.call(arguments)));
  };
}
function K(e) {
  return Array.isArray ? Array.isArray(e) : vs.call(e) === "[object Array]";
}
function mt(e) {
  return typeof e == "function";
}
function et(e) {
  return typeof e == "string";
}
function Tu(e) {
  return vs.call(e) === "[object String]";
}
function Zt(e) {
  return typeof e == "number";
}
function tt(e) {
  var t = typeof e;
  return t === "function" || !!e && t === "object";
}
function ym(e) {
  return !!Qb[vs.call(e)];
}
function Ne(e) {
  return !!Jb[vs.call(e)];
}
function ss(e) {
  return typeof e == "object" && typeof e.nodeType == "number" && typeof e.ownerDocument == "object";
}
function kc(e) {
  return e.colorStops != null;
}
function jA(e) {
  return e.image != null;
}
function qA(e) {
  return vs.call(e) === "[object RegExp]";
}
function e1(e) {
  return e !== e;
}
function rr() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  for (var i = 0, n = e.length; i < n; i++)
    if (e[i] != null)
      return e[i];
}
function rt(e, t) {
  return e ?? t;
}
function Qr(e, t, i) {
  return e ?? t ?? i;
}
function Sv(e) {
  for (var t = [], i = 1; i < arguments.length; i++)
    t[i - 1] = arguments[i];
  return xv.apply(e, t);
}
function Mv(e) {
  if (typeof e == "number")
    return [e, e, e, e];
  var t = e.length;
  return t === 2 ? [e[0], e[1], e[0], e[1]] : t === 3 ? [e[0], e[1], e[2], e[1]] : e;
}
function nt(e, t) {
  if (!e)
    throw new Error(t);
}
function Xi(e) {
  return e == null ? null : typeof e.trim == "function" ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
}
var i1 = "__ec_primitive__";
function Gd(e) {
  e[i1] = !0;
}
function fo(e) {
  return e[i1];
}
var ZA = (function() {
  function e() {
    this.data = {};
  }
  return e.prototype.delete = function(t) {
    var i = this.has(t);
    return i && delete this.data[t], i;
  }, e.prototype.has = function(t) {
    return this.data.hasOwnProperty(t);
  }, e.prototype.get = function(t) {
    return this.data[t];
  }, e.prototype.set = function(t, i) {
    return this.data[t] = i, this;
  }, e.prototype.keys = function() {
    return qt(this.data);
  }, e.prototype.forEach = function(t) {
    var i = this.data;
    for (var n in i)
      i.hasOwnProperty(n) && t(i[n], n);
  }, e;
})(), n1 = typeof Map == "function";
function KA() {
  return n1 ? /* @__PURE__ */ new Map() : new ZA();
}
var QA = (function() {
  function e(t) {
    var i = K(t);
    this.data = KA();
    var n = this;
    t instanceof e ? t.each(r) : t && E(t, r);
    function r(a, s) {
      i ? n.set(a, s) : n.set(s, a);
    }
  }
  return e.prototype.hasKey = function(t) {
    return this.data.has(t);
  }, e.prototype.get = function(t) {
    return this.data.get(t);
  }, e.prototype.set = function(t, i) {
    return this.data.set(t, i), i;
  }, e.prototype.each = function(t, i) {
    this.data.forEach(function(n, r) {
      t.call(i, n, r);
    });
  }, e.prototype.keys = function() {
    var t = this.data.keys();
    return n1 ? Array.from(t) : t;
  }, e.prototype.removeKey = function(t) {
    this.data.delete(t);
  }, e;
})();
function ht(e) {
  return new QA(e);
}
function JA(e, t) {
  for (var i = new e.constructor(e.length + t.length), n = 0; n < e.length; n++)
    i[n] = e[n];
  for (var r = e.length, n = 0; n < t.length; n++)
    i[n + r] = t[n];
  return i;
}
function Dc(e, t) {
  var i;
  if (Object.create)
    i = Object.create(e);
  else {
    var n = function() {
    };
    n.prototype = e, i = new n();
  }
  return t && Y(i, t), i;
}
function r1(e) {
  var t = e.style;
  t.webkitUserSelect = "none", t.userSelect = "none", t.webkitTapHighlightColor = "rgba(0,0,0,0)", t["-webkit-touch-callout"] = "none";
}
function Zi(e, t) {
  return e.hasOwnProperty(t);
}
function ke() {
}
var tP = 180 / Math.PI;
var Xd = function(e, t) {
  return Xd = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(i, n) {
    i.__proto__ = n;
  } || function(i, n) {
    for (var r in n) Object.prototype.hasOwnProperty.call(n, r) && (i[r] = n[r]);
  }, Xd(e, t);
};
function Lt(e, t) {
  if (typeof t != "function" && t !== null)
    throw new TypeError("Class extends value " + String(t) + " is not a constructor or null");
  Xd(e, t);
  function i() {
    this.constructor = e;
  }
  e.prototype = t === null ? Object.create(t) : (i.prototype = t.prototype, new i());
}
function gs(e, t) {
  return e == null && (e = 0), t == null && (t = 0), [e, t];
}
function eP(e, t) {
  return e[0] = t[0], e[1] = t[1], e;
}
function iP(e) {
  return [e[0], e[1]];
}
function _m(e, t, i) {
  return e[0] = t[0] + i[0], e[1] = t[1] + i[1], e;
}
function nP(e, t, i) {
  return e[0] = t[0] - i[0], e[1] = t[1] - i[1], e;
}
function rP(e) {
  return Math.sqrt(aP(e));
}
function aP(e) {
  return e[0] * e[0] + e[1] * e[1];
}
function vh(e, t, i) {
  return e[0] = t[0] * i, e[1] = t[1] * i, e;
}
function sP(e, t) {
  var i = rP(t);
  return i === 0 ? (e[0] = 0, e[1] = 0) : (e[0] = t[0] / i, e[1] = t[1] / i), e;
}
function jd(e, t) {
  return Math.sqrt((e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]));
}
var oP = jd;
function lP(e, t) {
  return (e[0] - t[0]) * (e[0] - t[0]) + (e[1] - t[1]) * (e[1] - t[1]);
}
var Za = lP;
function Je(e, t, i) {
  var n = t[0], r = t[1];
  return e[0] = i[0] * n + i[2] * r + i[4], e[1] = i[1] * n + i[3] * r + i[5], e;
}
function Va(e, t, i) {
  return e[0] = Math.min(t[0], i[0]), e[1] = Math.min(t[1], i[1]), e;
}
function Ha(e, t, i) {
  return e[0] = Math.max(t[0], i[0]), e[1] = Math.max(t[1], i[1]), e;
}
var ba = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.target = t, this.topTarget = i && i.topTarget;
  }
  return e;
})(), uP = (function() {
  function e(t) {
    this.handler = t, t.on("mousedown", this._dragStart, this), t.on("mousemove", this._drag, this), t.on("mouseup", this._dragEnd, this);
  }
  return e.prototype._dragStart = function(t) {
    for (var i = t.target; i && !i.draggable; )
      i = i.parent || i.__hostTarget;
    i && (this._draggingTarget = i, i.dragging = !0, this._x = t.offsetX, this._y = t.offsetY, this.handler.dispatchToElement(new ba(i, t), "dragstart", t.event));
  }, e.prototype._drag = function(t) {
    var i = this._draggingTarget;
    if (i) {
      var n = t.offsetX, r = t.offsetY, a = n - this._x, s = r - this._y;
      this._x = n, this._y = r, i.drift(a, s, t), this.handler.dispatchToElement(new ba(i, t), "drag", t.event);
      var o = this.handler.findHover(n, r, i).target, l = this._dropTarget;
      this._dropTarget = o, i !== o && (l && o !== l && this.handler.dispatchToElement(new ba(l, t), "dragleave", t.event), o && o !== l && this.handler.dispatchToElement(new ba(o, t), "dragenter", t.event));
    }
  }, e.prototype._dragEnd = function(t) {
    var i = this._draggingTarget;
    i && (i.dragging = !1), this.handler.dispatchToElement(new ba(i, t), "dragend", t.event), this._dropTarget && this.handler.dispatchToElement(new ba(this._dropTarget, t), "drop", t.event), this._draggingTarget = null, this._dropTarget = null;
  }, e;
})(), Li = (function() {
  function e(t) {
    t && (this._$eventProcessor = t);
  }
  return e.prototype.on = function(t, i, n, r) {
    this._$handlers || (this._$handlers = {});
    var a = this._$handlers;
    if (typeof i == "function" && (r = n, n = i, i = null), !n || !t)
      return this;
    var s = this._$eventProcessor;
    i != null && s && s.normalizeQuery && (i = s.normalizeQuery(i)), a[t] || (a[t] = []);
    for (var o = 0; o < a[t].length; o++)
      if (a[t][o].h === n)
        return this;
    var l = {
      h: n,
      query: i,
      ctx: r || this,
      callAtLast: n.zrEventfulCallAtLast
    }, u = a[t].length - 1, c = a[t][u];
    return c && c.callAtLast ? a[t].splice(u, 0, l) : a[t].push(l), this;
  }, e.prototype.isSilent = function(t) {
    var i = this._$handlers;
    return !i || !i[t] || !i[t].length;
  }, e.prototype.off = function(t, i) {
    var n = this._$handlers;
    if (!n)
      return this;
    if (!t)
      return this._$handlers = {}, this;
    if (i) {
      if (n[t]) {
        for (var r = [], a = 0, s = n[t].length; a < s; a++)
          n[t][a].h !== i && r.push(n[t][a]);
        n[t] = r;
      }
      n[t] && n[t].length === 0 && delete n[t];
    } else
      delete n[t];
    return this;
  }, e.prototype.trigger = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var s = i.length, o = r.length, l = 0; l < o; l++) {
        var u = r[l];
        if (!(a && a.filter && u.query != null && !a.filter(t, u.query)))
          switch (s) {
            case 0:
              u.h.call(u.ctx);
              break;
            case 1:
              u.h.call(u.ctx, i[0]);
              break;
            case 2:
              u.h.call(u.ctx, i[0], i[1]);
              break;
            default:
              u.h.apply(u.ctx, i);
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e.prototype.triggerWithContext = function(t) {
    for (var i = [], n = 1; n < arguments.length; n++)
      i[n - 1] = arguments[n];
    if (!this._$handlers)
      return this;
    var r = this._$handlers[t], a = this._$eventProcessor;
    if (r)
      for (var s = i.length, o = i[s - 1], l = r.length, u = 0; u < l; u++) {
        var c = r[u];
        if (!(a && a.filter && c.query != null && !a.filter(t, c.query)))
          switch (s) {
            case 0:
              c.h.call(o);
              break;
            case 1:
              c.h.call(o, i[0]);
              break;
            case 2:
              c.h.call(o, i[0], i[1]);
              break;
            default:
              c.h.apply(o, i.slice(1, s - 1));
              break;
          }
      }
    return a && a.afterTrigger && a.afterTrigger(t), this;
  }, e;
})(), cP = Math.log(2);
function qd(e, t, i, n, r, a) {
  var s = n + "-" + r, o = e.length;
  if (a.hasOwnProperty(s))
    return a[s];
  if (t === 1) {
    var l = Math.round(Math.log((1 << o) - 1 & ~r) / cP);
    return e[i][l];
  }
  for (var u = n | 1 << i, c = i + 1; n & 1 << c; )
    c++;
  for (var h = 0, d = 0, f = 0; d < o; d++) {
    var v = 1 << d;
    v & r || (h += (f % 2 ? -1 : 1) * e[i][d] * qd(e, t - 1, c, u, r | v, a), f++);
  }
  return a[s] = h, h;
}
function bm(e, t) {
  var i = [
    [e[0], e[1], 1, 0, 0, 0, -t[0] * e[0], -t[0] * e[1]],
    [0, 0, 0, e[0], e[1], 1, -t[1] * e[0], -t[1] * e[1]],
    [e[2], e[3], 1, 0, 0, 0, -t[2] * e[2], -t[2] * e[3]],
    [0, 0, 0, e[2], e[3], 1, -t[3] * e[2], -t[3] * e[3]],
    [e[4], e[5], 1, 0, 0, 0, -t[4] * e[4], -t[4] * e[5]],
    [0, 0, 0, e[4], e[5], 1, -t[5] * e[4], -t[5] * e[5]],
    [e[6], e[7], 1, 0, 0, 0, -t[6] * e[6], -t[6] * e[7]],
    [0, 0, 0, e[6], e[7], 1, -t[7] * e[6], -t[7] * e[7]]
  ], n = {}, r = qd(i, 8, 0, 0, 0, n);
  if (r !== 0) {
    for (var a = [], s = 0; s < 8; s++)
      for (var o = 0; o < 8; o++)
        a[o] == null && (a[o] = 0), a[o] += ((s + o) % 2 ? -1 : 1) * qd(i, 7, s === 0 ? 1 : 0, 1 << s, 1 << o, n) / r * t[s];
    return function(l, u, c) {
      var h = u * a[6] + c * a[7] + 1;
      l[0] = (u * a[0] + c * a[1] + a[2]) / h, l[1] = (u * a[3] + c * a[4] + a[5]) / h;
    };
  }
}
var Cu = "___zrEVENTSAVED", ph = [];
function hP(e, t, i, n, r) {
  return Zd(ph, t, n, r, !0) && Zd(e, i, ph[0], ph[1]);
}
function dP(e, t) {
  e && i(e), t && i(t);
  function i(n) {
    var r = n[Cu];
    r && (r.clearMarkers && r.clearMarkers(), delete n[Cu]);
  }
}
function Zd(e, t, i, n, r) {
  if (t.getBoundingClientRect && ot.domSupported && !a1(t)) {
    var a = t[Cu] || (t[Cu] = {}), s = fP(t, a), o = vP(s, a, r);
    if (o)
      return o(e, i, n), !0;
  }
  return !1;
}
function fP(e, t) {
  var i = t.markers;
  if (i)
    return i;
  i = t.markers = [];
  for (var n = ["left", "right"], r = ["top", "bottom"], a = 0; a < 4; a++) {
    var s = document.createElement("div"), o = s.style, l = a % 2, u = (a >> 1) % 2;
    o.cssText = [
      "position: absolute",
      "visibility: hidden",
      "padding: 0",
      "margin: 0",
      "border-width: 0",
      "user-select: none",
      "width:0",
      "height:0",
      n[l] + ":0",
      r[u] + ":0",
      n[1 - l] + ":auto",
      r[1 - u] + ":auto",
      ""
    ].join("!important;"), e.appendChild(s), i.push(s);
  }
  return t.clearMarkers = function() {
    E(i, function(c) {
      c.parentNode && c.parentNode.removeChild(c);
    });
  }, i;
}
function vP(e, t, i) {
  for (var n = i ? "invTrans" : "trans", r = t[n], a = t.srcCoords, s = [], o = [], l = !0, u = 0; u < 4; u++) {
    var c = e[u].getBoundingClientRect(), h = 2 * u, d = c.left, f = c.top;
    s.push(d, f), l = l && a && d === a[h] && f === a[h + 1], o.push(e[u].offsetLeft, e[u].offsetTop);
  }
  return l && r ? r : (t.srcCoords = s, t[n] = i ? bm(o, s) : bm(s, o));
}
function a1(e) {
  return e.nodeName.toUpperCase() === "CANVAS";
}
var pP = /([&<>"'])/g, gP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function Ve(e) {
  return e == null ? "" : (e + "").replace(pP, function(t, i) {
    return gP[i];
  });
}
var mP = /^(?:mouse|pointer|contextmenu|drag|drop)|click/, gh = [], yP = ot.browser.firefox && +ot.browser.version.split(".")[0] < 39;
function Kd(e, t, i, n) {
  return i = i || {}, n ? xm(e, t, i) : yP && t.layerX != null && t.layerX !== t.offsetX ? (i.zrX = t.layerX, i.zrY = t.layerY) : t.offsetX != null ? (i.zrX = t.offsetX, i.zrY = t.offsetY) : xm(e, t, i), i;
}
function xm(e, t, i) {
  if (ot.domSupported && e.getBoundingClientRect) {
    var n = t.clientX, r = t.clientY;
    if (a1(e)) {
      var a = e.getBoundingClientRect();
      i.zrX = n - a.left, i.zrY = r - a.top;
      return;
    } else if (Zd(gh, e, n, r)) {
      i.zrX = gh[0], i.zrY = gh[1];
      return;
    }
  }
  i.zrX = i.zrY = 0;
}
function kv(e) {
  return e || window.event;
}
function oi(e, t, i) {
  if (t = kv(t), t.zrX != null)
    return t;
  var n = t.type, r = n && n.indexOf("touch") >= 0;
  if (r) {
    var s = n !== "touchend" ? t.targetTouches[0] : t.changedTouches[0];
    s && Kd(e, s, t, i);
  } else {
    Kd(e, t, t, i);
    var a = _P(t);
    t.zrDelta = a ? a / 120 : -(t.detail || 0) / 3;
  }
  var o = t.button;
  return t.which == null && o !== void 0 && mP.test(t.type) && (t.which = o & 1 ? 1 : o & 2 ? 3 : o & 4 ? 2 : 0), t;
}
function _P(e) {
  var t = e.wheelDelta;
  if (t)
    return t;
  var i = e.deltaX, n = e.deltaY;
  if (i == null || n == null)
    return t;
  var r = Math.abs(n !== 0 ? n : i), a = n > 0 ? -1 : n < 0 ? 1 : i > 0 ? -1 : 1;
  return 3 * r * a;
}
function bP(e, t, i, n) {
  e.addEventListener(t, i, n);
}
function xP(e, t, i, n) {
  e.removeEventListener(t, i, n);
}
var Eu = function(e) {
  e.preventDefault(), e.stopPropagation(), e.cancelBubble = !0;
};
function wm(e) {
  return e.which === 2 || e.which === 3;
}
var wP = (function() {
  function e() {
    this._track = [];
  }
  return e.prototype.recognize = function(t, i, n) {
    return this._doTrack(t, i, n), this._recognize(t);
  }, e.prototype.clear = function() {
    return this._track.length = 0, this;
  }, e.prototype._doTrack = function(t, i, n) {
    var r = t.touches;
    if (r) {
      for (var a = {
        points: [],
        touches: [],
        target: i,
        event: t
      }, s = 0, o = r.length; s < o; s++) {
        var l = r[s], u = Kd(n, l, {});
        a.points.push([u.zrX, u.zrY]), a.touches.push(l);
      }
      this._track.push(a);
    }
  }, e.prototype._recognize = function(t) {
    for (var i in mh)
      if (mh.hasOwnProperty(i)) {
        var n = mh[i](this._track, t);
        if (n)
          return n;
      }
  }, e;
})();
function Sm(e) {
  var t = e[1][0] - e[0][0], i = e[1][1] - e[0][1];
  return Math.sqrt(t * t + i * i);
}
function SP(e) {
  return [
    (e[0][0] + e[1][0]) / 2,
    (e[0][1] + e[1][1]) / 2
  ];
}
var mh = {
  pinch: function(e, t) {
    var i = e.length;
    if (i) {
      var n = (e[i - 1] || {}).points, r = (e[i - 2] || {}).points || n;
      if (r && r.length > 1 && n && n.length > 1) {
        var a = Sm(n) / Sm(r);
        !isFinite(a) && (a = 1), t.pinchScale = a;
        var s = SP(n);
        return t.pinchX = s[0], t.pinchY = s[1], {
          type: "pinch",
          target: e[0].target,
          event: t
        };
      }
    }
  }
};
function Ki() {
  return [1, 0, 0, 1, 0, 0];
}
function Dv(e) {
  return e[0] = 1, e[1] = 0, e[2] = 0, e[3] = 1, e[4] = 0, e[5] = 0, e;
}
function Tv(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4], e[5] = t[5], e;
}
function vo(e, t, i) {
  var n = t[0] * i[0] + t[2] * i[1], r = t[1] * i[0] + t[3] * i[1], a = t[0] * i[2] + t[2] * i[3], s = t[1] * i[2] + t[3] * i[3], o = t[0] * i[4] + t[2] * i[5] + t[4], l = t[1] * i[4] + t[3] * i[5] + t[5];
  return e[0] = n, e[1] = r, e[2] = a, e[3] = s, e[4] = o, e[5] = l, e;
}
function Qd(e, t, i) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e[4] = t[4] + i[0], e[5] = t[5] + i[1], e;
}
function Cv(e, t, i, n) {
  n === void 0 && (n = [0, 0]);
  var r = t[0], a = t[2], s = t[4], o = t[1], l = t[3], u = t[5], c = Math.sin(i), h = Math.cos(i);
  return e[0] = r * h + o * c, e[1] = -r * c + o * h, e[2] = a * h + l * c, e[3] = -a * c + h * l, e[4] = h * (s - n[0]) + c * (u - n[1]) + n[0], e[5] = h * (u - n[1]) - c * (s - n[0]) + n[1], e;
}
function MP(e, t, i) {
  var n = i[0], r = i[1];
  return e[0] = t[0] * n, e[1] = t[1] * r, e[2] = t[2] * n, e[3] = t[3] * r, e[4] = t[4] * n, e[5] = t[5] * r, e;
}
function qo(e, t) {
  var i = t[0], n = t[2], r = t[4], a = t[1], s = t[3], o = t[5], l = i * s - a * n;
  return l ? (l = 1 / l, e[0] = s * l, e[1] = -a * l, e[2] = -n * l, e[3] = i * l, e[4] = (n * o - s * r) * l, e[5] = (a * r - i * o) * l, e) : null;
}
var It = (function() {
  function e(t, i) {
    this.x = t || 0, this.y = i || 0;
  }
  return e.prototype.copy = function(t) {
    return this.x = t.x, this.y = t.y, this;
  }, e.prototype.clone = function() {
    return new e(this.x, this.y);
  }, e.prototype.set = function(t, i) {
    return this.x = t, this.y = i, this;
  }, e.prototype.equal = function(t) {
    return t.x === this.x && t.y === this.y;
  }, e.prototype.add = function(t) {
    return this.x += t.x, this.y += t.y, this;
  }, e.prototype.scale = function(t) {
    this.x *= t, this.y *= t;
  }, e.prototype.scaleAndAdd = function(t, i) {
    this.x += t.x * i, this.y += t.y * i;
  }, e.prototype.sub = function(t) {
    return this.x -= t.x, this.y -= t.y, this;
  }, e.prototype.dot = function(t) {
    return this.x * t.x + this.y * t.y;
  }, e.prototype.len = function() {
    return Math.sqrt(this.x * this.x + this.y * this.y);
  }, e.prototype.lenSquare = function() {
    return this.x * this.x + this.y * this.y;
  }, e.prototype.normalize = function() {
    var t = this.len();
    return this.x /= t, this.y /= t, this;
  }, e.prototype.distance = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return Math.sqrt(i * i + n * n);
  }, e.prototype.distanceSquare = function(t) {
    var i = this.x - t.x, n = this.y - t.y;
    return i * i + n * n;
  }, e.prototype.negate = function() {
    return this.x = -this.x, this.y = -this.y, this;
  }, e.prototype.transform = function(t) {
    if (t) {
      var i = this.x, n = this.y;
      return this.x = t[0] * i + t[2] * n + t[4], this.y = t[1] * i + t[3] * n + t[5], this;
    }
  }, e.prototype.toArray = function(t) {
    return t[0] = this.x, t[1] = this.y, t;
  }, e.prototype.fromArray = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.set = function(t, i, n) {
    t.x = i, t.y = n;
  }, e.copy = function(t, i) {
    t.x = i.x, t.y = i.y;
  }, e.len = function(t) {
    return Math.sqrt(t.x * t.x + t.y * t.y);
  }, e.lenSquare = function(t) {
    return t.x * t.x + t.y * t.y;
  }, e.dot = function(t, i) {
    return t.x * i.x + t.y * i.y;
  }, e.add = function(t, i, n) {
    t.x = i.x + n.x, t.y = i.y + n.y;
  }, e.sub = function(t, i, n) {
    t.x = i.x - n.x, t.y = i.y - n.y;
  }, e.scale = function(t, i, n) {
    t.x = i.x * n, t.y = i.y * n;
  }, e.scaleAndAdd = function(t, i, n, r) {
    t.x = i.x + n.x * r, t.y = i.y + n.y * r;
  }, e.lerp = function(t, i, n, r) {
    var a = 1 - r;
    t.x = a * i.x + r * n.x, t.y = a * i.y + r * n.y;
  }, e;
})(), Yr = Math.min, Ya = Math.max, Jd = Math.abs, Mm = ["x", "y"], kP = ["width", "height"], dr = new It(), fr = new It(), vr = new It(), pr = new It(), Ze = s1(), Js = Ze.minTv, tf = Ze.maxTv, po = [0, 0], lt = (function() {
  function e(t, i, n, r) {
    e.set(this, t, i, n, r);
  }
  return e.set = function(t, i, n, r, a) {
    return r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), t.x = i, t.y = n, t.width = r, t.height = a, t;
  }, e.prototype.union = function(t) {
    var i = Yr(t.x, this.x), n = Yr(t.y, this.y);
    isFinite(this.x) && isFinite(this.width) ? this.width = Ya(t.x + t.width, this.x + this.width) - i : this.width = t.width, isFinite(this.y) && isFinite(this.height) ? this.height = Ya(t.y + t.height, this.y + this.height) - n : this.height = t.height, this.x = i, this.y = n;
  }, e.prototype.applyTransform = function(t) {
    e.applyTransform(this, this, t);
  }, e.prototype.calculateTransform = function(t) {
    var i = this, n = t.width / i.width, r = t.height / i.height, a = Ki();
    return Qd(a, a, [-i.x, -i.y]), MP(a, a, [n, r]), Qd(a, a, [t.x, t.y]), a;
  }, e.prototype.intersect = function(t, i, n) {
    return e.intersect(this, t, i, n);
  }, e.intersect = function(t, i, n, r) {
    n && It.set(n, 0, 0);
    var a = r && r.outIntersectRect || null, s = r && r.clamp;
    if (a && (a.x = a.y = a.width = a.height = NaN), !t || !i)
      return !1;
    t instanceof e || (t = e.set(DP, t.x, t.y, t.width, t.height)), i instanceof e || (i = e.set(TP, i.x, i.y, i.width, i.height));
    var o = !!n;
    Ze.reset(r, o);
    var l = Ze.touchThreshold, u = t.x + l, c = t.x + t.width - l, h = t.y + l, d = t.y + t.height - l, f = i.x + l, v = i.x + i.width - l, m = i.y + l, p = i.y + i.height - l;
    if (u > c || h > d || f > v || m > p)
      return !1;
    var g = !(c < f || v < u || d < m || p < h);
    return (o || a) && (po[0] = 1 / 0, po[1] = 0, km(u, c, f, v, 0, o, a, s), km(h, d, m, p, 1, o, a, s), o && It.copy(n, g ? Ze.useDir ? Ze.dirMinTv : Js : tf)), g;
  }, e.contain = function(t, i, n) {
    return i >= t.x && i <= t.x + t.width && n >= t.y && n <= t.y + t.height;
  }, e.prototype.contain = function(t, i) {
    return e.contain(this, t, i);
  }, e.prototype.clone = function() {
    return new e(this.x, this.y, this.width, this.height);
  }, e.prototype.copy = function(t) {
    e.copy(this, t);
  }, e.prototype.plain = function() {
    return {
      x: this.x,
      y: this.y,
      width: this.width,
      height: this.height
    };
  }, e.prototype.isFinite = function() {
    return isFinite(this.x) && isFinite(this.y) && isFinite(this.width) && isFinite(this.height);
  }, e.prototype.isZero = function() {
    return this.width === 0 || this.height === 0;
  }, e.create = function(t) {
    return new e(t.x, t.y, t.width, t.height);
  }, e.copy = function(t, i) {
    return t.x = i.x, t.y = i.y, t.width = i.width, t.height = i.height, t;
  }, e.applyTransform = function(t, i, n) {
    if (!n) {
      t !== i && e.copy(t, i);
      return;
    }
    if (n[1] < 1e-5 && n[1] > -1e-5 && n[2] < 1e-5 && n[2] > -1e-5) {
      var r = n[0], a = n[3], s = n[4], o = n[5];
      t.x = i.x * r + s, t.y = i.y * a + o, t.width = i.width * r, t.height = i.height * a, t.width < 0 && (t.x += t.width, t.width = -t.width), t.height < 0 && (t.y += t.height, t.height = -t.height);
      return;
    }
    dr.x = vr.x = i.x, dr.y = pr.y = i.y, fr.x = pr.x = i.x + i.width, fr.y = vr.y = i.y + i.height, dr.transform(n), pr.transform(n), fr.transform(n), vr.transform(n), t.x = Yr(dr.x, fr.x, vr.x, pr.x), t.y = Yr(dr.y, fr.y, vr.y, pr.y);
    var l = Ya(dr.x, fr.x, vr.x, pr.x), u = Ya(dr.y, fr.y, vr.y, pr.y);
    t.width = l - t.x, t.height = u - t.y;
  }, e;
})(), DP = new lt(0, 0, 0, 0), TP = new lt(0, 0, 0, 0);
function km(e, t, i, n, r, a, s, o) {
  var l = Jd(t - i), u = Jd(n - e), c = Yr(l, u), h = Mm[r], d = Mm[1 - r], f = kP[r];
  t < i || n < e ? l < u ? (a && (tf[h] = -l), o && (s[h] = t, s[f] = 0)) : (a && (tf[h] = u), o && (s[h] = e, s[f] = 0)) : (s && (s[h] = Ya(e, i), s[f] = Yr(t, n) - s[h]), a && (c < po[0] || Ze.useDir) && (po[0] = Yr(c, po[0]), (l < u || !Ze.bidirectional) && (Js[h] = l, Js[d] = 0, Ze.useDir && Ze.calcDirMTV()), (l >= u || !Ze.bidirectional) && (Js[h] = -u, Js[d] = 0, Ze.useDir && Ze.calcDirMTV())));
}
function s1() {
  var e = 0, t = new It(), i = new It(), n = {
    minTv: new It(),
    maxTv: new It(),
    useDir: !1,
    dirMinTv: new It(),
    touchThreshold: 0,
    bidirectional: !0,
    negativeSize: !1,
    reset: function(a, s) {
      n.touchThreshold = 0, a && a.touchThreshold != null && (n.touchThreshold = Ya(0, a.touchThreshold)), n.negativeSize = !1, s && (n.minTv.set(1 / 0, 1 / 0), n.maxTv.set(0, 0), n.useDir = !1, a && a.direction != null && (n.useDir = !0, n.dirMinTv.copy(n.minTv), i.copy(n.minTv), e = a.direction, n.bidirectional = a.bidirectional == null || !!a.bidirectional, n.bidirectional || t.set(Math.cos(e), Math.sin(e))));
    },
    calcDirMTV: function() {
      var a = n.minTv, s = n.dirMinTv, o = a.y * a.y + a.x * a.x, l = Math.sin(e), u = Math.cos(e), c = l * a.y + u * a.x;
      if (r(c)) {
        r(a.x) && r(a.y) && s.set(0, 0);
        return;
      }
      if (i.x = o * u / c, i.y = o * l / c, r(i.x) && r(i.y)) {
        s.set(0, 0);
        return;
      }
      (n.bidirectional || t.dot(i) > 0) && i.len() < s.len() && s.copy(i);
    }
  };
  function r(a) {
    return Jd(a) < 1e-10;
  }
  return n;
}
var o1 = "silent";
function CP(e, t, i) {
  return {
    type: e,
    event: i,
    target: t.target,
    topTarget: t.topTarget,
    cancelBubble: !1,
    offsetX: i.zrX,
    offsetY: i.zrY,
    gestureEvent: i.gestureEvent,
    pinchX: i.pinchX,
    pinchY: i.pinchY,
    pinchScale: i.pinchScale,
    wheelDelta: i.zrDelta,
    zrByTouch: i.zrByTouch,
    which: i.which,
    stop: EP
  };
}
function EP() {
  Eu(this.event);
}
var AP = (function(e) {
  Lt(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.handler = null, i;
  }
  return t.prototype.dispose = function() {
  }, t.prototype.setCursor = function() {
  }, t;
})(Li), Ds = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.x = t, this.y = i;
  }
  return e;
})(), PP = [
  "click",
  "dblclick",
  "mousewheel",
  "mouseout",
  "mouseup",
  "mousedown",
  "mousemove",
  "contextmenu"
], yh = new lt(0, 0, 0, 0), l1 = (function(e) {
  Lt(t, e);
  function t(i, n, r, a, s) {
    var o = e.call(this) || this;
    return o._hovered = new Ds(0, 0), o.storage = i, o.painter = n, o.painterRoot = a, o._pointerSize = s, r = r || new AP(), o.proxy = null, o.setHandlerProxy(r), o._draggingMgr = new uP(o), o;
  }
  return t.prototype.setHandlerProxy = function(i) {
    this.proxy && this.proxy.dispose(), i && (E(PP, function(n) {
      i.on && i.on(n, this[n], this);
    }, this), i.handler = this), this.proxy = i;
  }, t.prototype.mousemove = function(i) {
    var n = i.zrX, r = i.zrY, a = u1(this, n, r), s = this._hovered, o = s.target;
    o && !o.__zr && (s = this.findHover(s.x, s.y), o = s.target);
    var l = this._hovered = a ? new Ds(n, r) : this.findHover(n, r), u = l.target, c = this.proxy;
    c.setCursor && c.setCursor(u ? u.cursor : "default"), o && u !== o && this.dispatchToElement(s, "mouseout", i), this.dispatchToElement(l, "mousemove", i), u && u !== o && this.dispatchToElement(l, "mouseover", i);
  }, t.prototype.mouseout = function(i) {
    var n = i.zrEventControl;
    n !== "only_globalout" && this.dispatchToElement(this._hovered, "mouseout", i), n !== "no_globalout" && this.trigger("globalout", { type: "globalout", event: i });
  }, t.prototype.resize = function() {
    this._hovered = new Ds(0, 0);
  }, t.prototype.dispatch = function(i, n) {
    var r = this[i];
    r && r.call(this, n);
  }, t.prototype.dispose = function() {
    this.proxy.dispose(), this.storage = null, this.proxy = null, this.painter = null;
  }, t.prototype.setCursorStyle = function(i) {
    var n = this.proxy;
    n.setCursor && n.setCursor(i);
  }, t.prototype.dispatchToElement = function(i, n, r) {
    i = i || {};
    var a = i.target;
    if (!(a && a.silent)) {
      for (var s = "on" + n, o = CP(n, i, r); a && (a[s] && (o.cancelBubble = !!a[s].call(a, o)), a.trigger(n, o), a = a.__hostTarget ? a.__hostTarget : a.parent, !o.cancelBubble); )
        ;
      o.cancelBubble || (this.trigger(n, o), this.painter && this.painter.eachOtherLayer && this.painter.eachOtherLayer(function(l) {
        typeof l[s] == "function" && l[s].call(l, o), l.trigger && l.trigger(n, o);
      }));
    }
  }, t.prototype.findHover = function(i, n, r) {
    var a = this.storage.getDisplayList(), s = new Ds(i, n);
    if (Dm(a, s, i, n, r), this._pointerSize && !s.target) {
      for (var o = [], l = this._pointerSize, u = l / 2, c = new lt(i - u, n - u, l, l), h = a.length - 1; h >= 0; h--) {
        var d = a[h];
        d !== r && !d.ignore && !d.ignoreCoarsePointer && (!d.parent || !d.parent.ignoreCoarsePointer) && (yh.copy(d.getBoundingRect()), d.transform && yh.applyTransform(d.transform), yh.intersect(c) && o.push(d));
      }
      if (o.length)
        for (var f = 4, v = Math.PI / 12, m = Math.PI * 2, p = 0; p < u; p += f)
          for (var g = 0; g < m; g += v) {
            var y = i + p * Math.cos(g), _ = n + p * Math.sin(g);
            if (Dm(o, s, y, _, r), s.target)
              return s;
          }
    }
    return s;
  }, t.prototype.processGesture = function(i, n) {
    this._gestureMgr || (this._gestureMgr = new wP());
    var r = this._gestureMgr;
    n === "start" && r.clear();
    var a = r.recognize(i, this.findHover(i.zrX, i.zrY, null).target, this.proxy.dom);
    if (n === "end" && r.clear(), a) {
      var s = a.type;
      i.gestureEvent = s;
      var o = new Ds();
      o.target = a.target, this.dispatchToElement(o, s, a.event);
    }
  }, t;
})(Li);
E(["click", "mousedown", "mouseup", "mousewheel", "dblclick", "contextmenu"], function(e) {
  l1.prototype[e] = function(t) {
    var i = t.zrX, n = t.zrY, r = u1(this, i, n), a, s;
    if ((e !== "mouseup" || !r) && (a = this.findHover(i, n), s = a.target), e === "mousedown")
      this._downEl = s, this._downPoint = [t.zrX, t.zrY], this._upEl = s;
    else if (e === "mouseup")
      this._upEl = s;
    else if (e === "click") {
      if (this._downEl !== this._upEl || !this._downPoint || oP(this._downPoint, [t.zrX, t.zrY]) > 4)
        return;
      this._downPoint = null;
    }
    this.dispatchToElement(a, e, t);
  };
});
function LP(e, t, i) {
  if (e[e.rectHover ? "rectContain" : "contain"](t, i)) {
    for (var n = e, r = void 0, a = !1; n; ) {
      if (n.ignoreClip && (a = !0), !a) {
        var s = n.getClipPath();
        if (s && !s.contain(t, i))
          return !1;
      }
      n.silent && (r = !0);
      var o = n.__hostTarget;
      n = o ? n.ignoreHostSilent ? null : o : n.parent;
    }
    return r ? o1 : !0;
  }
  return !1;
}
function Dm(e, t, i, n, r) {
  for (var a = e.length - 1; a >= 0; a--) {
    var s = e[a], o = void 0;
    if (s !== r && !s.ignore && (o = LP(s, i, n)) && (!t.topTarget && (t.topTarget = s), o !== o1)) {
      t.target = s;
      break;
    }
  }
}
function u1(e, t, i) {
  var n = e.painter;
  return t < 0 || t > n.getWidth() || i < 0 || i > n.getHeight();
}
var c1 = 32, Ts = 7;
function OP(e) {
  for (var t = 0; e >= c1; )
    t |= e & 1, e >>= 1;
  return e + t;
}
function Tm(e, t, i, n) {
  var r = t + 1;
  if (r === i)
    return 1;
  if (n(e[r++], e[t]) < 0) {
    for (; r < i && n(e[r], e[r - 1]) < 0; )
      r++;
    IP(e, t, r);
  } else
    for (; r < i && n(e[r], e[r - 1]) >= 0; )
      r++;
  return r - t;
}
function IP(e, t, i) {
  for (i--; t < i; ) {
    var n = e[t];
    e[t++] = e[i], e[i--] = n;
  }
}
function Cm(e, t, i, n, r) {
  for (n === t && n++; n < i; n++) {
    for (var a = e[n], s = t, o = n, l; s < o; )
      l = s + o >>> 1, r(a, e[l]) < 0 ? o = l : s = l + 1;
    var u = n - s;
    switch (u) {
      case 3:
        e[s + 3] = e[s + 2];
      case 2:
        e[s + 2] = e[s + 1];
      case 1:
        e[s + 1] = e[s];
        break;
      default:
        for (; u > 0; )
          e[s + u] = e[s + u - 1], u--;
    }
    e[s] = a;
  }
}
function _h(e, t, i, n, r, a) {
  var s = 0, o = 0, l = 1;
  if (a(e, t[i + r]) > 0) {
    for (o = n - r; l < o && a(e, t[i + r + l]) > 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o), s += r, l += r;
  } else {
    for (o = r + 1; l < o && a(e, t[i + r - l]) <= 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o);
    var u = s;
    s = r - l, l = r - u;
  }
  for (s++; s < l; ) {
    var c = s + (l - s >>> 1);
    a(e, t[i + c]) > 0 ? s = c + 1 : l = c;
  }
  return l;
}
function bh(e, t, i, n, r, a) {
  var s = 0, o = 0, l = 1;
  if (a(e, t[i + r]) < 0) {
    for (o = r + 1; l < o && a(e, t[i + r - l]) < 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o);
    var u = s;
    s = r - l, l = r - u;
  } else {
    for (o = n - r; l < o && a(e, t[i + r + l]) >= 0; )
      s = l, l = (l << 1) + 1, l <= 0 && (l = o);
    l > o && (l = o), s += r, l += r;
  }
  for (s++; s < l; ) {
    var c = s + (l - s >>> 1);
    a(e, t[i + c]) < 0 ? l = c : s = c + 1;
  }
  return l;
}
function RP(e, t) {
  var i = Ts, n, r, a = 0, s = [];
  n = [], r = [];
  function o(f, v) {
    n[a] = f, r[a] = v, a += 1;
  }
  function l() {
    for (; a > 1; ) {
      var f = a - 2;
      if (f >= 1 && r[f - 1] <= r[f] + r[f + 1] || f >= 2 && r[f - 2] <= r[f] + r[f - 1])
        r[f - 1] < r[f + 1] && f--;
      else if (r[f] > r[f + 1])
        break;
      c(f);
    }
  }
  function u() {
    for (; a > 1; ) {
      var f = a - 2;
      f > 0 && r[f - 1] < r[f + 1] && f--, c(f);
    }
  }
  function c(f) {
    var v = n[f], m = r[f], p = n[f + 1], g = r[f + 1];
    r[f] = m + g, f === a - 3 && (n[f + 1] = n[f + 2], r[f + 1] = r[f + 2]), a--;
    var y = bh(e[p], e, v, m, 0, t);
    v += y, m -= y, m !== 0 && (g = _h(e[v + m - 1], e, p, g, g - 1, t), g !== 0 && (m <= g ? h(v, m, p, g) : d(v, m, p, g)));
  }
  function h(f, v, m, p) {
    var g = 0;
    for (g = 0; g < v; g++)
      s[g] = e[f + g];
    var y = 0, _ = m, b = f;
    if (e[b++] = e[_++], --p === 0) {
      for (g = 0; g < v; g++)
        e[b + g] = s[y + g];
      return;
    }
    if (v === 1) {
      for (g = 0; g < p; g++)
        e[b + g] = e[_ + g];
      e[b + p] = s[y];
      return;
    }
    for (var w = i, S, M, k; ; ) {
      S = 0, M = 0, k = !1;
      do
        if (t(e[_], s[y]) < 0) {
          if (e[b++] = e[_++], M++, S = 0, --p === 0) {
            k = !0;
            break;
          }
        } else if (e[b++] = s[y++], S++, M = 0, --v === 1) {
          k = !0;
          break;
        }
      while ((S | M) < w);
      if (k)
        break;
      do {
        if (S = bh(e[_], s, y, v, 0, t), S !== 0) {
          for (g = 0; g < S; g++)
            e[b + g] = s[y + g];
          if (b += S, y += S, v -= S, v <= 1) {
            k = !0;
            break;
          }
        }
        if (e[b++] = e[_++], --p === 0) {
          k = !0;
          break;
        }
        if (M = _h(s[y], e, _, p, 0, t), M !== 0) {
          for (g = 0; g < M; g++)
            e[b + g] = e[_ + g];
          if (b += M, _ += M, p -= M, p === 0) {
            k = !0;
            break;
          }
        }
        if (e[b++] = s[y++], --v === 1) {
          k = !0;
          break;
        }
        w--;
      } while (S >= Ts || M >= Ts);
      if (k)
        break;
      w < 0 && (w = 0), w += 2;
    }
    if (i = w, i < 1 && (i = 1), v === 1) {
      for (g = 0; g < p; g++)
        e[b + g] = e[_ + g];
      e[b + p] = s[y];
    } else {
      if (v === 0)
        throw new Error();
      for (g = 0; g < v; g++)
        e[b + g] = s[y + g];
    }
  }
  function d(f, v, m, p) {
    var g = 0;
    for (g = 0; g < p; g++)
      s[g] = e[m + g];
    var y = f + v - 1, _ = p - 1, b = m + p - 1, w = 0, S = 0;
    if (e[b--] = e[y--], --v === 0) {
      for (w = b - (p - 1), g = 0; g < p; g++)
        e[w + g] = s[g];
      return;
    }
    if (p === 1) {
      for (b -= v, y -= v, S = b + 1, w = y + 1, g = v - 1; g >= 0; g--)
        e[S + g] = e[w + g];
      e[b] = s[_];
      return;
    }
    for (var M = i; ; ) {
      var k = 0, T = 0, D = !1;
      do
        if (t(s[_], e[y]) < 0) {
          if (e[b--] = e[y--], k++, T = 0, --v === 0) {
            D = !0;
            break;
          }
        } else if (e[b--] = s[_--], T++, k = 0, --p === 1) {
          D = !0;
          break;
        }
      while ((k | T) < M);
      if (D)
        break;
      do {
        if (k = v - bh(s[_], e, f, v, v - 1, t), k !== 0) {
          for (b -= k, y -= k, v -= k, S = b + 1, w = y + 1, g = k - 1; g >= 0; g--)
            e[S + g] = e[w + g];
          if (v === 0) {
            D = !0;
            break;
          }
        }
        if (e[b--] = s[_--], --p === 1) {
          D = !0;
          break;
        }
        if (T = p - _h(e[y], s, 0, p, p - 1, t), T !== 0) {
          for (b -= T, _ -= T, p -= T, S = b + 1, w = _ + 1, g = 0; g < T; g++)
            e[S + g] = s[w + g];
          if (p <= 1) {
            D = !0;
            break;
          }
        }
        if (e[b--] = e[y--], --v === 0) {
          D = !0;
          break;
        }
        M--;
      } while (k >= Ts || T >= Ts);
      if (D)
        break;
      M < 0 && (M = 0), M += 2;
    }
    if (i = M, i < 1 && (i = 1), p === 1) {
      for (b -= v, y -= v, S = b + 1, w = y + 1, g = v - 1; g >= 0; g--)
        e[S + g] = e[w + g];
      e[b] = s[_];
    } else {
      if (p === 0)
        throw new Error();
      for (w = b - (p - 1), g = 0; g < p; g++)
        e[w + g] = s[g];
    }
  }
  return {
    mergeRuns: l,
    forceMergeRuns: u,
    pushRun: o
  };
}
function ru(e, t, i, n) {
  i || (i = 0), n || (n = e.length);
  var r = n - i;
  if (!(r < 2)) {
    var a = 0;
    if (r < c1) {
      a = Tm(e, i, n, t), Cm(e, i, n, i + a, t);
      return;
    }
    var s = RP(e, t), o = OP(r);
    do {
      if (a = Tm(e, i, n, t), a < o) {
        var l = r;
        l > o && (l = o), Cm(e, i, i + l, i + a, t), a = l;
      }
      s.pushRun(i, a), s.mergeRuns(), r -= a, i += a;
    } while (r !== 0);
    s.forceMergeRuns();
  }
}
var Qe = 1, to = 2, $a = 4, Em = !1;
function xh() {
  Em || (Em = !0, console.warn("z / z2 / zlevel of displayable is invalid, which may cause unexpected errors"));
}
function Am(e, t) {
  return e.zlevel === t.zlevel ? e.z === t.z ? e.z2 - t.z2 : e.z - t.z : e.zlevel - t.zlevel;
}
var NP = (function() {
  function e() {
    this._roots = [], this._displayList = [], this._displayListLen = 0, this.displayableSortFunc = Am;
  }
  return e.prototype.traverse = function(t, i) {
    for (var n = 0; n < this._roots.length; n++)
      this._roots[n].traverse(t, i);
  }, e.prototype.getDisplayList = function(t, i) {
    i = i || !1;
    var n = this._displayList;
    return (t || !n.length) && this.updateDisplayList(i), n;
  }, e.prototype.updateDisplayList = function(t) {
    this._displayListLen = 0;
    for (var i = this._roots, n = this._displayList, r = 0, a = i.length; r < a; r++)
      this._updateAndAddDisplayable(i[r], null, t);
    n.length = this._displayListLen, ru(n, Am);
  }, e.prototype._updateAndAddDisplayable = function(t, i, n) {
    if (!(t.ignore && !n)) {
      t.beforeUpdate(), t.update(), t.afterUpdate();
      var r = t.getClipPath(), a = i && i.length, s = 0, o = t.__clipPaths;
      if (!t.ignoreClip && (a || r)) {
        if (o || (o = t.__clipPaths = []), a)
          for (var l = 0; l < i.length; l++)
            o[s++] = i[l];
        for (var u = r, c = t; u; )
          u.parent = c, u.updateTransform(), o[s++] = u, c = u, u = u.getClipPath();
      }
      if (o && (o.length = s), t.childrenRef) {
        for (var h = t.childrenRef(), d = 0; d < h.length; d++) {
          var f = h[d];
          t.__dirty && (f.__dirty |= Qe), this._updateAndAddDisplayable(f, o, n);
        }
        t.__dirty = 0;
      } else {
        var v = t;
        isNaN(v.z) && (xh(), v.z = 0), isNaN(v.z2) && (xh(), v.z2 = 0), isNaN(v.zlevel) && (xh(), v.zlevel = 0), this._displayList[this._displayListLen++] = v;
      }
      var m = t.getDecalElement && t.getDecalElement();
      m && this._updateAndAddDisplayable(m, o, n);
      var p = t.getTextGuideLine();
      p && this._updateAndAddDisplayable(p, o, n);
      var g = t.getTextContent();
      g && this._updateAndAddDisplayable(g, o, n);
    }
  }, e.prototype.addRoot = function(t) {
    t.__zr && t.__zr.storage === this || this._roots.push(t);
  }, e.prototype.delRoot = function(t) {
    if (t instanceof Array) {
      for (var i = 0, n = t.length; i < n; i++)
        this.delRoot(t[i]);
      return;
    }
    var r = Ht(this._roots, t);
    r >= 0 && this._roots.splice(r, 1);
  }, e.prototype.delAllRoots = function() {
    this._roots = [], this._displayList = [], this._displayListLen = 0;
  }, e.prototype.getRoots = function() {
    return this._roots;
  }, e.prototype.dispose = function() {
    this._displayList = null, this._roots = null;
  }, e;
})(), Au;
Au = ot.hasGlobalWindow && (window.requestAnimationFrame && window.requestAnimationFrame.bind(window) || window.msRequestAnimationFrame && window.msRequestAnimationFrame.bind(window) || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame) || function(e) {
  return setTimeout(e, 16);
};
var go = {
  linear: function(e) {
    return e;
  },
  quadraticIn: function(e) {
    return e * e;
  },
  quadraticOut: function(e) {
    return e * (2 - e);
  },
  quadraticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e : -0.5 * (--e * (e - 2) - 1);
  },
  cubicIn: function(e) {
    return e * e * e;
  },
  cubicOut: function(e) {
    return --e * e * e + 1;
  },
  cubicInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e : 0.5 * ((e -= 2) * e * e + 2);
  },
  quarticIn: function(e) {
    return e * e * e * e;
  },
  quarticOut: function(e) {
    return 1 - --e * e * e * e;
  },
  quarticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e : -0.5 * ((e -= 2) * e * e * e - 2);
  },
  quinticIn: function(e) {
    return e * e * e * e * e;
  },
  quinticOut: function(e) {
    return --e * e * e * e * e + 1;
  },
  quinticInOut: function(e) {
    return (e *= 2) < 1 ? 0.5 * e * e * e * e * e : 0.5 * ((e -= 2) * e * e * e * e + 2);
  },
  sinusoidalIn: function(e) {
    return 1 - Math.cos(e * Math.PI / 2);
  },
  sinusoidalOut: function(e) {
    return Math.sin(e * Math.PI / 2);
  },
  sinusoidalInOut: function(e) {
    return 0.5 * (1 - Math.cos(Math.PI * e));
  },
  exponentialIn: function(e) {
    return e === 0 ? 0 : Math.pow(1024, e - 1);
  },
  exponentialOut: function(e) {
    return e === 1 ? 1 : 1 - Math.pow(2, -10 * e);
  },
  exponentialInOut: function(e) {
    return e === 0 ? 0 : e === 1 ? 1 : (e *= 2) < 1 ? 0.5 * Math.pow(1024, e - 1) : 0.5 * (-Math.pow(2, -10 * (e - 1)) + 2);
  },
  circularIn: function(e) {
    return 1 - Math.sqrt(1 - e * e);
  },
  circularOut: function(e) {
    return Math.sqrt(1 - --e * e);
  },
  circularInOut: function(e) {
    return (e *= 2) < 1 ? -0.5 * (Math.sqrt(1 - e * e) - 1) : 0.5 * (Math.sqrt(1 - (e -= 2) * e) + 1);
  },
  elasticIn: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), -(i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)));
  },
  elasticOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), i * Math.pow(2, -10 * e) * Math.sin((e - t) * (2 * Math.PI) / n) + 1);
  },
  elasticInOut: function(e) {
    var t, i = 0.1, n = 0.4;
    return e === 0 ? 0 : e === 1 ? 1 : (!i || i < 1 ? (i = 1, t = n / 4) : t = n * Math.asin(1 / i) / (2 * Math.PI), (e *= 2) < 1 ? -0.5 * (i * Math.pow(2, 10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n)) : i * Math.pow(2, -10 * (e -= 1)) * Math.sin((e - t) * (2 * Math.PI) / n) * 0.5 + 1);
  },
  backIn: function(e) {
    var t = 1.70158;
    return e * e * ((t + 1) * e - t);
  },
  backOut: function(e) {
    var t = 1.70158;
    return --e * e * ((t + 1) * e + t) + 1;
  },
  backInOut: function(e) {
    var t = 2.5949095;
    return (e *= 2) < 1 ? 0.5 * (e * e * ((t + 1) * e - t)) : 0.5 * ((e -= 2) * e * ((t + 1) * e + t) + 2);
  },
  bounceIn: function(e) {
    return 1 - go.bounceOut(1 - e);
  },
  bounceOut: function(e) {
    return e < 1 / 2.75 ? 7.5625 * e * e : e < 2 / 2.75 ? 7.5625 * (e -= 1.5 / 2.75) * e + 0.75 : e < 2.5 / 2.75 ? 7.5625 * (e -= 2.25 / 2.75) * e + 0.9375 : 7.5625 * (e -= 2.625 / 2.75) * e + 0.984375;
  },
  bounceInOut: function(e) {
    return e < 0.5 ? go.bounceIn(e * 2) * 0.5 : go.bounceOut(e * 2 - 1) * 0.5 + 0.5;
  }
}, yl = Math.pow, Kn = Math.sqrt, Pu = 1e-8, h1 = 1e-4, Pm = Kn(3), _l = 1 / 3, Ui = gs(), ci = gs(), Ka = gs();
function Gn(e) {
  return e > -Pu && e < Pu;
}
function d1(e) {
  return e > Pu || e < -Pu;
}
function Le(e, t, i, n, r) {
  var a = 1 - r;
  return a * a * (a * e + 3 * r * t) + r * r * (r * n + 3 * a * i);
}
function Lm(e, t, i, n, r) {
  var a = 1 - r;
  return 3 * (((t - e) * a + 2 * (i - t) * r) * a + (n - i) * r * r);
}
function f1(e, t, i, n, r, a) {
  var s = n + 3 * (t - i) - e, o = 3 * (i - t * 2 + e), l = 3 * (t - e), u = e - r, c = o * o - 3 * s * l, h = o * l - 9 * s * u, d = l * l - 3 * o * u, f = 0;
  if (Gn(c) && Gn(h))
    if (Gn(o))
      a[0] = 0;
    else {
      var v = -l / o;
      v >= 0 && v <= 1 && (a[f++] = v);
    }
  else {
    var m = h * h - 4 * c * d;
    if (Gn(m)) {
      var p = h / c, v = -o / s + p, g = -p / 2;
      v >= 0 && v <= 1 && (a[f++] = v), g >= 0 && g <= 1 && (a[f++] = g);
    } else if (m > 0) {
      var y = Kn(m), _ = c * o + 1.5 * s * (-h + y), b = c * o + 1.5 * s * (-h - y);
      _ < 0 ? _ = -yl(-_, _l) : _ = yl(_, _l), b < 0 ? b = -yl(-b, _l) : b = yl(b, _l);
      var v = (-o - (_ + b)) / (3 * s);
      v >= 0 && v <= 1 && (a[f++] = v);
    } else {
      var w = (2 * c * o - 3 * s * h) / (2 * Kn(c * c * c)), S = Math.acos(w) / 3, M = Kn(c), k = Math.cos(S), v = (-o - 2 * M * k) / (3 * s), g = (-o + M * (k + Pm * Math.sin(S))) / (3 * s), T = (-o + M * (k - Pm * Math.sin(S))) / (3 * s);
      v >= 0 && v <= 1 && (a[f++] = v), g >= 0 && g <= 1 && (a[f++] = g), T >= 0 && T <= 1 && (a[f++] = T);
    }
  }
  return f;
}
function v1(e, t, i, n, r) {
  var a = 6 * i - 12 * t + 6 * e, s = 9 * t + 3 * n - 3 * e - 9 * i, o = 3 * t - 3 * e, l = 0;
  if (Gn(s)) {
    if (d1(a)) {
      var u = -o / a;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = a * a - 4 * s * o;
    if (Gn(c))
      r[0] = -a / (2 * s);
    else if (c > 0) {
      var h = Kn(c), u = (-a + h) / (2 * s), d = (-a - h) / (2 * s);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function Lu(e, t, i, n, r, a) {
  var s = (t - e) * r + e, o = (i - t) * r + t, l = (n - i) * r + i, u = (o - s) * r + s, c = (l - o) * r + o, h = (c - u) * r + u;
  a[0] = e, a[1] = s, a[2] = u, a[3] = h, a[4] = h, a[5] = c, a[6] = l, a[7] = n;
}
function FP(e, t, i, n, r, a, s, o, l, u, c) {
  var h, d = 5e-3, f = 1 / 0, v, m, p, g;
  Ui[0] = l, Ui[1] = u;
  for (var y = 0; y < 1; y += 0.05)
    ci[0] = Le(e, i, r, s, y), ci[1] = Le(t, n, a, o, y), p = Za(Ui, ci), p < f && (h = y, f = p);
  f = 1 / 0;
  for (var _ = 0; _ < 32 && !(d < h1); _++)
    v = h - d, m = h + d, ci[0] = Le(e, i, r, s, v), ci[1] = Le(t, n, a, o, v), p = Za(ci, Ui), v >= 0 && p < f ? (h = v, f = p) : (Ka[0] = Le(e, i, r, s, m), Ka[1] = Le(t, n, a, o, m), g = Za(Ka, Ui), m <= 1 && g < f ? (h = m, f = g) : d *= 0.5);
  return Kn(f);
}
function BP(e, t, i, n, r, a, s, o, l) {
  for (var u = e, c = t, h = 0, d = 1 / l, f = 1; f <= l; f++) {
    var v = f * d, m = Le(e, i, r, s, v), p = Le(t, n, a, o, v), g = m - u, y = p - c;
    h += Math.sqrt(g * g + y * y), u = m, c = p;
  }
  return h;
}
function He(e, t, i, n) {
  var r = 1 - n;
  return r * (r * e + 2 * n * t) + n * n * i;
}
function Om(e, t, i, n) {
  return 2 * ((1 - n) * (t - e) + n * (i - t));
}
function $P(e, t, i, n, r) {
  var a = e - 2 * t + i, s = 2 * (t - e), o = e - n, l = 0;
  if (Gn(a)) {
    if (d1(s)) {
      var u = -o / s;
      u >= 0 && u <= 1 && (r[l++] = u);
    }
  } else {
    var c = s * s - 4 * a * o;
    if (Gn(c)) {
      var u = -s / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u);
    } else if (c > 0) {
      var h = Kn(c), u = (-s + h) / (2 * a), d = (-s - h) / (2 * a);
      u >= 0 && u <= 1 && (r[l++] = u), d >= 0 && d <= 1 && (r[l++] = d);
    }
  }
  return l;
}
function p1(e, t, i) {
  var n = e + i - 2 * t;
  return n === 0 ? 0.5 : (e - t) / n;
}
function Ou(e, t, i, n, r) {
  var a = (t - e) * n + e, s = (i - t) * n + t, o = (s - a) * n + a;
  r[0] = e, r[1] = a, r[2] = o, r[3] = o, r[4] = s, r[5] = i;
}
function zP(e, t, i, n, r, a, s, o, l) {
  var u, c = 5e-3, h = 1 / 0;
  Ui[0] = s, Ui[1] = o;
  for (var d = 0; d < 1; d += 0.05) {
    ci[0] = He(e, i, r, d), ci[1] = He(t, n, a, d);
    var f = Za(Ui, ci);
    f < h && (u = d, h = f);
  }
  h = 1 / 0;
  for (var v = 0; v < 32 && !(c < h1); v++) {
    var m = u - c, p = u + c;
    ci[0] = He(e, i, r, m), ci[1] = He(t, n, a, m);
    var f = Za(ci, Ui);
    if (m >= 0 && f < h)
      u = m, h = f;
    else {
      Ka[0] = He(e, i, r, p), Ka[1] = He(t, n, a, p);
      var g = Za(Ka, Ui);
      p <= 1 && g < h ? (u = p, h = g) : c *= 0.5;
    }
  }
  return Kn(h);
}
function VP(e, t, i, n, r, a, s) {
  for (var o = e, l = t, u = 0, c = 1 / s, h = 1; h <= s; h++) {
    var d = h * c, f = He(e, i, r, d), v = He(t, n, a, d), m = f - o, p = v - l;
    u += Math.sqrt(m * m + p * p), o = f, l = v;
  }
  return u;
}
var HP = /cubic-bezier\(([0-9,\.e ]+)\)/;
function g1(e) {
  var t = e && HP.exec(e);
  if (t) {
    var i = t[1].split(","), n = +Xi(i[0]), r = +Xi(i[1]), a = +Xi(i[2]), s = +Xi(i[3]);
    if (isNaN(n + r + a + s))
      return;
    var o = [];
    return function(l) {
      return l <= 0 ? 0 : l >= 1 ? 1 : f1(0, n, a, 1, l, o) && Le(0, r, s, 1, o[0]);
    };
  }
}
var YP = (function() {
  function e(t) {
    this._inited = !1, this._startTime = 0, this._pausedTime = 0, this._paused = !1, this._life = t.life || 1e3, this._delay = t.delay || 0, this.loop = t.loop || !1, this.onframe = t.onframe || ke, this.ondestroy = t.ondestroy || ke, this.onrestart = t.onrestart || ke, t.easing && this.setEasing(t.easing);
  }
  return e.prototype.step = function(t, i) {
    if (this._inited || (this._startTime = t + this._delay, this._inited = !0), this._paused) {
      this._pausedTime += i;
      return;
    }
    var n = this._life, r = t - this._startTime - this._pausedTime, a = r / n;
    a < 0 && (a = 0), a = Math.min(a, 1);
    var s = this.easingFunc, o = s ? s(a) : a;
    if (this.onframe(o), a === 1)
      if (this.loop) {
        var l = r % n;
        this._startTime = t - l, this._pausedTime = 0, this.onrestart();
      } else
        return !0;
    return !1;
  }, e.prototype.pause = function() {
    this._paused = !0;
  }, e.prototype.resume = function() {
    this._paused = !1;
  }, e.prototype.setEasing = function(t) {
    this.easing = t, this.easingFunc = mt(t) ? t : go[t] || g1(t);
  }, e;
})(), m1 = /* @__PURE__ */ (function() {
  function e(t) {
    this.value = t;
  }
  return e;
})(), WP = (function() {
  function e() {
    this._len = 0;
  }
  return e.prototype.insert = function(t) {
    var i = new m1(t);
    return this.insertEntry(i), i;
  }, e.prototype.insertEntry = function(t) {
    this.head ? (this.tail.next = t, t.prev = this.tail, t.next = null, this.tail = t) : this.head = this.tail = t, this._len++;
  }, e.prototype.remove = function(t) {
    var i = t.prev, n = t.next;
    i ? i.next = n : this.head = n, n ? n.prev = i : this.tail = i, t.next = t.prev = null, this._len--;
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.clear = function() {
    this.head = this.tail = null, this._len = 0;
  }, e;
})(), os = (function() {
  function e(t) {
    this._list = new WP(), this._maxSize = 10, this._map = {}, this._maxSize = t;
  }
  return e.prototype.put = function(t, i) {
    var n = this._list, r = this._map, a = null;
    if (r[t] == null) {
      var s = n.len(), o = this._lastRemovedEntry;
      if (s >= this._maxSize && s > 0) {
        var l = n.head;
        n.remove(l), delete r[l.key], a = l.value, this._lastRemovedEntry = l;
      }
      o ? o.value = i : o = new m1(i), o.key = t, n.insertEntry(o), r[t] = o;
    }
    return a;
  }, e.prototype.get = function(t) {
    var i = this._map[t], n = this._list;
    if (i != null)
      return i !== n.tail && (n.remove(i), n.insertEntry(i)), i.value;
  }, e.prototype.clear = function() {
    this._list.clear(), this._map = {};
  }, e.prototype.len = function() {
    return this._list.len();
  }, e;
})(), Im = {
  transparent: [0, 0, 0, 0],
  aliceblue: [240, 248, 255, 1],
  antiquewhite: [250, 235, 215, 1],
  aqua: [0, 255, 255, 1],
  aquamarine: [127, 255, 212, 1],
  azure: [240, 255, 255, 1],
  beige: [245, 245, 220, 1],
  bisque: [255, 228, 196, 1],
  black: [0, 0, 0, 1],
  blanchedalmond: [255, 235, 205, 1],
  blue: [0, 0, 255, 1],
  blueviolet: [138, 43, 226, 1],
  brown: [165, 42, 42, 1],
  burlywood: [222, 184, 135, 1],
  cadetblue: [95, 158, 160, 1],
  chartreuse: [127, 255, 0, 1],
  chocolate: [210, 105, 30, 1],
  coral: [255, 127, 80, 1],
  cornflowerblue: [100, 149, 237, 1],
  cornsilk: [255, 248, 220, 1],
  crimson: [220, 20, 60, 1],
  cyan: [0, 255, 255, 1],
  darkblue: [0, 0, 139, 1],
  darkcyan: [0, 139, 139, 1],
  darkgoldenrod: [184, 134, 11, 1],
  darkgray: [169, 169, 169, 1],
  darkgreen: [0, 100, 0, 1],
  darkgrey: [169, 169, 169, 1],
  darkkhaki: [189, 183, 107, 1],
  darkmagenta: [139, 0, 139, 1],
  darkolivegreen: [85, 107, 47, 1],
  darkorange: [255, 140, 0, 1],
  darkorchid: [153, 50, 204, 1],
  darkred: [139, 0, 0, 1],
  darksalmon: [233, 150, 122, 1],
  darkseagreen: [143, 188, 143, 1],
  darkslateblue: [72, 61, 139, 1],
  darkslategray: [47, 79, 79, 1],
  darkslategrey: [47, 79, 79, 1],
  darkturquoise: [0, 206, 209, 1],
  darkviolet: [148, 0, 211, 1],
  deeppink: [255, 20, 147, 1],
  deepskyblue: [0, 191, 255, 1],
  dimgray: [105, 105, 105, 1],
  dimgrey: [105, 105, 105, 1],
  dodgerblue: [30, 144, 255, 1],
  firebrick: [178, 34, 34, 1],
  floralwhite: [255, 250, 240, 1],
  forestgreen: [34, 139, 34, 1],
  fuchsia: [255, 0, 255, 1],
  gainsboro: [220, 220, 220, 1],
  ghostwhite: [248, 248, 255, 1],
  gold: [255, 215, 0, 1],
  goldenrod: [218, 165, 32, 1],
  gray: [128, 128, 128, 1],
  green: [0, 128, 0, 1],
  greenyellow: [173, 255, 47, 1],
  grey: [128, 128, 128, 1],
  honeydew: [240, 255, 240, 1],
  hotpink: [255, 105, 180, 1],
  indianred: [205, 92, 92, 1],
  indigo: [75, 0, 130, 1],
  ivory: [255, 255, 240, 1],
  khaki: [240, 230, 140, 1],
  lavender: [230, 230, 250, 1],
  lavenderblush: [255, 240, 245, 1],
  lawngreen: [124, 252, 0, 1],
  lemonchiffon: [255, 250, 205, 1],
  lightblue: [173, 216, 230, 1],
  lightcoral: [240, 128, 128, 1],
  lightcyan: [224, 255, 255, 1],
  lightgoldenrodyellow: [250, 250, 210, 1],
  lightgray: [211, 211, 211, 1],
  lightgreen: [144, 238, 144, 1],
  lightgrey: [211, 211, 211, 1],
  lightpink: [255, 182, 193, 1],
  lightsalmon: [255, 160, 122, 1],
  lightseagreen: [32, 178, 170, 1],
  lightskyblue: [135, 206, 250, 1],
  lightslategray: [119, 136, 153, 1],
  lightslategrey: [119, 136, 153, 1],
  lightsteelblue: [176, 196, 222, 1],
  lightyellow: [255, 255, 224, 1],
  lime: [0, 255, 0, 1],
  limegreen: [50, 205, 50, 1],
  linen: [250, 240, 230, 1],
  magenta: [255, 0, 255, 1],
  maroon: [128, 0, 0, 1],
  mediumaquamarine: [102, 205, 170, 1],
  mediumblue: [0, 0, 205, 1],
  mediumorchid: [186, 85, 211, 1],
  mediumpurple: [147, 112, 219, 1],
  mediumseagreen: [60, 179, 113, 1],
  mediumslateblue: [123, 104, 238, 1],
  mediumspringgreen: [0, 250, 154, 1],
  mediumturquoise: [72, 209, 204, 1],
  mediumvioletred: [199, 21, 133, 1],
  midnightblue: [25, 25, 112, 1],
  mintcream: [245, 255, 250, 1],
  mistyrose: [255, 228, 225, 1],
  moccasin: [255, 228, 181, 1],
  navajowhite: [255, 222, 173, 1],
  navy: [0, 0, 128, 1],
  oldlace: [253, 245, 230, 1],
  olive: [128, 128, 0, 1],
  olivedrab: [107, 142, 35, 1],
  orange: [255, 165, 0, 1],
  orangered: [255, 69, 0, 1],
  orchid: [218, 112, 214, 1],
  palegoldenrod: [238, 232, 170, 1],
  palegreen: [152, 251, 152, 1],
  paleturquoise: [175, 238, 238, 1],
  palevioletred: [219, 112, 147, 1],
  papayawhip: [255, 239, 213, 1],
  peachpuff: [255, 218, 185, 1],
  peru: [205, 133, 63, 1],
  pink: [255, 192, 203, 1],
  plum: [221, 160, 221, 1],
  powderblue: [176, 224, 230, 1],
  purple: [128, 0, 128, 1],
  red: [255, 0, 0, 1],
  rosybrown: [188, 143, 143, 1],
  royalblue: [65, 105, 225, 1],
  saddlebrown: [139, 69, 19, 1],
  salmon: [250, 128, 114, 1],
  sandybrown: [244, 164, 96, 1],
  seagreen: [46, 139, 87, 1],
  seashell: [255, 245, 238, 1],
  sienna: [160, 82, 45, 1],
  silver: [192, 192, 192, 1],
  skyblue: [135, 206, 235, 1],
  slateblue: [106, 90, 205, 1],
  slategray: [112, 128, 144, 1],
  slategrey: [112, 128, 144, 1],
  snow: [255, 250, 250, 1],
  springgreen: [0, 255, 127, 1],
  steelblue: [70, 130, 180, 1],
  tan: [210, 180, 140, 1],
  teal: [0, 128, 128, 1],
  thistle: [216, 191, 216, 1],
  tomato: [255, 99, 71, 1],
  turquoise: [64, 224, 208, 1],
  violet: [238, 130, 238, 1],
  wheat: [245, 222, 179, 1],
  white: [255, 255, 255, 1],
  whitesmoke: [245, 245, 245, 1],
  yellow: [255, 255, 0, 1],
  yellowgreen: [154, 205, 50, 1]
};
function Qn(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 255 ? 255 : e;
}
function UP(e) {
  return e = Math.round(e), e < 0 ? 0 : e > 360 ? 360 : e;
}
function Iu(e) {
  return e < 0 ? 0 : e > 1 ? 1 : e;
}
function wh(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Qn(parseFloat(t) / 100 * 255) : Qn(parseInt(t, 10));
}
function Jr(e) {
  var t = e;
  return t.length && t.charAt(t.length - 1) === "%" ? Iu(parseFloat(t) / 100) : Iu(parseFloat(t));
}
function Sh(e, t, i) {
  return i < 0 ? i += 1 : i > 1 && (i -= 1), i * 6 < 1 ? e + (t - e) * i * 6 : i * 2 < 1 ? t : i * 3 < 2 ? e + (t - e) * (2 / 3 - i) * 6 : e;
}
function bl(e, t, i) {
  return e + (t - e) * i;
}
function si(e, t, i, n, r) {
  return e[0] = t, e[1] = i, e[2] = n, e[3] = r, e;
}
function ef(e, t) {
  return e[0] = t[0], e[1] = t[1], e[2] = t[2], e[3] = t[3], e;
}
var y1 = new os(20), xl = null;
function xa(e, t) {
  xl && ef(xl, t), xl = y1.put(e, xl || t.slice());
}
function Sn(e, t) {
  if (e) {
    t = t || [];
    var i = y1.get(e);
    if (i)
      return ef(t, i);
    e = e + "";
    var n = e.replace(/ /g, "").toLowerCase();
    if (n in Im)
      return ef(t, Im[n]), xa(e, t), t;
    var r = n.length;
    if (n.charAt(0) === "#") {
      if (r === 4 || r === 5) {
        var a = parseInt(n.slice(1, 4), 16);
        if (!(a >= 0 && a <= 4095)) {
          si(t, 0, 0, 0, 1);
          return;
        }
        return si(t, (a & 3840) >> 4 | (a & 3840) >> 8, a & 240 | (a & 240) >> 4, a & 15 | (a & 15) << 4, r === 5 ? parseInt(n.slice(4), 16) / 15 : 1), xa(e, t), t;
      } else if (r === 7 || r === 9) {
        var a = parseInt(n.slice(1, 7), 16);
        if (!(a >= 0 && a <= 16777215)) {
          si(t, 0, 0, 0, 1);
          return;
        }
        return si(t, (a & 16711680) >> 16, (a & 65280) >> 8, a & 255, r === 9 ? parseInt(n.slice(7), 16) / 255 : 1), xa(e, t), t;
      }
      return;
    }
    var s = n.indexOf("("), o = n.indexOf(")");
    if (s !== -1 && o + 1 === r) {
      var l = n.substr(0, s), u = n.substr(s + 1, o - (s + 1)).split(","), c = 1;
      switch (l) {
        case "rgba":
          if (u.length !== 4)
            return u.length === 3 ? si(t, +u[0], +u[1], +u[2], 1) : si(t, 0, 0, 0, 1);
          c = Jr(u.pop());
        case "rgb":
          if (u.length >= 3)
            return si(t, wh(u[0]), wh(u[1]), wh(u[2]), u.length === 3 ? c : Jr(u[3])), xa(e, t), t;
          si(t, 0, 0, 0, 1);
          return;
        case "hsla":
          if (u.length !== 4) {
            si(t, 0, 0, 0, 1);
            return;
          }
          return u[3] = Jr(u[3]), nf(u, t), xa(e, t), t;
        case "hsl":
          if (u.length !== 3) {
            si(t, 0, 0, 0, 1);
            return;
          }
          return nf(u, t), xa(e, t), t;
        default:
          return;
      }
    }
    si(t, 0, 0, 0, 1);
  }
}
function nf(e, t) {
  var i = (parseFloat(e[0]) % 360 + 360) % 360 / 360, n = Jr(e[1]), r = Jr(e[2]), a = r <= 0.5 ? r * (n + 1) : r + n - r * n, s = r * 2 - a;
  return t = t || [], si(t, Qn(Sh(s, a, i + 1 / 3) * 255), Qn(Sh(s, a, i) * 255), Qn(Sh(s, a, i - 1 / 3) * 255), 1), e.length === 4 && (t[3] = e[3]), t;
}
function GP(e) {
  if (e) {
    var t = e[0] / 255, i = e[1] / 255, n = e[2] / 255, r = Math.min(t, i, n), a = Math.max(t, i, n), s = a - r, o = (a + r) / 2, l, u;
    if (s === 0)
      l = 0, u = 0;
    else {
      o < 0.5 ? u = s / (a + r) : u = s / (2 - a - r);
      var c = ((a - t) / 6 + s / 2) / s, h = ((a - i) / 6 + s / 2) / s, d = ((a - n) / 6 + s / 2) / s;
      t === a ? l = d - h : i === a ? l = 1 / 3 + c - d : n === a && (l = 2 / 3 + h - c), l < 0 && (l += 1), l > 1 && (l -= 1);
    }
    var f = [l * 360, u, o];
    return e[3] != null && f.push(e[3]), f;
  }
}
function Rm(e, t) {
  var i = Sn(e);
  if (i) {
    for (var n = 0; n < 3; n++)
      i[n] = i[n] * (1 - t) | 0, i[n] > 255 ? i[n] = 255 : i[n] < 0 && (i[n] = 0);
    return ta(i, i.length === 4 ? "rgba" : "rgb");
  }
}
function Mh(e, t, i) {
  if (!(!(t && t.length) || !(e >= 0 && e <= 1))) {
    i = i || [];
    var n = e * (t.length - 1), r = Math.floor(n), a = Math.ceil(n), s = t[r], o = t[a], l = n - r;
    return i[0] = Qn(bl(s[0], o[0], l)), i[1] = Qn(bl(s[1], o[1], l)), i[2] = Qn(bl(s[2], o[2], l)), i[3] = Iu(bl(s[3], o[3], l)), i;
  }
}
function Qa(e, t, i, n) {
  var r = Sn(e);
  if (e)
    return r = GP(r), t != null && (r[0] = UP(mt(t) ? t(r[0]) : t)), i != null && (r[1] = Jr(mt(i) ? i(r[1]) : i)), n != null && (r[2] = Jr(mt(n) ? n(r[2]) : n)), ta(nf(r), "rgba");
}
function XP(e, t) {
  var i = Sn(e);
  if (i && t != null)
    return i[3] = Iu(t), ta(i, "rgba");
}
function ta(e, t) {
  if (!(!e || !e.length)) {
    var i = e[0] + "," + e[1] + "," + e[2];
    return (t === "rgba" || t === "hsva" || t === "hsla") && (i += "," + e[3]), t + "(" + i + ")";
  }
}
function Ru(e, t) {
  var i = Sn(e);
  return i ? (0.299 * i[0] + 0.587 * i[1] + 0.114 * i[2]) * i[3] / 255 + (1 - i[3]) * t : 0;
}
var Nm = new os(100);
function Fm(e) {
  if (et(e)) {
    var t = Nm.get(e);
    return t || (t = Rm(e, -0.1), Nm.put(e, t)), t;
  } else if (kc(e)) {
    var i = Y({}, e);
    return i.colorStops = _t(e.colorStops, function(n) {
      return {
        offset: n.offset,
        color: Rm(n.color, -0.1)
      };
    }), i;
  }
  return e;
}
function jP(e) {
  return e.type === "linear";
}
function qP(e) {
  return e.type === "radial";
}
(function() {
  return ot.hasGlobalWindow && mt(window.btoa) ? function(e) {
    return window.btoa(unescape(encodeURIComponent(e)));
  } : typeof Buffer < "u" ? function(e) {
    return Buffer.from(e).toString("base64");
  } : function(e) {
    return process.env.NODE_ENV !== "production" && Kr("Base64 isn't natively supported in the current environment."), null;
  };
})();
var rf = Array.prototype.slice;
function vn(e, t, i) {
  return (t - e) * i + e;
}
function kh(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = vn(t[a], i[a], n);
  return e;
}
function ZP(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, s = 0; s < r; s++) {
    e[s] || (e[s] = []);
    for (var o = 0; o < a; o++)
      e[s][o] = vn(t[s][o], i[s][o], n);
  }
  return e;
}
function wl(e, t, i, n) {
  for (var r = t.length, a = 0; a < r; a++)
    e[a] = t[a] + i[a] * n;
  return e;
}
function Bm(e, t, i, n) {
  for (var r = t.length, a = r && t[0].length, s = 0; s < r; s++) {
    e[s] || (e[s] = []);
    for (var o = 0; o < a; o++)
      e[s][o] = t[s][o] + i[s][o] * n;
  }
  return e;
}
function KP(e, t) {
  for (var i = e.length, n = t.length, r = i > n ? t : e, a = Math.min(i, n), s = r[a - 1] || { color: [0, 0, 0, 0], offset: 0 }, o = a; o < Math.max(i, n); o++)
    r.push({
      offset: s.offset,
      color: s.color.slice()
    });
}
function QP(e, t, i) {
  var n = e, r = t;
  if (!(!n.push || !r.push)) {
    var a = n.length, s = r.length;
    if (a !== s) {
      var o = a > s;
      if (o)
        n.length = s;
      else
        for (var l = a; l < s; l++)
          n.push(i === 1 ? r[l] : rf.call(r[l]));
    }
    for (var u = n[0] && n[0].length, l = 0; l < n.length; l++)
      if (i === 1)
        isNaN(n[l]) && (n[l] = r[l]);
      else
        for (var c = 0; c < u; c++)
          isNaN(n[l][c]) && (n[l][c] = r[l][c]);
  }
}
function au(e) {
  if (Xe(e)) {
    var t = e.length;
    if (Xe(e[0])) {
      for (var i = [], n = 0; n < t; n++)
        i.push(rf.call(e[n]));
      return i;
    }
    return rf.call(e);
  }
  return e;
}
function su(e) {
  return e[0] = Math.floor(e[0]) || 0, e[1] = Math.floor(e[1]) || 0, e[2] = Math.floor(e[2]) || 0, e[3] = e[3] == null ? 1 : e[3], "rgba(" + e.join(",") + ")";
}
function JP(e) {
  return Xe(e && e[0]) ? 2 : 1;
}
var Sl = 0, ou = 1, _1 = 2, eo = 3, af = 4, sf = 5, $m = 6;
function zm(e) {
  return e === af || e === sf;
}
function Ml(e) {
  return e === ou || e === _1;
}
var Cs = [0, 0, 0, 0], tL = (function() {
  function e(t) {
    this.keyframes = [], this.discrete = !1, this._invalid = !1, this._needsSort = !1, this._lastFr = 0, this._lastFrP = 0, this.propName = t;
  }
  return e.prototype.isFinished = function() {
    return this._finished;
  }, e.prototype.setFinished = function() {
    this._finished = !0, this._additiveTrack && this._additiveTrack.setFinished();
  }, e.prototype.needsAnimate = function() {
    return this.keyframes.length >= 1;
  }, e.prototype.getAdditiveTrack = function() {
    return this._additiveTrack;
  }, e.prototype.addKeyframe = function(t, i, n) {
    this._needsSort = !0;
    var r = this.keyframes, a = r.length, s = !1, o = $m, l = i;
    if (Xe(i)) {
      var u = JP(i);
      o = u, (u === 1 && !Zt(i[0]) || u === 2 && !Zt(i[0][0])) && (s = !0);
    } else if (Zt(i) && !e1(i))
      o = Sl;
    else if (et(i))
      if (!isNaN(+i))
        o = Sl;
      else {
        var c = Sn(i);
        c && (l = c, o = eo);
      }
    else if (kc(i)) {
      var h = Y({}, l);
      h.colorStops = _t(i.colorStops, function(f) {
        return {
          offset: f.offset,
          color: Sn(f.color)
        };
      }), jP(i) ? o = af : qP(i) && (o = sf), l = h;
    }
    a === 0 ? this.valType = o : (o !== this.valType || o === $m) && (s = !0), this.discrete = this.discrete || s;
    var d = {
      time: t,
      value: l,
      rawValue: i,
      percent: 0
    };
    return n && (d.easing = n, d.easingFunc = mt(n) ? n : go[n] || g1(n)), r.push(d), d;
  }, e.prototype.prepare = function(t, i) {
    var n = this.keyframes;
    this._needsSort && n.sort(function(m, p) {
      return m.time - p.time;
    });
    for (var r = this.valType, a = n.length, s = n[a - 1], o = this.discrete, l = Ml(r), u = zm(r), c = 0; c < a; c++) {
      var h = n[c], d = h.value, f = s.value;
      h.percent = h.time / t, o || (l && c !== a - 1 ? QP(d, f, r) : u && KP(d.colorStops, f.colorStops));
    }
    if (!o && r !== sf && i && this.needsAnimate() && i.needsAnimate() && r === i.valType && !i._finished) {
      this._additiveTrack = i;
      for (var v = n[0].value, c = 0; c < a; c++)
        r === Sl ? n[c].additiveValue = n[c].value - v : r === eo ? n[c].additiveValue = wl([], n[c].value, v, -1) : Ml(r) && (n[c].additiveValue = r === ou ? wl([], n[c].value, v, -1) : Bm([], n[c].value, v, -1));
    }
  }, e.prototype.step = function(t, i) {
    if (!this._finished) {
      this._additiveTrack && this._additiveTrack._finished && (this._additiveTrack = null);
      var n = this._additiveTrack != null, r = n ? "additiveValue" : "value", a = this.valType, s = this.keyframes, o = s.length, l = this.propName, u = a === eo, c, h = this._lastFr, d = Math.min, f, v;
      if (o === 1)
        f = v = s[0];
      else {
        if (i < 0)
          c = 0;
        else if (i < this._lastFrP) {
          var m = d(h + 1, o - 1);
          for (c = m; c >= 0 && !(s[c].percent <= i); c--)
            ;
          c = d(c, o - 2);
        } else {
          for (c = h; c < o && !(s[c].percent > i); c++)
            ;
          c = d(c - 1, o - 2);
        }
        v = s[c + 1], f = s[c];
      }
      if (f && v) {
        this._lastFr = c, this._lastFrP = i;
        var p = v.percent - f.percent, g = p === 0 ? 1 : d((i - f.percent) / p, 1);
        v.easingFunc && (g = v.easingFunc(g));
        var y = n ? this._additiveValue : u ? Cs : t[l];
        if ((Ml(a) || u) && !y && (y = this._additiveValue = []), this.discrete)
          t[l] = g < 1 ? f.rawValue : v.rawValue;
        else if (Ml(a))
          a === ou ? kh(y, f[r], v[r], g) : ZP(y, f[r], v[r], g);
        else if (zm(a)) {
          var _ = f[r], b = v[r], w = a === af;
          t[l] = {
            type: w ? "linear" : "radial",
            x: vn(_.x, b.x, g),
            y: vn(_.y, b.y, g),
            colorStops: _t(_.colorStops, function(M, k) {
              var T = b.colorStops[k];
              return {
                offset: vn(M.offset, T.offset, g),
                color: su(kh([], M.color, T.color, g))
              };
            }),
            global: b.global
          }, w ? (t[l].x2 = vn(_.x2, b.x2, g), t[l].y2 = vn(_.y2, b.y2, g)) : t[l].r = vn(_.r, b.r, g);
        } else if (u)
          kh(y, f[r], v[r], g), n || (t[l] = su(y));
        else {
          var S = vn(f[r], v[r], g);
          n ? this._additiveValue = S : t[l] = S;
        }
        n && this._addToTarget(t);
      }
    }
  }, e.prototype._addToTarget = function(t) {
    var i = this.valType, n = this.propName, r = this._additiveValue;
    i === Sl ? t[n] = t[n] + r : i === eo ? (Sn(t[n], Cs), wl(Cs, Cs, r, 1), t[n] = su(Cs)) : i === ou ? wl(t[n], t[n], r, 1) : i === _1 && Bm(t[n], t[n], r, 1);
  }, e;
})(), Ev = (function() {
  function e(t, i, n, r) {
    if (this._tracks = {}, this._trackKeys = [], this._maxTime = 0, this._started = 0, this._clip = null, this._target = t, this._loop = i, i && r) {
      Kr("Can' use additive animation on looped animation.");
      return;
    }
    this._additiveAnimators = r, this._allowDiscrete = n;
  }
  return e.prototype.getMaxTime = function() {
    return this._maxTime;
  }, e.prototype.getDelay = function() {
    return this._delay;
  }, e.prototype.getLoop = function() {
    return this._loop;
  }, e.prototype.getTarget = function() {
    return this._target;
  }, e.prototype.changeTarget = function(t) {
    this._target = t;
  }, e.prototype.when = function(t, i, n) {
    return this.whenWithKeys(t, i, qt(i), n);
  }, e.prototype.whenWithKeys = function(t, i, n, r) {
    for (var a = this._tracks, s = 0; s < n.length; s++) {
      var o = n[s], l = a[o];
      if (!l) {
        l = a[o] = new tL(o);
        var u = void 0, c = this._getAdditiveTrack(o);
        if (c) {
          var h = c.keyframes, d = h[h.length - 1];
          u = d && d.value, c.valType === eo && u && (u = su(u));
        } else
          u = this._target[o];
        if (u == null)
          continue;
        t > 0 && l.addKeyframe(0, au(u), r), this._trackKeys.push(o);
      }
      l.addKeyframe(t, au(i[o]), r);
    }
    return this._maxTime = Math.max(this._maxTime, t), this;
  }, e.prototype.pause = function() {
    this._clip.pause(), this._paused = !0;
  }, e.prototype.resume = function() {
    this._clip.resume(), this._paused = !1;
  }, e.prototype.isPaused = function() {
    return !!this._paused;
  }, e.prototype.duration = function(t) {
    return this._maxTime = t, this._force = !0, this;
  }, e.prototype._doneCallback = function() {
    this._setTracksFinished(), this._clip = null;
    var t = this._doneCbs;
    if (t)
      for (var i = t.length, n = 0; n < i; n++)
        t[n].call(this);
  }, e.prototype._abortedCallback = function() {
    this._setTracksFinished();
    var t = this.animation, i = this._abortedCbs;
    if (t && t.removeClip(this._clip), this._clip = null, i)
      for (var n = 0; n < i.length; n++)
        i[n].call(this);
  }, e.prototype._setTracksFinished = function() {
    for (var t = this._tracks, i = this._trackKeys, n = 0; n < i.length; n++)
      t[i[n]].setFinished();
  }, e.prototype._getAdditiveTrack = function(t) {
    var i, n = this._additiveAnimators;
    if (n)
      for (var r = 0; r < n.length; r++) {
        var a = n[r].getTrack(t);
        a && (i = a);
      }
    return i;
  }, e.prototype.start = function(t) {
    if (!(this._started > 0)) {
      this._started = 1;
      for (var i = this, n = [], r = this._maxTime || 0, a = 0; a < this._trackKeys.length; a++) {
        var s = this._trackKeys[a], o = this._tracks[s], l = this._getAdditiveTrack(s), u = o.keyframes, c = u.length;
        if (o.prepare(r, l), o.needsAnimate())
          if (!this._allowDiscrete && o.discrete) {
            var h = u[c - 1];
            h && (i._target[o.propName] = h.rawValue), o.setFinished();
          } else
            n.push(o);
      }
      if (n.length || this._force) {
        var d = new YP({
          life: r,
          loop: this._loop,
          delay: this._delay || 0,
          onframe: function(f) {
            i._started = 2;
            var v = i._additiveAnimators;
            if (v) {
              for (var m = !1, p = 0; p < v.length; p++)
                if (v[p]._clip) {
                  m = !0;
                  break;
                }
              m || (i._additiveAnimators = null);
            }
            for (var p = 0; p < n.length; p++)
              n[p].step(i._target, f);
            var g = i._onframeCbs;
            if (g)
              for (var p = 0; p < g.length; p++)
                g[p](i._target, f);
          },
          ondestroy: function() {
            i._doneCallback();
          }
        });
        this._clip = d, this.animation && this.animation.addClip(d), t && d.setEasing(t);
      } else
        this._doneCallback();
      return this;
    }
  }, e.prototype.stop = function(t) {
    if (this._clip) {
      var i = this._clip;
      t && i.onframe(1), this._abortedCallback();
    }
  }, e.prototype.delay = function(t) {
    return this._delay = t, this;
  }, e.prototype.during = function(t) {
    return t && (this._onframeCbs || (this._onframeCbs = []), this._onframeCbs.push(t)), this;
  }, e.prototype.done = function(t) {
    return t && (this._doneCbs || (this._doneCbs = []), this._doneCbs.push(t)), this;
  }, e.prototype.aborted = function(t) {
    return t && (this._abortedCbs || (this._abortedCbs = []), this._abortedCbs.push(t)), this;
  }, e.prototype.getClip = function() {
    return this._clip;
  }, e.prototype.getTrack = function(t) {
    return this._tracks[t];
  }, e.prototype.getTracks = function() {
    var t = this;
    return _t(this._trackKeys, function(i) {
      return t._tracks[i];
    });
  }, e.prototype.stopTracks = function(t, i) {
    if (!t.length || !this._clip)
      return !0;
    for (var n = this._tracks, r = this._trackKeys, a = 0; a < t.length; a++) {
      var s = n[t[a]];
      s && !s.isFinished() && (i ? s.step(this._target, 1) : this._started === 1 && s.step(this._target, 0), s.setFinished());
    }
    for (var o = !0, a = 0; a < r.length; a++)
      if (!n[r[a]].isFinished()) {
        o = !1;
        break;
      }
    return o && this._abortedCallback(), o;
  }, e.prototype.saveTo = function(t, i, n) {
    if (t) {
      i = i || this._trackKeys;
      for (var r = 0; r < i.length; r++) {
        var a = i[r], s = this._tracks[a];
        if (!(!s || s.isFinished())) {
          var o = s.keyframes, l = o[n ? 0 : o.length - 1];
          l && (t[a] = au(l.rawValue));
        }
      }
    }
  }, e.prototype.__changeFinalValue = function(t, i) {
    i = i || qt(t);
    for (var n = 0; n < i.length; n++) {
      var r = i[n], a = this._tracks[r];
      if (a) {
        var s = a.keyframes;
        if (s.length > 1) {
          var o = s.pop();
          a.addKeyframe(o.time, t[r]), a.prepare(this._maxTime, a.getAdditiveTrack());
        }
      }
    }
  }, e;
})();
function Wa() {
  return (/* @__PURE__ */ new Date()).getTime();
}
var eL = (function(e) {
  Lt(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n._running = !1, n._time = 0, n._pausedTime = 0, n._pauseStart = 0, n._paused = !1, i = i || {}, n.stage = i.stage || {}, n;
  }
  return t.prototype.addClip = function(i) {
    i.animation && this.removeClip(i), this._head ? (this._tail.next = i, i.prev = this._tail, i.next = null, this._tail = i) : this._head = this._tail = i, i.animation = this;
  }, t.prototype.addAnimator = function(i) {
    i.animation = this;
    var n = i.getClip();
    n && this.addClip(n);
  }, t.prototype.removeClip = function(i) {
    if (i.animation) {
      var n = i.prev, r = i.next;
      n ? n.next = r : this._head = r, r ? r.prev = n : this._tail = n, i.next = i.prev = i.animation = null;
    }
  }, t.prototype.removeAnimator = function(i) {
    var n = i.getClip();
    n && this.removeClip(n), i.animation = null;
  }, t.prototype.update = function(i) {
    for (var n = Wa() - this._pausedTime, r = n - this._time, a = this._head; a; ) {
      var s = a.next, o = a.step(n, r);
      o && (a.ondestroy(), this.removeClip(a)), a = s;
    }
    this._time = n, i || (this.trigger("frame", r), this.stage.update && this.stage.update());
  }, t.prototype._startLoop = function() {
    var i = this;
    this._running = !0;
    function n() {
      i._running && (Au(n), !i._paused && i.update());
    }
    Au(n);
  }, t.prototype.start = function() {
    this._running || (this._time = Wa(), this._pausedTime = 0, this._startLoop());
  }, t.prototype.stop = function() {
    this._running = !1;
  }, t.prototype.pause = function() {
    this._paused || (this._pauseStart = Wa(), this._paused = !0);
  }, t.prototype.resume = function() {
    this._paused && (this._pausedTime += Wa() - this._pauseStart, this._paused = !1);
  }, t.prototype.clear = function() {
    for (var i = this._head; i; ) {
      var n = i.next;
      i.prev = i.next = i.animation = null, i = n;
    }
    this._head = this._tail = null;
  }, t.prototype.isFinished = function() {
    return this._head == null;
  }, t.prototype.animate = function(i, n) {
    n = n || {}, this.start();
    var r = new Ev(i, n.loop);
    return this.addAnimator(r), r;
  }, t;
})(Li), iL = 300, Dh = ot.domSupported, Th = (function() {
  var e = [
    "click",
    "dblclick",
    "mousewheel",
    "wheel",
    "mouseout",
    "mouseup",
    "mousedown",
    "mousemove",
    "contextmenu"
  ], t = [
    "touchstart",
    "touchend",
    "touchmove"
  ], i = {
    pointerdown: 1,
    pointerup: 1,
    pointermove: 1,
    pointerout: 1
  }, n = _t(e, function(r) {
    var a = r.replace("mouse", "pointer");
    return i.hasOwnProperty(a) ? a : r;
  });
  return {
    mouse: e,
    touch: t,
    pointer: n
  };
})(), Vm = {
  mouse: ["mousemove", "mouseup"],
  pointer: ["pointermove", "pointerup"]
}, Hm = !1;
function of(e) {
  var t = e.pointerType;
  return t === "pen" || t === "touch";
}
function nL(e) {
  e.touching = !0, e.touchTimer != null && (clearTimeout(e.touchTimer), e.touchTimer = null), e.touchTimer = setTimeout(function() {
    e.touching = !1, e.touchTimer = null;
  }, 700);
}
function Ch(e) {
  e && (e.zrByTouch = !0);
}
function rL(e, t) {
  return oi(e.dom, new aL(e, t), !0);
}
function b1(e, t) {
  for (var i = t, n = !1; i && i.nodeType !== 9 && !(n = i.domBelongToZr || i !== t && i === e.painterRoot); )
    i = i.parentNode;
  return n;
}
var aL = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.stopPropagation = ke, this.stopImmediatePropagation = ke, this.preventDefault = ke, this.type = i.type, this.target = this.currentTarget = t.dom, this.pointerType = i.pointerType, this.clientX = i.clientX, this.clientY = i.clientY;
  }
  return e;
})(), Si = {
  mousedown: function(e) {
    e = oi(this.dom, e), this.__mayPointerCapture = [e.zrX, e.zrY], this.trigger("mousedown", e);
  },
  mousemove: function(e) {
    e = oi(this.dom, e);
    var t = this.__mayPointerCapture;
    t && (e.zrX !== t[0] || e.zrY !== t[1]) && this.__togglePointerCapture(!0), this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    e = oi(this.dom, e), this.__togglePointerCapture(!1), this.trigger("mouseup", e);
  },
  mouseout: function(e) {
    e = oi(this.dom, e);
    var t = e.toElement || e.relatedTarget;
    b1(this, t) || (this.__pointerCapturing && (e.zrEventControl = "no_globalout"), this.trigger("mouseout", e));
  },
  wheel: function(e) {
    Hm = !0, e = oi(this.dom, e), this.trigger("mousewheel", e);
  },
  mousewheel: function(e) {
    Hm || (e = oi(this.dom, e), this.trigger("mousewheel", e));
  },
  touchstart: function(e) {
    e = oi(this.dom, e), Ch(e), this.__lastTouchMoment = /* @__PURE__ */ new Date(), this.handler.processGesture(e, "start"), Si.mousemove.call(this, e), Si.mousedown.call(this, e);
  },
  touchmove: function(e) {
    e = oi(this.dom, e), Ch(e), this.handler.processGesture(e, "change"), Si.mousemove.call(this, e);
  },
  touchend: function(e) {
    e = oi(this.dom, e), Ch(e), this.handler.processGesture(e, "end"), Si.mouseup.call(this, e), +/* @__PURE__ */ new Date() - +this.__lastTouchMoment < iL && Si.click.call(this, e);
  },
  pointerdown: function(e) {
    Si.mousedown.call(this, e);
  },
  pointermove: function(e) {
    of(e) || Si.mousemove.call(this, e);
  },
  pointerup: function(e) {
    Si.mouseup.call(this, e);
  },
  pointerout: function(e) {
    of(e) || Si.mouseout.call(this, e);
  }
};
E(["click", "dblclick", "contextmenu"], function(e) {
  Si[e] = function(t) {
    t = oi(this.dom, t), this.trigger(e, t);
  };
});
var lf = {
  pointermove: function(e) {
    of(e) || lf.mousemove.call(this, e);
  },
  pointerup: function(e) {
    lf.mouseup.call(this, e);
  },
  mousemove: function(e) {
    this.trigger("mousemove", e);
  },
  mouseup: function(e) {
    var t = this.__pointerCapturing;
    this.__togglePointerCapture(!1), this.trigger("mouseup", e), t && (e.zrEventControl = "only_globalout", this.trigger("mouseout", e));
  }
};
function sL(e, t) {
  var i = t.domHandlers;
  ot.pointerEventsSupported ? E(Th.pointer, function(n) {
    lu(t, n, function(r) {
      i[n].call(e, r);
    });
  }) : (ot.touchEventsSupported && E(Th.touch, function(n) {
    lu(t, n, function(r) {
      i[n].call(e, r), nL(t);
    });
  }), E(Th.mouse, function(n) {
    lu(t, n, function(r) {
      r = kv(r), t.touching || i[n].call(e, r);
    });
  }));
}
function oL(e, t) {
  ot.pointerEventsSupported ? E(Vm.pointer, i) : ot.touchEventsSupported || E(Vm.mouse, i);
  function i(n) {
    function r(a) {
      a = kv(a), b1(e, a.target) || (a = rL(e, a), t.domHandlers[n].call(e, a));
    }
    lu(t, n, r, { capture: !0 });
  }
}
function lu(e, t, i, n) {
  e.mounted[t] = i, e.listenerOpts[t] = n, bP(e.domTarget, t, i, n);
}
function Eh(e) {
  var t = e.mounted;
  for (var i in t)
    t.hasOwnProperty(i) && xP(e.domTarget, i, t[i], e.listenerOpts[i]);
  e.mounted = {};
}
var Ym = /* @__PURE__ */ (function() {
  function e(t, i) {
    this.mounted = {}, this.listenerOpts = {}, this.touching = !1, this.domTarget = t, this.domHandlers = i;
  }
  return e;
})(), lL = (function(e) {
  Lt(t, e);
  function t(i, n) {
    var r = e.call(this) || this;
    return r.__pointerCapturing = !1, r.dom = i, r.painterRoot = n, r._localHandlerScope = new Ym(i, Si), Dh && (r._globalHandlerScope = new Ym(document, lf)), sL(r, r._localHandlerScope), r;
  }
  return t.prototype.dispose = function() {
    Eh(this._localHandlerScope), Dh && Eh(this._globalHandlerScope);
  }, t.prototype.setCursor = function(i) {
    this.dom.style && (this.dom.style.cursor = i || "default");
  }, t.prototype.__togglePointerCapture = function(i) {
    if (this.__mayPointerCapture = null, Dh && +this.__pointerCapturing ^ +i) {
      this.__pointerCapturing = i;
      var n = this._globalHandlerScope;
      i ? oL(this, n) : Eh(n);
    }
  }, t;
})(Li), x1 = 1;
ot.hasGlobalWindow && (x1 = Math.max(window.devicePixelRatio || window.screen && window.screen.deviceXDPI / window.screen.logicalXDPI || 1, 1));
var Nu = x1, uf = 0.4, cf = "#333", hf = "#ccc", uL = "#eee", Wm = Dv, Um = 5e-5;
function gr(e) {
  return e > Um || e < -Um;
}
var mr = [], wa = [], Ah = Ki(), Ph = Math.abs, Wr = (function() {
  function e() {
  }
  return e.prototype.getLocalTransform = function(t) {
    return e.getLocalTransform(this, t);
  }, e.prototype.setPosition = function(t) {
    this.x = t[0], this.y = t[1];
  }, e.prototype.setScale = function(t) {
    this.scaleX = t[0], this.scaleY = t[1];
  }, e.prototype.setSkew = function(t) {
    this.skewX = t[0], this.skewY = t[1];
  }, e.prototype.setOrigin = function(t) {
    this.originX = t[0], this.originY = t[1];
  }, e.prototype.needLocalTransform = function() {
    return gr(this.rotation) || gr(this.x) || gr(this.y) || gr(this.scaleX - 1) || gr(this.scaleY - 1) || gr(this.skewX) || gr(this.skewY);
  }, e.prototype.updateTransform = function() {
    var t = this.parent && this.parent.transform, i = this.needLocalTransform(), n = this.transform;
    if (!(i || t)) {
      n && (Wm(n), this.invTransform = null);
      return;
    }
    n = n || Ki(), i ? this.getLocalTransform(n) : Wm(n), t && (i ? vo(n, t, n) : Tv(n, t)), this.transform = n, this._resolveGlobalScaleRatio(n);
  }, e.prototype._resolveGlobalScaleRatio = function(t) {
    var i = this.globalScaleRatio;
    if (i != null && i !== 1) {
      this.getGlobalScale(mr);
      var n = mr[0] < 0 ? -1 : 1, r = mr[1] < 0 ? -1 : 1, a = ((mr[0] - n) * i + n) / mr[0] || 0, s = ((mr[1] - r) * i + r) / mr[1] || 0;
      t[0] *= a, t[1] *= a, t[2] *= s, t[3] *= s;
    }
    this.invTransform = this.invTransform || Ki(), qo(this.invTransform, t);
  }, e.prototype.getComputedTransform = function() {
    for (var t = this, i = []; t; )
      i.push(t), t = t.parent;
    for (; t = i.pop(); )
      t.updateTransform();
    return this.transform;
  }, e.prototype.setLocalTransform = function(t) {
    if (t) {
      var i = t[0] * t[0] + t[1] * t[1], n = t[2] * t[2] + t[3] * t[3], r = Math.atan2(t[1], t[0]), a = Math.PI / 2 + r - Math.atan2(t[3], t[2]);
      n = Math.sqrt(n) * Math.cos(a), i = Math.sqrt(i), this.skewX = a, this.skewY = 0, this.rotation = -r, this.x = +t[4], this.y = +t[5], this.scaleX = i, this.scaleY = n, this.originX = 0, this.originY = 0;
    }
  }, e.prototype.decomposeTransform = function() {
    if (this.transform) {
      var t = this.parent, i = this.transform;
      t && t.transform && (t.invTransform = t.invTransform || Ki(), vo(wa, t.invTransform, i), i = wa);
      var n = this.originX, r = this.originY;
      (n || r) && (Ah[4] = n, Ah[5] = r, vo(wa, i, Ah), wa[4] -= n, wa[5] -= r, i = wa), this.setLocalTransform(i);
    }
  }, e.prototype.getGlobalScale = function(t) {
    var i = this.transform;
    return t = t || [], i ? (t[0] = Math.sqrt(i[0] * i[0] + i[1] * i[1]), t[1] = Math.sqrt(i[2] * i[2] + i[3] * i[3]), i[0] < 0 && (t[0] = -t[0]), i[3] < 0 && (t[1] = -t[1]), t) : (t[0] = 1, t[1] = 1, t);
  }, e.prototype.transformCoordToLocal = function(t, i) {
    var n = [t, i], r = this.invTransform;
    return r && Je(n, n, r), n;
  }, e.prototype.transformCoordToGlobal = function(t, i) {
    var n = [t, i], r = this.transform;
    return r && Je(n, n, r), n;
  }, e.prototype.getLineScale = function() {
    var t = this.transform;
    return t && Ph(t[0] - 1) > 1e-10 && Ph(t[3] - 1) > 1e-10 ? Math.sqrt(Ph(t[0] * t[3] - t[2] * t[1])) : 1;
  }, e.prototype.copyTransform = function(t) {
    df(this, t);
  }, e.getLocalTransform = function(t, i) {
    i = i || [];
    var n = t.originX || 0, r = t.originY || 0, a = t.scaleX, s = t.scaleY, o = t.anchorX, l = t.anchorY, u = t.rotation || 0, c = t.x, h = t.y, d = t.skewX ? Math.tan(t.skewX) : 0, f = t.skewY ? Math.tan(-t.skewY) : 0;
    if (n || r || o || l) {
      var v = n + o, m = r + l;
      i[4] = -v * a - d * m * s, i[5] = -m * s - f * v * a;
    } else
      i[4] = i[5] = 0;
    return i[0] = a, i[3] = s, i[1] = f * a, i[2] = d * s, u && Cv(i, i, u), i[4] += n + c, i[5] += r + h, i;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.scaleX = t.scaleY = t.globalScaleRatio = 1, t.x = t.y = t.originX = t.originY = t.skewX = t.skewY = t.rotation = t.anchorX = t.anchorY = 0;
  })(), e;
})(), Po = [
  "x",
  "y",
  "originX",
  "originY",
  "anchorX",
  "anchorY",
  "rotation",
  "scaleX",
  "scaleY",
  "skewX",
  "skewY"
];
function df(e, t) {
  for (var i = 0; i < Po.length; i++) {
    var n = Po[i];
    e[n] = t[n];
  }
}
function Qi(e) {
  kl || (kl = new os(100)), e = e || nr;
  var t = kl.get(e);
  return t || (t = {
    font: e,
    strWidthCache: new os(500),
    asciiWidthMap: null,
    asciiWidthMapTried: !1,
    stWideCharWidth: Tn.measureText("", e).width,
    asciiCharWidth: Tn.measureText("a", e).width
  }, kl.put(e, t)), t;
}
var kl;
function cL(e) {
  if (!(Lh >= Gm)) {
    e = e || nr;
    for (var t = [], i = +/* @__PURE__ */ new Date(), n = 0; n <= 127; n++)
      t[n] = Tn.measureText(String.fromCharCode(n), e).width;
    var r = +/* @__PURE__ */ new Date() - i;
    return r > 16 ? Lh = Gm : r > 2 && Lh++, t;
  }
}
var Lh = 0, Gm = 5;
function w1(e, t) {
  return e.asciiWidthMapTried || (e.asciiWidthMap = cL(e.font), e.asciiWidthMapTried = !0), 0 <= t && t <= 127 ? e.asciiWidthMap != null ? e.asciiWidthMap[t] : e.asciiCharWidth : e.stWideCharWidth;
}
function Ji(e, t) {
  var i = e.strWidthCache, n = i.get(t);
  return n == null && (n = Tn.measureText(t, e.font).width, i.put(t, n)), n;
}
function Xm(e, t, i, n) {
  var r = Ji(Qi(t), e), a = Tc(t), s = ls(0, r, i), o = ea(0, a, n), l = new lt(s, o, r, a);
  return l;
}
function hL(e, t, i, n) {
  var r = ((e || "") + "").split(`
`), a = r.length;
  if (a === 1)
    return Xm(r[0], t, i, n);
  for (var s = new lt(0, 0, 0, 0), o = 0; o < r.length; o++) {
    var l = Xm(r[o], t, i, n);
    o === 0 ? s.copy(l) : s.union(l);
  }
  return s;
}
function ls(e, t, i, n) {
  return i === "right" ? n ? e += t : e -= t : i === "center" && (n ? e += t / 2 : e -= t / 2), e;
}
function ea(e, t, i, n) {
  return i === "middle" ? n ? e += t / 2 : e -= t / 2 : i === "bottom" && (n ? e += t : e -= t), e;
}
function Tc(e) {
  return Qi(e).stWideCharWidth;
}
function Lo(e, t) {
  return typeof e == "string" ? e.lastIndexOf("%") >= 0 ? parseFloat(e) / 100 * t : parseFloat(e) : e;
}
function S1(e, t, i) {
  var n = t.position || "inside", r = t.distance != null ? t.distance : 5, a = i.height, s = i.width, o = a / 2, l = i.x, u = i.y, c = "left", h = "top";
  if (n instanceof Array)
    l += Lo(n[0], i.width), u += Lo(n[1], i.height), c = null, h = null;
  else
    switch (n) {
      case "left":
        l -= r, u += o, c = "right", h = "middle";
        break;
      case "right":
        l += r + s, u += o, h = "middle";
        break;
      case "top":
        l += s / 2, u -= r, c = "center", h = "bottom";
        break;
      case "bottom":
        l += s / 2, u += a + r, c = "center";
        break;
      case "inside":
        l += s / 2, u += o, c = "center", h = "middle";
        break;
      case "insideLeft":
        l += r, u += o, h = "middle";
        break;
      case "insideRight":
        l += s - r, u += o, c = "right", h = "middle";
        break;
      case "insideTop":
        l += s / 2, u += r, c = "center";
        break;
      case "insideBottom":
        l += s / 2, u += a - r, c = "center", h = "bottom";
        break;
      case "insideTopLeft":
        l += r, u += r;
        break;
      case "insideTopRight":
        l += s - r, u += r, c = "right";
        break;
      case "insideBottomLeft":
        l += r, u += a - r, h = "bottom";
        break;
      case "insideBottomRight":
        l += s - r, u += a - r, c = "right", h = "bottom";
        break;
    }
  return e = e || {}, e.x = l, e.y = u, e.align = c, e.verticalAlign = h, e;
}
var Oh = "__zr_normal__", Ih = Po.concat(["ignore"]), dL = ps(Po, function(e, t) {
  return e[t] = !0, e;
}, { ignore: !1 }), Sa = {}, fL = new lt(0, 0, 0, 0), Dl = [], Cc = (function() {
  function e(t) {
    this.id = t1(), this.animators = [], this.currentStates = [], this.states = {}, this._init(t);
  }
  return e.prototype._init = function(t) {
    this.attr(t);
  }, e.prototype.drift = function(t, i, n) {
    switch (this.draggable) {
      case "horizontal":
        i = 0;
        break;
      case "vertical":
        t = 0;
        break;
    }
    var r = this.transform;
    r || (r = this.transform = [1, 0, 0, 1, 0, 0]), r[4] += t, r[5] += i, this.decomposeTransform(), this.markRedraw();
  }, e.prototype.beforeUpdate = function() {
  }, e.prototype.afterUpdate = function() {
  }, e.prototype.update = function() {
    this.updateTransform(), this.__dirty && this.updateInnerText();
  }, e.prototype.updateInnerText = function(t) {
    var i = this._textContent;
    if (i && (!i.ignore || t)) {
      this.textConfig || (this.textConfig = {});
      var n = this.textConfig, r = n.local, a = i.innerTransformable, s = void 0, o = void 0, l = !1;
      a.parent = r ? this : null;
      var u = !1;
      a.copyTransform(i);
      var c = n.position != null, h = n.autoOverflowArea, d = void 0;
      if ((h || c) && (d = fL, n.layoutRect ? d.copy(n.layoutRect) : d.copy(this.getBoundingRect()), r || d.applyTransform(this.transform)), c) {
        this.calculateTextPosition ? this.calculateTextPosition(Sa, n, d) : S1(Sa, n, d), a.x = Sa.x, a.y = Sa.y, s = Sa.align, o = Sa.verticalAlign;
        var f = n.origin;
        if (f && n.rotation != null) {
          var v = void 0, m = void 0;
          f === "center" ? (v = d.width * 0.5, m = d.height * 0.5) : (v = Lo(f[0], d.width), m = Lo(f[1], d.height)), u = !0, a.originX = -a.x + v + (r ? 0 : d.x), a.originY = -a.y + m + (r ? 0 : d.y);
        }
      }
      n.rotation != null && (a.rotation = n.rotation);
      var p = n.offset;
      p && (a.x += p[0], a.y += p[1], u || (a.originX = -p[0], a.originY = -p[1]));
      var g = this._innerTextDefaultStyle || (this._innerTextDefaultStyle = {});
      if (h) {
        var y = g.overflowRect = g.overflowRect || new lt(0, 0, 0, 0);
        a.getLocalTransform(Dl), qo(Dl, Dl), lt.copy(y, d), y.applyTransform(Dl);
      } else
        g.overflowRect = null;
      var _ = n.inside == null ? typeof n.position == "string" && n.position.indexOf("inside") >= 0 : n.inside, b = void 0, w = void 0, S = void 0;
      _ && this.canBeInsideText() ? (b = n.insideFill, w = n.insideStroke, (b == null || b === "auto") && (b = this.getInsideTextFill()), (w == null || w === "auto") && (w = this.getInsideTextStroke(b), S = !0)) : (b = n.outsideFill, w = n.outsideStroke, (b == null || b === "auto") && (b = this.getOutsideFill()), (w == null || w === "auto") && (w = this.getOutsideStroke(b), S = !0)), b = b || "#000", (b !== g.fill || w !== g.stroke || S !== g.autoStroke || s !== g.align || o !== g.verticalAlign) && (l = !0, g.fill = b, g.stroke = w, g.autoStroke = S, g.align = s, g.verticalAlign = o, i.setDefaultTextStyle(g)), i.__dirty |= Qe, l && i.dirtyStyle(!0);
    }
  }, e.prototype.canBeInsideText = function() {
    return !0;
  }, e.prototype.getInsideTextFill = function() {
    return "#fff";
  }, e.prototype.getInsideTextStroke = function(t) {
    return "#000";
  }, e.prototype.getOutsideFill = function() {
    return this.__zr && this.__zr.isDarkMode() ? hf : cf;
  }, e.prototype.getOutsideStroke = function(t) {
    var i = this.__zr && this.__zr.getBackgroundColor(), n = typeof i == "string" && Sn(i);
    n || (n = [255, 255, 255, 1]);
    for (var r = n[3], a = this.__zr.isDarkMode(), s = 0; s < 3; s++)
      n[s] = n[s] * r + (a ? 0 : 255) * (1 - r);
    return n[3] = 1, ta(n, "rgba");
  }, e.prototype.traverse = function(t, i) {
  }, e.prototype.attrKV = function(t, i) {
    t === "textConfig" ? this.setTextConfig(i) : t === "textContent" ? this.setTextContent(i) : t === "clipPath" ? this.setClipPath(i) : t === "extra" ? (this.extra = this.extra || {}, Y(this.extra, i)) : this[t] = i;
  }, e.prototype.hide = function() {
    this.ignore = !0, this.markRedraw();
  }, e.prototype.show = function() {
    this.ignore = !1, this.markRedraw();
  }, e.prototype.attr = function(t, i) {
    if (typeof t == "string")
      this.attrKV(t, i);
    else if (tt(t))
      for (var n = t, r = qt(n), a = 0; a < r.length; a++) {
        var s = r[a];
        this.attrKV(s, t[s]);
      }
    return this.markRedraw(), this;
  }, e.prototype.saveCurrentToNormalState = function(t) {
    this._innerSaveToNormal(t);
    for (var i = this._normalState, n = 0; n < this.animators.length; n++) {
      var r = this.animators[n], a = r.__fromStateTransition;
      if (!(r.getLoop() || a && a !== Oh)) {
        var s = r.targetName, o = s ? i[s] : i;
        r.saveTo(o);
      }
    }
  }, e.prototype._innerSaveToNormal = function(t) {
    var i = this._normalState;
    i || (i = this._normalState = {}), t.textConfig && !i.textConfig && (i.textConfig = this.textConfig), this._savePrimaryToNormal(t, i, Ih);
  }, e.prototype._savePrimaryToNormal = function(t, i, n) {
    for (var r = 0; r < n.length; r++) {
      var a = n[r];
      t[a] != null && !(a in i) && (i[a] = this[a]);
    }
  }, e.prototype.hasState = function() {
    return this.currentStates.length > 0;
  }, e.prototype.getState = function(t) {
    return this.states[t];
  }, e.prototype.ensureState = function(t) {
    var i = this.states;
    return i[t] || (i[t] = {}), i[t];
  }, e.prototype.clearStates = function(t) {
    this.useState(Oh, !1, t);
  }, e.prototype.useState = function(t, i, n, r) {
    var a = t === Oh, s = this.hasState();
    if (!(!s && a)) {
      var o = this.currentStates, l = this.stateTransition;
      if (!(Ht(o, t) >= 0 && (i || o.length === 1))) {
        var u;
        if (this.stateProxy && !a && (u = this.stateProxy(t)), u || (u = this.states && this.states[t]), !u && !a) {
          Kr("State " + t + " not exists.");
          return;
        }
        a || this.saveCurrentToNormalState(u);
        var c = !!(u && u.hoverLayer || r);
        c && this._toggleHoverLayerFlag(!0), this._applyStateObj(t, u, this._normalState, i, !n && !this.__inHover && l && l.duration > 0, l);
        var h = this._textContent, d = this._textGuide;
        return h && h.useState(t, i, n, c), d && d.useState(t, i, n, c), a ? (this.currentStates = [], this._normalState = {}) : i ? this.currentStates.push(t) : this.currentStates = [t], this._updateAnimationTargets(), this.markRedraw(), !c && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Qe), u;
      }
    }
  }, e.prototype.useStates = function(t, i, n) {
    if (!t.length)
      this.clearStates();
    else {
      var r = [], a = this.currentStates, s = t.length, o = s === a.length;
      if (o) {
        for (var l = 0; l < s; l++)
          if (t[l] !== a[l]) {
            o = !1;
            break;
          }
      }
      if (o)
        return;
      for (var l = 0; l < s; l++) {
        var u = t[l], c = void 0;
        this.stateProxy && (c = this.stateProxy(u, t)), c || (c = this.states[u]), c && r.push(c);
      }
      var h = r[s - 1], d = !!(h && h.hoverLayer || n);
      d && this._toggleHoverLayerFlag(!0);
      var f = this._mergeStates(r), v = this.stateTransition;
      this.saveCurrentToNormalState(f), this._applyStateObj(t.join(","), f, this._normalState, !1, !i && !this.__inHover && v && v.duration > 0, v);
      var m = this._textContent, p = this._textGuide;
      m && m.useStates(t, i, d), p && p.useStates(t, i, d), this._updateAnimationTargets(), this.currentStates = t.slice(), this.markRedraw(), !d && this.__inHover && (this._toggleHoverLayerFlag(!1), this.__dirty &= ~Qe);
    }
  }, e.prototype.isSilent = function() {
    for (var t = this; t; ) {
      if (t.silent)
        return !0;
      var i = t.__hostTarget;
      t = i ? t.ignoreHostSilent ? null : i : t.parent;
    }
    return !1;
  }, e.prototype._updateAnimationTargets = function() {
    for (var t = 0; t < this.animators.length; t++) {
      var i = this.animators[t];
      i.targetName && i.changeTarget(this[i.targetName]);
    }
  }, e.prototype.removeState = function(t) {
    var i = Ht(this.currentStates, t);
    if (i >= 0) {
      var n = this.currentStates.slice();
      n.splice(i, 1), this.useStates(n);
    }
  }, e.prototype.replaceState = function(t, i, n) {
    var r = this.currentStates.slice(), a = Ht(r, t), s = Ht(r, i) >= 0;
    a >= 0 ? s ? r.splice(a, 1) : r[a] = i : n && !s && r.push(i), this.useStates(r);
  }, e.prototype.toggleState = function(t, i) {
    i ? this.useState(t, !0) : this.removeState(t);
  }, e.prototype._mergeStates = function(t) {
    for (var i = {}, n, r = 0; r < t.length; r++) {
      var a = t[r];
      Y(i, a), a.textConfig && (n = n || {}, Y(n, a.textConfig));
    }
    return n && (i.textConfig = n), i;
  }, e.prototype._applyStateObj = function(t, i, n, r, a, s) {
    var o = !(i && r);
    i && i.textConfig ? (this.textConfig = Y({}, r ? this.textConfig : n.textConfig), Y(this.textConfig, i.textConfig)) : o && n.textConfig && (this.textConfig = n.textConfig);
    for (var l = {}, u = !1, c = 0; c < Ih.length; c++) {
      var h = Ih[c], d = a && dL[h];
      i && i[h] != null ? d ? (u = !0, l[h] = i[h]) : this[h] = i[h] : o && n[h] != null && (d ? (u = !0, l[h] = n[h]) : this[h] = n[h]);
    }
    if (!a)
      for (var c = 0; c < this.animators.length; c++) {
        var f = this.animators[c], v = f.targetName;
        f.getLoop() || f.__changeFinalValue(v ? (i || n)[v] : i || n);
      }
    u && this._transitionState(t, l, s);
  }, e.prototype._attachComponent = function(t) {
    if (t.__zr && !t.__hostTarget) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Text element has been added to zrender.");
      return;
    }
    if (t === this) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("Recursive component attachment.");
      return;
    }
    var i = this.__zr;
    i && t.addSelfToZr(i), t.__zr = i, t.__hostTarget = this;
  }, e.prototype._detachComponent = function(t) {
    t.__zr && t.removeSelfFromZr(t.__zr), t.__zr = null, t.__hostTarget = null;
  }, e.prototype.getClipPath = function() {
    return this._clipPath;
  }, e.prototype.setClipPath = function(t) {
    this._clipPath && this._clipPath !== t && this.removeClipPath(), this._attachComponent(t), this._clipPath = t, this.markRedraw();
  }, e.prototype.removeClipPath = function() {
    var t = this._clipPath;
    t && (this._detachComponent(t), this._clipPath = null, this.markRedraw());
  }, e.prototype.getTextContent = function() {
    return this._textContent;
  }, e.prototype.setTextContent = function(t) {
    var i = this._textContent;
    if (i !== t) {
      if (i && i !== t && this.removeTextContent(), process.env.NODE_ENV !== "production" && t.__zr && !t.__hostTarget)
        throw new Error("Text element has been added to zrender.");
      t.innerTransformable = new Wr(), this._attachComponent(t), this._textContent = t, this.markRedraw();
    }
  }, e.prototype.setTextConfig = function(t) {
    this.textConfig || (this.textConfig = {}), Y(this.textConfig, t), this.markRedraw();
  }, e.prototype.removeTextConfig = function() {
    this.textConfig = null, this.markRedraw();
  }, e.prototype.removeTextContent = function() {
    var t = this._textContent;
    t && (t.innerTransformable = null, this._detachComponent(t), this._textContent = null, this._innerTextDefaultStyle = null, this.markRedraw());
  }, e.prototype.getTextGuideLine = function() {
    return this._textGuide;
  }, e.prototype.setTextGuideLine = function(t) {
    this._textGuide && this._textGuide !== t && this.removeTextGuideLine(), this._attachComponent(t), this._textGuide = t, this.markRedraw();
  }, e.prototype.removeTextGuideLine = function() {
    var t = this._textGuide;
    t && (this._detachComponent(t), this._textGuide = null, this.markRedraw());
  }, e.prototype.markRedraw = function() {
    this.__dirty |= Qe;
    var t = this.__zr;
    t && (this.__inHover ? t.refreshHover() : t.refresh()), this.__hostTarget && this.__hostTarget.markRedraw();
  }, e.prototype.dirty = function() {
    this.markRedraw();
  }, e.prototype._toggleHoverLayerFlag = function(t) {
    this.__inHover = t;
    var i = this._textContent, n = this._textGuide;
    i && (i.__inHover = t), n && (n.__inHover = t);
  }, e.prototype.addSelfToZr = function(t) {
    if (this.__zr !== t) {
      this.__zr = t;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.addAnimator(i[n]);
      this._clipPath && this._clipPath.addSelfToZr(t), this._textContent && this._textContent.addSelfToZr(t), this._textGuide && this._textGuide.addSelfToZr(t);
    }
  }, e.prototype.removeSelfFromZr = function(t) {
    if (this.__zr) {
      this.__zr = null;
      var i = this.animators;
      if (i)
        for (var n = 0; n < i.length; n++)
          t.animation.removeAnimator(i[n]);
      this._clipPath && this._clipPath.removeSelfFromZr(t), this._textContent && this._textContent.removeSelfFromZr(t), this._textGuide && this._textGuide.removeSelfFromZr(t);
    }
  }, e.prototype.animate = function(t, i, n) {
    var r = t ? this[t] : this;
    if (process.env.NODE_ENV !== "production" && !r) {
      Kr('Property "' + t + '" is not existed in element ' + this.id);
      return;
    }
    var a = new Ev(r, i, n);
    return t && (a.targetName = t), this.addAnimator(a, t), a;
  }, e.prototype.addAnimator = function(t, i) {
    var n = this.__zr, r = this;
    t.during(function() {
      r.updateDuringAnimation(i);
    }).done(function() {
      var a = r.animators, s = Ht(a, t);
      s >= 0 && a.splice(s, 1);
    }), this.animators.push(t), n && n.animation.addAnimator(t), n && n.wakeUp();
  }, e.prototype.updateDuringAnimation = function(t) {
    this.markRedraw();
  }, e.prototype.stopAnimation = function(t, i) {
    for (var n = this.animators, r = n.length, a = [], s = 0; s < r; s++) {
      var o = n[s];
      !t || t === o.scope ? o.stop(i) : a.push(o);
    }
    return this.animators = a, this;
  }, e.prototype.animateTo = function(t, i, n) {
    Rh(this, t, i, n);
  }, e.prototype.animateFrom = function(t, i, n) {
    Rh(this, t, i, n, !0);
  }, e.prototype._transitionState = function(t, i, n, r) {
    for (var a = Rh(this, i, n, r), s = 0; s < a.length; s++)
      a[s].__fromStateTransition = t;
  }, e.prototype.getBoundingRect = function() {
    return null;
  }, e.prototype.getPaintRect = function() {
    return null;
  }, e.initDefaultProps = (function() {
    var t = e.prototype;
    t.type = "element", t.name = "", t.ignore = t.silent = t.ignoreHostSilent = t.isGroup = t.draggable = t.dragging = t.ignoreClip = t.__inHover = !1, t.__dirty = Qe;
    var i = {};
    function n(a, s, o) {
      i[a + s + o] || (console.warn("DEPRECATED: '" + a + "' has been deprecated. use '" + s + "', '" + o + "' instead"), i[a + s + o] = !0);
    }
    function r(a, s, o, l) {
      Object.defineProperty(t, a, {
        get: function() {
          if (process.env.NODE_ENV !== "production" && n(a, o, l), !this[s]) {
            var c = this[s] = [];
            u(this, c);
          }
          return this[s];
        },
        set: function(c) {
          process.env.NODE_ENV !== "production" && n(a, o, l), this[o] = c[0], this[l] = c[1], this[s] = c, u(this, c);
        }
      });
      function u(c, h) {
        Object.defineProperty(h, 0, {
          get: function() {
            return c[o];
          },
          set: function(d) {
            c[o] = d;
          }
        }), Object.defineProperty(h, 1, {
          get: function() {
            return c[l];
          },
          set: function(d) {
            c[l] = d;
          }
        });
      }
    }
    Object.defineProperty && (r("position", "_legacyPos", "x", "y"), r("scale", "_legacyScale", "scaleX", "scaleY"), r("origin", "_legacyOrigin", "originX", "originY"));
  })(), e;
})();
Pi(Cc, Li);
Pi(Cc, Wr);
function Rh(e, t, i, n, r) {
  i = i || {};
  var a = [];
  M1(e, "", e, t, i, n, a, r);
  var s = a.length, o = !1, l = i.done, u = i.aborted, c = function() {
    o = !0, s--, s <= 0 && (o ? l && l() : u && u());
  }, h = function() {
    s--, s <= 0 && (o ? l && l() : u && u());
  };
  s || l && l(), a.length > 0 && i.during && a[0].during(function(v, m) {
    i.during(m);
  });
  for (var d = 0; d < a.length; d++) {
    var f = a[d];
    c && f.done(c), h && f.aborted(h), i.force && f.duration(i.duration), f.start(i.easing);
  }
  return a;
}
function Nh(e, t, i) {
  for (var n = 0; n < i; n++)
    e[n] = t[n];
}
function vL(e) {
  return Xe(e[0]);
}
function pL(e, t, i) {
  if (Xe(t[i]))
    if (Xe(e[i]) || (e[i] = []), Ne(t[i])) {
      var n = t[i].length;
      e[i].length !== n && (e[i] = new t[i].constructor(n), Nh(e[i], t[i], n));
    } else {
      var r = t[i], a = e[i], s = r.length;
      if (vL(r))
        for (var o = r[0].length, l = 0; l < s; l++)
          a[l] ? Nh(a[l], r[l], o) : a[l] = Array.prototype.slice.call(r[l]);
      else
        Nh(a, r, s);
      a.length = r.length;
    }
  else
    e[i] = t[i];
}
function gL(e, t) {
  return e === t || Xe(e) && Xe(t) && mL(e, t);
}
function mL(e, t) {
  var i = e.length;
  if (i !== t.length)
    return !1;
  for (var n = 0; n < i; n++)
    if (e[n] !== t[n])
      return !1;
  return !0;
}
function M1(e, t, i, n, r, a, s, o) {
  for (var l = qt(n), u = r.duration, c = r.delay, h = r.additive, d = r.setToFinal, f = !tt(a), v = e.animators, m = [], p = 0; p < l.length; p++) {
    var g = l[p], y = n[g];
    if (y != null && i[g] != null && (f || a[g]))
      if (tt(y) && !Xe(y) && !kc(y)) {
        if (t) {
          o || (i[g] = y, e.updateDuringAnimation(t));
          continue;
        }
        M1(e, g, i[g], y, r, a && a[g], s, o);
      } else
        m.push(g);
    else o || (i[g] = y, e.updateDuringAnimation(t), m.push(g));
  }
  var _ = m.length;
  if (!h && _)
    for (var b = 0; b < v.length; b++) {
      var w = v[b];
      if (w.targetName === t) {
        var S = w.stopTracks(m);
        if (S) {
          var M = Ht(v, w);
          v.splice(M, 1);
        }
      }
    }
  if (r.force || (m = Ke(m, function(C) {
    return !gL(n[C], i[C]);
  }), _ = m.length), _ > 0 || r.force && !s.length) {
    var k = void 0, T = void 0, D = void 0;
    if (o) {
      T = {}, d && (k = {});
      for (var b = 0; b < _; b++) {
        var g = m[b];
        T[g] = i[g], d ? k[g] = n[g] : i[g] = n[g];
      }
    } else if (d) {
      D = {};
      for (var b = 0; b < _; b++) {
        var g = m[b];
        D[g] = au(i[g]), pL(i, n, g);
      }
    }
    var w = new Ev(i, !1, !1, h ? Ke(v, function(P) {
      return P.targetName === t;
    }) : null);
    w.targetName = t, r.scope && (w.scope = r.scope), d && k && w.whenWithKeys(0, k, m), D && w.whenWithKeys(0, D, m), w.whenWithKeys(u ?? 500, o ? T : n, m).delay(c || 0), e.addAnimator(w, t), s.push(w);
  }
}
var Ci = (function(e) {
  Lt(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.isGroup = !0, n._children = [], n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.children = function() {
    return this._children.slice();
  }, t.prototype.childAt = function(i) {
    return this._children[i];
  }, t.prototype.childOfName = function(i) {
    for (var n = this._children, r = 0; r < n.length; r++)
      if (n[r].name === i)
        return n[r];
  }, t.prototype.childCount = function() {
    return this._children.length;
  }, t.prototype.add = function(i) {
    if (i && (i !== this && i.parent !== this && (this._children.push(i), this._doAdd(i)), process.env.NODE_ENV !== "production" && i.__hostTarget))
      throw "This elemenet has been used as an attachment";
    return this;
  }, t.prototype.addBefore = function(i, n) {
    if (i && i !== this && i.parent !== this && n && n.parent === this) {
      var r = this._children, a = r.indexOf(n);
      a >= 0 && (r.splice(a, 0, i), this._doAdd(i));
    }
    return this;
  }, t.prototype.replace = function(i, n) {
    var r = Ht(this._children, i);
    return r >= 0 && this.replaceAt(n, r), this;
  }, t.prototype.replaceAt = function(i, n) {
    var r = this._children, a = r[n];
    if (i && i !== this && i.parent !== this && i !== a) {
      r[n] = i, a.parent = null;
      var s = this.__zr;
      s && a.removeSelfFromZr(s), this._doAdd(i);
    }
    return this;
  }, t.prototype._doAdd = function(i) {
    i.parent && i.parent.remove(i), i.parent = this;
    var n = this.__zr;
    n && n !== i.__zr && i.addSelfToZr(n), n && n.refresh();
  }, t.prototype.remove = function(i) {
    var n = this.__zr, r = this._children, a = Ht(r, i);
    return a < 0 ? this : (r.splice(a, 1), i.parent = null, n && i.removeSelfFromZr(n), n && n.refresh(), this);
  }, t.prototype.removeAll = function() {
    for (var i = this._children, n = this.__zr, r = 0; r < i.length; r++) {
      var a = i[r];
      n && a.removeSelfFromZr(n), a.parent = null;
    }
    return i.length = 0, this;
  }, t.prototype.eachChild = function(i, n) {
    for (var r = this._children, a = 0; a < r.length; a++) {
      var s = r[a];
      i.call(n, s, a);
    }
    return this;
  }, t.prototype.traverse = function(i, n) {
    for (var r = 0; r < this._children.length; r++) {
      var a = this._children[r], s = i.call(n, a);
      a.isGroup && !s && a.traverse(i, n);
    }
    return this;
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.addSelfToZr(i);
    }
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++) {
      var r = this._children[n];
      r.removeSelfFromZr(i);
    }
  }, t.prototype.getBoundingRect = function(i) {
    for (var n = new lt(0, 0, 0, 0), r = i || this._children, a = [], s = null, o = 0; o < r.length; o++) {
      var l = r[o];
      if (!(l.ignore || l.invisible)) {
        var u = l.getBoundingRect(), c = l.getLocalTransform(a);
        c ? (lt.applyTransform(n, u, c), s = s || n.clone(), s.union(n)) : (s = s || u.clone(), s.union(u));
      }
    }
    return s || n;
  }, t;
})(Cc);
Ci.prototype.type = "group";
var io = {}, k1 = {};
function yL(e) {
  delete k1[e];
}
function _L(e) {
  if (!e)
    return !1;
  if (typeof e == "string")
    return Ru(e, 1) < uf;
  if (e.colorStops) {
    for (var t = e.colorStops, i = 0, n = t.length, r = 0; r < n; r++)
      i += Ru(t[r].color, 1);
    return i /= n, i < uf;
  }
  return !1;
}
var bL = (function() {
  function e(t, i, n) {
    var r = this;
    this._sleepAfterStill = 10, this._stillFrameAccum = 0, this._needsRefresh = !0, this._needsRefreshHover = !0, this._darkMode = !1, n = n || {}, this.dom = i, this.id = t;
    var a = new NP(), s = n.renderer || "canvas";
    if (io[s] || (s = qt(io)[0]), process.env.NODE_ENV !== "production" && !io[s])
      throw new Error("Renderer '" + s + "' is not imported. Please import it first.");
    n.useDirtyRect = n.useDirtyRect == null ? !1 : n.useDirtyRect;
    var o = new io[s](i, a, n, t), l = n.ssr || o.ssrOnly;
    this.storage = a, this.painter = o;
    var u = !ot.node && !ot.worker && !l ? new lL(o.getViewportRoot(), o.root) : null, c = n.useCoarsePointer, h = c == null || c === "auto" ? ot.touchEventsSupported : !!c, d = 44, f;
    h && (f = rt(n.pointerSize, d)), this.handler = new l1(a, o, u, o.root, f), this.animation = new eL({
      stage: {
        update: l ? null : function() {
          return r._flush(!0);
        }
      }
    }), l || this.animation.start();
  }
  return e.prototype.add = function(t) {
    this._disposed || !t || (this.storage.addRoot(t), t.addSelfToZr(this), this.refresh());
  }, e.prototype.remove = function(t) {
    this._disposed || !t || (this.storage.delRoot(t), t.removeSelfFromZr(this), this.refresh());
  }, e.prototype.configLayer = function(t, i) {
    this._disposed || (this.painter.configLayer && this.painter.configLayer(t, i), this.refresh());
  }, e.prototype.setBackgroundColor = function(t) {
    this._disposed || (this.painter.setBackgroundColor && this.painter.setBackgroundColor(t), this.refresh(), this._backgroundColor = t, this._darkMode = _L(t));
  }, e.prototype.getBackgroundColor = function() {
    return this._backgroundColor;
  }, e.prototype.setDarkMode = function(t) {
    this._darkMode = t;
  }, e.prototype.isDarkMode = function() {
    return this._darkMode;
  }, e.prototype.refreshImmediately = function(t) {
    this._disposed || (t || this.animation.update(!0), this._needsRefresh = !1, this.painter.refresh(), this._needsRefresh = !1);
  }, e.prototype.refresh = function() {
    this._disposed || (this._needsRefresh = !0, this.animation.start());
  }, e.prototype.flush = function() {
    this._disposed || this._flush(!1);
  }, e.prototype._flush = function(t) {
    var i, n = Wa();
    this._needsRefresh && (i = !0, this.refreshImmediately(t)), this._needsRefreshHover && (i = !0, this.refreshHoverImmediately());
    var r = Wa();
    i ? (this._stillFrameAccum = 0, this.trigger("rendered", {
      elapsedTime: r - n
    })) : this._sleepAfterStill > 0 && (this._stillFrameAccum++, this._stillFrameAccum > this._sleepAfterStill && this.animation.stop());
  }, e.prototype.setSleepAfterStill = function(t) {
    this._sleepAfterStill = t;
  }, e.prototype.wakeUp = function() {
    this._disposed || (this.animation.start(), this._stillFrameAccum = 0);
  }, e.prototype.refreshHover = function() {
    this._needsRefreshHover = !0;
  }, e.prototype.refreshHoverImmediately = function() {
    this._disposed || (this._needsRefreshHover = !1, this.painter.refreshHover && this.painter.getType() === "canvas" && this.painter.refreshHover());
  }, e.prototype.resize = function(t) {
    this._disposed || (t = t || {}, this.painter.resize(t.width, t.height), this.handler.resize());
  }, e.prototype.clearAnimation = function() {
    this._disposed || this.animation.clear();
  }, e.prototype.getWidth = function() {
    if (!this._disposed)
      return this.painter.getWidth();
  }, e.prototype.getHeight = function() {
    if (!this._disposed)
      return this.painter.getHeight();
  }, e.prototype.setCursorStyle = function(t) {
    this._disposed || this.handler.setCursorStyle(t);
  }, e.prototype.findHover = function(t, i) {
    if (!this._disposed)
      return this.handler.findHover(t, i);
  }, e.prototype.on = function(t, i, n) {
    return this._disposed || this.handler.on(t, i, n), this;
  }, e.prototype.off = function(t, i) {
    this._disposed || this.handler.off(t, i);
  }, e.prototype.trigger = function(t, i) {
    this._disposed || this.handler.trigger(t, i);
  }, e.prototype.clear = function() {
    if (!this._disposed) {
      for (var t = this.storage.getRoots(), i = 0; i < t.length; i++)
        t[i] instanceof Ci && t[i].removeSelfFromZr(this);
      this.storage.delAllRoots(), this.painter.clear();
    }
  }, e.prototype.dispose = function() {
    this._disposed || (this.animation.stop(), this.clear(), this.storage.dispose(), this.painter.dispose(), this.handler.dispose(), this.animation = this.storage = this.painter = this.handler = null, this._disposed = !0, yL(this.id));
  }, e;
})();
function jm(e, t) {
  var i = new bL(t1(), e, t);
  return k1[i.id] = i, i;
}
function xL(e, t) {
  io[e] = t;
}
var qm = 1e-4, D1 = 20;
function wL(e) {
  return e.replace(/^\s+|\s+$/g, "");
}
var Oo = Math.min, ki = Math.max, _n = Math.abs;
function Io(e, t, i, n) {
  var r = t[0], a = t[1], s = i[0], o = i[1], l = a - r, u = o - s;
  if (l === 0)
    return u === 0 ? s : (s + o) / 2;
  if (l > 0) {
    if (e <= r)
      return s;
    if (e >= a)
      return o;
  } else {
    if (e >= r)
      return s;
    if (e <= a)
      return o;
  }
  return (e - r) / l * u + s;
}
var Ye = SL;
function SL(e, t, i) {
  switch (e) {
    case "center":
    case "middle":
      e = "50%";
      break;
    case "left":
    case "top":
      e = "0%";
      break;
    case "right":
    case "bottom":
      e = "100%";
      break;
  }
  return ML(e, t, i);
}
function ML(e, t, i) {
  return et(e) ? wL(e).match(/%$/) ? parseFloat(e) / 100 * t + (i || 0) : parseFloat(e) : e == null ? NaN : +e;
}
function kL(e, t, i) {
  return t == null && (t = 10), t = Math.min(Math.max(0, t), D1), e = (+e).toFixed(t), i ? e : +e;
}
function Zm(e) {
  if (e = +e, isNaN(e))
    return 0;
  if (e > 1e-14) {
    for (var t = 1, i = 0; i < 15; i++, t *= 10)
      if (Math.round(e * t) / t === e)
        return i;
  }
  return DL(e);
}
function DL(e) {
  var t = e.toString().toLowerCase(), i = t.indexOf("e"), n = i > 0 ? +t.slice(i + 1) : 0, r = i > 0 ? i : t.length, a = t.indexOf("."), s = a < 0 ? 0 : r - 1 - a;
  return Math.max(0, s - n);
}
function TL(e, t) {
  var i = Math.max(Zm(e), Zm(t)), n = e + t;
  return i > D1 ? n : kL(n, i);
}
function T1(e) {
  var t = Math.PI * 2;
  return (e % t + t) % t;
}
function Fu(e) {
  return e > -qm && e < qm;
}
var CL = /^(?:(\d{4})(?:[-\/](\d{1,2})(?:[-\/](\d{1,2})(?:[T ](\d{1,2})(?::(\d{1,2})(?::(\d{1,2})(?:[.,](\d+))?)?)?(Z|[\+\-]\d\d:?\d\d)?)?)?)?)?$/;
function Ec(e) {
  if (e instanceof Date)
    return e;
  if (et(e)) {
    var t = CL.exec(e);
    if (!t)
      return /* @__PURE__ */ new Date(NaN);
    if (t[8]) {
      var i = +t[4] || 0;
      return t[8].toUpperCase() !== "Z" && (i -= +t[8].slice(0, 3)), new Date(Date.UTC(+t[1], +(t[2] || 1) - 1, +t[3] || 1, i, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0));
    } else
      return new Date(+t[1], +(t[2] || 1) - 1, +t[3] || 1, +t[4] || 0, +(t[5] || 0), +t[6] || 0, t[7] ? +t[7].substring(0, 3) : 0);
  } else if (e == null)
    return /* @__PURE__ */ new Date(NaN);
  return new Date(Math.round(e));
}
function Bu(e) {
  var t = parseFloat(e);
  return t == e && (t !== 0 || !et(e) || e.indexOf("x") <= 0) ? t : NaN;
}
function C1(e) {
  return !isNaN(Bu(e));
}
function E1() {
  return Math.round(Math.random() * 9);
}
function A1(e, t) {
  return t === 0 ? e : A1(t, e % t);
}
function Km(e, t) {
  return e == null ? t : t == null ? e : e * t / A1(e, t);
}
var EL = "[ECharts] ", Qm = {}, AL = typeof console < "u" && console.warn && console.log;
function Ac(e, t, i) {
  if (AL) {
    if (i) {
      if (Qm[t])
        return;
      Qm[t] = !0;
    }
    console[e](EL + t);
  }
}
function PL(e, t) {
  Ac("log", e, t);
}
function hi(e, t) {
  Ac("warn", e, t);
}
function Kt(e, t) {
  Ac("error", e, t);
}
function Cn(e) {
  process.env.NODE_ENV !== "production" && Ac("warn", "DEPRECATED: " + e, !0);
}
function ge(e, t, i) {
  process.env.NODE_ENV !== "production" && Cn((i ? "[" + i + "]" : "") + (e + " is deprecated; use " + t + " instead."));
}
function $u() {
  for (var e = [], t = 0; t < arguments.length; t++)
    e[t] = arguments[t];
  var i = "";
  if (process.env.NODE_ENV !== "production") {
    var n = function(r) {
      return r === void 0 ? "undefined" : r === 1 / 0 ? "Infinity" : r === -1 / 0 ? "-Infinity" : e1(r) ? "NaN" : r instanceof Date ? "Date(" + r.toISOString() + ")" : mt(r) ? "function () { ... }" : qA(r) ? r + "" : null;
    };
    i = _t(e, function(r) {
      if (et(r))
        return r;
      var a = n(r);
      if (a != null)
        return a;
      if (typeof JSON < "u" && JSON.stringify)
        try {
          return JSON.stringify(r, function(s, o) {
            var l = n(o);
            return l ?? o;
          });
        } catch {
          return "?";
        }
      else
        return "?";
    }).join(" ");
  }
  return i;
}
function We(e) {
  throw new Error(e);
}
var P1 = "series\0", LL = "\0_ec_\0";
function Ie(e) {
  return e instanceof Array ? e : e == null ? [] : [e];
}
function Jm(e, t, i) {
  if (e) {
    e[t] = e[t] || {}, e.emphasis = e.emphasis || {}, e.emphasis[t] = e.emphasis[t] || {};
    for (var n = 0, r = i.length; n < r; n++) {
      var a = i[n];
      !e.emphasis[t].hasOwnProperty(a) && e[t].hasOwnProperty(a) && (e.emphasis[t][a] = e[t][a]);
    }
  }
}
var t0 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "rich", "tag", "color", "textBorderColor", "textBorderWidth", "width", "height", "lineHeight", "align", "verticalAlign", "baseline", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY", "backgroundColor", "borderColor", "borderWidth", "borderRadius", "padding"];
function Zo(e) {
  return tt(e) && !K(e) && !(e instanceof Date) ? e.value : e;
}
function OL(e) {
  return tt(e) && !(e instanceof Array);
}
function IL(e, t, i) {
  var n = i === "normalMerge", r = i === "replaceMerge", a = i === "replaceAll";
  e = e || [], t = (t || []).slice();
  var s = ht();
  E(t, function(l, u) {
    if (!tt(l)) {
      t[u] = null;
      return;
    }
    process.env.NODE_ENV !== "production" && (l.id != null && !i0(l.id) && e0(l.id), l.name != null && !i0(l.name) && e0(l.name));
  });
  var o = RL(e, s, i);
  return (n || r) && NL(o, e, s, t), n && FL(o, t), n || r ? BL(o, t, r) : a && $L(o, t), zL(o), o;
}
function RL(e, t, i) {
  var n = [];
  if (i === "replaceAll")
    return n;
  for (var r = 0; r < e.length; r++) {
    var a = e[r];
    a && a.id != null && t.set(a.id, r), n.push({
      existing: i === "replaceMerge" || us(a) ? null : a,
      newOption: null,
      keyInfo: null,
      brandNew: null
    });
  }
  return n;
}
function NL(e, t, i, n) {
  E(n, function(r, a) {
    if (!(!r || r.id == null)) {
      var s = mo(r.id), o = i.get(s);
      if (o != null) {
        var l = e[o];
        nt(!l.newOption, 'Duplicated option on id "' + s + '".'), l.newOption = r, l.existing = t[o], n[a] = null;
      }
    }
  });
}
function FL(e, t) {
  E(t, function(i, n) {
    if (!(!i || i.name == null))
      for (var r = 0; r < e.length; r++) {
        var a = e[r].existing;
        if (!e[r].newOption && a && (a.id == null || i.id == null) && !us(i) && !us(a) && L1("name", a, i)) {
          e[r].newOption = i, t[n] = null;
          return;
        }
      }
  });
}
function BL(e, t, i) {
  E(t, function(n) {
    if (n) {
      for (
        var r, a = 0;
        // Be `!resultItem` only when `nextIdx >= result.length`.
        (r = e[a]) && (r.newOption || us(r.existing) || // In mode "replaceMerge", here no not-mapped-non-internal-existing.
        r.existing && n.id != null && !L1("id", n, r.existing));
      )
        a++;
      r ? (r.newOption = n, r.brandNew = i) : e.push({
        newOption: n,
        brandNew: i,
        existing: null,
        keyInfo: null
      }), a++;
    }
  });
}
function $L(e, t) {
  E(t, function(i) {
    e.push({
      newOption: i,
      brandNew: !0,
      existing: null,
      keyInfo: null
    });
  });
}
function zL(e) {
  var t = ht();
  E(e, function(i) {
    var n = i.existing;
    n && t.set(n.id, i);
  }), E(e, function(i) {
    var n = i.newOption;
    nt(!n || n.id == null || !t.get(n.id) || t.get(n.id) === i, "id duplicates: " + (n && n.id)), n && n.id != null && t.set(n.id, i), !i.keyInfo && (i.keyInfo = {});
  }), E(e, function(i, n) {
    var r = i.existing, a = i.newOption, s = i.keyInfo;
    if (tt(a)) {
      if (s.name = a.name != null ? mo(a.name) : r ? r.name : P1 + n, r)
        s.id = mo(r.id);
      else if (a.id != null)
        s.id = mo(a.id);
      else {
        var o = 0;
        do
          s.id = "\0" + s.name + "\0" + o++;
        while (t.get(s.id));
      }
      t.set(s.id, i);
    }
  });
}
function L1(e, t, i) {
  var n = Ti(t[e], null), r = Ti(i[e], null);
  return n != null && r != null && n === r;
}
function mo(e) {
  if (process.env.NODE_ENV !== "production" && e == null)
    throw new Error();
  return Ti(e, "");
}
function Ti(e, t) {
  return e == null ? t : et(e) ? e : Zt(e) || Tu(e) ? e + "" : t;
}
function e0(e) {
  process.env.NODE_ENV !== "production" && hi("`" + e + "` is invalid id or name. Must be a string or number.");
}
function i0(e) {
  return Tu(e) || C1(e);
}
function O1(e) {
  var t = e.name;
  return !!(t && t.indexOf(P1));
}
function us(e) {
  return e && e.id != null && mo(e.id).indexOf(LL) === 0;
}
function VL(e, t, i) {
  E(e, function(n) {
    var r = n.newOption;
    tt(r) && (n.keyInfo.mainType = t, n.keyInfo.subType = HL(t, r, n.existing, i));
  });
}
function HL(e, t, i, n) {
  var r = t.type ? t.type : i ? i.subType : n.determineSubType(e, t);
  return r;
}
function Ko(e, t) {
  if (t.dataIndexInside != null)
    return t.dataIndexInside;
  if (t.dataIndex != null)
    return K(t.dataIndex) ? _t(t.dataIndex, function(i) {
      return e.indexOfRawIndex(i);
    }) : e.indexOfRawIndex(t.dataIndex);
  if (t.name != null)
    return K(t.name) ? _t(t.name, function(i) {
      return e.indexOfName(i);
    }) : e.indexOfName(t.name);
}
function Gt() {
  var e = "__ec_inner_" + YL++;
  return function(t) {
    return t[e] || (t[e] = {});
  };
}
var YL = E1();
function Fh(e, t, i) {
  var n = Av(t, i), r = n.mainTypeSpecified, a = n.queryOptionMap, s = n.others, o = s, l = i ? i.defaultMainType : null;
  return !r && l && a.set(l, {}), a.each(function(u, c) {
    var h = Qo(e, c, u, {
      useDefault: l === c,
      enableAll: i && i.enableAll != null ? i.enableAll : !0,
      enableNone: i && i.enableNone != null ? i.enableNone : !0
    });
    o[c + "Models"] = h.models, o[c + "Model"] = h.models[0];
  }), o;
}
function Av(e, t) {
  var i;
  if (et(e)) {
    var n = {};
    n[e + "Index"] = 0, i = n;
  } else
    i = e;
  var r = ht(), a = {}, s = !1;
  return E(i, function(o, l) {
    if (l === "dataIndex" || l === "dataIndexInside") {
      a[l] = o;
      return;
    }
    var u = l.match(/^(\w+)(Index|Id|Name)$/) || [], c = u[1], h = (u[2] || "").toLowerCase();
    if (!(!c || !h || t && t.includeMainTypes && Ht(t.includeMainTypes, c) < 0)) {
      s = s || !!c;
      var d = r.get(c) || r.set(c, {});
      d[h] = o;
    }
  }), {
    mainTypeSpecified: s,
    queryOptionMap: r,
    others: a
  };
}
var Hn = {
  useDefault: !0,
  enableAll: !1,
  enableNone: !1
};
function Qo(e, t, i, n) {
  n = n || Hn;
  var r = i.index, a = i.id, s = i.name, o = {
    models: null,
    specified: r != null || a != null || s != null
  };
  if (!o.specified) {
    var l = void 0;
    return o.models = n.useDefault && (l = e.getComponent(t)) ? [l] : [], o;
  }
  if (r === "none" || r === !1) {
    if (n.enableNone)
      return o.models = [], o;
    process.env.NODE_ENV !== "production" && Kt('`"none"` or `false` is not a valid value on index option.'), r = -1;
  }
  return r === "all" && (n.enableAll ? r = a = s = null : (process.env.NODE_ENV !== "production" && Kt('`"all"` is not a valid value on index option.'), r = -1)), o.models = e.queryComponents({
    mainType: t,
    index: r,
    id: a,
    name: s
  }), o;
}
function I1(e, t, i) {
  e.setAttribute ? e.setAttribute(t, i) : e[t] = i;
}
function WL(e, t) {
  return e.getAttribute ? e.getAttribute(t) : e[t];
}
function UL(e) {
  return e === "auto" ? ot.domSupported ? "html" : "richText" : e || "html";
}
function GL(e, t) {
  var i = ht(), n = [];
  return E(e, function(r) {
    var a = t(r);
    (i.get(a) || (n.push(a), i.set(a, []))).push(r);
  }), {
    keys: n,
    buckets: i
  };
}
var XL = ".", yr = "___EC__COMPONENT__CONTAINER___", R1 = "___EC__EXTENDED_CLASS___";
function ji(e) {
  var t = {
    main: "",
    sub: ""
  };
  if (e) {
    var i = e.split(XL);
    t.main = i[0] || "", t.sub = i[1] || "";
  }
  return t;
}
function jL(e) {
  nt(/^[a-zA-Z0-9_]+([.][a-zA-Z0-9_]+)?$/.test(e), 'componentType "' + e + '" illegal');
}
function qL(e) {
  return !!(e && e[R1]);
}
function Pv(e, t) {
  e.$constructor = e, e.extend = function(i) {
    process.env.NODE_ENV !== "production" && E(t, function(a) {
      i[a] || console.warn("Method `" + a + "` should be implemented" + (i.type ? " in " + i.type : "") + ".");
    });
    var n = this, r;
    return ZL(n) ? r = /** @class */
    (function(a) {
      oe(s, a);
      function s() {
        return a.apply(this, arguments) || this;
      }
      return s;
    })(n) : (r = function() {
      (i.$constructor || n).apply(this, arguments);
    }, GA(r, this)), Y(r.prototype, i), r[R1] = !0, r.extend = this.extend, r.superCall = JL, r.superApply = tO, r.superClass = n, r;
  };
}
function ZL(e) {
  return mt(e) && /^class\s/.test(Function.prototype.toString.call(e));
}
function N1(e, t) {
  e.extend = t.extend;
}
var KL = Math.round(Math.random() * 10);
function QL(e) {
  var t = ["__\0is_clz", KL++].join("_");
  e.prototype[t] = !0, process.env.NODE_ENV !== "production" && nt(!e.isInstance, 'The method "is" can not be defined.'), e.isInstance = function(i) {
    return !!(i && i[t]);
  };
}
function JL(e, t) {
  for (var i = [], n = 2; n < arguments.length; n++)
    i[n - 2] = arguments[n];
  return this.superClass.prototype[t].apply(e, i);
}
function tO(e, t, i) {
  return this.superClass.prototype[t].apply(e, i);
}
function Lv(e) {
  var t = {};
  e.registerClass = function(n) {
    var r = n.type || n.prototype.type;
    if (r) {
      jL(r), n.prototype.type = r;
      var a = ji(r);
      if (!a.sub)
        process.env.NODE_ENV !== "production" && t[a.main] && console.warn(a.main + " exists."), t[a.main] = n;
      else if (a.sub !== yr) {
        var s = i(a);
        s[a.sub] = n;
      }
    }
    return n;
  }, e.getClass = function(n, r, a) {
    var s = t[n];
    if (s && s[yr] && (s = r ? s[r] : null), a && !s)
      throw new Error(r ? "Component " + n + "." + (r || "") + " is used but not imported." : n + ".type should be specified.");
    return s;
  }, e.getClassesByMainType = function(n) {
    var r = ji(n), a = [], s = t[r.main];
    return s && s[yr] ? E(s, function(o, l) {
      l !== yr && a.push(o);
    }) : a.push(s), a;
  }, e.hasClass = function(n) {
    var r = ji(n);
    return !!t[r.main];
  }, e.getAllClassMainTypes = function() {
    var n = [];
    return E(t, function(r, a) {
      n.push(a);
    }), n;
  }, e.hasSubTypes = function(n) {
    var r = ji(n), a = t[r.main];
    return a && a[yr];
  };
  function i(n) {
    var r = t[n.main];
    return (!r || !r[yr]) && (r = t[n.main] = {}, r[yr] = !0), r;
  }
}
function Ro(e, t) {
  for (var i = 0; i < e.length; i++)
    e[i][1] || (e[i][1] = e[i][0]);
  return t = t || !1, function(n, r, a) {
    for (var s = {}, o = 0; o < e.length; o++) {
      var l = e[o][1];
      if (!(r && Ht(r, l) >= 0 || a && Ht(a, l) < 0)) {
        var u = n.getShallow(l, t);
        u != null && (s[e[o][0]] = u);
      }
    }
    return s;
  };
}
var eO = [
  ["fill", "color"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["opacity"],
  ["shadowColor"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], iO = Ro(eO), nO = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getAreaStyle = function(t, i) {
      return iO(this, t, i);
    }, e;
  })()
), ff = new os(50);
function rO(e) {
  if (typeof e == "string") {
    var t = ff.get(e);
    return t && t.image;
  } else
    return e;
}
function F1(e, t, i, n, r) {
  if (e)
    if (typeof e == "string") {
      if (t && t.__zrImageSrc === e || !i)
        return t;
      var a = ff.get(e), s = { hostEl: i, cb: n, cbPayload: r };
      return a ? (t = a.image, !Pc(t) && a.pending.push(s)) : (t = Tn.loadImage(e, n0, n0), t.__zrImageSrc = e, ff.put(e, t.__cachedImgObj = {
        image: t,
        pending: [s]
      })), t;
    } else
      return e;
  else return t;
}
function n0() {
  var e = this.__cachedImgObj;
  this.onload = this.onerror = this.__cachedImgObj = null;
  for (var t = 0; t < e.pending.length; t++) {
    var i = e.pending[t], n = i.cb;
    n && n(this, i.cbPayload), i.hostEl.dirty();
  }
  e.pending.length = 0;
}
function Pc(e) {
  return e && e.width && e.height;
}
var Bh = /\{([a-zA-Z0-9_]+)\|([^}]*)\}/g;
function aO(e, t, i, n, r, a) {
  if (!i) {
    e.text = "", e.isTruncated = !1;
    return;
  }
  var s = (t + "").split(`
`);
  a = B1(i, n, r, a);
  for (var o = !1, l = {}, u = 0, c = s.length; u < c; u++)
    $1(l, s[u], a), s[u] = l.textLine, o = o || l.isTruncated;
  e.text = s.join(`
`), e.isTruncated = o;
}
function B1(e, t, i, n) {
  n = n || {};
  var r = Y({}, n);
  i = rt(i, "..."), r.maxIterations = rt(n.maxIterations, 2);
  var a = r.minChar = rt(n.minChar, 0), s = r.fontMeasureInfo = Qi(t), o = s.asciiCharWidth;
  r.placeholder = rt(n.placeholder, "");
  for (var l = e = Math.max(0, e - 1), u = 0; u < a && l >= o; u++)
    l -= o;
  var c = Ji(s, i);
  return c > l && (i = "", c = 0), l = e - c, r.ellipsis = i, r.ellipsisWidth = c, r.contentWidth = l, r.containerWidth = e, r;
}
function $1(e, t, i) {
  var n = i.containerWidth, r = i.contentWidth, a = i.fontMeasureInfo;
  if (!n) {
    e.textLine = "", e.isTruncated = !1;
    return;
  }
  var s = Ji(a, t);
  if (s <= n) {
    e.textLine = t, e.isTruncated = !1;
    return;
  }
  for (var o = 0; ; o++) {
    if (s <= r || o >= i.maxIterations) {
      t += i.ellipsis;
      break;
    }
    var l = o === 0 ? sO(t, r, a) : s > 0 ? Math.floor(t.length * r / s) : 0;
    t = t.substr(0, l), s = Ji(a, t);
  }
  t === "" && (t = i.placeholder), e.textLine = t, e.isTruncated = !0;
}
function sO(e, t, i) {
  for (var n = 0, r = 0, a = e.length; r < a && n < t; r++)
    n += w1(i, e.charCodeAt(r));
  return r;
}
function oO(e, t, i, n) {
  var r = Ov(e), a = t.overflow, s = t.padding, o = s ? s[1] + s[3] : 0, l = s ? s[0] + s[2] : 0, u = t.font, c = a === "truncate", h = Tc(u), d = rt(t.lineHeight, h), f = t.lineOverflow === "truncate", v = !1, m = t.width;
  m == null && i != null && (m = i - o);
  var p = t.height;
  p == null && n != null && (p = n - l);
  var g;
  m != null && (a === "break" || a === "breakAll") ? g = r ? z1(r, t.font, m, a === "breakAll", 0).lines : [] : g = r ? r.split(`
`) : [];
  var y = g.length * d;
  if (p == null && (p = y), y > p && f) {
    var _ = Math.floor(p / d);
    v = v || g.length > _, g = g.slice(0, _), y = g.length * d;
  }
  if (r && c && m != null)
    for (var b = B1(m, u, t.ellipsis, {
      minChar: t.truncateMinChar,
      placeholder: t.placeholder
    }), w = {}, S = 0; S < g.length; S++)
      $1(w, g[S], b), g[S] = w.textLine, v = v || w.isTruncated;
  for (var M = p, k = 0, T = Qi(u), S = 0; S < g.length; S++)
    k = Math.max(Ji(T, g[S]), k);
  m == null && (m = k);
  var D = m;
  return M += l, D += o, {
    lines: g,
    height: p,
    outerWidth: D,
    outerHeight: M,
    lineHeight: d,
    calculatedLineHeight: h,
    contentWidth: k,
    contentHeight: y,
    width: m,
    isTruncated: v
  };
}
var lO = /* @__PURE__ */ (function() {
  function e() {
  }
  return e;
})(), r0 = /* @__PURE__ */ (function() {
  function e(t) {
    this.tokens = [], t && (this.tokens = t);
  }
  return e;
})(), uO = /* @__PURE__ */ (function() {
  function e() {
    this.width = 0, this.height = 0, this.contentWidth = 0, this.contentHeight = 0, this.outerWidth = 0, this.outerHeight = 0, this.lines = [], this.isTruncated = !1;
  }
  return e;
})();
function cO(e, t, i, n, r) {
  var a = new uO(), s = Ov(e);
  if (!s)
    return a;
  var o = t.padding, l = o ? o[1] + o[3] : 0, u = o ? o[0] + o[2] : 0, c = t.width;
  c == null && i != null && (c = i - l);
  var h = t.height;
  h == null && n != null && (h = n - u);
  for (var d = t.overflow, f = (d === "break" || d === "breakAll") && c != null ? { width: c, accumWidth: 0, breakAll: d === "breakAll" } : null, v = Bh.lastIndex = 0, m; (m = Bh.exec(s)) != null; ) {
    var p = m.index;
    p > v && $h(a, s.substring(v, p), t, f), $h(a, m[2], t, f, m[1]), v = Bh.lastIndex;
  }
  v < s.length && $h(a, s.substring(v, s.length), t, f);
  var g = [], y = 0, _ = 0, b = d === "truncate", w = t.lineOverflow === "truncate", S = {};
  function M(Tt, me, Ae) {
    Tt.width = me, Tt.lineHeight = Ae, y += Ae, _ = Math.max(_, me);
  }
  t: for (var k = 0; k < a.lines.length; k++) {
    for (var T = a.lines[k], D = 0, C = 0, P = 0; P < T.tokens.length; P++) {
      var L = T.tokens[P], O = L.styleName && t.rich[L.styleName] || {}, N = L.textPadding = O.padding, B = N ? N[1] + N[3] : 0, G = L.font = O.font || t.font;
      L.contentHeight = Tc(G);
      var V = rt(O.height, L.contentHeight);
      if (L.innerHeight = V, N && (V += N[0] + N[2]), L.height = V, L.lineHeight = Qr(O.lineHeight, t.lineHeight, V), L.align = O && O.align || r, L.verticalAlign = O && O.verticalAlign || "middle", w && h != null && y + L.lineHeight > h) {
        var F = a.lines.length;
        P > 0 ? (T.tokens = T.tokens.slice(0, P), M(T, C, D), a.lines = a.lines.slice(0, k + 1)) : a.lines = a.lines.slice(0, k), a.isTruncated = a.isTruncated || a.lines.length < F;
        break t;
      }
      var $ = O.width, Z = $ == null || $ === "auto";
      if (typeof $ == "string" && $.charAt($.length - 1) === "%")
        L.percentWidth = $, g.push(L), L.contentWidth = Ji(Qi(G), L.text);
      else {
        if (Z) {
          var j = O.backgroundColor, it = j && j.image;
          it && (it = rO(it), Pc(it) && (L.width = Math.max(L.width, it.width * V / it.height)));
        }
        var st = b && c != null ? c - C : null;
        st != null && st < L.width ? !Z || st < B ? (L.text = "", L.width = L.contentWidth = 0) : (aO(S, L.text, st - B, G, t.ellipsis, { minChar: t.truncateMinChar }), L.text = S.text, a.isTruncated = a.isTruncated || S.isTruncated, L.width = L.contentWidth = Ji(Qi(G), L.text)) : L.contentWidth = Ji(Qi(G), L.text);
      }
      L.width += B, C += L.width, O && (D = Math.max(D, L.lineHeight));
    }
    M(T, C, D);
  }
  a.outerWidth = a.width = rt(c, _), a.outerHeight = a.height = rt(h, y), a.contentHeight = y, a.contentWidth = _, a.outerWidth += l, a.outerHeight += u;
  for (var k = 0; k < g.length; k++) {
    var L = g[k], wt = L.percentWidth;
    L.width = parseInt(wt, 10) / 100 * a.width;
  }
  return a;
}
function $h(e, t, i, n, r) {
  var a = t === "", s = r && i.rich[r] || {}, o = e.lines, l = s.font || i.font, u = !1, c, h;
  if (n) {
    var d = s.padding, f = d ? d[1] + d[3] : 0;
    if (s.width != null && s.width !== "auto") {
      var v = Lo(s.width, n.width) + f;
      o.length > 0 && v + n.accumWidth > n.width && (c = t.split(`
`), u = !0), n.accumWidth = v;
    } else {
      var m = z1(t, l, n.width, n.breakAll, n.accumWidth);
      n.accumWidth = m.accumWidth + f, h = m.linesWidths, c = m.lines;
    }
  }
  c || (c = t.split(`
`));
  for (var p = Qi(l), g = 0; g < c.length; g++) {
    var y = c[g], _ = new lO();
    if (_.styleName = r, _.text = y, _.isLineHolder = !y && !a, typeof s.width == "number" ? _.width = s.width : _.width = h ? h[g] : Ji(p, y), !g && !u) {
      var b = (o[o.length - 1] || (o[0] = new r0())).tokens, w = b.length;
      w === 1 && b[0].isLineHolder ? b[0] = _ : (y || !w || a) && b.push(_);
    } else
      o.push(new r0([_]));
  }
}
function hO(e) {
  var t = e.charCodeAt(0);
  return t >= 32 && t <= 591 || t >= 880 && t <= 4351 || t >= 4608 && t <= 5119 || t >= 7680 && t <= 8303;
}
var dO = ps(",&?/;] ".split(""), function(e, t) {
  return e[t] = !0, e;
}, {});
function fO(e) {
  return hO(e) ? !!dO[e] : !0;
}
function z1(e, t, i, n, r) {
  for (var a = [], s = [], o = "", l = "", u = 0, c = 0, h = Qi(t), d = 0; d < e.length; d++) {
    var f = e.charAt(d);
    if (f === `
`) {
      l && (o += l, c += u), a.push(o), s.push(c), o = "", l = "", u = 0, c = 0;
      continue;
    }
    var v = w1(h, f.charCodeAt(0)), m = n ? !1 : !fO(f);
    if (a.length ? c + v > i : r + c + v > i) {
      c ? (o || l) && (m ? (o || (o = l, l = "", u = 0, c = u), a.push(o), s.push(c - u), l += f, u += v, o = "", c = u) : (l && (o += l, l = "", u = 0), a.push(o), s.push(c), o = f, c = v)) : m ? (a.push(l), s.push(u), l = f, u = v) : (a.push(f), s.push(v));
      continue;
    }
    c += v, m ? (l += f, u += v) : (l && (o += l, l = "", u = 0), o += f);
  }
  return l && (o += l), o && (a.push(o), s.push(c)), a.length === 1 && (c += r), {
    accumWidth: c,
    lines: a,
    linesWidths: s
  };
}
function a0(e, t, i, n, r, a) {
  if (e.baseX = i, e.baseY = n, e.outerWidth = e.outerHeight = null, !!t) {
    var s = t.width * 2, o = t.height * 2;
    lt.set(s0, ls(i, s, r), ea(n, o, a), s, o), lt.intersect(t, s0, null, o0);
    var l = o0.outIntersectRect;
    e.outerWidth = l.width, e.outerHeight = l.height, e.baseX = ls(l.x, l.width, r, !0), e.baseY = ea(l.y, l.height, a, !0);
  }
}
var s0 = new lt(0, 0, 0, 0), o0 = { outIntersectRect: {}, clamp: !0 };
function Ov(e) {
  return e != null ? e += "" : e = "";
}
function vO(e) {
  var t = Ov(e.text), i = e.font, n = Ji(Qi(i), t), r = Tc(i);
  return vf(e, n, r, null);
}
function vf(e, t, i, n) {
  var r = new lt(ls(e.x || 0, t, e.textAlign), ea(e.y || 0, i, e.textBaseline), t, i), a = n ?? (V1(e) ? e.lineWidth : 0);
  return a > 0 && (r.x -= a / 2, r.y -= a / 2, r.width += a, r.height += a), r;
}
function V1(e) {
  var t = e.stroke;
  return t != null && t !== "none" && e.lineWidth > 0;
}
var pf = "__zr_style_" + Math.round(Math.random() * 10), ia = {
  shadowBlur: 0,
  shadowOffsetX: 0,
  shadowOffsetY: 0,
  shadowColor: "#000",
  opacity: 1,
  blend: "source-over"
}, Lc = {
  style: {
    shadowBlur: !0,
    shadowOffsetX: !0,
    shadowOffsetY: !0,
    shadowColor: !0,
    opacity: !0
  }
};
ia[pf] = !0;
var l0 = ["z", "z2", "invisible"], pO = ["invisible"], Jo = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype._init = function(i) {
    for (var n = qt(i), r = 0; r < n.length; r++) {
      var a = n[r];
      a === "style" ? this.useStyle(i[a]) : e.prototype.attrKV.call(this, a, i[a]);
    }
    this.style || this.useStyle({});
  }, t.prototype.beforeBrush = function() {
  }, t.prototype.afterBrush = function() {
  }, t.prototype.innerBeforeBrush = function() {
  }, t.prototype.innerAfterBrush = function() {
  }, t.prototype.shouldBePainted = function(i, n, r, a) {
    var s = this.transform;
    if (this.ignore || this.invisible || this.style.opacity === 0 || this.culling && gO(this, i, n) || s && !s[0] && !s[3])
      return !1;
    if (r && this.__clipPaths && this.__clipPaths.length) {
      for (var o = 0; o < this.__clipPaths.length; ++o)
        if (this.__clipPaths[o].isZeroArea())
          return !1;
    }
    if (a && this.parent)
      for (var l = this.parent; l; ) {
        if (l.ignore)
          return !1;
        l = l.parent;
      }
    return !0;
  }, t.prototype.contain = function(i, n) {
    return this.rectContain(i, n);
  }, t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.rectContain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    return a.contain(r[0], r[1]);
  }, t.prototype.getPaintRect = function() {
    var i = this._paintRect;
    if (!this._paintRect || this.__dirty) {
      var n = this.transform, r = this.getBoundingRect(), a = this.style, s = a.shadowBlur || 0, o = a.shadowOffsetX || 0, l = a.shadowOffsetY || 0;
      i = this._paintRect || (this._paintRect = new lt(0, 0, 0, 0)), n ? lt.applyTransform(i, r, n) : i.copy(r), (s || o || l) && (i.width += s * 2 + Math.abs(o), i.height += s * 2 + Math.abs(l), i.x = Math.min(i.x, i.x + o - s), i.y = Math.min(i.y, i.y + l - s));
      var u = this.dirtyRectTolerance;
      i.isZero() || (i.x = Math.floor(i.x - u), i.y = Math.floor(i.y - u), i.width = Math.ceil(i.width + 1 + u * 2), i.height = Math.ceil(i.height + 1 + u * 2));
    }
    return i;
  }, t.prototype.setPrevPaintRect = function(i) {
    i ? (this._prevPaintRect = this._prevPaintRect || new lt(0, 0, 0, 0), this._prevPaintRect.copy(i)) : this._prevPaintRect = null;
  }, t.prototype.getPrevPaintRect = function() {
    return this._prevPaintRect;
  }, t.prototype.animateStyle = function(i) {
    return this.animate("style", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i !== "style" ? e.prototype.attrKV.call(this, i, n) : this.style ? this.setStyle(n) : this.useStyle(n);
  }, t.prototype.setStyle = function(i, n) {
    return typeof i == "string" ? this.style[i] = n : Y(this.style, i), this.dirtyStyle(), this;
  }, t.prototype.dirtyStyle = function(i) {
    i || this.markRedraw(), this.__dirty |= to, this._rect && (this._rect = null);
  }, t.prototype.dirty = function() {
    this.dirtyStyle();
  }, t.prototype.styleChanged = function() {
    return !!(this.__dirty & to);
  }, t.prototype.styleUpdated = function() {
    this.__dirty &= ~to;
  }, t.prototype.createStyle = function(i) {
    return Dc(ia, i);
  }, t.prototype.useStyle = function(i) {
    i[pf] || (i = this.createStyle(i)), this.__inHover ? this.__hoverStyle = i : this.style = i, this.dirtyStyle();
  }, t.prototype.isStyleObject = function(i) {
    return i[pf];
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.style && !n.style && (n.style = this._mergeStyle(this.createStyle(), this.style)), this._savePrimaryToNormal(i, n, l0);
  }, t.prototype._applyStateObj = function(i, n, r, a, s, o) {
    e.prototype._applyStateObj.call(this, i, n, r, a, s, o);
    var l = !(n && a), u;
    if (n && n.style ? s ? a ? u = n.style : (u = this._mergeStyle(this.createStyle(), r.style), this._mergeStyle(u, n.style)) : (u = this._mergeStyle(this.createStyle(), a ? this.style : r.style), this._mergeStyle(u, n.style)) : l && (u = r.style), u)
      if (s) {
        var c = this.style;
        if (this.style = this.createStyle(l ? {} : c), l)
          for (var h = qt(c), d = 0; d < h.length; d++) {
            var f = h[d];
            f in u && (u[f] = u[f], this.style[f] = c[f]);
          }
        for (var v = qt(u), d = 0; d < v.length; d++) {
          var f = v[d];
          this.style[f] = this.style[f];
        }
        this._transitionState(i, {
          style: u
        }, o, this.getAnimationStyleProps());
      } else
        this.useStyle(u);
    for (var m = this.__inHover ? pO : l0, d = 0; d < m.length; d++) {
      var f = m[d];
      n && n[f] != null ? this[f] = n[f] : l && r[f] != null && (this[f] = r[f]);
    }
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var s = i[a];
      s.style && (r = r || {}, this._mergeStyle(r, s.style));
    }
    return r && (n.style = r), n;
  }, t.prototype._mergeStyle = function(i, n) {
    return Y(i, n), i;
  }, t.prototype.getAnimationStyleProps = function() {
    return Lc;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "displayable", i.invisible = !1, i.z = 0, i.z2 = 0, i.zlevel = 0, i.culling = !1, i.cursor = "pointer", i.rectHover = !1, i.incremental = !1, i._rect = null, i.dirtyRectTolerance = 0, i.__dirty = Qe | to;
  })(), t;
})(Cc), zh = new lt(0, 0, 0, 0), Vh = new lt(0, 0, 0, 0);
function gO(e, t, i) {
  return zh.copy(e.getBoundingRect()), e.transform && zh.applyTransform(e.transform), Vh.width = t, Vh.height = i, !zh.intersect(Vh);
}
var di = Math.min, fi = Math.max, Hh = Math.sin, Yh = Math.cos, _r = Math.PI * 2, Tl = gs(), Cl = gs(), El = gs();
function u0(e, t, i, n, r, a) {
  r[0] = di(e, i), r[1] = di(t, n), a[0] = fi(e, i), a[1] = fi(t, n);
}
var c0 = [], h0 = [];
function mO(e, t, i, n, r, a, s, o, l, u) {
  var c = v1, h = Le, d = c(e, i, r, s, c0);
  l[0] = 1 / 0, l[1] = 1 / 0, u[0] = -1 / 0, u[1] = -1 / 0;
  for (var f = 0; f < d; f++) {
    var v = h(e, i, r, s, c0[f]);
    l[0] = di(v, l[0]), u[0] = fi(v, u[0]);
  }
  d = c(t, n, a, o, h0);
  for (var f = 0; f < d; f++) {
    var m = h(t, n, a, o, h0[f]);
    l[1] = di(m, l[1]), u[1] = fi(m, u[1]);
  }
  l[0] = di(e, l[0]), u[0] = fi(e, u[0]), l[0] = di(s, l[0]), u[0] = fi(s, u[0]), l[1] = di(t, l[1]), u[1] = fi(t, u[1]), l[1] = di(o, l[1]), u[1] = fi(o, u[1]);
}
function yO(e, t, i, n, r, a, s, o) {
  var l = p1, u = He, c = fi(di(l(e, i, r), 1), 0), h = fi(di(l(t, n, a), 1), 0), d = u(e, i, r, c), f = u(t, n, a, h);
  s[0] = di(e, r, d), s[1] = di(t, a, f), o[0] = fi(e, r, d), o[1] = fi(t, a, f);
}
function _O(e, t, i, n, r, a, s, o, l) {
  var u = Va, c = Ha, h = Math.abs(r - a);
  if (h % _r < 1e-4 && h > 1e-4) {
    o[0] = e - i, o[1] = t - n, l[0] = e + i, l[1] = t + n;
    return;
  }
  if (Tl[0] = Yh(r) * i + e, Tl[1] = Hh(r) * n + t, Cl[0] = Yh(a) * i + e, Cl[1] = Hh(a) * n + t, u(o, Tl, Cl), c(l, Tl, Cl), r = r % _r, r < 0 && (r = r + _r), a = a % _r, a < 0 && (a = a + _r), r > a && !s ? a += _r : r < a && s && (r += _r), s) {
    var d = a;
    a = r, r = d;
  }
  for (var f = 0; f < a; f += Math.PI / 2)
    f > r && (El[0] = Yh(f) * i + e, El[1] = Hh(f) * n + t, u(o, El, o), c(l, El, l));
}
var Mt = {
  M: 1,
  L: 2,
  C: 3,
  Q: 4,
  A: 5,
  Z: 6,
  R: 7
}, br = [], xr = [], Bi = [], Rn = [], $i = [], zi = [], Wh = Math.min, Uh = Math.max, wr = Math.cos, Sr = Math.sin, on = Math.abs, gf = Math.PI, zn = gf * 2, Gh = typeof Float32Array < "u", Es = [];
function Xh(e) {
  var t = Math.round(e / gf * 1e8) / 1e8;
  return t % 2 * gf;
}
function bO(e, t) {
  var i = Xh(e[0]);
  i < 0 && (i += zn);
  var n = i - e[0], r = e[1];
  r += n, !t && r - i >= zn ? r = i + zn : t && i - r >= zn ? r = i - zn : !t && i > r ? r = i + (zn - Xh(i - r)) : t && i < r && (r = i - (zn - Xh(r - i))), e[0] = i, e[1] = r;
}
var cs = (function() {
  function e(t) {
    this.dpr = 1, this._xi = 0, this._yi = 0, this._x0 = 0, this._y0 = 0, this._len = 0, t && (this._saveData = !1), this._saveData && (this.data = []);
  }
  return e.prototype.increaseVersion = function() {
    this._version++;
  }, e.prototype.getVersion = function() {
    return this._version;
  }, e.prototype.setScale = function(t, i, n) {
    n = n || 0, n > 0 && (this._ux = on(n / Nu / t) || 0, this._uy = on(n / Nu / i) || 0);
  }, e.prototype.setDPR = function(t) {
    this.dpr = t;
  }, e.prototype.setContext = function(t) {
    this._ctx = t;
  }, e.prototype.getContext = function() {
    return this._ctx;
  }, e.prototype.beginPath = function() {
    return this._ctx && this._ctx.beginPath(), this.reset(), this;
  }, e.prototype.reset = function() {
    this._saveData && (this._len = 0), this._pathSegLen && (this._pathSegLen = null, this._pathLen = 0), this._version++;
  }, e.prototype.moveTo = function(t, i) {
    return this._drawPendingPt(), this.addData(Mt.M, t, i), this._ctx && this._ctx.moveTo(t, i), this._x0 = t, this._y0 = i, this._xi = t, this._yi = i, this;
  }, e.prototype.lineTo = function(t, i) {
    var n = on(t - this._xi), r = on(i - this._yi), a = n > this._ux || r > this._uy;
    if (this.addData(Mt.L, t, i), this._ctx && a && this._ctx.lineTo(t, i), a)
      this._xi = t, this._yi = i, this._pendingPtDist = 0;
    else {
      var s = n * n + r * r;
      s > this._pendingPtDist && (this._pendingPtX = t, this._pendingPtY = i, this._pendingPtDist = s);
    }
    return this;
  }, e.prototype.bezierCurveTo = function(t, i, n, r, a, s) {
    return this._drawPendingPt(), this.addData(Mt.C, t, i, n, r, a, s), this._ctx && this._ctx.bezierCurveTo(t, i, n, r, a, s), this._xi = a, this._yi = s, this;
  }, e.prototype.quadraticCurveTo = function(t, i, n, r) {
    return this._drawPendingPt(), this.addData(Mt.Q, t, i, n, r), this._ctx && this._ctx.quadraticCurveTo(t, i, n, r), this._xi = n, this._yi = r, this;
  }, e.prototype.arc = function(t, i, n, r, a, s) {
    this._drawPendingPt(), Es[0] = r, Es[1] = a, bO(Es, s), r = Es[0], a = Es[1];
    var o = a - r;
    return this.addData(Mt.A, t, i, n, n, r, o, 0, s ? 0 : 1), this._ctx && this._ctx.arc(t, i, n, r, a, s), this._xi = wr(a) * n + t, this._yi = Sr(a) * n + i, this;
  }, e.prototype.arcTo = function(t, i, n, r, a) {
    return this._drawPendingPt(), this._ctx && this._ctx.arcTo(t, i, n, r, a), this;
  }, e.prototype.rect = function(t, i, n, r) {
    return this._drawPendingPt(), this._ctx && this._ctx.rect(t, i, n, r), this.addData(Mt.R, t, i, n, r), this;
  }, e.prototype.closePath = function() {
    this._drawPendingPt(), this.addData(Mt.Z);
    var t = this._ctx, i = this._x0, n = this._y0;
    return t && t.closePath(), this._xi = i, this._yi = n, this;
  }, e.prototype.fill = function(t) {
    t && t.fill(), this.toStatic();
  }, e.prototype.stroke = function(t) {
    t && t.stroke(), this.toStatic();
  }, e.prototype.len = function() {
    return this._len;
  }, e.prototype.setData = function(t) {
    if (this._saveData) {
      var i = t.length;
      !(this.data && this.data.length === i) && Gh && (this.data = new Float32Array(i));
      for (var n = 0; n < i; n++)
        this.data[n] = t[n];
      this._len = i;
    }
  }, e.prototype.appendPath = function(t) {
    if (this._saveData) {
      t instanceof Array || (t = [t]);
      for (var i = t.length, n = 0, r = this._len, a = 0; a < i; a++)
        n += t[a].len();
      var s = this.data;
      if (Gh && (s instanceof Float32Array || !s) && (this.data = new Float32Array(r + n), r > 0 && s))
        for (var o = 0; o < r; o++)
          this.data[o] = s[o];
      for (var a = 0; a < i; a++)
        for (var l = t[a].data, o = 0; o < l.length; o++)
          this.data[r++] = l[o];
      this._len = r;
    }
  }, e.prototype.addData = function(t, i, n, r, a, s, o, l, u) {
    if (this._saveData) {
      var c = this.data;
      this._len + arguments.length > c.length && (this._expandData(), c = this.data);
      for (var h = 0; h < arguments.length; h++)
        c[this._len++] = arguments[h];
    }
  }, e.prototype._drawPendingPt = function() {
    this._pendingPtDist > 0 && (this._ctx && this._ctx.lineTo(this._pendingPtX, this._pendingPtY), this._pendingPtDist = 0);
  }, e.prototype._expandData = function() {
    if (!(this.data instanceof Array)) {
      for (var t = [], i = 0; i < this._len; i++)
        t[i] = this.data[i];
      this.data = t;
    }
  }, e.prototype.toStatic = function() {
    if (this._saveData) {
      this._drawPendingPt();
      var t = this.data;
      t instanceof Array && (t.length = this._len, Gh && this._len > 11 && (this.data = new Float32Array(t)));
    }
  }, e.prototype.getBoundingRect = function() {
    Bi[0] = Bi[1] = $i[0] = $i[1] = Number.MAX_VALUE, Rn[0] = Rn[1] = zi[0] = zi[1] = -Number.MAX_VALUE;
    var t = this.data, i = 0, n = 0, r = 0, a = 0, s;
    for (s = 0; s < this._len; ) {
      var o = t[s++], l = s === 1;
      switch (l && (i = t[s], n = t[s + 1], r = i, a = n), o) {
        case Mt.M:
          i = r = t[s++], n = a = t[s++], $i[0] = r, $i[1] = a, zi[0] = r, zi[1] = a;
          break;
        case Mt.L:
          u0(i, n, t[s], t[s + 1], $i, zi), i = t[s++], n = t[s++];
          break;
        case Mt.C:
          mO(i, n, t[s++], t[s++], t[s++], t[s++], t[s], t[s + 1], $i, zi), i = t[s++], n = t[s++];
          break;
        case Mt.Q:
          yO(i, n, t[s++], t[s++], t[s], t[s + 1], $i, zi), i = t[s++], n = t[s++];
          break;
        case Mt.A:
          var u = t[s++], c = t[s++], h = t[s++], d = t[s++], f = t[s++], v = t[s++] + f;
          s += 1;
          var m = !t[s++];
          l && (r = wr(f) * h + u, a = Sr(f) * d + c), _O(u, c, h, d, f, v, m, $i, zi), i = wr(v) * h + u, n = Sr(v) * d + c;
          break;
        case Mt.R:
          r = i = t[s++], a = n = t[s++];
          var p = t[s++], g = t[s++];
          u0(r, a, r + p, a + g, $i, zi);
          break;
        case Mt.Z:
          i = r, n = a;
          break;
      }
      Va(Bi, Bi, $i), Ha(Rn, Rn, zi);
    }
    return s === 0 && (Bi[0] = Bi[1] = Rn[0] = Rn[1] = 0), new lt(Bi[0], Bi[1], Rn[0] - Bi[0], Rn[1] - Bi[1]);
  }, e.prototype._calculateLength = function() {
    var t = this.data, i = this._len, n = this._ux, r = this._uy, a = 0, s = 0, o = 0, l = 0;
    this._pathSegLen || (this._pathSegLen = []);
    for (var u = this._pathSegLen, c = 0, h = 0, d = 0; d < i; ) {
      var f = t[d++], v = d === 1;
      v && (a = t[d], s = t[d + 1], o = a, l = s);
      var m = -1;
      switch (f) {
        case Mt.M:
          a = o = t[d++], s = l = t[d++];
          break;
        case Mt.L: {
          var p = t[d++], g = t[d++], y = p - a, _ = g - s;
          (on(y) > n || on(_) > r || d === i - 1) && (m = Math.sqrt(y * y + _ * _), a = p, s = g);
          break;
        }
        case Mt.C: {
          var b = t[d++], w = t[d++], p = t[d++], g = t[d++], S = t[d++], M = t[d++];
          m = BP(a, s, b, w, p, g, S, M, 10), a = S, s = M;
          break;
        }
        case Mt.Q: {
          var b = t[d++], w = t[d++], p = t[d++], g = t[d++];
          m = VP(a, s, b, w, p, g, 10), a = p, s = g;
          break;
        }
        case Mt.A:
          var k = t[d++], T = t[d++], D = t[d++], C = t[d++], P = t[d++], L = t[d++], O = L + P;
          d += 1, v && (o = wr(P) * D + k, l = Sr(P) * C + T), m = Uh(D, C) * Wh(zn, Math.abs(L)), a = wr(O) * D + k, s = Sr(O) * C + T;
          break;
        case Mt.R: {
          o = a = t[d++], l = s = t[d++];
          var N = t[d++], B = t[d++];
          m = N * 2 + B * 2;
          break;
        }
        case Mt.Z: {
          var y = o - a, _ = l - s;
          m = Math.sqrt(y * y + _ * _), a = o, s = l;
          break;
        }
      }
      m >= 0 && (u[h++] = m, c += m);
    }
    return this._pathLen = c, c;
  }, e.prototype.rebuildPath = function(t, i) {
    var n = this.data, r = this._ux, a = this._uy, s = this._len, o, l, u, c, h, d, f = i < 1, v, m, p = 0, g = 0, y, _ = 0, b, w;
    if (!(f && (this._pathSegLen || this._calculateLength(), v = this._pathSegLen, m = this._pathLen, y = i * m, !y)))
      t: for (var S = 0; S < s; ) {
        var M = n[S++], k = S === 1;
        switch (k && (u = n[S], c = n[S + 1], o = u, l = c), M !== Mt.L && _ > 0 && (t.lineTo(b, w), _ = 0), M) {
          case Mt.M:
            o = u = n[S++], l = c = n[S++], t.moveTo(u, c);
            break;
          case Mt.L: {
            h = n[S++], d = n[S++];
            var T = on(h - u), D = on(d - c);
            if (T > r || D > a) {
              if (f) {
                var C = v[g++];
                if (p + C > y) {
                  var P = (y - p) / C;
                  t.lineTo(u * (1 - P) + h * P, c * (1 - P) + d * P);
                  break t;
                }
                p += C;
              }
              t.lineTo(h, d), u = h, c = d, _ = 0;
            } else {
              var L = T * T + D * D;
              L > _ && (b = h, w = d, _ = L);
            }
            break;
          }
          case Mt.C: {
            var O = n[S++], N = n[S++], B = n[S++], G = n[S++], V = n[S++], F = n[S++];
            if (f) {
              var C = v[g++];
              if (p + C > y) {
                var P = (y - p) / C;
                Lu(u, O, B, V, P, br), Lu(c, N, G, F, P, xr), t.bezierCurveTo(br[1], xr[1], br[2], xr[2], br[3], xr[3]);
                break t;
              }
              p += C;
            }
            t.bezierCurveTo(O, N, B, G, V, F), u = V, c = F;
            break;
          }
          case Mt.Q: {
            var O = n[S++], N = n[S++], B = n[S++], G = n[S++];
            if (f) {
              var C = v[g++];
              if (p + C > y) {
                var P = (y - p) / C;
                Ou(u, O, B, P, br), Ou(c, N, G, P, xr), t.quadraticCurveTo(br[1], xr[1], br[2], xr[2]);
                break t;
              }
              p += C;
            }
            t.quadraticCurveTo(O, N, B, G), u = B, c = G;
            break;
          }
          case Mt.A:
            var $ = n[S++], Z = n[S++], j = n[S++], it = n[S++], st = n[S++], wt = n[S++], Tt = n[S++], me = !n[S++], Ae = j > it ? j : it, At = on(j - it) > 1e-3, Ft = st + wt, at = !1;
            if (f) {
              var C = v[g++];
              p + C > y && (Ft = st + wt * (y - p) / C, at = !0), p += C;
            }
            if (At && t.ellipse ? t.ellipse($, Z, j, it, Tt, st, Ft, me) : t.arc($, Z, Ae, st, Ft, me), at)
              break t;
            k && (o = wr(st) * j + $, l = Sr(st) * it + Z), u = wr(Ft) * j + $, c = Sr(Ft) * it + Z;
            break;
          case Mt.R:
            o = u = n[S], l = c = n[S + 1], h = n[S++], d = n[S++];
            var ft = n[S++], Ni = n[S++];
            if (f) {
              var C = v[g++];
              if (p + C > y) {
                var ue = y - p;
                t.moveTo(h, d), t.lineTo(h + Wh(ue, ft), d), ue -= ft, ue > 0 && t.lineTo(h + ft, d + Wh(ue, Ni)), ue -= Ni, ue > 0 && t.lineTo(h + Uh(ft - ue, 0), d + Ni), ue -= ft, ue > 0 && t.lineTo(h, d + Uh(Ni - ue, 0));
                break t;
              }
              p += C;
            }
            t.rect(h, d, ft, Ni);
            break;
          case Mt.Z:
            if (f) {
              var C = v[g++];
              if (p + C > y) {
                var P = (y - p) / C;
                t.lineTo(u * (1 - P) + o * P, c * (1 - P) + l * P);
                break t;
              }
              p += C;
            }
            t.closePath(), u = o, c = l;
        }
      }
  }, e.prototype.clone = function() {
    var t = new e(), i = this.data;
    return t.data = i.slice ? i.slice() : Array.prototype.slice.call(i), t._len = this._len, t;
  }, e.prototype.canSave = function() {
    return !!this._saveData;
  }, e.CMD = Mt, e.initDefaultProps = (function() {
    var t = e.prototype;
    t._saveData = !0, t._ux = 0, t._uy = 0, t._pendingPtDist = 0, t._version = 0;
  })(), e;
})();
function Ma(e, t, i, n, r, a, s) {
  if (r === 0)
    return !1;
  var o = r, l = 0, u = e;
  if (s > t + o && s > n + o || s < t - o && s < n - o || a > e + o && a > i + o || a < e - o && a < i - o)
    return !1;
  if (e !== i)
    l = (t - n) / (e - i), u = (e * n - i * t) / (e - i);
  else
    return Math.abs(a - e) <= o / 2;
  var c = l * a - s + u, h = c * c / (l * l + 1);
  return h <= o / 2 * o / 2;
}
function xO(e, t, i, n, r, a, s, o, l, u, c) {
  if (l === 0)
    return !1;
  var h = l;
  if (c > t + h && c > n + h && c > a + h && c > o + h || c < t - h && c < n - h && c < a - h && c < o - h || u > e + h && u > i + h && u > r + h && u > s + h || u < e - h && u < i - h && u < r - h && u < s - h)
    return !1;
  var d = FP(e, t, i, n, r, a, s, o, u, c);
  return d <= h / 2;
}
function wO(e, t, i, n, r, a, s, o, l) {
  if (s === 0)
    return !1;
  var u = s;
  if (l > t + u && l > n + u && l > a + u || l < t - u && l < n - u && l < a - u || o > e + u && o > i + u && o > r + u || o < e - u && o < i - u && o < r - u)
    return !1;
  var c = zP(e, t, i, n, r, a, o, l);
  return c <= u / 2;
}
var d0 = Math.PI * 2;
function Al(e) {
  return e %= d0, e < 0 && (e += d0), e;
}
var As = Math.PI * 2;
function SO(e, t, i, n, r, a, s, o, l) {
  if (s === 0)
    return !1;
  var u = s;
  o -= e, l -= t;
  var c = Math.sqrt(o * o + l * l);
  if (c - u > i || c + u < i)
    return !1;
  if (Math.abs(n - r) % As < 1e-4)
    return !0;
  if (a) {
    var h = n;
    n = Al(r), r = Al(h);
  } else
    n = Al(n), r = Al(r);
  n > r && (r += As);
  var d = Math.atan2(l, o);
  return d < 0 && (d += As), d >= n && d <= r || d + As >= n && d + As <= r;
}
function Mr(e, t, i, n, r, a) {
  if (a > t && a > n || a < t && a < n || n === t)
    return 0;
  var s = (a - t) / (n - t), o = n < t ? 1 : -1;
  (s === 1 || s === 0) && (o = n < t ? 0.5 : -0.5);
  var l = s * (i - e) + e;
  return l === r ? 1 / 0 : l > r ? o : 0;
}
var Nn = cs.CMD, kr = Math.PI * 2, MO = 1e-4;
function kO(e, t) {
  return Math.abs(e - t) < MO;
}
var Pe = [-1, -1, -1], ui = [-1, -1];
function DO() {
  var e = ui[0];
  ui[0] = ui[1], ui[1] = e;
}
function TO(e, t, i, n, r, a, s, o, l, u) {
  if (u > t && u > n && u > a && u > o || u < t && u < n && u < a && u < o)
    return 0;
  var c = f1(t, n, a, o, u, Pe);
  if (c === 0)
    return 0;
  for (var h = 0, d = -1, f = void 0, v = void 0, m = 0; m < c; m++) {
    var p = Pe[m], g = p === 0 || p === 1 ? 0.5 : 1, y = Le(e, i, r, s, p);
    y < l || (d < 0 && (d = v1(t, n, a, o, ui), ui[1] < ui[0] && d > 1 && DO(), f = Le(t, n, a, o, ui[0]), d > 1 && (v = Le(t, n, a, o, ui[1]))), d === 2 ? p < ui[0] ? h += f < t ? g : -g : p < ui[1] ? h += v < f ? g : -g : h += o < v ? g : -g : p < ui[0] ? h += f < t ? g : -g : h += o < f ? g : -g);
  }
  return h;
}
function CO(e, t, i, n, r, a, s, o) {
  if (o > t && o > n && o > a || o < t && o < n && o < a)
    return 0;
  var l = $P(t, n, a, o, Pe);
  if (l === 0)
    return 0;
  var u = p1(t, n, a);
  if (u >= 0 && u <= 1) {
    for (var c = 0, h = He(t, n, a, u), d = 0; d < l; d++) {
      var f = Pe[d] === 0 || Pe[d] === 1 ? 0.5 : 1, v = He(e, i, r, Pe[d]);
      v < s || (Pe[d] < u ? c += h < t ? f : -f : c += a < h ? f : -f);
    }
    return c;
  } else {
    var f = Pe[0] === 0 || Pe[0] === 1 ? 0.5 : 1, v = He(e, i, r, Pe[0]);
    return v < s ? 0 : a < t ? f : -f;
  }
}
function EO(e, t, i, n, r, a, s, o) {
  if (o -= t, o > i || o < -i)
    return 0;
  var l = Math.sqrt(i * i - o * o);
  Pe[0] = -l, Pe[1] = l;
  var u = Math.abs(n - r);
  if (u < 1e-4)
    return 0;
  if (u >= kr - 1e-4) {
    n = 0, r = kr;
    var c = a ? 1 : -1;
    return s >= Pe[0] + e && s <= Pe[1] + e ? c : 0;
  }
  if (n > r) {
    var h = n;
    n = r, r = h;
  }
  n < 0 && (n += kr, r += kr);
  for (var d = 0, f = 0; f < 2; f++) {
    var v = Pe[f];
    if (v + e > s) {
      var m = Math.atan2(o, v), c = a ? 1 : -1;
      m < 0 && (m = kr + m), (m >= n && m <= r || m + kr >= n && m + kr <= r) && (m > Math.PI / 2 && m < Math.PI * 1.5 && (c = -c), d += c);
    }
  }
  return d;
}
function H1(e, t, i, n, r) {
  for (var a = e.data, s = e.len(), o = 0, l = 0, u = 0, c = 0, h = 0, d, f, v = 0; v < s; ) {
    var m = a[v++], p = v === 1;
    switch (m === Nn.M && v > 1 && (i || (o += Mr(l, u, c, h, n, r))), p && (l = a[v], u = a[v + 1], c = l, h = u), m) {
      case Nn.M:
        c = a[v++], h = a[v++], l = c, u = h;
        break;
      case Nn.L:
        if (i) {
          if (Ma(l, u, a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += Mr(l, u, a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Nn.C:
        if (i) {
          if (xO(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += TO(l, u, a[v++], a[v++], a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Nn.Q:
        if (i) {
          if (wO(l, u, a[v++], a[v++], a[v], a[v + 1], t, n, r))
            return !0;
        } else
          o += CO(l, u, a[v++], a[v++], a[v], a[v + 1], n, r) || 0;
        l = a[v++], u = a[v++];
        break;
      case Nn.A:
        var g = a[v++], y = a[v++], _ = a[v++], b = a[v++], w = a[v++], S = a[v++];
        v += 1;
        var M = !!(1 - a[v++]);
        d = Math.cos(w) * _ + g, f = Math.sin(w) * b + y, p ? (c = d, h = f) : o += Mr(l, u, d, f, n, r);
        var k = (n - g) * b / _ + g;
        if (i) {
          if (SO(g, y, b, w, w + S, M, t, k, r))
            return !0;
        } else
          o += EO(g, y, b, w, w + S, M, k, r);
        l = Math.cos(w + S) * _ + g, u = Math.sin(w + S) * b + y;
        break;
      case Nn.R:
        c = l = a[v++], h = u = a[v++];
        var T = a[v++], D = a[v++];
        if (d = c + T, f = h + D, i) {
          if (Ma(c, h, d, h, t, n, r) || Ma(d, h, d, f, t, n, r) || Ma(d, f, c, f, t, n, r) || Ma(c, f, c, h, t, n, r))
            return !0;
        } else
          o += Mr(d, h, d, f, n, r), o += Mr(c, f, c, h, n, r);
        break;
      case Nn.Z:
        if (i) {
          if (Ma(l, u, c, h, t, n, r))
            return !0;
        } else
          o += Mr(l, u, c, h, n, r);
        l = c, u = h;
        break;
    }
  }
  return !i && !kO(u, h) && (o += Mr(l, u, c, h, n, r) || 0), o !== 0;
}
function AO(e, t, i) {
  return H1(e, 0, !1, t, i);
}
function PO(e, t, i, n) {
  return H1(e, t, !0, i, n);
}
var Y1 = Jt({
  fill: "#000",
  stroke: null,
  strokePercent: 1,
  fillOpacity: 1,
  strokeOpacity: 1,
  lineDashOffset: 0,
  lineWidth: 1,
  lineCap: "butt",
  miterLimit: 10,
  strokeNoScale: !1,
  strokeFirst: !1
}, ia), LO = {
  style: Jt({
    fill: !0,
    stroke: !0,
    strokePercent: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineDashOffset: !0,
    lineWidth: !0,
    miterLimit: !0
  }, Lc.style)
}, jh = Po.concat([
  "invisible",
  "culling",
  "z",
  "z2",
  "zlevel",
  "parent"
]), $t = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.update = function() {
    var i = this;
    e.prototype.update.call(this);
    var n = this.style;
    if (n.decal) {
      var r = this._decalEl = this._decalEl || new t();
      r.buildPath === t.prototype.buildPath && (r.buildPath = function(l) {
        i.buildPath(l, i.shape);
      }), r.silent = !0;
      var a = r.style;
      for (var s in n)
        a[s] !== n[s] && (a[s] = n[s]);
      a.fill = n.fill ? n.decal : null, a.decal = null, a.shadowColor = null, n.strokeFirst && (a.stroke = null);
      for (var o = 0; o < jh.length; ++o)
        r[jh[o]] = this[jh[o]];
      r.__dirty |= Qe;
    } else this._decalEl && (this._decalEl = null);
  }, t.prototype.getDecalElement = function() {
    return this._decalEl;
  }, t.prototype._init = function(i) {
    var n = qt(i);
    this.shape = this.getDefaultShape();
    var r = this.getDefaultStyle();
    r && this.useStyle(r);
    for (var a = 0; a < n.length; a++) {
      var s = n[a], o = i[s];
      s === "style" ? this.style ? Y(this.style, o) : this.useStyle(o) : s === "shape" ? Y(this.shape, o) : e.prototype.attrKV.call(this, s, o);
    }
    this.style || this.useStyle({});
  }, t.prototype.getDefaultStyle = function() {
    return null;
  }, t.prototype.getDefaultShape = function() {
    return {};
  }, t.prototype.canBeInsideText = function() {
    return this.hasFill();
  }, t.prototype.getInsideTextFill = function() {
    var i = this.style.fill;
    if (i !== "none") {
      if (et(i)) {
        var n = Ru(i, 0);
        return n > 0.5 ? cf : n > 0.2 ? uL : hf;
      } else if (i)
        return hf;
    }
    return cf;
  }, t.prototype.getInsideTextStroke = function(i) {
    var n = this.style.fill;
    if (et(n)) {
      var r = this.__zr, a = !!(r && r.isDarkMode()), s = Ru(i, 0) < uf;
      if (a === s)
        return n;
    }
  }, t.prototype.buildPath = function(i, n, r) {
  }, t.prototype.pathUpdated = function() {
    this.__dirty &= ~$a;
  }, t.prototype.getUpdatedPathProxy = function(i) {
    return !this.path && this.createPathProxy(), this.path.beginPath(), this.buildPath(this.path, this.shape, i), this.path;
  }, t.prototype.createPathProxy = function() {
    this.path = new cs(!1);
  }, t.prototype.hasStroke = function() {
    var i = this.style, n = i.stroke;
    return !(n == null || n === "none" || !(i.lineWidth > 0));
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.getBoundingRect = function() {
    var i = this._rect, n = this.style, r = !i;
    if (r) {
      var a = !1;
      this.path || (a = !0, this.createPathProxy());
      var s = this.path;
      (a || this.__dirty & $a) && (s.beginPath(), this.buildPath(s, this.shape, !1), this.pathUpdated()), i = s.getBoundingRect();
    }
    if (this._rect = i, this.hasStroke() && this.path && this.path.len() > 0) {
      var o = this._rectStroke || (this._rectStroke = i.clone());
      if (this.__dirty || r) {
        o.copy(i);
        var l = n.strokeNoScale ? this.getLineScale() : 1, u = n.lineWidth;
        if (!this.hasFill()) {
          var c = this.strokeContainThreshold;
          u = Math.max(u, c ?? 4);
        }
        l > 1e-10 && (o.width += u / l, o.height += u / l, o.x -= u / l / 2, o.y -= u / l / 2);
      }
      return o;
    }
    return i;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect(), s = this.style;
    if (i = r[0], n = r[1], a.contain(i, n)) {
      var o = this.path;
      if (this.hasStroke()) {
        var l = s.lineWidth, u = s.strokeNoScale ? this.getLineScale() : 1;
        if (u > 1e-10 && (this.hasFill() || (l = Math.max(l, this.strokeContainThreshold)), PO(o, l / u, i, n)))
          return !0;
      }
      if (this.hasFill())
        return AO(o, i, n);
    }
    return !1;
  }, t.prototype.dirtyShape = function() {
    this.__dirty |= $a, this._rect && (this._rect = null), this._decalEl && this._decalEl.dirtyShape(), this.markRedraw();
  }, t.prototype.dirty = function() {
    this.dirtyStyle(), this.dirtyShape();
  }, t.prototype.animateShape = function(i) {
    return this.animate("shape", i);
  }, t.prototype.updateDuringAnimation = function(i) {
    i === "style" ? this.dirtyStyle() : i === "shape" ? this.dirtyShape() : this.markRedraw();
  }, t.prototype.attrKV = function(i, n) {
    i === "shape" ? this.setShape(n) : e.prototype.attrKV.call(this, i, n);
  }, t.prototype.setShape = function(i, n) {
    var r = this.shape;
    return r || (r = this.shape = {}), typeof i == "string" ? r[i] = n : Y(r, i), this.dirtyShape(), this;
  }, t.prototype.shapeChanged = function() {
    return !!(this.__dirty & $a);
  }, t.prototype.createStyle = function(i) {
    return Dc(Y1, i);
  }, t.prototype._innerSaveToNormal = function(i) {
    e.prototype._innerSaveToNormal.call(this, i);
    var n = this._normalState;
    i.shape && !n.shape && (n.shape = Y({}, this.shape));
  }, t.prototype._applyStateObj = function(i, n, r, a, s, o) {
    e.prototype._applyStateObj.call(this, i, n, r, a, s, o);
    var l = !(n && a), u;
    if (n && n.shape ? s ? a ? u = n.shape : (u = Y({}, r.shape), Y(u, n.shape)) : (u = Y({}, a ? this.shape : r.shape), Y(u, n.shape)) : l && (u = r.shape), u)
      if (s) {
        this.shape = Y({}, this.shape);
        for (var c = {}, h = qt(u), d = 0; d < h.length; d++) {
          var f = h[d];
          typeof u[f] == "object" ? this.shape[f] = u[f] : c[f] = u[f];
        }
        this._transitionState(i, {
          shape: c
        }, o);
      } else
        this.shape = u, this.dirtyShape();
  }, t.prototype._mergeStates = function(i) {
    for (var n = e.prototype._mergeStates.call(this, i), r, a = 0; a < i.length; a++) {
      var s = i[a];
      s.shape && (r = r || {}, this._mergeStyle(r, s.shape));
    }
    return r && (n.shape = r), n;
  }, t.prototype.getAnimationStyleProps = function() {
    return LO;
  }, t.prototype.isZeroArea = function() {
    return !1;
  }, t.extend = function(i) {
    var n = (function(a) {
      Lt(s, a);
      function s(o) {
        var l = a.call(this, o) || this;
        return i.init && i.init.call(l, o), l;
      }
      return s.prototype.getDefaultStyle = function() {
        return pt(i.style);
      }, s.prototype.getDefaultShape = function() {
        return pt(i.shape);
      }, s;
    })(t);
    for (var r in i)
      typeof i[r] == "function" && (n.prototype[r] = i[r]);
    return n;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.type = "path", i.strokeContainThreshold = 5, i.segmentIgnoreThreshold = 0, i.subPixelOptimize = !1, i.autoBatch = !1, i.__dirty = Qe | to | $a;
  })(), t;
})(Jo), OO = Jt({
  strokeFirst: !0,
  font: nr,
  x: 0,
  y: 0,
  textAlign: "left",
  textBaseline: "top",
  miterLimit: 2
}, Y1), zu = (function(e) {
  Lt(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.hasStroke = function() {
    return V1(this.style);
  }, t.prototype.hasFill = function() {
    var i = this.style, n = i.fill;
    return n != null && n !== "none";
  }, t.prototype.createStyle = function(i) {
    return Dc(OO, i);
  }, t.prototype.setBoundingRect = function(i) {
    this._rect = i;
  }, t.prototype.getBoundingRect = function() {
    return this._rect || (this._rect = vO(this.style)), this._rect;
  }, t.initDefaultProps = (function() {
    var i = t.prototype;
    i.dirtyRectTolerance = 10;
  })(), t;
})(Jo);
zu.prototype.type = "tspan";
var IO = Jt({
  x: 0,
  y: 0
}, ia), RO = {
  style: Jt({
    x: !0,
    y: !0,
    width: !0,
    height: !0,
    sx: !0,
    sy: !0,
    sWidth: !0,
    sHeight: !0
  }, Lc.style)
};
function NO(e) {
  return !!(e && typeof e != "string" && e.width && e.height);
}
var ha = (function(e) {
  Lt(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.createStyle = function(i) {
    return Dc(IO, i);
  }, t.prototype._getSize = function(i) {
    var n = this.style, r = n[i];
    if (r != null)
      return r;
    var a = NO(n.image) ? n.image : this.__image;
    if (!a)
      return 0;
    var s = i === "width" ? "height" : "width", o = n[s];
    return o == null ? a[i] : a[i] / a[s] * o;
  }, t.prototype.getWidth = function() {
    return this._getSize("width");
  }, t.prototype.getHeight = function() {
    return this._getSize("height");
  }, t.prototype.getAnimationStyleProps = function() {
    return RO;
  }, t.prototype.getBoundingRect = function() {
    var i = this.style;
    return this._rect || (this._rect = new lt(i.x || 0, i.y || 0, this.getWidth(), this.getHeight())), this._rect;
  }, t;
})(Jo);
ha.prototype.type = "image";
function FO(e, t) {
  var i = t.x, n = t.y, r = t.width, a = t.height, s = t.r, o, l, u, c;
  r < 0 && (i = i + r, r = -r), a < 0 && (n = n + a, a = -a), typeof s == "number" ? o = l = u = c = s : s instanceof Array ? s.length === 1 ? o = l = u = c = s[0] : s.length === 2 ? (o = u = s[0], l = c = s[1]) : s.length === 3 ? (o = s[0], l = c = s[1], u = s[2]) : (o = s[0], l = s[1], u = s[2], c = s[3]) : o = l = u = c = 0;
  var h;
  o + l > r && (h = o + l, o *= r / h, l *= r / h), u + c > r && (h = u + c, u *= r / h, c *= r / h), l + u > a && (h = l + u, l *= a / h, u *= a / h), o + c > a && (h = o + c, o *= a / h, c *= a / h), e.moveTo(i + o, n), e.lineTo(i + r - l, n), l !== 0 && e.arc(i + r - l, n + l, l, -Math.PI / 2, 0), e.lineTo(i + r, n + a - u), u !== 0 && e.arc(i + r - u, n + a - u, u, 0, Math.PI / 2), e.lineTo(i + c, n + a), c !== 0 && e.arc(i + c, n + a - c, c, Math.PI / 2, Math.PI), e.lineTo(i, n + o), o !== 0 && e.arc(i + o, n + o, o, Math.PI, Math.PI * 1.5);
}
var Ua = Math.round;
function W1(e, t, i) {
  if (t) {
    var n = t.x1, r = t.x2, a = t.y1, s = t.y2;
    e.x1 = n, e.x2 = r, e.y1 = a, e.y2 = s;
    var o = i && i.lineWidth;
    return o && (Ua(n * 2) === Ua(r * 2) && (e.x1 = e.x2 = Ur(n, o, !0)), Ua(a * 2) === Ua(s * 2) && (e.y1 = e.y2 = Ur(a, o, !0))), e;
  }
}
function U1(e, t, i) {
  if (t) {
    var n = t.x, r = t.y, a = t.width, s = t.height;
    e.x = n, e.y = r, e.width = a, e.height = s;
    var o = i && i.lineWidth;
    return o && (e.x = Ur(n, o, !0), e.y = Ur(r, o, !0), e.width = Math.max(Ur(n + a, o, !1) - e.x, a === 0 ? 0 : 1), e.height = Math.max(Ur(r + s, o, !1) - e.y, s === 0 ? 0 : 1)), e;
  }
}
function Ur(e, t, i) {
  if (!t)
    return e;
  var n = Ua(e * 2);
  return (n + Ua(t)) % 2 === 0 ? n / 2 : (n + (i ? 1 : -1)) / 2;
}
var BO = /* @__PURE__ */ (function() {
  function e() {
    this.x = 0, this.y = 0, this.width = 0, this.height = 0;
  }
  return e;
})(), $O = {}, De = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new BO();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, s, o;
    if (this.subPixelOptimize) {
      var l = U1($O, n, this.style);
      r = l.x, a = l.y, s = l.width, o = l.height, l.r = n.r, n = l;
    } else
      r = n.x, a = n.y, s = n.width, o = n.height;
    n.r ? FO(i, n) : i.rect(r, a, s, o);
  }, t.prototype.isZeroArea = function() {
    return !this.shape.width || !this.shape.height;
  }, t;
})($t);
De.prototype.type = "rect";
var f0 = {
  fill: "#000"
}, v0 = 2, Vi = {}, zO = {
  style: Jt({
    fill: !0,
    stroke: !0,
    fillOpacity: !0,
    strokeOpacity: !0,
    lineWidth: !0,
    fontSize: !0,
    lineHeight: !0,
    width: !0,
    height: !0,
    textShadowColor: !0,
    textShadowBlur: !0,
    textShadowOffsetX: !0,
    textShadowOffsetY: !0,
    backgroundColor: !0,
    padding: !0,
    borderColor: !0,
    borderWidth: !0,
    borderRadius: !0
  }, Lc.style)
}, _i = (function(e) {
  Lt(t, e);
  function t(i) {
    var n = e.call(this) || this;
    return n.type = "text", n._children = [], n._defaultStyle = f0, n.attr(i), n;
  }
  return t.prototype.childrenRef = function() {
    return this._children;
  }, t.prototype.update = function() {
    e.prototype.update.call(this), this.styleChanged() && this._updateSubTexts();
    for (var i = 0; i < this._children.length; i++) {
      var n = this._children[i];
      n.zlevel = this.zlevel, n.z = this.z, n.z2 = this.z2, n.culling = this.culling, n.cursor = this.cursor, n.invisible = this.invisible;
    }
  }, t.prototype.updateTransform = function() {
    var i = this.innerTransformable;
    i ? (i.updateTransform(), i.transform && (this.transform = i.transform)) : e.prototype.updateTransform.call(this);
  }, t.prototype.getLocalTransform = function(i) {
    var n = this.innerTransformable;
    return n ? n.getLocalTransform(i) : e.prototype.getLocalTransform.call(this, i);
  }, t.prototype.getComputedTransform = function() {
    return this.__hostTarget && (this.__hostTarget.getComputedTransform(), this.__hostTarget.updateInnerText(!0)), e.prototype.getComputedTransform.call(this);
  }, t.prototype._updateSubTexts = function() {
    this._childCursor = 0, UO(this.style), this.style.rich ? this._updateRichTexts() : this._updatePlainTexts(), this._children.length = this._childCursor, this.styleUpdated();
  }, t.prototype.addSelfToZr = function(i) {
    e.prototype.addSelfToZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = i;
  }, t.prototype.removeSelfFromZr = function(i) {
    e.prototype.removeSelfFromZr.call(this, i);
    for (var n = 0; n < this._children.length; n++)
      this._children[n].__zr = null;
  }, t.prototype.getBoundingRect = function() {
    if (this.styleChanged() && this._updateSubTexts(), !this._rect) {
      for (var i = new lt(0, 0, 0, 0), n = this._children, r = [], a = null, s = 0; s < n.length; s++) {
        var o = n[s], l = o.getBoundingRect(), u = o.getLocalTransform(r);
        u ? (i.copy(l), i.applyTransform(u), a = a || i.clone(), a.union(i)) : (a = a || l.clone(), a.union(l));
      }
      this._rect = a || i;
    }
    return this._rect;
  }, t.prototype.setDefaultTextStyle = function(i) {
    this._defaultStyle = i || f0;
  }, t.prototype.setTextContent = function(i) {
    if (process.env.NODE_ENV !== "production")
      throw new Error("Can't attach text on another text");
  }, t.prototype._mergeStyle = function(i, n) {
    if (!n)
      return i;
    var r = n.rich, a = i.rich || r && {};
    return Y(i, n), r && a ? (this._mergeRich(a, r), i.rich = a) : a && (i.rich = a), i;
  }, t.prototype._mergeRich = function(i, n) {
    for (var r = qt(n), a = 0; a < r.length; a++) {
      var s = r[a];
      i[s] = i[s] || {}, Y(i[s], n[s]);
    }
  }, t.prototype.getAnimationStyleProps = function() {
    return zO;
  }, t.prototype._getOrCreateChild = function(i) {
    var n = this._children[this._childCursor];
    return (!n || !(n instanceof i)) && (n = new i()), this._children[this._childCursor++] = n, n.__zr = this.__zr, n.parent = this, n;
  }, t.prototype._updatePlainTexts = function() {
    var i = this.style, n = i.font || nr, r = i.padding, a = this._defaultStyle, s = i.x || 0, o = i.y || 0, l = i.align || a.align || "left", u = i.verticalAlign || a.verticalAlign || "top";
    a0(Vi, a.overflowRect, s, o, l, u), s = Vi.baseX, o = Vi.baseY;
    var c = x0(i), h = oO(c, i, Vi.outerWidth, Vi.outerHeight), d = qh(i), f = !!i.backgroundColor, v = h.outerHeight, m = h.outerWidth, p = h.lines, g = h.lineHeight;
    this.isTruncated = !!h.isTruncated;
    var y = s, _ = ea(o, h.contentHeight, u);
    if (d || r) {
      var b = ls(s, m, l), w = ea(o, v, u);
      d && this._renderBackground(i, i, b, w, m, v);
    }
    _ += g / 2, r && (y = b0(s, l, r), u === "top" ? _ += r[0] : u === "bottom" && (_ -= r[2]));
    for (var S = 0, M = !1, k = !1, T = _0("fill" in i ? i.fill : (k = !0, a.fill)), D = y0("stroke" in i ? i.stroke : !f && (!a.autoStroke || k) ? (S = v0, M = !0, a.stroke) : null), C = i.textShadowBlur > 0, P = 0; P < p.length; P++) {
      var L = this._getOrCreateChild(zu), O = L.createStyle();
      L.useStyle(O), O.text = p[P], O.x = y, O.y = _, O.textAlign = l, O.textBaseline = "middle", O.opacity = i.opacity, O.strokeFirst = !0, C && (O.shadowBlur = i.textShadowBlur || 0, O.shadowColor = i.textShadowColor || "transparent", O.shadowOffsetX = i.textShadowOffsetX || 0, O.shadowOffsetY = i.textShadowOffsetY || 0), O.stroke = D, O.fill = T, D && (O.lineWidth = i.lineWidth || S, O.lineDash = i.lineDash, O.lineDashOffset = i.lineDashOffset || 0), O.font = n, g0(O, i), _ += g, L.setBoundingRect(vf(O, h.contentWidth, h.calculatedLineHeight, M ? 0 : null));
    }
  }, t.prototype._updateRichTexts = function() {
    var i = this.style, n = this._defaultStyle, r = i.align || n.align, a = i.verticalAlign || n.verticalAlign, s = i.x || 0, o = i.y || 0;
    a0(Vi, n.overflowRect, s, o, r, a), s = Vi.baseX, o = Vi.baseY;
    var l = x0(i), u = cO(l, i, Vi.outerWidth, Vi.outerHeight, r), c = u.width, h = u.outerWidth, d = u.outerHeight, f = i.padding;
    this.isTruncated = !!u.isTruncated;
    var v = ls(s, h, r), m = ea(o, d, a), p = v, g = m;
    f && (p += f[3], g += f[0]);
    var y = p + c;
    qh(i) && this._renderBackground(i, i, v, m, h, d);
    for (var _ = !!i.backgroundColor, b = 0; b < u.lines.length; b++) {
      for (var w = u.lines[b], S = w.tokens, M = S.length, k = w.lineHeight, T = w.width, D = 0, C = p, P = y, L = M - 1, O = void 0; D < M && (O = S[D], !O.align || O.align === "left"); )
        this._placeToken(O, i, k, g, C, "left", _), T -= O.width, C += O.width, D++;
      for (; L >= 0 && (O = S[L], O.align === "right"); )
        this._placeToken(O, i, k, g, P, "right", _), T -= O.width, P -= O.width, L--;
      for (C += (c - (C - p) - (y - P) - T) / 2; D <= L; )
        O = S[D], this._placeToken(O, i, k, g, C + O.width / 2, "center", _), C += O.width, D++;
      g += k;
    }
  }, t.prototype._placeToken = function(i, n, r, a, s, o, l) {
    var u = n.rich[i.styleName] || {};
    u.text = i.text;
    var c = i.verticalAlign, h = a + r / 2;
    c === "top" ? h = a + i.height / 2 : c === "bottom" && (h = a + r - i.height / 2);
    var d = !i.isLineHolder && qh(u);
    d && this._renderBackground(u, n, o === "right" ? s - i.width : o === "center" ? s - i.width / 2 : s, h - i.height / 2, i.width, i.height);
    var f = !!u.backgroundColor, v = i.textPadding;
    v && (s = b0(s, o, v), h -= i.height / 2 - v[0] - i.innerHeight / 2);
    var m = this._getOrCreateChild(zu), p = m.createStyle();
    m.useStyle(p);
    var g = this._defaultStyle, y = !1, _ = 0, b = !1, w = _0("fill" in u ? u.fill : "fill" in n ? n.fill : (y = !0, g.fill)), S = y0("stroke" in u ? u.stroke : "stroke" in n ? n.stroke : !f && !l && (!g.autoStroke || y) ? (_ = v0, b = !0, g.stroke) : null), M = u.textShadowBlur > 0 || n.textShadowBlur > 0;
    p.text = i.text, p.x = s, p.y = h, M && (p.shadowBlur = u.textShadowBlur || n.textShadowBlur || 0, p.shadowColor = u.textShadowColor || n.textShadowColor || "transparent", p.shadowOffsetX = u.textShadowOffsetX || n.textShadowOffsetX || 0, p.shadowOffsetY = u.textShadowOffsetY || n.textShadowOffsetY || 0), p.textAlign = o, p.textBaseline = "middle", p.font = i.font || nr, p.opacity = Qr(u.opacity, n.opacity, 1), g0(p, u), S && (p.lineWidth = Qr(u.lineWidth, n.lineWidth, _), p.lineDash = rt(u.lineDash, n.lineDash), p.lineDashOffset = n.lineDashOffset || 0, p.stroke = S), w && (p.fill = w), m.setBoundingRect(vf(p, i.contentWidth, i.contentHeight, b ? 0 : null));
  }, t.prototype._renderBackground = function(i, n, r, a, s, o) {
    var l = i.backgroundColor, u = i.borderWidth, c = i.borderColor, h = l && l.image, d = l && !h, f = i.borderRadius, v = this, m, p;
    if (d || i.lineHeight || u && c) {
      m = this._getOrCreateChild(De), m.useStyle(m.createStyle()), m.style.fill = null;
      var g = m.shape;
      g.x = r, g.y = a, g.width = s, g.height = o, g.r = f, m.dirtyShape();
    }
    if (d) {
      var y = m.style;
      y.fill = l || null, y.fillOpacity = rt(i.fillOpacity, 1);
    } else if (h) {
      p = this._getOrCreateChild(ha), p.onload = function() {
        v.dirtyStyle();
      };
      var _ = p.style;
      _.image = l.image, _.x = r, _.y = a, _.width = s, _.height = o;
    }
    if (u && c) {
      var y = m.style;
      y.lineWidth = u, y.stroke = c, y.strokeOpacity = rt(i.strokeOpacity, 1), y.lineDash = i.borderDash, y.lineDashOffset = i.borderDashOffset || 0, m.strokeContainThreshold = 0, m.hasFill() && m.hasStroke() && (y.strokeFirst = !0, y.lineWidth *= 2);
    }
    var b = (m || p).style;
    b.shadowBlur = i.shadowBlur || 0, b.shadowColor = i.shadowColor || "transparent", b.shadowOffsetX = i.shadowOffsetX || 0, b.shadowOffsetY = i.shadowOffsetY || 0, b.opacity = Qr(i.opacity, n.opacity, 1);
  }, t.makeFont = function(i) {
    var n = "";
    return WO(i) && (n = [
      i.fontStyle,
      i.fontWeight,
      YO(i.fontSize),
      i.fontFamily || "sans-serif"
    ].join(" ")), n && Xi(n) || i.textFont || i.font;
  }, t;
})(Jo), VO = { left: !0, right: 1, center: 1 }, HO = { top: 1, bottom: 1, middle: 1 }, p0 = ["fontStyle", "fontWeight", "fontSize", "fontFamily"];
function YO(e) {
  return typeof e == "string" && (e.indexOf("px") !== -1 || e.indexOf("rem") !== -1 || e.indexOf("em") !== -1) ? e : isNaN(+e) ? bv + "px" : e + "px";
}
function g0(e, t) {
  for (var i = 0; i < p0.length; i++) {
    var n = p0[i], r = t[n];
    r != null && (e[n] = r);
  }
}
function WO(e) {
  return e.fontSize != null || e.fontFamily || e.fontWeight;
}
function UO(e) {
  return m0(e), E(e.rich, m0), e;
}
function m0(e) {
  if (e) {
    e.font = _i.makeFont(e);
    var t = e.align;
    t === "middle" && (t = "center"), e.align = t == null || VO[t] ? t : "left";
    var i = e.verticalAlign;
    i === "center" && (i = "middle"), e.verticalAlign = i == null || HO[i] ? i : "top";
    var n = e.padding;
    n && (e.padding = Mv(e.padding));
  }
}
function y0(e, t) {
  return e == null || t <= 0 || e === "transparent" || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function _0(e) {
  return e == null || e === "none" ? null : e.image || e.colorStops ? "#000" : e;
}
function b0(e, t, i) {
  return t === "right" ? e - i[1] : t === "center" ? e + i[3] / 2 - i[1] / 2 : e + i[3];
}
function x0(e) {
  var t = e.text;
  return t != null && (t += ""), t;
}
function qh(e) {
  return !!(e.backgroundColor || e.lineHeight || e.borderWidth && e.borderColor);
}
var Vt = Gt(), GO = function(e, t, i, n) {
  if (n) {
    var r = Vt(n);
    r.dataIndex = i, r.dataType = t, r.seriesIndex = e, r.ssrType = "chart", n.type === "group" && n.traverse(function(a) {
      var s = Vt(a);
      s.seriesIndex = e, s.dataIndex = i, s.dataType = t, s.ssrType = "chart";
    });
  }
}, w0 = 1, S0 = {}, G1 = Gt(), Iv = Gt(), X1 = 0, Rv = 1, Nv = 2, ar = ["emphasis", "blur", "select"], M0 = ["normal", "emphasis", "blur", "select"], XO = 10, jO = 9, na = "highlight", uu = "downplay", Vu = "select", mf = "unselect", Hu = "toggleSelect", Fv = "selectchanged";
function ka(e) {
  return e != null && e !== "none";
}
function Oc(e, t, i) {
  e.onHoverStateChange && (e.hoverState || 0) !== i && e.onHoverStateChange(t), e.hoverState = i;
}
function j1(e) {
  Oc(e, "emphasis", Nv);
}
function q1(e) {
  e.hoverState === Nv && Oc(e, "normal", X1);
}
function Bv(e) {
  Oc(e, "blur", Rv);
}
function Z1(e) {
  e.hoverState === Rv && Oc(e, "normal", X1);
}
function qO(e) {
  e.selected = !0;
}
function ZO(e) {
  e.selected = !1;
}
function k0(e, t, i) {
  t(e, i);
}
function Ln(e, t, i) {
  k0(e, t, i), e.isGroup && e.traverse(function(n) {
    k0(n, t, i);
  });
}
function KO(e, t, i, n) {
  for (var r = e.style, a = {}, s = 0; s < t.length; s++) {
    var o = t[s], l = r[o];
    a[o] = l ?? (n && n[o]);
  }
  for (var s = 0; s < e.animators.length; s++) {
    var u = e.animators[s];
    u.__fromStateTransition && u.__fromStateTransition.indexOf(i) < 0 && u.targetName === "style" && u.saveTo(a, t);
  }
  return a;
}
function QO(e, t, i, n) {
  var r = i && Ht(i, "select") >= 0, a = !1;
  if (e instanceof $t) {
    var s = G1(e), o = r && s.selectFill || s.normalFill, l = r && s.selectStroke || s.normalStroke;
    if (ka(o) || ka(l)) {
      n = n || {};
      var u = n.style || {};
      u.fill === "inherit" ? (a = !0, n = Y({}, n), u = Y({}, u), u.fill = o) : !ka(u.fill) && ka(o) ? (a = !0, n = Y({}, n), u = Y({}, u), u.fill = Fm(o)) : !ka(u.stroke) && ka(l) && (a || (n = Y({}, n), u = Y({}, u)), u.stroke = Fm(l)), n.style = u;
    }
  }
  if (n && n.z2 == null) {
    a || (n = Y({}, n));
    var c = e.z2EmphasisLift;
    n.z2 = e.z2 + (c ?? XO);
  }
  return n;
}
function JO(e, t, i) {
  if (i && i.z2 == null) {
    i = Y({}, i);
    var n = e.z2SelectLift;
    i.z2 = e.z2 + (n ?? jO);
  }
  return i;
}
function tI(e, t, i) {
  var n = Ht(e.currentStates, t) >= 0, r = e.style.opacity, a = n ? null : KO(e, ["opacity"], t, {
    opacity: 1
  });
  i = i || {};
  var s = i.style || {};
  return s.opacity == null && (i = Y({}, i), s = Y({
    // Already being applied 'emphasis'. DON'T mul opacity multiple times.
    opacity: n ? r : a.opacity * 0.1
  }, s), i.style = s), i;
}
function Zh(e, t) {
  var i = this.states[e];
  if (this.style) {
    if (e === "emphasis")
      return QO(this, e, t, i);
    if (e === "blur")
      return tI(this, e, i);
    if (e === "select")
      return JO(this, e, i);
  }
  return i;
}
function eI(e) {
  e.stateProxy = Zh;
  var t = e.getTextContent(), i = e.getTextGuideLine();
  t && (t.stateProxy = Zh), i && (i.stateProxy = Zh);
}
function D0(e, t) {
  !tx(e, t) && !e.__highByOuter && Ln(e, j1);
}
function T0(e, t) {
  !tx(e, t) && !e.__highByOuter && Ln(e, q1);
}
function Yu(e, t) {
  e.__highByOuter |= 1 << (t || 0), Ln(e, j1);
}
function Wu(e, t) {
  !(e.__highByOuter &= ~(1 << (t || 0))) && Ln(e, q1);
}
function iI(e) {
  Ln(e, Bv);
}
function K1(e) {
  Ln(e, Z1);
}
function Q1(e) {
  Ln(e, qO);
}
function J1(e) {
  Ln(e, ZO);
}
function tx(e, t) {
  return e.__highDownSilentOnTouch && t.zrByTouch;
}
function ex(e) {
  var t = e.getModel(), i = [], n = [];
  t.eachComponent(function(r, a) {
    var s = Iv(a), o = r === "series", l = o ? e.getViewOfSeriesModel(a) : e.getViewOfComponentModel(a);
    !o && n.push(l), s.isBlured && (l.group.traverse(function(u) {
      Z1(u);
    }), o && i.push(a)), s.isBlured = !1;
  }), E(n, function(r) {
    r && r.toggleBlurSeries && r.toggleBlurSeries(i, !1, t);
  });
}
function yf(e, t, i, n) {
  var r = n.getModel();
  i = i || "coordinateSystem";
  function a(u, c) {
    for (var h = 0; h < c.length; h++) {
      var d = u.getItemGraphicEl(c[h]);
      d && K1(d);
    }
  }
  if (e != null && !(!t || t === "none")) {
    var s = r.getSeriesByIndex(e), o = s.coordinateSystem;
    o && o.master && (o = o.master);
    var l = [];
    r.eachSeries(function(u) {
      var c = s === u, h = u.coordinateSystem;
      h && h.master && (h = h.master);
      var d = h && o ? h === o : c;
      if (!// Not blur other series if blurScope series
      (i === "series" && !c || i === "coordinateSystem" && !d || t === "series" && c)) {
        var f = n.getViewOfSeriesModel(u);
        if (f.group.traverse(function(p) {
          p.__highByOuter && c && t === "self" || Bv(p);
        }), Xe(t))
          a(u.getData(), t);
        else if (tt(t))
          for (var v = qt(t), m = 0; m < v.length; m++)
            a(u.getData(v[m]), t[v[m]]);
        l.push(u), Iv(u).isBlured = !0;
      }
    }), r.eachComponent(function(u, c) {
      if (u !== "series") {
        var h = n.getViewOfComponentModel(c);
        h && h.toggleBlurSeries && h.toggleBlurSeries(l, !0, r);
      }
    });
  }
}
function _f(e, t, i) {
  if (!(e == null || t == null)) {
    var n = i.getModel().getComponent(e, t);
    if (n) {
      Iv(n).isBlured = !0;
      var r = i.getViewOfComponentModel(n);
      !r || !r.focusBlurEnabled || r.group.traverse(function(a) {
        Bv(a);
      });
    }
  }
}
function nI(e, t, i) {
  var n = e.seriesIndex, r = e.getData(t.dataType);
  if (!r) {
    process.env.NODE_ENV !== "production" && Kt("Unknown dataType " + t.dataType);
    return;
  }
  var a = Ko(r, t);
  a = (K(a) ? a[0] : a) || 0;
  var s = r.getItemGraphicEl(a);
  if (!s)
    for (var o = r.count(), l = 0; !s && l < o; )
      s = r.getItemGraphicEl(l++);
  if (s) {
    var u = Vt(s);
    yf(n, u.focus, u.blurScope, i);
  } else {
    var c = e.get(["emphasis", "focus"]), h = e.get(["emphasis", "blurScope"]);
    c != null && yf(n, c, h, i);
  }
}
function $v(e, t, i, n) {
  var r = {
    focusSelf: !1,
    dispatchers: null
  };
  if (e == null || e === "series" || t == null || i == null)
    return r;
  var a = n.getModel().getComponent(e, t);
  if (!a)
    return r;
  var s = n.getViewOfComponentModel(a);
  if (!s || !s.findHighDownDispatchers)
    return r;
  for (var o = s.findHighDownDispatchers(i), l, u = 0; u < o.length; u++)
    if (process.env.NODE_ENV !== "production" && !hs(o[u]) && Kt("param should be highDownDispatcher"), Vt(o[u]).focus === "self") {
      l = !0;
      break;
    }
  return {
    focusSelf: l,
    dispatchers: o
  };
}
function rI(e, t, i) {
  process.env.NODE_ENV !== "production" && !hs(e) && Kt("param should be highDownDispatcher");
  var n = Vt(e), r = $v(n.componentMainType, n.componentIndex, n.componentHighDownName, i), a = r.dispatchers, s = r.focusSelf;
  a ? (s && _f(n.componentMainType, n.componentIndex, i), E(a, function(o) {
    return D0(o, t);
  })) : (yf(n.seriesIndex, n.focus, n.blurScope, i), n.focus === "self" && _f(n.componentMainType, n.componentIndex, i), D0(e, t));
}
function aI(e, t, i) {
  process.env.NODE_ENV !== "production" && !hs(e) && Kt("param should be highDownDispatcher"), ex(i);
  var n = Vt(e), r = $v(n.componentMainType, n.componentIndex, n.componentHighDownName, i).dispatchers;
  r ? E(r, function(a) {
    return T0(a, t);
  }) : T0(e, t);
}
function sI(e, t, i) {
  if (bf(t)) {
    var n = t.dataType, r = e.getData(n), a = Ko(r, t);
    K(a) || (a = [a]), e[t.type === Hu ? "toggleSelect" : t.type === Vu ? "select" : "unselect"](a, n);
  }
}
function C0(e) {
  var t = e.getAllData();
  E(t, function(i) {
    var n = i.data, r = i.type;
    n.eachItemGraphicEl(function(a, s) {
      e.isSelected(s, r) ? Q1(a) : J1(a);
    });
  });
}
function oI(e) {
  var t = [];
  return e.eachSeries(function(i) {
    var n = i.getAllData();
    E(n, function(r) {
      r.data;
      var a = r.type, s = i.getSelectedDataIndices();
      if (s.length > 0) {
        var o = {
          dataIndex: s,
          seriesIndex: i.seriesIndex
        };
        a != null && (o.dataType = a), t.push(o);
      }
    });
  }), t;
}
function lI(e, t, i) {
  ix(e, !0), Ln(e, eI), cI(e, t, i);
}
function uI(e) {
  ix(e, !1);
}
function E0(e, t, i, n) {
  n ? uI(e) : lI(e, t, i);
}
function cI(e, t, i) {
  var n = Vt(e);
  t != null ? (n.focus = t, n.blurScope = i) : n.focus && (n.focus = null);
}
var A0 = ["emphasis", "blur", "select"], hI = {
  itemStyle: "getItemStyle",
  lineStyle: "getLineStyle",
  areaStyle: "getAreaStyle"
};
function P0(e, t, i, n) {
  i = i || "itemStyle";
  for (var r = 0; r < A0.length; r++) {
    var a = A0[r], s = t.getModel([a, i]), o = e.ensureState(a);
    o.style = n ? n(s) : s[hI[i]]();
  }
}
function ix(e, t) {
  var i = t === !1, n = e;
  e.highDownSilentOnTouch && (n.__highDownSilentOnTouch = e.highDownSilentOnTouch), (!i || n.__highDownDispatcher) && (n.__highByOuter = n.__highByOuter || 0, n.__highDownDispatcher = !i);
}
function hs(e) {
  return !!(e && e.__highDownDispatcher);
}
function dI(e) {
  var t = S0[e];
  return t == null && w0 <= 32 && (t = S0[e] = w0++), t;
}
function bf(e) {
  var t = e.type;
  return t === Vu || t === mf || t === Hu;
}
function L0(e) {
  var t = e.type;
  return t === na || t === uu;
}
function fI(e) {
  var t = G1(e);
  t.normalFill = e.style.fill, t.normalStroke = e.style.stroke;
  var i = e.states.select || {};
  t.selectFill = i.style && i.style.fill || null, t.selectStroke = i.style && i.style.stroke || null;
}
var Da = cs.CMD, vI = [[], [], []], O0 = Math.sqrt, pI = Math.atan2;
function gI(e, t) {
  if (t) {
    var i = e.data, n = e.len(), r, a, s, o, l, u, c = Da.M, h = Da.C, d = Da.L, f = Da.R, v = Da.A, m = Da.Q;
    for (s = 0, o = 0; s < n; ) {
      switch (r = i[s++], o = s, a = 0, r) {
        case c:
          a = 1;
          break;
        case d:
          a = 1;
          break;
        case h:
          a = 3;
          break;
        case m:
          a = 2;
          break;
        case v:
          var p = t[4], g = t[5], y = O0(t[0] * t[0] + t[1] * t[1]), _ = O0(t[2] * t[2] + t[3] * t[3]), b = pI(-t[1] / _, t[0] / y);
          i[s] *= y, i[s++] += p, i[s] *= _, i[s++] += g, i[s++] *= y, i[s++] *= _, i[s++] += b, i[s++] += b, s += 2, o = s;
          break;
        case f:
          u[0] = i[s++], u[1] = i[s++], Je(u, u, t), i[o++] = u[0], i[o++] = u[1], u[0] += i[s++], u[1] += i[s++], Je(u, u, t), i[o++] = u[0], i[o++] = u[1];
      }
      for (l = 0; l < a; l++) {
        var w = vI[l];
        w[0] = i[s++], w[1] = i[s++], Je(w, w, t), i[o++] = w[0], i[o++] = w[1];
      }
    }
    e.increaseVersion();
  }
}
var Kh = Math.sqrt, Pl = Math.sin, Ll = Math.cos, Ps = Math.PI;
function I0(e) {
  return Math.sqrt(e[0] * e[0] + e[1] * e[1]);
}
function xf(e, t) {
  return (e[0] * t[0] + e[1] * t[1]) / (I0(e) * I0(t));
}
function R0(e, t) {
  return (e[0] * t[1] < e[1] * t[0] ? -1 : 1) * Math.acos(xf(e, t));
}
function N0(e, t, i, n, r, a, s, o, l, u, c) {
  var h = l * (Ps / 180), d = Ll(h) * (e - i) / 2 + Pl(h) * (t - n) / 2, f = -1 * Pl(h) * (e - i) / 2 + Ll(h) * (t - n) / 2, v = d * d / (s * s) + f * f / (o * o);
  v > 1 && (s *= Kh(v), o *= Kh(v));
  var m = (r === a ? -1 : 1) * Kh((s * s * (o * o) - s * s * (f * f) - o * o * (d * d)) / (s * s * (f * f) + o * o * (d * d))) || 0, p = m * s * f / o, g = m * -o * d / s, y = (e + i) / 2 + Ll(h) * p - Pl(h) * g, _ = (t + n) / 2 + Pl(h) * p + Ll(h) * g, b = R0([1, 0], [(d - p) / s, (f - g) / o]), w = [(d - p) / s, (f - g) / o], S = [(-1 * d - p) / s, (-1 * f - g) / o], M = R0(w, S);
  if (xf(w, S) <= -1 && (M = Ps), xf(w, S) >= 1 && (M = 0), M < 0) {
    var k = Math.round(M / Ps * 1e6) / 1e6;
    M = Ps * 2 + k % 2 * Ps;
  }
  c.addData(u, y, _, s, o, b, M, h, a);
}
var mI = /([mlvhzcqtsa])([^mlvhzcqtsa]*)/ig, yI = /-?([0-9]*\.)?[0-9]+([eE]-?[0-9]+)?/g;
function _I(e) {
  var t = new cs();
  if (!e)
    return t;
  var i = 0, n = 0, r = i, a = n, s, o = cs.CMD, l = e.match(mI);
  if (!l)
    return t;
  for (var u = 0; u < l.length; u++) {
    for (var c = l[u], h = c.charAt(0), d = void 0, f = c.match(yI) || [], v = f.length, m = 0; m < v; m++)
      f[m] = parseFloat(f[m]);
    for (var p = 0; p < v; ) {
      var g = void 0, y = void 0, _ = void 0, b = void 0, w = void 0, S = void 0, M = void 0, k = i, T = n, D = void 0, C = void 0;
      switch (h) {
        case "l":
          i += f[p++], n += f[p++], d = o.L, t.addData(d, i, n);
          break;
        case "L":
          i = f[p++], n = f[p++], d = o.L, t.addData(d, i, n);
          break;
        case "m":
          i += f[p++], n += f[p++], d = o.M, t.addData(d, i, n), r = i, a = n, h = "l";
          break;
        case "M":
          i = f[p++], n = f[p++], d = o.M, t.addData(d, i, n), r = i, a = n, h = "L";
          break;
        case "h":
          i += f[p++], d = o.L, t.addData(d, i, n);
          break;
        case "H":
          i = f[p++], d = o.L, t.addData(d, i, n);
          break;
        case "v":
          n += f[p++], d = o.L, t.addData(d, i, n);
          break;
        case "V":
          n = f[p++], d = o.L, t.addData(d, i, n);
          break;
        case "C":
          d = o.C, t.addData(d, f[p++], f[p++], f[p++], f[p++], f[p++], f[p++]), i = f[p - 2], n = f[p - 1];
          break;
        case "c":
          d = o.C, t.addData(d, f[p++] + i, f[p++] + n, f[p++] + i, f[p++] + n, f[p++] + i, f[p++] + n), i += f[p - 2], n += f[p - 1];
          break;
        case "S":
          g = i, y = n, D = t.len(), C = t.data, s === o.C && (g += i - C[D - 4], y += n - C[D - 3]), d = o.C, k = f[p++], T = f[p++], i = f[p++], n = f[p++], t.addData(d, g, y, k, T, i, n);
          break;
        case "s":
          g = i, y = n, D = t.len(), C = t.data, s === o.C && (g += i - C[D - 4], y += n - C[D - 3]), d = o.C, k = i + f[p++], T = n + f[p++], i += f[p++], n += f[p++], t.addData(d, g, y, k, T, i, n);
          break;
        case "Q":
          k = f[p++], T = f[p++], i = f[p++], n = f[p++], d = o.Q, t.addData(d, k, T, i, n);
          break;
        case "q":
          k = f[p++] + i, T = f[p++] + n, i += f[p++], n += f[p++], d = o.Q, t.addData(d, k, T, i, n);
          break;
        case "T":
          g = i, y = n, D = t.len(), C = t.data, s === o.Q && (g += i - C[D - 4], y += n - C[D - 3]), i = f[p++], n = f[p++], d = o.Q, t.addData(d, g, y, i, n);
          break;
        case "t":
          g = i, y = n, D = t.len(), C = t.data, s === o.Q && (g += i - C[D - 4], y += n - C[D - 3]), i += f[p++], n += f[p++], d = o.Q, t.addData(d, g, y, i, n);
          break;
        case "A":
          _ = f[p++], b = f[p++], w = f[p++], S = f[p++], M = f[p++], k = i, T = n, i = f[p++], n = f[p++], d = o.A, N0(k, T, i, n, S, M, _, b, w, d, t);
          break;
        case "a":
          _ = f[p++], b = f[p++], w = f[p++], S = f[p++], M = f[p++], k = i, T = n, i += f[p++], n += f[p++], d = o.A, N0(k, T, i, n, S, M, _, b, w, d, t);
          break;
      }
    }
    (h === "z" || h === "Z") && (d = o.Z, t.addData(d), i = r, n = a), s = d;
  }
  return t.toStatic(), t;
}
var nx = (function(e) {
  Lt(t, e);
  function t() {
    return e !== null && e.apply(this, arguments) || this;
  }
  return t.prototype.applyTransform = function(i) {
  }, t;
})($t);
function rx(e) {
  return e.setData != null;
}
function ax(e, t) {
  var i = _I(e), n = Y({}, t);
  return n.buildPath = function(r) {
    var a = rx(r);
    if (a && r.canSave()) {
      r.appendPath(i);
      var s = r.getContext();
      s && r.rebuildPath(s, 1);
    } else {
      var s = a ? r.getContext() : r;
      s && i.rebuildPath(s, 1);
    }
  }, n.applyTransform = function(r) {
    gI(i, r), this.dirtyShape();
  }, n;
}
function bI(e, t) {
  return new nx(ax(e, t));
}
function xI(e, t) {
  var i = ax(e, t), n = (function(r) {
    Lt(a, r);
    function a(s) {
      var o = r.call(this, s) || this;
      return o.applyTransform = i.applyTransform, o.buildPath = i.buildPath, o;
    }
    return a;
  })(nx);
  return n;
}
function wI(e, t) {
  for (var i = [], n = e.length, r = 0; r < n; r++) {
    var a = e[r];
    i.push(a.getUpdatedPathProxy(!0));
  }
  var s = new $t(t);
  return s.createPathProxy(), s.buildPath = function(o) {
    if (rx(o)) {
      o.appendPath(i);
      var l = o.getContext();
      l && o.rebuildPath(l, 1);
    }
  }, s;
}
var SI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0;
  }
  return e;
})(), Ic = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new SI();
  }, t.prototype.buildPath = function(i, n) {
    i.moveTo(n.cx + n.r, n.cy), i.arc(n.cx, n.cy, n.r, 0, Math.PI * 2);
  }, t;
})($t);
Ic.prototype.type = "circle";
var MI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.rx = 0, this.ry = 0;
  }
  return e;
})(), zv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new MI();
  }, t.prototype.buildPath = function(i, n) {
    var r = 0.5522848, a = n.cx, s = n.cy, o = n.rx, l = n.ry, u = o * r, c = l * r;
    i.moveTo(a - o, s), i.bezierCurveTo(a - o, s - c, a - u, s - l, a, s - l), i.bezierCurveTo(a + u, s - l, a + o, s - c, a + o, s), i.bezierCurveTo(a + o, s + c, a + u, s + l, a, s + l), i.bezierCurveTo(a - u, s + l, a - o, s + c, a - o, s), i.closePath();
  }, t;
})($t);
zv.prototype.type = "ellipse";
var sx = Math.PI, Qh = sx * 2, Dr = Math.sin, Ta = Math.cos, kI = Math.acos, be = Math.atan2, F0 = Math.abs, yo = Math.sqrt, no = Math.max, Hi = Math.min, wi = 1e-4;
function DI(e, t, i, n, r, a, s, o) {
  var l = i - e, u = n - t, c = s - r, h = o - a, d = h * l - c * u;
  if (!(d * d < wi))
    return d = (c * (t - a) - h * (e - r)) / d, [e + d * l, t + d * u];
}
function Ol(e, t, i, n, r, a, s) {
  var o = e - i, l = t - n, u = (s ? a : -a) / yo(o * o + l * l), c = u * l, h = -u * o, d = e + c, f = t + h, v = i + c, m = n + h, p = (d + v) / 2, g = (f + m) / 2, y = v - d, _ = m - f, b = y * y + _ * _, w = r - a, S = d * m - v * f, M = (_ < 0 ? -1 : 1) * yo(no(0, w * w * b - S * S)), k = (S * _ - y * M) / b, T = (-S * y - _ * M) / b, D = (S * _ + y * M) / b, C = (-S * y + _ * M) / b, P = k - p, L = T - g, O = D - p, N = C - g;
  return P * P + L * L > O * O + N * N && (k = D, T = C), {
    cx: k,
    cy: T,
    x0: -c,
    y0: -h,
    x1: k * (r / w - 1),
    y1: T * (r / w - 1)
  };
}
function TI(e) {
  var t;
  if (K(e)) {
    var i = e.length;
    if (!i)
      return e;
    i === 1 ? t = [e[0], e[0], 0, 0] : i === 2 ? t = [e[0], e[0], e[1], e[1]] : i === 3 ? t = e.concat(e[2]) : t = e;
  } else
    t = [e, e, e, e];
  return t;
}
function CI(e, t) {
  var i, n = no(t.r, 0), r = no(t.r0 || 0, 0), a = n > 0, s = r > 0;
  if (!(!a && !s)) {
    if (a || (n = r, r = 0), r > n) {
      var o = n;
      n = r, r = o;
    }
    var l = t.startAngle, u = t.endAngle;
    if (!(isNaN(l) || isNaN(u))) {
      var c = t.cx, h = t.cy, d = !!t.clockwise, f = F0(u - l), v = f > Qh && f % Qh;
      if (v > wi && (f = v), !(n > wi))
        e.moveTo(c, h);
      else if (f > Qh - wi)
        e.moveTo(c + n * Ta(l), h + n * Dr(l)), e.arc(c, h, n, l, u, !d), r > wi && (e.moveTo(c + r * Ta(u), h + r * Dr(u)), e.arc(c, h, r, u, l, d));
      else {
        var m = void 0, p = void 0, g = void 0, y = void 0, _ = void 0, b = void 0, w = void 0, S = void 0, M = void 0, k = void 0, T = void 0, D = void 0, C = void 0, P = void 0, L = void 0, O = void 0, N = n * Ta(l), B = n * Dr(l), G = r * Ta(u), V = r * Dr(u), F = f > wi;
        if (F) {
          var $ = t.cornerRadius;
          $ && (i = TI($), m = i[0], p = i[1], g = i[2], y = i[3]);
          var Z = F0(n - r) / 2;
          if (_ = Hi(Z, g), b = Hi(Z, y), w = Hi(Z, m), S = Hi(Z, p), T = M = no(_, b), D = k = no(w, S), (M > wi || k > wi) && (C = n * Ta(u), P = n * Dr(u), L = r * Ta(l), O = r * Dr(l), f < sx)) {
            var j = DI(N, B, L, O, C, P, G, V);
            if (j) {
              var it = N - j[0], st = B - j[1], wt = C - j[0], Tt = P - j[1], me = 1 / Dr(kI((it * wt + st * Tt) / (yo(it * it + st * st) * yo(wt * wt + Tt * Tt))) / 2), Ae = yo(j[0] * j[0] + j[1] * j[1]);
              T = Hi(M, (n - Ae) / (me + 1)), D = Hi(k, (r - Ae) / (me - 1));
            }
          }
        }
        if (!F)
          e.moveTo(c + N, h + B);
        else if (T > wi) {
          var At = Hi(g, T), Ft = Hi(y, T), at = Ol(L, O, N, B, n, At, d), ft = Ol(C, P, G, V, n, Ft, d);
          e.moveTo(c + at.cx + at.x0, h + at.cy + at.y0), T < M && At === Ft ? e.arc(c + at.cx, h + at.cy, T, be(at.y0, at.x0), be(ft.y0, ft.x0), !d) : (At > 0 && e.arc(c + at.cx, h + at.cy, At, be(at.y0, at.x0), be(at.y1, at.x1), !d), e.arc(c, h, n, be(at.cy + at.y1, at.cx + at.x1), be(ft.cy + ft.y1, ft.cx + ft.x1), !d), Ft > 0 && e.arc(c + ft.cx, h + ft.cy, Ft, be(ft.y1, ft.x1), be(ft.y0, ft.x0), !d));
        } else
          e.moveTo(c + N, h + B), e.arc(c, h, n, l, u, !d);
        if (!(r > wi) || !F)
          e.lineTo(c + G, h + V);
        else if (D > wi) {
          var At = Hi(m, D), Ft = Hi(p, D), at = Ol(G, V, C, P, r, -Ft, d), ft = Ol(N, B, L, O, r, -At, d);
          e.lineTo(c + at.cx + at.x0, h + at.cy + at.y0), D < k && At === Ft ? e.arc(c + at.cx, h + at.cy, D, be(at.y0, at.x0), be(ft.y0, ft.x0), !d) : (Ft > 0 && e.arc(c + at.cx, h + at.cy, Ft, be(at.y0, at.x0), be(at.y1, at.x1), !d), e.arc(c, h, r, be(at.cy + at.y1, at.cx + at.x1), be(ft.cy + ft.y1, ft.cx + ft.x1), d), At > 0 && e.arc(c + ft.cx, h + ft.cy, At, be(ft.y1, ft.x1), be(ft.y0, ft.x0), !d));
        } else
          e.lineTo(c + G, h + V), e.arc(c, h, r, u, l, d);
      }
      e.closePath();
    }
  }
}
var EI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r0 = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0, this.cornerRadius = 0;
  }
  return e;
})(), Vv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new EI();
  }, t.prototype.buildPath = function(i, n) {
    CI(i, n);
  }, t.prototype.isZeroArea = function() {
    return this.shape.startAngle === this.shape.endAngle || this.shape.r === this.shape.r0;
  }, t;
})($t);
Vv.prototype.type = "sector";
var AI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.r0 = 0;
  }
  return e;
})(), Hv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new AI();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, s = Math.PI * 2;
    i.moveTo(r + n.r, a), i.arc(r, a, n.r, 0, s, !1), i.moveTo(r + n.r0, a), i.arc(r, a, n.r0, 0, s, !0);
  }, t;
})($t);
Hv.prototype.type = "ring";
function PI(e, t, i, n) {
  var r = [], a = [], s = [], o = [], l, u, c, h;
  if (n) {
    c = [1 / 0, 1 / 0], h = [-1 / 0, -1 / 0];
    for (var d = 0, f = e.length; d < f; d++)
      Va(c, c, e[d]), Ha(h, h, e[d]);
    Va(c, c, n[0]), Ha(h, h, n[1]);
  }
  for (var d = 0, f = e.length; d < f; d++) {
    var v = e[d];
    if (i)
      l = e[d ? d - 1 : f - 1], u = e[(d + 1) % f];
    else if (d === 0 || d === f - 1) {
      r.push(iP(e[d]));
      continue;
    } else
      l = e[d - 1], u = e[d + 1];
    nP(a, u, l), vh(a, a, t);
    var m = jd(v, l), p = jd(v, u), g = m + p;
    g !== 0 && (m /= g, p /= g), vh(s, a, -m), vh(o, a, p);
    var y = _m([], v, s), _ = _m([], v, o);
    n && (Ha(y, y, c), Va(y, y, h), Ha(_, _, c), Va(_, _, h)), r.push(y), r.push(_);
  }
  return i && r.push(r.shift()), r;
}
function ox(e, t, i) {
  var n = t.smooth, r = t.points;
  if (r && r.length >= 2) {
    if (n) {
      var a = PI(r, n, i, t.smoothConstraint);
      e.moveTo(r[0][0], r[0][1]);
      for (var s = r.length, o = 0; o < (i ? s : s - 1); o++) {
        var l = a[o * 2], u = a[o * 2 + 1], c = r[(o + 1) % s];
        e.bezierCurveTo(l[0], l[1], u[0], u[1], c[0], c[1]);
      }
    } else {
      e.moveTo(r[0][0], r[0][1]);
      for (var o = 1, h = r.length; o < h; o++)
        e.lineTo(r[o][0], r[o][1]);
    }
    i && e.closePath();
  }
}
var LI = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), Yv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultShape = function() {
    return new LI();
  }, t.prototype.buildPath = function(i, n) {
    ox(i, n, !0);
  }, t;
})($t);
Yv.prototype.type = "polygon";
var OI = /* @__PURE__ */ (function() {
  function e() {
    this.points = null, this.percent = 1, this.smooth = 0, this.smoothConstraint = null;
  }
  return e;
})(), Wv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new OI();
  }, t.prototype.buildPath = function(i, n) {
    ox(i, n, !1);
  }, t;
})($t);
Wv.prototype.type = "polyline";
var II = {}, RI = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.percent = 1;
  }
  return e;
})(), ms = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new RI();
  }, t.prototype.buildPath = function(i, n) {
    var r, a, s, o;
    if (this.subPixelOptimize) {
      var l = W1(II, n, this.style);
      r = l.x1, a = l.y1, s = l.x2, o = l.y2;
    } else
      r = n.x1, a = n.y1, s = n.x2, o = n.y2;
    var u = n.percent;
    u !== 0 && (i.moveTo(r, a), u < 1 && (s = r * (1 - u) + s * u, o = a * (1 - u) + o * u), i.lineTo(s, o));
  }, t.prototype.pointAt = function(i) {
    var n = this.shape;
    return [
      n.x1 * (1 - i) + n.x2 * i,
      n.y1 * (1 - i) + n.y2 * i
    ];
  }, t;
})($t);
ms.prototype.type = "line";
var Be = [], NI = /* @__PURE__ */ (function() {
  function e() {
    this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.percent = 1;
  }
  return e;
})();
function B0(e, t, i) {
  var n = e.cpx2, r = e.cpy2;
  return n != null || r != null ? [
    (i ? Lm : Le)(e.x1, e.cpx1, e.cpx2, e.x2, t),
    (i ? Lm : Le)(e.y1, e.cpy1, e.cpy2, e.y2, t)
  ] : [
    (i ? Om : He)(e.x1, e.cpx1, e.x2, t),
    (i ? Om : He)(e.y1, e.cpy1, e.y2, t)
  ];
}
var Uv = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new NI();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.x1, a = n.y1, s = n.x2, o = n.y2, l = n.cpx1, u = n.cpy1, c = n.cpx2, h = n.cpy2, d = n.percent;
    d !== 0 && (i.moveTo(r, a), c == null || h == null ? (d < 1 && (Ou(r, l, s, d, Be), l = Be[1], s = Be[2], Ou(a, u, o, d, Be), u = Be[1], o = Be[2]), i.quadraticCurveTo(l, u, s, o)) : (d < 1 && (Lu(r, l, c, s, d, Be), l = Be[1], c = Be[2], s = Be[3], Lu(a, u, h, o, d, Be), u = Be[1], h = Be[2], o = Be[3]), i.bezierCurveTo(l, u, c, h, s, o)));
  }, t.prototype.pointAt = function(i) {
    return B0(this.shape, i, !1);
  }, t.prototype.tangentAt = function(i) {
    var n = B0(this.shape, i, !0);
    return sP(n, n);
  }, t;
})($t);
Uv.prototype.type = "bezier-curve";
var FI = /* @__PURE__ */ (function() {
  function e() {
    this.cx = 0, this.cy = 0, this.r = 0, this.startAngle = 0, this.endAngle = Math.PI * 2, this.clockwise = !0;
  }
  return e;
})(), Rc = (function(e) {
  Lt(t, e);
  function t(i) {
    return e.call(this, i) || this;
  }
  return t.prototype.getDefaultStyle = function() {
    return {
      stroke: "#000",
      fill: null
    };
  }, t.prototype.getDefaultShape = function() {
    return new FI();
  }, t.prototype.buildPath = function(i, n) {
    var r = n.cx, a = n.cy, s = Math.max(n.r, 0), o = n.startAngle, l = n.endAngle, u = n.clockwise, c = Math.cos(o), h = Math.sin(o);
    i.moveTo(c * s + r, h * s + a), i.arc(r, a, s, o, l, !u);
  }, t;
})($t);
Rc.prototype.type = "arc";
var BI = (function(e) {
  Lt(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.type = "compound", i;
  }
  return t.prototype._updatePathDirty = function() {
    for (var i = this.shape.paths, n = this.shapeChanged(), r = 0; r < i.length; r++)
      n = n || i[r].shapeChanged();
    n && this.dirtyShape();
  }, t.prototype.beforeBrush = function() {
    this._updatePathDirty();
    for (var i = this.shape.paths || [], n = this.getGlobalScale(), r = 0; r < i.length; r++)
      i[r].path || i[r].createPathProxy(), i[r].path.setScale(n[0], n[1], i[r].segmentIgnoreThreshold);
  }, t.prototype.buildPath = function(i, n) {
    for (var r = n.paths || [], a = 0; a < r.length; a++)
      r[a].buildPath(i, r[a].shape, !0);
  }, t.prototype.afterBrush = function() {
    for (var i = this.shape.paths || [], n = 0; n < i.length; n++)
      i[n].pathUpdated();
  }, t.prototype.getBoundingRect = function() {
    return this._updatePathDirty.call(this), $t.prototype.getBoundingRect.call(this);
  }, t;
})($t), lx = (function() {
  function e(t) {
    this.colorStops = t || [];
  }
  return e.prototype.addColorStop = function(t, i) {
    this.colorStops.push({
      offset: t,
      color: i
    });
  }, e;
})(), ux = (function(e) {
  Lt(t, e);
  function t(i, n, r, a, s, o) {
    var l = e.call(this, s) || this;
    return l.x = i ?? 0, l.y = n ?? 0, l.x2 = r ?? 1, l.y2 = a ?? 0, l.type = "linear", l.global = o || !1, l;
  }
  return t;
})(lx), $I = (function(e) {
  Lt(t, e);
  function t(i, n, r, a, s) {
    var o = e.call(this, a) || this;
    return o.x = i ?? 0.5, o.y = n ?? 0.5, o.r = r ?? 0.5, o.type = "radial", o.global = s || !1, o;
  }
  return t;
})(lx), Jh = Math.min, zI = Math.max, Il = Math.abs, Tr = [0, 0], Cr = [0, 0], pe = s1(), Rl = pe.minTv, Nl = pe.maxTv, cx = (function() {
  function e(t, i) {
    this._corners = [], this._axes = [], this._origin = [0, 0];
    for (var n = 0; n < 4; n++)
      this._corners[n] = new It();
    for (var n = 0; n < 2; n++)
      this._axes[n] = new It();
    t && this.fromBoundingRect(t, i);
  }
  return e.prototype.fromBoundingRect = function(t, i) {
    var n = this._corners, r = this._axes, a = t.x, s = t.y, o = a + t.width, l = s + t.height;
    if (n[0].set(a, s), n[1].set(o, s), n[2].set(o, l), n[3].set(a, l), i)
      for (var u = 0; u < 4; u++)
        n[u].transform(i);
    It.sub(r[0], n[1], n[0]), It.sub(r[1], n[3], n[0]), r[0].normalize(), r[1].normalize();
    for (var u = 0; u < 2; u++)
      this._origin[u] = r[u].dot(n[0]);
  }, e.prototype.intersect = function(t, i, n) {
    var r = !0, a = !i;
    return i && It.set(i, 0, 0), pe.reset(n, !a), !this._intersectCheckOneSide(this, t, a, 1) && (r = !1, a) || !this._intersectCheckOneSide(t, this, a, -1) && (r = !1, a) || !a && !pe.negativeSize && It.copy(i, r ? pe.useDir ? pe.dirMinTv : Rl : Nl), r;
  }, e.prototype._intersectCheckOneSide = function(t, i, n, r) {
    for (var a = !0, s = 0; s < 2; s++) {
      var o = t._axes[s];
      if (t._getProjMinMaxOnAxis(s, t._corners, Tr), t._getProjMinMaxOnAxis(s, i._corners, Cr), pe.negativeSize || Tr[1] < Cr[0] || Tr[0] > Cr[1]) {
        if (a = !1, pe.negativeSize || n)
          return a;
        var l = Il(Cr[0] - Tr[1]), u = Il(Tr[0] - Cr[1]);
        Jh(l, u) > Nl.len() && (l < u ? It.scale(Nl, o, -l * r) : It.scale(Nl, o, u * r));
      } else if (!n) {
        var l = Il(Cr[0] - Tr[1]), u = Il(Tr[0] - Cr[1]);
        (pe.useDir || Jh(l, u) < Rl.len()) && ((l < u || !pe.bidirectional) && (It.scale(Rl, o, l * r), pe.useDir && pe.calcDirMTV()), (l >= u || !pe.bidirectional) && (It.scale(Rl, o, -u * r), pe.useDir && pe.calcDirMTV()));
      }
    }
    return a;
  }, e.prototype._getProjMinMaxOnAxis = function(t, i, n) {
    for (var r = this._axes[t], a = this._origin, s = i[0].dot(r) + a[t], o = s, l = s, u = 1; u < i.length; u++) {
      var c = i[u].dot(r) + a[t];
      o = Jh(c, o), l = zI(c, l);
    }
    n[0] = o + pe.touchThreshold, n[1] = l - pe.touchThreshold, pe.negativeSize = n[1] < n[0];
  }, e;
})(), VI = [], HI = (function(e) {
  Lt(t, e);
  function t() {
    var i = e !== null && e.apply(this, arguments) || this;
    return i.notClear = !0, i.incremental = !0, i._displayables = [], i._temporaryDisplayables = [], i._cursor = 0, i;
  }
  return t.prototype.traverse = function(i, n) {
    i.call(n, this);
  }, t.prototype.useStyle = function() {
    this.style = {};
  }, t.prototype.getCursor = function() {
    return this._cursor;
  }, t.prototype.innerAfterBrush = function() {
    this._cursor = this._displayables.length;
  }, t.prototype.clearDisplaybles = function() {
    this._displayables = [], this._temporaryDisplayables = [], this._cursor = 0, this.markRedraw(), this.notClear = !1;
  }, t.prototype.clearTemporalDisplayables = function() {
    this._temporaryDisplayables = [];
  }, t.prototype.addDisplayable = function(i, n) {
    n ? this._temporaryDisplayables.push(i) : this._displayables.push(i), this.markRedraw();
  }, t.prototype.addDisplayables = function(i, n) {
    n = n || !1;
    for (var r = 0; r < i.length; r++)
      this.addDisplayable(i[r], n);
  }, t.prototype.getDisplayables = function() {
    return this._displayables;
  }, t.prototype.getTemporalDisplayables = function() {
    return this._temporaryDisplayables;
  }, t.prototype.eachPendingDisplayable = function(i) {
    for (var n = this._cursor; n < this._displayables.length; n++)
      i && i(this._displayables[n]);
    for (var n = 0; n < this._temporaryDisplayables.length; n++)
      i && i(this._temporaryDisplayables[n]);
  }, t.prototype.update = function() {
    this.updateTransform();
    for (var i = this._cursor; i < this._displayables.length; i++) {
      var n = this._displayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
    for (var i = 0; i < this._temporaryDisplayables.length; i++) {
      var n = this._temporaryDisplayables[i];
      n.parent = this, n.update(), n.parent = null;
    }
  }, t.prototype.getBoundingRect = function() {
    if (!this._rect) {
      for (var i = new lt(1 / 0, 1 / 0, -1 / 0, -1 / 0), n = 0; n < this._displayables.length; n++) {
        var r = this._displayables[n], a = r.getBoundingRect().clone();
        r.needLocalTransform() && a.applyTransform(r.getLocalTransform(VI)), i.union(a);
      }
      this._rect = i;
    }
    return this._rect;
  }, t.prototype.contain = function(i, n) {
    var r = this.transformCoordToLocal(i, n), a = this.getBoundingRect();
    if (a.contain(r[0], r[1]))
      for (var s = 0; s < this._displayables.length; s++) {
        var o = this._displayables[s];
        if (o.contain(i, n))
          return !0;
      }
    return !1;
  }, t;
})(Jo);
Gt();
function YI(e, t, i, n, r) {
  var a;
  if (t && t.ecModel) {
    var s = t.ecModel.getUpdatePayload();
    a = s && s.animation;
  }
  var o = t && t.isAnimationEnabled(), l = e === "update";
  if (o) {
    var u = void 0, c = void 0, h = void 0;
    n ? (u = rt(n.duration, 200), c = rt(n.easing, "cubicOut"), h = 0) : (u = t.getShallow(l ? "animationDurationUpdate" : "animationDuration"), c = t.getShallow(l ? "animationEasingUpdate" : "animationEasing"), h = t.getShallow(l ? "animationDelayUpdate" : "animationDelay")), a && (a.duration != null && (u = a.duration), a.easing != null && (c = a.easing), a.delay != null && (h = a.delay)), mt(h) && (h = h(i, r)), mt(u) && (u = u(i));
    var d = {
      duration: u || 0,
      delay: h,
      easing: c
    };
    return d;
  } else
    return null;
}
function Gv(e, t, i, n, r, a, s) {
  var o = !1, l;
  mt(r) ? (s = a, a = r, r = null) : tt(r) && (a = r.cb, s = r.during, o = r.isFrom, l = r.removeOpt, r = r.dataIndex);
  var u = e === "leave";
  u || t.stopAnimation("leave");
  var c = YI(e, n, r, u ? l || {} : null, n && n.getAnimationDelayParams ? n.getAnimationDelayParams(t, r) : null);
  if (c && c.duration > 0) {
    var h = c.duration, d = c.delay, f = c.easing, v = {
      duration: h,
      delay: d || 0,
      easing: f,
      done: a,
      force: !!a || !!s,
      // Set to final state in update/init animation.
      // So the post processing based on the path shape can be done correctly.
      setToFinal: !u,
      scope: e,
      during: s
    };
    o ? t.animateFrom(i, v) : t.animateTo(i, v);
  } else
    t.stopAnimation(), !o && t.attr(i), s && s(1), a && a();
}
function Xv(e, t, i, n, r, a) {
  Gv("update", e, t, i, n, r, a);
}
function hx(e, t, i, n, r, a) {
  Gv("enter", e, t, i, n, r, a);
}
function _o(e) {
  if (!e.__zr)
    return !0;
  for (var t = 0; t < e.animators.length; t++) {
    var i = e.animators[t];
    if (i.scope === "leave")
      return !0;
  }
  return !1;
}
function dx(e, t, i, n, r, a) {
  _o(e) || Gv("leave", e, t, i, n, r, a);
}
function $0(e, t, i, n) {
  e.removeTextContent(), e.removeTextGuideLine(), dx(e, {
    style: {
      opacity: 0
    }
  }, t, i, n);
}
function WI(e, t, i) {
  function n() {
    e.parent && e.parent.remove(e);
  }
  e.isGroup ? e.traverse(function(r) {
    r.isGroup || $0(r, t, i, n);
  }) : $0(e, t, i, n);
}
var wf = {}, UI = ["x", "y"], GI = ["width", "height"];
function XI(e) {
  return $t.extend(e);
}
var jI = xI;
function qI(e, t) {
  return jI(e, t);
}
function Oi(e, t) {
  wf[e] = t;
}
function ZI(e) {
  if (wf.hasOwnProperty(e))
    return wf[e];
}
function jv(e, t, i, n) {
  var r = bI(e, t);
  return i && (n === "center" && (i = vx(i, r.getBoundingRect())), px(r, i)), r;
}
function fx(e, t, i) {
  var n = new ha({
    style: {
      image: e,
      x: t.x,
      y: t.y,
      width: t.width,
      height: t.height
    },
    onload: function(r) {
      if (i === "center") {
        var a = {
          width: r.width,
          height: r.height
        };
        n.setStyle(vx(t, a));
      }
    }
  });
  return n;
}
function vx(e, t) {
  var i = t.width / t.height, n = e.height * i, r;
  n <= e.width ? r = e.height : (n = e.width, r = n / i);
  var a = e.x + e.width / 2, s = e.y + e.height / 2;
  return {
    x: a - n / 2,
    y: s - r / 2,
    width: n,
    height: r
  };
}
var KI = wI;
function px(e, t) {
  if (e.applyTransform) {
    var i = e.getBoundingRect(), n = i.calculateTransform(t);
    e.applyTransform(n);
  }
}
function qv(e, t) {
  return W1(e, e, {
    lineWidth: t
  }), e;
}
function QI(e, t) {
  return U1(e, e, t), e;
}
var JI = Ur;
function tR(e, t) {
  for (var i = Dv([]); e && e !== t; )
    vo(i, e.getLocalTransform(), i), e = e.parent;
  return i;
}
function Zv(e, t, i) {
  return t && !Xe(t) && (t = Wr.getLocalTransform(t)), i && (t = qo([], t)), Je([], e, t);
}
function eR(e, t, i) {
  var n = t[4] === 0 || t[5] === 0 || t[0] === 0 ? 1 : _n(2 * t[4] / t[0]), r = t[4] === 0 || t[5] === 0 || t[2] === 0 ? 1 : _n(2 * t[4] / t[2]), a = [e === "left" ? -n : e === "right" ? n : 0, e === "top" ? -r : e === "bottom" ? r : 0];
  return a = Zv(a, t, i), _n(a[0]) > _n(a[1]) ? a[0] > 0 ? "right" : "left" : a[1] > 0 ? "bottom" : "top";
}
function z0(e) {
  return !e.isGroup;
}
function iR(e) {
  return e.shape != null;
}
function nR(e, t, i) {
  if (!e || !t)
    return;
  function n(s) {
    var o = {};
    return s.traverse(function(l) {
      z0(l) && l.anid && (o[l.anid] = l);
    }), o;
  }
  function r(s) {
    var o = {
      x: s.x,
      y: s.y,
      rotation: s.rotation
    };
    return iR(s) && (o.shape = pt(s.shape)), o;
  }
  var a = n(e);
  t.traverse(function(s) {
    if (z0(s) && s.anid) {
      var o = a[s.anid];
      if (o) {
        var l = r(s);
        s.attr(r(o)), Xv(s, l, i, Vt(s).dataIndex);
      }
    }
  });
}
function rR(e, t) {
  return _t(e, function(i) {
    var n = i[0];
    n = ki(n, t.x), n = Oo(n, t.x + t.width);
    var r = i[1];
    return r = ki(r, t.y), r = Oo(r, t.y + t.height), [n, r];
  });
}
function aR(e, t) {
  var i = ki(e.x, t.x), n = Oo(e.x + e.width, t.x + t.width), r = ki(e.y, t.y), a = Oo(e.y + e.height, t.y + t.height);
  if (n >= i && a >= r)
    return {
      x: i,
      y: r,
      width: n - i,
      height: a - r
    };
}
function gx(e, t, i) {
  var n = Y({
    rectHover: !0
  }, t), r = n.style = {
    strokeNoScale: !0
  };
  if (i = i || {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }, e)
    return e.indexOf("image://") === 0 ? (r.image = e.slice(8), Jt(r, i), new ha(n)) : jv(e.replace("path://", ""), n, i, "center");
}
function sR(e, t, i, n, r) {
  for (var a = 0, s = r[r.length - 1]; a < r.length; a++) {
    var o = r[a];
    if (mx(e, t, i, n, o[0], o[1], s[0], s[1]))
      return !0;
    s = o;
  }
}
function mx(e, t, i, n, r, a, s, o) {
  var l = i - e, u = n - t, c = s - r, h = o - a, d = td(c, h, l, u);
  if (oR(d))
    return !1;
  var f = e - r, v = t - a, m = td(f, v, l, u) / d;
  if (m < 0 || m > 1)
    return !1;
  var p = td(f, v, c, h) / d;
  return !(p < 0 || p > 1);
}
function td(e, t, i, n) {
  return e * n - i * t;
}
function oR(e) {
  return e <= 1e-6 && e >= -1e-6;
}
function Sf(e, t, i, n, r) {
  return t == null || (Zt(t) ? Bt[0] = Bt[1] = Bt[2] = Bt[3] = t : (process.env.NODE_ENV !== "production" && nt(t.length === 4), Bt[0] = t[0], Bt[1] = t[1], Bt[2] = t[2], Bt[3] = t[3]), n && (Bt[0] = ki(0, Bt[0]), Bt[1] = ki(0, Bt[1]), Bt[2] = ki(0, Bt[2]), Bt[3] = ki(0, Bt[3])), i && (Bt[0] = -Bt[0], Bt[1] = -Bt[1], Bt[2] = -Bt[2], Bt[3] = -Bt[3]), V0(e, Bt, "x", "width", 3, 1, r && r[0] || 0), V0(e, Bt, "y", "height", 0, 2, r && r[1] || 0)), e;
}
var Bt = [0, 0, 0, 0];
function V0(e, t, i, n, r, a, s) {
  var o = t[a] + t[r], l = e[n];
  e[n] += o, s = ki(0, Oo(s, l)), e[n] < s ? (e[n] = s, e[i] += t[r] >= 0 ? -t[r] : t[a] >= 0 ? l + t[a] : _n(o) > 1e-8 ? (l - s) * t[r] / o : 0) : e[i] -= t[r];
}
function Kv(e) {
  var t = e.itemTooltipOption, i = e.componentModel, n = e.itemName, r = et(t) ? {
    formatter: t
  } : t, a = i.mainType, s = i.componentIndex, o = {
    componentType: a,
    name: n,
    $vars: ["name"]
  };
  o[a + "Index"] = s;
  var l = e.formatterParamsExtra;
  l && E(qt(l), function(c) {
    Zi(o, c) || (o[c] = l[c], o.$vars.push(c));
  });
  var u = Vt(e.el);
  u.componentMainType = a, u.componentIndex = s, u.tooltipConfig = {
    name: n,
    option: Jt({
      content: n,
      encodeHTMLContent: !0,
      formatterParams: o
    }, r)
  };
}
function Mf(e, t) {
  var i;
  e.isGroup && (i = t(e)), i || e.traverse(t);
}
function yx(e, t) {
  if (e)
    if (K(e))
      for (var i = 0; i < e.length; i++)
        Mf(e[i], t);
    else
      Mf(e, t);
}
function Qv(e) {
  return !e || _n(e[1]) < Fl && _n(e[2]) < Fl || _n(e[0]) < Fl && _n(e[3]) < Fl;
}
var Fl = 1e-5;
function No(e, t) {
  return e ? lt.copy(e, t) : t.clone();
}
function Jv(e, t) {
  return t ? Tv(e || Ki(), t) : void 0;
}
function Fo(e) {
  return {
    z: e.get("z") || 0,
    zlevel: e.get("zlevel") || 0
  };
}
function lR(e) {
  var t = -1 / 0, i = 1 / 0;
  Mf(e, function(a) {
    n(a), n(a.getTextContent()), n(a.getTextGuideLine());
  });
  function n(a) {
    if (!(!a || a.isGroup)) {
      var s = a.currentStates;
      if (s.length)
        for (var o = 0; o < s.length; o++)
          r(a.states[s[o]]);
      r(a);
    }
  }
  function r(a) {
    if (a) {
      var s = a.z2;
      s > t && (t = s), s < i && (i = s);
    }
  }
  return i > t && (i = t = 0), {
    min: i,
    max: t
  };
}
function _x(e, t, i) {
  bx(e, t, i, -1 / 0);
}
function bx(e, t, i, n) {
  if (e.ignoreModelZ)
    return n;
  var r = e.getTextContent(), a = e.getTextGuideLine(), s = e.isGroup;
  if (s)
    for (var o = e.childrenRef(), l = 0; l < o.length; l++)
      n = ki(bx(o[l], t, i, n), n);
  else
    e.z = t, e.zlevel = i, n = ki(e.z2 || 0, n);
  if (r && (r.z = t, r.zlevel = i, isFinite(n) && (r.z2 = n + 2)), a) {
    var u = e.textGuideLineConfig;
    a.z = t, a.zlevel = i, isFinite(n) && (a.z2 = n + (u && u.showAbove ? 1 : -1));
  }
  return n;
}
Oi("circle", Ic);
Oi("ellipse", zv);
Oi("sector", Vv);
Oi("ring", Hv);
Oi("polygon", Yv);
Oi("polyline", Wv);
Oi("rect", De);
Oi("line", ms);
Oi("bezierCurve", Uv);
Oi("arc", Rc);
const uR = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: Rc,
  BezierCurve: Uv,
  BoundingRect: lt,
  Circle: Ic,
  CompoundPath: BI,
  Ellipse: zv,
  Group: Ci,
  Image: ha,
  IncrementalDisplayable: HI,
  Line: ms,
  LinearGradient: ux,
  OrientedBoundingRect: cx,
  Path: $t,
  Point: It,
  Polygon: Yv,
  Polyline: Wv,
  RadialGradient: $I,
  Rect: De,
  Ring: Hv,
  Sector: Vv,
  Text: _i,
  WH: GI,
  XY: UI,
  applyTransform: Zv,
  calcZ2Range: lR,
  clipPointsByRect: rR,
  clipRectByRect: aR,
  createIcon: gx,
  ensureCopyRect: No,
  ensureCopyTransform: Jv,
  expandOrShrinkRect: Sf,
  extendPath: qI,
  extendShape: XI,
  getShapeClass: ZI,
  getTransform: tR,
  groupTransition: nR,
  initProps: hx,
  isBoundingRectAxisAligned: Qv,
  isElementRemoved: _o,
  lineLineIntersect: mx,
  linePolygonIntersect: sR,
  makeImage: fx,
  makePath: jv,
  mergePath: KI,
  registerShape: Oi,
  removeElement: dx,
  removeElementWithFadeOut: WI,
  resizePath: px,
  retrieveZInfo: Fo,
  setTooltipConfig: Kv,
  subPixelOptimize: JI,
  subPixelOptimizeLine: qv,
  subPixelOptimizeRect: QI,
  transformDirection: eR,
  traverseElements: yx,
  traverseUpdateZ: _x,
  updateProps: Xv
}, Symbol.toStringTag, { value: "Module" }));
var Nc = {};
function cR(e, t) {
  for (var i = 0; i < ar.length; i++) {
    var n = ar[i], r = t[n], a = e.ensureState(n);
    a.style = a.style || {}, a.style.text = r;
  }
  var s = e.currentStates.slice();
  e.clearStates(!0), e.setStyle({
    text: t.normal
  }), e.useStates(s, !0);
}
function H0(e, t, i) {
  var n = e.labelFetcher, r = e.labelDataIndex, a = e.labelDimIndex, s = t.normal, o;
  n && (o = n.getFormattedLabel(r, "normal", null, a, s && s.get("formatter"), i != null ? {
    interpolatedValue: i
  } : null)), o == null && (o = mt(e.defaultText) ? e.defaultText(r, e, i) : e.defaultText);
  for (var l = {
    normal: o
  }, u = 0; u < ar.length; u++) {
    var c = ar[u], h = t[c];
    l[c] = rt(n ? n.getFormattedLabel(r, c, null, a, h && h.get("formatter")) : null, o);
  }
  return l;
}
function Y0(e, t, i, n) {
  i = i || Nc;
  for (var r = e instanceof _i, a = !1, s = 0; s < M0.length; s++) {
    var o = t[M0[s]];
    if (o && o.getShallow("show")) {
      a = !0;
      break;
    }
  }
  var l = r ? e : e.getTextContent();
  if (a) {
    r || (l || (l = new _i(), e.setTextContent(l)), e.stateProxy && (l.stateProxy = e.stateProxy));
    var u = H0(i, t), c = t.normal, h = !!c.getShallow("show"), d = la(c, n, i, !1, !r);
    d.text = u.normal, r || e.setTextConfig(U0(c, i, !1));
    for (var s = 0; s < ar.length; s++) {
      var f = ar[s], o = t[f];
      if (o) {
        var v = l.ensureState(f), m = !!rt(o.getShallow("show"), h);
        if (m !== h && (v.ignore = !m), v.style = la(o, n, i, !0, !r), v.style.text = u[f], !r) {
          var p = e.ensureState(f);
          p.textConfig = U0(o, i, !0);
        }
      }
    }
    l.silent = !!c.getShallow("silent"), l.style.x != null && (d.x = l.style.x), l.style.y != null && (d.y = l.style.y), l.ignore = !h, l.useStyle(d), l.dirty(), i.enableTextSetter && (vR(l).setLabelText = function(g) {
      var y = H0(i, t, g);
      cR(l, y);
    });
  } else l && (l.ignore = !0);
  e.dirty();
}
function W0(e, t) {
  t = t || "label";
  for (var i = {
    normal: e.getModel(t)
  }, n = 0; n < ar.length; n++) {
    var r = ar[n];
    i[r] = e.getModel([r, t]);
  }
  return i;
}
function la(e, t, i, n, r) {
  var a = {};
  return hR(a, e, i, n, r), t && Y(a, t), a;
}
function U0(e, t, i) {
  t = t || {};
  var n = {}, r, a = e.getShallow("rotate"), s = rt(e.getShallow("distance"), i ? null : 5), o = e.getShallow("offset");
  return r = e.getShallow("position") || (i ? null : "inside"), r === "outside" && (r = t.defaultOutsidePosition || "top"), r != null && (n.position = r), o != null && (n.offset = o), a != null && (a *= Math.PI / 180, n.rotation = a), s != null && (n.distance = s), n.outsideFill = e.get("color") === "inherit" ? t.inheritColor || null : "auto", t.autoOverflowArea != null && (n.autoOverflowArea = t.autoOverflowArea), t.layoutRect != null && (n.layoutRect = t.layoutRect), n;
}
function hR(e, t, i, n, r) {
  i = i || Nc;
  var a = t.ecModel, s = a && a.option.textStyle, o = dR(t), l;
  if (o) {
    l = {};
    var u = "richInheritPlainLabel", c = rt(t.get(u), a ? a.get(u) : void 0);
    for (var h in o)
      if (o.hasOwnProperty(h)) {
        var d = t.getModel(["rich", h]);
        q0(l[h] = {}, d, s, t, c, i, n, r, !1, !0);
      }
  }
  l && (e.rich = l);
  var f = t.get("overflow");
  f && (e.overflow = f);
  var v = t.get("lineOverflow");
  v && (e.lineOverflow = v);
  var m = e, p = t.get("minMargin");
  if (p != null)
    p = Zt(p) ? p / 2 : 0, m.margin = [p, p, p, p], m.__marginType = Ga.minMargin;
  else {
    var g = t.get("textMargin");
    g != null && (m.margin = Mv(g), m.__marginType = Ga.textMargin);
  }
  q0(e, t, s, null, null, i, n, r, !0, !1);
}
function dR(e) {
  for (var t; e && e !== e.ecModel; ) {
    var i = (e.option || Nc).rich;
    if (i) {
      t = t || {};
      for (var n = qt(i), r = 0; r < n.length; r++) {
        var a = n[r];
        t[a] = 1;
      }
    }
    e = e.parentModel;
  }
  return t;
}
var G0 = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "textShadowColor", "textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], X0 = ["align", "lineHeight", "width", "height", "tag", "verticalAlign", "ellipsis"], j0 = ["padding", "borderWidth", "borderRadius", "borderDashOffset", "backgroundColor", "borderColor", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"];
function q0(e, t, i, n, r, a, s, o, l, u) {
  i = !s && i || Nc;
  var c = a && a.inheritColor, h = t.getShallow("color"), d = t.getShallow("textBorderColor"), f = rt(t.getShallow("opacity"), i.opacity);
  (h === "inherit" || h === "auto") && (process.env.NODE_ENV !== "production" && h === "auto" && ge("color: 'auto'", "color: 'inherit'"), c ? h = c : h = null), (d === "inherit" || d === "auto") && (process.env.NODE_ENV !== "production" && d === "auto" && ge("color: 'auto'", "color: 'inherit'"), c ? d = c : d = null), o || (h = h || i.color, d = d || i.textBorderColor), h != null && (e.fill = h), d != null && (e.stroke = d);
  var v = rt(t.getShallow("textBorderWidth"), i.textBorderWidth);
  v != null && (e.lineWidth = v);
  var m = rt(t.getShallow("textBorderType"), i.textBorderType);
  m != null && (e.lineDash = m);
  var p = rt(t.getShallow("textBorderDashOffset"), i.textBorderDashOffset);
  p != null && (e.lineDashOffset = p), !s && f == null && !u && (f = a && a.defaultOpacity), f != null && (e.opacity = f), !s && !o && e.fill == null && a.inheritColor && (e.fill = a.inheritColor);
  for (var g = 0; g < G0.length; g++) {
    var y = G0[g], _ = r !== !1 && n ? Qr(t.getShallow(y), n.getShallow(y), i[y]) : rt(t.getShallow(y), i[y]);
    _ != null && (e[y] = _);
  }
  for (var g = 0; g < X0.length; g++) {
    var y = X0[g], _ = t.getShallow(y);
    _ != null && (e[y] = _);
  }
  if (e.verticalAlign == null) {
    var b = t.getShallow("baseline");
    b != null && (e.verticalAlign = b);
  }
  if (!l || !a.disableBox) {
    for (var g = 0; g < j0.length; g++) {
      var y = j0[g], _ = t.getShallow(y);
      _ != null && (e[y] = _);
    }
    var w = t.getShallow("borderType");
    w != null && (e.borderDash = w), (e.backgroundColor === "auto" || e.backgroundColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.backgroundColor === "auto" && ge("backgroundColor: 'auto'", "backgroundColor: 'inherit'"), e.backgroundColor = c), (e.borderColor === "auto" || e.borderColor === "inherit") && c && (process.env.NODE_ENV !== "production" && e.borderColor === "auto" && ge("borderColor: 'auto'", "borderColor: 'inherit'"), e.borderColor = c);
  }
}
function fR(e, t) {
  var i = t && t.getModel("textStyle");
  return Xi([
    // FIXME in node-canvas fontWeight is before fontStyle
    e.fontStyle || i && i.getShallow("fontStyle") || "",
    e.fontWeight || i && i.getShallow("fontWeight") || "",
    (e.fontSize || i && i.getShallow("fontSize") || 12) + "px",
    e.fontFamily || i && i.getShallow("fontFamily") || "sans-serif"
  ].join(" "));
}
var vR = Gt(), Ga = {
  minMargin: 1,
  textMargin: 2
}, pR = ["textStyle", "color"], ed = ["fontStyle", "fontWeight", "fontSize", "fontFamily", "padding", "lineHeight", "rich", "width", "height", "overflow"], id = new _i(), gR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getTextColor = function(t) {
      var i = this.ecModel;
      return this.getShallow("color") || (!t && i ? i.get(pR) : null);
    }, e.prototype.getFont = function() {
      return fR({
        fontStyle: this.getShallow("fontStyle"),
        fontWeight: this.getShallow("fontWeight"),
        fontSize: this.getShallow("fontSize"),
        fontFamily: this.getShallow("fontFamily")
      }, this.ecModel);
    }, e.prototype.getTextRect = function(t) {
      for (var i = {
        text: t,
        verticalAlign: this.getShallow("verticalAlign") || this.getShallow("baseline")
      }, n = 0; n < ed.length; n++)
        i[ed[n]] = this.getShallow(ed[n]);
      return id.useStyle(i), id.update(), id.getBoundingRect();
    }, e;
  })()
), xx = [
  ["lineWidth", "width"],
  ["stroke", "color"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "type"],
  ["lineDashOffset", "dashOffset"],
  ["lineCap", "cap"],
  ["lineJoin", "join"],
  ["miterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], mR = Ro(xx), yR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getLineStyle = function(t) {
      return mR(this, t);
    }, e;
  })()
), Sx = [
  ["fill", "color"],
  ["stroke", "borderColor"],
  ["lineWidth", "borderWidth"],
  ["opacity"],
  ["shadowBlur"],
  ["shadowOffsetX"],
  ["shadowOffsetY"],
  ["shadowColor"],
  ["lineDash", "borderType"],
  ["lineDashOffset", "borderDashOffset"],
  ["lineCap", "borderCap"],
  ["lineJoin", "borderJoin"],
  ["miterLimit", "borderMiterLimit"]
  // Option decal is in `DecalObject` but style.decal is in `PatternObject`.
  // So do not transfer decal directly.
], _R = Ro(Sx), bR = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getItemStyle = function(t, i) {
      return _R(this, t, i);
    }, e;
  })()
), jt = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.parentModel = i, this.ecModel = n, this.option = t;
    }
    return e.prototype.init = function(t, i, n) {
    }, e.prototype.mergeOption = function(t, i) {
      se(this.option, t, !0);
    }, e.prototype.get = function(t, i) {
      return t == null ? this.option : this._doGet(this.parsePath(t), !i && this.parentModel);
    }, e.prototype.getShallow = function(t, i) {
      var n = this.option, r = n == null ? n : n[t];
      if (r == null && !i) {
        var a = this.parentModel;
        a && (r = a.getShallow(t));
      }
      return r;
    }, e.prototype.getModel = function(t, i) {
      var n = t != null, r = n ? this.parsePath(t) : null, a = n ? this._doGet(r) : this.option;
      return i = i || this.parentModel && this.parentModel.getModel(this.resolveParentPath(r)), new e(a, i, this.ecModel);
    }, e.prototype.isEmpty = function() {
      return this.option == null;
    }, e.prototype.restoreData = function() {
    }, e.prototype.clone = function() {
      var t = this.constructor;
      return new t(pt(this.option));
    }, e.prototype.parsePath = function(t) {
      return typeof t == "string" ? t.split(".") : t;
    }, e.prototype.resolveParentPath = function(t) {
      return t;
    }, e.prototype.isAnimationEnabled = function() {
      if (!ot.node && this.option) {
        if (this.option.animation != null)
          return !!this.option.animation;
        if (this.parentModel)
          return this.parentModel.isAnimationEnabled();
      }
    }, e.prototype._doGet = function(t, i) {
      var n = this.option;
      if (!t)
        return n;
      for (var r = 0; r < t.length && !(t[r] && (n = n && typeof n == "object" ? n[t[r]] : null, n == null)); r++)
        ;
      return n == null && i && (n = i._doGet(this.resolveParentPath(t), i.parentModel)), n;
    }, e;
  })()
);
Pv(jt);
QL(jt);
Pi(jt, yR);
Pi(jt, bR);
Pi(jt, nO);
Pi(jt, gR);
var xR = Math.round(Math.random() * 10);
function Fc(e) {
  return [e || "", xR++].join("_");
}
function wR(e) {
  var t = {};
  e.registerSubTypeDefaulter = function(i, n) {
    var r = ji(i);
    t[r.main] = n;
  }, e.determineSubType = function(i, n) {
    var r = n.type;
    if (!r) {
      var a = ji(i).main;
      e.hasSubTypes(i) && t[a] && (r = t[a](n));
    }
    return r;
  };
}
function SR(e, t) {
  e.topologicalTravel = function(a, s, o, l) {
    if (!a.length)
      return;
    var u = i(s), c = u.graph, h = u.noEntryList, d = {};
    for (E(a, function(y) {
      d[y] = !0;
    }); h.length; ) {
      var f = h.pop(), v = c[f], m = !!d[f];
      m && (o.call(l, f, v.originalDeps.slice()), delete d[f]), E(v.successor, m ? g : p);
    }
    E(d, function() {
      var y = "";
      throw process.env.NODE_ENV !== "production" && (y = $u("Circular dependency may exists: ", d, a, s)), new Error(y);
    });
    function p(y) {
      c[y].entryCount--, c[y].entryCount === 0 && h.push(y);
    }
    function g(y) {
      d[y] = !0, p(y);
    }
  };
  function i(a) {
    var s = {}, o = [];
    return E(a, function(l) {
      var u = n(s, l), c = u.originalDeps = t(l), h = r(c, a);
      u.entryCount = h.length, u.entryCount === 0 && o.push(l), E(h, function(d) {
        Ht(u.predecessor, d) < 0 && u.predecessor.push(d);
        var f = n(s, d);
        Ht(f.successor, d) < 0 && f.successor.push(l);
      });
    }), {
      graph: s,
      noEntryList: o
    };
  }
  function n(a, s) {
    return a[s] || (a[s] = {
      predecessor: [],
      successor: []
    }), a[s];
  }
  function r(a, s) {
    var o = [];
    return E(a, function(l) {
      Ht(s, l) >= 0 && o.push(l);
    }), o;
  }
}
const MR = {
  time: {
    month: ["January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"],
    monthAbbr: ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"],
    dayOfWeek: ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"],
    dayOfWeekAbbr: ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"]
  },
  legend: {
    selector: {
      all: "All",
      inverse: "Inv"
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "Box Select",
        polygon: "Lasso Select",
        lineX: "Horizontally Select",
        lineY: "Vertically Select",
        keep: "Keep Selections",
        clear: "Clear Selections"
      }
    },
    dataView: {
      title: "Data View",
      lang: ["Data View", "Close", "Refresh"]
    },
    dataZoom: {
      title: {
        zoom: "Zoom",
        back: "Zoom Reset"
      }
    },
    magicType: {
      title: {
        line: "Switch to Line Chart",
        bar: "Switch to Bar Chart",
        stack: "Stack",
        tiled: "Tile"
      }
    },
    restore: {
      title: "Restore"
    },
    saveAsImage: {
      title: "Save as Image",
      lang: ["Right Click to Save Image"]
    }
  },
  series: {
    typeNames: {
      pie: "Pie chart",
      bar: "Bar chart",
      line: "Line chart",
      scatter: "Scatter plot",
      effectScatter: "Ripple scatter plot",
      radar: "Radar chart",
      tree: "Tree",
      treemap: "Treemap",
      boxplot: "Boxplot",
      candlestick: "Candlestick",
      k: "K line chart",
      heatmap: "Heat map",
      map: "Map",
      parallel: "Parallel coordinate map",
      lines: "Line graph",
      graph: "Relationship graph",
      sankey: "Sankey diagram",
      funnel: "Funnel chart",
      gauge: "Gauge",
      pictorialBar: "Pictorial bar",
      themeRiver: "Theme River Map",
      sunburst: "Sunburst",
      custom: "Custom chart",
      chart: "Chart"
    }
  },
  aria: {
    general: {
      withTitle: 'This is a chart about "{title}"',
      withoutTitle: "This is a chart"
    },
    series: {
      single: {
        prefix: "",
        withName: " with type {seriesType} named {seriesName}.",
        withoutName: " with type {seriesType}."
      },
      multiple: {
        prefix: ". It consists of {seriesCount} series count.",
        withName: " The {seriesId} series is a {seriesType} representing {seriesName}.",
        withoutName: " The {seriesId} series is a {seriesType}.",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "The data is as follows: ",
      partialData: "The first {displayCnt} items are: ",
      withName: "the data for {name} is {value}",
      withoutName: "{value}",
      separator: {
        middle: ", ",
        end: ". "
      }
    }
  }
}, kR = {
  time: {
    month: ["", "", "", "", "", "", "", "", "", "", "", ""],
    monthAbbr: ["1", "2", "3", "4", "5", "6", "7", "8", "9", "10", "11", "12"],
    dayOfWeek: ["", "", "", "", "", "", ""],
    dayOfWeekAbbr: ["", "", "", "", "", "", ""]
  },
  legend: {
    selector: {
      all: "",
      inverse: ""
    }
  },
  toolbox: {
    brush: {
      title: {
        rect: "",
        polygon: "",
        lineX: "",
        lineY: "",
        keep: "",
        clear: ""
      }
    },
    dataView: {
      title: "",
      lang: ["", "", ""]
    },
    dataZoom: {
      title: {
        zoom: "",
        back: ""
      }
    },
    magicType: {
      title: {
        line: "",
        bar: "",
        stack: "",
        tiled: ""
      }
    },
    restore: {
      title: ""
    },
    saveAsImage: {
      title: "",
      lang: [""]
    }
  },
  series: {
    typeNames: {
      pie: "",
      bar: "",
      line: "",
      scatter: "",
      effectScatter: "",
      radar: "",
      tree: "",
      treemap: "",
      boxplot: "",
      candlestick: "K",
      k: "K",
      heatmap: "",
      map: "",
      parallel: "",
      lines: "",
      graph: "",
      sankey: "",
      funnel: "",
      gauge: "",
      pictorialBar: "",
      themeRiver: "",
      sunburst: "",
      custom: "",
      chart: ""
    }
  },
  aria: {
    general: {
      withTitle: "{title}",
      withoutTitle: ""
    },
    series: {
      single: {
        prefix: "",
        withName: "{seriesType}{seriesName}",
        withoutName: "{seriesType}"
      },
      multiple: {
        prefix: "{seriesCount}",
        withName: "{seriesId}{seriesName}{seriesType}",
        withoutName: "{seriesId}{seriesType}",
        separator: {
          middle: "",
          end: ""
        }
      }
    },
    data: {
      allData: "",
      partialData: "{displayCnt}",
      withName: "{name}{value}",
      withoutName: "{value}",
      separator: {
        middle: "",
        end: ""
      }
    }
  }
};
var Uu = "ZH", tp = "EN", Ja = tp, cu = {}, ep = {}, Mx = ot.domSupported ? (function() {
  var e = (
    /* eslint-disable-next-line */
    (document.documentElement.lang || navigator.language || navigator.browserLanguage || Ja).toUpperCase()
  );
  return e.indexOf(Uu) > -1 ? Uu : Ja;
})() : Ja;
function kx(e, t) {
  e = e.toUpperCase(), ep[e] = new jt(t), cu[e] = t;
}
function DR(e) {
  if (et(e)) {
    var t = cu[e.toUpperCase()] || {};
    return e === Uu || e === tp ? pt(t) : se(pt(t), pt(cu[Ja]), !1);
  } else
    return se(pt(e), pt(cu[Ja]), !1);
}
function TR(e) {
  return ep[e];
}
function CR() {
  return ep[Ja];
}
kx(tp, MR);
kx(Uu, kR);
function Fn(e, t) {
  return e += "", "0000".substr(0, t - e.length) + e;
}
function Dx(e, t, i, n) {
  var r = Ec(e), a = r[ER(i)](), s = r[AR(i)]() + 1, o = Math.floor((s - 1) / 3) + 1, l = r[PR(i)](), u = r["get" + (i ? "UTC" : "") + "Day"](), c = r[LR(i)](), h = (c - 1) % 12 + 1, d = r[OR(i)](), f = r[IR(i)](), v = r[RR(i)](), m = c >= 12 ? "pm" : "am", p = m.toUpperCase(), g = n instanceof jt ? n : TR(Mx) || CR(), y = g.getModel("time"), _ = y.get("month"), b = y.get("monthAbbr"), w = y.get("dayOfWeek"), S = y.get("dayOfWeekAbbr");
  return (t || "").replace(/{a}/g, m + "").replace(/{A}/g, p + "").replace(/{yyyy}/g, a + "").replace(/{yy}/g, Fn(a % 100 + "", 2)).replace(/{Q}/g, o + "").replace(/{MMMM}/g, _[s - 1]).replace(/{MMM}/g, b[s - 1]).replace(/{MM}/g, Fn(s, 2)).replace(/{M}/g, s + "").replace(/{dd}/g, Fn(l, 2)).replace(/{d}/g, l + "").replace(/{eeee}/g, w[u]).replace(/{ee}/g, S[u]).replace(/{e}/g, u + "").replace(/{HH}/g, Fn(c, 2)).replace(/{H}/g, c + "").replace(/{hh}/g, Fn(h + "", 2)).replace(/{h}/g, h + "").replace(/{mm}/g, Fn(d, 2)).replace(/{m}/g, d + "").replace(/{ss}/g, Fn(f, 2)).replace(/{s}/g, f + "").replace(/{SSS}/g, Fn(v, 3)).replace(/{S}/g, v + "");
}
function ER(e) {
  return e ? "getUTCFullYear" : "getFullYear";
}
function AR(e) {
  return e ? "getUTCMonth" : "getMonth";
}
function PR(e) {
  return e ? "getUTCDate" : "getDate";
}
function LR(e) {
  return e ? "getUTCHours" : "getHours";
}
function OR(e) {
  return e ? "getUTCMinutes" : "getMinutes";
}
function IR(e) {
  return e ? "getUTCSeconds" : "getSeconds";
}
function RR(e) {
  return e ? "getUTCMilliseconds" : "getMilliseconds";
}
function NR(e) {
  if (!C1(e))
    return et(e) ? e : "-";
  var t = (e + "").split(".");
  return t[0].replace(/(\d{1,3})(?=(?:\d{3})+(?!\d))/g, "$1,") + (t.length > 1 ? "." + t[1] : "");
}
function Tx(e, t) {
  return e = (e || "").toLowerCase().replace(/-(.)/g, function(i, n) {
    return n.toUpperCase();
  }), t && e && (e = e.charAt(0).toUpperCase() + e.slice(1)), e;
}
var ip = Mv;
function kf(e, t, i) {
  var n = "{yyyy}-{MM}-{dd} {HH}:{mm}:{ss}";
  function r(c) {
    return c && Xi(c) ? c : "-";
  }
  function a(c) {
    return !!(c != null && !isNaN(c) && isFinite(c));
  }
  var s = t === "time", o = e instanceof Date;
  if (s || o) {
    var l = s ? Ec(e) : e;
    if (isNaN(+l)) {
      if (o)
        return "-";
    } else return Dx(l, n, i);
  }
  if (t === "ordinal")
    return Tu(e) ? r(e) : Zt(e) && a(e) ? e + "" : "-";
  var u = Bu(e);
  return a(u) ? NR(u) : Tu(e) ? r(e) : typeof e == "boolean" ? e + "" : "-";
}
var Z0 = ["a", "b", "c", "d", "e", "f", "g"], nd = function(e, t) {
  return "{" + e + (t ?? "") + "}";
};
function Cx(e, t, i) {
  K(t) || (t = [t]);
  var n = t.length;
  if (!n)
    return "";
  for (var r = t[0].$vars || [], a = 0; a < r.length; a++) {
    var s = Z0[a];
    e = e.replace(nd(s), nd(s, 0));
  }
  for (var o = 0; o < n; o++)
    for (var l = 0; l < r.length; l++) {
      var u = t[o][r[l]];
      e = e.replace(nd(Z0[l], o), i ? Ve(u) : u);
    }
  return e;
}
function FR(e, t) {
  var i = et(e) ? {
    color: e,
    extraCssText: t
  } : e || {}, n = i.color, r = i.type;
  t = i.extraCssText;
  var a = i.renderMode || "html";
  if (!n)
    return "";
  if (a === "html")
    return r === "subItem" ? '<span style="display:inline-block;vertical-align:middle;margin-right:8px;margin-left:3px;border-radius:4px;width:4px;height:4px;background-color:' + Ve(n) + ";" + (t || "") + '"></span>' : '<span style="display:inline-block;margin-right:4px;border-radius:10px;width:10px;height:10px;background-color:' + Ve(n) + ";" + (t || "") + '"></span>';
  var s = i.markerId || "markerX";
  return {
    renderMode: a,
    content: "{" + s + "|}  ",
    style: r === "subItem" ? {
      width: 4,
      height: 4,
      borderRadius: 2,
      backgroundColor: n
    } : {
      width: 10,
      height: 10,
      borderRadius: 5,
      backgroundColor: n
    }
  };
}
function Bo(e, t) {
  return t = t || "transparent", et(e) ? e : tt(e) && e.colorStops && (e.colorStops[0] || {}).color || t;
}
function K0(e, t) {
  if (t === "_blank" || t === "blank") {
    var i = window.open();
    i.opener = null, i.location.href = e;
  } else
    window.open(e, t);
}
var rd = {}, ad = {}, Bc = (
  /** @class */
  (function() {
    function e() {
      this._normalMasterList = [], this._nonSeriesBoxMasterList = [];
    }
    return e.prototype.create = function(t, i) {
      this._nonSeriesBoxMasterList = n(rd, !0), this._normalMasterList = n(ad, !1);
      function n(r, a) {
        var s = [];
        return E(r, function(o, l) {
          var u = o.create(t, i);
          s = s.concat(u || []), process.env.NODE_ENV !== "production" && a && E(u, function(c) {
            return nt(!c.update);
          });
        }), s;
      }
    }, e.prototype.update = function(t, i) {
      E(this._normalMasterList, function(n) {
        n.update && n.update(t, i);
      });
    }, e.prototype.getCoordinateSystems = function() {
      return this._normalMasterList.concat(this._nonSeriesBoxMasterList);
    }, e.register = function(t, i) {
      if (t === "matrix" || t === "calendar") {
        rd[t] = i;
        return;
      }
      ad[t] = i;
    }, e.get = function(t) {
      return ad[t] || rd[t];
    }, e;
  })()
), Q0 = {
  // By default fetch coord from `model.get('coord')`.
  coord: 1,
  // Some model/series, such as pie, is allowed to also get coord from `model.get('center')`,
  // if cannot get from `model.get('coord')`. But historically pie use `center` option, but
  // geo use `layoutCenter` option to specify layout center; they are not able to be unified.
  // Therefor it is not recommended.
  coord2: 2
}, BR = ht();
function $R(e) {
  var t = e.getShallow("coord", !0), i = Q0.coord;
  if (t == null) {
    var n = BR.get(e.type);
    n && n.getCoord2 && (i = Q0.coord2, t = n.getCoord2(e));
  }
  return {
    coord: t,
    from: i
  };
}
var hu = E, zR = ["left", "right", "top", "bottom", "width", "height"], Bl = [["width", "left", "right"], ["height", "top", "bottom"]];
function Ex(e, t, i, n, r) {
  var a = 0, s = 0;
  n == null && (n = 1 / 0), r == null && (r = 1 / 0);
  var o = 0;
  t.eachChild(function(l, u) {
    var c = l.getBoundingRect(), h = t.childAt(u + 1), d = h && h.getBoundingRect(), f, v;
    if (e === "horizontal") {
      var m = c.width + (d ? -d.x + c.x : 0);
      f = a + m, f > n || l.newline ? (a = 0, f = m, s += o + i, o = c.height) : o = Math.max(o, c.height);
    } else {
      var p = c.height + (d ? -d.y + c.y : 0);
      v = s + p, v > r || l.newline ? (a += o + i, s = 0, v = p, o = c.width) : o = Math.max(o, c.width);
    }
    l.newline || (l.x = a, l.y = s, l.markRedraw(), e === "horizontal" ? a = f + i : s = v + i);
  });
}
Oe(Ex, "vertical");
Oe(Ex, "horizontal");
function VR(e, t) {
  return {
    left: e.getShallow("left", t),
    top: e.getShallow("top", t),
    right: e.getShallow("right", t),
    bottom: e.getShallow("bottom", t),
    width: e.getShallow("width", t),
    height: e.getShallow("height", t)
  };
}
function np(e, t, i) {
  i = ip(i || 0);
  var n = t.width, r = t.height, a = Ye(e.left, n), s = Ye(e.top, r), o = Ye(e.right, n), l = Ye(e.bottom, r), u = Ye(e.width, n), c = Ye(e.height, r), h = i[2] + i[0], d = i[1] + i[3], f = e.aspect;
  switch (isNaN(u) && (u = n - o - d - a), isNaN(c) && (c = r - l - h - s), f != null && (isNaN(u) && isNaN(c) && (f > n / r ? u = n * 0.8 : c = r * 0.8), isNaN(u) && (u = f * c), isNaN(c) && (c = u / f)), isNaN(a) && (a = n - o - u - d), isNaN(s) && (s = r - l - c - h), e.left || e.right) {
    case "center":
      a = n / 2 - u / 2 - i[3];
      break;
    case "right":
      a = n - u - d;
      break;
  }
  switch (e.top || e.bottom) {
    case "middle":
    case "center":
      s = r / 2 - c / 2 - i[0];
      break;
    case "bottom":
      s = r - c - h;
      break;
  }
  a = a || 0, s = s || 0, isNaN(u) && (u = n - d - a - (o || 0)), isNaN(c) && (c = r - h - s - (l || 0));
  var v = new lt((t.x || 0) + a + i[3], (t.y || 0) + s + i[0], u, c);
  return v.margin = i, v;
}
var sd = {
  rect: 1
};
function Ax(e, t, i) {
  var n, r, a, s = e.boxCoordinateSystem, o;
  if (s) {
    var l = $R(e), u = l.coord, c = l.from;
    if (s.dataToLayout) {
      a = sd.rect, o = c;
      var h = s.dataToLayout(u);
      n = h.contentRect || h.rect;
    } else
      process.env.NODE_ENV !== "production" && Kt(e.type + "[" + e.componentIndex + "]" + (" layout based on " + s.type + " is not supported."));
  }
  return a == null && (a = sd.rect), a === sd.rect && (n || (n = {
    x: 0,
    y: 0,
    width: t.getWidth(),
    height: t.getHeight()
  }), r = [n.x + n.width / 2, n.y + n.height / 2]), {
    type: a,
    refContainer: n,
    refPoint: r,
    boxCoordFrom: o
  };
}
function Gu(e) {
  var t = e.layoutMode || e.constructor.layoutMode;
  return tt(t) ? t : t ? {
    type: t
  } : null;
}
function Xu(e, t, i) {
  var n = i && i.ignoreSize;
  !K(n) && (n = [n, n]);
  var r = s(Bl[0], 0), a = s(Bl[1], 1);
  l(Bl[0], e, r), l(Bl[1], e, a);
  function s(u, c) {
    var h = {}, d = 0, f = {}, v = 0, m = 2;
    if (hu(u, function(y) {
      f[y] = e[y];
    }), hu(u, function(y) {
      Zi(t, y) && (h[y] = f[y] = t[y]), o(h, y) && d++, o(f, y) && v++;
    }), n[c])
      return o(t, u[1]) ? f[u[2]] = null : o(t, u[2]) && (f[u[1]] = null), f;
    if (v === m || !d)
      return f;
    if (d >= m)
      return h;
    for (var p = 0; p < u.length; p++) {
      var g = u[p];
      if (!Zi(h, g) && Zi(e, g)) {
        h[g] = e[g];
        break;
      }
    }
    return h;
  }
  function o(u, c) {
    return u[c] != null && u[c] !== "auto";
  }
  function l(u, c, h) {
    hu(u, function(d) {
      c[d] = h[d];
    });
  }
}
function Px(e) {
  return HR({}, e);
}
function HR(e, t) {
  return t && e && hu(zR, function(i) {
    Zi(t, i) && (e[i] = t[i]);
  }), e;
}
var YR = Gt(), Pt = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i, n, r) {
      var a = e.call(this, i, n, r) || this;
      return a.uid = Fc("ec_cpt_model"), a;
    }
    return t.prototype.init = function(i, n, r) {
      this.mergeDefaultAndTheme(i, r);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = Gu(this), a = r ? Px(i) : {}, s = n.getTheme();
      se(i, s.get(this.mainType)), se(i, this.getDefaultOption()), r && Xu(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      se(this.option, i, !0);
      var r = Gu(this);
      r && Xu(this.option, i, r);
    }, t.prototype.optionUpdated = function(i, n) {
    }, t.prototype.getDefaultOption = function() {
      var i = this.constructor;
      if (!qL(i))
        return i.defaultOption;
      var n = YR(this);
      if (!n.defaultOption) {
        for (var r = [], a = i; a; ) {
          var s = a.prototype.defaultOption;
          s && r.push(s), a = a.superClass;
        }
        for (var o = {}, l = r.length - 1; l >= 0; l--)
          o = se(o, r[l], !0);
        n.defaultOption = o;
      }
      return n.defaultOption;
    }, t.prototype.getReferringComponents = function(i, n) {
      var r = i + "Index", a = i + "Id";
      return Qo(this.ecModel, i, {
        index: this.get(r, !0),
        id: this.get(a, !0)
      }, n);
    }, t.prototype.getBoxLayoutParams = function() {
      return VR(this, !1);
    }, t.prototype.getZLevelKey = function() {
      return "";
    }, t.prototype.setZLevel = function(i) {
      this.option.zlevel = i;
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "component", i.id = "", i.name = "", i.mainType = "", i.subType = "", i.componentIndex = 0;
    })(), t;
  })(jt)
);
N1(Pt, jt);
Lv(Pt);
wR(Pt);
SR(Pt, WR);
function WR(e) {
  var t = [];
  return E(Pt.getClassesByMainType(e), function(i) {
    t = t.concat(i.dependencies || i.prototype.dependencies || []);
  }), t = _t(t, function(i) {
    return ji(i).main;
  }), e !== "dataset" && Ht(t, "dataset") <= 0 && t.unshift("dataset"), t;
}
var St = {
  color: {},
  darkColor: {},
  size: {}
}, Qt = St.color = {
  theme: ["#5070dd", "#b6d634", "#505372", "#ff994d", "#0ca8df", "#ffd10a", "#fb628b", "#785db0", "#3fbe95"],
  neutral00: "#fff",
  neutral05: "#f4f7fd",
  neutral10: "#e8ebf0",
  neutral15: "#dbdee4",
  neutral20: "#cfd2d7",
  neutral25: "#c3c5cb",
  neutral30: "#b7b9be",
  neutral35: "#aaacb2",
  neutral40: "#9ea0a5",
  neutral45: "#929399",
  neutral50: "#86878c",
  neutral55: "#797b7f",
  neutral60: "#6d6e73",
  neutral65: "#616266",
  neutral70: "#54555a",
  neutral75: "#48494d",
  neutral80: "#3c3c41",
  neutral85: "#303034",
  neutral90: "#232328",
  neutral95: "#17171b",
  neutral99: "#000",
  accent05: "#eff1f9",
  accent10: "#e0e4f2",
  accent15: "#d0d6ec",
  accent20: "#c0c9e6",
  accent25: "#b1bbdf",
  accent30: "#a1aed9",
  accent35: "#91a0d3",
  accent40: "#8292cc",
  accent45: "#7285c6",
  accent50: "#6578ba",
  accent55: "#5c6da9",
  accent60: "#536298",
  accent65: "#4a5787",
  accent70: "#404c76",
  accent75: "#374165",
  accent80: "#2e3654",
  accent85: "#252b43",
  accent90: "#1b2032",
  accent95: "#121521",
  transparent: "rgba(0,0,0,0)",
  highlight: "rgba(255,231,130,0.8)"
};
Y(Qt, {
  primary: Qt.neutral80,
  secondary: Qt.neutral70,
  tertiary: Qt.neutral60,
  quaternary: Qt.neutral50,
  disabled: Qt.neutral20,
  border: Qt.neutral30,
  borderTint: Qt.neutral20,
  borderShade: Qt.neutral40,
  background: Qt.neutral05,
  backgroundTint: "rgba(234,237,245,0.5)",
  backgroundTransparent: "rgba(255,255,255,0)",
  backgroundShade: Qt.neutral10,
  shadow: "rgba(0,0,0,0.2)",
  shadowTint: "rgba(129,130,136,0.2)",
  axisLine: Qt.neutral70,
  axisLineTint: Qt.neutral40,
  axisTick: Qt.neutral70,
  axisTickMinor: Qt.neutral60,
  axisLabel: Qt.neutral70,
  axisSplitLine: Qt.neutral15,
  axisMinorSplitLine: Qt.neutral05
});
for (var Er in Qt)
  if (Qt.hasOwnProperty(Er)) {
    var J0 = Qt[Er];
    Er === "theme" ? St.darkColor.theme = Qt.theme.slice() : Er === "highlight" ? St.darkColor.highlight = "rgba(255,231,130,0.4)" : Er.indexOf("accent") === 0 ? St.darkColor[Er] = Qa(J0, null, function(e) {
      return e * 0.5;
    }, function(e) {
      return Math.min(1, 1.3 - e);
    }) : St.darkColor[Er] = Qa(J0, null, function(e) {
      return e * 0.9;
    }, function(e) {
      return 1 - Math.pow(e, 1.5);
    });
  }
St.size = {
  xxs: 2,
  xs: 5,
  s: 10,
  m: 15,
  l: 20,
  xl: 30,
  xxl: 40,
  xxxl: 50
};
var Lx = "";
typeof navigator < "u" && (Lx = navigator.platform || "");
var Ca = "rgba(0, 0, 0, 0.2)", Ox = St.color.theme[0], UR = Qa(Ox, null, null, 0.9);
const GR = {
  darkMode: "auto",
  // backgroundColor: 'rgba(0,0,0,0)',
  colorBy: "series",
  color: St.color.theme,
  gradientColor: [UR, Ox],
  aria: {
    decal: {
      decals: [{
        color: Ca,
        dashArrayX: [1, 0],
        dashArrayY: [2, 5],
        symbolSize: 1,
        rotation: Math.PI / 6
      }, {
        color: Ca,
        symbol: "circle",
        dashArrayX: [[8, 8], [0, 8, 8, 0]],
        dashArrayY: [6, 0],
        symbolSize: 0.8
      }, {
        color: Ca,
        dashArrayX: [1, 0],
        dashArrayY: [4, 3],
        rotation: -Math.PI / 4
      }, {
        color: Ca,
        dashArrayX: [[6, 6], [0, 6, 6, 0]],
        dashArrayY: [6, 0]
      }, {
        color: Ca,
        dashArrayX: [[1, 0], [1, 6]],
        dashArrayY: [1, 0, 6, 0],
        rotation: Math.PI / 4
      }, {
        color: Ca,
        symbol: "triangle",
        dashArrayX: [[9, 9], [0, 9, 9, 0]],
        dashArrayY: [7, 2],
        symbolSize: 0.75
      }]
    }
  },
  // If xAxis and yAxis declared, grid is created by default.
  // grid: {},
  textStyle: {
    // color: '#000',
    // decoration: 'none',
    // PENDING
    fontFamily: Lx.match(/^Win/) ? "Microsoft YaHei" : "sans-serif",
    // fontFamily: 'Arial, Verdana, sans-serif',
    fontSize: 12,
    fontStyle: "normal",
    fontWeight: "normal"
  },
  // http://blogs.adobe.com/webplatform/2014/02/24/using-blend-modes-in-html-canvas/
  // https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation
  // Default is source-over
  blendMode: null,
  stateAnimation: {
    duration: 300,
    easing: "cubicOut"
  },
  animation: "auto",
  animationDuration: 1e3,
  animationDurationUpdate: 500,
  animationEasing: "cubicInOut",
  animationEasingUpdate: "cubicInOut",
  animationThreshold: 2e3,
  // Configuration for progressive/incremental rendering
  progressiveThreshold: 3e3,
  progressive: 400,
  // Threshold of if use single hover layer to optimize.
  // It is recommended that `hoverLayerThreshold` is equivalent to or less than
  // `progressiveThreshold`, otherwise hover will cause restart of progressive,
  // which is unexpected.
  // see example <echarts/test/heatmap-large.html>.
  hoverLayerThreshold: 3e3,
  // See: module:echarts/scale/Time
  useUTC: !1
};
var Df = ht(["tooltip", "label", "itemName", "itemId", "itemGroupId", "itemChildGroupId", "seriesName"]), ti = "original", Ee = "arrayRows", Ii = "objectRows", nn = "keyedColumns", Mn = "typedArray", Ix = "unknown", tn = "column", da = "row", je = {
  Must: 1,
  Might: 2,
  Not: 3
  // Other cases
}, Rx = Gt();
function XR(e) {
  Rx(e).datasetMap = ht();
}
function jR(e, t, i) {
  var n = {}, r = Nx(t);
  if (!r || !e)
    return n;
  var a = [], s = [], o = t.ecModel, l = Rx(o).datasetMap, u = r.uid + "_" + i.seriesLayoutBy, c, h;
  e = e.slice(), E(e, function(m, p) {
    var g = tt(m) ? m : e[p] = {
      name: m
    };
    g.type === "ordinal" && c == null && (c = p, h = v(g)), n[g.name] = [];
  });
  var d = l.get(u) || l.set(u, {
    categoryWayDim: h,
    valueWayDim: 0
  });
  E(e, function(m, p) {
    var g = m.name, y = v(m);
    if (c == null) {
      var _ = d.valueWayDim;
      f(n[g], _, y), f(s, _, y), d.valueWayDim += y;
    } else if (c === p)
      f(n[g], 0, y), f(a, 0, y);
    else {
      var _ = d.categoryWayDim;
      f(n[g], _, y), f(s, _, y), d.categoryWayDim += y;
    }
  });
  function f(m, p, g) {
    for (var y = 0; y < g; y++)
      m.push(p + y);
  }
  function v(m) {
    var p = m.dimsDef;
    return p ? p.length : 1;
  }
  return a.length && (n.itemName = a), s.length && (n.seriesName = s), n;
}
function Nx(e) {
  var t = e.get("data", !0);
  if (!t)
    return Qo(e.ecModel, "dataset", {
      index: e.get("datasetIndex", !0),
      id: e.get("datasetId", !0)
    }, Hn).models[0];
}
function qR(e) {
  return !e.get("transform", !0) && !e.get("fromTransformResult", !0) ? [] : Qo(e.ecModel, "dataset", {
    index: e.get("fromDatasetIndex", !0),
    id: e.get("fromDatasetId", !0)
  }, Hn).models;
}
function Fx(e, t) {
  return ZR(e.data, e.sourceFormat, e.seriesLayoutBy, e.dimensionsDefine, e.startIndex, t);
}
function ZR(e, t, i, n, r, a) {
  var s, o = 5;
  if (Ne(e))
    return je.Not;
  var l, u;
  if (n) {
    var c = n[a];
    tt(c) ? (l = c.name, u = c.type) : et(c) && (l = c);
  }
  if (u != null)
    return u === "ordinal" ? je.Must : je.Not;
  if (t === Ee) {
    var h = e;
    if (i === da) {
      for (var d = h[a], f = 0; f < (d || []).length && f < o; f++)
        if ((s = b(d[r + f])) != null)
          return s;
    } else
      for (var f = 0; f < h.length && f < o; f++) {
        var v = h[r + f];
        if (v && (s = b(v[a])) != null)
          return s;
      }
  } else if (t === Ii) {
    var m = e;
    if (!l)
      return je.Not;
    for (var f = 0; f < m.length && f < o; f++) {
      var p = m[f];
      if (p && (s = b(p[l])) != null)
        return s;
    }
  } else if (t === nn) {
    var g = e;
    if (!l)
      return je.Not;
    var d = g[l];
    if (!d || Ne(d))
      return je.Not;
    for (var f = 0; f < d.length && f < o; f++)
      if ((s = b(d[f])) != null)
        return s;
  } else if (t === ti)
    for (var y = e, f = 0; f < y.length && f < o; f++) {
      var p = y[f], _ = Zo(p);
      if (!K(_))
        return je.Not;
      if ((s = b(_[a])) != null)
        return s;
    }
  function b(w) {
    var S = et(w);
    if (w != null && Number.isFinite(Number(w)) && w !== "")
      return S ? je.Might : je.Not;
    if (S && w !== "-")
      return je.Must;
  }
  return je.Not;
}
var KR = ht();
function QR(e, t, i) {
  var n = KR.get(t);
  if (!n)
    return i;
  var r = n(e);
  if (!r)
    return i;
  if (process.env.NODE_ENV !== "production")
    for (var a = 0; a < r.length; a++)
      nt(us(r[a]));
  return i.concat(r);
}
var ty = Gt();
Gt();
var rp = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getColorFromPalette = function(t, i, n) {
      var r = Ie(this.get("color", !0)), a = this.get("colorLayer", !0);
      return t5(this, ty, r, a, t, i, n);
    }, e.prototype.clearColorPalette = function() {
      e5(this, ty);
    }, e;
  })()
);
function JR(e, t) {
  for (var i = e.length, n = 0; n < i; n++)
    if (e[n].length > t)
      return e[n];
  return e[i - 1];
}
function t5(e, t, i, n, r, a, s) {
  a = a || e;
  var o = t(a), l = o.paletteIdx || 0, u = o.paletteNameMap = o.paletteNameMap || {};
  if (u.hasOwnProperty(r))
    return u[r];
  var c = s == null || !n ? i : JR(n, s);
  if (c = c || i, !(!c || !c.length)) {
    var h = c[l];
    return r && (u[r] = h), o.paletteIdx = (l + 1) % c.length, h;
  }
}
function e5(e, t) {
  t(e).paletteIdx = 0, t(e).paletteNameMap = {};
}
var $l, Ls, ey, od = "\0_ec_inner", iy = 1, i5 = {
  grid: "GridComponent",
  polar: "PolarComponent",
  geo: "GeoComponent",
  singleAxis: "SingleAxisComponent",
  parallel: "ParallelComponent",
  calendar: "CalendarComponent",
  matrix: "MatrixComponent",
  graphic: "GraphicComponent",
  toolbox: "ToolboxComponent",
  tooltip: "TooltipComponent",
  axisPointer: "AxisPointerComponent",
  brush: "BrushComponent",
  title: "TitleComponent",
  timeline: "TimelineComponent",
  markPoint: "MarkPointComponent",
  markLine: "MarkLineComponent",
  markArea: "MarkAreaComponent",
  legend: "LegendComponent",
  dataZoom: "DataZoomComponent",
  visualMap: "VisualMapComponent",
  // aria: 'AriaComponent',
  // dataset: 'DatasetComponent',
  // Dependencies
  xAxis: "GridComponent",
  yAxis: "GridComponent",
  angleAxis: "PolarComponent",
  radiusAxis: "PolarComponent"
}, n5 = {
  line: "LineChart",
  bar: "BarChart",
  pie: "PieChart",
  scatter: "ScatterChart",
  radar: "RadarChart",
  map: "MapChart",
  tree: "TreeChart",
  treemap: "TreemapChart",
  graph: "GraphChart",
  chord: "ChordChart",
  gauge: "GaugeChart",
  funnel: "FunnelChart",
  parallel: "ParallelChart",
  sankey: "SankeyChart",
  boxplot: "BoxplotChart",
  candlestick: "CandlestickChart",
  effectScatter: "EffectScatterChart",
  lines: "LinesChart",
  heatmap: "HeatmapChart",
  pictorialBar: "PictorialBarChart",
  themeRiver: "ThemeRiverChart",
  sunburst: "SunburstChart",
  custom: "CustomChart"
}, ju = {};
function r5(e) {
  E(e, function(t, i) {
    if (!Pt.hasClass(i)) {
      var n = i5[i];
      n && !ju[n] && (Kt("Component " + i + ` is used but not imported.
import { ` + n + ` } from 'echarts/components';
echarts.use([` + n + "]);"), ju[n] = !0);
    }
  });
}
var ap = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.init = function(i, n, r, a, s, o) {
      a = a || {}, this.option = null, this._theme = new jt(a), this._locale = new jt(s), this._optionManager = o;
    }, t.prototype.setOption = function(i, n, r) {
      process.env.NODE_ENV !== "production" && (nt(i != null, "option is null/undefined"), nt(i[od] !== iy, "please use chart.getOption()"));
      var a = ay(n);
      this._optionManager.setOption(i, r, a), this._resetOption(null, a);
    }, t.prototype.resetOption = function(i, n) {
      return this._resetOption(i, ay(n));
    }, t.prototype._resetOption = function(i, n) {
      var r = !1, a = this._optionManager;
      if (!i || i === "recreate") {
        var s = a.mountOption(i === "recreate");
        process.env.NODE_ENV !== "production" && r5(s), !this.option || i === "recreate" ? ey(this, s) : (this.restoreData(), this._mergeOption(s, n)), r = !0;
      }
      if ((i === "timeline" || i === "media") && this.restoreData(), !i || i === "recreate" || i === "timeline") {
        var o = a.getTimelineOption(this);
        o && (r = !0, this._mergeOption(o, n));
      }
      if (!i || i === "recreate" || i === "media") {
        var l = a.getMediaOption(this);
        l.length && E(l, function(u) {
          r = !0, this._mergeOption(u, n);
        }, this);
      }
      return r;
    }, t.prototype.mergeOption = function(i) {
      this._mergeOption(i, null);
    }, t.prototype._mergeOption = function(i, n) {
      var r = this.option, a = this._componentsMap, s = this._componentsCount, o = [], l = ht(), u = n && n.replaceMergeMainTypeMap;
      XR(this), E(i, function(h, d) {
        h != null && (Pt.hasClass(d) ? d && (o.push(d), l.set(d, !0)) : r[d] = r[d] == null ? pt(h) : se(r[d], h, !0));
      }), u && u.each(function(h, d) {
        Pt.hasClass(d) && !l.get(d) && (o.push(d), l.set(d, !0));
      }), Pt.topologicalTravel(o, Pt.getAllClassMainTypes(), c, this);
      function c(h) {
        var d = QR(this, h, Ie(i[h])), f = a.get(h), v = (
          // `!oldCmptList` means init. See the comment in `mappingToExists`
          f ? u && u.get(h) ? "replaceMerge" : "normalMerge" : "replaceAll"
        ), m = IL(f, d, v);
        VL(m, h, Pt), r[h] = null, a.set(h, null), s.set(h, 0);
        var p = [], g = [], y = 0, _, b;
        E(m, function(w, S) {
          var M = w.existing, k = w.newOption;
          if (!k)
            M && (M.mergeOption({}, this), M.optionUpdated({}, !1));
          else {
            var T = h === "series", D = Pt.getClass(
              h,
              w.keyInfo.subType,
              !T
              // Give a more detailed warn later if series don't exists
            );
            if (!D) {
              if (process.env.NODE_ENV !== "production") {
                var C = w.keyInfo.subType, P = n5[C];
                ju[C] || (ju[C] = !0, Kt(P ? "Series " + C + ` is used but not imported.
import { ` + P + ` } from 'echarts/charts';
echarts.use([` + P + "]);" : "Unknown series " + C));
              }
              return;
            }
            if (h === "tooltip") {
              if (_) {
                process.env.NODE_ENV !== "production" && (b || (hi("Currently only one tooltip component is allowed."), b = !0));
                return;
              }
              _ = !0;
            }
            if (M && M.constructor === D)
              M.name = w.keyInfo.name, M.mergeOption(k, this), M.optionUpdated(k, !1);
            else {
              var L = Y({
                componentIndex: S
              }, w.keyInfo);
              M = new D(k, this, this, L), Y(M, L), w.brandNew && (M.__requireNewView = !0), M.init(k, this, this), M.optionUpdated(null, !0);
            }
          }
          M ? (p.push(M.option), g.push(M), y++) : (p.push(void 0), g.push(void 0));
        }, this), r[h] = p, a.set(h, g), s.set(h, y), h === "series" && $l(this);
      }
      this._seriesIndices || $l(this);
    }, t.prototype.getOption = function() {
      var i = pt(this.option);
      return E(i, function(n, r) {
        if (Pt.hasClass(r)) {
          for (var a = Ie(n), s = a.length, o = !1, l = s - 1; l >= 0; l--)
            a[l] && !us(a[l]) ? o = !0 : (a[l] = null, !o && s--);
          a.length = s, i[r] = a;
        }
      }), delete i[od], i;
    }, t.prototype.setTheme = function(i) {
      this._theme = new jt(i), this._resetOption("recreate", null);
    }, t.prototype.getTheme = function() {
      return this._theme;
    }, t.prototype.getLocaleModel = function() {
      return this._locale;
    }, t.prototype.setUpdatePayload = function(i) {
      this._payload = i;
    }, t.prototype.getUpdatePayload = function() {
      return this._payload;
    }, t.prototype.getComponent = function(i, n) {
      var r = this._componentsMap.get(i);
      if (r) {
        var a = r[n || 0];
        if (a)
          return a;
        if (n == null) {
          for (var s = 0; s < r.length; s++)
            if (r[s])
              return r[s];
        }
      }
    }, t.prototype.queryComponents = function(i) {
      var n = i.mainType;
      if (!n)
        return [];
      var r = i.index, a = i.id, s = i.name, o = this._componentsMap.get(n);
      if (!o || !o.length)
        return [];
      var l;
      return r != null ? (l = [], E(Ie(r), function(u) {
        o[u] && l.push(o[u]);
      })) : a != null ? l = ny("id", a, o) : s != null ? l = ny("name", s, o) : l = Ke(o, function(u) {
        return !!u;
      }), ry(l, i);
    }, t.prototype.findComponents = function(i) {
      var n = i.query, r = i.mainType, a = o(n), s = a ? this.queryComponents(a) : Ke(this._componentsMap.get(r), function(u) {
        return !!u;
      });
      return l(ry(s, i));
      function o(u) {
        var c = r + "Index", h = r + "Id", d = r + "Name";
        return u && (u[c] != null || u[h] != null || u[d] != null) ? {
          mainType: r,
          // subType will be filtered finally.
          index: u[c],
          id: u[h],
          name: u[d]
        } : null;
      }
      function l(u) {
        return i.filter ? Ke(u, i.filter) : u;
      }
    }, t.prototype.eachComponent = function(i, n, r) {
      var a = this._componentsMap;
      if (mt(i)) {
        var s = n, o = i;
        a.each(function(h, d) {
          for (var f = 0; h && f < h.length; f++) {
            var v = h[f];
            v && o.call(s, d, v, v.componentIndex);
          }
        });
      } else
        for (var l = et(i) ? a.get(i) : tt(i) ? this.findComponents(i) : null, u = 0; l && u < l.length; u++) {
          var c = l[u];
          c && n.call(r, c, c.componentIndex);
        }
    }, t.prototype.getSeriesByName = function(i) {
      var n = Ti(i, null);
      return Ke(this._componentsMap.get("series"), function(r) {
        return !!r && n != null && r.name === n;
      });
    }, t.prototype.getSeriesByIndex = function(i) {
      return this._componentsMap.get("series")[i];
    }, t.prototype.getSeriesByType = function(i) {
      return Ke(this._componentsMap.get("series"), function(n) {
        return !!n && n.subType === i;
      });
    }, t.prototype.getSeries = function() {
      return Ke(this._componentsMap.get("series"), function(i) {
        return !!i;
      });
    }, t.prototype.getSeriesCount = function() {
      return this._componentsCount.get("series");
    }, t.prototype.eachSeries = function(i, n) {
      Ls(this), E(this._seriesIndices, function(r) {
        var a = this._componentsMap.get("series")[r];
        i.call(n, a, r);
      }, this);
    }, t.prototype.eachRawSeries = function(i, n) {
      E(this._componentsMap.get("series"), function(r) {
        r && i.call(n, r, r.componentIndex);
      });
    }, t.prototype.eachSeriesByType = function(i, n, r) {
      Ls(this), E(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        s.subType === i && n.call(r, s, a);
      }, this);
    }, t.prototype.eachRawSeriesByType = function(i, n, r) {
      return E(this.getSeriesByType(i), n, r);
    }, t.prototype.isSeriesFiltered = function(i) {
      return Ls(this), this._seriesIndicesMap.get(i.componentIndex) == null;
    }, t.prototype.getCurrentSeriesIndices = function() {
      return (this._seriesIndices || []).slice();
    }, t.prototype.filterSeries = function(i, n) {
      Ls(this);
      var r = [];
      E(this._seriesIndices, function(a) {
        var s = this._componentsMap.get("series")[a];
        i.call(n, s, a) && r.push(a);
      }, this), this._seriesIndices = r, this._seriesIndicesMap = ht(r);
    }, t.prototype.restoreData = function(i) {
      $l(this);
      var n = this._componentsMap, r = [];
      n.each(function(a, s) {
        Pt.hasClass(s) && r.push(s);
      }), Pt.topologicalTravel(r, Pt.getAllClassMainTypes(), function(a) {
        E(n.get(a), function(s) {
          s && (a !== "series" || !a5(s, i)) && s.restoreData();
        });
      });
    }, t.internalField = (function() {
      $l = function(i) {
        var n = i._seriesIndices = [];
        E(i._componentsMap.get("series"), function(r) {
          r && n.push(r.componentIndex);
        }), i._seriesIndicesMap = ht(n);
      }, Ls = function(i) {
        if (process.env.NODE_ENV !== "production" && !i._seriesIndices)
          throw new Error("Option should contains series.");
      }, ey = function(i, n) {
        i.option = {}, i.option[od] = iy, i._componentsMap = ht({
          series: []
        }), i._componentsCount = ht();
        var r = n.aria;
        tt(r) && r.enabled == null && (r.enabled = !0), s5(n, i._theme.option), se(n, GR, !1), i._mergeOption(n, null);
      };
    })(), t;
  })(jt)
);
function a5(e, t) {
  if (t) {
    var i = t.seriesIndex, n = t.seriesId, r = t.seriesName;
    return i != null && e.componentIndex !== i || n != null && e.id !== n || r != null && e.name !== r;
  }
}
function s5(e, t) {
  var i = e.color && !e.colorLayer;
  E(t, function(n, r) {
    r === "colorLayer" && i || r === "color" && e.color || Pt.hasClass(r) || (typeof n == "object" ? e[r] = e[r] ? se(e[r], n, !1) : pt(n) : e[r] == null && (e[r] = n));
  });
}
function ny(e, t, i) {
  if (K(t)) {
    var n = ht();
    return E(t, function(a) {
      if (a != null) {
        var s = Ti(a, null);
        s != null && n.set(a, !0);
      }
    }), Ke(i, function(a) {
      return a && n.get(a[e]);
    });
  } else {
    var r = Ti(t, null);
    return Ke(i, function(a) {
      return a && r != null && a[e] === r;
    });
  }
}
function ry(e, t) {
  return t.hasOwnProperty("subType") ? Ke(e, function(i) {
    return i && i.subType === t.subType;
  }) : e;
}
function ay(e) {
  var t = ht();
  return e && E(Ie(e.replaceMerge), function(i) {
    process.env.NODE_ENV !== "production" && nt(Pt.hasClass(i), '"' + i + '" is not valid component main type in "replaceMerge"'), t.set(i, !0);
  }), {
    replaceMergeMainTypeMap: t
  };
}
Pi(ap, rp);
var o5 = [
  "getDom",
  "getZr",
  "getWidth",
  "getHeight",
  "getDevicePixelRatio",
  "dispatchAction",
  "isSSR",
  "isDisposed",
  "on",
  "off",
  "getDataURL",
  "getConnectedDataURL",
  // 'getModel',
  "getOption",
  // 'getViewOfComponentModel',
  // 'getViewOfSeriesModel',
  "getId",
  "updateLabelLayout"
], Bx = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      E(o5, function(i) {
        this[i] = Dt(t[i], t);
      }, this);
    }
    return e;
  })()
), l5 = /^(min|max)?(.+)$/, u5 = (
  /** @class */
  (function() {
    function e(t) {
      this._timelineOptions = [], this._mediaList = [], this._currentMediaIndices = [], this._api = t;
    }
    return e.prototype.setOption = function(t, i, n) {
      t && (E(Ie(t.series), function(s) {
        s && s.data && Ne(s.data) && Gd(s.data);
      }), E(Ie(t.dataset), function(s) {
        s && s.source && Ne(s.source) && Gd(s.source);
      })), t = pt(t);
      var r = this._optionBackup, a = c5(t, i, !r);
      this._newBaseOption = a.baseOption, r ? (a.timelineOptions.length && (r.timelineOptions = a.timelineOptions), a.mediaList.length && (r.mediaList = a.mediaList), a.mediaDefault && (r.mediaDefault = a.mediaDefault)) : this._optionBackup = a;
    }, e.prototype.mountOption = function(t) {
      var i = this._optionBackup;
      return this._timelineOptions = i.timelineOptions, this._mediaList = i.mediaList, this._mediaDefault = i.mediaDefault, this._currentMediaIndices = [], pt(t ? i.baseOption : this._newBaseOption);
    }, e.prototype.getTimelineOption = function(t) {
      var i, n = this._timelineOptions;
      if (n.length) {
        var r = t.getComponent("timeline");
        r && (i = pt(
          // FIXME:TS as TimelineModel or quivlant interface
          n[r.getCurrentIndex()]
        ));
      }
      return i;
    }, e.prototype.getMediaOption = function(t) {
      var i = this._api.getWidth(), n = this._api.getHeight(), r = this._mediaList, a = this._mediaDefault, s = [], o = [];
      if (!r.length && !a)
        return o;
      for (var l = 0, u = r.length; l < u; l++)
        h5(r[l].query, i, n) && s.push(l);
      return !s.length && a && (s = [-1]), s.length && !f5(s, this._currentMediaIndices) && (o = _t(s, function(c) {
        return pt(c === -1 ? a.option : r[c].option);
      })), this._currentMediaIndices = s, o;
    }, e;
  })()
);
function c5(e, t, i) {
  var n = [], r, a, s = e.baseOption, o = e.timeline, l = e.options, u = e.media, c = !!e.media, h = !!(l || o || s && s.timeline);
  s ? (a = s, a.timeline || (a.timeline = o)) : ((h || c) && (e.options = e.media = null), a = e), c && (K(u) ? E(u, function(f) {
    process.env.NODE_ENV !== "production" && f && !f.option && tt(f.query) && tt(f.query.option) && Kt("Illegal media option. Must be like { media: [ { query: {}, option: {} } ] }"), f && f.option && (f.query ? n.push(f) : r || (r = f));
  }) : process.env.NODE_ENV !== "production" && Kt("Illegal media option. Must be an array. Like { media: [ {...}, {...} ] }")), d(a), E(l, function(f) {
    return d(f);
  }), E(n, function(f) {
    return d(f.option);
  });
  function d(f) {
    E(t, function(v) {
      v(f, i);
    });
  }
  return {
    baseOption: a,
    timelineOptions: l || [],
    mediaDefault: r,
    mediaList: n
  };
}
function h5(e, t, i) {
  var n = {
    width: t,
    height: i,
    aspectratio: t / i
    // lower case for convenience.
  }, r = !0;
  return E(e, function(a, s) {
    var o = s.match(l5);
    if (!(!o || !o[1] || !o[2])) {
      var l = o[1], u = o[2].toLowerCase();
      d5(n[u], a, l) || (r = !1);
    }
  }), r;
}
function d5(e, t, i) {
  return i === "min" ? e >= t : i === "max" ? e <= t : e === t;
}
function f5(e, t) {
  return e.join(",") === t.join(",");
}
var ri = E, $o = tt, sy = ["areaStyle", "lineStyle", "nodeStyle", "linkStyle", "chordStyle", "label", "labelLine"];
function ld(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0, n = sy.length; i < n; i++) {
      var r = sy[i], a = t.normal, s = t.emphasis;
      a && a[r] && (process.env.NODE_ENV !== "production" && ge("itemStyle.normal." + r, r), e[r] = e[r] || {}, e[r].normal ? se(e[r].normal, a[r]) : e[r].normal = a[r], a[r] = null), s && s[r] && (process.env.NODE_ENV !== "production" && ge("itemStyle.emphasis." + r, "emphasis." + r), e[r] = e[r] || {}, e[r].emphasis ? se(e[r].emphasis, s[r]) : e[r].emphasis = s[r], s[r] = null);
    }
}
function we(e, t, i) {
  if (e && e[t] && (e[t].normal || e[t].emphasis)) {
    var n = e[t].normal, r = e[t].emphasis;
    n && (process.env.NODE_ENV !== "production" && Cn("'normal' hierarchy in " + t + " has been removed since 4.0. All style properties are configured in " + t + " directly now."), i ? (e[t].normal = e[t].emphasis = null, Jt(e[t], n)) : e[t] = n), r && (process.env.NODE_ENV !== "production" && Cn(t + ".emphasis has been changed to emphasis." + t + " since 4.0"), e.emphasis = e.emphasis || {}, e.emphasis[t] = r, r.focus && (e.emphasis.focus = r.focus), r.blurScope && (e.emphasis.blurScope = r.blurScope));
  }
}
function ro(e) {
  we(e, "itemStyle"), we(e, "lineStyle"), we(e, "areaStyle"), we(e, "label"), we(e, "labelLine"), we(e, "upperLabel"), we(e, "edgeLabel");
}
function ie(e, t) {
  var i = $o(e) && e[t], n = $o(i) && i.textStyle;
  if (n) {
    process.env.NODE_ENV !== "production" && Cn("textStyle hierarchy in " + t + " has been removed since 4.0. All textStyle properties are configured in " + t + " directly now.");
    for (var r = 0, a = t0.length; r < a; r++) {
      var s = t0[r];
      n.hasOwnProperty(s) && (i[s] = n[s]);
    }
  }
}
function li(e) {
  e && (ro(e), ie(e, "label"), e.emphasis && ie(e.emphasis, "label"));
}
function v5(e) {
  if ($o(e)) {
    ld(e), ro(e), ie(e, "label"), ie(e, "upperLabel"), ie(e, "edgeLabel"), e.emphasis && (ie(e.emphasis, "label"), ie(e.emphasis, "upperLabel"), ie(e.emphasis, "edgeLabel"));
    var t = e.markPoint;
    t && (ld(t), li(t));
    var i = e.markLine;
    i && (ld(i), li(i));
    var n = e.markArea;
    n && li(n);
    var r = e.data;
    if (e.type === "graph") {
      r = r || e.nodes;
      var a = e.links || e.edges;
      if (a && !Ne(a))
        for (var s = 0; s < a.length; s++)
          li(a[s]);
      E(e.categories, function(u) {
        ro(u);
      });
    }
    if (r && !Ne(r))
      for (var s = 0; s < r.length; s++)
        li(r[s]);
    if (t = e.markPoint, t && t.data)
      for (var o = t.data, s = 0; s < o.length; s++)
        li(o[s]);
    if (i = e.markLine, i && i.data)
      for (var l = i.data, s = 0; s < l.length; s++)
        K(l[s]) ? (li(l[s][0]), li(l[s][1])) : li(l[s]);
    e.type === "gauge" ? (ie(e, "axisLabel"), ie(e, "title"), ie(e, "detail")) : e.type === "treemap" ? (we(e.breadcrumb, "itemStyle"), E(e.levels, function(u) {
      ro(u);
    })) : e.type === "tree" && ro(e.leaves);
  }
}
function ln(e) {
  return K(e) ? e : e ? [e] : [];
}
function oy(e) {
  return (K(e) ? e[0] : e) || {};
}
function p5(e, t) {
  ri(ln(e.series), function(n) {
    $o(n) && v5(n);
  });
  var i = ["xAxis", "yAxis", "radiusAxis", "angleAxis", "singleAxis", "parallelAxis", "radar"];
  t && i.push("valueAxis", "categoryAxis", "logAxis", "timeAxis"), ri(i, function(n) {
    ri(ln(e[n]), function(r) {
      r && (ie(r, "axisLabel"), ie(r.axisPointer, "label"));
    });
  }), ri(ln(e.parallel), function(n) {
    var r = n && n.parallelAxisDefault;
    ie(r, "axisLabel"), ie(r && r.axisPointer, "label");
  }), ri(ln(e.calendar), function(n) {
    we(n, "itemStyle"), ie(n, "dayLabel"), ie(n, "monthLabel"), ie(n, "yearLabel");
  }), ri(ln(e.radar), function(n) {
    ie(n, "name"), n.name && n.axisName == null && (n.axisName = n.name, delete n.name, process.env.NODE_ENV !== "production" && Cn("name property in radar component has been changed to axisName")), n.nameGap != null && n.axisNameGap == null && (n.axisNameGap = n.nameGap, delete n.nameGap, process.env.NODE_ENV !== "production" && Cn("nameGap property in radar component has been changed to axisNameGap")), process.env.NODE_ENV !== "production" && ri(n.indicator, function(r) {
      r.text && ge("text", "name", "radar.indicator");
    });
  }), ri(ln(e.geo), function(n) {
    $o(n) && (li(n), ri(ln(n.regions), function(r) {
      li(r);
    }));
  }), ri(ln(e.timeline), function(n) {
    li(n), we(n, "label"), we(n, "itemStyle"), we(n, "controlStyle", !0);
    var r = n.data;
    K(r) && E(r, function(a) {
      tt(a) && (we(a, "label"), we(a, "itemStyle"));
    });
  }), ri(ln(e.toolbox), function(n) {
    we(n, "iconStyle"), ri(n.feature, function(r) {
      we(r, "iconStyle");
    });
  }), ie(oy(e.axisPointer), "label"), ie(oy(e.tooltip).axisPointer, "label");
}
function g5(e, t) {
  for (var i = t.split(","), n = e, r = 0; r < i.length && (n = n && n[i[r]], n != null); r++)
    ;
  return n;
}
function m5(e, t, i, n) {
  for (var r = t.split(","), a = e, s, o = 0; o < r.length - 1; o++)
    s = r[o], a[s] == null && (a[s] = {}), a = a[s];
  a[r[o]] == null && (a[r[o]] = i);
}
function ly(e) {
  e && E(y5, function(t) {
    t[0] in e && !(t[1] in e) && (e[t[1]] = e[t[0]]);
  });
}
var y5 = [["x", "left"], ["y", "top"], ["x2", "right"], ["y2", "bottom"]], _5 = ["grid", "geo", "parallel", "legend", "toolbox", "title", "visualMap", "dataZoom", "timeline"], ud = [["borderRadius", "barBorderRadius"], ["borderColor", "barBorderColor"], ["borderWidth", "barBorderWidth"]];
function Os(e) {
  var t = e && e.itemStyle;
  if (t)
    for (var i = 0; i < ud.length; i++) {
      var n = ud[i][1], r = ud[i][0];
      t[n] != null && (t[r] = t[n], process.env.NODE_ENV !== "production" && ge(n, r));
    }
}
function uy(e) {
  e && e.alignTo === "edge" && e.margin != null && e.edgeDistance == null && (process.env.NODE_ENV !== "production" && ge("label.margin", "label.edgeDistance", "pie"), e.edgeDistance = e.margin);
}
function cy(e) {
  e && e.downplay && !e.blur && (e.blur = e.downplay, process.env.NODE_ENV !== "production" && ge("downplay", "blur", "sunburst"));
}
function b5(e) {
  e && e.focusNodeAdjacency != null && (e.emphasis = e.emphasis || {}, e.emphasis.focus == null && (process.env.NODE_ENV !== "production" && ge("focusNodeAdjacency", "emphasis: { focus: 'adjacency'}", "graph/sankey"), e.emphasis.focus = "adjacency"));
}
function $x(e, t) {
  if (e)
    for (var i = 0; i < e.length; i++)
      t(e[i]), e[i] && $x(e[i].children, t);
}
function zx(e, t) {
  p5(e, t), e.series = Ie(e.series), E(e.series, function(i) {
    if (tt(i)) {
      var n = i.type;
      if (n === "line")
        i.clipOverflow != null && (i.clip = i.clipOverflow, process.env.NODE_ENV !== "production" && ge("clipOverflow", "clip", "line"));
      else if (n === "pie" || n === "gauge") {
        i.clockWise != null && (i.clockwise = i.clockWise, process.env.NODE_ENV !== "production" && ge("clockWise", "clockwise")), uy(i.label);
        var r = i.data;
        if (r && !Ne(r))
          for (var a = 0; a < r.length; a++)
            uy(r[a]);
        i.hoverOffset != null && (i.emphasis = i.emphasis || {}, (i.emphasis.scaleSize = null) && (process.env.NODE_ENV !== "production" && ge("hoverOffset", "emphasis.scaleSize"), i.emphasis.scaleSize = i.hoverOffset));
      } else if (n === "gauge") {
        var s = g5(i, "pointer.color");
        s != null && m5(i, "itemStyle.color", s);
      } else if (n === "bar") {
        Os(i), Os(i.backgroundStyle), Os(i.emphasis);
        var r = i.data;
        if (r && !Ne(r))
          for (var a = 0; a < r.length; a++)
            typeof r[a] == "object" && (Os(r[a]), Os(r[a] && r[a].emphasis));
      } else if (n === "sunburst") {
        var o = i.highlightPolicy;
        o && (i.emphasis = i.emphasis || {}, i.emphasis.focus || (i.emphasis.focus = o, process.env.NODE_ENV !== "production" && ge("highlightPolicy", "emphasis.focus", "sunburst"))), cy(i), $x(i.data, cy);
      } else n === "graph" || n === "sankey" ? b5(i) : n === "map" && (i.mapType && !i.map && (process.env.NODE_ENV !== "production" && ge("mapType", "map", "map"), i.map = i.mapType), i.mapLocation && (process.env.NODE_ENV !== "production" && Cn("`mapLocation` is not used anymore."), Jt(i, i.mapLocation)));
      i.hoverAnimation != null && (i.emphasis = i.emphasis || {}, i.emphasis && i.emphasis.scale == null && (process.env.NODE_ENV !== "production" && ge("hoverAnimation", "emphasis.scale"), i.emphasis.scale = i.hoverAnimation)), ly(i);
    }
  }), e.dataRange && (e.visualMap = e.dataRange), E(_5, function(i) {
    var n = e[i];
    n && (K(n) || (n = [n]), E(n, function(r) {
      ly(r);
    }));
  });
}
function x5(e) {
  var t = ht();
  e.eachSeries(function(i) {
    var n = i.get("stack");
    if (n) {
      var r = t.get(n) || t.set(n, []), a = i.getData(), s = {
        // Used for calculate axis extent automatically.
        // TODO: Type getCalculationInfo return more specific type?
        stackResultDimension: a.getCalculationInfo("stackResultDimension"),
        stackedOverDimension: a.getCalculationInfo("stackedOverDimension"),
        stackedDimension: a.getCalculationInfo("stackedDimension"),
        stackedByDimension: a.getCalculationInfo("stackedByDimension"),
        isStackedByIndex: a.getCalculationInfo("isStackedByIndex"),
        data: a,
        seriesModel: i
      };
      if (!s.stackedDimension || !(s.isStackedByIndex || s.stackedByDimension))
        return;
      r.push(s);
    }
  }), t.each(function(i) {
    if (i.length !== 0) {
      var n = i[0].seriesModel, r = n.get("stackOrder") || "seriesAsc";
      r === "seriesDesc" && i.reverse(), E(i, function(a, s) {
        a.data.setCalculationInfo("stackedOnSeries", s > 0 ? i[s - 1].seriesModel : null);
      }), w5(i);
    }
  });
}
function w5(e) {
  E(e, function(t, i) {
    var n = [], r = [NaN, NaN], a = [t.stackResultDimension, t.stackedOverDimension], s = t.data, o = t.isStackedByIndex, l = t.seriesModel.get("stackStrategy") || "samesign";
    s.modify(a, function(u, c, h) {
      var d = s.get(t.stackedDimension, h);
      if (isNaN(d))
        return r;
      var f, v;
      o ? v = s.getRawIndex(h) : f = s.get(t.stackedByDimension, h);
      for (var m = NaN, p = i - 1; p >= 0; p--) {
        var g = e[p];
        if (o || (v = g.data.rawIndexOf(g.stackedByDimension, f)), v >= 0) {
          var y = g.data.getByRawIndex(g.stackResultDimension, v);
          if (l === "all" || l === "positive" && y > 0 || l === "negative" && y < 0 || l === "samesign" && d >= 0 && y > 0 || l === "samesign" && d <= 0 && y < 0) {
            d = TL(d, y), m = y;
            break;
          }
        }
      }
      return n[0] = d, n[1] = m, n;
    });
  });
}
var $c = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.data = t.data || (t.sourceFormat === nn ? {} : []), this.sourceFormat = t.sourceFormat || Ix, this.seriesLayoutBy = t.seriesLayoutBy || tn, this.startIndex = t.startIndex || 0, this.dimensionsDetectedCount = t.dimensionsDetectedCount, this.metaRawOption = t.metaRawOption;
      var i = this.dimensionsDefine = t.dimensionsDefine;
      if (i)
        for (var n = 0; n < i.length; n++) {
          var r = i[n];
          r.type == null && Fx(this, n) === je.Must && (r.type = "ordinal");
        }
    }
    return e;
  })()
);
function sp(e) {
  return e instanceof $c;
}
function Tf(e, t, i) {
  i = i || Vx(e);
  var n = t.seriesLayoutBy, r = M5(e, i, n, t.sourceHeader, t.dimensions), a = new $c({
    data: e,
    sourceFormat: i,
    seriesLayoutBy: n,
    dimensionsDefine: r.dimensionsDefine,
    startIndex: r.startIndex,
    dimensionsDetectedCount: r.dimensionsDetectedCount,
    metaRawOption: pt(t)
  });
  return a;
}
function op(e) {
  return new $c({
    data: e,
    sourceFormat: Ne(e) ? Mn : ti
  });
}
function S5(e) {
  return new $c({
    data: e.data,
    sourceFormat: e.sourceFormat,
    seriesLayoutBy: e.seriesLayoutBy,
    dimensionsDefine: pt(e.dimensionsDefine),
    startIndex: e.startIndex,
    dimensionsDetectedCount: e.dimensionsDetectedCount
  });
}
function Vx(e) {
  var t = Ix;
  if (Ne(e))
    t = Mn;
  else if (K(e)) {
    e.length === 0 && (t = Ee);
    for (var i = 0, n = e.length; i < n; i++) {
      var r = e[i];
      if (r != null) {
        if (K(r) || Ne(r)) {
          t = Ee;
          break;
        } else if (tt(r)) {
          t = Ii;
          break;
        }
      }
    }
  } else if (tt(e)) {
    for (var a in e)
      if (Zi(e, a) && Xe(e[a])) {
        t = nn;
        break;
      }
  }
  return t;
}
function M5(e, t, i, n, r) {
  var a, s;
  if (!e)
    return {
      dimensionsDefine: hy(r),
      startIndex: s,
      dimensionsDetectedCount: a
    };
  if (t === Ee) {
    var o = e;
    n === "auto" || n == null ? dy(function(u) {
      u != null && u !== "-" && (et(u) ? s == null && (s = 1) : s = 0);
    }, i, o, 10) : s = Zt(n) ? n : n ? 1 : 0, !r && s === 1 && (r = [], dy(function(u, c) {
      r[c] = u != null ? u + "" : "";
    }, i, o, 1 / 0)), a = r ? r.length : i === da ? o.length : o[0] ? o[0].length : null;
  } else if (t === Ii)
    r || (r = k5(e));
  else if (t === nn)
    r || (r = [], E(e, function(u, c) {
      r.push(c);
    }));
  else if (t === ti) {
    var l = Zo(e[0]);
    a = K(l) && l.length || 1;
  } else t === Mn && process.env.NODE_ENV !== "production" && nt(!!r, "dimensions must be given if data is TypedArray.");
  return {
    startIndex: s,
    dimensionsDefine: hy(r),
    dimensionsDetectedCount: a
  };
}
function k5(e) {
  for (var t = 0, i; t < e.length && !(i = e[t++]); )
    ;
  if (i)
    return qt(i);
}
function hy(e) {
  if (e) {
    var t = ht();
    return _t(e, function(i, n) {
      i = tt(i) ? i : {
        name: i
      };
      var r = {
        name: i.name,
        displayName: i.displayName,
        type: i.type
      };
      if (r.name == null)
        return r;
      r.name += "", r.displayName == null && (r.displayName = r.name);
      var a = t.get(r.name);
      return a ? r.name += "-" + a.count++ : t.set(r.name, {
        count: 1
      }), r;
    });
  }
}
function dy(e, t, i, n) {
  if (t === da)
    for (var r = 0; r < i.length && r < n; r++)
      e(i[r] ? i[r][0] : null, r);
  else
    for (var a = i[0] || [], r = 0; r < a.length && r < n; r++)
      e(a[r], r);
}
function Hx(e) {
  var t = e.sourceFormat;
  return t === Ii || t === nn;
}
var Ar, Pr, Lr, Or, fy, vy, Yx = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = sp(t) ? t : op(t);
      this._source = n;
      var r = this._data = n.data, a = n.sourceFormat, s = n.seriesLayoutBy;
      if (a === Mn) {
        if (process.env.NODE_ENV !== "production" && i == null)
          throw new Error("Typed array data must specify dimension size");
        this._offset = 0, this._dimSize = i, this._data = r;
      }
      if (process.env.NODE_ENV !== "production") {
        var o = D5[qu(a, s)];
        o && o(r, n.dimensionsDefine);
      }
      vy(this, r, n);
    }
    return e.prototype.getSource = function() {
      return this._source;
    }, e.prototype.count = function() {
      return 0;
    }, e.prototype.getItem = function(t, i) {
    }, e.prototype.appendData = function(t) {
    }, e.prototype.clean = function() {
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.pure = !1, t.persistent = !0;
    })(), e.internalField = (function() {
      var t;
      vy = function(s, o, l) {
        var u = l.sourceFormat, c = l.seriesLayoutBy, h = l.startIndex, d = l.dimensionsDefine, f = fy[qu(u, c)];
        if (process.env.NODE_ENV !== "production" && nt(f, "Invalide sourceFormat: " + u), Y(s, f), u === Mn)
          s.getItem = i, s.count = r, s.fillStorage = n;
        else {
          var v = Wx(u, c);
          s.getItem = Dt(v, null, o, h, d);
          var m = Ux(u, c);
          s.count = Dt(m, null, o, h, d);
        }
      };
      var i = function(s, o) {
        s = s - this._offset, o = o || [];
        for (var l = this._data, u = this._dimSize, c = u * s, h = 0; h < u; h++)
          o[h] = l[c + h];
        return o;
      }, n = function(s, o, l, u) {
        for (var c = this._data, h = this._dimSize, d = 0; d < h; d++) {
          for (var f = u[d], v = f[0] == null ? 1 / 0 : f[0], m = f[1] == null ? -1 / 0 : f[1], p = o - s, g = l[d], y = 0; y < p; y++) {
            var _ = c[y * h + d];
            g[s + y] = _, _ < v && (v = _), _ > m && (m = _);
          }
          f[0] = v, f[1] = m;
        }
      }, r = function() {
        return this._data ? this._data.length / this._dimSize : 0;
      };
      fy = (t = {}, t[Ee + "_" + tn] = {
        pure: !0,
        appendData: a
      }, t[Ee + "_" + da] = {
        pure: !0,
        appendData: function() {
          throw new Error('Do not support appendData when set seriesLayoutBy: "row".');
        }
      }, t[Ii] = {
        pure: !0,
        appendData: a
      }, t[nn] = {
        pure: !0,
        appendData: function(s) {
          var o = this._data;
          E(s, function(l, u) {
            for (var c = o[u] || (o[u] = []), h = 0; h < (l || []).length; h++)
              c.push(l[h]);
          });
        }
      }, t[ti] = {
        appendData: a
      }, t[Mn] = {
        persistent: !1,
        pure: !0,
        appendData: function(s) {
          process.env.NODE_ENV !== "production" && nt(Ne(s), "Added data must be TypedArray if data in initialization is TypedArray"), this._data = s;
        },
        // Clean self if data is already used.
        clean: function() {
          this._offset += this.count(), this._data = null;
        }
      }, t);
      function a(s) {
        for (var o = 0; o < s.length; o++)
          this._data.push(s[o]);
      }
    })(), e;
  })()
), zl = function(e) {
  K(e) || Kt("series.data or dataset.source must be an array.");
}, D5 = (Ar = {}, Ar[Ee + "_" + tn] = zl, Ar[Ee + "_" + da] = zl, Ar[Ii] = zl, Ar[nn] = function(e, t) {
  for (var i = 0; i < t.length; i++) {
    var n = t[i].name;
    n == null && Kt("dimension name must not be null/undefined.");
  }
}, Ar[ti] = zl, Ar), py = function(e, t, i, n) {
  return e[n];
}, T5 = (Pr = {}, Pr[Ee + "_" + tn] = function(e, t, i, n) {
  return e[n + t];
}, Pr[Ee + "_" + da] = function(e, t, i, n, r) {
  n += t;
  for (var a = r || [], s = e, o = 0; o < s.length; o++) {
    var l = s[o];
    a[o] = l ? l[n] : null;
  }
  return a;
}, Pr[Ii] = py, Pr[nn] = function(e, t, i, n, r) {
  for (var a = r || [], s = 0; s < i.length; s++) {
    var o = i[s].name, l = o != null ? e[o] : null;
    a[s] = l ? l[n] : null;
  }
  return a;
}, Pr[ti] = py, Pr);
function Wx(e, t) {
  var i = T5[qu(e, t)];
  return process.env.NODE_ENV !== "production" && nt(i, 'Do not support get item on "' + e + '", "' + t + '".'), i;
}
var gy = function(e, t, i) {
  return e.length;
}, C5 = (Lr = {}, Lr[Ee + "_" + tn] = function(e, t, i) {
  return Math.max(0, e.length - t);
}, Lr[Ee + "_" + da] = function(e, t, i) {
  var n = e[0];
  return n ? Math.max(0, n.length - t) : 0;
}, Lr[Ii] = gy, Lr[nn] = function(e, t, i) {
  var n = i[0].name, r = n != null ? e[n] : null;
  return r ? r.length : 0;
}, Lr[ti] = gy, Lr);
function Ux(e, t) {
  var i = C5[qu(e, t)];
  return process.env.NODE_ENV !== "production" && nt(i, 'Do not support count on "' + e + '", "' + t + '".'), i;
}
var cd = function(e, t, i) {
  return e[t];
}, E5 = (Or = {}, Or[Ee] = cd, Or[Ii] = function(e, t, i) {
  return e[i];
}, Or[nn] = cd, Or[ti] = function(e, t, i) {
  var n = Zo(e);
  return n instanceof Array ? n[t] : n;
}, Or[Mn] = cd, Or);
function Gx(e) {
  var t = E5[e];
  return process.env.NODE_ENV !== "production" && nt(t, 'Do not support get value on "' + e + '".'), t;
}
function qu(e, t) {
  return e === Ee ? e + "_" + t : e;
}
function Zu(e, t, i) {
  if (e) {
    var n = e.getRawDataItem(t);
    if (n != null) {
      var r = e.getStore(), a = r.getSource().sourceFormat;
      if (i != null) {
        var s = e.getDimensionIndex(i), o = r.getDimensionProperty(s);
        return Gx(a)(n, s, o);
      } else {
        var l = n;
        return a === ti && (l = Zo(n)), l;
      }
    }
  }
}
var A5 = /\{@(.+?)\}/g, P5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getDataParams = function(t, i) {
      var n = this.getData(i), r = this.getRawValue(t, i), a = n.getRawIndex(t), s = n.getName(t), o = n.getRawDataItem(t), l = n.getItemVisual(t, "style"), u = l && l[n.getItemVisual(t, "drawType") || "fill"], c = l && l.stroke, h = this.mainType, d = h === "series", f = n.userOutput && n.userOutput.get();
      return {
        componentType: h,
        componentSubType: this.subType,
        componentIndex: this.componentIndex,
        seriesType: d ? this.subType : null,
        seriesIndex: this.seriesIndex,
        seriesId: d ? this.id : null,
        seriesName: d ? this.name : null,
        name: s,
        dataIndex: a,
        data: o,
        dataType: i,
        value: r,
        color: u,
        borderColor: c,
        dimensionNames: f ? f.fullDimensions : null,
        encode: f ? f.encode : null,
        // Param name list for mapping `a`, `b`, `c`, `d`, `e`
        $vars: ["seriesName", "name", "value"]
      };
    }, e.prototype.getFormattedLabel = function(t, i, n, r, a, s) {
      i = i || "normal";
      var o = this.getData(n), l = this.getDataParams(t, n);
      if (s && (l.value = s.interpolatedValue), r != null && K(l.value) && (l.value = l.value[r]), !a) {
        var u = o.getItemModel(t);
        a = u.get(i === "normal" ? ["label", "formatter"] : [i, "label", "formatter"]);
      }
      if (mt(a))
        return l.status = i, l.dimensionIndex = r, a(l);
      if (et(a)) {
        var c = Cx(a, l);
        return c.replace(A5, function(h, d) {
          var f = d.length, v = d;
          v.charAt(0) === "[" && v.charAt(f - 1) === "]" && (v = +v.slice(1, f - 1), process.env.NODE_ENV !== "production" && isNaN(v) && Kt("Invalide label formatter: @" + d + ", only support @[0], @[1], @[2], ..."));
          var m = Zu(o, t, v);
          if (s && K(s.interpolatedValue)) {
            var p = o.getDimensionIndex(v);
            p >= 0 && (m = s.interpolatedValue[p]);
          }
          return m != null ? m + "" : "";
        });
      }
    }, e.prototype.getRawValue = function(t, i) {
      return Zu(this.getData(i), t);
    }, e.prototype.formatTooltip = function(t, i, n) {
    }, e;
  })()
);
function my(e) {
  var t, i;
  return tt(e) ? e.type ? i = e : process.env.NODE_ENV !== "production" && console.warn("The return type of `formatTooltip` is not supported: " + $u(e)) : t = e, {
    text: t,
    // markers: markers || markersExisting,
    frag: i
  };
}
function bo(e) {
  return new L5(e);
}
var L5 = (
  /** @class */
  (function() {
    function e(t) {
      t = t || {}, this._reset = t.reset, this._plan = t.plan, this._count = t.count, this._onDirty = t.onDirty, this._dirty = !0;
    }
    return e.prototype.perform = function(t) {
      var i = this._upstream, n = t && t.skip;
      if (this._dirty && i) {
        var r = this.context;
        r.data = r.outputData = i.context.outputData;
      }
      this.__pipeline && (this.__pipeline.currentTask = this);
      var a;
      this._plan && !n && (a = this._plan(this.context));
      var s = c(this._modBy), o = this._modDataCount || 0, l = c(t && t.modBy), u = t && t.modDataCount || 0;
      (s !== l || o !== u) && (a = "reset");
      function c(y) {
        return !(y >= 1) && (y = 1), y;
      }
      var h;
      (this._dirty || a === "reset") && (this._dirty = !1, h = this._doReset(n)), this._modBy = l, this._modDataCount = u;
      var d = t && t.step;
      if (i ? (process.env.NODE_ENV !== "production" && nt(i._outputDueEnd != null), this._dueEnd = i._outputDueEnd) : (process.env.NODE_ENV !== "production" && nt(!this._progress || this._count), this._dueEnd = this._count ? this._count(this.context) : 1 / 0), this._progress) {
        var f = this._dueIndex, v = Math.min(d != null ? this._dueIndex + d : 1 / 0, this._dueEnd);
        if (!n && (h || f < v)) {
          var m = this._progress;
          if (K(m))
            for (var p = 0; p < m.length; p++)
              this._doProgress(m[p], f, v, l, u);
          else
            this._doProgress(m, f, v, l, u);
        }
        this._dueIndex = v;
        var g = this._settedOutputEnd != null ? this._settedOutputEnd : v;
        process.env.NODE_ENV !== "production" && nt(g >= this._outputDueEnd), this._outputDueEnd = g;
      } else
        this._dueIndex = this._outputDueEnd = this._settedOutputEnd != null ? this._settedOutputEnd : this._dueEnd;
      return this.unfinished();
    }, e.prototype.dirty = function() {
      this._dirty = !0, this._onDirty && this._onDirty(this.context);
    }, e.prototype._doProgress = function(t, i, n, r, a) {
      yy.reset(i, n, r, a), this._callingProgress = t, this._callingProgress({
        start: i,
        end: n,
        count: n - i,
        next: yy.next
      }, this.context);
    }, e.prototype._doReset = function(t) {
      this._dueIndex = this._outputDueEnd = this._dueEnd = 0, this._settedOutputEnd = null;
      var i, n;
      !t && this._reset && (i = this._reset(this.context), i && i.progress && (n = i.forceFirstProgress, i = i.progress), K(i) && !i.length && (i = null)), this._progress = i, this._modBy = this._modDataCount = null;
      var r = this._downstream;
      return r && r.dirty(), n;
    }, e.prototype.unfinished = function() {
      return this._progress && this._dueIndex < this._dueEnd;
    }, e.prototype.pipe = function(t) {
      process.env.NODE_ENV !== "production" && nt(t && !t._disposed && t !== this), (this._downstream !== t || this._dirty) && (this._downstream = t, t._upstream = this, t.dirty());
    }, e.prototype.dispose = function() {
      this._disposed || (this._upstream && (this._upstream._downstream = null), this._downstream && (this._downstream._upstream = null), this._dirty = !1, this._disposed = !0);
    }, e.prototype.getUpstream = function() {
      return this._upstream;
    }, e.prototype.getDownstream = function() {
      return this._downstream;
    }, e.prototype.setOutputEnd = function(t) {
      this._outputDueEnd = this._settedOutputEnd = t;
    }, e;
  })()
), yy = /* @__PURE__ */ (function() {
  var e, t, i, n, r, a = {
    reset: function(l, u, c, h) {
      t = l, e = u, i = c, n = h, r = Math.ceil(n / i), a.next = i > 1 && n > 0 ? o : s;
    }
  };
  return a;
  function s() {
    return t < e ? t++ : null;
  }
  function o() {
    var l = t % r * i + Math.ceil(t / r), u = t >= e ? null : l < n ? l : t;
    return t++, u;
  }
})();
function du(e, t) {
  var i = t && t.type;
  return i === "ordinal" ? e : (i === "time" && !Zt(e) && e != null && e !== "-" && (e = +Ec(e)), e == null || e === "" ? NaN : Number(e));
}
ht({
  number: function(e) {
    return parseFloat(e);
  },
  time: function(e) {
    return +Ec(e);
  },
  trim: function(e) {
    return et(e) ? Xi(e) : e;
  }
});
var O5 = (
  /** @class */
  (function() {
    function e(t, i) {
      var n = t === "desc";
      this._resultLT = n ? 1 : -1, i == null && (i = n ? "min" : "max"), this._incomparable = i === "min" ? -1 / 0 : 1 / 0;
    }
    return e.prototype.evaluate = function(t, i) {
      var n = Zt(t) ? t : Bu(t), r = Zt(i) ? i : Bu(i), a = isNaN(n), s = isNaN(r);
      if (a && (n = this._incomparable), s && (r = this._incomparable), a && s) {
        var o = et(t), l = et(i);
        o && (n = l ? t : 0), l && (r = o ? i : 0);
      }
      return n < r ? this._resultLT : n > r ? -this._resultLT : 0;
    }, e;
  })()
), I5 = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.getRawData = function() {
      throw new Error("not supported");
    }, e.prototype.getRawDataItem = function(t) {
      throw new Error("not supported");
    }, e.prototype.cloneRawData = function() {
    }, e.prototype.getDimensionInfo = function(t) {
    }, e.prototype.cloneAllDimensionInfo = function() {
    }, e.prototype.count = function() {
    }, e.prototype.retrieveValue = function(t, i) {
    }, e.prototype.retrieveValueFromItem = function(t, i) {
    }, e.prototype.convertValue = function(t, i) {
      return du(t, i);
    }, e;
  })()
);
function R5(e, t) {
  var i = new I5(), n = e.data, r = i.sourceFormat = e.sourceFormat, a = e.startIndex, s = "";
  e.seriesLayoutBy !== tn && (process.env.NODE_ENV !== "production" && (s = '`seriesLayoutBy` of upstream dataset can only be "column" in data transform.'), We(s));
  var o = [], l = {}, u = e.dimensionsDefine;
  if (u)
    E(u, function(m, p) {
      var g = m.name, y = {
        index: p,
        name: g,
        displayName: m.displayName
      };
      if (o.push(y), g != null) {
        var _ = "";
        Zi(l, g) && (process.env.NODE_ENV !== "production" && (_ = 'dimension name "' + g + '" duplicated.'), We(_)), l[g] = y;
      }
    });
  else
    for (var c = 0; c < e.dimensionsDetectedCount; c++)
      o.push({
        index: c
      });
  var h = Wx(r, tn);
  t.__isBuiltIn && (i.getRawDataItem = function(m) {
    return h(n, a, o, m);
  }, i.getRawData = Dt(N5, null, e)), i.cloneRawData = Dt(F5, null, e);
  var d = Ux(r, tn);
  i.count = Dt(d, null, n, a, o);
  var f = Gx(r);
  i.retrieveValue = function(m, p) {
    var g = h(n, a, o, m);
    return v(g, p);
  };
  var v = i.retrieveValueFromItem = function(m, p) {
    if (m != null) {
      var g = o[p];
      if (g)
        return f(m, p, g.name);
    }
  };
  return i.getDimensionInfo = Dt(B5, null, o, l), i.cloneAllDimensionInfo = Dt($5, null, o), i;
}
function N5(e) {
  var t = e.sourceFormat;
  if (!lp(t)) {
    var i = "";
    process.env.NODE_ENV !== "production" && (i = "`getRawData` is not supported in source format " + t), We(i);
  }
  return e.data;
}
function F5(e) {
  var t = e.sourceFormat, i = e.data;
  if (!lp(t)) {
    var n = "";
    process.env.NODE_ENV !== "production" && (n = "`cloneRawData` is not supported in source format " + t), We(n);
  }
  if (t === Ee) {
    for (var r = [], a = 0, s = i.length; a < s; a++)
      r.push(i[a].slice());
    return r;
  } else if (t === Ii) {
    for (var r = [], a = 0, s = i.length; a < s; a++)
      r.push(Y({}, i[a]));
    return r;
  }
}
function B5(e, t, i) {
  if (i != null) {
    if (Zt(i) || !isNaN(i) && !Zi(t, i))
      return e[i];
    if (Zi(t, i))
      return t[i];
  }
}
function $5(e) {
  return pt(e);
}
var Xx = ht();
function z5(e) {
  e = pt(e);
  var t = e.type, i = "";
  t || (process.env.NODE_ENV !== "production" && (i = "Must have a `type` when `registerTransform`."), We(i));
  var n = t.split(":");
  n.length !== 2 && (process.env.NODE_ENV !== "production" && (i = 'Name must include namespace like "ns:regression".'), We(i));
  var r = !1;
  n[0] === "echarts" && (t = n[1], r = !0), e.__isBuiltIn = r, Xx.set(t, e);
}
function V5(e, t, i) {
  var n = Ie(e), r = n.length, a = "";
  r || (process.env.NODE_ENV !== "production" && (a = "If `transform` declared, it should at least contain one transform."), We(a));
  for (var s = 0, o = r; s < o; s++) {
    var l = n[s];
    t = H5(l, t, i, r === 1 ? null : s), s !== o - 1 && (t.length = Math.max(t.length, 1));
  }
  return t;
}
function H5(e, t, i, n) {
  var r = "";
  t.length || (process.env.NODE_ENV !== "production" && (r = "Must have at least one upstream dataset."), We(r)), tt(e) || (process.env.NODE_ENV !== "production" && (r = "transform declaration must be an object rather than " + typeof e + "."), We(r));
  var a = e.type, s = Xx.get(a);
  s || (process.env.NODE_ENV !== "production" && (r = 'Can not find transform on type "' + a + '".'), We(r));
  var o = _t(t, function(c) {
    return R5(c, s);
  }), l = Ie(s.transform({
    upstream: o[0],
    upstreamList: o,
    config: pt(e.config)
  }));
  if (process.env.NODE_ENV !== "production" && e.print) {
    var u = _t(l, function(c) {
      var h = n != null ? " === pipe index: " + n : "";
      return ["=== dataset index: " + i.datasetIndex + h + " ===", "- transform result data:", $u(c.data), "- transform result dimensions:", $u(c.dimensions)].join(`
`);
    }).join(`
`);
    PL(u);
  }
  return _t(l, function(c, h) {
    var d = "";
    tt(c) || (process.env.NODE_ENV !== "production" && (d = "A transform should not return some empty results."), We(d)), c.data || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be not be null or undefined"), We(d));
    var f = Vx(c.data);
    lp(f) || (process.env.NODE_ENV !== "production" && (d = "Transform result data should be array rows or object rows."), We(d));
    var v, m = t[0];
    if (m && h === 0 && !c.dimensions) {
      var p = m.startIndex;
      p && (c.data = m.data.slice(0, p).concat(c.data)), v = {
        seriesLayoutBy: tn,
        sourceHeader: p,
        dimensions: m.metaRawOption.dimensions
      };
    } else
      v = {
        seriesLayoutBy: tn,
        sourceHeader: 0,
        dimensions: c.dimensions
      };
    return Tf(c.data, v, null);
  });
}
function lp(e) {
  return e === Ee || e === Ii;
}
var zc = "undefined", Y5 = typeof Uint32Array === zc ? Array : Uint32Array, W5 = typeof Uint16Array === zc ? Array : Uint16Array, jx = typeof Int32Array === zc ? Array : Int32Array, _y = typeof Float64Array === zc ? Array : Float64Array, qx = {
  float: _y,
  int: jx,
  // Ordinal data type can be string or int
  ordinal: Array,
  number: Array,
  time: _y
}, hd;
function Ea(e) {
  return e > 65535 ? Y5 : W5;
}
function Aa() {
  return [1 / 0, -1 / 0];
}
function U5(e) {
  var t = e.constructor;
  return t === Array ? e.slice() : new t(e);
}
function by(e, t, i, n, r) {
  var a = qx[i || "float"];
  if (r) {
    var s = e[t], o = s && s.length;
    if (o !== n) {
      for (var l = new a(n), u = 0; u < o; u++)
        l[u] = s[u];
      e[t] = l;
    }
  } else
    e[t] = new a(n);
}
var Cf = (
  /** @class */
  (function() {
    function e() {
      this._chunks = [], this._rawExtent = [], this._extent = [], this._count = 0, this._rawCount = 0, this._calcDimNameToIdx = ht();
    }
    return e.prototype.initData = function(t, i, n) {
      process.env.NODE_ENV !== "production" && nt(mt(t.getItem) && mt(t.count), "Invalid data provider."), this._provider = t, this._chunks = [], this._indices = null, this.getRawIndex = this._getRawIdxIdentity;
      var r = t.getSource(), a = this.defaultDimValueGetter = hd[r.sourceFormat];
      this._dimValueGetter = n || a, this._rawExtent = [];
      var s = Hx(r);
      this._dimensions = _t(i, function(o) {
        return process.env.NODE_ENV !== "production" && s && nt(o.property != null), {
          // Only pick these two props. Not leak other properties like orderMeta.
          type: o.type,
          property: o.property
        };
      }), this._initDataFromProvider(0, t.count());
    }, e.prototype.getProvider = function() {
      return this._provider;
    }, e.prototype.getSource = function() {
      return this._provider.getSource();
    }, e.prototype.ensureCalculationDimension = function(t, i) {
      var n = this._calcDimNameToIdx, r = this._dimensions, a = n.get(t);
      if (a != null) {
        if (r[a].type === i)
          return a;
      } else
        a = r.length;
      return r[a] = {
        type: i
      }, n.set(t, a), this._chunks[a] = new qx[i || "float"](this._rawCount), this._rawExtent[a] = Aa(), a;
    }, e.prototype.collectOrdinalMeta = function(t, i) {
      var n = this._chunks[t], r = this._dimensions[t], a = this._rawExtent, s = r.ordinalOffset || 0, o = n.length;
      s === 0 && (a[t] = Aa());
      for (var l = a[t], u = s; u < o; u++) {
        var c = n[u] = i.parseAndCollect(n[u]);
        isNaN(c) || (l[0] = Math.min(c, l[0]), l[1] = Math.max(c, l[1]));
      }
      r.ordinalMeta = i, r.ordinalOffset = o, r.type = "ordinal";
    }, e.prototype.getOrdinalMeta = function(t) {
      var i = this._dimensions[t], n = i.ordinalMeta;
      return n;
    }, e.prototype.getDimensionProperty = function(t) {
      var i = this._dimensions[t];
      return i && i.property;
    }, e.prototype.appendData = function(t) {
      process.env.NODE_ENV !== "production" && nt(!this._indices, "appendData can only be called on raw data.");
      var i = this._provider, n = this.count();
      i.appendData(t);
      var r = i.count();
      return i.persistent || (r += n), n < r && this._initDataFromProvider(n, r, !0), [n, r];
    }, e.prototype.appendValues = function(t, i) {
      for (var n = this._chunks, r = this._dimensions, a = r.length, s = this._rawExtent, o = this.count(), l = o + Math.max(t.length, i || 0), u = 0; u < a; u++) {
        var c = r[u];
        by(n, u, c.type, l, !0);
      }
      for (var h = [], d = o; d < l; d++)
        for (var f = d - o, v = 0; v < a; v++) {
          var c = r[v], m = hd.arrayRows.call(this, t[f] || h, c.property, f, v);
          n[v][d] = m;
          var p = s[v];
          m < p[0] && (p[0] = m), m > p[1] && (p[1] = m);
        }
      return this._rawCount = this._count = l, {
        start: o,
        end: l
      };
    }, e.prototype._initDataFromProvider = function(t, i, n) {
      for (var r = this._provider, a = this._chunks, s = this._dimensions, o = s.length, l = this._rawExtent, u = _t(s, function(y) {
        return y.property;
      }), c = 0; c < o; c++) {
        var h = s[c];
        l[c] || (l[c] = Aa()), by(a, c, h.type, i, n);
      }
      if (r.fillStorage)
        r.fillStorage(t, i, a, l);
      else
        for (var d = [], f = t; f < i; f++) {
          d = r.getItem(f, d);
          for (var v = 0; v < o; v++) {
            var m = a[v], p = this._dimValueGetter(d, u[v], f, v);
            m[f] = p;
            var g = l[v];
            p < g[0] && (g[0] = p), p > g[1] && (g[1] = p);
          }
        }
      !r.persistent && r.clean && r.clean(), this._rawCount = this._count = i, this._extent = [];
    }, e.prototype.count = function() {
      return this._count;
    }, e.prototype.get = function(t, i) {
      if (!(i >= 0 && i < this._count))
        return NaN;
      var n = this._chunks[t];
      return n ? n[this.getRawIndex(i)] : NaN;
    }, e.prototype.getValues = function(t, i) {
      var n = [], r = [];
      if (i == null) {
        i = t, t = [];
        for (var a = 0; a < this._dimensions.length; a++)
          r.push(a);
      } else
        r = t;
      for (var a = 0, s = r.length; a < s; a++)
        n.push(this.get(r[a], i));
      return n;
    }, e.prototype.getByRawIndex = function(t, i) {
      if (!(i >= 0 && i < this._rawCount))
        return NaN;
      var n = this._chunks[t];
      return n ? n[i] : NaN;
    }, e.prototype.getSum = function(t) {
      var i = this._chunks[t], n = 0;
      if (i)
        for (var r = 0, a = this.count(); r < a; r++) {
          var s = this.get(t, r);
          isNaN(s) || (n += s);
        }
      return n;
    }, e.prototype.getMedian = function(t) {
      var i = [];
      this.each([t], function(a) {
        isNaN(a) || i.push(a);
      });
      var n = i.sort(function(a, s) {
        return a - s;
      }), r = this.count();
      return r === 0 ? 0 : r % 2 === 1 ? n[(r - 1) / 2] : (n[r / 2] + n[r / 2 - 1]) / 2;
    }, e.prototype.indexOfRawIndex = function(t) {
      if (t >= this._rawCount || t < 0)
        return -1;
      if (!this._indices)
        return t;
      var i = this._indices, n = i[t];
      if (n != null && n < this._count && n === t)
        return t;
      for (var r = 0, a = this._count - 1; r <= a; ) {
        var s = (r + a) / 2 | 0;
        if (i[s] < t)
          r = s + 1;
        else if (i[s] > t)
          a = s - 1;
        else
          return s;
      }
      return -1;
    }, e.prototype.getIndices = function() {
      var t, i = this._indices;
      if (i) {
        var n = i.constructor, r = this._count;
        if (n === Array) {
          t = new n(r);
          for (var a = 0; a < r; a++)
            t[a] = i[a];
        } else
          t = new n(i.buffer, 0, r);
      } else {
        var n = Ea(this._rawCount);
        t = new n(this.count());
        for (var a = 0; a < t.length; a++)
          t[a] = a;
      }
      return t;
    }, e.prototype.filter = function(t, i) {
      if (!this._count)
        return this;
      for (var n = this.clone(), r = n.count(), a = Ea(n._rawCount), s = new a(r), o = [], l = t.length, u = 0, c = t[0], h = n._chunks, d = 0; d < r; d++) {
        var f = void 0, v = n.getRawIndex(d);
        if (l === 0)
          f = i(d);
        else if (l === 1) {
          var m = h[c][v];
          f = i(m, d);
        } else {
          for (var p = 0; p < l; p++)
            o[p] = h[t[p]][v];
          o[p] = d, f = i.apply(null, o);
        }
        f && (s[u++] = v);
      }
      return u < r && (n._indices = s), n._count = u, n._extent = [], n._updateGetRawIdx(), n;
    }, e.prototype.selectRange = function(t) {
      var i = this.clone(), n = i._count;
      if (!n)
        return this;
      var r = qt(t), a = r.length;
      if (!a)
        return this;
      var s = i.count(), o = Ea(i._rawCount), l = new o(s), u = 0, c = r[0], h = t[c][0], d = t[c][1], f = i._chunks, v = !1;
      if (!i._indices) {
        var m = 0;
        if (a === 1) {
          for (var p = f[r[0]], g = 0; g < n; g++) {
            var y = p[g];
            (y >= h && y <= d || isNaN(y)) && (l[u++] = m), m++;
          }
          v = !0;
        } else if (a === 2) {
          for (var p = f[r[0]], _ = f[r[1]], b = t[r[1]][0], w = t[r[1]][1], g = 0; g < n; g++) {
            var y = p[g], S = _[g];
            (y >= h && y <= d || isNaN(y)) && (S >= b && S <= w || isNaN(S)) && (l[u++] = m), m++;
          }
          v = !0;
        }
      }
      if (!v)
        if (a === 1)
          for (var g = 0; g < s; g++) {
            var M = i.getRawIndex(g), y = f[r[0]][M];
            (y >= h && y <= d || isNaN(y)) && (l[u++] = M);
          }
        else
          for (var g = 0; g < s; g++) {
            for (var k = !0, M = i.getRawIndex(g), T = 0; T < a; T++) {
              var D = r[T], y = f[D][M];
              (y < t[D][0] || y > t[D][1]) && (k = !1);
            }
            k && (l[u++] = i.getRawIndex(g));
          }
      return u < s && (i._indices = l), i._count = u, i._extent = [], i._updateGetRawIdx(), i;
    }, e.prototype.map = function(t, i) {
      var n = this.clone(t);
      return this._updateDims(n, t, i), n;
    }, e.prototype.modify = function(t, i) {
      this._updateDims(this, t, i);
    }, e.prototype._updateDims = function(t, i, n) {
      for (var r = t._chunks, a = [], s = i.length, o = t.count(), l = [], u = t._rawExtent, c = 0; c < i.length; c++)
        u[i[c]] = Aa();
      for (var h = 0; h < o; h++) {
        for (var d = t.getRawIndex(h), f = 0; f < s; f++)
          l[f] = r[i[f]][d];
        l[s] = h;
        var v = n && n.apply(null, l);
        if (v != null) {
          typeof v != "object" && (a[0] = v, v = a);
          for (var c = 0; c < v.length; c++) {
            var m = i[c], p = v[c], g = u[m], y = r[m];
            y && (y[d] = p), p < g[0] && (g[0] = p), p > g[1] && (g[1] = p);
          }
        }
      }
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = this.clone([t], !0), r = n._chunks, a = r[t], s = this.count(), o = 0, l = Math.floor(1 / i), u = this.getRawIndex(0), c, h, d, f = new (Ea(this._rawCount))(Math.min((Math.ceil(s / l) + 2) * 2, s));
      f[o++] = u;
      for (var v = 1; v < s - 1; v += l) {
        for (var m = Math.min(v + l, s - 1), p = Math.min(v + l * 2, s), g = (p + m) / 2, y = 0, _ = m; _ < p; _++) {
          var b = this.getRawIndex(_), w = a[b];
          isNaN(w) || (y += w);
        }
        y /= p - m;
        var S = v, M = Math.min(v + l, s), k = v - 1, T = a[u];
        c = -1, d = S;
        for (var D = -1, C = 0, _ = S; _ < M; _++) {
          var b = this.getRawIndex(_), w = a[b];
          if (isNaN(w)) {
            C++, D < 0 && (D = b);
            continue;
          }
          h = Math.abs((k - g) * (w - T) - (k - _) * (y - T)), h > c && (c = h, d = b);
        }
        C > 0 && C < M - S && (f[o++] = Math.min(D, d), d = Math.max(D, d)), f[o++] = d, u = d;
      }
      return f[o++] = this.getRawIndex(s - 1), n._count = o, n._indices = f, n.getRawIndex = this._getRawIdx, n;
    }, e.prototype.minmaxDownSample = function(t, i) {
      for (var n = this.clone([t], !0), r = n._chunks, a = Math.floor(1 / i), s = r[t], o = this.count(), l = new (Ea(this._rawCount))(Math.ceil(o / a) * 2), u = 0, c = 0; c < o; c += a) {
        var h = c, d = s[this.getRawIndex(h)], f = c, v = s[this.getRawIndex(f)], m = a;
        c + a > o && (m = o - c);
        for (var p = 0; p < m; p++) {
          var g = this.getRawIndex(c + p), y = s[g];
          y < d && (d = y, h = c + p), y > v && (v = y, f = c + p);
        }
        var _ = this.getRawIndex(h), b = this.getRawIndex(f);
        h < f ? (l[u++] = _, l[u++] = b) : (l[u++] = b, l[u++] = _);
      }
      return n._count = u, n._indices = l, n._updateGetRawIdx(), n;
    }, e.prototype.downSample = function(t, i, n, r) {
      for (var a = this.clone([t], !0), s = a._chunks, o = [], l = Math.floor(1 / i), u = s[t], c = this.count(), h = a._rawExtent[t] = Aa(), d = new (Ea(this._rawCount))(Math.ceil(c / l)), f = 0, v = 0; v < c; v += l) {
        l > c - v && (l = c - v, o.length = l);
        for (var m = 0; m < l; m++) {
          var p = this.getRawIndex(v + m);
          o[m] = u[p];
        }
        var g = n(o), y = this.getRawIndex(Math.min(v + r(o, g) || 0, c - 1));
        u[y] = g, g < h[0] && (h[0] = g), g > h[1] && (h[1] = g), d[f++] = y;
      }
      return a._count = f, a._indices = d, a._updateGetRawIdx(), a;
    }, e.prototype.each = function(t, i) {
      if (this._count)
        for (var n = t.length, r = this._chunks, a = 0, s = this.count(); a < s; a++) {
          var o = this.getRawIndex(a);
          switch (n) {
            case 0:
              i(a);
              break;
            case 1:
              i(r[t[0]][o], a);
              break;
            case 2:
              i(r[t[0]][o], r[t[1]][o], a);
              break;
            default:
              for (var l = 0, u = []; l < n; l++)
                u[l] = r[t[l]][o];
              u[l] = a, i.apply(null, u);
          }
        }
    }, e.prototype.getDataExtent = function(t) {
      var i = this._chunks[t], n = Aa();
      if (!i)
        return n;
      var r = this.count(), a = !this._indices, s;
      if (a)
        return this._rawExtent[t].slice();
      if (s = this._extent[t], s)
        return s.slice();
      s = n;
      for (var o = s[0], l = s[1], u = 0; u < r; u++) {
        var c = this.getRawIndex(u), h = i[c];
        h < o && (o = h), h > l && (l = h);
      }
      return s = [o, l], this._extent[t] = s, s;
    }, e.prototype.getRawDataItem = function(t) {
      var i = this.getRawIndex(t);
      if (this._provider.persistent)
        return this._provider.getItem(i);
      for (var n = [], r = this._chunks, a = 0; a < r.length; a++)
        n.push(r[a][i]);
      return n;
    }, e.prototype.clone = function(t, i) {
      var n = new e(), r = this._chunks, a = t && ps(t, function(o, l) {
        return o[l] = !0, o;
      }, {});
      if (a)
        for (var s = 0; s < r.length; s++)
          n._chunks[s] = a[s] ? U5(r[s]) : r[s];
      else
        n._chunks = r;
      return this._copyCommonProps(n), i || (n._indices = this._cloneIndices()), n._updateGetRawIdx(), n;
    }, e.prototype._copyCommonProps = function(t) {
      t._count = this._count, t._rawCount = this._rawCount, t._provider = this._provider, t._dimensions = this._dimensions, t._extent = pt(this._extent), t._rawExtent = pt(this._rawExtent);
    }, e.prototype._cloneIndices = function() {
      if (this._indices) {
        var t = this._indices.constructor, i = void 0;
        if (t === Array) {
          var n = this._indices.length;
          i = new t(n);
          for (var r = 0; r < n; r++)
            i[r] = this._indices[r];
        } else
          i = new t(this._indices);
        return i;
      }
      return null;
    }, e.prototype._getRawIdxIdentity = function(t) {
      return t;
    }, e.prototype._getRawIdx = function(t) {
      return t < this._count && t >= 0 ? this._indices[t] : -1;
    }, e.prototype._updateGetRawIdx = function() {
      this.getRawIndex = this._indices ? this._getRawIdx : this._getRawIdxIdentity;
    }, e.internalField = (function() {
      function t(i, n, r, a) {
        return du(i[a], this._dimensions[a]);
      }
      hd = {
        arrayRows: t,
        objectRows: function(i, n, r, a) {
          return du(i[n], this._dimensions[a]);
        },
        keyedColumns: t,
        original: function(i, n, r, a) {
          var s = i && (i.value == null ? i : i.value);
          return du(s instanceof Array ? s[a] : s, this._dimensions[a]);
        },
        typedArray: function(i, n, r, a) {
          return i[a];
        }
      };
    })(), e;
  })()
), G5 = (
  /** @class */
  (function() {
    function e(t) {
      this._sourceList = [], this._storeList = [], this._upstreamSignList = [], this._versionSignBase = 0, this._dirty = !0, this._sourceHost = t;
    }
    return e.prototype.dirty = function() {
      this._setLocalSource([], []), this._storeList = [], this._dirty = !0;
    }, e.prototype._setLocalSource = function(t, i) {
      this._sourceList = t, this._upstreamSignList = i, this._versionSignBase++, this._versionSignBase > 9e10 && (this._versionSignBase = 0);
    }, e.prototype._getVersionSign = function() {
      return this._sourceHost.uid + "_" + this._versionSignBase;
    }, e.prototype.prepareSource = function() {
      this._isDirty() && (this._createSource(), this._dirty = !1);
    }, e.prototype._createSource = function() {
      this._setLocalSource([], []);
      var t = this._sourceHost, i = this._getUpstreamSourceManagers(), n = !!i.length, r, a;
      if (Is(t)) {
        var s = t, o = void 0, l = void 0, u = void 0;
        if (n) {
          var c = i[0];
          c.prepareSource(), u = c.getSource(), o = u.data, l = u.sourceFormat, a = [c._getVersionSign()];
        } else
          o = s.get("data", !0), l = Ne(o) ? Mn : ti, a = [];
        var h = this._getSourceMetaRawOption() || {}, d = u && u.metaRawOption || {}, f = rt(h.seriesLayoutBy, d.seriesLayoutBy) || null, v = rt(h.sourceHeader, d.sourceHeader), m = rt(h.dimensions, d.dimensions), p = f !== d.seriesLayoutBy || !!v != !!d.sourceHeader || m;
        r = p ? [Tf(o, {
          seriesLayoutBy: f,
          sourceHeader: v,
          dimensions: m
        }, l)] : [];
      } else {
        var g = t;
        if (n) {
          var y = this._applyTransform(i);
          r = y.sourceList, a = y.upstreamSignList;
        } else {
          var _ = g.get("source", !0);
          r = [Tf(_, this._getSourceMetaRawOption(), null)], a = [];
        }
      }
      process.env.NODE_ENV !== "production" && nt(r && a), this._setLocalSource(r, a);
    }, e.prototype._applyTransform = function(t) {
      var i = this._sourceHost, n = i.get("transform", !0), r = i.get("fromTransformResult", !0);
      if (process.env.NODE_ENV !== "production" && nt(r != null || n != null), r != null) {
        var a = "";
        t.length !== 1 && (process.env.NODE_ENV !== "production" && (a = "When using `fromTransformResult`, there should be only one upstream dataset"), xy(a));
      }
      var s, o = [], l = [];
      return E(t, function(u) {
        u.prepareSource();
        var c = u.getSource(r || 0), h = "";
        r != null && !c && (process.env.NODE_ENV !== "production" && (h = "Can not retrieve result by `fromTransformResult`: " + r), xy(h)), o.push(c), l.push(u._getVersionSign());
      }), n ? s = V5(n, o, {
        datasetIndex: i.componentIndex
      }) : r != null && (s = [S5(o[0])]), {
        sourceList: s,
        upstreamSignList: l
      };
    }, e.prototype._isDirty = function() {
      if (this._dirty)
        return !0;
      for (var t = this._getUpstreamSourceManagers(), i = 0; i < t.length; i++) {
        var n = t[i];
        if (
          // Consider the case that there is ancestor diry, call it recursively.
          // The performance is probably not an issue because usually the chain is not long.
          n._isDirty() || this._upstreamSignList[i] !== n._getVersionSign()
        )
          return !0;
      }
    }, e.prototype.getSource = function(t) {
      t = t || 0;
      var i = this._sourceList[t];
      if (!i) {
        var n = this._getUpstreamSourceManagers();
        return n[0] && n[0].getSource(t);
      }
      return i;
    }, e.prototype.getSharedDataStore = function(t) {
      process.env.NODE_ENV !== "production" && nt(Is(this._sourceHost), "Can only call getDataStore on series source manager.");
      var i = t.makeStoreSchema();
      return this._innerGetDataStore(i.dimensions, t.source, i.hash);
    }, e.prototype._innerGetDataStore = function(t, i, n) {
      var r = 0, a = this._storeList, s = a[r];
      s || (s = a[r] = {});
      var o = s[n];
      if (!o) {
        var l = this._getUpstreamSourceManagers()[0];
        Is(this._sourceHost) && l ? o = l._innerGetDataStore(t, i, n) : (o = new Cf(), o.initData(new Yx(i, t.length), t)), s[n] = o;
      }
      return o;
    }, e.prototype._getUpstreamSourceManagers = function() {
      var t = this._sourceHost;
      if (Is(t)) {
        var i = Nx(t);
        return i ? [i.getSourceManager()] : [];
      } else
        return _t(qR(t), function(n) {
          return n.getSourceManager();
        });
    }, e.prototype._getSourceMetaRawOption = function() {
      var t = this._sourceHost, i, n, r;
      if (Is(t))
        i = t.get("seriesLayoutBy", !0), n = t.get("sourceHeader", !0), r = t.get("dimensions", !0);
      else if (!this._getUpstreamSourceManagers().length) {
        var a = t;
        i = a.get("seriesLayoutBy", !0), n = a.get("sourceHeader", !0), r = a.get("dimensions", !0);
      }
      return {
        seriesLayoutBy: i,
        sourceHeader: n,
        dimensions: r
      };
    }, e;
  })()
);
function Is(e) {
  return e.mainType === "series";
}
function xy(e) {
  throw new Error(e);
}
var X5 = "line-height:1";
function Zx(e) {
  var t = e.lineHeight;
  return t == null ? X5 : "line-height:" + Ve(t + "") + "px";
}
function Kx(e, t) {
  var i = e.color || St.color.tertiary, n = e.fontSize || 12, r = e.fontWeight || "400", a = e.color || St.color.secondary, s = e.fontSize || 14, o = e.fontWeight || "900";
  return t === "html" ? {
    // eslint-disable-next-line max-len
    nameStyle: "font-size:" + Ve(n + "") + "px;color:" + Ve(i) + ";font-weight:" + Ve(r + ""),
    // eslint-disable-next-line max-len
    valueStyle: "font-size:" + Ve(s + "") + "px;color:" + Ve(a) + ";font-weight:" + Ve(o + "")
  } : {
    nameStyle: {
      fontSize: n,
      fill: i,
      fontWeight: r
    },
    valueStyle: {
      fontSize: s,
      fill: a,
      fontWeight: o
    }
  };
}
var j5 = [0, 10, 20, 30], q5 = ["", `
`, `

`, `


`];
function ua(e, t) {
  return t.type = e, t;
}
function Ef(e) {
  return e.type === "section";
}
function Qx(e) {
  return Ef(e) ? Z5 : K5;
}
function Jx(e) {
  if (Ef(e)) {
    var t = 0, i = e.blocks.length, n = i > 1 || i > 0 && !e.noHeader;
    return E(e.blocks, function(r) {
      var a = Jx(r);
      a >= t && (t = a + +(n && // 0 always can not be readable gap level.
      (!a || Ef(r) && !r.noHeader)));
    }), t;
  }
  return 0;
}
function Z5(e, t, i, n) {
  var r = t.noHeader, a = Q5(Jx(t)), s = [], o = t.blocks || [];
  nt(!o || K(o)), o = o || [];
  var l = e.orderMode;
  if (t.sortBlocks && l) {
    o = o.slice();
    var u = {
      valueAsc: "asc",
      valueDesc: "desc"
    };
    if (Zi(u, l)) {
      var c = new O5(u[l], null);
      o.sort(function(m, p) {
        return c.evaluate(m.sortParam, p.sortParam);
      });
    } else l === "seriesDesc" && o.reverse();
  }
  E(o, function(m, p) {
    var g = t.valueFormatter, y = Qx(m)(
      // Inherit valueFormatter
      g ? Y(Y({}, e), {
        valueFormatter: g
      }) : e,
      m,
      p > 0 ? a.html : 0,
      n
    );
    y != null && s.push(y);
  });
  var h = e.renderMode === "richText" ? s.join(a.richText) : Af(n, s.join(""), r ? i : a.html);
  if (r)
    return h;
  var d = kf(t.header, "ordinal", e.useUTC), f = Kx(n, e.renderMode).nameStyle, v = Zx(n);
  return e.renderMode === "richText" ? tw(e, d, f) + a.richText + h : Af(n, '<div style="' + f + ";" + v + ';">' + Ve(d) + "</div>" + h, i);
}
function K5(e, t, i, n) {
  var r = e.renderMode, a = t.noName, s = t.noValue, o = !t.markerType, l = t.name, u = e.useUTC, c = t.valueFormatter || e.valueFormatter || function(b) {
    return b = K(b) ? b : [b], _t(b, function(w, S) {
      return kf(w, K(f) ? f[S] : f, u);
    });
  };
  if (!(a && s)) {
    var h = o ? "" : e.markupStyleCreator.makeTooltipMarker(t.markerType, t.markerColor || St.color.secondary, r), d = a ? "" : kf(l, "ordinal", u), f = t.valueType, v = s ? [] : c(t.value, t.dataIndex), m = !o || !a, p = !o && a, g = Kx(n, r), y = g.nameStyle, _ = g.valueStyle;
    return r === "richText" ? (o ? "" : h) + (a ? "" : tw(e, d, y)) + (s ? "" : eN(e, v, m, p, _)) : Af(n, (o ? "" : h) + (a ? "" : J5(d, !o, y)) + (s ? "" : tN(v, m, p, _)), i);
  }
}
function wy(e, t, i, n, r, a) {
  if (e) {
    var s = Qx(e), o = {
      useUTC: r,
      renderMode: i,
      orderMode: n,
      markupStyleCreator: t,
      valueFormatter: e.valueFormatter
    };
    return s(o, e, 0, a);
  }
}
function Q5(e) {
  return {
    html: j5[e],
    richText: q5[e]
  };
}
function Af(e, t, i) {
  var n = '<div style="clear:both"></div>', r = "margin: " + i + "px 0 0", a = Zx(e);
  return '<div style="' + r + ";" + a + ';">' + t + n + "</div>";
}
function J5(e, t, i) {
  var n = t ? "margin-left:2px" : "";
  return '<span style="' + i + ";" + n + '">' + Ve(e) + "</span>";
}
function tN(e, t, i, n) {
  var r = i ? "10px" : "20px", a = t ? "float:right;margin-left:" + r : "";
  return e = K(e) ? e : [e], '<span style="' + a + ";" + n + '">' + _t(e, function(s) {
    return Ve(s);
  }).join("&nbsp;&nbsp;") + "</span>";
}
function tw(e, t, i) {
  return e.markupStyleCreator.wrapRichTextStyle(t, i);
}
function eN(e, t, i, n, r) {
  var a = [r], s = n ? 10 : 20;
  return i && a.push({
    padding: [0, 0, 0, s],
    align: "right"
  }), e.markupStyleCreator.wrapRichTextStyle(K(t) ? t.join("  ") : t, a);
}
function iN(e, t) {
  var i = e.getData().getItemVisual(t, "style"), n = i[e.visualDrawType];
  return Bo(n);
}
function ew(e, t) {
  var i = e.get("padding");
  return i ?? (t === "richText" ? [8, 10] : 10);
}
var dd = (
  /** @class */
  (function() {
    function e() {
      this.richTextStyles = {}, this._nextStyleNameId = E1();
    }
    return e.prototype._generateStyleName = function() {
      return "__EC_aUTo_" + this._nextStyleNameId++;
    }, e.prototype.makeTooltipMarker = function(t, i, n) {
      var r = n === "richText" ? this._generateStyleName() : null, a = FR({
        color: i,
        type: t,
        renderMode: n,
        markerId: r
      });
      return et(a) ? a : (process.env.NODE_ENV !== "production" && nt(r), this.richTextStyles[r] = a.style, a.content);
    }, e.prototype.wrapRichTextStyle = function(t, i) {
      var n = {};
      K(i) ? E(i, function(a) {
        return Y(n, a);
      }) : Y(n, i);
      var r = this._generateStyleName();
      return this.richTextStyles[r] = n, "{" + r + "|" + t + "}";
    }, e;
  })()
);
function nN(e) {
  var t = e.series, i = e.dataIndex, n = e.multipleSeries, r = t.getData(), a = r.mapDimensionsAll("defaultedTooltip"), s = a.length, o = t.getRawValue(i), l = K(o), u = iN(t, i), c, h, d, f;
  if (s > 1 || l && !s) {
    var v = rN(o, t, i, a, u);
    c = v.inlineValues, h = v.inlineValueTypes, d = v.blocks, f = v.inlineValues[0];
  } else if (s) {
    var m = r.getDimensionInfo(a[0]);
    f = c = Zu(r, i, a[0]), h = m.type;
  } else
    f = c = l ? o[0] : o;
  var p = O1(t), g = p && t.name || "", y = r.getName(i), _ = n ? g : y;
  return ua("section", {
    header: g,
    // When series name is not specified, do not show a header line with only '-'.
    // This case always happens in tooltip.trigger: 'item'.
    noHeader: n || !p,
    sortParam: f,
    blocks: [ua("nameValue", {
      markerType: "item",
      markerColor: u,
      // Do not mix display seriesName and itemName in one tooltip,
      // which might confuses users.
      name: _,
      // name dimension might be auto assigned, where the name might
      // be not readable. So we check trim here.
      noName: !Xi(_),
      value: c,
      valueType: h,
      dataIndex: i
    })].concat(d || [])
  });
}
function rN(e, t, i, n, r) {
  var a = t.getData(), s = ps(e, function(h, d, f) {
    var v = a.getDimensionInfo(f);
    return h = h || v && v.tooltip !== !1 && v.displayName != null;
  }, !1), o = [], l = [], u = [];
  n.length ? E(n, function(h) {
    c(Zu(a, i, h), h);
  }) : E(e, c);
  function c(h, d) {
    var f = a.getDimensionInfo(d);
    !f || f.otherDims.tooltip === !1 || (s ? u.push(ua("nameValue", {
      markerType: "subItem",
      markerColor: r,
      name: f.displayName,
      value: h,
      valueType: f.type
    })) : (o.push(h), l.push(f.type)));
  }
  return {
    inlineValues: o,
    inlineValueTypes: l,
    blocks: u
  };
}
var Bn = Gt();
function Vl(e, t) {
  return e.getName(t) || e.getId(t);
}
var aN = "__universalTransitionEnabled", sr = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i._selectedDataIndicesMap = {}, i;
    }
    return t.prototype.init = function(i, n, r) {
      this.seriesIndex = this.componentIndex, this.dataTask = bo({
        count: oN,
        reset: lN
      }), this.dataTask.context = {
        model: this
      }, this.mergeDefaultAndTheme(i, r);
      var a = Bn(this).sourceManager = new G5(this);
      a.prepareSource();
      var s = this.getInitialData(i, r);
      My(s, this), this.dataTask.context.data = s, process.env.NODE_ENV !== "production" && nt(s, "getInitialData returned invalid data."), Bn(this).dataBeforeProcessed = s, Sy(this), this._initSelectedMapFromData(s);
    }, t.prototype.mergeDefaultAndTheme = function(i, n) {
      var r = Gu(this), a = r ? Px(i) : {}, s = this.subType;
      Pt.hasClass(s) && (s += "Series"), se(i, n.getTheme().get(this.subType)), se(i, this.getDefaultOption()), Jm(i, "label", ["show"]), this.fillDataTextStyle(i.data), r && Xu(i, a, r);
    }, t.prototype.mergeOption = function(i, n) {
      i = se(this.option, i, !0), this.fillDataTextStyle(i.data);
      var r = Gu(this);
      r && Xu(this.option, i, r);
      var a = Bn(this).sourceManager;
      a.dirty(), a.prepareSource();
      var s = this.getInitialData(i, n);
      My(s, this), this.dataTask.dirty(), this.dataTask.context.data = s, Bn(this).dataBeforeProcessed = s, Sy(this), this._initSelectedMapFromData(s);
    }, t.prototype.fillDataTextStyle = function(i) {
      if (i && !Ne(i))
        for (var n = ["show"], r = 0; r < i.length; r++)
          i[r] && i[r].label && Jm(i[r], "label", n);
    }, t.prototype.getInitialData = function(i, n) {
    }, t.prototype.appendData = function(i) {
      var n = this.getRawData();
      n.appendData(i.data);
    }, t.prototype.getData = function(i) {
      var n = Pf(this);
      if (n) {
        var r = n.context.data;
        return i == null || !r.getLinkedData ? r : r.getLinkedData(i);
      } else
        return Bn(this).data;
    }, t.prototype.getAllData = function() {
      var i = this.getData();
      return i && i.getLinkedDataAll ? i.getLinkedDataAll() : [{
        data: i
      }];
    }, t.prototype.setData = function(i) {
      var n = Pf(this);
      if (n) {
        var r = n.context;
        r.outputData = i, n !== this.dataTask && (r.data = i);
      }
      Bn(this).data = i;
    }, t.prototype.getEncode = function() {
      var i = this.get("encode", !0);
      if (i)
        return ht(i);
    }, t.prototype.getSourceManager = function() {
      return Bn(this).sourceManager;
    }, t.prototype.getSource = function() {
      return this.getSourceManager().getSource();
    }, t.prototype.getRawData = function() {
      return Bn(this).dataBeforeProcessed;
    }, t.prototype.getColorBy = function() {
      var i = this.get("colorBy");
      return i || "series";
    }, t.prototype.isColorBySeries = function() {
      return this.getColorBy() === "series";
    }, t.prototype.getBaseAxis = function() {
      var i = this.coordinateSystem;
      return i && i.getBaseAxis && i.getBaseAxis();
    }, t.prototype.indicesOfNearest = function(i, n, r, a) {
      var s = this.getData(), o = this.coordinateSystem, l = o && o.getAxis(i);
      if (!o || !l)
        return [];
      var u = l.dataToCoord(r);
      a == null && (a = 1 / 0);
      var c = [], h = 1 / 0, d = -1, f = 0;
      return s.each(n, function(v, m) {
        var p = l.dataToCoord(v), g = u - p, y = Math.abs(g);
        y <= a && ((y < h || y === h && g >= 0 && d < 0) && (h = y, d = g, f = 0), g === d && (c[f++] = m));
      }), c.length = f, c;
    }, t.prototype.formatTooltip = function(i, n, r) {
      return nN({
        series: this,
        dataIndex: i,
        multipleSeries: n
      });
    }, t.prototype.isAnimationEnabled = function() {
      var i = this.ecModel;
      if (ot.node && !(i && i.ssr))
        return !1;
      var n = this.getShallow("animation");
      return n && this.getData().count() > this.getShallow("animationThreshold") && (n = !1), !!n;
    }, t.prototype.restoreData = function() {
      this.dataTask.dirty();
    }, t.prototype.getColorFromPalette = function(i, n, r) {
      var a = this.ecModel, s = rp.prototype.getColorFromPalette.call(this, i, n, r);
      return s || (s = a.getColorFromPalette(i, n, r)), s;
    }, t.prototype.coordDimToDataDim = function(i) {
      return this.getRawData().mapDimensionsAll(i);
    }, t.prototype.getProgressive = function() {
      return this.get("progressive");
    }, t.prototype.getProgressiveThreshold = function() {
      return this.get("progressiveThreshold");
    }, t.prototype.select = function(i, n) {
      this._innerSelect(this.getData(n), i);
    }, t.prototype.unselect = function(i, n) {
      var r = this.option.selectedMap;
      if (r) {
        var a = this.option.selectedMode, s = this.getData(n);
        if (a === "series" || r === "all") {
          this.option.selectedMap = {}, this._selectedDataIndicesMap = {};
          return;
        }
        for (var o = 0; o < i.length; o++) {
          var l = i[o], u = Vl(s, l);
          r[u] = !1, this._selectedDataIndicesMap[u] = -1;
        }
      }
    }, t.prototype.toggleSelect = function(i, n) {
      for (var r = [], a = 0; a < i.length; a++)
        r[0] = i[a], this.isSelected(i[a], n) ? this.unselect(r, n) : this.select(r, n);
    }, t.prototype.getSelectedDataIndices = function() {
      if (this.option.selectedMap === "all")
        return [].slice.call(this.getData().getIndices());
      for (var i = this._selectedDataIndicesMap, n = qt(i), r = [], a = 0; a < n.length; a++) {
        var s = i[n[a]];
        s >= 0 && r.push(s);
      }
      return r;
    }, t.prototype.isSelected = function(i, n) {
      var r = this.option.selectedMap;
      if (!r)
        return !1;
      var a = this.getData(n);
      return (r === "all" || r[Vl(a, i)]) && !a.getItemModel(i).get(["select", "disabled"]);
    }, t.prototype.isUniversalTransitionEnabled = function() {
      if (this[aN])
        return !0;
      var i = this.option.universalTransition;
      return i ? i === !0 ? !0 : i && i.enabled : !1;
    }, t.prototype._innerSelect = function(i, n) {
      var r, a, s = this.option, o = s.selectedMode, l = n.length;
      if (!(!o || !l)) {
        if (o === "series")
          s.selectedMap = "all";
        else if (o === "multiple") {
          tt(s.selectedMap) || (s.selectedMap = {});
          for (var u = s.selectedMap, c = 0; c < l; c++) {
            var h = n[c], d = Vl(i, h);
            u[d] = !0, this._selectedDataIndicesMap[d] = i.getRawIndex(h);
          }
        } else if (o === "single" || o === !0) {
          var f = n[l - 1], d = Vl(i, f);
          s.selectedMap = (r = {}, r[d] = !0, r), this._selectedDataIndicesMap = (a = {}, a[d] = i.getRawIndex(f), a);
        }
      }
    }, t.prototype._initSelectedMapFromData = function(i) {
      if (!this.option.selectedMap) {
        var n = [];
        i.hasItemOption && i.each(function(r) {
          var a = i.getRawDataItem(r);
          a && a.selected && n.push(r);
        }), n.length > 0 && this._innerSelect(i, n);
      }
    }, t.registerClass = function(i) {
      return Pt.registerClass(i);
    }, t.protoInitialize = (function() {
      var i = t.prototype;
      i.type = "series.__base__", i.seriesIndex = 0, i.ignoreStyleOnData = !1, i.hasSymbolVisual = !1, i.defaultSymbol = "circle", i.visualStyleAccessPath = "itemStyle", i.visualDrawType = "fill";
    })(), t;
  })(Pt)
);
Pi(sr, P5);
Pi(sr, rp);
N1(sr, Pt);
function Sy(e) {
  var t = e.name;
  O1(e) || (e.name = sN(e) || t);
}
function sN(e) {
  var t = e.getRawData(), i = t.mapDimensionsAll("seriesName"), n = [];
  return E(i, function(r) {
    var a = t.getDimensionInfo(r);
    a.displayName && n.push(a.displayName);
  }), n.join(" ");
}
function oN(e) {
  return e.model.getRawData().count();
}
function lN(e) {
  var t = e.model;
  return t.setData(t.getRawData().cloneShallow()), uN;
}
function uN(e, t) {
  t.outputData && e.end > t.outputData.count() && t.model.getRawData().cloneShallow(t.outputData);
}
function My(e, t) {
  E(JA(e.CHANGABLE_METHODS, e.DOWNSAMPLE_METHODS), function(i) {
    e.wrapMethod(i, Oe(cN, t));
  });
}
function cN(e, t) {
  var i = Pf(e);
  return i && i.setOutputEnd((t || this).count()), t;
}
function Pf(e) {
  var t = (e.ecModel || {}).scheduler, i = t && t.getPipeline(e.uid);
  if (i) {
    var n = i.currentTask;
    if (n) {
      var r = n.agentStubMap;
      r && (n = r.get(e.uid));
    }
    return n;
  }
}
var En = (
  /** @class */
  (function() {
    function e() {
      this.group = new Ci(), this.uid = Fc("viewComponent");
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
    }, e.prototype.updateLayout = function(t, i, n, r) {
    }, e.prototype.updateVisual = function(t, i, n, r) {
    }, e.prototype.toggleBlurSeries = function(t, i, n) {
    }, e.prototype.eachRendered = function(t) {
      var i = this.group;
      i && i.traverse(t);
    }, e;
  })()
);
Pv(En);
Lv(En);
function hN() {
  var e = Gt();
  return function(t) {
    var i = e(t), n = t.pipelineContext, r = !!i.large, a = !!i.progressiveRender, s = i.large = !!(n && n.large), o = i.progressiveRender = !!(n && n.progressiveRender);
    return (r !== s || a !== o) && "reset";
  };
}
var iw = Gt(), dN = hN(), Jn = (
  /** @class */
  (function() {
    function e() {
      this.group = new Ci(), this.uid = Fc("viewChart"), this.renderTask = bo({
        plan: fN,
        reset: vN
      }), this.renderTask.context = {
        view: this
      };
    }
    return e.prototype.init = function(t, i) {
    }, e.prototype.render = function(t, i, n, r) {
      if (process.env.NODE_ENV !== "production")
        throw new Error("render method must been implemented");
    }, e.prototype.highlight = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Kt("Unknown dataType " + r.dataType);
        return;
      }
      Dy(a, r, "emphasis");
    }, e.prototype.downplay = function(t, i, n, r) {
      var a = t.getData(r && r.dataType);
      if (!a) {
        process.env.NODE_ENV !== "production" && Kt("Unknown dataType " + r.dataType);
        return;
      }
      Dy(a, r, "normal");
    }, e.prototype.remove = function(t, i) {
      this.group.removeAll();
    }, e.prototype.dispose = function(t, i) {
    }, e.prototype.updateView = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateLayout = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.updateVisual = function(t, i, n, r) {
      this.render(t, i, n, r);
    }, e.prototype.eachRendered = function(t) {
      yx(this.group, t);
    }, e.markUpdateMethod = function(t, i) {
      iw(t).updateMethod = i;
    }, e.protoInitialize = (function() {
      var t = e.prototype;
      t.type = "chart";
    })(), e;
  })()
);
function ky(e, t, i) {
  e && hs(e) && (t === "emphasis" ? Yu : Wu)(e, i);
}
function Dy(e, t, i) {
  var n = Ko(e, t), r = t && t.highlightKey != null ? dI(t.highlightKey) : null;
  n != null ? E(Ie(n), function(a) {
    ky(e.getItemGraphicEl(a), i, r);
  }) : e.eachItemGraphicEl(function(a) {
    ky(a, i, r);
  });
}
Pv(Jn, ["dispose"]);
Lv(Jn);
function fN(e) {
  return dN(e.model);
}
function vN(e) {
  var t = e.model, i = e.ecModel, n = e.api, r = e.payload, a = t.pipelineContext.progressiveRender, s = e.view, o = r && iw(r).updateMethod, l = a ? "incrementalPrepareRender" : o && s[o] ? o : "render";
  return l !== "render" && s[l](t, i, n, r), pN[l];
}
var pN = {
  incrementalPrepareRender: {
    progress: function(e, t) {
      t.view.incrementalRender(e, t.model, t.ecModel, t.api, t.payload);
    }
  },
  render: {
    // Put view.render in `progress` to support appendData. But in this case
    // view.render should not be called in reset, otherwise it will be called
    // twise. Use `forceFirstProgress` to make sure that view.render is called
    // in any cases.
    forceFirstProgress: !0,
    progress: function(e, t) {
      t.view.render(t.model, t.ecModel, t.api, t.payload);
    }
  }
}, Ku = "\0__throttleOriginMethod", Ty = "\0__throttleRate", Cy = "\0__throttleType";
function nw(e, t, i) {
  var n, r = 0, a = 0, s = null, o, l, u, c;
  t = t || 0;
  function h() {
    a = (/* @__PURE__ */ new Date()).getTime(), s = null, e.apply(l, u || []);
  }
  var d = function() {
    for (var f = [], v = 0; v < arguments.length; v++)
      f[v] = arguments[v];
    n = (/* @__PURE__ */ new Date()).getTime(), l = this, u = f;
    var m = c || t, p = c || i;
    c = null, o = n - (p ? r : a) - m, clearTimeout(s), p ? s = setTimeout(h, m) : o >= 0 ? h() : s = setTimeout(h, -o), r = n;
  };
  return d.clear = function() {
    s && (clearTimeout(s), s = null);
  }, d.debounceNextCall = function(f) {
    c = f;
  }, d;
}
function rw(e, t, i, n) {
  var r = e[t];
  if (r) {
    var a = r[Ku] || r, s = r[Cy], o = r[Ty];
    if (o !== i || s !== n) {
      if (i == null || !n)
        return e[t] = a;
      r = e[t] = nw(a, i, n === "debounce"), r[Ku] = a, r[Cy] = n, r[Ty] = i;
    }
    return r;
  }
}
function Lf(e, t) {
  var i = e[t];
  i && i[Ku] && (i.clear && i.clear(), e[t] = i[Ku]);
}
var Ey = Gt(), Ay = {
  itemStyle: Ro(Sx, !0),
  lineStyle: Ro(xx, !0)
}, gN = {
  lineStyle: "stroke",
  itemStyle: "fill"
};
function aw(e, t) {
  var i = e.visualStyleMapper || Ay[t];
  return i || (console.warn("Unknown style type '" + t + "'."), Ay.itemStyle);
}
function sw(e, t) {
  var i = e.visualDrawType || gN[t];
  return i || (console.warn("Unknown style type '" + t + "'."), "fill");
}
var mN = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = e.getModel(n), a = aw(e, n), s = a(r), o = r.getShallow("decal");
    o && (i.setVisual("decal", o), o.dirty = !0);
    var l = sw(e, n), u = s[l], c = mt(u) ? u : null, h = s.fill === "auto" || s.stroke === "auto";
    if (!s[l] || c || h) {
      var d = e.getColorFromPalette(
        // TODO series count changed.
        e.name,
        null,
        t.getSeriesCount()
      );
      s[l] || (s[l] = d, i.setVisual("colorFromPalette", !0)), s.fill = s.fill === "auto" || mt(s.fill) ? d : s.fill, s.stroke = s.stroke === "auto" || mt(s.stroke) ? d : s.stroke;
    }
    if (i.setVisual("style", s), i.setVisual("drawType", l), !t.isSeriesFiltered(e) && c)
      return i.setVisual("colorFromPalette", !1), {
        dataEach: function(f, v) {
          var m = e.getDataParams(v), p = Y({}, s);
          p[l] = c(m), f.setItemVisual(v, "style", p);
        }
      };
  }
}, Rs = new jt(), yN = {
  createOnAllSeries: !0,
  performRawSeries: !0,
  reset: function(e, t) {
    if (!(e.ignoreStyleOnData || t.isSeriesFiltered(e))) {
      var i = e.getData(), n = e.visualStyleAccessPath || "itemStyle", r = aw(e, n), a = i.getVisual("drawType");
      return {
        dataEach: i.hasItemOption ? function(s, o) {
          var l = s.getRawDataItem(o);
          if (l && l[n]) {
            Rs.option = l[n];
            var u = r(Rs), c = s.ensureUniqueItemVisual(o, "style");
            Y(c, u), Rs.option.decal && (s.setItemVisual(o, "decal", Rs.option.decal), Rs.option.decal.dirty = !0), a in u && s.setItemVisual(o, "colorFromPalette", !1);
          }
        } : null
      };
    }
  }
}, _N = {
  performRawSeries: !0,
  overallReset: function(e) {
    var t = ht();
    e.eachSeries(function(i) {
      var n = i.getColorBy();
      if (!i.isColorBySeries()) {
        var r = i.type + "-" + n, a = t.get(r);
        a || (a = {}, t.set(r, a)), Ey(i).scope = a;
      }
    }), e.eachSeries(function(i) {
      if (!(i.isColorBySeries() || e.isSeriesFiltered(i))) {
        var n = i.getRawData(), r = {}, a = i.getData(), s = Ey(i).scope, o = i.visualStyleAccessPath || "itemStyle", l = sw(i, o);
        a.each(function(u) {
          var c = a.getRawIndex(u);
          r[c] = u;
        }), n.each(function(u) {
          var c = r[u], h = a.getItemVisual(c, "colorFromPalette");
          if (h) {
            var d = a.ensureUniqueItemVisual(c, "style"), f = n.getName(u) || u + "", v = n.count();
            d[l] = i.getColorFromPalette(f, s, v);
          }
        });
      }
    });
  }
}, Hl = Math.PI;
function bN(e, t) {
  t = t || {}, Jt(t, {
    text: "loading",
    textColor: St.color.primary,
    fontSize: 12,
    fontWeight: "normal",
    fontStyle: "normal",
    fontFamily: "sans-serif",
    maskColor: "rgba(255,255,255,0.8)",
    showSpinner: !0,
    color: St.color.theme[0],
    spinnerRadius: 10,
    lineWidth: 5,
    zlevel: 0
  });
  var i = new Ci(), n = new De({
    style: {
      fill: t.maskColor
    },
    zlevel: t.zlevel,
    z: 1e4
  });
  i.add(n);
  var r = new _i({
    style: {
      text: t.text,
      fill: t.textColor,
      fontSize: t.fontSize,
      fontWeight: t.fontWeight,
      fontStyle: t.fontStyle,
      fontFamily: t.fontFamily
    },
    zlevel: t.zlevel,
    z: 10001
  }), a = new De({
    style: {
      fill: "none"
    },
    textContent: r,
    textConfig: {
      position: "right",
      distance: 10
    },
    zlevel: t.zlevel,
    z: 10001
  });
  i.add(a);
  var s;
  return t.showSpinner && (s = new Rc({
    shape: {
      startAngle: -Hl / 2,
      endAngle: -Hl / 2 + 0.1,
      r: t.spinnerRadius
    },
    style: {
      stroke: t.color,
      lineCap: "round",
      lineWidth: t.lineWidth
    },
    zlevel: t.zlevel,
    z: 10001
  }), s.animateShape(!0).when(1e3, {
    endAngle: Hl * 3 / 2
  }).start("circularInOut"), s.animateShape(!0).when(1e3, {
    startAngle: Hl * 3 / 2
  }).delay(300).start("circularInOut"), i.add(s)), i.resize = function() {
    var o = r.getBoundingRect().width, l = t.showSpinner ? t.spinnerRadius : 0, u = (e.getWidth() - l * 2 - (t.showSpinner && o ? 10 : 0) - o) / 2 - (t.showSpinner && o ? 0 : 5 + o / 2) + (t.showSpinner ? 0 : o / 2) + (o ? 0 : l), c = e.getHeight() / 2;
    t.showSpinner && s.setShape({
      cx: u,
      cy: c
    }), a.setShape({
      x: u - l,
      y: c - l,
      width: l * 2,
      height: l * 2
    }), n.setShape({
      x: 0,
      y: 0,
      width: e.getWidth(),
      height: e.getHeight()
    });
  }, i.resize(), i;
}
var ow = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this._stageTaskMap = ht(), this.ecInstance = t, this.api = i, n = this._dataProcessorHandlers = n.slice(), r = this._visualHandlers = r.slice(), this._allHandlers = n.concat(r);
    }
    return e.prototype.restoreData = function(t, i) {
      t.restoreData(i), this._stageTaskMap.each(function(n) {
        var r = n.overallTask;
        r && r.dirty();
      });
    }, e.prototype.getPerformArgs = function(t, i) {
      if (t.__pipeline) {
        var n = this._pipelineMap.get(t.__pipeline.id), r = n.context, a = !i && n.progressiveEnabled && (!r || r.progressiveRender) && t.__idxInPipeline > n.blockIndex, s = a ? n.step : null, o = r && r.modDataCount, l = o != null ? Math.ceil(o / s) : null;
        return {
          step: s,
          modBy: l,
          modDataCount: o
        };
      }
    }, e.prototype.getPipeline = function(t) {
      return this._pipelineMap.get(t);
    }, e.prototype.updateStreamModes = function(t, i) {
      var n = this._pipelineMap.get(t.uid), r = t.getData(), a = r.count(), s = n.progressiveEnabled && i.incrementalPrepareRender && a >= n.threshold, o = t.get("large") && a >= t.get("largeThreshold"), l = t.get("progressiveChunkMode") === "mod" ? a : null;
      t.pipelineContext = n.context = {
        progressiveRender: s,
        modDataCount: l,
        large: o
      };
    }, e.prototype.restorePipelines = function(t) {
      var i = this, n = i._pipelineMap = ht();
      t.eachSeries(function(r) {
        var a = r.getProgressive(), s = r.uid;
        n.set(s, {
          id: s,
          head: null,
          tail: null,
          threshold: r.getProgressiveThreshold(),
          progressiveEnabled: a && !(r.preventIncremental && r.preventIncremental()),
          blockIndex: -1,
          step: Math.round(a || 700),
          count: 0
        }), i._pipe(r, r.dataTask);
      });
    }, e.prototype.prepareStageTasks = function() {
      var t = this._stageTaskMap, i = this.api.getModel(), n = this.api;
      E(this._allHandlers, function(r) {
        var a = t.get(r.uid) || t.set(r.uid, {}), s = "";
        process.env.NODE_ENV !== "production" && (s = '"reset" and "overallReset" must not be both specified.'), nt(!(r.reset && r.overallReset), s), r.reset && this._createSeriesStageTask(r, a, i, n), r.overallReset && this._createOverallStageTask(r, a, i, n);
      }, this);
    }, e.prototype.prepareView = function(t, i, n, r) {
      var a = t.renderTask, s = a.context;
      s.model = i, s.ecModel = n, s.api = r, a.__block = !t.incrementalPrepareRender, this._pipe(i, a);
    }, e.prototype.performDataProcessorTasks = function(t, i) {
      this._performStageTasks(this._dataProcessorHandlers, t, i, {
        block: !0
      });
    }, e.prototype.performVisualTasks = function(t, i, n) {
      this._performStageTasks(this._visualHandlers, t, i, n);
    }, e.prototype._performStageTasks = function(t, i, n, r) {
      r = r || {};
      var a = !1, s = this;
      E(t, function(l, u) {
        if (!(r.visualType && r.visualType !== l.visualType)) {
          var c = s._stageTaskMap.get(l.uid), h = c.seriesTaskMap, d = c.overallTask;
          if (d) {
            var f, v = d.agentStubMap;
            v.each(function(p) {
              o(r, p) && (p.dirty(), f = !0);
            }), f && d.dirty(), s.updatePayload(d, n);
            var m = s.getPerformArgs(d, r.block);
            v.each(function(p) {
              p.perform(m);
            }), d.perform(m) && (a = !0);
          } else h && h.each(function(p, g) {
            o(r, p) && p.dirty();
            var y = s.getPerformArgs(p, r.block);
            y.skip = !l.performRawSeries && i.isSeriesFiltered(p.context.model), s.updatePayload(p, n), p.perform(y) && (a = !0);
          });
        }
      });
      function o(l, u) {
        return l.setDirty && (!l.dirtyMap || l.dirtyMap.get(u.__pipeline.id));
      }
      this.unfinished = a || this.unfinished;
    }, e.prototype.performSeriesTasks = function(t) {
      var i;
      t.eachSeries(function(n) {
        i = n.dataTask.perform() || i;
      }), this.unfinished = i || this.unfinished;
    }, e.prototype.plan = function() {
      this._pipelineMap.each(function(t) {
        var i = t.tail;
        do {
          if (i.__block) {
            t.blockIndex = i.__idxInPipeline;
            break;
          }
          i = i.getUpstream();
        } while (i);
      });
    }, e.prototype.updatePayload = function(t, i) {
      i !== "remain" && (t.context.payload = i);
    }, e.prototype._createSeriesStageTask = function(t, i, n, r) {
      var a = this, s = i.seriesTaskMap, o = i.seriesTaskMap = ht(), l = t.seriesType, u = t.getTargetSeries;
      t.createOnAllSeries ? n.eachRawSeries(c) : l ? n.eachRawSeriesByType(l, c) : u && u(n, r).each(c);
      function c(h) {
        var d = h.uid, f = o.set(d, s && s.get(d) || bo({
          plan: kN,
          reset: DN,
          count: CN
        }));
        f.context = {
          model: h,
          ecModel: n,
          api: r,
          // PENDING: `useClearVisual` not used?
          useClearVisual: t.isVisual && !t.isLayout,
          plan: t.plan,
          reset: t.reset,
          scheduler: a
        }, a._pipe(h, f);
      }
    }, e.prototype._createOverallStageTask = function(t, i, n, r) {
      var a = this, s = i.overallTask = i.overallTask || bo({
        reset: xN
      });
      s.context = {
        ecModel: n,
        api: r,
        overallReset: t.overallReset,
        scheduler: a
      };
      var o = s.agentStubMap, l = s.agentStubMap = ht(), u = t.seriesType, c = t.getTargetSeries, h = !0, d = !1, f = "";
      process.env.NODE_ENV !== "production" && (f = '"createOnAllSeries" is not supported for "overallReset", because it will block all streams.'), nt(!t.createOnAllSeries, f), u ? n.eachRawSeriesByType(u, v) : c ? c(n, r).each(v) : (h = !1, E(n.getSeries(), v));
      function v(m) {
        var p = m.uid, g = l.set(p, o && o.get(p) || // When the result of `getTargetSeries` changed, the overallTask
        // should be set as dirty and re-performed.
        (d = !0, bo({
          reset: wN,
          onDirty: MN
        })));
        g.context = {
          model: m,
          overallProgress: h
          // FIXME:TS never used, so comment it
          // modifyOutputEnd: modifyOutputEnd
        }, g.agent = s, g.__block = h, a._pipe(m, g);
      }
      d && s.dirty();
    }, e.prototype._pipe = function(t, i) {
      var n = t.uid, r = this._pipelineMap.get(n);
      !r.head && (r.head = i), r.tail && r.tail.pipe(i), r.tail = i, i.__idxInPipeline = r.count++, i.__pipeline = r;
    }, e.wrapStageHandler = function(t, i) {
      return mt(t) && (t = {
        overallReset: t,
        seriesType: EN(t)
      }), t.uid = Fc("stageHandler"), i && (t.visualType = i), t;
    }, e;
  })()
);
function xN(e) {
  e.overallReset(e.ecModel, e.api, e.payload);
}
function wN(e) {
  return e.overallProgress && SN;
}
function SN() {
  this.agent.dirty(), this.getDownstream().dirty();
}
function MN() {
  this.agent && this.agent.dirty();
}
function kN(e) {
  return e.plan ? e.plan(e.model, e.ecModel, e.api, e.payload) : null;
}
function DN(e) {
  e.useClearVisual && e.data.clearAllVisual();
  var t = e.resetDefines = Ie(e.reset(e.model, e.ecModel, e.api, e.payload));
  return t.length > 1 ? _t(t, function(i, n) {
    return lw(n);
  }) : TN;
}
var TN = lw(0);
function lw(e) {
  return function(t, i) {
    var n = i.data, r = i.resetDefines[e];
    if (r && r.dataEach)
      for (var a = t.start; a < t.end; a++)
        r.dataEach(n, a);
    else r && r.progress && r.progress(t, n);
  };
}
function CN(e) {
  return e.data.count();
}
function EN(e) {
  Qu = null;
  try {
    e(zo, uw);
  } catch {
  }
  return Qu;
}
var zo = {}, uw = {}, Qu;
cw(zo, ap);
cw(uw, Bx);
zo.eachSeriesByType = zo.eachRawSeriesByType = function(e) {
  Qu = e;
};
zo.eachComponent = function(e) {
  e.mainType === "series" && e.subType && (Qu = e.subType);
};
function cw(e, t) {
  for (var i in t.prototype)
    e[i] = ke;
}
var W = St.darkColor, AN = W.background, Ns = function() {
  return {
    axisLine: {
      lineStyle: {
        color: W.axisLine
      }
    },
    splitLine: {
      lineStyle: {
        color: W.axisSplitLine
      }
    },
    splitArea: {
      areaStyle: {
        color: [W.backgroundTint, W.backgroundTransparent]
      }
    },
    minorSplitLine: {
      lineStyle: {
        color: W.axisMinorSplitLine
      }
    },
    axisLabel: {
      color: W.axisLabel
    },
    axisName: {}
  };
}, Py = {
  label: {
    color: W.secondary
  },
  itemStyle: {
    borderColor: W.borderTint
  },
  dividerLineStyle: {
    color: W.border
  }
}, hw = {
  darkMode: !0,
  color: W.theme,
  backgroundColor: AN,
  axisPointer: {
    lineStyle: {
      color: W.border
    },
    crossStyle: {
      color: W.borderShade
    },
    label: {
      color: W.tertiary
    }
  },
  legend: {
    textStyle: {
      color: W.secondary
    },
    pageTextStyle: {
      color: W.tertiary
    }
  },
  textStyle: {
    color: W.secondary
  },
  title: {
    textStyle: {
      color: W.primary
    },
    subtextStyle: {
      color: W.quaternary
    }
  },
  toolbox: {
    iconStyle: {
      borderColor: W.accent50
    }
  },
  tooltip: {
    backgroundColor: W.neutral20,
    defaultBorderColor: W.border,
    textStyle: {
      color: W.tertiary
    }
  },
  dataZoom: {
    borderColor: W.accent10,
    textStyle: {
      color: W.tertiary
    },
    brushStyle: {
      color: W.backgroundTint
    },
    handleStyle: {
      color: W.neutral00,
      borderColor: W.accent20
    },
    moveHandleStyle: {
      color: W.accent40
    },
    emphasis: {
      handleStyle: {
        borderColor: W.accent50
      }
    },
    dataBackground: {
      lineStyle: {
        color: W.accent30
      },
      areaStyle: {
        color: W.accent20
      }
    },
    selectedDataBackground: {
      lineStyle: {
        color: W.accent50
      },
      areaStyle: {
        color: W.accent30
      }
    }
  },
  visualMap: {
    textStyle: {
      color: W.secondary
    },
    handleStyle: {
      borderColor: W.neutral30
    }
  },
  timeline: {
    lineStyle: {
      color: W.accent10
    },
    label: {
      color: W.tertiary
    },
    controlStyle: {
      color: W.accent30,
      borderColor: W.accent30
    }
  },
  calendar: {
    itemStyle: {
      color: W.neutral00,
      borderColor: W.neutral20
    },
    dayLabel: {
      color: W.tertiary
    },
    monthLabel: {
      color: W.secondary
    },
    yearLabel: {
      color: W.secondary
    }
  },
  matrix: {
    x: Py,
    y: Py,
    backgroundColor: {
      borderColor: W.axisLine
    },
    body: {
      itemStyle: {
        borderColor: W.borderTint
      }
    }
  },
  timeAxis: Ns(),
  logAxis: Ns(),
  valueAxis: Ns(),
  categoryAxis: Ns(),
  line: {
    symbol: "circle"
  },
  graph: {
    color: W.theme
  },
  gauge: {
    title: {
      color: W.secondary
    },
    axisLine: {
      lineStyle: {
        color: [[1, W.neutral05]]
      }
    },
    axisLabel: {
      color: W.axisLabel
    },
    detail: {
      color: W.primary
    }
  },
  candlestick: {
    itemStyle: {
      color: "#f64e56",
      color0: "#54ea92",
      borderColor: "#f64e56",
      borderColor0: "#54ea92"
      // borderColor: '#ca2824',
      // borderColor0: '#09a443'
    }
  },
  funnel: {
    itemStyle: {
      borderColor: W.background
    }
  },
  radar: (function() {
    var e = Ns();
    return e.axisName = {
      color: W.axisLabel
    }, e.axisLine.lineStyle.color = W.neutral20, e;
  })(),
  treemap: {
    breadcrumb: {
      itemStyle: {
        color: W.neutral20,
        textStyle: {
          color: W.secondary
        }
      },
      emphasis: {
        itemStyle: {
          color: W.neutral30
        }
      }
    }
  },
  sunburst: {
    itemStyle: {
      borderColor: W.background
    }
  },
  map: {
    itemStyle: {
      borderColor: W.border,
      areaColor: W.neutral10
    },
    label: {
      color: W.tertiary
    },
    emphasis: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    },
    select: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    }
  },
  geo: {
    itemStyle: {
      borderColor: W.border,
      areaColor: W.neutral10
    },
    emphasis: {
      label: {
        color: W.primary
      },
      itemStyle: {
        areaColor: W.highlight
      }
    },
    select: {
      label: {
        color: W.primary
      },
      itemStyle: {
        color: W.highlight
      }
    }
  }
};
hw.categoryAxis.splitLine.show = !1;
var PN = (
  /** @class */
  (function() {
    function e() {
    }
    return e.prototype.normalizeQuery = function(t) {
      var i = {}, n = {}, r = {};
      if (et(t)) {
        var a = ji(t);
        i.mainType = a.main || null, i.subType = a.sub || null;
      } else {
        var s = ["Index", "Name", "Id"], o = {
          name: 1,
          dataIndex: 1,
          dataType: 1
        };
        E(t, function(l, u) {
          for (var c = !1, h = 0; h < s.length; h++) {
            var d = s[h], f = u.lastIndexOf(d);
            if (f > 0 && f === u.length - d.length) {
              var v = u.slice(0, f);
              v !== "data" && (i.mainType = v, i[d.toLowerCase()] = l, c = !0);
            }
          }
          o.hasOwnProperty(u) && (n[u] = l, c = !0), c || (r[u] = l);
        });
      }
      return {
        cptQuery: i,
        dataQuery: n,
        otherQuery: r
      };
    }, e.prototype.filter = function(t, i) {
      var n = this.eventInfo;
      if (!n)
        return !0;
      var r = n.targetEl, a = n.packedEvent, s = n.model, o = n.view;
      if (!s || !o)
        return !0;
      var l = i.cptQuery, u = i.dataQuery;
      return c(l, s, "mainType") && c(l, s, "subType") && c(l, s, "index", "componentIndex") && c(l, s, "name") && c(l, s, "id") && c(u, a, "name") && c(u, a, "dataIndex") && c(u, a, "dataType") && (!o.filterForExposedEvent || o.filterForExposedEvent(t, i.otherQuery, r, a));
      function c(h, d, f, v) {
        return h[f] == null || d[v || f] === h[f];
      }
    }, e.prototype.afterTrigger = function() {
      this.eventInfo = null;
    }, e;
  })()
), Of = ["symbol", "symbolSize", "symbolRotate", "symbolOffset"], Ly = Of.concat(["symbolKeepAspect"]), LN = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    var i = e.getData();
    if (e.legendIcon && i.setVisual("legendIcon", e.legendIcon), !e.hasSymbolVisual)
      return;
    for (var n = {}, r = {}, a = !1, s = 0; s < Of.length; s++) {
      var o = Of[s], l = e.get(o);
      mt(l) ? (a = !0, r[o] = l) : n[o] = l;
    }
    if (n.symbol = n.symbol || e.defaultSymbol, i.setVisual(Y({
      legendIcon: e.legendIcon || n.symbol,
      symbolKeepAspect: e.get("symbolKeepAspect")
    }, n)), t.isSeriesFiltered(e))
      return;
    var u = qt(r);
    function c(h, d) {
      for (var f = e.getRawValue(d), v = e.getDataParams(d), m = 0; m < u.length; m++) {
        var p = u[m];
        h.setItemVisual(d, p, r[p](f, v));
      }
    }
    return {
      dataEach: a ? c : null
    };
  }
}, ON = {
  createOnAllSeries: !0,
  // For legend.
  performRawSeries: !0,
  reset: function(e, t) {
    if (!e.hasSymbolVisual || t.isSeriesFiltered(e))
      return;
    var i = e.getData();
    function n(r, a) {
      for (var s = r.getItemModel(a), o = 0; o < Ly.length; o++) {
        var l = Ly[o], u = s.getShallow(l, !0);
        u != null && r.setItemVisual(a, l, u);
      }
    }
    return {
      dataEach: i.hasItemOption ? n : null
    };
  }
};
function IN(e, t, i) {
  switch (i) {
    case "color":
      var n = e.getItemVisual(t, "style");
      return n[e.getVisual("drawType")];
    case "opacity":
      return e.getItemVisual(t, "style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getItemVisual(t, i);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + i);
  }
}
function RN(e, t) {
  switch (t) {
    case "color":
      var i = e.getVisual("style");
      return i[e.getVisual("drawType")];
    case "opacity":
      return e.getVisual("style").opacity;
    case "symbol":
    case "symbolSize":
    case "liftZ":
      return e.getVisual(t);
    default:
      process.env.NODE_ENV !== "production" && console.warn("Unknown visual type " + t);
  }
}
function Pa(e, t, i, n, r) {
  var a = e + t;
  i.isSilent(a) || (process.env.NODE_ENV !== "production" && Cn("event " + a + " is deprecated."), n.eachComponent({
    mainType: "series",
    subType: "pie"
  }, function(s) {
    for (var o = s.seriesIndex, l = s.option.selectedMap, u = r.selected, c = 0; c < u.length; c++)
      if (u[c].seriesIndex === o) {
        var h = s.getData(), d = Ko(h, r.fromActionPayload);
        i.trigger(a, {
          type: a,
          seriesId: s.id,
          name: K(d) ? h.getName(d[0]) : h.getName(d),
          selected: et(l) ? l : Y({}, l)
        });
      }
  }));
}
function NN(e, t, i) {
  e.on("selectchanged", function(n) {
    var r = i.getModel();
    n.isFromClick ? (Pa("map", "selectchanged", t, r, n), Pa("pie", "selectchanged", t, r, n)) : n.fromAction === "select" ? (Pa("map", "selected", t, r, n), Pa("pie", "selected", t, r, n)) : n.fromAction === "unselect" && (Pa("map", "unselected", t, r, n), Pa("pie", "unselected", t, r, n));
  });
}
function ao(e, t, i) {
  for (var n; e && !(t(e) && (n = e, i)); )
    e = e.__hostTarget || e.parent;
  return n;
}
var FN = Math.round(Math.random() * 9), BN = typeof Object.defineProperty == "function", $N = (function() {
  function e() {
    this._id = "__ec_inner_" + FN++;
  }
  return e.prototype.get = function(t) {
    return this._guard(t)[this._id];
  }, e.prototype.set = function(t, i) {
    var n = this._guard(t);
    return BN ? Object.defineProperty(n, this._id, {
      value: i,
      enumerable: !1,
      configurable: !0
    }) : n[this._id] = i, this;
  }, e.prototype.delete = function(t) {
    return this.has(t) ? (delete this._guard(t)[this._id], !0) : !1;
  }, e.prototype.has = function(t) {
    return !!this._guard(t)[this._id];
  }, e.prototype._guard = function(t) {
    if (t !== Object(t))
      throw TypeError("Value of WeakMap is not a non-null object.");
    return t;
  }, e;
})(), zN = $t.extend({
  type: "triangle",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n + a), e.lineTo(i - r, n + a), e.closePath();
  }
}), VN = $t.extend({
  type: "diamond",
  shape: {
    cx: 0,
    cy: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.cx, n = t.cy, r = t.width / 2, a = t.height / 2;
    e.moveTo(i, n - a), e.lineTo(i + r, n), e.lineTo(i, n + a), e.lineTo(i - r, n), e.closePath();
  }
}), HN = $t.extend({
  type: "pin",
  shape: {
    // x, y on the cusp
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.x, n = t.y, r = t.width / 5 * 3, a = Math.max(r, t.height), s = r / 2, o = s * s / (a - s), l = n - a + s + o, u = Math.asin(o / s), c = Math.cos(u) * s, h = Math.sin(u), d = Math.cos(u), f = s * 0.6, v = s * 0.7;
    e.moveTo(i - c, l + o), e.arc(i, l, s, Math.PI - u, Math.PI * 2 + u), e.bezierCurveTo(i + c - h * f, l + o + d * f, i, n - v, i, n), e.bezierCurveTo(i, n - v, i - c + h * f, l + o + d * f, i - c, l + o), e.closePath();
  }
}), YN = $t.extend({
  type: "arrow",
  shape: {
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  buildPath: function(e, t) {
    var i = t.height, n = t.width, r = t.x, a = t.y, s = n / 3 * 2;
    e.moveTo(r, a), e.lineTo(r + s, a + i), e.lineTo(r, a + i / 4 * 3), e.lineTo(r - s, a + i), e.lineTo(r, a), e.closePath();
  }
}), WN = {
  line: ms,
  rect: De,
  roundRect: De,
  square: De,
  circle: Ic,
  diamond: VN,
  pin: HN,
  arrow: YN,
  triangle: zN
}, UN = {
  line: function(e, t, i, n, r) {
    r.x1 = e, r.y1 = t + n / 2, r.x2 = e + i, r.y2 = t + n / 2;
  },
  rect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n;
  },
  roundRect: function(e, t, i, n, r) {
    r.x = e, r.y = t, r.width = i, r.height = n, r.r = Math.min(i, n) / 4;
  },
  square: function(e, t, i, n, r) {
    var a = Math.min(i, n);
    r.x = e, r.y = t, r.width = a, r.height = a;
  },
  circle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.r = Math.min(i, n) / 2;
  },
  diamond: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  },
  pin: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  arrow: function(e, t, i, n, r) {
    r.x = e + i / 2, r.y = t + n / 2, r.width = i, r.height = n;
  },
  triangle: function(e, t, i, n, r) {
    r.cx = e + i / 2, r.cy = t + n / 2, r.width = i, r.height = n;
  }
}, If = {};
E(WN, function(e, t) {
  If[t] = new e();
});
var GN = $t.extend({
  type: "symbol",
  shape: {
    symbolType: "",
    x: 0,
    y: 0,
    width: 0,
    height: 0
  },
  calculateTextPosition: function(e, t, i) {
    var n = S1(e, t, i), r = this.shape;
    return r && r.symbolType === "pin" && t.position === "inside" && (n.y = i.y + i.height * 0.4), n;
  },
  buildPath: function(e, t, i) {
    var n = t.symbolType;
    if (n !== "none") {
      var r = If[n];
      r || (n = "rect", r = If[n]), UN[n](t.x, t.y, t.width, t.height, r.shape), r.buildPath(e, r.shape, i);
    }
  }
});
function XN(e, t) {
  if (this.type !== "image") {
    var i = this.style;
    this.__isEmptyBrush ? (i.stroke = e, i.fill = t || St.color.neutral00, i.lineWidth = 2) : this.shape.symbolType === "line" ? i.stroke = e : i.fill = e, this.markRedraw();
  }
}
function dw(e, t, i, n, r, a, s) {
  var o = e.indexOf("empty") === 0;
  o && (e = e.substr(5, 1).toLowerCase() + e.substr(6));
  var l;
  return e.indexOf("image://") === 0 ? l = fx(e.slice(8), new lt(t, i, n, r), s ? "center" : "cover") : e.indexOf("path://") === 0 ? l = jv(e.slice(7), {}, new lt(t, i, n, r), s ? "center" : "cover") : l = new GN({
    shape: {
      symbolType: e,
      x: t,
      y: i,
      width: n,
      height: r
    }
  }), l.__isEmptyBrush = o, l.setColor = XN, a && l.setColor(a), l;
}
function jN(e, t) {
  if (e != null)
    return K(e) || (e = [e, e]), [Ye(e[0], t[0]) || 0, Ye(rt(e[1], e[0]), t[1]) || 0];
}
function Gr(e) {
  return isFinite(e);
}
function qN(e, t, i) {
  var n = t.x == null ? 0 : t.x, r = t.x2 == null ? 1 : t.x2, a = t.y == null ? 0 : t.y, s = t.y2 == null ? 0 : t.y2;
  t.global || (n = n * i.width + i.x, r = r * i.width + i.x, a = a * i.height + i.y, s = s * i.height + i.y), n = Gr(n) ? n : 0, r = Gr(r) ? r : 1, a = Gr(a) ? a : 0, s = Gr(s) ? s : 0;
  var o = e.createLinearGradient(n, a, r, s);
  return o;
}
function ZN(e, t, i) {
  var n = i.width, r = i.height, a = Math.min(n, r), s = t.x == null ? 0.5 : t.x, o = t.y == null ? 0.5 : t.y, l = t.r == null ? 0.5 : t.r;
  t.global || (s = s * n + i.x, o = o * r + i.y, l = l * a), s = Gr(s) ? s : 0.5, o = Gr(o) ? o : 0.5, l = l >= 0 && Gr(l) ? l : 0.5;
  var u = e.createRadialGradient(s, o, 0, s, o, l);
  return u;
}
function Rf(e, t, i) {
  for (var n = t.type === "radial" ? ZN(e, t, i) : qN(e, t, i), r = t.colorStops, a = 0; a < r.length; a++)
    n.addColorStop(r[a].offset, r[a].color);
  return n;
}
function KN(e, t) {
  if (e === t || !e && !t)
    return !1;
  if (!e || !t || e.length !== t.length)
    return !0;
  for (var i = 0; i < e.length; i++)
    if (e[i] !== t[i])
      return !0;
  return !1;
}
function Yl(e) {
  return parseInt(e, 10);
}
function Wl(e, t, i) {
  var n = ["width", "height"][t], r = ["clientWidth", "clientHeight"][t], a = ["paddingLeft", "paddingTop"][t], s = ["paddingRight", "paddingBottom"][t];
  if (i[n] != null && i[n] !== "auto")
    return parseFloat(i[n]);
  var o = document.defaultView.getComputedStyle(e);
  return (e[r] || Yl(o[n]) || Yl(e.style[n])) - (Yl(o[a]) || 0) - (Yl(o[s]) || 0) | 0;
}
function QN(e, t) {
  return !e || e === "solid" || !(t > 0) ? null : e === "dashed" ? [4 * t, 2 * t] : e === "dotted" ? [t] : Zt(e) ? [e] : K(e) ? e : null;
}
function fw(e) {
  var t = e.style, i = t.lineDash && t.lineWidth > 0 && QN(t.lineDash, t.lineWidth), n = t.lineDashOffset;
  if (i) {
    var r = t.strokeNoScale && e.getLineScale ? e.getLineScale() : 1;
    r && r !== 1 && (i = _t(i, function(a) {
      return a / r;
    }), n /= r);
  }
  return [i, n];
}
var JN = new cs(!0);
function Ju(e) {
  var t = e.stroke;
  return !(t == null || t === "none" || !(e.lineWidth > 0));
}
function Oy(e) {
  return typeof e == "string" && e !== "none";
}
function tc(e) {
  var t = e.fill;
  return t != null && t !== "none";
}
function Iy(e, t) {
  if (t.fillOpacity != null && t.fillOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.fillOpacity * t.opacity, e.fill(), e.globalAlpha = i;
  } else
    e.fill();
}
function Ry(e, t) {
  if (t.strokeOpacity != null && t.strokeOpacity !== 1) {
    var i = e.globalAlpha;
    e.globalAlpha = t.strokeOpacity * t.opacity, e.stroke(), e.globalAlpha = i;
  } else
    e.stroke();
}
function Nf(e, t, i) {
  var n = F1(t.image, t.__image, i);
  if (Pc(n)) {
    var r = e.createPattern(n, t.repeat || "repeat");
    if (typeof DOMMatrix == "function" && r && r.setTransform) {
      var a = new DOMMatrix();
      a.translateSelf(t.x || 0, t.y || 0), a.rotateSelf(0, 0, (t.rotation || 0) * tP), a.scaleSelf(t.scaleX || 1, t.scaleY || 1), r.setTransform(a);
    }
    return r;
  }
}
function tF(e, t, i, n) {
  var r, a = Ju(i), s = tc(i), o = i.strokePercent, l = o < 1, u = !t.path;
  (!t.silent || l) && u && t.createPathProxy();
  var c = t.path || JN, h = t.__dirty;
  if (!n) {
    var d = i.fill, f = i.stroke, v = s && !!d.colorStops, m = a && !!f.colorStops, p = s && !!d.image, g = a && !!f.image, y = void 0, _ = void 0, b = void 0, w = void 0, S = void 0;
    (v || m) && (S = t.getBoundingRect()), v && (y = h ? Rf(e, d, S) : t.__canvasFillGradient, t.__canvasFillGradient = y), m && (_ = h ? Rf(e, f, S) : t.__canvasStrokeGradient, t.__canvasStrokeGradient = _), p && (b = h || !t.__canvasFillPattern ? Nf(e, d, t) : t.__canvasFillPattern, t.__canvasFillPattern = b), g && (w = h || !t.__canvasStrokePattern ? Nf(e, f, t) : t.__canvasStrokePattern, t.__canvasStrokePattern = w), v ? e.fillStyle = y : p && (b ? e.fillStyle = b : s = !1), m ? e.strokeStyle = _ : g && (w ? e.strokeStyle = w : a = !1);
  }
  var M = t.getGlobalScale();
  c.setScale(M[0], M[1], t.segmentIgnoreThreshold);
  var k, T;
  e.setLineDash && i.lineDash && (r = fw(t), k = r[0], T = r[1]);
  var D = !0;
  (u || h & $a) && (c.setDPR(e.dpr), l ? c.setContext(null) : (c.setContext(e), D = !1), c.reset(), t.buildPath(c, t.shape, n), c.toStatic(), t.pathUpdated()), D && c.rebuildPath(e, l ? o : 1), k && (e.setLineDash(k), e.lineDashOffset = T), n || (i.strokeFirst ? (a && Ry(e, i), s && Iy(e, i)) : (s && Iy(e, i), a && Ry(e, i))), k && e.setLineDash([]);
}
function eF(e, t, i) {
  var n = t.__image = F1(i.image, t.__image, t, t.onload);
  if (!(!n || !Pc(n))) {
    var r = i.x || 0, a = i.y || 0, s = t.getWidth(), o = t.getHeight(), l = n.width / n.height;
    if (s == null && o != null ? s = o * l : o == null && s != null ? o = s / l : s == null && o == null && (s = n.width, o = n.height), i.sWidth && i.sHeight) {
      var u = i.sx || 0, c = i.sy || 0;
      e.drawImage(n, u, c, i.sWidth, i.sHeight, r, a, s, o);
    } else if (i.sx && i.sy) {
      var u = i.sx, c = i.sy, h = s - u, d = o - c;
      e.drawImage(n, u, c, h, d, r, a, s, o);
    } else
      e.drawImage(n, r, a, s, o);
  }
}
function iF(e, t, i) {
  var n, r = i.text;
  if (r != null && (r += ""), r) {
    e.font = i.font || nr, e.textAlign = i.textAlign, e.textBaseline = i.textBaseline;
    var a = void 0, s = void 0;
    e.setLineDash && i.lineDash && (n = fw(t), a = n[0], s = n[1]), a && (e.setLineDash(a), e.lineDashOffset = s), i.strokeFirst ? (Ju(i) && e.strokeText(r, i.x, i.y), tc(i) && e.fillText(r, i.x, i.y)) : (tc(i) && e.fillText(r, i.x, i.y), Ju(i) && e.strokeText(r, i.x, i.y)), a && e.setLineDash([]);
  }
}
var Ny = ["shadowBlur", "shadowOffsetX", "shadowOffsetY"], Fy = [
  ["lineCap", "butt"],
  ["lineJoin", "miter"],
  ["miterLimit", 10]
];
function vw(e, t, i, n, r) {
  var a = !1;
  if (!n && (i = i || {}, t === i))
    return !1;
  if (n || t.opacity !== i.opacity) {
    Ge(e, r), a = !0;
    var s = Math.max(Math.min(t.opacity, 1), 0);
    e.globalAlpha = isNaN(s) ? ia.opacity : s;
  }
  (n || t.blend !== i.blend) && (a || (Ge(e, r), a = !0), e.globalCompositeOperation = t.blend || ia.blend);
  for (var o = 0; o < Ny.length; o++) {
    var l = Ny[o];
    (n || t[l] !== i[l]) && (a || (Ge(e, r), a = !0), e[l] = e.dpr * (t[l] || 0));
  }
  return (n || t.shadowColor !== i.shadowColor) && (a || (Ge(e, r), a = !0), e.shadowColor = t.shadowColor || ia.shadowColor), a;
}
function By(e, t, i, n, r) {
  var a = Vo(t, r.inHover), s = n ? null : i && Vo(i, r.inHover) || {};
  if (a === s)
    return !1;
  var o = vw(e, a, s, n, r);
  if ((n || a.fill !== s.fill) && (o || (Ge(e, r), o = !0), Oy(a.fill) && (e.fillStyle = a.fill)), (n || a.stroke !== s.stroke) && (o || (Ge(e, r), o = !0), Oy(a.stroke) && (e.strokeStyle = a.stroke)), (n || a.opacity !== s.opacity) && (o || (Ge(e, r), o = !0), e.globalAlpha = a.opacity == null ? 1 : a.opacity), t.hasStroke()) {
    var l = a.lineWidth, u = l / (a.strokeNoScale && t.getLineScale ? t.getLineScale() : 1);
    e.lineWidth !== u && (o || (Ge(e, r), o = !0), e.lineWidth = u);
  }
  for (var c = 0; c < Fy.length; c++) {
    var h = Fy[c], d = h[0];
    (n || a[d] !== s[d]) && (o || (Ge(e, r), o = !0), e[d] = a[d] || h[1]);
  }
  return o;
}
function nF(e, t, i, n, r) {
  return vw(e, Vo(t, r.inHover), i && Vo(i, r.inHover), n, r);
}
function pw(e, t) {
  var i = t.transform, n = e.dpr || 1;
  i ? e.setTransform(n * i[0], n * i[1], n * i[2], n * i[3], n * i[4], n * i[5]) : e.setTransform(n, 0, 0, n, 0, 0);
}
function rF(e, t, i) {
  for (var n = !1, r = 0; r < e.length; r++) {
    var a = e[r];
    n = n || a.isZeroArea(), pw(t, a), t.beginPath(), a.buildPath(t, a.shape), t.clip();
  }
  i.allClipped = n;
}
function aF(e, t) {
  return e && t ? e[0] !== t[0] || e[1] !== t[1] || e[2] !== t[2] || e[3] !== t[3] || e[4] !== t[4] || e[5] !== t[5] : !(!e && !t);
}
var $y = 1, zy = 2, Vy = 3, Hy = 4;
function sF(e) {
  var t = tc(e), i = Ju(e);
  return !(e.lineDash || !(+t ^ +i) || t && typeof e.fill != "string" || i && typeof e.stroke != "string" || e.strokePercent < 1 || e.strokeOpacity < 1 || e.fillOpacity < 1);
}
function Ge(e, t) {
  t.batchFill && e.fill(), t.batchStroke && e.stroke(), t.batchFill = "", t.batchStroke = "";
}
function Vo(e, t) {
  return t && e.__hoverStyle || e.style;
}
function gw(e, t) {
  Xr(e, t, { inHover: !1, viewWidth: 0, viewHeight: 0 }, !0);
}
function Xr(e, t, i, n) {
  var r = t.transform;
  if (!t.shouldBePainted(i.viewWidth, i.viewHeight, !1, !1)) {
    t.__dirty &= ~Qe, t.__isRendered = !1;
    return;
  }
  var a = t.__clipPaths, s = i.prevElClipPaths, o = !1, l = !1;
  if ((!s || KN(a, s)) && (s && s.length && (Ge(e, i), e.restore(), l = o = !0, i.prevElClipPaths = null, i.allClipped = !1, i.prevEl = null), a && a.length && (Ge(e, i), e.save(), rF(a, e, i), o = !0), i.prevElClipPaths = a), i.allClipped) {
    t.__isRendered = !1;
    return;
  }
  t.beforeBrush && t.beforeBrush(), t.innerBeforeBrush();
  var u = i.prevEl;
  u || (l = o = !0);
  var c = t instanceof $t && t.autoBatch && sF(t.style);
  o || aF(r, u.transform) ? (Ge(e, i), pw(e, t)) : c || Ge(e, i);
  var h = Vo(t, i.inHover);
  t instanceof $t ? (i.lastDrawType !== $y && (l = !0, i.lastDrawType = $y), By(e, t, u, l, i), (!c || !i.batchFill && !i.batchStroke) && e.beginPath(), tF(e, t, h, c), c && (i.batchFill = h.fill || "", i.batchStroke = h.stroke || "")) : t instanceof zu ? (i.lastDrawType !== Vy && (l = !0, i.lastDrawType = Vy), By(e, t, u, l, i), iF(e, t, h)) : t instanceof ha ? (i.lastDrawType !== zy && (l = !0, i.lastDrawType = zy), nF(e, t, u, l, i), eF(e, t, h)) : t.getTemporalDisplayables && (i.lastDrawType !== Hy && (l = !0, i.lastDrawType = Hy), oF(e, t, i)), c && n && Ge(e, i), t.innerAfterBrush(), t.afterBrush && t.afterBrush(), i.prevEl = t, t.__dirty = 0, t.__isRendered = !0;
}
function oF(e, t, i) {
  var n = t.getDisplayables(), r = t.getTemporalDisplayables();
  e.save();
  var a = {
    prevElClipPaths: null,
    prevEl: null,
    allClipped: !1,
    viewWidth: i.viewWidth,
    viewHeight: i.viewHeight,
    inHover: i.inHover
  }, s, o;
  for (s = t.getCursor(), o = n.length; s < o; s++) {
    var l = n[s];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Xr(e, l, a, s === o - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  for (var u = 0, c = r.length; u < c; u++) {
    var l = r[u];
    l.beforeBrush && l.beforeBrush(), l.innerBeforeBrush(), Xr(e, l, a, u === c - 1), l.innerAfterBrush(), l.afterBrush && l.afterBrush(), a.prevEl = l;
  }
  t.clearTemporalDisplayables(), t.notClear = !0, e.restore();
}
var fd = new $N(), Yy = new os(100), Wy = ["symbol", "symbolSize", "symbolKeepAspect", "color", "backgroundColor", "dashArrayX", "dashArrayY", "maxTileWidth", "maxTileHeight"];
function Uy(e, t) {
  if (e === "none")
    return null;
  var i = t.getDevicePixelRatio(), n = t.getZr(), r = n.painter.type === "svg";
  e.dirty && fd.delete(e);
  var a = fd.get(e);
  if (a)
    return a;
  var s = Jt(e, {
    symbol: "rect",
    symbolSize: 1,
    symbolKeepAspect: !0,
    color: "rgba(0, 0, 0, 0.2)",
    backgroundColor: null,
    dashArrayX: 5,
    dashArrayY: 5,
    rotation: 0,
    maxTileWidth: 512,
    maxTileHeight: 512
  });
  s.backgroundColor === "none" && (s.backgroundColor = null);
  var o = {
    repeat: "repeat"
  };
  return l(o), o.rotation = s.rotation, o.scaleX = o.scaleY = r ? 1 : 1 / i, fd.set(e, o), e.dirty = !1, o;
  function l(u) {
    for (var c = [i], h = !0, d = 0; d < Wy.length; ++d) {
      var f = s[Wy[d]];
      if (f != null && !K(f) && !et(f) && !Zt(f) && typeof f != "boolean") {
        h = !1;
        break;
      }
      c.push(f);
    }
    var v;
    if (h) {
      v = c.join(",") + (r ? "-svg" : "");
      var m = Yy.get(v);
      m && (r ? u.svgElement = m : u.image = m);
    }
    var p = yw(s.dashArrayX), g = lF(s.dashArrayY), y = mw(s.symbol), _ = uF(p), b = _w(g), w = !r && Tn.createCanvas(), S = r && {
      tag: "g",
      attrs: {},
      key: "dcl",
      children: []
    }, M = T(), k;
    w && (w.width = M.width * i, w.height = M.height * i, k = w.getContext("2d")), D(), h && Yy.put(v, w || S), u.image = w, u.svgElement = S, u.svgWidth = M.width, u.svgHeight = M.height;
    function T() {
      for (var C = 1, P = 0, L = _.length; P < L; ++P)
        C = Km(C, _[P]);
      for (var O = 1, P = 0, L = y.length; P < L; ++P)
        O = Km(O, y[P].length);
      C *= O;
      var N = b * _.length * y.length;
      if (process.env.NODE_ENV !== "production") {
        var B = function(G) {
          console.warn("Calculated decal size is greater than " + G + " due to decal option settings so " + G + " is used for the decal size. Please consider changing the decal option to make a smaller decal or set " + G + " to be larger to avoid incontinuity.");
        };
        C > s.maxTileWidth && B("maxTileWidth"), N > s.maxTileHeight && B("maxTileHeight");
      }
      return {
        width: Math.max(1, Math.min(C, s.maxTileWidth)),
        height: Math.max(1, Math.min(N, s.maxTileHeight))
      };
    }
    function D() {
      k && (k.clearRect(0, 0, w.width, w.height), s.backgroundColor && (k.fillStyle = s.backgroundColor, k.fillRect(0, 0, w.width, w.height)));
      for (var C = 0, P = 0; P < g.length; ++P)
        C += g[P];
      if (C <= 0)
        return;
      for (var L = -b, O = 0, N = 0, B = 0; L < M.height; ) {
        if (O % 2 === 0) {
          for (var G = N / 2 % y.length, V = 0, F = 0, $ = 0; V < M.width * 2; ) {
            for (var Z = 0, P = 0; P < p[B].length; ++P)
              Z += p[B][P];
            if (Z <= 0)
              break;
            if (F % 2 === 0) {
              var j = (1 - s.symbolSize) * 0.5, it = V + p[B][F] * j, st = L + g[O] * j, wt = p[B][F] * s.symbolSize, Tt = g[O] * s.symbolSize, me = $ / 2 % y[G].length;
              Ae(it, st, wt, Tt, y[G][me]);
            }
            V += p[B][F], ++$, ++F, F === p[B].length && (F = 0);
          }
          ++B, B === p.length && (B = 0);
        }
        L += g[O], ++N, ++O, O === g.length && (O = 0);
      }
      function Ae(At, Ft, at, ft, Ni) {
        var ue = r ? 1 : i, Gp = dw(Ni, At * ue, Ft * ue, at * ue, ft * ue, s.color, s.symbolKeepAspect);
        if (r) {
          var Xp = n.painter.renderOneToVNode(Gp);
          Xp && S.children.push(Xp);
        } else
          gw(k, Gp);
      }
    }
  }
}
function mw(e) {
  if (!e || e.length === 0)
    return [["rect"]];
  if (et(e))
    return [[e]];
  for (var t = !0, i = 0; i < e.length; ++i)
    if (!et(e[i])) {
      t = !1;
      break;
    }
  if (t)
    return mw([e]);
  for (var n = [], i = 0; i < e.length; ++i)
    et(e[i]) ? n.push([e[i]]) : n.push(e[i]);
  return n;
}
function yw(e) {
  if (!e || e.length === 0)
    return [[0, 0]];
  if (Zt(e)) {
    var t = Math.ceil(e);
    return [[t, t]];
  }
  for (var i = !0, n = 0; n < e.length; ++n)
    if (!Zt(e[n])) {
      i = !1;
      break;
    }
  if (i)
    return yw([e]);
  for (var r = [], n = 0; n < e.length; ++n)
    if (Zt(e[n])) {
      var t = Math.ceil(e[n]);
      r.push([t, t]);
    } else {
      var t = _t(e[n], function(o) {
        return Math.ceil(o);
      });
      t.length % 2 === 1 ? r.push(t.concat(t)) : r.push(t);
    }
  return r;
}
function lF(e) {
  if (!e || typeof e == "object" && e.length === 0)
    return [0, 0];
  if (Zt(e)) {
    var t = Math.ceil(e);
    return [t, t];
  }
  var i = _t(e, function(n) {
    return Math.ceil(n);
  });
  return e.length % 2 ? i.concat(i) : i;
}
function uF(e) {
  return _t(e, function(t) {
    return _w(t);
  });
}
function _w(e) {
  for (var t = 0, i = 0; i < e.length; ++i)
    t += e[i];
  return e.length % 2 === 1 ? t * 2 : t;
}
function cF(e, t) {
  e.eachRawSeries(function(i) {
    if (!e.isSeriesFiltered(i)) {
      var n = i.getData();
      n.hasItemVisual() && n.each(function(s) {
        var o = n.getItemVisual(s, "decal");
        if (o) {
          var l = n.ensureUniqueItemVisual(s, "style");
          l.decal = Uy(o, t);
        }
      });
      var r = n.getVisual("decal");
      if (r) {
        var a = n.getVisual("style");
        a.decal = Uy(r, t);
      }
    }
  });
}
var Mi = new Li(), ec = {};
function hF(e, t) {
  process.env.NODE_ENV !== "production" && ec[e] && Kt("Already has an implementation of " + e + "."), ec[e] = t;
}
function dF(e) {
  return process.env.NODE_ENV !== "production" && (ec[e] || Kt("Implementation of " + e + " doesn't exists.")), ec[e];
}
var fF = 1, vF = 800, pF = 900, gF = 1e3, mF = 2e3, yF = 5e3, bw = 1e3, _F = 1100, up = 2e3, xw = 3e3, bF = 4e3, Vc = 4500, xF = 4600, wF = 5e3, SF = 6e3, ww = 7e3, MF = {
  PROCESSOR: {
    FILTER: gF,
    SERIES_FILTER: vF,
    STATISTIC: yF
  },
  VISUAL: {
    LAYOUT: bw,
    PROGRESSIVE_LAYOUT: _F,
    GLOBAL: up,
    CHART: xw,
    POST_CHART_LAYOUT: xF,
    COMPONENT: bF,
    BRUSH: wF,
    CHART_ITEM: Vc,
    ARIA: SF,
    DECAL: ww
  }
}, re = "__flagInMainProcess", Ul = "__mainProcessVersion", ve = "__pendingUpdate", vd = "__needsUpdateStatus", Gy = /^[a-zA-Z0-9_]+$/, pd = "__connectUpdateStatus", Xy = 0, kF = 1, DF = 2;
function Sw(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    if (this.isDisposed()) {
      $e(this.id);
      return;
    }
    return kw(this, e, t);
  };
}
function Mw(e) {
  return function() {
    for (var t = [], i = 0; i < arguments.length; i++)
      t[i] = arguments[i];
    return kw(this, e, t);
  };
}
function kw(e, t, i) {
  return i[0] = i[0] && i[0].toLowerCase(), Li.prototype[t].apply(e, i);
}
var Dw = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t;
  })(Li)
), Tw = Dw.prototype;
Tw.on = Mw("on");
Tw.off = Mw("off");
var Ir, gd, Gl, un, Xl, md, yd, La, Oa, jy, qy, _d, Zy, jl, Ky, Cw, ai, Qy, Ia, Ew = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i, n, r) {
      var a = e.call(this, new PN()) || this;
      a._chartsViews = [], a._chartsMap = {}, a._componentsViews = [], a._componentsMap = {}, a._pendingActions = [], r = r || {}, a._dom = i;
      var s = "canvas", o = "auto", l = !1;
      if (a[Ul] = 1, process.env.NODE_ENV !== "production") {
        var u = (
          /* eslint-disable-next-line */
          ot.hasGlobalWindow ? window : global
        );
        u && (s = rt(u.__ECHARTS__DEFAULT__RENDERER__, s), o = rt(u.__ECHARTS__DEFAULT__COARSE_POINTER, o), l = rt(u.__ECHARTS__DEFAULT__USE_DIRTY_RECT__, l));
      }
      r.ssr;
      var c = a._zr = jm(i, {
        renderer: r.renderer || s,
        devicePixelRatio: r.devicePixelRatio,
        width: r.width,
        height: r.height,
        ssr: r.ssr,
        useDirtyRect: rt(r.useDirtyRect, l),
        useCoarsePointer: rt(r.useCoarsePointer, o),
        pointerSize: r.pointerSize
      });
      a._ssr = r.ssr, a._throttledZrFlush = nw(Dt(c.flush, c), 17), a._updateTheme(n), a._locale = DR(r.locale || Mx), a._coordSysMgr = new Bc();
      var h = a._api = Ky(a);
      function d(f, v) {
        return f.__prio - v.__prio;
      }
      return ru(rc, d), ru(Bf, d), a._scheduler = new ow(a, h, Bf, rc), a._messageCenter = new Dw(), a._initEvents(), a.resize = Dt(a.resize, a), c.animation.on("frame", a._onframe, a), jy(c, a), qy(c, a), Gd(a), a;
    }
    return t.prototype._onframe = function() {
      if (!this._disposed) {
        Qy(this);
        var i = this._scheduler;
        if (this[ve]) {
          var n = this[ve].silent;
          this[re] = !0, Ia(this);
          try {
            Ir(this), un.update.call(this, null, this[ve].updateParams);
          } catch (l) {
            throw this[re] = !1, this[ve] = null, l;
          }
          this._zr.flush(), this[re] = !1, this[ve] = null, La.call(this, n), Oa.call(this, n);
        } else if (i.unfinished) {
          var r = fF, a = this._model, s = this._api;
          i.unfinished = !1;
          do {
            var o = +/* @__PURE__ */ new Date();
            i.performSeriesTasks(a), i.performDataProcessorTasks(a), md(this, a), i.performVisualTasks(a), jl(this, this._model, s, "remain", {}), r -= +/* @__PURE__ */ new Date() - o;
          } while (r > 0 && i.unfinished);
          i.unfinished || this._zr.flush();
        }
      }
    }, t.prototype.getDom = function() {
      return this._dom;
    }, t.prototype.getId = function() {
      return this.id;
    }, t.prototype.getZr = function() {
      return this._zr;
    }, t.prototype.isSSR = function() {
      return this._ssr;
    }, t.prototype.setOption = function(i, n, r) {
      if (this[re]) {
        process.env.NODE_ENV !== "production" && Kt("`setOption` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        $e(this.id);
        return;
      }
      var a, s, o;
      if (tt(n) && (r = n.lazyUpdate, a = n.silent, s = n.replaceMerge, o = n.transition, n = n.notMerge), this[re] = !0, Ia(this), !this._model || n) {
        var l = new u5(this._api), u = this._theme, c = this._model = new ap();
        c.scheduler = this._scheduler, c.ssr = this._ssr, c.init(null, null, null, u, this._locale, l);
      }
      this._model.setOption(i, {
        replaceMerge: s
      }, $f);
      var h = {
        seriesTransition: o,
        optionChanged: !0
      };
      if (r)
        this[ve] = {
          silent: a,
          updateParams: h
        }, this[re] = !1, this.getZr().wakeUp();
      else {
        try {
          Ir(this), un.update.call(this, null, h);
        } catch (d) {
          throw this[ve] = null, this[re] = !1, d;
        }
        this._ssr || this._zr.flush(), this[ve] = null, this[re] = !1, La.call(this, a), Oa.call(this, a);
      }
    }, t.prototype.setTheme = function(i, n) {
      if (this[re]) {
        process.env.NODE_ENV !== "production" && Kt("`setTheme` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        $e(this.id);
        return;
      }
      var r = this._model;
      if (r) {
        var a = n && n.silent, s = null;
        this[ve] && (a == null && (a = this[ve].silent), s = this[ve].updateParams, this[ve] = null), this[re] = !0, Ia(this);
        try {
          this._updateTheme(i), r.setTheme(this._theme), Ir(this), un.update.call(this, {
            type: "setTheme"
          }, s);
        } catch (o) {
          throw this[re] = !1, o;
        }
        this[re] = !1, La.call(this, a), Oa.call(this, a);
      }
    }, t.prototype._updateTheme = function(i) {
      et(i) && (i = Aw[i]), i && (i = pt(i), i && zx(i, !0), this._theme = i);
    }, t.prototype.getModel = function() {
      return this._model;
    }, t.prototype.getOption = function() {
      return this._model && this._model.getOption();
    }, t.prototype.getWidth = function() {
      return this._zr.getWidth();
    }, t.prototype.getHeight = function() {
      return this._zr.getHeight();
    }, t.prototype.getDevicePixelRatio = function() {
      return this._zr.painter.dpr || ot.hasGlobalWindow && window.devicePixelRatio || 1;
    }, t.prototype.getRenderedCanvas = function(i) {
      return process.env.NODE_ENV !== "production" && ge("getRenderedCanvas", "renderToCanvas"), this.renderToCanvas(i);
    }, t.prototype.renderToCanvas = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "canvas")
        throw new Error("renderToCanvas can only be used in the canvas renderer.");
      return n.getRenderedCanvas({
        backgroundColor: i.backgroundColor || this._model.get("backgroundColor"),
        pixelRatio: i.pixelRatio || this.getDevicePixelRatio()
      });
    }, t.prototype.renderToSVGString = function(i) {
      i = i || {};
      var n = this._zr.painter;
      if (process.env.NODE_ENV !== "production" && n.type !== "svg")
        throw new Error("renderToSVGString can only be used in the svg renderer.");
      return n.renderToString({
        useViewBox: i.useViewBox
      });
    }, t.prototype.getSvgDataURL = function() {
      var i = this._zr, n = i.storage.getDisplayList();
      return E(n, function(r) {
        r.stopAnimation(null, !0);
      }), i.painter.toDataURL();
    }, t.prototype.getDataURL = function(i) {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      i = i || {};
      var n = i.excludeComponents, r = this._model, a = [], s = this;
      E(n, function(l) {
        r.eachComponent({
          mainType: l
        }, function(u) {
          var c = s._componentsMap[u.__viewId];
          c.group.ignore || (a.push(c), c.group.ignore = !0);
        });
      });
      var o = this._zr.painter.getType() === "svg" ? this.getSvgDataURL() : this.renderToCanvas(i).toDataURL("image/" + (i && i.type || "png"));
      return E(a, function(l) {
        l.group.ignore = !1;
      }), o;
    }, t.prototype.getConnectedDataURL = function(i) {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      var n = i.type === "svg", r = this.group, a = Math.min, s = Math.max, o = 1 / 0;
      if (Jy[r]) {
        var l = o, u = o, c = -o, h = -o, d = [], f = i && i.pixelRatio || this.getDevicePixelRatio();
        E(xo, function(_, b) {
          if (_.group === r) {
            var w = n ? _.getZr().painter.getSvgDom().innerHTML : _.renderToCanvas(pt(i)), S = _.getDom().getBoundingClientRect();
            l = a(S.left, l), u = a(S.top, u), c = s(S.right, c), h = s(S.bottom, h), d.push({
              dom: w,
              left: S.left,
              top: S.top
            });
          }
        }), l *= f, u *= f, c *= f, h *= f;
        var v = c - l, m = h - u, p = Tn.createCanvas(), g = jm(p, {
          renderer: n ? "svg" : "canvas"
        });
        if (g.resize({
          width: v,
          height: m
        }), n) {
          var y = "";
          return E(d, function(_) {
            var b = _.left - l, w = _.top - u;
            y += '<g transform="translate(' + b + "," + w + ')">' + _.dom + "</g>";
          }), g.painter.getSvgRoot().innerHTML = y, i.connectedBackgroundColor && g.painter.setBackgroundColor(i.connectedBackgroundColor), g.refreshImmediately(), g.painter.toDataURL();
        } else
          return i.connectedBackgroundColor && g.add(new De({
            shape: {
              x: 0,
              y: 0,
              width: v,
              height: m
            },
            style: {
              fill: i.connectedBackgroundColor
            }
          })), E(d, function(_) {
            var b = new ha({
              style: {
                x: _.left * f - l,
                y: _.top * f - u,
                image: _.dom
              }
            });
            g.add(b);
          }), g.refreshImmediately(), p.toDataURL("image/" + (i && i.type || "png"));
      } else
        return this.getDataURL(i);
    }, t.prototype.convertToPixel = function(i, n, r) {
      return Xl(this, "convertToPixel", i, n, r);
    }, t.prototype.convertToLayout = function(i, n, r) {
      return Xl(this, "convertToLayout", i, n, r);
    }, t.prototype.convertFromPixel = function(i, n, r) {
      return Xl(this, "convertFromPixel", i, n, r);
    }, t.prototype.containPixel = function(i, n) {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      var r = this._model, a, s = Fh(r, i);
      return E(s, function(o, l) {
        l.indexOf("Models") >= 0 && E(o, function(u) {
          var c = u.coordinateSystem;
          if (c && c.containPoint)
            a = a || !!c.containPoint(n);
          else if (l === "seriesModels") {
            var h = this._chartsMap[u.__viewId];
            h && h.containPoint ? a = a || h.containPoint(n, u) : process.env.NODE_ENV !== "production" && hi(l + ": " + (h ? "The found component do not support containPoint." : "No view mapping to the found component."));
          } else
            process.env.NODE_ENV !== "production" && hi(l + ": containPoint is not supported");
        }, this);
      }, this), !!a;
    }, t.prototype.getVisual = function(i, n) {
      var r = this._model, a = Fh(r, i, {
        defaultMainType: "series"
      }), s = a.seriesModel;
      process.env.NODE_ENV !== "production" && (s || hi("There is no specified series model"));
      var o = s.getData(), l = a.hasOwnProperty("dataIndexInside") ? a.dataIndexInside : a.hasOwnProperty("dataIndex") ? o.indexOfRawIndex(a.dataIndex) : null;
      return l != null ? IN(o, l, n) : RN(o, n);
    }, t.prototype.getViewOfComponentModel = function(i) {
      return this._componentsMap[i.__viewId];
    }, t.prototype.getViewOfSeriesModel = function(i) {
      return this._chartsMap[i.__viewId];
    }, t.prototype._initEvents = function() {
      var i = this;
      E(TF, function(r) {
        var a = function(s) {
          var o = i.getModel(), l = s.target, u, c = r === "globalout";
          if (c ? u = {} : l && ao(l, function(m) {
            var p = Vt(m);
            if (p && p.dataIndex != null) {
              var g = p.dataModel || o.getSeriesByIndex(p.seriesIndex);
              return u = g && g.getDataParams(p.dataIndex, p.dataType, l) || {}, !0;
            } else if (p.eventData)
              return u = Y({}, p.eventData), !0;
          }, !0), u) {
            var h = u.componentType, d = u.componentIndex;
            (h === "markLine" || h === "markPoint" || h === "markArea") && (h = "series", d = u.seriesIndex);
            var f = h && d != null && o.getComponent(h, d), v = f && i[f.mainType === "series" ? "_chartsMap" : "_componentsMap"][f.__viewId];
            process.env.NODE_ENV !== "production" && !c && !(f && v) && hi("model or view can not be found by params"), u.event = s, u.type = r, i._$eventProcessor.eventInfo = {
              targetEl: l,
              packedEvent: u,
              model: f,
              view: v
            }, i.trigger(r, u);
          }
        };
        a.zrEventfulCallAtLast = !0, i._zr.on(r, a, i);
      });
      var n = this._messageCenter;
      E(Ff, function(r, a) {
        n.on(a, function(s) {
          i.trigger(a, s);
        });
      }), NN(n, this, this._api);
    }, t.prototype.isDisposed = function() {
      return this._disposed;
    }, t.prototype.clear = function() {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      this.setOption({
        series: []
      }, !0);
    }, t.prototype.dispose = function() {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      this._disposed = !0;
      var i = this.getDom();
      i && I1(this.getDom(), hp, "");
      var n = this, r = n._api, a = n._model;
      E(n._componentsViews, function(s) {
        s.dispose(a, r);
      }), E(n._chartsViews, function(s) {
        s.dispose(a, r);
      }), n._zr.dispose(), n._dom = n._model = n._chartsMap = n._componentsMap = n._chartsViews = n._componentsViews = n._scheduler = n._api = n._zr = n._throttledZrFlush = n._theme = n._coordSysMgr = n._messageCenter = null, delete xo[n.id];
    }, t.prototype.resize = function(i) {
      if (this[re]) {
        process.env.NODE_ENV !== "production" && Kt("`resize` should not be called during main process.");
        return;
      }
      if (this._disposed) {
        $e(this.id);
        return;
      }
      this._zr.resize(i);
      var n = this._model;
      if (this._loadingFX && this._loadingFX.resize(), !!n) {
        var r = n.resetOption("media"), a = i && i.silent;
        this[ve] && (a == null && (a = this[ve].silent), r = !0, this[ve] = null), this[re] = !0, Ia(this);
        try {
          r && Ir(this), un.update.call(this, {
            type: "resize",
            animation: Y({
              // Disable animation
              duration: 0
            }, i && i.animation)
          });
        } catch (s) {
          throw this[re] = !1, s;
        }
        this[re] = !1, La.call(this, a), Oa.call(this, a);
      }
    }, t.prototype.showLoading = function(i, n) {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      if (tt(i) && (n = i, i = ""), i = i || "default", this.hideLoading(), !zf[i]) {
        process.env.NODE_ENV !== "production" && hi("Loading effects " + i + " not exists.");
        return;
      }
      var r = zf[i](this._api, n), a = this._zr;
      this._loadingFX = r, a.add(r);
    }, t.prototype.hideLoading = function() {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      this._loadingFX && this._zr.remove(this._loadingFX), this._loadingFX = null;
    }, t.prototype.makeActionFromEvent = function(i) {
      var n = Y({}, i);
      return n.type = nc[i.type], n;
    }, t.prototype.dispatchAction = function(i, n) {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      if (tt(n) || (n = {
        silent: !!n
      }), !!ic[i.type] && this._model) {
        if (this[re]) {
          this._pendingActions.push(i);
          return;
        }
        var r = n.silent;
        yd.call(this, i, r);
        var a = n.flush;
        a ? this._zr.flush() : a !== !1 && ot.browser.weChat && this._throttledZrFlush(), La.call(this, r), Oa.call(this, r);
      }
    }, t.prototype.updateLabelLayout = function() {
      Mi.trigger("series:layoutlabels", this._model, this._api, {
        // Not adding series labels.
        // TODO
        updatedSeries: []
      });
    }, t.prototype.appendData = function(i) {
      if (this._disposed) {
        $e(this.id);
        return;
      }
      var n = i.seriesIndex, r = this.getModel(), a = r.getSeriesByIndex(n);
      process.env.NODE_ENV !== "production" && nt(i.data && a), a.appendData(i), this._scheduler.unfinished = !0, this.getZr().wakeUp();
    }, t.internalField = (function() {
      Ir = function(h) {
        var d = h._scheduler;
        d.restorePipelines(h._model), d.prepareStageTasks(), gd(h, !0), gd(h, !1), d.plan();
      }, gd = function(h, d) {
        for (var f = h._model, v = h._scheduler, m = d ? h._componentsViews : h._chartsViews, p = d ? h._componentsMap : h._chartsMap, g = h._zr, y = h._api, _ = 0; _ < m.length; _++)
          m[_].__alive = !1;
        d ? f.eachComponent(function(S, M) {
          S !== "series" && b(M);
        }) : f.eachSeries(b);
        function b(S) {
          var M = S.__requireNewView;
          S.__requireNewView = !1;
          var k = "_ec_" + S.id + "_" + S.type, T = !M && p[k];
          if (!T) {
            var D = ji(S.type), C = d ? En.getClass(D.main, D.sub) : (
              // FIXME:TS
              // (ChartView as ChartViewConstructor).getClass('series', classType.sub)
              // For backward compat, still support a chart type declared as only subType
              // like "liquidfill", but recommend "series.liquidfill"
              // But need a base class to make a type series.
              Jn.getClass(D.sub)
            );
            process.env.NODE_ENV !== "production" && nt(C, D.sub + " does not exist."), T = new C(), T.init(f, y), p[k] = T, m.push(T), g.add(T.group);
          }
          S.__viewId = T.__id = k, T.__alive = !0, T.__model = S, T.group.__ecComponentInfo = {
            mainType: S.mainType,
            index: S.componentIndex
          }, !d && v.prepareView(T, S, f, y);
        }
        for (var _ = 0; _ < m.length; ) {
          var w = m[_];
          w.__alive ? _++ : (!d && w.renderTask.dispose(), g.remove(w.group), w.dispose(f, y), m.splice(_, 1), p[w.__id] === w && delete p[w.__id], w.__id = w.group.__ecComponentInfo = null);
        }
      }, Gl = function(h, d, f, v, m) {
        var p = h._model;
        if (p.setUpdatePayload(f), !v) {
          E([].concat(h._componentsViews).concat(h._chartsViews), w);
          return;
        }
        var g = {};
        g[v + "Id"] = f[v + "Id"], g[v + "Index"] = f[v + "Index"], g[v + "Name"] = f[v + "Name"];
        var y = {
          mainType: v,
          query: g
        };
        m && (y.subType = m);
        var _ = f.excludeSeriesId, b;
        _ != null && (b = ht(), E(Ie(_), function(S) {
          var M = Ti(S, null);
          M != null && b.set(M, !0);
        })), p && p.eachComponent(y, function(S) {
          var M = b && b.get(S.id) != null;
          if (!M)
            if (L0(f))
              if (S instanceof sr)
                f.type === na && !f.notBlur && !S.get(["emphasis", "disabled"]) && nI(S, f, h._api);
              else {
                var k = $v(S.mainType, S.componentIndex, f.name, h._api), T = k.focusSelf, D = k.dispatchers;
                f.type === na && T && !f.notBlur && _f(S.mainType, S.componentIndex, h._api), D && E(D, function(C) {
                  f.type === na ? Yu(C) : Wu(C);
                });
              }
            else bf(f) && S instanceof sr && (sI(S, f, h._api), C0(S), ai(h));
        }, h), p && p.eachComponent(y, function(S) {
          var M = b && b.get(S.id) != null;
          M || w(h[v === "series" ? "_chartsMap" : "_componentsMap"][S.__viewId]);
        }, h);
        function w(S) {
          S && S.__alive && S[d] && S[d](S.__model, p, h._api, f);
        }
      }, un = {
        prepareAndUpdate: function(h) {
          Ir(this), un.update.call(this, h, h && {
            // Needs to mark option changed if newOption is given.
            // It's from MagicType.
            // TODO If use a separate flag optionChanged in payload?
            optionChanged: h.newOption != null
          });
        },
        update: function(h, d) {
          var f = this._model, v = this._api, m = this._zr, p = this._coordSysMgr, g = this._scheduler;
          if (f) {
            f.setUpdatePayload(h), g.restoreData(f, h), g.performSeriesTasks(f), p.create(f, v), g.performDataProcessorTasks(f, h), md(this, f), p.update(f, v), n(f), g.performVisualTasks(f, h);
            var y = f.get("backgroundColor") || "transparent";
            m.setBackgroundColor(y);
            var _ = f.get("darkMode");
            _ != null && _ !== "auto" && m.setDarkMode(_), _d(this, f, v, h, d), Mi.trigger("afterupdate", f, v);
          }
        },
        updateTransform: function(h) {
          var d = this, f = this._model, v = this._api;
          if (f) {
            f.setUpdatePayload(h);
            var m = [];
            f.eachComponent(function(g, y) {
              if (g !== "series") {
                var _ = d.getViewOfComponentModel(y);
                if (_ && _.__alive)
                  if (_.updateTransform) {
                    var b = _.updateTransform(y, f, v, h);
                    b && b.update && m.push(_);
                  } else
                    m.push(_);
              }
            });
            var p = ht();
            f.eachSeries(function(g) {
              var y = d._chartsMap[g.__viewId];
              if (y.updateTransform) {
                var _ = y.updateTransform(g, f, v, h);
                _ && _.update && p.set(g.uid, 1);
              } else
                p.set(g.uid, 1);
            }), n(f), this._scheduler.performVisualTasks(f, h, {
              setDirty: !0,
              dirtyMap: p
            }), jl(this, f, v, h, {}, p), Mi.trigger("afterupdate", f, v);
          }
        },
        updateView: function(h) {
          var d = this._model;
          d && (d.setUpdatePayload(h), Jn.markUpdateMethod(h, "updateView"), n(d), this._scheduler.performVisualTasks(d, h, {
            setDirty: !0
          }), _d(this, d, this._api, h, {}), Mi.trigger("afterupdate", d, this._api));
        },
        updateVisual: function(h) {
          var d = this, f = this._model;
          f && (f.setUpdatePayload(h), f.eachSeries(function(v) {
            v.getData().clearAllVisual();
          }), Jn.markUpdateMethod(h, "updateVisual"), n(f), this._scheduler.performVisualTasks(f, h, {
            visualType: "visual",
            setDirty: !0
          }), f.eachComponent(function(v, m) {
            if (v !== "series") {
              var p = d.getViewOfComponentModel(m);
              p && p.__alive && p.updateVisual(m, f, d._api, h);
            }
          }), f.eachSeries(function(v) {
            var m = d._chartsMap[v.__viewId];
            m.updateVisual(v, f, d._api, h);
          }), Mi.trigger("afterupdate", f, this._api));
        },
        updateLayout: function(h) {
          un.update.call(this, h);
        }
      };
      function i(h, d, f, v, m) {
        if (h._disposed) {
          $e(h.id);
          return;
        }
        for (var p = h._model, g = h._coordSysMgr.getCoordinateSystems(), y, _ = Fh(p, f), b = 0; b < g.length; b++) {
          var w = g[b];
          if (w[d] && (y = w[d](p, _, v, m)) != null)
            return y;
        }
        process.env.NODE_ENV !== "production" && hi("No coordinate system that supports " + d + " found by the given finder.");
      }
      Xl = i, md = function(h, d) {
        var f = h._chartsMap, v = h._scheduler;
        d.eachSeries(function(m) {
          v.updateStreamModes(m, f[m.__viewId]);
        });
      }, yd = function(h, d) {
        var f = this, v = this.getModel(), m = h.type, p = h.escapeConnect, g = ic[m], y = (g.update || "update").split(":"), _ = y.pop(), b = y[0] != null && ji(y[0]);
        this[re] = !0, Ia(this);
        var w = [h], S = !1;
        h.batch && (S = !0, w = _t(h.batch, function(B) {
          return B = Jt(Y({}, B), h), B.batch = null, B;
        }));
        var M = [], k, T = [], D = g.nonRefinedEventType, C = bf(h), P = L0(h);
        if (P && ex(this._api), E(w, function(B) {
          var G = g.action(B, v, f._api);
          if (g.refineEvent ? T.push(G) : k = G, k = k || Y({}, B), k.type = D, M.push(k), P) {
            var V = Av(h), F = V.queryOptionMap, $ = V.mainTypeSpecified, Z = $ ? F.keys()[0] : "series";
            Gl(f, _, B, Z), ai(f);
          } else C ? (Gl(f, _, B, "series"), ai(f)) : b && Gl(f, _, B, b.main, b.sub);
        }), _ !== "none" && !P && !C && !b)
          try {
            this[ve] ? (Ir(this), un.update.call(this, h), this[ve] = null) : un[_].call(this, h);
          } catch (B) {
            throw this[re] = !1, B;
          }
        if (S ? k = {
          type: D,
          escapeConnect: p,
          batch: M
        } : k = M[0], this[re] = !1, !d) {
          var L = void 0;
          if (g.refineEvent) {
            var O = g.refineEvent(T, h, v, this._api).eventContent;
            nt(tt(O)), L = Jt({
              type: g.refinedEventType
            }, O), L.fromAction = h.type, L.fromActionPayload = h, L.escapeConnect = !0;
          }
          var N = this._messageCenter;
          N.trigger(k.type, k), L && N.trigger(L.type, L);
        }
      }, La = function(h) {
        for (var d = this._pendingActions; d.length; ) {
          var f = d.shift();
          yd.call(this, f, h);
        }
      }, Oa = function(h) {
        !h && this.trigger("updated");
      }, jy = function(h, d) {
        h.on("rendered", function(f) {
          d.trigger("rendered", f), // Although zr is dirty if initial animation is not finished
          // and this checking is called on frame, we also check
          // animation finished for robustness.
          h.animation.isFinished() && !d[ve] && !d._scheduler.unfinished && !d._pendingActions.length && d.trigger("finished");
        });
      }, qy = function(h, d) {
        h.on("mouseover", function(f) {
          var v = f.target, m = ao(v, hs);
          m && (rI(m, f, d._api), ai(d));
        }).on("mouseout", function(f) {
          var v = f.target, m = ao(v, hs);
          m && (aI(m, f, d._api), ai(d));
        }).on("click", function(f) {
          var v = f.target, m = ao(v, function(y) {
            return Vt(y).dataIndex != null;
          }, !0);
          if (m) {
            var p = m.selected ? "unselect" : "select", g = Vt(m);
            d._api.dispatchAction({
              type: p,
              dataType: g.dataType,
              dataIndexInside: g.dataIndex,
              seriesIndex: g.seriesIndex,
              isFromClick: !0
            });
          }
        });
      };
      function n(h) {
        h.clearColorPalette(), h.eachSeries(function(d) {
          d.clearColorPalette();
        });
      }
      function r(h) {
        var d = [], f = [], v = !1;
        if (h.eachComponent(function(y, _) {
          var b = _.get("zlevel") || 0, w = _.get("z") || 0, S = _.getZLevelKey();
          v = v || !!S, (y === "series" ? f : d).push({
            zlevel: b,
            z: w,
            idx: _.componentIndex,
            type: y,
            key: S
          });
        }), v) {
          var m = d.concat(f), p, g;
          ru(m, function(y, _) {
            return y.zlevel === _.zlevel ? y.z - _.z : y.zlevel - _.zlevel;
          }), E(m, function(y) {
            var _ = h.getComponent(y.type, y.idx), b = y.zlevel, w = y.key;
            p != null && (b = Math.max(p, b)), w ? (b === p && w !== g && b++, g = w) : g && (b === p && b++, g = ""), p = b, _.setZLevel(b);
          });
        }
      }
      _d = function(h, d, f, v, m) {
        r(d), Zy(h, d, f, v, m), E(h._chartsViews, function(p) {
          p.__alive = !1;
        }), jl(h, d, f, v, m), E(h._chartsViews, function(p) {
          p.__alive || p.remove(d, f);
        });
      }, Zy = function(h, d, f, v, m, p) {
        E(p || h._componentsViews, function(g) {
          var y = g.__model;
          u(y, g), g.render(y, d, f, v), l(y, g), c(y, g);
        });
      }, jl = function(h, d, f, v, m, p) {
        var g = h._scheduler;
        m = Y(m || {}, {
          updatedSeries: d.getSeries()
        }), Mi.trigger("series:beforeupdate", d, f, m);
        var y = !1;
        d.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          b.__alive = !0;
          var w = b.renderTask;
          g.updatePayload(w, v), u(_, b), p && p.get(_.uid) && w.dirty(), w.perform(g.getPerformArgs(w)) && (y = !0), b.group.silent = !!_.get("silent"), o(_, b), C0(_);
        }), g.unfinished = y || g.unfinished, Mi.trigger("series:layoutlabels", d, f, m), Mi.trigger("series:transition", d, f, m), d.eachSeries(function(_) {
          var b = h._chartsMap[_.__viewId];
          l(_, b), c(_, b);
        }), s(h, d), Mi.trigger("series:afterupdate", d, f, m);
      }, ai = function(h) {
        h[vd] = !0, h.getZr().wakeUp();
      }, Ia = function(h) {
        h[Ul] = (h[Ul] + 1) % 1e3;
      }, Qy = function(h) {
        h[vd] && (h.getZr().storage.traverse(function(d) {
          _o(d) || a(d);
        }), h[vd] = !1);
      };
      function a(h) {
        for (var d = [], f = h.currentStates, v = 0; v < f.length; v++) {
          var m = f[v];
          m === "emphasis" || m === "blur" || m === "select" || d.push(m);
        }
        h.selected && h.states.select && d.push("select"), h.hoverState === Nv && h.states.emphasis ? d.push("emphasis") : h.hoverState === Rv && h.states.blur && d.push("blur"), h.useStates(d);
      }
      function s(h, d) {
        var f = h._zr, v = f.storage, m = 0;
        v.traverse(function(p) {
          p.isGroup || m++;
        }), m > d.get("hoverLayerThreshold") && !ot.node && !ot.worker && d.eachSeries(function(p) {
          if (!p.preventUsingHoverLayer) {
            var g = h._chartsMap[p.__viewId];
            g.__alive && g.eachRendered(function(y) {
              y.states.emphasis && (y.states.emphasis.hoverLayer = !0);
            });
          }
        });
      }
      function o(h, d) {
        var f = h.get("blendMode") || null;
        d.eachRendered(function(v) {
          v.isGroup || (v.style.blend = f);
        });
      }
      function l(h, d) {
        if (!h.preventAutoZ) {
          var f = Fo(h);
          d.eachRendered(function(v) {
            return _x(v, f.z, f.zlevel), !0;
          });
        }
      }
      function u(h, d) {
        d.eachRendered(function(f) {
          if (!_o(f)) {
            var v = f.getTextContent(), m = f.getTextGuideLine();
            f.stateTransition && (f.stateTransition = null), v && v.stateTransition && (v.stateTransition = null), m && m.stateTransition && (m.stateTransition = null), f.hasState() ? (f.prevStates = f.currentStates, f.clearStates()) : f.prevStates && (f.prevStates = null);
          }
        });
      }
      function c(h, d) {
        var f = h.getModel("stateAnimation"), v = h.isAnimationEnabled(), m = f.get("duration"), p = m > 0 ? {
          duration: m,
          delay: f.get("delay"),
          easing: f.get("easing")
          // additive: stateAnimationModel.get('additive')
        } : null;
        d.eachRendered(function(g) {
          if (g.states && g.states.emphasis) {
            if (_o(g))
              return;
            if (g instanceof $t && fI(g), g.__dirty) {
              var y = g.prevStates;
              y && g.useStates(y);
            }
            if (v) {
              g.stateTransition = p;
              var _ = g.getTextContent(), b = g.getTextGuideLine();
              _ && (_.stateTransition = p), b && (b.stateTransition = p);
            }
            g.__dirty && a(g);
          }
        });
      }
      Ky = function(h) {
        return new /** @class */
        ((function(d) {
          oe(f, d);
          function f() {
            return d !== null && d.apply(this, arguments) || this;
          }
          return f.prototype.getCoordinateSystems = function() {
            return h._coordSysMgr.getCoordinateSystems();
          }, f.prototype.getComponentByElement = function(v) {
            for (; v; ) {
              var m = v.__ecComponentInfo;
              if (m != null)
                return h._model.getComponent(m.mainType, m.index);
              v = v.parent;
            }
          }, f.prototype.enterEmphasis = function(v, m) {
            Yu(v, m), ai(h);
          }, f.prototype.leaveEmphasis = function(v, m) {
            Wu(v, m), ai(h);
          }, f.prototype.enterBlur = function(v) {
            iI(v), ai(h);
          }, f.prototype.leaveBlur = function(v) {
            K1(v), ai(h);
          }, f.prototype.enterSelect = function(v) {
            Q1(v), ai(h);
          }, f.prototype.leaveSelect = function(v) {
            J1(v), ai(h);
          }, f.prototype.getModel = function() {
            return h.getModel();
          }, f.prototype.getViewOfComponentModel = function(v) {
            return h.getViewOfComponentModel(v);
          }, f.prototype.getViewOfSeriesModel = function(v) {
            return h.getViewOfSeriesModel(v);
          }, f.prototype.getMainProcessVersion = function() {
            return h[Ul];
          }, f;
        })(Bx))(h);
      }, Cw = function(h) {
        function d(f, v) {
          for (var m = 0; m < f.length; m++) {
            var p = f[m];
            p[pd] = v;
          }
        }
        E(nc, function(f, v) {
          h._messageCenter.on(v, function(m) {
            if (Jy[h.group] && h[pd] !== Xy) {
              if (m && m.escapeConnect)
                return;
              var p = h.makeActionFromEvent(m), g = [];
              E(xo, function(y) {
                y !== h && y.group === h.group && g.push(y);
              }), d(g, Xy), E(g, function(y) {
                y[pd] !== kF && y.dispatchAction(p);
              }), d(g, DF);
            }
          });
        });
      };
    })(), t;
  })(Li)
), cp = Ew.prototype;
cp.on = Sw("on");
cp.off = Sw("off");
cp.one = function(e, t, i) {
  var n = this;
  Cn("ECharts#one is deprecated.");
  function r() {
    for (var a = [], s = 0; s < arguments.length; s++)
      a[s] = arguments[s];
    t && t.apply && t.apply(this, a), n.off(e, r);
  }
  this.on.call(this, e, r, i);
};
var TF = ["click", "dblclick", "mouseover", "mouseout", "mousemove", "mousedown", "mouseup", "globalout", "contextmenu"];
function $e(e) {
  process.env.NODE_ENV !== "production" && hi("Instance " + e + " has been disposed");
}
var ic = {}, nc = {}, Ff = {}, Bf = [], $f = [], rc = [], Aw = {}, zf = {}, xo = {}, Jy = {}, CF = +/* @__PURE__ */ new Date() - 0, hp = "_echarts_instance_";
function EF(e, t, i) {
  {
    if (process.env.NODE_ENV !== "production" && !e)
      throw new Error("Initialize failed: invalid dom.");
    var n = AF(e);
    if (n)
      return process.env.NODE_ENV !== "production" && hi("There is a chart instance already initialized on the dom."), n;
    process.env.NODE_ENV !== "production" && ss(e) && e.nodeName.toUpperCase() !== "CANVAS" && (!e.clientWidth && !i || !e.clientHeight && !i) && hi("Can't get DOM width or height. Please check dom.clientWidth and dom.clientHeight. They should not be 0.For example, you may need to call this in the callback of window.onload.");
  }
  var r = new Ew(e, t, i);
  return r.id = "ec_" + CF++, xo[r.id] = r, I1(e, hp, r.id), Cw(r), Mi.trigger("afterinit", r), r;
}
function AF(e) {
  return xo[WL(e, hp)];
}
function Pw(e, t) {
  Aw[e] = t;
}
function Lw(e) {
  Ht($f, e) < 0 && $f.push(e);
}
function Ow(e, t) {
  fp(Bf, e, t, mF);
}
function PF(e) {
  dp("afterinit", e);
}
function LF(e) {
  dp("afterupdate", e);
}
function dp(e, t) {
  Mi.on(e, t);
}
function fa(e, t, i) {
  var n, r, a, s, o;
  mt(t) && (i = t, t = ""), tt(e) ? (n = e.type, r = e.event, s = e.update, o = e.publishNonRefinedEvent, i || (i = e.action), a = e.refineEvent) : (n = e, r = t);
  function l(c) {
    return c.toLowerCase();
  }
  r = l(r || n);
  var u = a ? l(n) : r;
  ic[n] || (nt(Gy.test(n) && Gy.test(r)), a && nt(r !== n), ic[n] = {
    actionType: n,
    refinedEventType: r,
    nonRefinedEventType: u,
    update: s,
    action: i,
    refineEvent: a
  }, Ff[r] = 1, a && o && (Ff[u] = 1), process.env.NODE_ENV !== "production" && nc[u] && Kt(u + ' must not be shared; use "refineEvent" if you intend to share an event name.'), nc[u] = n);
}
function OF(e, t) {
  Bc.register(e, t);
}
function IF(e, t) {
  fp(rc, e, t, bw, "layout");
}
function va(e, t) {
  fp(rc, e, t, xw, "visual");
}
var t_ = [];
function fp(e, t, i, n, r) {
  if ((mt(t) || tt(t)) && (i = t, t = n), process.env.NODE_ENV !== "production") {
    if (isNaN(t) || t == null)
      throw new Error("Illegal priority");
    E(e, function(s) {
      nt(s.__raw !== i);
    });
  }
  if (!(Ht(t_, i) >= 0)) {
    t_.push(i);
    var a = ow.wrapStageHandler(i, r);
    a.__prio = t, a.__raw = i, e.push(a);
  }
}
function Iw(e, t) {
  zf[e] = t;
}
function RF(e, t, i) {
  var n = dF("registerMap");
  n && n(e, t, i);
}
var NF = z5;
va(up, mN);
va(Vc, yN);
va(Vc, _N);
va(up, LN);
va(Vc, ON);
va(ww, cF);
Lw(zx);
Ow(pF, x5);
Iw("default", bN);
fa({
  type: na,
  event: na,
  update: na
}, ke);
fa({
  type: uu,
  event: uu,
  update: uu
}, ke);
fa({
  type: Vu,
  event: Fv,
  update: Vu,
  action: ke,
  refineEvent: vp,
  publishNonRefinedEvent: !0
});
fa({
  type: mf,
  event: Fv,
  update: mf,
  action: ke,
  refineEvent: vp,
  publishNonRefinedEvent: !0
});
fa({
  type: Hu,
  event: Fv,
  update: Hu,
  action: ke,
  refineEvent: vp,
  publishNonRefinedEvent: !0
});
function vp(e, t, i, n) {
  return {
    eventContent: {
      selected: oI(i),
      isFromClick: t.isFromClick || !1
    }
  };
}
Pw("default", {});
Pw("dark", hw);
function Fs(e) {
  return e == null ? 0 : e.length || 1;
}
function e_(e) {
  return e;
}
var FF = (
  /** @class */
  (function() {
    function e(t, i, n, r, a, s) {
      this._old = t, this._new = i, this._oldKeyGetter = n || e_, this._newKeyGetter = r || e_, this.context = a, this._diffModeMultiple = s === "multiple";
    }
    return e.prototype.add = function(t) {
      return this._add = t, this;
    }, e.prototype.update = function(t) {
      return this._update = t, this;
    }, e.prototype.updateManyToOne = function(t) {
      return this._updateManyToOne = t, this;
    }, e.prototype.updateOneToMany = function(t) {
      return this._updateOneToMany = t, this;
    }, e.prototype.updateManyToMany = function(t) {
      return this._updateManyToMany = t, this;
    }, e.prototype.remove = function(t) {
      return this._remove = t, this;
    }, e.prototype.execute = function() {
      this[this._diffModeMultiple ? "_executeMultiple" : "_executeOneToOne"]();
    }, e.prototype._executeOneToOne = function() {
      var t = this._old, i = this._new, n = {}, r = new Array(t.length), a = new Array(i.length);
      this._initIndexMap(t, null, r, "_oldKeyGetter"), this._initIndexMap(i, n, a, "_newKeyGetter");
      for (var s = 0; s < t.length; s++) {
        var o = r[s], l = n[o], u = Fs(l);
        if (u > 1) {
          var c = l.shift();
          l.length === 1 && (n[o] = l[0]), this._update && this._update(c, s);
        } else u === 1 ? (n[o] = null, this._update && this._update(l, s)) : this._remove && this._remove(s);
      }
      this._performRestAdd(a, n);
    }, e.prototype._executeMultiple = function() {
      var t = this._old, i = this._new, n = {}, r = {}, a = [], s = [];
      this._initIndexMap(t, n, a, "_oldKeyGetter"), this._initIndexMap(i, r, s, "_newKeyGetter");
      for (var o = 0; o < a.length; o++) {
        var l = a[o], u = n[l], c = r[l], h = Fs(u), d = Fs(c);
        if (h > 1 && d === 1)
          this._updateManyToOne && this._updateManyToOne(c, u), r[l] = null;
        else if (h === 1 && d > 1)
          this._updateOneToMany && this._updateOneToMany(c, u), r[l] = null;
        else if (h === 1 && d === 1)
          this._update && this._update(c, u), r[l] = null;
        else if (h > 1 && d > 1)
          this._updateManyToMany && this._updateManyToMany(c, u), r[l] = null;
        else if (h > 1)
          for (var f = 0; f < h; f++)
            this._remove && this._remove(u[f]);
        else
          this._remove && this._remove(u);
      }
      this._performRestAdd(s, r);
    }, e.prototype._performRestAdd = function(t, i) {
      for (var n = 0; n < t.length; n++) {
        var r = t[n], a = i[r], s = Fs(a);
        if (s > 1)
          for (var o = 0; o < s; o++)
            this._add && this._add(a[o]);
        else s === 1 && this._add && this._add(a);
        i[r] = null;
      }
    }, e.prototype._initIndexMap = function(t, i, n, r) {
      for (var a = this._diffModeMultiple, s = 0; s < t.length; s++) {
        var o = "_ec_" + this[r](t[s], s);
        if (a || (n[s] = o), !!i) {
          var l = i[o], u = Fs(l);
          u === 0 ? (i[o] = s, a && n.push(o)) : u === 1 ? i[o] = [l, s] : l.push(s);
        }
      }
    }, e;
  })()
), BF = (
  /** @class */
  (function() {
    function e(t, i) {
      this._encode = t, this._schema = i;
    }
    return e.prototype.get = function() {
      return {
        // Do not generate full dimension name until fist used.
        fullDimensions: this._getFullDimensionNames(),
        encode: this._encode
      };
    }, e.prototype._getFullDimensionNames = function() {
      return this._cachedDimNames || (this._cachedDimNames = this._schema ? this._schema.makeOutputDimensionNames() : []), this._cachedDimNames;
    }, e;
  })()
);
function $F(e, t) {
  var i = {}, n = i.encode = {}, r = ht(), a = [], s = [], o = {};
  E(e.dimensions, function(d) {
    var f = e.getDimensionInfo(d), v = f.coordDim;
    if (v) {
      process.env.NODE_ENV !== "production" && nt(Df.get(v) == null);
      var m = f.coordDimIndex;
      bd(n, v)[m] = d, f.isExtraCoord || (r.set(v, 1), VF(f.type) && (a[0] = d), bd(o, v)[m] = e.getDimensionIndex(f.name)), f.defaultTooltip && s.push(d);
    }
    Df.each(function(p, g) {
      var y = bd(n, g), _ = f.otherDims[g];
      _ != null && _ !== !1 && (y[_] = f.name);
    });
  });
  var l = [], u = {};
  r.each(function(d, f) {
    var v = n[f];
    u[f] = v[0], l = l.concat(v);
  }), i.dataDimsOnCoord = l, i.dataDimIndicesOnCoord = _t(l, function(d) {
    return e.getDimensionInfo(d).storeDimIndex;
  }), i.encodeFirstDimNotExtra = u;
  var c = n.label;
  c && c.length && (a = c.slice());
  var h = n.tooltip;
  return h && h.length ? s = h.slice() : s.length || (s = a.slice()), n.defaultedLabel = a, n.defaultedTooltip = s, i.userOutput = new BF(o, t), i;
}
function bd(e, t) {
  return e.hasOwnProperty(t) || (e[t] = []), e[t];
}
function zF(e) {
  return e === "category" ? "ordinal" : e === "time" ? "time" : "float";
}
function VF(e) {
  return !(e === "ordinal" || e === "time");
}
var fu = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.otherDims = {}, t != null && Y(this, t);
    }
    return e;
  })()
), HF = Gt(), YF = {
  float: "f",
  int: "i",
  ordinal: "o",
  number: "n",
  time: "t"
}, Rw = (
  /** @class */
  (function() {
    function e(t) {
      this.dimensions = t.dimensions, this._dimOmitted = t.dimensionOmitted, this.source = t.source, this._fullDimCount = t.fullDimensionCount, this._updateDimOmitted(t.dimensionOmitted);
    }
    return e.prototype.isDimensionOmitted = function() {
      return this._dimOmitted;
    }, e.prototype._updateDimOmitted = function(t) {
      this._dimOmitted = t, t && (this._dimNameMap || (this._dimNameMap = Bw(this.source)));
    }, e.prototype.getSourceDimensionIndex = function(t) {
      return rt(this._dimNameMap.get(t), -1);
    }, e.prototype.getSourceDimension = function(t) {
      var i = this.source.dimensionsDefine;
      if (i)
        return i[t];
    }, e.prototype.makeStoreSchema = function() {
      for (var t = this._fullDimCount, i = Hx(this.source), n = !$w(t), r = "", a = [], s = 0, o = 0; s < t; s++) {
        var l = void 0, u = void 0, c = void 0, h = this.dimensions[o];
        if (h && h.storeDimIndex === s)
          l = i ? h.name : null, u = h.type, c = h.ordinalMeta, o++;
        else {
          var d = this.getSourceDimension(s);
          d && (l = i ? d.name : null, u = d.type);
        }
        a.push({
          property: l,
          type: u,
          ordinalMeta: c
        }), i && l != null && (!h || !h.isCalculationCoord) && (r += n ? l.replace(/\`/g, "`1").replace(/\$/g, "`2") : l), r += "$", r += YF[u] || "f", c && (r += c.uid), r += "$";
      }
      var f = this.source, v = [f.seriesLayoutBy, f.startIndex, r].join("$$");
      return {
        dimensions: a,
        hash: v
      };
    }, e.prototype.makeOutputDimensionNames = function() {
      for (var t = [], i = 0, n = 0; i < this._fullDimCount; i++) {
        var r = void 0, a = this.dimensions[n];
        if (a && a.storeDimIndex === i)
          a.isCalculationCoord || (r = a.name), n++;
        else {
          var s = this.getSourceDimension(i);
          s && (r = s.name);
        }
        t.push(r);
      }
      return t;
    }, e.prototype.appendCalculationDimension = function(t) {
      this.dimensions.push(t), t.isCalculationCoord = !0, this._fullDimCount++, this._updateDimOmitted(!0);
    }, e;
  })()
);
function Nw(e) {
  return e instanceof Rw;
}
function Fw(e) {
  for (var t = ht(), i = 0; i < (e || []).length; i++) {
    var n = e[i], r = tt(n) ? n.name : n;
    r != null && t.get(r) == null && t.set(r, i);
  }
  return t;
}
function Bw(e) {
  var t = HF(e);
  return t.dimNameMap || (t.dimNameMap = Fw(e.dimensionsDefine));
}
function $w(e) {
  return e > 30;
}
var Bs = tt, $n = _t, WF = typeof Int32Array > "u" ? Array : Int32Array, UF = "e\0\0", i_ = -1, GF = ["hasItemOption", "_nameList", "_idList", "_invertedIndicesMap", "_dimSummary", "userOutput", "_rawData", "_dimValueGetter", "_nameDimIdx", "_idDimIdx", "_nameRepeatCount"], XF = ["_approximateExtent"], n_, ql, $s, Ra, xd, zs, wd, Vf = (
  /** @class */
  (function() {
    function e(t, i) {
      this.type = "list", this._dimOmitted = !1, this._nameList = [], this._idList = [], this._visual = {}, this._layout = {}, this._itemVisuals = [], this._itemLayouts = [], this._graphicEls = [], this._approximateExtent = {}, this._calculationInfo = {}, this.hasItemOption = !1, this.TRANSFERABLE_METHODS = ["cloneShallow", "downSample", "minmaxDownSample", "lttbDownSample", "map"], this.CHANGABLE_METHODS = ["filterSelf", "selectRange"], this.DOWNSAMPLE_METHODS = ["downSample", "minmaxDownSample", "lttbDownSample"];
      var n, r = !1;
      Nw(t) ? (n = t.dimensions, this._dimOmitted = t.isDimensionOmitted(), this._schema = t) : (r = !0, n = t), n = n || ["x", "y"];
      for (var a = {}, s = [], o = {}, l = !1, u = {}, c = 0; c < n.length; c++) {
        var h = n[c], d = et(h) ? new fu({
          name: h
        }) : h instanceof fu ? h : new fu(h), f = d.name;
        d.type = d.type || "float", d.coordDim || (d.coordDim = f, d.coordDimIndex = 0);
        var v = d.otherDims = d.otherDims || {};
        s.push(f), a[f] = d, u[f] != null && (l = !0), d.createInvertedIndices && (o[f] = []);
        var m = c;
        Zt(d.storeDimIndex) && (m = d.storeDimIndex), v.itemName === 0 && (this._nameDimIdx = m), v.itemId === 0 && (this._idDimIdx = m), process.env.NODE_ENV !== "production" && nt(r || d.storeDimIndex >= 0), r && (d.storeDimIndex = c);
      }
      if (this.dimensions = s, this._dimInfos = a, this._initGetDimensionInfo(l), this.hostModel = i, this._invertedIndicesMap = o, this._dimOmitted) {
        var p = this._dimIdxToName = ht();
        E(s, function(g) {
          p.set(a[g].storeDimIndex, g);
        });
      }
    }
    return e.prototype.getDimension = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i == null)
        return t;
      if (i = t, !this._dimOmitted)
        return this.dimensions[i];
      var n = this._dimIdxToName.get(i);
      if (n != null)
        return n;
      var r = this._schema.getSourceDimension(i);
      if (r)
        return r.name;
    }, e.prototype.getDimensionIndex = function(t) {
      var i = this._recognizeDimIndex(t);
      if (i != null)
        return i;
      if (t == null)
        return -1;
      var n = this._getDimInfo(t);
      return n ? n.storeDimIndex : this._dimOmitted ? this._schema.getSourceDimensionIndex(t) : -1;
    }, e.prototype._recognizeDimIndex = function(t) {
      if (Zt(t) || t != null && !isNaN(t) && !this._getDimInfo(t) && (!this._dimOmitted || this._schema.getSourceDimensionIndex(t) < 0))
        return +t;
    }, e.prototype._getStoreDimIndex = function(t) {
      var i = this.getDimensionIndex(t);
      if (process.env.NODE_ENV !== "production" && i == null)
        throw new Error("Unknown dimension " + t);
      return i;
    }, e.prototype.getDimensionInfo = function(t) {
      return this._getDimInfo(this.getDimension(t));
    }, e.prototype._initGetDimensionInfo = function(t) {
      var i = this._dimInfos;
      this._getDimInfo = t ? function(n) {
        return i.hasOwnProperty(n) ? i[n] : void 0;
      } : function(n) {
        return i[n];
      };
    }, e.prototype.getDimensionsOnCoord = function() {
      return this._dimSummary.dataDimsOnCoord.slice();
    }, e.prototype.mapDimension = function(t, i) {
      var n = this._dimSummary;
      if (i == null)
        return n.encodeFirstDimNotExtra[t];
      var r = n.encode[t];
      return r ? r[i] : null;
    }, e.prototype.mapDimensionsAll = function(t) {
      var i = this._dimSummary, n = i.encode[t];
      return (n || []).slice();
    }, e.prototype.getStore = function() {
      return this._store;
    }, e.prototype.initData = function(t, i, n) {
      var r = this, a;
      if (t instanceof Cf && (a = t), !a) {
        var s = this.dimensions, o = sp(t) || Xe(t) ? new Yx(t, s.length) : t;
        a = new Cf();
        var l = $n(s, function(u) {
          return {
            type: r._dimInfos[u].type,
            property: u
          };
        });
        a.initData(o, l, n);
      }
      this._store = a, this._nameList = (i || []).slice(), this._idList = [], this._nameRepeatCount = {}, this._doInit(0, a.count()), this._dimSummary = $F(this, this._schema), this.userOutput = this._dimSummary.userOutput;
    }, e.prototype.appendData = function(t) {
      var i = this._store.appendData(t);
      this._doInit(i[0], i[1]);
    }, e.prototype.appendValues = function(t, i) {
      var n = this._store.appendValues(t, i && i.length), r = n.start, a = n.end, s = this._shouldMakeIdFromName();
      if (this._updateOrdinalMeta(), i)
        for (var o = r; o < a; o++) {
          var l = o - r;
          this._nameList[o] = i[l], s && wd(this, o);
        }
    }, e.prototype._updateOrdinalMeta = function() {
      for (var t = this._store, i = this.dimensions, n = 0; n < i.length; n++) {
        var r = this._dimInfos[i[n]];
        r.ordinalMeta && t.collectOrdinalMeta(r.storeDimIndex, r.ordinalMeta);
      }
    }, e.prototype._shouldMakeIdFromName = function() {
      var t = this._store.getProvider();
      return this._idDimIdx == null && t.getSource().sourceFormat !== Mn && !t.fillStorage;
    }, e.prototype._doInit = function(t, i) {
      if (!(t >= i)) {
        var n = this._store, r = n.getProvider();
        this._updateOrdinalMeta();
        var a = this._nameList, s = this._idList, o = r.getSource().sourceFormat, l = o === ti;
        if (l && !r.pure)
          for (var u = [], c = t; c < i; c++) {
            var h = r.getItem(c, u);
            if (!this.hasItemOption && OL(h) && (this.hasItemOption = !0), h) {
              var d = h.name;
              a[c] == null && d != null && (a[c] = Ti(d, null));
              var f = h.id;
              s[c] == null && f != null && (s[c] = Ti(f, null));
            }
          }
        if (this._shouldMakeIdFromName())
          for (var c = t; c < i; c++)
            wd(this, c);
        n_(this);
      }
    }, e.prototype.getApproximateExtent = function(t) {
      return this._approximateExtent[t] || this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.setApproximateExtent = function(t, i) {
      i = this.getDimension(i), this._approximateExtent[i] = t.slice();
    }, e.prototype.getCalculationInfo = function(t) {
      return this._calculationInfo[t];
    }, e.prototype.setCalculationInfo = function(t, i) {
      Bs(t) ? Y(this._calculationInfo, t) : this._calculationInfo[t] = i;
    }, e.prototype.getName = function(t) {
      var i = this.getRawIndex(t), n = this._nameList[i];
      return n == null && this._nameDimIdx != null && (n = $s(this, this._nameDimIdx, i)), n == null && (n = ""), n;
    }, e.prototype._getCategory = function(t, i) {
      var n = this._store.get(t, i), r = this._store.getOrdinalMeta(t);
      return r ? r.categories[n] : n;
    }, e.prototype.getId = function(t) {
      return ql(this, this.getRawIndex(t));
    }, e.prototype.count = function() {
      return this._store.count();
    }, e.prototype.get = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.get(r.storeDimIndex, i);
    }, e.prototype.getByRawIndex = function(t, i) {
      var n = this._store, r = this._dimInfos[t];
      if (r)
        return n.getByRawIndex(r.storeDimIndex, i);
    }, e.prototype.getIndices = function() {
      return this._store.getIndices();
    }, e.prototype.getDataExtent = function(t) {
      return this._store.getDataExtent(this._getStoreDimIndex(t));
    }, e.prototype.getSum = function(t) {
      return this._store.getSum(this._getStoreDimIndex(t));
    }, e.prototype.getMedian = function(t) {
      return this._store.getMedian(this._getStoreDimIndex(t));
    }, e.prototype.getValues = function(t, i) {
      var n = this, r = this._store;
      return K(t) ? r.getValues($n(t, function(a) {
        return n._getStoreDimIndex(a);
      }), i) : r.getValues(t);
    }, e.prototype.hasValue = function(t) {
      for (var i = this._dimSummary.dataDimIndicesOnCoord, n = 0, r = i.length; n < r; n++)
        if (isNaN(this._store.get(i[n], t)))
          return !1;
      return !0;
    }, e.prototype.indexOfName = function(t) {
      for (var i = 0, n = this._store.count(); i < n; i++)
        if (this.getName(i) === t)
          return i;
      return -1;
    }, e.prototype.getRawIndex = function(t) {
      return this._store.getRawIndex(t);
    }, e.prototype.indexOfRawIndex = function(t) {
      return this._store.indexOfRawIndex(t);
    }, e.prototype.rawIndexOf = function(t, i) {
      var n = t && this._invertedIndicesMap[t];
      if (process.env.NODE_ENV !== "production" && !n)
        throw new Error("Do not supported yet");
      var r = n && n[i];
      return r == null || isNaN(r) ? i_ : r;
    }, e.prototype.each = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []);
      var r = n || this, a = $n(Ra(t), this._getStoreDimIndex, this);
      this._store.each(a, r ? Dt(i, r) : i);
    }, e.prototype.filterSelf = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []);
      var r = n || this, a = $n(Ra(t), this._getStoreDimIndex, this);
      return this._store = this._store.filter(a, r ? Dt(i, r) : i), this;
    }, e.prototype.selectRange = function(t) {
      var i = this, n = {}, r = qt(t);
      return E(r, function(a) {
        var s = i._getStoreDimIndex(a);
        n[s] = t[a];
      }), this._store = this._store.selectRange(n), this;
    }, e.prototype.mapArray = function(t, i, n) {
      mt(t) && (n = i, i = t, t = []), n = n || this;
      var r = [];
      return this.each(t, function() {
        r.push(i && i.apply(this, arguments));
      }, n), r;
    }, e.prototype.map = function(t, i, n, r) {
      var a = n || r || this, s = $n(Ra(t), this._getStoreDimIndex, this), o = zs(this);
      return o._store = this._store.map(s, a ? Dt(i, a) : i), o;
    }, e.prototype.modify = function(t, i, n, r) {
      var a = this, s = n || r || this;
      process.env.NODE_ENV !== "production" && E(Ra(t), function(l) {
        var u = a.getDimensionInfo(l);
        u.isCalculationCoord || console.error("Danger: only stack dimension can be modified");
      });
      var o = $n(Ra(t), this._getStoreDimIndex, this);
      this._store.modify(o, s ? Dt(i, s) : i);
    }, e.prototype.downSample = function(t, i, n, r) {
      var a = zs(this);
      return a._store = this._store.downSample(this._getStoreDimIndex(t), i, n, r), a;
    }, e.prototype.minmaxDownSample = function(t, i) {
      var n = zs(this);
      return n._store = this._store.minmaxDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.lttbDownSample = function(t, i) {
      var n = zs(this);
      return n._store = this._store.lttbDownSample(this._getStoreDimIndex(t), i), n;
    }, e.prototype.getRawDataItem = function(t) {
      return this._store.getRawDataItem(t);
    }, e.prototype.getItemModel = function(t) {
      var i = this.hostModel, n = this.getRawDataItem(t);
      return new jt(n, i, i && i.ecModel);
    }, e.prototype.diff = function(t) {
      var i = this;
      return new FF(t ? t.getStore().getIndices() : [], this.getStore().getIndices(), function(n) {
        return ql(t, n);
      }, function(n) {
        return ql(i, n);
      });
    }, e.prototype.getVisual = function(t) {
      var i = this._visual;
      return i && i[t];
    }, e.prototype.setVisual = function(t, i) {
      this._visual = this._visual || {}, Bs(t) ? Y(this._visual, t) : this._visual[t] = i;
    }, e.prototype.getItemVisual = function(t, i) {
      var n = this._itemVisuals[t], r = n && n[i];
      return r ?? this.getVisual(i);
    }, e.prototype.hasItemVisual = function() {
      return this._itemVisuals.length > 0;
    }, e.prototype.ensureUniqueItemVisual = function(t, i) {
      var n = this._itemVisuals, r = n[t];
      r || (r = n[t] = {});
      var a = r[i];
      return a == null && (a = this.getVisual(i), K(a) ? a = a.slice() : Bs(a) && (a = Y({}, a)), r[i] = a), a;
    }, e.prototype.setItemVisual = function(t, i, n) {
      var r = this._itemVisuals[t] || {};
      this._itemVisuals[t] = r, Bs(i) ? Y(r, i) : r[i] = n;
    }, e.prototype.clearAllVisual = function() {
      this._visual = {}, this._itemVisuals = [];
    }, e.prototype.setLayout = function(t, i) {
      Bs(t) ? Y(this._layout, t) : this._layout[t] = i;
    }, e.prototype.getLayout = function(t) {
      return this._layout[t];
    }, e.prototype.getItemLayout = function(t) {
      return this._itemLayouts[t];
    }, e.prototype.setItemLayout = function(t, i, n) {
      this._itemLayouts[t] = n ? Y(this._itemLayouts[t] || {}, i) : i;
    }, e.prototype.clearItemLayouts = function() {
      this._itemLayouts.length = 0;
    }, e.prototype.setItemGraphicEl = function(t, i) {
      var n = this.hostModel && this.hostModel.seriesIndex;
      GO(n, this.dataType, t, i), this._graphicEls[t] = i;
    }, e.prototype.getItemGraphicEl = function(t) {
      return this._graphicEls[t];
    }, e.prototype.eachItemGraphicEl = function(t, i) {
      E(this._graphicEls, function(n, r) {
        n && t && t.call(i, n, r);
      });
    }, e.prototype.cloneShallow = function(t) {
      return t || (t = new e(this._schema ? this._schema : $n(this.dimensions, this._getDimInfo, this), this.hostModel)), xd(t, this), t._store = this._store, t;
    }, e.prototype.wrapMethod = function(t, i) {
      var n = this[t];
      mt(n) && (this.__wrappedMethods = this.__wrappedMethods || [], this.__wrappedMethods.push(t), this[t] = function() {
        var r = n.apply(this, arguments);
        return i.apply(this, [r].concat(Sv(arguments)));
      });
    }, e.internalField = (function() {
      n_ = function(t) {
        var i = t._invertedIndicesMap;
        E(i, function(n, r) {
          var a = t._dimInfos[r], s = a.ordinalMeta, o = t._store;
          if (s) {
            n = i[r] = new WF(s.categories.length);
            for (var l = 0; l < n.length; l++)
              n[l] = i_;
            for (var l = 0; l < o.count(); l++)
              n[o.get(a.storeDimIndex, l)] = l;
          }
        });
      }, $s = function(t, i, n) {
        return Ti(t._getCategory(i, n), null);
      }, ql = function(t, i) {
        var n = t._idList[i];
        return n == null && t._idDimIdx != null && (n = $s(t, t._idDimIdx, i)), n == null && (n = UF + i), n;
      }, Ra = function(t) {
        return K(t) || (t = t != null ? [t] : []), t;
      }, zs = function(t) {
        var i = new e(t._schema ? t._schema : $n(t.dimensions, t._getDimInfo, t), t.hostModel);
        return xd(i, t), i;
      }, xd = function(t, i) {
        E(GF.concat(i.__wrappedMethods || []), function(n) {
          i.hasOwnProperty(n) && (t[n] = i[n]);
        }), t.__wrappedMethods = i.__wrappedMethods, E(XF, function(n) {
          t[n] = pt(i[n]);
        }), t._calculationInfo = Y({}, i._calculationInfo);
      }, wd = function(t, i) {
        var n = t._nameList, r = t._idList, a = t._nameDimIdx, s = t._idDimIdx, o = n[i], l = r[i];
        if (o == null && a != null && (n[i] = o = $s(t, a, i)), l == null && s != null && (r[i] = l = $s(t, s, i)), l == null && o != null) {
          var u = t._nameRepeatCount, c = u[o] = (u[o] || 0) + 1;
          l = o, c > 1 && (l += "__ec__" + c), r[i] = l;
        }
      };
    })(), e;
  })()
);
function zw(e, t) {
  sp(e) || (e = op(e)), t = t || {};
  var i = t.coordDimensions || [], n = t.dimensionsDefine || e.dimensionsDefine || [], r = ht(), a = [], s = qF(e, i, n, t.dimensionsCount), o = t.canOmitUnusedDimensions && $w(s), l = n === e.dimensionsDefine, u = l ? Bw(e) : Fw(n), c = t.encodeDefine;
  !c && t.encodeDefaulter && (c = t.encodeDefaulter(e, s));
  for (var h = ht(c), d = new jx(s), f = 0; f < d.length; f++)
    d[f] = -1;
  function v(T) {
    var D = d[T];
    if (D < 0) {
      var C = n[T], P = tt(C) ? C : {
        name: C
      }, L = new fu(), O = P.name;
      O != null && u.get(O) != null && (L.name = L.displayName = O), P.type != null && (L.type = P.type), P.displayName != null && (L.displayName = P.displayName);
      var N = a.length;
      return d[T] = N, L.storeDimIndex = T, a.push(L), L;
    }
    return a[D];
  }
  if (!o)
    for (var f = 0; f < s; f++)
      v(f);
  h.each(function(T, D) {
    var C = Ie(T).slice();
    if (C.length === 1 && !et(C[0]) && C[0] < 0) {
      h.set(D, !1);
      return;
    }
    var P = h.set(D, []);
    E(C, function(L, O) {
      var N = et(L) ? u.get(L) : L;
      N != null && N < s && (P[O] = N, p(v(N), D, O));
    });
  });
  var m = 0;
  E(i, function(T) {
    var D, C, P, L;
    if (et(T))
      D = T, L = {};
    else {
      L = T, D = L.name;
      var O = L.ordinalMeta;
      L.ordinalMeta = null, L = Y({}, L), L.ordinalMeta = O, C = L.dimsDef, P = L.otherDims, L.name = L.coordDim = L.coordDimIndex = L.dimsDef = L.otherDims = null;
    }
    var N = h.get(D);
    if (N !== !1) {
      if (N = Ie(N), !N.length)
        for (var B = 0; B < (C && C.length || 1); B++) {
          for (; m < s && v(m).coordDim != null; )
            m++;
          m < s && N.push(m++);
        }
      E(N, function(G, V) {
        var F = v(G);
        if (l && L.type != null && (F.type = L.type), p(Jt(F, L), D, V), F.name == null && C) {
          var $ = C[V];
          !tt($) && ($ = {
            name: $
          }), F.name = F.displayName = $.name, F.defaultTooltip = $.defaultTooltip;
        }
        P && Jt(F.otherDims, P);
      });
    }
  });
  function p(T, D, C) {
    Df.get(D) != null ? T.otherDims[D] = C : (T.coordDim = D, T.coordDimIndex = C, r.set(D, !0));
  }
  var g = t.generateCoord, y = t.generateCoordCount, _ = y != null;
  y = g ? y || 1 : 0;
  var b = g || "value";
  function w(T) {
    T.name == null && (T.name = T.coordDim);
  }
  if (o)
    E(a, function(T) {
      w(T);
    }), a.sort(function(T, D) {
      return T.storeDimIndex - D.storeDimIndex;
    });
  else
    for (var S = 0; S < s; S++) {
      var M = v(S), k = M.coordDim;
      k == null && (M.coordDim = ZF(b, r, _), M.coordDimIndex = 0, (!g || y <= 0) && (M.isExtraCoord = !0), y--), w(M), M.type == null && (Fx(e, S) === je.Must || M.isExtraCoord && (M.otherDims.itemName != null || M.otherDims.seriesName != null)) && (M.type = "ordinal");
    }
  return jF(a), new Rw({
    source: e,
    dimensions: a,
    fullDimensionCount: s,
    dimensionOmitted: o
  });
}
function jF(e) {
  for (var t = ht(), i = 0; i < e.length; i++) {
    var n = e[i], r = n.name, a = t.get(r) || 0;
    a > 0 && (n.name = r + (a - 1)), a++, t.set(r, a);
  }
}
function qF(e, t, i, n) {
  var r = Math.max(e.dimensionsDetectedCount || 1, t.length, i.length, n || 0);
  return E(t, function(a) {
    var s;
    tt(a) && (s = a.dimsDef) && (r = Math.max(r, s.length));
  }), r;
}
function ZF(e, t, i) {
  if (i || t.hasKey(e)) {
    for (var n = 0; t.hasKey(e + n); )
      n++;
    e += n;
  }
  return t.set(e, !0), e;
}
var KF = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e(t) {
      this.coordSysDims = [], this.axisMap = ht(), this.categoryAxisMap = ht(), this.coordSysName = t;
    }
    return e;
  })()
);
function QF(e) {
  var t = e.get("coordinateSystem"), i = new KF(t), n = JF[t];
  if (n)
    return n(e, i, i.axisMap, i.categoryAxisMap), i;
}
var JF = {
  cartesian2d: function(e, t, i, n) {
    var r = e.getReferringComponents("xAxis", Hn).models[0], a = e.getReferringComponents("yAxis", Hn).models[0];
    if (process.env.NODE_ENV !== "production") {
      if (!r)
        throw new Error('xAxis "' + rr(e.get("xAxisIndex"), e.get("xAxisId"), 0) + '" not found');
      if (!a)
        throw new Error('yAxis "' + rr(e.get("xAxisIndex"), e.get("yAxisId"), 0) + '" not found');
    }
    t.coordSysDims = ["x", "y"], i.set("x", r), i.set("y", a), Na(r) && (n.set("x", r), t.firstCategoryDimIndex = 0), Na(a) && (n.set("y", a), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  singleAxis: function(e, t, i, n) {
    var r = e.getReferringComponents("singleAxis", Hn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("singleAxis should be specified.");
    t.coordSysDims = ["single"], i.set("single", r), Na(r) && (n.set("single", r), t.firstCategoryDimIndex = 0);
  },
  polar: function(e, t, i, n) {
    var r = e.getReferringComponents("polar", Hn).models[0], a = r.findAxisModel("radiusAxis"), s = r.findAxisModel("angleAxis");
    if (process.env.NODE_ENV !== "production") {
      if (!s)
        throw new Error("angleAxis option not found");
      if (!a)
        throw new Error("radiusAxis option not found");
    }
    t.coordSysDims = ["radius", "angle"], i.set("radius", a), i.set("angle", s), Na(a) && (n.set("radius", a), t.firstCategoryDimIndex = 0), Na(s) && (n.set("angle", s), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = 1));
  },
  geo: function(e, t, i, n) {
    t.coordSysDims = ["lng", "lat"];
  },
  parallel: function(e, t, i, n) {
    var r = e.ecModel, a = r.getComponent("parallel", e.get("parallelIndex")), s = t.coordSysDims = a.dimensions.slice();
    E(a.parallelAxisIndex, function(o, l) {
      var u = r.getComponent("parallelAxis", o), c = s[l];
      i.set(c, u), Na(u) && (n.set(c, u), t.firstCategoryDimIndex == null && (t.firstCategoryDimIndex = l));
    });
  },
  matrix: function(e, t, i, n) {
    var r = e.getReferringComponents("matrix", Hn).models[0];
    if (process.env.NODE_ENV !== "production" && !r)
      throw new Error("matrix coordinate system should be specified.");
    t.coordSysDims = ["x", "y"];
    var a = r.getDimensionModel("x"), s = r.getDimensionModel("y");
    i.set("x", a), i.set("y", s), n.set("x", a), n.set("y", s);
  }
};
function Na(e) {
  return e.get("type") === "category";
}
function tB(e, t, i) {
  i = i || {};
  var n = i.byIndex, r = i.stackedCoordDimension, a, s, o;
  eB(t) ? a = t : (s = t.schema, a = s.dimensions, o = t.store);
  var l = !!(e && e.get("stack")), u, c, h, d;
  if (E(a, function(y, _) {
    et(y) && (a[_] = y = {
      name: y
    }), l && !y.isExtraCoord && (!n && !u && y.ordinalMeta && (u = y), !c && y.type !== "ordinal" && y.type !== "time" && (!r || r === y.coordDim) && (c = y));
  }), c && !n && !u && (n = !0), c) {
    h = "__\0ecstackresult_" + e.id, d = "__\0ecstackedover_" + e.id, u && (u.createInvertedIndices = !0);
    var f = c.coordDim, v = c.type, m = 0;
    E(a, function(y) {
      y.coordDim === f && m++;
    });
    var p = {
      name: h,
      coordDim: f,
      coordDimIndex: m,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length
    }, g = {
      name: d,
      // This dimension contains stack base (generally, 0), so do not set it as
      // `stackedDimCoordDim` to avoid extent calculation, consider log scale.
      coordDim: d,
      coordDimIndex: m + 1,
      type: v,
      isExtraCoord: !0,
      isCalculationCoord: !0,
      storeDimIndex: a.length + 1
    };
    s ? (o && (p.storeDimIndex = o.ensureCalculationDimension(d, v), g.storeDimIndex = o.ensureCalculationDimension(h, v)), s.appendCalculationDimension(p), s.appendCalculationDimension(g)) : (a.push(p), a.push(g));
  }
  return {
    stackedDimension: c && c.name,
    stackedByDimension: u && u.name,
    isStackedByIndex: n,
    stackedOverDimension: d,
    stackResultDimension: h
  };
}
function eB(e) {
  return !Nw(e.schema);
}
function iB(e, t) {
  var i = e.get("coordinateSystem"), n = Bc.get(i), r;
  return t && t.coordSysDims && (r = _t(t.coordSysDims, function(a) {
    var s = {
      name: a
    }, o = t.axisMap.get(a);
    if (o) {
      var l = o.get("type");
      s.type = zF(l);
    }
    return s;
  })), r || (r = n && (n.getDimensionsInfo ? n.getDimensionsInfo() : n.dimensions.slice()) || ["x", "y"]), r;
}
function nB(e, t, i) {
  var n, r;
  return i && E(e, function(a, s) {
    var o = a.coordDim, l = i.categoryAxisMap.get(o);
    l && (n == null && (n = s), a.ordinalMeta = l.getOrdinalMeta(), t && (a.createInvertedIndices = !0)), a.otherDims.itemName != null && (r = !0);
  }), !r && n != null && (e[n].otherDims.itemName = 0), n;
}
function rB(e, t, i) {
  i = i || {};
  var n = t.getSourceManager(), r, a = !1;
  e ? (a = !0, r = op(e)) : (r = n.getSource(), a = r.sourceFormat === ti);
  var s = QF(t), o = iB(t, s), l = i.useEncodeDefaulter, u = mt(l) ? l : l ? Oe(jR, o, t) : null, c = {
    coordDimensions: o,
    generateCoord: i.generateCoord,
    encodeDefine: t.getEncode(),
    encodeDefaulter: u,
    canOmitUnusedDimensions: !a
  }, h = zw(r, c), d = nB(h.dimensions, i.createInvertedIndices, s), f = a ? null : n.getSharedDataStore(h), v = tB(t, {
    schema: h,
    store: f
  }), m = new Vf(h, t);
  m.setCalculationInfo(v);
  var p = d != null && aB(r) ? function(g, y, _, b) {
    return b === d ? _ : this.defaultDimValueGetter(g, y, _, b);
  } : null;
  return m.hasItemOption = !1, m.initData(
    // Try to reuse the data store in sourceManager if using dataset.
    a ? r : f,
    null,
    p
  ), m;
}
function aB(e) {
  if (e.sourceFormat === ti) {
    var t = sB(e.data || []);
    return !K(Zo(t));
  }
}
function sB(e) {
  for (var t = 0; t < e.length && e[t] == null; )
    t++;
  return e[t];
}
function Vw(e, t) {
  return e.type === "category" ? e.scale.getLabel(t) : t.value;
}
function oB(e) {
  var t = e.get("interval");
  return t ?? "auto";
}
function lB(e) {
  return e.type === "category" && oB(e.getLabelModel()) === 0;
}
function ac(e) {
  return e === "middle" || e === "center";
}
var r_ = [], uB = {
  registerPreprocessor: Lw,
  registerProcessor: Ow,
  registerPostInit: PF,
  registerPostUpdate: LF,
  registerUpdateLifecycle: dp,
  registerAction: fa,
  registerCoordinateSystem: OF,
  registerLayout: IF,
  registerVisual: va,
  registerTransform: NF,
  registerLoading: Iw,
  registerMap: RF,
  registerImpl: hF,
  PRIORITY: MF,
  ComponentModel: Pt,
  ComponentView: En,
  SeriesModel: sr,
  ChartView: Jn,
  // TODO Use ComponentModel and SeriesModel instead of Constructor
  registerComponentModel: function(e) {
    Pt.registerClass(e);
  },
  registerComponentView: function(e) {
    En.registerClass(e);
  },
  registerSeriesModel: function(e) {
    sr.registerClass(e);
  },
  registerChartView: function(e) {
    Jn.registerClass(e);
  },
  registerCustomSeries: function(e, t) {
  },
  registerSubTypeDefaulter: function(e, t) {
    Pt.registerSubTypeDefaulter(e, t);
  },
  registerPainter: function(e, t) {
    xL(e, t);
  }
};
function pp(e) {
  if (K(e)) {
    E(e, function(t) {
      pp(t);
    });
    return;
  }
  Ht(r_, e) >= 0 || (r_.push(e), mt(e) && (e = {
    install: e
  }), e.install(uB));
}
Gt();
Gt();
var a_ = {
  estimate: 1,
  determine: 2
};
function cB(e) {
  return {
    out: {
      noPxChangeTryDetermine: []
    },
    kind: e
  };
}
var s_ = ["label", "labelLine", "layoutOption", "priority", "defaultAttr", "marginForce", "minMarginForce", "marginDefault", "suggestIgnore"], hB = 1, sc = 2, Hw = hB | sc;
function oc(e, t, i) {
  i = i || Hw, t ? e.dirty |= i : e.dirty &= ~i;
}
function Yw(e, t) {
  return t = t || Hw, e.dirty == null || !!(e.dirty & t);
}
function or(e) {
  if (e)
    return Yw(e) && dB(e, e.label, e), e;
}
function dB(e, t, i) {
  var n = t.getComputedTransform();
  e.transform = Jv(e.transform, n);
  var r = e.localRect = No(e.localRect, t.getBoundingRect()), a = t.style, s = a.margin, o = i && i.marginForce, l = i && i.minMarginForce, u = i && i.marginDefault, c = a.__marginType;
  c == null && u && (s = u, c = Ga.textMargin);
  for (var h = 0; h < 4; h++)
    Sd[h] = c === Ga.minMargin && l && l[h] != null ? l[h] : o && o[h] != null ? o[h] : s ? s[h] : 0;
  c === Ga.textMargin && Sf(r, Sd, !1, !1);
  var d = e.rect = No(e.rect, r);
  return n && d.applyTransform(n), c === Ga.minMargin && Sf(d, Sd, !1, !1), e.axisAligned = Qv(n), (e.label = e.label || {}).ignore = t.ignore, oc(e, !1), oc(e, !0, sc), e;
}
var Sd = [0, 0, 0, 0];
function fB(e, t, i) {
  return e.transform = Jv(e.transform, i), e.localRect = No(e.localRect, t), e.rect = No(e.rect, t), i && e.rect.applyTransform(i), e.axisAligned = Qv(i), e.obb = void 0, (e.label = e.label || {}).ignore = !1, e;
}
function vB(e, t) {
  if (e) {
    e.label.x += t.x, e.label.y += t.y, e.label.markRedraw();
    var i = e.transform;
    i && (i[4] += t.x, i[5] += t.y);
    var n = e.rect;
    n && (n.x += t.x, n.y += t.y);
    var r = e.obb;
    r && r.fromBoundingRect(e.localRect, i);
  }
}
function o_(e, t) {
  for (var i = 0; i < s_.length; i++) {
    var n = s_[i];
    e[n] == null && (e[n] = t[n]);
  }
  return or(e);
}
function l_(e) {
  var t = e.obb;
  return (!t || Yw(e, sc)) && (e.obb = t = t || new cx(), t.fromBoundingRect(e.localRect, e.transform), oc(e, !1, sc)), t;
}
function pB(e) {
  var t = [];
  e.sort(function(u, c) {
    return (c.suggestIgnore ? 1 : 0) - (u.suggestIgnore ? 1 : 0) || c.priority - u.priority;
  });
  function i(u) {
    if (!u.ignore) {
      var c = u.ensureState("emphasis");
      c.ignore == null && (c.ignore = !1);
    }
    u.ignore = !0;
  }
  for (var n = 0; n < e.length; n++) {
    var r = or(e[n]);
    if (!r.label.ignore) {
      for (var a = r.label, s = r.labelLine, o = !1, l = 0; l < t.length; l++)
        if (gp(r, t[l], null, {
          touchThreshold: 0.05
        })) {
          o = !0;
          break;
        }
      o ? (i(a), s && i(s)) : t.push(r);
    }
  }
}
function gp(e, t, i, n) {
  return !e || !t || e.label && e.label.ignore || t.label && t.label.ignore || !e.rect.intersect(t.rect, i, n) ? !1 : e.axisAligned && t.axisAligned ? !0 : l_(e).intersect(l_(t), i, n);
}
var gB = null;
function mB() {
  return gB;
}
var yB = "expandAxisBreak", Xn = Math.PI, _B = [[1, 2, 1, 2], [5, 3, 5, 3], [8, 3, 8, 3]], bB = [[0, 1, 0, 1], [0, 3, 0, 3], [0, 3, 0, 3]], lc = Gt(), Ww = Gt(), xB = (
  /** @class */
  (function() {
    function e(t) {
      this.recordMap = {}, this.resolveAxisNameOverlap = t;
    }
    return e.prototype.ensureRecord = function(t) {
      var i = t.axis.dim, n = t.componentIndex, r = this.recordMap, a = r[i] || (r[i] = []);
      return a[n] || (a[n] = {
        ready: {}
      });
    }, e;
  })()
);
function wB(e, t, i, n) {
  var r = i.axis, a = t.ensureRecord(i), s = [], o, l = mp(e.axisName) && ac(e.nameLocation);
  E(n, function(v) {
    var m = or(v);
    if (!(!m || m.label.ignore)) {
      s.push(m);
      var p = a.transGroup;
      l && (p.transform ? qo(Vs, p.transform) : Dv(Vs), m.transform && vo(Vs, Vs, m.transform), lt.copy(Zl, m.localRect), Zl.applyTransform(Vs), o ? o.union(Zl) : lt.copy(o = new lt(0, 0, 0, 0), Zl));
    }
  });
  var u = Math.abs(a.dirVec.x) > 0.1 ? "x" : "y", c = a.transGroup[u];
  if (s.sort(function(v, m) {
    return Math.abs(v.label[u] - c) - Math.abs(m.label[u] - c);
  }), l && o) {
    var h = r.getExtent(), d = Math.min(h[0], h[1]), f = Math.max(h[0], h[1]) - d;
    o.union(new lt(d, 0, f, 1));
  }
  a.stOccupiedRect = o, a.labelInfoList = s;
}
var Vs = Ki(), Zl = new lt(0, 0, 0, 0), SB = function(e, t, i, n, r, a) {
  if (ac(e.nameLocation)) {
    var s = a.stOccupiedRect;
    s && Uw(fB({}, s, a.transGroup.transform), n, r);
  } else
    MB(a.labelInfoList, a.dirVec, n, r);
};
function Uw(e, t, i) {
  var n = new It();
  gp(e, t, n, {
    direction: Math.atan2(i.y, i.x),
    bidirectional: !1,
    touchThreshold: 0.05
  }) && vB(t, n);
}
function MB(e, t, i, n) {
  for (var r = It.dot(n, t) >= 0, a = 0, s = e.length; a < s; a++) {
    var o = e[r ? a : s - 1 - a];
    o.label.ignore || Uw(o, i, n);
  }
}
var ra = (
  /** @class */
  (function() {
    function e(t, i, n, r) {
      this.group = new Ci(), this._axisModel = t, this._api = i, this._local = {}, this._shared = r || new xB(SB), this._resetCfgDetermined(n);
    }
    return e.prototype.updateCfg = function(t) {
      if (process.env.NODE_ENV !== "production") {
        var i = this._shared.ensureRecord(this._axisModel).ready;
        nt(!i.axisLine && !i.axisTickLabelDetermine), i.axisName = i.axisTickLabelEstimate = !1;
      }
      var n = this._cfg.raw;
      n.position = t.position, n.labelOffset = t.labelOffset, this._resetCfgDetermined(n);
    }, e.prototype.__getRawCfg = function() {
      return this._cfg.raw;
    }, e.prototype._resetCfgDetermined = function(t) {
      var i = this._axisModel, n = i.getDefaultOption ? i.getDefaultOption() : {}, r = rt(t.axisName, i.get("name")), a = i.get("nameMoveOverlap");
      (a == null || a === "auto") && (a = rt(t.defaultNameMoveOverlap, !0));
      var s = {
        raw: t,
        position: t.position,
        rotation: t.rotation,
        nameDirection: rt(t.nameDirection, 1),
        tickDirection: rt(t.tickDirection, 1),
        labelDirection: rt(t.labelDirection, 1),
        labelOffset: rt(t.labelOffset, 0),
        silent: rt(t.silent, !0),
        axisName: r,
        nameLocation: Qr(i.get("nameLocation"), n.nameLocation, "end"),
        shouldNameMoveOverlap: mp(r) && a,
        optionHideOverlap: i.get(["axisLabel", "hideOverlap"]),
        showMinorTicks: i.get(["minorTick", "show"])
      };
      process.env.NODE_ENV !== "production" && (nt(s.position != null), nt(s.rotation != null)), this._cfg = s;
      var o = new Ci({
        x: s.position[0],
        y: s.position[1],
        rotation: s.rotation
      });
      o.updateTransform(), this._transformGroup = o;
      var l = this._shared.ensureRecord(i);
      l.transGroup = this._transformGroup, l.dirVec = new It(Math.cos(-s.rotation), Math.sin(-s.rotation));
    }, e.prototype.build = function(t, i) {
      var n = this;
      return t || (t = {
        axisLine: !0,
        axisTickLabelEstimate: !1,
        axisTickLabelDetermine: !0,
        axisName: !0
      }), E(kB, function(r) {
        t[r] && DB[r](n._cfg, n._local, n._shared, n._axisModel, n.group, n._transformGroup, n._api, i || {});
      }), this;
    }, e.innerTextLayout = function(t, i, n) {
      var r = T1(i - t), a, s;
      return Fu(r) ? (s = n > 0 ? "top" : "bottom", a = "center") : Fu(r - Xn) ? (s = n > 0 ? "bottom" : "top", a = "center") : (s = "middle", r > 0 && r < Xn ? a = n > 0 ? "right" : "left" : a = n > 0 ? "left" : "right"), {
        rotation: r,
        textAlign: a,
        textVerticalAlign: s
      };
    }, e.makeAxisEventDataBase = function(t) {
      var i = {
        componentType: t.mainType,
        componentIndex: t.componentIndex
      };
      return i[t.mainType + "Index"] = t.componentIndex, i;
    }, e.isLabelSilent = function(t) {
      var i = t.get("tooltip");
      return t.get("silent") || !(t.get("triggerEvent") || i && i.show);
    }, e;
  })()
), kB = ["axisLine", "axisTickLabelEstimate", "axisTickLabelDetermine", "axisName"], DB = {
  axisLine: function(e, t, i, n, r, a, s) {
    if (process.env.NODE_ENV !== "production") {
      var o = i.ensureRecord(n).ready;
      nt(!o.axisLine), o.axisLine = !0;
    }
    var l = n.get(["axisLine", "show"]);
    if (l === "auto" && (l = !0, e.raw.axisLineAutoShow != null && (l = !!e.raw.axisLineAutoShow)), !!l) {
      var u = n.axis.getExtent(), c = a.transform, h = [u[0], 0], d = [u[1], 0], f = h[0] > d[0];
      c && (Je(h, h, c), Je(d, d, c));
      var v = Y({
        lineCap: "round"
      }, n.getModel(["axisLine", "lineStyle"]).getLineStyle()), m = {
        strokeContainThreshold: e.raw.strokeContainThreshold || 5,
        silent: !0,
        z2: 1,
        style: v
      };
      if (n.get(["axisLine", "breakLine"]) && n.axis.scale.hasBreaks())
        mB().buildAxisBreakLine(n, r, a, m);
      else {
        var p = new ms(Y({
          shape: {
            x1: h[0],
            y1: h[1],
            x2: d[0],
            y2: d[1]
          }
        }, m));
        qv(p.shape, p.style.lineWidth), p.anid = "line", r.add(p);
      }
      var g = n.get(["axisLine", "symbol"]);
      if (g != null) {
        var y = n.get(["axisLine", "symbolSize"]);
        et(g) && (g = [g, g]), (et(y) || Zt(y)) && (y = [y, y]);
        var _ = jN(n.get(["axisLine", "symbolOffset"]) || 0, y), b = y[0], w = y[1];
        E([{
          rotate: e.rotation + Math.PI / 2,
          offset: _[0],
          r: 0
        }, {
          rotate: e.rotation - Math.PI / 2,
          offset: _[1],
          r: Math.sqrt((h[0] - d[0]) * (h[0] - d[0]) + (h[1] - d[1]) * (h[1] - d[1]))
        }], function(S, M) {
          if (g[M] !== "none" && g[M] != null) {
            var k = dw(g[M], -b / 2, -w / 2, b, w, v.stroke, !0), T = S.r + S.offset, D = f ? d : h;
            k.attr({
              rotation: S.rotate,
              x: D[0] + T * Math.cos(e.rotation),
              y: D[1] - T * Math.sin(e.rotation),
              silent: !0,
              z2: 11
            }), r.add(k);
          }
        });
      }
    }
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisTickLabelEstimate: function(e, t, i, n, r, a, s, o) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      nt(!l.axisTickLabelDetermine), l.axisTickLabelEstimate = !0;
    }
    var u = c_(t, r, o);
    u && u_(e, t, i, n, r, a, s, a_.estimate);
  },
  /**
   * Finish axis tick label build.
   * Can be only called once.
   */
  axisTickLabelDetermine: function(e, t, i, n, r, a, s, o) {
    if (process.env.NODE_ENV !== "production") {
      var l = i.ensureRecord(n).ready;
      l.axisTickLabelDetermine = !0;
    }
    var u = c_(t, r, o);
    u && u_(e, t, i, n, r, a, s, a_.determine);
    var c = AB(e, r, a, n);
    EB(e, t.labelLayoutList, c), PB(e, r, a, n, e.tickDirection);
  },
  /**
   * [CAUTION] This method can be called multiple times, following the change due to `resetCfg` called
   *  in size measurement. Thus this method should be idempotent, and should be performant.
   */
  axisName: function(e, t, i, n, r, a, s, o) {
    var l = i.ensureRecord(n);
    if (process.env.NODE_ENV !== "production") {
      var u = l.ready;
      nt(u.axisTickLabelEstimate || u.axisTickLabelDetermine), u.axisName = !0;
    }
    t.nameEl && (r.remove(t.nameEl), t.nameEl = l.nameLayout = l.nameLocation = null);
    var c = e.axisName;
    if (mp(c)) {
      var h = e.nameLocation, d = e.nameDirection, f = n.getModel("nameTextStyle"), v = n.get("nameGap") || 0, m = n.axis.getExtent(), p = n.axis.inverse ? -1 : 1, g = new It(0, 0), y = new It(0, 0);
      h === "start" ? (g.x = m[0] - p * v, y.x = -p) : h === "end" ? (g.x = m[1] + p * v, y.x = p) : (g.x = (m[0] + m[1]) / 2, g.y = e.labelOffset + d * v, y.y = d);
      var _ = Ki();
      y.transform(Cv(_, _, e.rotation));
      var b = n.get("nameRotate");
      b != null && (b = b * Xn / 180);
      var w, S;
      ac(h) ? w = ra.innerTextLayout(
        e.rotation,
        b ?? e.rotation,
        // Adapt to axis.
        d
      ) : (w = TB(e.rotation, h, b || 0, m), S = e.raw.axisNameAvailableWidth, S != null && (S = Math.abs(S / Math.sin(w.rotation)), !isFinite(S) && (S = null)));
      var M = f.getFont(), k = n.get("nameTruncate", !0) || {}, T = k.ellipsis, D = rr(e.raw.nameTruncateMaxWidth, k.maxWidth, S), C = o.nameMarginLevel || 0, P = new _i({
        x: g.x,
        y: g.y,
        rotation: w.rotation,
        silent: ra.isLabelSilent(n),
        style: la(f, {
          text: c,
          font: M,
          overflow: "truncate",
          width: D,
          ellipsis: T,
          fill: f.getTextColor() || n.get(["axisLine", "lineStyle", "color"]),
          align: f.get("align") || w.textAlign,
          verticalAlign: f.get("verticalAlign") || w.textVerticalAlign
        }),
        z2: 1
      });
      if (Kv({
        el: P,
        componentModel: n,
        itemName: c
      }), P.__fullText = c, P.anid = "name", n.get("triggerEvent")) {
        var L = ra.makeAxisEventDataBase(n);
        L.targetType = "axisName", L.name = c, Vt(P).eventData = L;
      }
      a.add(P), P.updateTransform(), t.nameEl = P;
      var O = l.nameLayout = or({
        label: P,
        priority: P.z2,
        defaultAttr: {
          ignore: P.ignore
        },
        marginDefault: ac(h) ? _B[C] : bB[C]
      });
      if (l.nameLocation = h, r.add(P), P.decomposeTransform(), e.shouldNameMoveOverlap && O) {
        var N = i.ensureRecord(n);
        process.env.NODE_ENV !== "production" && nt(N.labelInfoList), i.resolveAxisNameOverlap(e, i, n, O, y, N);
      }
    }
  }
};
function u_(e, t, i, n, r, a, s, o) {
  Xw(t) || LB(e, t, r, o, n, s);
  var l = t.labelLayoutList;
  OB(e, n, l, a), e.rotation;
  var u = e.optionHideOverlap;
  CB(n, l, u), u && pB(
    // Filter the already ignored labels by the previous overlap resolving methods.
    Ke(l, function(c) {
      return c && !c.label.ignore;
    })
  ), wB(e, i, n, l);
}
function TB(e, t, i, n) {
  var r = T1(i - e), a, s, o = n[0] > n[1], l = t === "start" && !o || t !== "start" && o;
  return Fu(r - Xn / 2) ? (s = l ? "bottom" : "top", a = "center") : Fu(r - Xn * 1.5) ? (s = l ? "top" : "bottom", a = "center") : (s = "middle", r < Xn * 1.5 && r > Xn / 2 ? a = l ? "left" : "right" : a = l ? "right" : "left"), {
    rotation: r,
    textAlign: a,
    textVerticalAlign: s
  };
}
function CB(e, t, i) {
  if (lB(e.axis))
    return;
  function n(o, l, u) {
    var c = or(t[l]), h = or(t[u]);
    if (!(!c || !h)) {
      if (o === !1 || c.suggestIgnore) {
        so(c.label);
        return;
      }
      if (h.suggestIgnore) {
        so(h.label);
        return;
      }
      var d = 0.1;
      if (!i) {
        var f = [0, 0, 0, 0];
        c = o_({
          marginForce: f
        }, c), h = o_({
          marginForce: f
        }, h);
      }
      gp(c, h, null, {
        touchThreshold: d
      }) && so(o ? h.label : c.label);
    }
  }
  var r = e.get(["axisLabel", "showMinLabel"]), a = e.get(["axisLabel", "showMaxLabel"]), s = t.length;
  n(r, 0, 1), n(a, s - 1, s - 2);
}
function EB(e, t, i) {
  e.showMinorTicks || E(t, function(n) {
    if (n && n.label.ignore)
      for (var r = 0; r < i.length; r++) {
        var a = i[r], s = Ww(a), o = lc(n.label);
        if (s.tickValue != null && !s.onBand && s.tickValue === o.tickValue) {
          so(a);
          return;
        }
      }
  });
}
function so(e) {
  e && (e.ignore = !0);
}
function Gw(e, t, i, n, r) {
  for (var a = [], s = [], o = [], l = 0; l < e.length; l++) {
    var u = e[l].coord;
    s[0] = u, s[1] = 0, o[0] = u, o[1] = i, t && (Je(s, s, t), Je(o, o, t));
    var c = new ms({
      shape: {
        x1: s[0],
        y1: s[1],
        x2: o[0],
        y2: o[1]
      },
      style: n,
      z2: 2,
      autoBatch: !0,
      silent: !0
    });
    qv(c.shape, c.style.lineWidth), c.anid = r + "_" + e[l].tickValue, a.push(c);
    var h = Ww(c);
    h.onBand = !!e[l].onBand, h.tickValue = e[l].tickValue;
  }
  return a;
}
function AB(e, t, i, n) {
  var r = n.axis, a = n.getModel("axisTick"), s = a.get("show");
  if (s === "auto" && (s = !0, e.raw.axisTickAutoShow != null && (s = !!e.raw.axisTickAutoShow)), !s || r.scale.isBlank())
    return [];
  for (var o = a.getModel("lineStyle"), l = e.tickDirection * a.get("length"), u = r.getTicksCoords(), c = Gw(u, i.transform, l, Jt(o.getLineStyle(), {
    stroke: n.get(["axisLine", "lineStyle", "color"])
  }), "ticks"), h = 0; h < c.length; h++)
    t.add(c[h]);
  return c;
}
function PB(e, t, i, n, r) {
  var a = n.axis, s = n.getModel("minorTick");
  if (!(!e.showMinorTicks || a.scale.isBlank())) {
    var o = a.getMinorTicksCoords();
    if (o.length)
      for (var l = s.getModel("lineStyle"), u = r * s.get("length"), c = Jt(l.getLineStyle(), Jt(n.getModel("axisTick").getLineStyle(), {
        stroke: n.get(["axisLine", "lineStyle", "color"])
      })), h = 0; h < o.length; h++)
        for (var d = Gw(o[h], i.transform, u, c, "minorticks_" + h), f = 0; f < d.length; f++)
          t.add(d[f]);
  }
}
function c_(e, t, i) {
  if (Xw(e)) {
    var n = e.axisLabelsCreationContext;
    process.env.NODE_ENV !== "production" && nt(e.labelGroup && n);
    var r = n.out.noPxChangeTryDetermine;
    if (i.noPxChange) {
      for (var a = !0, s = 0; s < r.length; s++)
        a = a && r[s]();
      if (a)
        return !1;
    }
    r.length && (t.remove(e.labelGroup), Hf(e, null, null, null));
  }
  return !0;
}
function LB(e, t, i, n, r, a) {
  var s = r.axis, o = rr(e.raw.axisLabelShow, r.get(["axisLabel", "show"])), l = new Ci();
  i.add(l);
  var u = cB(n);
  if (!o || s.scale.isBlank()) {
    Hf(t, [], l, u);
    return;
  }
  var c = r.getModel("axisLabel"), h = s.getViewLabels(u), d = (rr(e.raw.labelRotate, c.get("rotate")) || 0) * Xn / 180, f = ra.innerTextLayout(e.rotation, d, e.labelDirection), v = r.getCategories && r.getCategories(!0), m = [], p = r.get("triggerEvent"), g = 1 / 0, y = -1 / 0;
  E(h, function(b, w) {
    var S, M = s.scale.type === "ordinal" ? s.scale.getRawOrdinalNumber(b.tickValue) : b.tickValue, k = b.formattedLabel, T = b.rawLabel, D = c;
    if (v && v[M]) {
      var C = v[M];
      tt(C) && C.textStyle && (D = new jt(C.textStyle, c, r.ecModel));
    }
    var P = D.getTextColor() || r.get(["axisLine", "lineStyle", "color"]), L = D.getShallow("align", !0) || f.textAlign, O = rt(D.getShallow("alignMinLabel", !0), L), N = rt(D.getShallow("alignMaxLabel", !0), L), B = D.getShallow("verticalAlign", !0) || D.getShallow("baseline", !0) || f.textVerticalAlign, G = rt(D.getShallow("verticalAlignMinLabel", !0), B), V = rt(D.getShallow("verticalAlignMaxLabel", !0), B), F = 10 + (((S = b.time) === null || S === void 0 ? void 0 : S.level) || 0);
    g = Math.min(g, F), y = Math.max(y, F);
    var $ = new _i({
      // --- transform props start ---
      // All of the transform props MUST not be set here, but should be set in
      // `updateAxisLabelChangableProps`, because they may change in estimation,
      // and need to calculate based on global coord sys by `decomposeTransform`.
      x: 0,
      y: 0,
      rotation: 0,
      // --- transform props end ---
      silent: ra.isLabelSilent(r),
      z2: F,
      style: la(D, {
        text: k,
        align: w === 0 ? O : w === h.length - 1 ? N : L,
        verticalAlign: w === 0 ? G : w === h.length - 1 ? V : B,
        fill: mt(P) ? P(
          // (1) In category axis with data zoom, tick is not the original
          // index of axis.data. So tick should not be exposed to user
          // in category axis.
          // (2) Compatible with previous version, which always use formatted label as
          // input. But in interval scale the formatted label is like '223,445', which
          // maked user replace ','. So we modify it to return original val but remain
          // it as 'string' to avoid error in replacing.
          s.type === "category" ? T : s.type === "value" ? M + "" : M,
          w
        ) : P
      })
    });
    $.anid = "label_" + M;
    var Z = lc($);
    if (Z.break = b.break, Z.tickValue = M, Z.layoutRotation = f.rotation, Kv({
      el: $,
      componentModel: r,
      itemName: k,
      formatterParamsExtra: {
        isTruncated: function() {
          return $.isTruncated;
        },
        value: T,
        tickIndex: w
      }
    }), p) {
      var j = ra.makeAxisEventDataBase(r);
      j.targetType = "axisLabel", j.value = T, j.tickIndex = w, b.break && (j.break = {
        // type: labelItem.break.type,
        start: b.break.parsedBreak.vmin,
        end: b.break.parsedBreak.vmax
      }), s.type === "category" && (j.dataIndex = M), Vt($).eventData = j, b.break && RB(r, a, $, b.break);
    }
    m.push($), l.add($);
  });
  var _ = _t(m, function(b) {
    return {
      label: b,
      priority: lc(b).break ? b.z2 + (y - g + 1) : b.z2,
      defaultAttr: {
        ignore: b.ignore
      }
    };
  });
  Hf(t, _, l, u);
}
function Xw(e) {
  return !!e.labelLayoutList;
}
function Hf(e, t, i, n) {
  e.labelLayoutList = t, e.labelGroup = i, e.axisLabelsCreationContext = n;
}
function OB(e, t, i, n) {
  var r = t.get(["axisLabel", "margin"]);
  E(i, function(a, s) {
    var o = or(a);
    if (o) {
      var l = o.label, u = lc(l);
      o.suggestIgnore = l.ignore, l.ignore = !1, df(cn, IB), cn.x = t.axis.dataToCoord(u.tickValue), cn.y = e.labelOffset + e.labelDirection * r, cn.rotation = u.layoutRotation, n.add(cn), cn.updateTransform(), n.remove(cn), cn.decomposeTransform(), df(l, cn), l.markRedraw(), oc(o, !0), or(o);
    }
  });
}
var cn = new De(), IB = new De();
function mp(e) {
  return !!e;
}
function RB(e, t, i, n) {
  i.on("click", function(r) {
    var a = {
      type: yB,
      breaks: [{
        start: n.parsedBreak.breakOption.start,
        end: n.parsedBreak.breakOption.end
      }]
    };
    a[e.axis.dim + "AxisIndex"] = e.componentIndex, t.dispatchAction(a);
  });
}
function h_(e, t, i) {
  i = i || {};
  var n = t.axis, r = {}, a = n.getAxesOnZeroOf()[0], s = n.position, o = a ? "onZero" : s, l = n.dim, u = [e.x, e.x + e.width, e.y, e.y + e.height], c = {
    left: 0,
    right: 1,
    top: 0,
    bottom: 1,
    onZero: 2
  }, h = t.get("offset") || 0, d = l === "x" ? [u[2] - h, u[3] + h] : [u[0] - h, u[1] + h];
  if (a) {
    var f = a.toGlobalCoord(a.dataToCoord(0));
    d[c.onZero] = Math.max(Math.min(f, d[1]), d[0]);
  }
  r.position = [l === "y" ? d[c[o]] : u[0], l === "x" ? d[c[o]] : u[3]], r.rotation = Math.PI / 2 * (l === "x" ? 0 : 1);
  var v = {
    top: -1,
    bottom: 1,
    left: -1,
    right: 1
  };
  r.labelDirection = r.tickDirection = r.nameDirection = v[s], r.labelOffset = a ? d[c[s]] - d[c.onZero] : 0, t.get(["axisTick", "inside"]) && (r.tickDirection = -r.tickDirection), rr(i.labelInside, t.get(["axisLabel", "inside"])) && (r.labelDirection = -r.labelDirection);
  var m = t.get(["axisLabel", "rotate"]);
  return r.labelRotate = o === "top" ? -m : m, r.z2 = 1, r;
}
function NB(e, t) {
  var i = {
    /**
     * key: makeKey(axis.model)
     * value: {
     *      axis,
     *      coordSys,
     *      axisPointerModel,
     *      triggerTooltip,
     *      triggerEmphasis,
     *      involveSeries,
     *      snap,
     *      seriesModels,
     *      seriesDataCount
     * }
     */
    axesInfo: {},
    seriesInvolved: !1,
    /**
     * key: makeKey(coordSys.model)
     * value: Object: key makeKey(axis.model), value: axisInfo
     */
    coordSysAxesInfo: {},
    coordSysMap: {}
  };
  return FB(i, e, t), i.seriesInvolved && $B(i, e), i;
}
function FB(e, t, i) {
  var n = t.getComponent("tooltip"), r = t.getComponent("axisPointer"), a = r.get("link", !0) || [], s = [];
  E(i.getCoordinateSystems(), function(o) {
    if (!o.axisPointerEnabled)
      return;
    var l = Ho(o.model), u = e.coordSysAxesInfo[l] = {};
    e.coordSysMap[l] = o;
    var c = o.model, h = c.getModel("tooltip", n);
    if (E(o.getAxes(), Oe(m, !1, null)), o.getTooltipAxes && n && h.get("show")) {
      var d = h.get("trigger") === "axis", f = h.get(["axisPointer", "type"]) === "cross", v = o.getTooltipAxes(h.get(["axisPointer", "axis"]));
      (d || f) && E(v.baseAxes, Oe(m, f ? "cross" : !0, d)), f && E(v.otherAxes, Oe(m, "cross", !1));
    }
    function m(p, g, y) {
      var _ = y.model.getModel("axisPointer", r), b = _.get("show");
      if (!(!b || b === "auto" && !p && !Yf(_))) {
        g == null && (g = _.get("triggerTooltip")), _ = p ? BB(y, h, r, t, p, g) : _;
        var w = _.get("snap"), S = _.get("triggerEmphasis"), M = Ho(y.model), k = g || w || y.type === "category", T = e.axesInfo[M] = {
          key: M,
          axis: y,
          coordSys: o,
          axisPointerModel: _,
          triggerTooltip: g,
          triggerEmphasis: S,
          involveSeries: k,
          snap: w,
          useHandle: Yf(_),
          seriesModels: [],
          linkGroup: null
        };
        u[M] = T, e.seriesInvolved = e.seriesInvolved || k;
        var D = zB(a, y);
        if (D != null) {
          var C = s[D] || (s[D] = {
            axesInfo: {}
          });
          C.axesInfo[M] = T, C.mapper = a[D].mapper, T.linkGroup = C;
        }
      }
    }
  });
}
function BB(e, t, i, n, r, a) {
  var s = t.getModel("axisPointer"), o = ["type", "snap", "lineStyle", "shadowStyle", "label", "animation", "animationDurationUpdate", "animationEasingUpdate", "z"], l = {};
  E(o, function(d) {
    l[d] = pt(s.get(d));
  }), l.snap = e.type !== "category" && !!a, s.get("type") === "cross" && (l.type = "line");
  var u = l.label || (l.label = {});
  if (u.show == null && (u.show = !1), r === "cross") {
    var c = s.get(["label", "show"]);
    if (u.show = c ?? !0, !a) {
      var h = l.lineStyle = s.get("crossStyle");
      h && Jt(u, h.textStyle);
    }
  }
  return e.model.getModel("axisPointer", new jt(l, i, n));
}
function $B(e, t) {
  t.eachSeries(function(i) {
    var n = i.coordinateSystem, r = i.get(["tooltip", "trigger"], !0), a = i.get(["tooltip", "show"], !0);
    !n || !n.model || r === "none" || r === !1 || r === "item" || a === !1 || i.get(["axisPointer", "show"], !0) === !1 || E(e.coordSysAxesInfo[Ho(n.model)], function(s) {
      var o = s.axis;
      n.getAxis(o.dim) === o && (s.seriesModels.push(i), s.seriesDataCount == null && (s.seriesDataCount = 0), s.seriesDataCount += i.getData().count());
    });
  });
}
function zB(e, t) {
  for (var i = t.model, n = t.dim, r = 0; r < e.length; r++) {
    var a = e[r] || {};
    if (Md(a[n + "AxisId"], i.id) || Md(a[n + "AxisIndex"], i.componentIndex) || Md(a[n + "AxisName"], i.name))
      return r;
  }
}
function Md(e, t) {
  return e === "all" || K(e) && Ht(e, t) >= 0 || e === t;
}
function VB(e) {
  var t = yp(e);
  if (t) {
    var i = t.axisPointerModel, n = t.axis.scale, r = i.option, a = i.get("status"), s = i.get("value");
    s != null && (s = n.parse(s));
    var o = Yf(i);
    a == null && (r.status = o ? "show" : "hide");
    var l = n.getExtent().slice();
    l[0] > l[1] && l.reverse(), // Pick a value on axis when initializing.
    (s == null || s > l[1]) && (s = l[1]), s < l[0] && (s = l[0]), r.value = s, o && (r.status = t.axis.scale.isBlank() ? "hide" : "show");
  }
}
function yp(e) {
  var t = (e.ecModel.getComponent("axisPointer") || {}).coordSysAxesInfo;
  return t && t.axesInfo[Ho(e)];
}
function HB(e) {
  var t = yp(e);
  return t && t.axisPointerModel;
}
function Yf(e) {
  return !!e.get(["handle", "show"]);
}
function Ho(e) {
  return e.type + "||" + e.id;
}
var kd = {}, YB = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r, a) {
      this.axisPointerClass && VB(i), e.prototype.render.apply(this, arguments), this._doUpdateAxisPointerClass(i, r, !0);
    }, t.prototype.updateAxisPointer = function(i, n, r, a) {
      this._doUpdateAxisPointerClass(i, r, !1);
    }, t.prototype.remove = function(i, n) {
      var r = this._axisPointer;
      r && r.remove(n);
    }, t.prototype.dispose = function(i, n) {
      this._disposeAxisPointer(n), e.prototype.dispose.apply(this, arguments);
    }, t.prototype._doUpdateAxisPointerClass = function(i, n, r) {
      var a = t.getAxisPointerClass(this.axisPointerClass);
      if (a) {
        var s = HB(i);
        s ? (this._axisPointer || (this._axisPointer = new a())).render(i, s, n, r) : this._disposeAxisPointer(n);
      }
    }, t.prototype._disposeAxisPointer = function(i) {
      this._axisPointer && this._axisPointer.dispose(i), this._axisPointer = null;
    }, t.registerAxisPointerClass = function(i, n) {
      if (process.env.NODE_ENV !== "production" && kd[i])
        throw new Error("axisPointer " + i + " exists");
      kd[i] = n;
    }, t.getAxisPointerClass = function(i) {
      return i && kd[i];
    }, t.type = "axis", t;
  })(En)
), Vr = Gt(), d_ = pt, Dd = Dt, WB = (
  /** @class */
  (function() {
    function e() {
      this._dragging = !1, this.animationThreshold = 15;
    }
    return e.prototype.render = function(t, i, n, r) {
      var a = i.get("value"), s = i.get("status");
      if (this._axisModel = t, this._axisPointerModel = i, this._api = n, !(!r && this._lastValue === a && this._lastStatus === s)) {
        this._lastValue = a, this._lastStatus = s;
        var o = this._group, l = this._handle;
        if (!s || s === "hide") {
          o && o.hide(), l && l.hide();
          return;
        }
        o && o.show(), l && l.show();
        var u = {};
        this.makeElOption(u, a, t, i, n);
        var c = u.graphicKey;
        c !== this._lastGraphicKey && this.clear(n), this._lastGraphicKey = c;
        var h = this._moveAnimation = this.determineAnimation(t, i);
        if (!o)
          o = this._group = new Ci(), this.createPointerEl(o, u, t, i), this.createLabelEl(o, u, t, i), n.getZr().add(o);
        else {
          var d = Oe(f_, i, h);
          this.updatePointerEl(o, u, d), this.updateLabelEl(o, u, d, i);
        }
        p_(o, i, !0), this._renderHandle(a);
      }
    }, e.prototype.remove = function(t) {
      this.clear(t);
    }, e.prototype.dispose = function(t) {
      this.clear(t);
    }, e.prototype.determineAnimation = function(t, i) {
      var n = i.get("animation"), r = t.axis, a = r.type === "category", s = i.get("snap");
      if (!s && !a)
        return !1;
      if (n === "auto" || n == null) {
        var o = this.animationThreshold;
        if (a && r.getBandWidth() > o)
          return !0;
        if (s) {
          var l = yp(t).seriesDataCount, u = r.getExtent();
          return Math.abs(u[0] - u[1]) / l > o;
        }
        return !1;
      }
      return n === !0;
    }, e.prototype.makeElOption = function(t, i, n, r, a) {
    }, e.prototype.createPointerEl = function(t, i, n, r) {
      var a = i.pointer;
      if (a) {
        var s = Vr(t).pointerEl = new uR[a.type](d_(i.pointer));
        t.add(s);
      }
    }, e.prototype.createLabelEl = function(t, i, n, r) {
      if (i.label) {
        var a = Vr(t).labelEl = new _i(d_(i.label));
        t.add(a), v_(a, r);
      }
    }, e.prototype.updatePointerEl = function(t, i, n) {
      var r = Vr(t).pointerEl;
      r && i.pointer && (r.setStyle(i.pointer.style), n(r, {
        shape: i.pointer.shape
      }));
    }, e.prototype.updateLabelEl = function(t, i, n, r) {
      var a = Vr(t).labelEl;
      a && (a.setStyle(i.label.style), n(a, {
        // Consider text length change in vertical axis, animation should
        // be used on shape, otherwise the effect will be weird.
        // TODOTODO
        // shape: elOption.label.shape,
        x: i.label.x,
        y: i.label.y
      }), v_(a, r));
    }, e.prototype._renderHandle = function(t) {
      if (!(this._dragging || !this.updateHandleTransform)) {
        var i = this._axisPointerModel, n = this._api.getZr(), r = this._handle, a = i.getModel("handle"), s = i.get("status");
        if (!a.get("show") || !s || s === "hide") {
          r && n.remove(r), this._handle = null;
          return;
        }
        var o;
        this._handle || (o = !0, r = this._handle = gx(a.get("icon"), {
          cursor: "move",
          draggable: !0,
          onmousemove: function(u) {
            Eu(u.event);
          },
          onmousedown: Dd(this._onHandleDragMove, this, 0, 0),
          drift: Dd(this._onHandleDragMove, this),
          ondragend: Dd(this._onHandleDragEnd, this)
        }), n.add(r)), p_(r, i, !1), r.setStyle(a.getItemStyle(null, ["color", "borderColor", "borderWidth", "opacity", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"]));
        var l = a.get("size");
        K(l) || (l = [l, l]), r.scaleX = l[0] / 2, r.scaleY = l[1] / 2, rw(this, "_doDispatchAxisPointer", a.get("throttle") || 0, "fixRate"), this._moveHandleToValue(t, o);
      }
    }, e.prototype._moveHandleToValue = function(t, i) {
      f_(this._axisPointerModel, !i && this._moveAnimation, this._handle, Td(this.getHandleTransform(t, this._axisModel, this._axisPointerModel)));
    }, e.prototype._onHandleDragMove = function(t, i) {
      var n = this._handle;
      if (n) {
        this._dragging = !0;
        var r = this.updateHandleTransform(Td(n), [t, i], this._axisModel, this._axisPointerModel);
        this._payloadInfo = r, n.stopAnimation(), n.attr(Td(r)), Vr(n).lastProp = null, this._doDispatchAxisPointer();
      }
    }, e.prototype._doDispatchAxisPointer = function() {
      var t = this._handle;
      if (t) {
        var i = this._payloadInfo, n = this._axisModel;
        this._api.dispatchAction({
          type: "updateAxisPointer",
          x: i.cursorPoint[0],
          y: i.cursorPoint[1],
          tooltipOption: i.tooltipOption,
          axesInfo: [{
            axisDim: n.axis.dim,
            axisIndex: n.componentIndex
          }]
        });
      }
    }, e.prototype._onHandleDragEnd = function() {
      this._dragging = !1;
      var t = this._handle;
      if (t) {
        var i = this._axisPointerModel.get("value");
        this._moveHandleToValue(i), this._api.dispatchAction({
          type: "hideTip"
        });
      }
    }, e.prototype.clear = function(t) {
      this._lastValue = null, this._lastStatus = null;
      var i = t.getZr(), n = this._group, r = this._handle;
      i && n && (this._lastGraphicKey = null, n && i.remove(n), r && i.remove(r), this._group = null, this._handle = null, this._payloadInfo = null), Lf(this, "_doDispatchAxisPointer");
    }, e.prototype.doClear = function() {
    }, e.prototype.buildLabel = function(t, i, n) {
      return n = n || 0, {
        x: t[n],
        y: t[1 - n],
        width: i[n],
        height: i[1 - n]
      };
    }, e;
  })()
);
function f_(e, t, i, n) {
  jw(Vr(i).lastProp, n) || (Vr(i).lastProp = n, t ? Xv(i, n, e) : (i.stopAnimation(), i.attr(n)));
}
function jw(e, t) {
  if (tt(e) && tt(t)) {
    var i = !0;
    return E(t, function(n, r) {
      i = i && jw(e[r], n);
    }), !!i;
  } else
    return e === t;
}
function v_(e, t) {
  e[t.get(["label", "show"]) ? "show" : "hide"]();
}
function Td(e) {
  return {
    x: e.x || 0,
    y: e.y || 0,
    rotation: e.rotation || 0
  };
}
function p_(e, t, i) {
  var n = t.get("z"), r = t.get("zlevel");
  e && e.traverse(function(a) {
    a.type !== "group" && (n != null && (a.z = n), r != null && (a.zlevel = r), a.silent = i);
  });
}
function UB(e) {
  var t = e.get("type"), i = e.getModel(t + "Style"), n;
  return t === "line" ? (n = i.getLineStyle(), n.fill = null) : t === "shadow" && (n = i.getAreaStyle(), n.stroke = null), n;
}
function GB(e, t, i, n, r) {
  var a = i.get("value"), s = qw(a, t.axis, t.ecModel, i.get("seriesDataIndices"), {
    precision: i.get(["label", "precision"]),
    formatter: i.get(["label", "formatter"])
  }), o = i.getModel("label"), l = ip(o.get("padding") || 0), u = o.getFont(), c = hL(s, u), h = r.position, d = c.width + l[1] + l[3], f = c.height + l[0] + l[2], v = r.align;
  v === "right" && (h[0] -= d), v === "center" && (h[0] -= d / 2);
  var m = r.verticalAlign;
  m === "bottom" && (h[1] -= f), m === "middle" && (h[1] -= f / 2), XB(h, d, f, n);
  var p = o.get("backgroundColor");
  (!p || p === "auto") && (p = t.get(["axisLine", "lineStyle", "color"])), e.label = {
    // shape: {x: 0, y: 0, width: width, height: height, r: labelModel.get('borderRadius')},
    x: h[0],
    y: h[1],
    style: la(o, {
      text: s,
      font: u,
      fill: o.getTextColor(),
      padding: l,
      backgroundColor: p
    }),
    // Label should be over axisPointer.
    z2: 10
  };
}
function XB(e, t, i, n) {
  var r = n.getWidth(), a = n.getHeight();
  e[0] = Math.min(e[0] + t, r) - t, e[1] = Math.min(e[1] + i, a) - i, e[0] = Math.max(e[0], 0), e[1] = Math.max(e[1], 0);
}
function qw(e, t, i, n, r) {
  e = t.scale.parse(e);
  var a = t.scale.getLabel({
    value: e
  }, {
    // If `precision` is set, width can be fixed (like '12.00500'), which
    // helps to debounce when when moving label.
    precision: r.precision
  }), s = r.formatter;
  if (s) {
    var o = {
      value: Vw(t, {
        value: e
      }),
      axisDimension: t.dim,
      axisIndex: t.index,
      seriesData: []
    };
    E(n, function(l) {
      var u = i.getSeriesByIndex(l.seriesIndex), c = l.dataIndexInside, h = u && u.getDataParams(c);
      h && o.seriesData.push(h);
    }), et(s) ? a = s.replace("{value}", a) : mt(s) && (a = s(o));
  }
  return a;
}
function Zw(e, t, i) {
  var n = Ki();
  return Cv(n, n, i.rotation), Qd(n, n, i.position), Zv([e.dataToCoord(t), (i.labelOffset || 0) + (i.labelDirection || 1) * (i.labelMargin || 0)], n);
}
function jB(e, t, i, n, r, a) {
  var s = ra.innerTextLayout(i.rotation, 0, i.labelDirection);
  i.labelMargin = r.get(["label", "margin"]), GB(t, n, r, a, {
    position: Zw(n.axis, e, i),
    align: s.textAlign,
    verticalAlign: s.textVerticalAlign
  });
}
function qB(e, t, i) {
  return i = i || 0, {
    x1: e[i],
    y1: e[1 - i],
    x2: t[i],
    y2: t[1 - i]
  };
}
function ZB(e, t, i) {
  return i = i || 0, {
    x: e[i],
    y: e[1 - i],
    width: t[i],
    height: t[1 - i]
  };
}
var KB = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      return e !== null && e.apply(this, arguments) || this;
    }
    return t.prototype.makeElOption = function(i, n, r, a, s) {
      var o = r.axis, l = o.grid, u = a.get("type"), c = g_(l, o).getOtherAxis(o).getGlobalExtent(), h = o.toGlobalCoord(o.dataToCoord(n, !0));
      if (u && u !== "none") {
        var d = UB(a), f = QB[u](o, h, c);
        f.style = d, i.graphicKey = f.type, i.pointer = f;
      }
      var v = h_(l.getRect(), r);
      jB(n, i, v, r, a, s);
    }, t.prototype.getHandleTransform = function(i, n, r) {
      var a = h_(n.axis.grid.getRect(), n, {
        labelInside: !1
      });
      a.labelMargin = r.get(["handle", "margin"]);
      var s = Zw(n.axis, i, a);
      return {
        x: s[0],
        y: s[1],
        rotation: a.rotation + (a.labelDirection < 0 ? Math.PI : 0)
      };
    }, t.prototype.updateHandleTransform = function(i, n, r, a) {
      var s = r.axis, o = s.grid, l = s.getGlobalExtent(!0), u = g_(o, s).getOtherAxis(s).getGlobalExtent(), c = s.dim === "x" ? 0 : 1, h = [i.x, i.y];
      h[c] += n[c], h[c] = Math.min(l[1], h[c]), h[c] = Math.max(l[0], h[c]);
      var d = (u[1] + u[0]) / 2, f = [d, d];
      f[c] = h[c];
      var v = [{
        verticalAlign: "middle"
      }, {
        align: "center"
      }];
      return {
        x: h[0],
        y: h[1],
        rotation: i.rotation,
        cursorPoint: f,
        tooltipOption: v[c]
      };
    }, t;
  })(WB)
);
function g_(e, t) {
  var i = {};
  return i[t.dim + "AxisIndex"] = t.index, e.getCartesian(i);
}
var QB = {
  line: function(e, t, i) {
    var n = qB([t, i[0]], [t, i[1]], m_(e));
    return {
      type: "Line",
      subPixelOptimize: !0,
      shape: n
    };
  },
  shadow: function(e, t, i) {
    var n = Math.max(1, e.getBandWidth()), r = i[1] - i[0];
    return {
      type: "Rect",
      shape: ZB([t - n / 2, i[0]], [n, r], m_(e))
    };
  }
};
function m_(e) {
  return e.dim === "x" ? 0 : 1;
}
var JB = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "axisPointer", t.defaultOption = {
      // 'auto' means that show when triggered by tooltip or handle.
      show: "auto",
      // zlevel: 0,
      z: 50,
      type: "line",
      // axispointer triggered by tootip determine snap automatically,
      // see `modelHelper`.
      snap: !1,
      triggerTooltip: !0,
      triggerEmphasis: !0,
      value: null,
      status: null,
      link: [],
      // Do not set 'auto' here, otherwise global animation: false
      // will not effect at this axispointer.
      animation: null,
      animationDurationUpdate: 200,
      lineStyle: {
        color: St.color.border,
        width: 1,
        type: "dashed"
      },
      shadowStyle: {
        color: St.color.shadowTint
      },
      label: {
        show: !0,
        formatter: null,
        precision: "auto",
        margin: 3,
        color: St.color.neutral00,
        padding: [5, 7, 5, 7],
        backgroundColor: St.color.accent60,
        borderColor: null,
        borderWidth: 0,
        borderRadius: 3
      },
      handle: {
        show: !1,
        // eslint-disable-next-line
        icon: "M10.7,11.9v-1.3H9.3v1.3c-4.9,0.3-8.8,4.4-8.8,9.4c0,5,3.9,9.1,8.8,9.4h1.3c4.9-0.3,8.8-4.4,8.8-9.4C19.5,16.3,15.6,12.2,10.7,11.9z M13.3,24.4H6.7v-1.2h6.6z M13.3,22H6.7v-1.2h6.6z M13.3,19.6H6.7v-1.2h6.6z",
        size: 45,
        // handle margin is from symbol center to axis, which is stable when circular move.
        margin: 50,
        // color: '#1b8bbd'
        // color: '#2f4554'
        color: St.color.accent40,
        // For mobile performance
        throttle: 40
      }
    }, t;
  })(Pt)
), bn = Gt(), t3 = E;
function Kw(e, t, i) {
  if (!ot.node) {
    var n = t.getZr();
    bn(n).records || (bn(n).records = {}), e3(n, t);
    var r = bn(n).records[e] || (bn(n).records[e] = {});
    r.handler = i;
  }
}
function e3(e, t) {
  if (bn(e).initialized)
    return;
  bn(e).initialized = !0, i("click", Oe(y_, "click")), i("mousemove", Oe(y_, "mousemove")), i("globalout", n3);
  function i(n, r) {
    e.on(n, function(a) {
      var s = r3(t);
      t3(bn(e).records, function(o) {
        o && r(o, a, s.dispatchAction);
      }), i3(s.pendings, t);
    });
  }
}
function i3(e, t) {
  var i = e.showTip.length, n = e.hideTip.length, r;
  i ? r = e.showTip[i - 1] : n && (r = e.hideTip[n - 1]), r && (r.dispatchAction = null, t.dispatchAction(r));
}
function n3(e, t, i) {
  e.handler("leave", null, i);
}
function y_(e, t, i, n) {
  t.handler(e, i, n);
}
function r3(e) {
  var t = {
    showTip: [],
    hideTip: []
  }, i = function(n) {
    var r = t[n.type];
    r ? r.push(n) : (n.dispatchAction = i, e.dispatchAction(n));
  };
  return {
    dispatchAction: i,
    pendings: t
  };
}
function Wf(e, t) {
  if (!ot.node) {
    var i = t.getZr(), n = (bn(i).records || {})[e];
    n && (bn(i).records[e] = null);
  }
}
var a3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      var a = n.getComponent("tooltip"), s = i.get("triggerOn") || a && a.get("triggerOn") || "mousemove|click";
      Kw("axisPointer", r, function(o, l, u) {
        s !== "none" && (o === "leave" || s.indexOf(o) >= 0) && u({
          type: "updateAxisPointer",
          currTrigger: o,
          x: l && l.offsetX,
          y: l && l.offsetY
        });
      });
    }, t.prototype.remove = function(i, n) {
      Wf("axisPointer", n);
    }, t.prototype.dispose = function(i, n) {
      Wf("axisPointer", n);
    }, t.type = "axisPointer", t;
  })(En)
);
function Qw(e, t) {
  var i = [], n = e.seriesIndex, r;
  if (n == null || !(r = t.getSeriesByIndex(n)))
    return {
      point: []
    };
  var a = r.getData(), s = Ko(a, e);
  if (s == null || s < 0 || K(s))
    return {
      point: []
    };
  var o = a.getItemGraphicEl(s), l = r.coordinateSystem;
  if (r.getTooltipPosition)
    i = r.getTooltipPosition(s) || [];
  else if (l && l.dataToPoint)
    if (e.isStacked) {
      var u = l.getBaseAxis(), c = l.getOtherAxis(u), h = c.dim, d = u.dim, f = h === "x" || h === "radius" ? 1 : 0, v = a.mapDimension(d), m = [];
      m[f] = a.get(v, s), m[1 - f] = a.get(a.getCalculationInfo("stackResultDimension"), s), i = l.dataToPoint(m) || [];
    } else
      i = l.dataToPoint(a.getValues(_t(l.dimensions, function(g) {
        return a.mapDimension(g);
      }), s)) || [];
  else if (o) {
    var p = o.getBoundingRect().clone();
    p.applyTransform(o.transform), i = [p.x + p.width / 2, p.y + p.height / 2];
  }
  return {
    point: i,
    el: o
  };
}
var __ = Gt();
function s3(e, t, i) {
  var n = e.currTrigger, r = [e.x, e.y], a = e, s = e.dispatchAction || Dt(i.dispatchAction, i), o = t.getComponent("axisPointer").coordSysAxesInfo;
  if (o) {
    vu(r) && (r = Qw({
      seriesIndex: a.seriesIndex,
      // Do not use dataIndexInside from other ec instance.
      // FIXME: auto detect it?
      dataIndex: a.dataIndex
    }, t).point);
    var l = vu(r), u = a.axesInfo, c = o.axesInfo, h = n === "leave" || vu(r), d = {}, f = {}, v = {
      list: [],
      map: {}
    }, m = {
      showPointer: Oe(l3, f),
      showTooltip: Oe(u3, v)
    };
    E(o.coordSysMap, function(g, y) {
      var _ = l || g.containPoint(r);
      E(o.coordSysAxesInfo[y], function(b, w) {
        var S = b.axis, M = f3(u, b);
        if (!h && _ && (!u || M)) {
          var k = M && M.value;
          k == null && !l && (k = S.pointToData(r)), k != null && b_(b, k, m, !1, d);
        }
      });
    });
    var p = {};
    return E(c, function(g, y) {
      var _ = g.linkGroup;
      _ && !f[y] && E(_.axesInfo, function(b, w) {
        var S = f[w];
        if (b !== g && S) {
          var M = S.value;
          _.mapper && (M = g.axis.scale.parse(_.mapper(M, x_(b), x_(g)))), p[g.key] = M;
        }
      });
    }), E(p, function(g, y) {
      b_(c[y], g, m, !0, d);
    }), c3(f, c, d), h3(v, r, e, s), d3(c, s, i), d;
  }
}
function b_(e, t, i, n, r) {
  var a = e.axis;
  if (!(a.scale.isBlank() || !a.containData(t))) {
    if (!e.involveSeries) {
      i.showPointer(e, t);
      return;
    }
    var s = o3(t, e), o = s.payloadBatch, l = s.snapToValue;
    o[0] && r.seriesIndex == null && Y(r, o[0]), !n && e.snap && a.containData(l) && l != null && (t = l), i.showPointer(e, t, o), i.showTooltip(e, s, l);
  }
}
function o3(e, t) {
  var i = t.axis, n = i.dim, r = e, a = [], s = Number.MAX_VALUE, o = -1;
  return E(t.seriesModels, function(l, u) {
    var c = l.getData().mapDimensionsAll(n), h, d;
    if (l.getAxisTooltipData) {
      var f = l.getAxisTooltipData(c, e, i);
      d = f.dataIndices, h = f.nestestValue;
    } else {
      if (d = l.indicesOfNearest(
        n,
        c[0],
        e,
        // Add a threshold to avoid find the wrong dataIndex
        // when data length is not same.
        // false,
        i.type === "category" ? 0.5 : null
      ), !d.length)
        return;
      h = l.getData().get(c[0], d[0]);
    }
    if (!(h == null || !isFinite(h))) {
      var v = e - h, m = Math.abs(v);
      m <= s && ((m < s || v >= 0 && o < 0) && (s = m, o = v, r = h, a.length = 0), E(d, function(p) {
        a.push({
          seriesIndex: l.seriesIndex,
          dataIndexInside: p,
          dataIndex: l.getData().getRawIndex(p)
        });
      }));
    }
  }), {
    payloadBatch: a,
    snapToValue: r
  };
}
function l3(e, t, i, n) {
  e[t.key] = {
    value: i,
    payloadBatch: n
  };
}
function u3(e, t, i, n) {
  var r = i.payloadBatch, a = t.axis, s = a.model, o = t.axisPointerModel;
  if (!(!t.triggerTooltip || !r.length)) {
    var l = t.coordSys.model, u = Ho(l), c = e.map[u];
    c || (c = e.map[u] = {
      coordSysId: l.id,
      coordSysIndex: l.componentIndex,
      coordSysType: l.type,
      coordSysMainType: l.mainType,
      dataByAxis: []
    }, e.list.push(c)), c.dataByAxis.push({
      axisDim: a.dim,
      axisIndex: s.componentIndex,
      axisType: s.type,
      axisId: s.id,
      value: n,
      // Caustion: viewHelper.getValueLabel is actually on "view stage", which
      // depends that all models have been updated. So it should not be performed
      // here. Considering axisPointerModel used here is volatile, which is hard
      // to be retrieve in TooltipView, we prepare parameters here.
      valueLabelOpt: {
        precision: o.get(["label", "precision"]),
        formatter: o.get(["label", "formatter"])
      },
      seriesDataIndices: r.slice()
    });
  }
}
function c3(e, t, i) {
  var n = i.axesInfo = [];
  E(t, function(r, a) {
    var s = r.axisPointerModel.option, o = e[a];
    o ? (!r.useHandle && (s.status = "show"), s.value = o.value, s.seriesDataIndices = (o.payloadBatch || []).slice()) : !r.useHandle && (s.status = "hide"), s.status === "show" && n.push({
      axisDim: r.axis.dim,
      axisIndex: r.axis.model.componentIndex,
      value: s.value
    });
  });
}
function h3(e, t, i, n) {
  if (vu(t) || !e.list.length) {
    n({
      type: "hideTip"
    });
    return;
  }
  var r = ((e.list[0].dataByAxis[0] || {}).seriesDataIndices || [])[0] || {};
  n({
    type: "showTip",
    escapeConnect: !0,
    x: t[0],
    y: t[1],
    tooltipOption: i.tooltipOption,
    position: i.position,
    dataIndexInside: r.dataIndexInside,
    dataIndex: r.dataIndex,
    seriesIndex: r.seriesIndex,
    dataByCoordSys: e.list
  });
}
function d3(e, t, i) {
  var n = i.getZr(), r = "axisPointerLastHighlights", a = __(n)[r] || {}, s = __(n)[r] = {};
  E(e, function(u, c) {
    var h = u.axisPointerModel.option;
    h.status === "show" && u.triggerEmphasis && E(h.seriesDataIndices, function(d) {
      var f = d.seriesIndex + " | " + d.dataIndex;
      s[f] = d;
    });
  });
  var o = [], l = [];
  E(a, function(u, c) {
    !s[c] && l.push(u);
  }), E(s, function(u, c) {
    !a[c] && o.push(u);
  }), l.length && i.dispatchAction({
    type: "downplay",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: l
  }), o.length && i.dispatchAction({
    type: "highlight",
    escapeConnect: !0,
    // Not blur others when highlight in axisPointer.
    notBlur: !0,
    batch: o
  });
}
function f3(e, t) {
  for (var i = 0; i < (e || []).length; i++) {
    var n = e[i];
    if (t.axis.dim === n.axisDim && t.axis.model.componentIndex === n.axisIndex)
      return n;
  }
}
function x_(e) {
  var t = e.axis.model, i = {}, n = i.axisDim = e.axis.dim;
  return i.axisIndex = i[n + "AxisIndex"] = t.componentIndex, i.axisName = i[n + "AxisName"] = t.name, i.axisId = i[n + "AxisId"] = t.id, i;
}
function vu(e) {
  return !e || e[0] == null || isNaN(e[0]) || e[1] == null || isNaN(e[1]);
}
function v3(e) {
  YB.registerAxisPointerClass("CartesianAxisPointer", KB), e.registerComponentModel(JB), e.registerComponentView(a3), e.registerPreprocessor(function(t) {
    if (t) {
      (!t.axisPointer || t.axisPointer.length === 0) && (t.axisPointer = {});
      var i = t.axisPointer.link;
      i && !K(i) && (t.axisPointer.link = [i]);
    }
  }), e.registerProcessor(e.PRIORITY.PROCESSOR.STATISTIC, function(t, i) {
    t.getComponent("axisPointer").coordSysAxesInfo = NB(t, i);
  }), e.registerAction({
    type: "updateAxisPointer",
    event: "updateAxisPointer",
    update: ":updateAxisPointer"
  }, s3);
}
function p3(e, t, i) {
  var n = e.target;
  n.x += t, n.y += i, n.dirty();
}
function g3(e, t, i, n) {
  var r = e.target, a = e.zoomLimit, s = e.zoom = e.zoom || 1;
  s *= t, s = _p(s, a);
  var o = s / e.zoom;
  e.zoom = s, Jw(r, i, n, o), r.dirty();
}
function m3(e, t, i, n, r, a) {
  var s = new lt(0, 0, 0, 0);
  n.enable(e.get("roam"), {
    api: t,
    zInfo: {
      component: e
    },
    triggerInfo: {
      roamTrigger: e.get("roamTrigger"),
      isInSelf: function(u, c, h) {
        return s.copy(i.getBoundingRect()), s.applyTransform(i.getComputedTransform()), s.contain(c, h);
      },
      isInClip: function(u, c, h) {
        return !0;
      }
    }
  }), r.zoomLimit = e.get("scaleLimit");
  var o = e.coordinateSystem;
  r.zoom = o ? o.getZoom() : 1;
  var l = e.subType + "Roam";
  n.off("pan").off("zoom").on("pan", function(u) {
    p3(r, u.dx, u.dy), t.dispatchAction({
      seriesId: e.id,
      type: l,
      dx: u.dx,
      dy: u.dy
    });
  }).on("zoom", function(u) {
    g3(r, u.scale, u.originX, u.originY), t.dispatchAction({
      seriesId: e.id,
      type: l,
      zoom: u.scale,
      originX: u.originX,
      originY: u.originY
    }), t.updateLabelLayout();
  });
}
function w_(e, t) {
  return e.pointToProjected ? e.pointToProjected(t) : e.pointToData(t);
}
function y3(e, t, i) {
  var n = e.getZoom(), r = e.getCenter(), a = t.zoom, s = e.projectedToPoint ? e.projectedToPoint(r) : e.dataToPoint(r);
  return t.dx != null && t.dy != null && (s[0] -= t.dx, s[1] -= t.dy, e.setCenter(w_(e, s))), a != null && (a = _p(n * a, i) / n, Jw(e, t.originX, t.originY, a), e.updateTransform(), e.setCenter(w_(e, s)), e.setZoom(a * n)), {
    center: e.getCenter(),
    zoom: e.getZoom()
  };
}
function Jw(e, t, i, n) {
  e.x -= (t - e.x) * (n - 1), e.y -= (i - e.y) * (n - 1), e.scaleX *= n, e.scaleY *= n;
}
function _p(e, t) {
  if (t) {
    var i = t.min || 0, n = t.max || 1 / 0;
    e = Math.max(Math.min(n, e), i);
  }
  return e;
}
var S_ = Je, _3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i, n) {
      var r = e.call(this) || this;
      return r.type = "view", r.dimensions = ["x", "y"], r._roamTransformable = new Wr(), r._rawTransformable = new Wr(), r.name = i, r._opt = n, r;
    }
    return t.prototype.setBoundingRect = function(i, n, r, a) {
      return this._rect = new lt(i, n, r, a), this._updateCenterAndZoom(), this._rect;
    }, t.prototype.getBoundingRect = function() {
      return this._rect;
    }, t.prototype.setViewRect = function(i, n, r, a) {
      this._transformTo(i, n, r, a), this._viewRect = new lt(i, n, r, a);
    }, t.prototype._transformTo = function(i, n, r, a) {
      var s = this.getBoundingRect(), o = this._rawTransformable;
      o.transform = s.calculateTransform(new lt(i, n, r, a));
      var l = o.parent;
      o.parent = null, o.decomposeTransform(), o.parent = l, this._updateTransform();
    }, t.prototype.setCenter = function(i) {
      var n = this._opt;
      n && n.api && n.ecModel && n.ecModel.getShallow("legacyViewCoordSysCenterBase") && i && (i = [Ye(i[0], n.api.getWidth()), Ye(i[1], n.api.getWidth())]), this._centerOption = pt(i), this._updateCenterAndZoom();
    }, t.prototype.setZoom = function(i) {
      this._zoom = _p(i || 1, this.zoomLimit), this._updateCenterAndZoom();
    }, t.prototype.getDefaultCenter = function() {
      var i = this.getBoundingRect(), n = i.x + i.width / 2, r = i.y + i.height / 2;
      return [n, r];
    }, t.prototype.getCenter = function() {
      return this._center || this.getDefaultCenter();
    }, t.prototype.getZoom = function() {
      return this._zoom || 1;
    }, t.prototype.getRoamTransform = function() {
      return this._roamTransformable.getLocalTransform();
    }, t.prototype._updateCenterAndZoom = function() {
      var i = this._centerOption, n = this._rect;
      i && n && (this._center = [Ye(i[0], n.width, n.x), Ye(i[1], n.height, n.y)]);
      var r = this._rawTransformable.getLocalTransform(), a = this._roamTransformable, s = this.getDefaultCenter(), o = this.getCenter(), l = this.getZoom();
      o = Je([], o, r), s = Je([], s, r), a.originX = o[0], a.originY = o[1], a.x = s[0] - o[0], a.y = s[1] - o[1], a.scaleX = a.scaleY = l, this._updateTransform();
    }, t.prototype._updateTransform = function() {
      var i = this._roamTransformable, n = this._rawTransformable;
      n.parent = i, i.updateTransform(), n.updateTransform(), Tv(this.transform || (this.transform = []), n.transform || Ki()), this._rawTransform = n.getLocalTransform(), this.invTransform = this.invTransform || [], qo(this.invTransform, this.transform), this.decomposeTransform();
    }, t.prototype.getTransformInfo = function() {
      var i = this._rawTransformable, n = this._roamTransformable, r = new Wr();
      return r.transform = n.transform, r.decomposeTransform(), {
        roam: {
          x: r.x,
          y: r.y,
          scaleX: r.scaleX,
          scaleY: r.scaleY
        },
        raw: {
          x: i.x,
          y: i.y,
          scaleX: i.scaleX,
          scaleY: i.scaleY
        }
      };
    }, t.prototype.getViewRect = function() {
      return this._viewRect;
    }, t.prototype.getViewRectAfterRoam = function() {
      var i = this.getBoundingRect().clone();
      return i.applyTransform(this.transform), i;
    }, t.prototype.dataToPoint = function(i, n, r) {
      var a = n ? this._rawTransform : this.transform;
      return r = r || [], a ? S_(r, i, a) : eP(r, i);
    }, t.prototype.pointToData = function(i, n, r) {
      r = r || [];
      var a = this.invTransform;
      return a ? S_(r, i, a) : (r[0] = i[0], r[1] = i[1], r);
    }, t.prototype.convertToPixel = function(i, n, r) {
      var a = M_(n);
      return a === this ? a.dataToPoint(r) : null;
    }, t.prototype.convertFromPixel = function(i, n, r) {
      var a = M_(n);
      return a === this ? a.pointToData(r) : null;
    }, t.prototype.containPoint = function(i) {
      return this.getViewRectAfterRoam().contain(i[0], i[1]);
    }, t.dimensions = ["x", "y"], t;
  })(Wr)
);
function M_(e) {
  var t = e.seriesModel;
  return t ? t.coordinateSystem : null;
}
var b3 = Gt();
function k_(e, t) {
  return !!b3(e)[t];
}
fa({
  type: "takeGlobalCursor",
  event: "globalCursorTaken",
  update: "update"
}, ke);
var x3 = {
  axisPointer: 1,
  tooltip: 1,
  brush: 1
};
function w3(e, t, i) {
  var n = t.getComponentByElement(e.topTarget);
  if (!n || n === i || x3.hasOwnProperty(n.mainType))
    return !1;
  var r = n.coordinateSystem;
  if (!r || r.model === i)
    return !1;
  var a = Fo(n), s = Fo(i);
  return !((a.zlevel - s.zlevel || a.z - s.z) <= 0);
}
var S3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i) {
      var n = e.call(this) || this;
      n._zr = i;
      var r = Dt(n._mousedownHandler, n), a = Dt(n._mousemoveHandler, n), s = Dt(n._mouseupHandler, n), o = Dt(n._mousewheelHandler, n), l = Dt(n._pinchHandler, n);
      return n.enable = function(u, c) {
        var h = c.zInfo, d = Fo(h.component), f = d.z, v = d.zlevel, m = {
          component: h.component,
          z: f,
          zlevel: v,
          // By default roam controller is the lowest z2 comparing to other elememts in a component.
          z2: rt(h.z2, -1 / 0)
        }, p = Y({}, c.triggerInfo);
        this._opt = Jt(Y({}, c), {
          zoomOnMouseWheel: !0,
          moveOnMouseMove: !0,
          // By default, wheel do not trigger move.
          moveOnMouseWheel: !1,
          preventDefaultMouseMove: !0,
          zInfoParsed: m,
          triggerInfo: p
        }), u == null && (u = !0), (!this._enabled || this._controlType !== u) && (this._enabled = !0, this.disable(), (u === !0 || u === "move" || u === "pan") && (Ys(i, "mousedown", r, m), Ys(i, "mousemove", a, m), Ys(i, "mouseup", s, m)), (u === !0 || u === "scale" || u === "zoom") && (Ys(i, "mousewheel", o, m), Ys(i, "pinch", l, m)));
      }, n.disable = function() {
        this._enabled = !1, Ws(i, "mousedown", r), Ws(i, "mousemove", a), Ws(i, "mouseup", s), Ws(i, "mousewheel", o), Ws(i, "pinch", l);
      }, n;
    }
    return t.prototype.isDragging = function() {
      return this._dragging;
    }, t.prototype.isPinching = function() {
      return this._pinching;
    }, t.prototype._checkPointer = function(i, n, r) {
      var a = this._opt, s = a.zInfoParsed;
      if (w3(i, a.api, s.component))
        return !1;
      var o = a.triggerInfo, l = o.roamTrigger, u = !1;
      return l === "global" && (u = !0), u || (u = o.isInSelf(i, n, r)), u && o.isInClip && !o.isInClip(i, n, r) && (u = !1), u;
    }, t.prototype._decideCursorStyle = function(i, n, r, a) {
      var s = i.target;
      if (!s && this._checkPointer(i, n, r))
        return "grab";
      if (a)
        return s && s.cursor || "default";
    }, t.prototype.dispose = function() {
      this.disable();
    }, t.prototype._mousedownHandler = function(i) {
      if (!(wm(i) || Hs(i))) {
        for (var n = i.target; n; ) {
          if (n.draggable)
            return;
          n = n.__hostTarget || n.parent;
        }
        var r = i.offsetX, a = i.offsetY;
        this._checkPointer(i, r, a) && (this._x = r, this._y = a, this._dragging = !0);
      }
    }, t.prototype._mousemoveHandler = function(i) {
      var n = this._zr;
      if (!(i.gestureEvent === "pinch" || k_(n, "globalPan") || Hs(i))) {
        var r = i.offsetX, a = i.offsetY;
        if (!this._dragging || !pu("moveOnMouseMove", i, this._opt)) {
          var s = this._decideCursorStyle(i, r, a, !1);
          s && n.setCursorStyle(s);
          return;
        }
        n.setCursorStyle("grabbing");
        var o = this._x, l = this._y, u = r - o, c = a - l;
        this._x = r, this._y = a, this._opt.preventDefaultMouseMove && Eu(i.event), i.__ecRoamConsumed = !0, D_(this, "pan", "moveOnMouseMove", i, {
          dx: u,
          dy: c,
          oldX: o,
          oldY: l,
          newX: r,
          newY: a,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._mouseupHandler = function(i) {
      if (!Hs(i)) {
        var n = this._zr;
        if (!wm(i)) {
          this._dragging = !1;
          var r = this._decideCursorStyle(i, i.offsetX, i.offsetY, !0);
          r && n.setCursorStyle(r);
        }
      }
    }, t.prototype._mousewheelHandler = function(i) {
      if (!Hs(i)) {
        var n = pu("zoomOnMouseWheel", i, this._opt), r = pu("moveOnMouseWheel", i, this._opt), a = i.wheelDelta, s = Math.abs(a), o = i.offsetX, l = i.offsetY;
        if (!(a === 0 || !n && !r)) {
          if (n) {
            var u = s > 3 ? 1.4 : s > 1 ? 1.2 : 1.1, c = a > 0 ? u : 1 / u;
            this._checkTriggerMoveZoom(this, "zoom", "zoomOnMouseWheel", i, {
              scale: c,
              originX: o,
              originY: l,
              isAvailableBehavior: null
            });
          }
          if (r) {
            var h = Math.abs(a), d = (a > 0 ? 1 : -1) * (h > 3 ? 0.4 : h > 1 ? 0.15 : 0.05);
            this._checkTriggerMoveZoom(this, "scrollMove", "moveOnMouseWheel", i, {
              scrollDelta: d,
              originX: o,
              originY: l,
              isAvailableBehavior: null
            });
          }
        }
      }
    }, t.prototype._pinchHandler = function(i) {
      if (!(k_(this._zr, "globalPan") || Hs(i))) {
        var n = i.pinchScale > 1 ? 1.1 : 1 / 1.1;
        this._checkTriggerMoveZoom(this, "zoom", null, i, {
          scale: n,
          originX: i.pinchX,
          originY: i.pinchY,
          isAvailableBehavior: null
        });
      }
    }, t.prototype._checkTriggerMoveZoom = function(i, n, r, a, s) {
      i._checkPointer(a, s.originX, s.originY) && (Eu(a.event), a.__ecRoamConsumed = !0, D_(i, n, r, a, s));
    }, t;
  })(Li)
);
function Hs(e) {
  return e.__ecRoamConsumed;
}
var M3 = Gt();
function Hc(e) {
  var t = M3(e);
  return t.roam = t.roam || {}, t.uniform = t.uniform || {}, t;
}
function Ys(e, t, i, n) {
  for (var r = Hc(e), a = r.roam, s = a[t] = a[t] || [], o = 0; o < s.length; o++) {
    var l = s[o].zInfoParsed;
    if ((l.zlevel - n.zlevel || l.z - n.z || l.z2 - n.z2) <= 0)
      break;
  }
  s.splice(o, 0, {
    listener: i,
    zInfoParsed: n
  }), k3(e, t);
}
function Ws(e, t, i) {
  for (var n = Hc(e), r = n.roam[t] || [], a = 0; a < r.length; a++)
    if (r[a].listener === i) {
      r.splice(a, 1), r.length || D3(e, t);
      return;
    }
}
function k3(e, t) {
  var i = Hc(e);
  i.uniform[t] || e.on(t, i.uniform[t] = function(n) {
    var r = i.roam[t];
    if (r)
      for (var a = 0; a < r.length; a++)
        r[a].listener(n);
  });
}
function D3(e, t) {
  var i = Hc(e), n = i.uniform;
  n[t] && (e.off(t, n[t]), n[t] = null);
}
function D_(e, t, i, n, r) {
  r.isAvailableBehavior = Dt(pu, null, i, n), e.trigger(t, r);
}
function pu(e, t, i) {
  var n = i[e];
  return !e || n && (!et(n) || t.event[n + "Key"]);
}
var T3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.type = "tooltip", t.dependencies = ["axisPointer"], t.defaultOption = {
      // zlevel: 0,
      z: 60,
      show: !0,
      // tooltip main content
      showContent: !0,
      // 'trigger' only works on coordinate system.
      // 'item' | 'axis' | 'none'
      trigger: "item",
      // 'click' | 'mousemove' | 'none'
      triggerOn: "mousemove|click",
      alwaysShowContent: !1,
      renderMode: "auto",
      // whether restraint content inside viewRect.
      // If renderMode: 'richText', default true.
      // If renderMode: 'html', defaults to `false` (for backward compat).
      confine: null,
      showDelay: 0,
      hideDelay: 100,
      // Animation transition time, unit is second
      transitionDuration: 0.4,
      displayTransition: !0,
      enterable: !1,
      backgroundColor: St.color.neutral00,
      // box shadow
      shadowBlur: 10,
      shadowColor: "rgba(0, 0, 0, .2)",
      shadowOffsetX: 1,
      shadowOffsetY: 2,
      // tooltip border radius, unit is px, default is 4
      borderRadius: 4,
      // tooltip border width, unit is px, default is 0 (no border)
      borderWidth: 1,
      defaultBorderColor: St.color.border,
      // Tooltip inside padding, default is 5 for all direction
      // Array is allowed to set up, right, bottom, left, same with css
      // The default value: See `tooltip/tooltipMarkup.ts#getPaddingFromTooltipModel`.
      padding: null,
      // Extra css text
      extraCssText: "",
      // axis indicator, trigger by axis
      axisPointer: {
        // default is line
        // legal values: 'line' | 'shadow' | 'cross'
        type: "line",
        // Valid when type is line, appoint tooltip line locate on which line. Optional
        // legal values: 'x' | 'y' | 'angle' | 'radius' | 'auto'
        // default is 'auto', chose the axis which type is category.
        // for multiply y axis, cartesian coord chose x axis, polar chose angle axis
        axis: "auto",
        animation: "auto",
        animationDurationUpdate: 200,
        animationEasingUpdate: "exponentialOut",
        crossStyle: {
          color: St.color.borderShade,
          width: 1,
          type: "dashed",
          // TODO formatter
          textStyle: {}
        }
        // lineStyle and shadowStyle should not be specified here,
        // otherwise it will always override those styles on option.axisPointer.
      },
      textStyle: {
        color: St.color.tertiary,
        fontSize: 14
      }
    }, t;
  })(Pt)
);
function tS(e) {
  var t = e.get("confine");
  return t != null ? !!t : e.get("renderMode") === "richText";
}
function eS(e) {
  if (ot.domSupported) {
    for (var t = document.documentElement.style, i = 0, n = e.length; i < n; i++)
      if (e[i] in t)
        return e[i];
  }
}
var iS = eS(["transform", "webkitTransform", "OTransform", "MozTransform", "msTransform"]), C3 = eS(["webkitTransition", "transition", "OTransition", "MozTransition", "msTransition"]);
function nS(e, t) {
  if (!e)
    return t;
  t = Tx(t, !0);
  var i = e.indexOf(t);
  return e = i === -1 ? t : "-" + e.slice(0, i) + "-" + t, e.toLowerCase();
}
function E3(e, t) {
  var i = e.currentStyle || document.defaultView && document.defaultView.getComputedStyle(e);
  return i ? i[t] : null;
}
var A3 = nS(C3, "transition"), bp = nS(iS, "transform"), P3 = "position:absolute;display:block;border-style:solid;white-space:nowrap;z-index:9999999;" + (ot.transform3dSupported ? "will-change:transform;" : "");
function L3(e) {
  return e = e === "left" ? "right" : e === "right" ? "left" : e === "top" ? "bottom" : "top", e;
}
function O3(e, t, i) {
  if (!et(i) || i === "inside")
    return "";
  var n = e.get("backgroundColor"), r = e.get("borderWidth");
  t = Bo(t);
  var a = L3(i), s = Math.max(Math.round(r) * 1.5, 6), o = "", l = bp + ":", u;
  Ht(["left", "right"], a) > -1 ? (o += "top:50%", l += "translateY(-50%) rotate(" + (u = a === "left" ? -225 : -45) + "deg)") : (o += "left:50%", l += "translateX(-50%) rotate(" + (u = a === "top" ? 225 : 45) + "deg)");
  var c = u * Math.PI / 180, h = s + r, d = h * Math.abs(Math.cos(c)) + h * Math.abs(Math.sin(c)), f = Math.round(((d - Math.SQRT2 * r) / 2 + Math.SQRT2 * r - (d - h) / 2) * 100) / 100;
  o += ";" + a + ":-" + f + "px";
  var v = t + " solid " + r + "px;", m = ["position:absolute;width:" + s + "px;height:" + s + "px;z-index:-1;", o + ";" + l + ";", "border-bottom:" + v, "border-right:" + v, "background-color:" + n + ";"];
  return '<div style="' + m.join("") + '"></div>';
}
function I3(e, t, i) {
  var n = "cubic-bezier(0.23,1,0.32,1)", r = "", a = "";
  return i && (r = " " + e / 2 + "s " + n, a = "opacity" + r + ",visibility" + r), t || (r = " " + e + "s " + n, a += (a.length ? "," : "") + (ot.transformSupported ? "" + bp + r : ",left" + r + ",top" + r)), A3 + ":" + a;
}
function T_(e, t, i) {
  var n = e.toFixed(0) + "px", r = t.toFixed(0) + "px";
  if (!ot.transformSupported)
    return i ? "top:" + r + ";left:" + n + ";" : [["top", r], ["left", n]];
  var a = ot.transform3dSupported, s = "translate" + (a ? "3d" : "") + "(" + n + "," + r + (a ? ",0" : "") + ")";
  return i ? "top:0;left:0;" + bp + ":" + s + ";" : [["top", 0], ["left", 0], [iS, s]];
}
function R3(e) {
  var t = [], i = e.get("fontSize"), n = e.getTextColor();
  n && t.push("color:" + n), t.push("font:" + e.getFont());
  var r = rt(e.get("lineHeight"), Math.round(i * 3 / 2));
  i && t.push("line-height:" + r + "px");
  var a = e.get("textShadowColor"), s = e.get("textShadowBlur") || 0, o = e.get("textShadowOffsetX") || 0, l = e.get("textShadowOffsetY") || 0;
  return a && s && t.push("text-shadow:" + o + "px " + l + "px " + s + "px " + a), E(["decoration", "align"], function(u) {
    var c = e.get(u);
    c && t.push("text-" + u + ":" + c);
  }), t.join(";");
}
function N3(e, t, i, n) {
  var r = [], a = e.get("transitionDuration"), s = e.get("backgroundColor"), o = e.get("shadowBlur"), l = e.get("shadowColor"), u = e.get("shadowOffsetX"), c = e.get("shadowOffsetY"), h = e.getModel("textStyle"), d = ew(e, "html"), f = u + "px " + c + "px " + o + "px " + l;
  return r.push("box-shadow:" + f), t && a > 0 && r.push(I3(a, i, n)), s && r.push("background-color:" + s), E(["width", "color", "radius"], function(v) {
    var m = "border-" + v, p = Tx(m), g = e.get(p);
    g != null && r.push(m + ":" + g + (v === "color" ? "" : "px"));
  }), r.push(R3(h)), d != null && r.push("padding:" + ip(d).join("px ") + "px"), r.join(";") + ";";
}
function C_(e, t, i, n, r) {
  var a = t && t.painter;
  if (i) {
    var s = a && a.getViewportRoot();
    s && hP(e, s, i, n, r);
  } else {
    e[0] = n, e[1] = r;
    var o = a && a.getViewportRootOffset();
    o && (e[0] += o.offsetLeft, e[1] += o.offsetTop);
  }
  e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var F3 = (
  /** @class */
  (function() {
    function e(t, i) {
      if (this._show = !1, this._styleCoord = [0, 0, 0, 0], this._enterable = !0, this._alwaysShowContent = !1, this._firstShow = !0, this._longHide = !0, ot.wxa)
        return null;
      var n = document.createElement("div");
      n.domBelongToZr = !0, this.el = n;
      var r = this._zr = t.getZr(), a = i.appendTo, s = a && (et(a) ? document.querySelector(a) : ss(a) ? a : mt(a) && a(t.getDom()));
      C_(this._styleCoord, r, s, t.getWidth() / 2, t.getHeight() / 2), (s || t.getDom()).appendChild(n), this._api = t, this._container = s;
      var o = this;
      n.onmouseenter = function() {
        o._enterable && (clearTimeout(o._hideTimeout), o._show = !0), o._inContent = !0;
      }, n.onmousemove = function(l) {
        if (l = l || window.event, !o._enterable) {
          var u = r.handler, c = r.painter.getViewportRoot();
          oi(c, l, !0), u.dispatch("mousemove", l);
        }
      }, n.onmouseleave = function() {
        o._inContent = !1, o._enterable && o._show && o.hideLater(o._hideDelay);
      };
    }
    return e.prototype.update = function(t) {
      if (!this._container) {
        var i = this._api.getDom(), n = E3(i, "position"), r = i.style;
        r.position !== "absolute" && n !== "absolute" && (r.position = "relative");
      }
      var a = t.get("alwaysShowContent");
      a && this._moveIfResized(), this._alwaysShowContent = a, this._enableDisplayTransition = t.get("displayTransition") && t.get("transitionDuration") > 0, this.el.className = t.get("className") || "";
    }, e.prototype.show = function(t, i) {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var n = this.el, r = n.style, a = this._styleCoord;
      n.innerHTML ? r.cssText = P3 + N3(t, !this._firstShow, this._longHide, this._enableDisplayTransition) + T_(a[0], a[1], !0) + ("border-color:" + Bo(i) + ";") + (t.get("extraCssText") || "") + (";pointer-events:" + (this._enterable ? "auto" : "none")) : r.display = "none", this._show = !0, this._firstShow = !1, this._longHide = !1;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var s = this.el;
      if (t == null) {
        s.innerHTML = "";
        return;
      }
      var o = "";
      if (et(a) && n.get("trigger") === "item" && !tS(n) && (o = O3(n, r, a)), et(t))
        s.innerHTML = t + o;
      else if (t) {
        s.innerHTML = "", K(t) || (t = [t]);
        for (var l = 0; l < t.length; l++)
          ss(t[l]) && t[l].parentNode !== s && s.appendChild(t[l]);
        if (o && s.childNodes.length) {
          var u = document.createElement("div");
          u.innerHTML = o, s.appendChild(u);
        }
      }
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el;
      return t ? [t.offsetWidth, t.offsetHeight] : [0, 0];
    }, e.prototype.moveTo = function(t, i) {
      if (this.el) {
        var n = this._styleCoord;
        if (C_(n, this._zr, this._container, t, i), n[0] != null && n[1] != null) {
          var r = this.el.style, a = T_(n[0], n[1]);
          E(a, function(s) {
            r[s[0]] = s[1];
          });
        }
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      var t = this, i = this.el.style;
      this._enableDisplayTransition ? (i.visibility = "hidden", i.opacity = "0") : i.display = "none", ot.transform3dSupported && (i.willChange = ""), this._show = !1, this._longHideTimeout = setTimeout(function() {
        return t._longHide = !0;
      }, 500);
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Dt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      clearTimeout(this._hideTimeout), clearTimeout(this._longHideTimeout);
      var t = this._zr;
      dP(t && t.painter && t.painter.getViewportRoot(), this._container);
      var i = this.el;
      if (i) {
        i.onmouseenter = i.onmousemove = i.onmouseleave = null;
        var n = i.parentNode;
        n && n.removeChild(i);
      }
      this.el = this._container = null;
    }, e;
  })()
), B3 = (
  /** @class */
  (function() {
    function e(t) {
      this._show = !1, this._styleCoord = [0, 0, 0, 0], this._alwaysShowContent = !1, this._enterable = !0, this._zr = t.getZr(), A_(this._styleCoord, this._zr, t.getWidth() / 2, t.getHeight() / 2);
    }
    return e.prototype.update = function(t) {
      var i = t.get("alwaysShowContent");
      i && this._moveIfResized(), this._alwaysShowContent = i;
    }, e.prototype.show = function() {
      this._hideTimeout && clearTimeout(this._hideTimeout), this.el.show(), this._show = !0;
    }, e.prototype.setContent = function(t, i, n, r, a) {
      var s = this;
      tt(t) && We(process.env.NODE_ENV !== "production" ? "Passing DOM nodes as content is not supported in richText tooltip!" : ""), this.el && this._zr.remove(this.el);
      var o = n.getModel("textStyle");
      this.el = new _i({
        style: {
          rich: i.richTextStyles,
          text: t,
          lineHeight: 22,
          borderWidth: 1,
          borderColor: r,
          textShadowColor: o.get("textShadowColor"),
          fill: n.get(["textStyle", "color"]),
          padding: ew(n, "richText"),
          verticalAlign: "top",
          align: "left"
        },
        z: n.get("z")
      }), E(["backgroundColor", "borderRadius", "shadowColor", "shadowBlur", "shadowOffsetX", "shadowOffsetY"], function(u) {
        s.el.style[u] = n.get(u);
      }), E(["textShadowBlur", "textShadowOffsetX", "textShadowOffsetY"], function(u) {
        s.el.style[u] = o.get(u) || 0;
      }), this._zr.add(this.el);
      var l = this;
      this.el.on("mouseover", function() {
        l._enterable && (clearTimeout(l._hideTimeout), l._show = !0), l._inContent = !0;
      }), this.el.on("mouseout", function() {
        l._enterable && l._show && l.hideLater(l._hideDelay), l._inContent = !1;
      });
    }, e.prototype.setEnterable = function(t) {
      this._enterable = t;
    }, e.prototype.getSize = function() {
      var t = this.el, i = this.el.getBoundingRect(), n = E_(t.style);
      return [i.width + n.left + n.right, i.height + n.top + n.bottom];
    }, e.prototype.moveTo = function(t, i) {
      var n = this.el;
      if (n) {
        var r = this._styleCoord;
        A_(r, this._zr, t, i), t = r[0], i = r[1];
        var a = n.style, s = Vn(a.borderWidth || 0), o = E_(a);
        n.x = t + s + o.left, n.y = i + s + o.top, n.markRedraw();
      }
    }, e.prototype._moveIfResized = function() {
      var t = this._styleCoord[2], i = this._styleCoord[3];
      this.moveTo(t * this._zr.getWidth(), i * this._zr.getHeight());
    }, e.prototype.hide = function() {
      this.el && this.el.hide(), this._show = !1;
    }, e.prototype.hideLater = function(t) {
      this._show && !(this._inContent && this._enterable) && !this._alwaysShowContent && (t ? (this._hideDelay = t, this._show = !1, this._hideTimeout = setTimeout(Dt(this.hide, this), t)) : this.hide());
    }, e.prototype.isShow = function() {
      return this._show;
    }, e.prototype.dispose = function() {
      this._zr.remove(this.el);
    }, e;
  })()
);
function Vn(e) {
  return Math.max(0, e);
}
function E_(e) {
  var t = Vn(e.shadowBlur || 0), i = Vn(e.shadowOffsetX || 0), n = Vn(e.shadowOffsetY || 0);
  return {
    left: Vn(t - i),
    right: Vn(t + i),
    top: Vn(t - n),
    bottom: Vn(t + n)
  };
}
function A_(e, t, i, n) {
  e[0] = i, e[1] = n, e[2] = e[0] / t.getWidth(), e[3] = e[1] / t.getHeight();
}
var $3 = new De({
  shape: {
    x: -1,
    y: -1,
    width: 2,
    height: 2
  }
}), z3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.init = function(i, n) {
      if (!(ot.node || !n.getDom())) {
        var r = i.getComponent("tooltip"), a = this._renderMode = UL(r.get("renderMode"));
        this._tooltipContent = a === "richText" ? new B3(n) : new F3(n, {
          appendTo: r.get("appendToBody", !0) ? "body" : r.get("appendTo", !0)
        });
      }
    }, t.prototype.render = function(i, n, r) {
      if (!(ot.node || !r.getDom())) {
        this.group.removeAll(), this._tooltipModel = i, this._ecModel = n, this._api = r;
        var a = this._tooltipContent;
        a.update(i), a.setEnterable(i.get("enterable")), this._initGlobalListener(), this._keepShow(), this._renderMode !== "richText" && i.get("transitionDuration") ? rw(this, "_updatePosition", 50, "fixRate") : Lf(this, "_updatePosition");
      }
    }, t.prototype._initGlobalListener = function() {
      var i = this._tooltipModel, n = i.get("triggerOn");
      Kw("itemTooltip", this._api, Dt(function(r, a, s) {
        n !== "none" && (n.indexOf(r) >= 0 ? this._tryShow(a, s) : r === "leave" && this._hide(s));
      }, this));
    }, t.prototype._keepShow = function() {
      var i = this._tooltipModel, n = this._ecModel, r = this._api, a = i.get("triggerOn");
      if (this._lastX != null && this._lastY != null && a !== "none" && a !== "click") {
        var s = this;
        clearTimeout(this._refreshUpdateTimeout), this._refreshUpdateTimeout = setTimeout(function() {
          !r.isDisposed() && s.manuallyShowTip(i, n, r, {
            x: s._lastX,
            y: s._lastY,
            dataByCoordSys: s._lastDataByCoordSys
          });
        });
      }
    }, t.prototype.manuallyShowTip = function(i, n, r, a) {
      if (!(a.from === this.uid || ot.node || !r.getDom())) {
        var s = P_(a, r);
        this._ticket = "";
        var o = a.dataByCoordSys, l = W3(a, n, r);
        if (l) {
          var u = l.el.getBoundingRect().clone();
          u.applyTransform(l.el.transform), this._tryShow({
            offsetX: u.x + u.width / 2,
            offsetY: u.y + u.height / 2,
            target: l.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, s);
        } else if (a.tooltip && a.x != null && a.y != null) {
          var c = $3;
          c.x = a.x, c.y = a.y, c.update(), Vt(c).tooltipConfig = {
            name: null,
            option: a.tooltip
          }, this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            target: c
          }, s);
        } else if (o)
          this._tryShow({
            offsetX: a.x,
            offsetY: a.y,
            position: a.position,
            dataByCoordSys: o,
            tooltipOption: a.tooltipOption
          }, s);
        else if (a.seriesIndex != null) {
          if (this._manuallyAxisShowTip(i, n, r, a))
            return;
          var h = Qw(a, n), d = h.point[0], f = h.point[1];
          d != null && f != null && this._tryShow({
            offsetX: d,
            offsetY: f,
            target: h.el,
            position: a.position,
            // When manully trigger, the mouse is not on the el, so we'd better to
            // position tooltip on the bottom of the el and display arrow is possible.
            positionDefault: "bottom"
          }, s);
        } else a.x != null && a.y != null && (r.dispatchAction({
          type: "updateAxisPointer",
          x: a.x,
          y: a.y
        }), this._tryShow({
          offsetX: a.x,
          offsetY: a.y,
          position: a.position,
          target: r.getZr().findHover(a.x, a.y).target
        }, s));
      }
    }, t.prototype.manuallyHideTip = function(i, n, r, a) {
      var s = this._tooltipContent;
      this._tooltipModel && s.hideLater(this._tooltipModel.get("hideDelay")), this._lastX = this._lastY = this._lastDataByCoordSys = null, a.from !== this.uid && this._hide(P_(a, r));
    }, t.prototype._manuallyAxisShowTip = function(i, n, r, a) {
      var s = a.seriesIndex, o = a.dataIndex, l = n.getComponent("axisPointer").coordSysAxesInfo;
      if (!(s == null || o == null || l == null)) {
        var u = n.getSeriesByIndex(s);
        if (u) {
          var c = u.getData(), h = Us([c.getItemModel(o), u, (u.coordinateSystem || {}).model], this._tooltipModel);
          if (h.get("trigger") === "axis")
            return r.dispatchAction({
              type: "updateAxisPointer",
              seriesIndex: s,
              dataIndex: o,
              position: a.position
            }), !0;
        }
      }
    }, t.prototype._tryShow = function(i, n) {
      var r = i.target, a = this._tooltipModel;
      if (a) {
        this._lastX = i.offsetX, this._lastY = i.offsetY;
        var s = i.dataByCoordSys;
        if (s && s.length)
          this._showAxisTooltip(s, i);
        else if (r) {
          var o = Vt(r);
          if (o.ssrType === "legend")
            return;
          this._lastDataByCoordSys = null;
          var l, u;
          ao(r, function(c) {
            if (c.tooltipDisabled)
              return l = u = null, !0;
            l || u || (Vt(c).dataIndex != null ? l = c : Vt(c).tooltipConfig != null && (u = c));
          }, !0), l ? this._showSeriesItemTooltip(i, l, n) : u ? this._showComponentItemTooltip(i, u, n) : this._hide(n);
        } else
          this._lastDataByCoordSys = null, this._hide(n);
      }
    }, t.prototype._showOrMove = function(i, n) {
      var r = i.get("showDelay");
      n = Dt(n, this), clearTimeout(this._showTimout), r > 0 ? this._showTimout = setTimeout(n, r) : n();
    }, t.prototype._showAxisTooltip = function(i, n) {
      var r = this._ecModel, a = this._tooltipModel, s = [n.offsetX, n.offsetY], o = Us([n.tooltipOption], a), l = this._renderMode, u = [], c = ua("section", {
        blocks: [],
        noHeader: !0
      }), h = [], d = new dd();
      E(i, function(y) {
        E(y.dataByAxis, function(_) {
          var b = r.getComponent(_.axisDim + "Axis", _.axisIndex), w = _.value;
          if (!(!b || w == null)) {
            var S = qw(w, b.axis, r, _.seriesDataIndices, _.valueLabelOpt), M = ua("section", {
              header: S,
              noHeader: !Xi(S),
              sortBlocks: !0,
              blocks: []
            });
            c.blocks.push(M), E(_.seriesDataIndices, function(k) {
              var T = r.getSeriesByIndex(k.seriesIndex), D = k.dataIndexInside, C = T.getDataParams(D);
              if (!(C.dataIndex < 0)) {
                C.axisDim = _.axisDim, C.axisIndex = _.axisIndex, C.axisType = _.axisType, C.axisId = _.axisId, C.axisValue = Vw(b.axis, {
                  value: w
                }), C.axisValueLabel = S, C.marker = d.makeTooltipMarker("item", Bo(C.color), l);
                var P = my(T.formatTooltip(D, !0, null)), L = P.frag;
                if (L) {
                  var O = Us([T], a).get("valueFormatter");
                  M.blocks.push(O ? Y({
                    valueFormatter: O
                  }, L) : L);
                }
                P.text && h.push(P.text), u.push(C);
              }
            });
          }
        });
      }), c.blocks.reverse(), h.reverse();
      var f = n.position, v = o.get("order"), m = wy(c, d, l, v, r.get("useUTC"), o.get("textStyle"));
      m && h.unshift(m);
      var p = l === "richText" ? `

` : "<br/>", g = h.join(p);
      this._showOrMove(o, function() {
        this._updateContentNotChangedOnAxis(i, u) ? this._updatePosition(o, f, s[0], s[1], this._tooltipContent, u) : this._showTooltipContent(o, g, u, Math.random() + "", s[0], s[1], f, null, d);
      });
    }, t.prototype._showSeriesItemTooltip = function(i, n, r) {
      var a = this._ecModel, s = Vt(n), o = s.seriesIndex, l = a.getSeriesByIndex(o), u = s.dataModel || l, c = s.dataIndex, h = s.dataType, d = u.getData(h), f = this._renderMode, v = i.positionDefault, m = Us([d.getItemModel(c), u, l && (l.coordinateSystem || {}).model], this._tooltipModel, v ? {
        position: v
      } : null), p = m.get("trigger");
      if (!(p != null && p !== "item")) {
        var g = u.getDataParams(c, h), y = new dd();
        g.marker = y.makeTooltipMarker("item", Bo(g.color), f);
        var _ = my(u.formatTooltip(c, !1, h)), b = m.get("order"), w = m.get("valueFormatter"), S = _.frag, M = S ? wy(w ? Y({
          valueFormatter: w
        }, S) : S, y, f, b, a.get("useUTC"), m.get("textStyle")) : _.text, k = "item_" + u.name + "_" + c;
        this._showOrMove(m, function() {
          this._showTooltipContent(m, M, g, k, i.offsetX, i.offsetY, i.position, i.target, y);
        }), r({
          type: "showTip",
          dataIndexInside: c,
          dataIndex: d.getRawIndex(c),
          seriesIndex: o,
          from: this.uid
        });
      }
    }, t.prototype._showComponentItemTooltip = function(i, n, r) {
      var a = this._renderMode === "html", s = Vt(n), o = s.tooltipConfig, l = o.option || {}, u = l.encodeHTMLContent;
      if (et(l)) {
        var c = l;
        l = {
          content: c,
          // Fixed formatter
          formatter: c
        }, u = !0;
      }
      u && a && l.content && (l = pt(l), l.content = Ve(l.content));
      var h = [l], d = this._ecModel.getComponent(s.componentMainType, s.componentIndex);
      d && h.push(d), h.push({
        formatter: l.content
      });
      var f = i.positionDefault, v = Us(h, this._tooltipModel, f ? {
        position: f
      } : null), m = v.get("content"), p = Math.random() + "", g = new dd();
      this._showOrMove(v, function() {
        var y = pt(v.get("formatterParams") || {});
        this._showTooltipContent(v, m, y, p, i.offsetX, i.offsetY, i.position, n, g);
      }), r({
        type: "showTip",
        from: this.uid
      });
    }, t.prototype._showTooltipContent = function(i, n, r, a, s, o, l, u, c) {
      if (this._ticket = "", !(!i.get("showContent") || !i.get("show"))) {
        var h = this._tooltipContent;
        h.setEnterable(i.get("enterable"));
        var d = i.get("formatter");
        l = l || i.get("position");
        var f = n, v = this._getNearestPoint([s, o], r, i.get("trigger"), i.get("borderColor"), i.get("defaultBorderColor", !0)), m = v.color;
        if (d)
          if (et(d)) {
            var p = i.ecModel.get("useUTC"), g = K(r) ? r[0] : r, y = g && g.axisType && g.axisType.indexOf("time") >= 0;
            f = d, y && (f = Dx(g.axisValue, f, p)), f = Cx(f, r, !0);
          } else if (mt(d)) {
            var _ = Dt(function(b, w) {
              b === this._ticket && (h.setContent(w, c, i, m, l), this._updatePosition(i, l, s, o, h, r, u));
            }, this);
            this._ticket = a, f = d(r, a, _);
          } else
            f = d;
        h.setContent(f, c, i, m, l), h.show(i, m), this._updatePosition(i, l, s, o, h, r, u);
      }
    }, t.prototype._getNearestPoint = function(i, n, r, a, s) {
      if (r === "axis" || K(n))
        return {
          color: a || s
        };
      if (!K(n))
        return {
          color: a || n.color || n.borderColor
        };
    }, t.prototype._updatePosition = function(i, n, r, a, s, o, l) {
      var u = this._api.getWidth(), c = this._api.getHeight();
      n = n || i.get("position");
      var h = s.getSize(), d = i.get("align"), f = i.get("verticalAlign"), v = l && l.getBoundingRect().clone();
      if (l && v.applyTransform(l.transform), mt(n) && (n = n([r, a], o, s.el, v, {
        viewSize: [u, c],
        contentSize: h.slice()
      })), K(n))
        r = Ye(n[0], u), a = Ye(n[1], c);
      else if (tt(n)) {
        var m = n;
        m.width = h[0], m.height = h[1];
        var p = np(m, {
          width: u,
          height: c
        });
        r = p.x, a = p.y, d = null, f = null;
      } else if (et(n) && l) {
        var g = Y3(n, v, h, i.get("borderWidth"));
        r = g[0], a = g[1];
      } else {
        var g = V3(r, a, s, u, c, d ? null : 20, f ? null : 20);
        r = g[0], a = g[1];
      }
      if (d && (r -= L_(d) ? h[0] / 2 : d === "right" ? h[0] : 0), f && (a -= L_(f) ? h[1] / 2 : f === "bottom" ? h[1] : 0), tS(i)) {
        var g = H3(r, a, s, u, c);
        r = g[0], a = g[1];
      }
      s.moveTo(r, a);
    }, t.prototype._updateContentNotChangedOnAxis = function(i, n) {
      var r = this._lastDataByCoordSys, a = this._cbParamsList, s = !!r && r.length === i.length;
      return s && E(r, function(o, l) {
        var u = o.dataByAxis || [], c = i[l] || {}, h = c.dataByAxis || [];
        s = s && u.length === h.length, s && E(u, function(d, f) {
          var v = h[f] || {}, m = d.seriesDataIndices || [], p = v.seriesDataIndices || [];
          s = s && d.value === v.value && d.axisType === v.axisType && d.axisId === v.axisId && m.length === p.length, s && E(m, function(g, y) {
            var _ = p[y];
            s = s && g.seriesIndex === _.seriesIndex && g.dataIndex === _.dataIndex;
          }), a && E(d.seriesDataIndices, function(g) {
            var y = g.seriesIndex, _ = n[y], b = a[y];
            _ && b && b.data !== _.data && (s = !1);
          });
        });
      }), this._lastDataByCoordSys = i, this._cbParamsList = n, !!s;
    }, t.prototype._hide = function(i) {
      this._lastDataByCoordSys = null, i({
        type: "hideTip",
        from: this.uid
      });
    }, t.prototype.dispose = function(i, n) {
      ot.node || !n.getDom() || (Lf(this, "_updatePosition"), this._tooltipContent.dispose(), Wf("itemTooltip", n));
    }, t.type = "tooltip", t;
  })(En)
);
function Us(e, t, i) {
  var n = t.ecModel, r;
  i ? (r = new jt(i, n, n), r = new jt(t.option, r, n)) : r = t;
  for (var a = e.length - 1; a >= 0; a--) {
    var s = e[a];
    s && (s instanceof jt && (s = s.get("tooltip", !0)), et(s) && (s = {
      formatter: s
    }), s && (r = new jt(s, r, n)));
  }
  return r;
}
function P_(e, t) {
  return e.dispatchAction || Dt(t.dispatchAction, t);
}
function V3(e, t, i, n, r, a, s) {
  var o = i.getSize(), l = o[0], u = o[1];
  return a != null && (e + l + a + 2 > n ? e -= l + a : e += a), s != null && (t + u + s > r ? t -= u + s : t += s), [e, t];
}
function H3(e, t, i, n, r) {
  var a = i.getSize(), s = a[0], o = a[1];
  return e = Math.min(e + s, n) - s, t = Math.min(t + o, r) - o, e = Math.max(e, 0), t = Math.max(t, 0), [e, t];
}
function Y3(e, t, i, n) {
  var r = i[0], a = i[1], s = Math.ceil(Math.SQRT2 * n) + 8, o = 0, l = 0, u = t.width, c = t.height;
  switch (e) {
    case "inside":
      o = t.x + u / 2 - r / 2, l = t.y + c / 2 - a / 2;
      break;
    case "top":
      o = t.x + u / 2 - r / 2, l = t.y - a - s;
      break;
    case "bottom":
      o = t.x + u / 2 - r / 2, l = t.y + c + s;
      break;
    case "left":
      o = t.x - r - s, l = t.y + c / 2 - a / 2;
      break;
    case "right":
      o = t.x + u + s, l = t.y + c / 2 - a / 2;
  }
  return [o, l];
}
function L_(e) {
  return e === "center" || e === "middle";
}
function W3(e, t, i) {
  var n = Av(e).queryOptionMap, r = n.keys()[0];
  if (!(!r || r === "series")) {
    var a = Qo(t, r, n.get(r), {
      useDefault: !1,
      enableAll: !1,
      enableNone: !1
    }), s = a.models[0];
    if (s) {
      var o = i.getViewOfComponentModel(s), l;
      if (o.group.traverse(function(u) {
        var c = Vt(u).tooltipConfig;
        if (c && c.name === e.name)
          return l = u, !0;
      }), l)
        return {
          componentMainType: r,
          componentIndex: s.componentIndex,
          el: l
        };
    }
  }
}
function U3(e) {
  pp(v3), e.registerComponentModel(T3), e.registerComponentView(z3), e.registerAction({
    type: "showTip",
    event: "showTip",
    update: "tooltip:manuallyShowTip"
  }, ke), e.registerAction({
    type: "hideTip",
    event: "hideTip",
    update: "tooltip:manuallyHideTip"
  }, ke);
}
var Yo = E, G3 = tt, uc = -1, xp = (
  /** @class */
  (function() {
    function e(t) {
      var i = t.mappingMethod, n = t.type, r = this.option = pt(t);
      this.type = n, this.mappingMethod = i, this._normalizeData = q3[i];
      var a = e.visualHandlers[n];
      this.applyVisual = a.applyVisual, this.getColorMapper = a.getColorMapper, this._normalizedToVisual = a._normalizedToVisual[i], i === "piecewise" ? (Cd(r), X3(r)) : i === "category" ? r.categories ? j3(r) : Cd(r, !0) : (nt(i !== "linear" || r.dataExtent), Cd(r));
    }
    return e.prototype.mapValueToVisual = function(t) {
      var i = this._normalizeData(t);
      return this._normalizedToVisual(i, t);
    }, e.prototype.getNormalizer = function() {
      return Dt(this._normalizeData, this);
    }, e.listVisualTypes = function() {
      return qt(e.visualHandlers);
    }, e.isValidType = function(t) {
      return e.visualHandlers.hasOwnProperty(t);
    }, e.eachVisual = function(t, i, n) {
      tt(t) ? E(t, i, n) : i.call(n, t);
    }, e.mapVisual = function(t, i, n) {
      var r, a = K(t) ? [] : tt(t) ? {} : (r = !0, null);
      return e.eachVisual(t, function(s, o) {
        var l = i.call(n, s, o);
        r ? a = l : a[o] = l;
      }), a;
    }, e.retrieveVisuals = function(t) {
      var i = {}, n;
      return t && Yo(e.visualHandlers, function(r, a) {
        t.hasOwnProperty(a) && (i[a] = t[a], n = !0);
      }), n ? i : null;
    }, e.prepareVisualTypes = function(t) {
      if (K(t))
        t = t.slice();
      else if (G3(t)) {
        var i = [];
        Yo(t, function(n, r) {
          i.push(r);
        }), t = i;
      } else
        return [];
      return t.sort(function(n, r) {
        return r === "color" && n !== "color" && n.indexOf("color") === 0 ? 1 : -1;
      }), t;
    }, e.dependsOn = function(t, i) {
      return i === "color" ? !!(t && t.indexOf(i) === 0) : t === i;
    }, e.findPieceIndex = function(t, i, n) {
      for (var r, a = 1 / 0, s = 0, o = i.length; s < o; s++) {
        var l = i[s].value;
        if (l != null) {
          if (l === t || et(l) && l === t + "")
            return s;
          n && d(l, s);
        }
      }
      for (var s = 0, o = i.length; s < o; s++) {
        var u = i[s], c = u.interval, h = u.close;
        if (c) {
          if (c[0] === -1 / 0) {
            if (Ql(h[1], t, c[1]))
              return s;
          } else if (c[1] === 1 / 0) {
            if (Ql(h[0], c[0], t))
              return s;
          } else if (Ql(h[0], c[0], t) && Ql(h[1], t, c[1]))
            return s;
          n && d(c[0], s), n && d(c[1], s);
        }
      }
      if (n)
        return t === 1 / 0 ? i.length - 1 : t === -1 / 0 ? 0 : r;
      function d(f, v) {
        var m = Math.abs(f - t);
        m < a && (a = m, r = v);
      }
    }, e.visualHandlers = {
      color: {
        applyVisual: Gs("color"),
        getColorMapper: function() {
          var t = this.option;
          return Dt(t.mappingMethod === "category" ? function(i, n) {
            return !n && (i = this._normalizeData(i)), oo.call(this, i);
          } : function(i, n, r) {
            var a = !!r;
            return !n && (i = this._normalizeData(i)), r = Mh(i, t.parsedVisual, r), a ? r : ta(r, "rgba");
          }, this);
        },
        _normalizedToVisual: {
          linear: function(t) {
            return ta(Mh(t, this.option.parsedVisual), "rgba");
          },
          category: oo,
          piecewise: function(t, i) {
            var n = Gf.call(this, i);
            return n == null && (n = ta(Mh(t, this.option.parsedVisual), "rgba")), n;
          },
          fixed: $r
        }
      },
      colorHue: Kl(function(t, i) {
        return Qa(t, i);
      }),
      colorSaturation: Kl(function(t, i) {
        return Qa(t, null, i);
      }),
      colorLightness: Kl(function(t, i) {
        return Qa(t, null, null, i);
      }),
      colorAlpha: Kl(function(t, i) {
        return XP(t, i);
      }),
      decal: {
        applyVisual: Gs("decal"),
        _normalizedToVisual: {
          linear: null,
          category: oo,
          piecewise: null,
          fixed: null
        }
      },
      opacity: {
        applyVisual: Gs("opacity"),
        _normalizedToVisual: Uf([0, 1])
      },
      liftZ: {
        applyVisual: Gs("liftZ"),
        _normalizedToVisual: {
          linear: $r,
          category: $r,
          piecewise: $r,
          fixed: $r
        }
      },
      symbol: {
        applyVisual: function(t, i, n) {
          var r = this.mapValueToVisual(t);
          n("symbol", r);
        },
        _normalizedToVisual: {
          linear: O_,
          category: oo,
          piecewise: function(t, i) {
            var n = Gf.call(this, i);
            return n == null && (n = O_.call(this, t)), n;
          },
          fixed: $r
        }
      },
      symbolSize: {
        applyVisual: Gs("symbolSize"),
        _normalizedToVisual: Uf([0, 1])
      }
    }, e;
  })()
);
function X3(e) {
  var t = e.pieceList;
  e.hasSpecialVisual = !1, E(t, function(i, n) {
    i.originIndex = n, i.visual != null && (e.hasSpecialVisual = !0);
  });
}
function j3(e) {
  var t = e.categories, i = e.categoryMap = {}, n = e.visual;
  if (Yo(t, function(s, o) {
    i[s] = o;
  }), !K(n)) {
    var r = [];
    tt(n) ? Yo(n, function(s, o) {
      var l = i[o];
      r[l ?? uc] = s;
    }) : r[uc] = n, n = rS(e, r);
  }
  for (var a = t.length - 1; a >= 0; a--)
    n[a] == null && (delete i[t[a]], t.pop());
}
function Cd(e, t) {
  var i = e.visual, n = [];
  tt(i) ? Yo(i, function(a) {
    n.push(a);
  }) : i != null && n.push(i);
  var r = {
    color: 1,
    symbol: 1
  };
  !t && n.length === 1 && !r.hasOwnProperty(e.type) && (n[1] = n[0]), rS(e, n);
}
function Kl(e) {
  return {
    applyVisual: function(t, i, n) {
      var r = this.mapValueToVisual(t);
      n("color", e(i("color"), r));
    },
    _normalizedToVisual: Uf([0, 1])
  };
}
function O_(e) {
  var t = this.option.visual;
  return t[Math.round(Io(e, [0, 1], [0, t.length - 1]))] || {};
}
function Gs(e) {
  return function(t, i, n) {
    n(e, this.mapValueToVisual(t));
  };
}
function oo(e) {
  var t = this.option.visual;
  return t[this.option.loop && e !== uc ? e % t.length : e];
}
function $r() {
  return this.option.visual[0];
}
function Uf(e) {
  return {
    linear: function(t) {
      return Io(t, e, this.option.visual);
    },
    category: oo,
    piecewise: function(t, i) {
      var n = Gf.call(this, i);
      return n == null && (n = Io(t, e, this.option.visual)), n;
    },
    fixed: $r
  };
}
function Gf(e) {
  var t = this.option, i = t.pieceList;
  if (t.hasSpecialVisual) {
    var n = xp.findPieceIndex(e, i), r = i[n];
    if (r && r.visual)
      return r.visual[this.type];
  }
}
function rS(e, t) {
  return e.visual = t, e.type === "color" && (e.parsedVisual = _t(t, function(i) {
    var n = Sn(i);
    return !n && process.env.NODE_ENV !== "production" && hi("'" + i + "' is an illegal color, fallback to '#000000'", !0), n || [0, 0, 0, 1];
  })), t;
}
var q3 = {
  linear: function(e) {
    return Io(e, this.option.dataExtent, [0, 1]);
  },
  piecewise: function(e) {
    var t = this.option.pieceList, i = xp.findPieceIndex(e, t, !0);
    if (i != null)
      return Io(i, [0, t.length - 1], [0, 1]);
  },
  category: function(e) {
    var t = this.option.categories ? this.option.categoryMap[e] : e;
    return t ?? uc;
  },
  fixed: ke
};
function Ql(e, t, i) {
  return e ? t <= i : t < i;
}
var Z3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i.layoutMode = {
        type: "box",
        ignoreSize: !0
      }, i;
    }
    return t.type = "title", t.defaultOption = {
      // zlevel: 0,
      z: 6,
      show: !0,
      text: "",
      target: "blank",
      subtext: "",
      subtarget: "blank",
      left: "center",
      top: St.size.m,
      backgroundColor: St.color.transparent,
      borderColor: St.color.primary,
      borderWidth: 0,
      padding: 5,
      itemGap: 10,
      textStyle: {
        fontSize: 18,
        fontWeight: "bold",
        color: St.color.primary
      },
      subtextStyle: {
        fontSize: 12,
        color: St.color.quaternary
      }
    }, t;
  })(Pt)
), K3 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.render = function(i, n, r) {
      if (this.group.removeAll(), !!i.get("show")) {
        var a = this.group, s = i.getModel("textStyle"), o = i.getModel("subtextStyle"), l = i.get("textAlign"), u = rt(i.get("textBaseline"), i.get("textVerticalAlign")), c = new _i({
          style: la(s, {
            text: i.get("text"),
            fill: s.getTextColor()
          }, {
            disableBox: !0
          }),
          z2: 10
        }), h = c.getBoundingRect(), d = i.get("subtext"), f = new _i({
          style: la(o, {
            text: d,
            fill: o.getTextColor(),
            y: h.height + i.get("itemGap"),
            verticalAlign: "top"
          }, {
            disableBox: !0
          }),
          z2: 10
        }), v = i.get("link"), m = i.get("sublink"), p = i.get("triggerEvent", !0);
        c.silent = !v && !p, f.silent = !m && !p, v && c.on("click", function() {
          K0(v, "_" + i.get("target"));
        }), m && f.on("click", function() {
          K0(m, "_" + i.get("subtarget"));
        }), Vt(c).eventData = Vt(f).eventData = p ? {
          componentType: "title",
          componentIndex: i.componentIndex
        } : null, a.add(c), d && a.add(f);
        var g = a.getBoundingRect(), y = i.getBoxLayoutParams();
        y.width = g.width, y.height = g.height;
        var _ = Ax(i, r), b = np(y, _.refContainer, i.get("padding"));
        l || (l = i.get("left") || i.get("right"), l === "middle" && (l = "center"), l === "right" ? b.x += b.width : l === "center" && (b.x += b.width / 2)), u || (u = i.get("top") || i.get("bottom"), u === "center" && (u = "middle"), u === "bottom" ? b.y += b.height : u === "middle" && (b.y += b.height / 2), u = u || "top"), a.x = b.x, a.y = b.y, a.markRedraw();
        var w = {
          align: l,
          verticalAlign: u
        };
        c.setStyle(w), f.setStyle(w), g = a.getBoundingRect();
        var S = b.margin, M = i.getItemStyle(["color", "opacity"]);
        M.fill = i.get("backgroundColor");
        var k = new De({
          shape: {
            x: g.x - S[3],
            y: g.y - S[0],
            width: g.width + S[1] + S[3],
            height: g.height + S[0] + S[2],
            r: i.get("borderRadius")
          },
          style: M,
          subPixelOptimize: !0,
          silent: !0
        });
        a.add(k);
      }
    }, t.type = "title", t;
  })(En)
);
function Q3(e) {
  e.registerComponentModel(Z3), e.registerComponentView(K3);
}
var mi = Gt();
function J3(e) {
  var t = e.mainData, i = e.datas;
  i || (i = {
    main: t
  }, e.datasAttr = {
    main: "data"
  }), e.datas = e.mainData = null, aS(t, i, e), E(i, function(n) {
    E(t.TRANSFERABLE_METHODS, function(r) {
      n.wrapMethod(r, Oe(t4, e));
    });
  }), t.wrapMethod("cloneShallow", Oe(i4, e)), E(t.CHANGABLE_METHODS, function(n) {
    t.wrapMethod(n, Oe(e4, e));
  }), nt(i[t.dataType] === t);
}
function t4(e, t) {
  if (a4(this)) {
    var i = Y({}, mi(this).datas);
    i[this.dataType] = t, aS(t, i, e);
  } else
    wp(t, this.dataType, mi(this).mainData, e);
  return t;
}
function e4(e, t) {
  return e.struct && e.struct.update(), t;
}
function i4(e, t) {
  return E(mi(t).datas, function(i, n) {
    i !== t && wp(i.cloneShallow(), n, t, e);
  }), t;
}
function n4(e) {
  var t = mi(this).mainData;
  return e == null || t == null ? t : mi(t).datas[e];
}
function r4() {
  var e = mi(this).mainData;
  return e == null ? [{
    data: e
  }] : _t(qt(mi(e).datas), function(t) {
    return {
      type: t,
      data: mi(e).datas[t]
    };
  });
}
function a4(e) {
  return mi(e).mainData === e;
}
function aS(e, t, i) {
  mi(e).datas = {}, E(t, function(n, r) {
    wp(n, r, e, i);
  });
}
function wp(e, t, i, n) {
  mi(i).datas[t] = e, mi(e).mainData = i, e.dataType = t, n.struct && (e[n.structAttr] = n.struct, n.struct[n.datasAttr[t]] = e), e.getLinkedData = n4, e.getLinkedDataAll = r4;
}
function Fa(e) {
  return "_EC_" + e;
}
var s4 = (
  /** @class */
  (function() {
    function e(t) {
      this.type = "graph", this.nodes = [], this.edges = [], this._nodesMap = {}, this._edgesMap = {}, this._directed = t || !1;
    }
    return e.prototype.isDirected = function() {
      return this._directed;
    }, e.prototype.addNode = function(t, i) {
      t = t == null ? "" + i : "" + t;
      var n = this._nodesMap;
      if (n[Fa(t)]) {
        process.env.NODE_ENV !== "production" && console.error("Graph nodes have duplicate name or id");
        return;
      }
      var r = new zr(t, i);
      return r.hostGraph = this, this.nodes.push(r), n[Fa(t)] = r, r;
    }, e.prototype.getNodeByIndex = function(t) {
      var i = this.data.getRawIndex(t);
      return this.nodes[i];
    }, e.prototype.getNodeById = function(t) {
      return this._nodesMap[Fa(t)];
    }, e.prototype.addEdge = function(t, i, n) {
      var r = this._nodesMap, a = this._edgesMap;
      if (Zt(t) && (t = this.nodes[t]), Zt(i) && (i = this.nodes[i]), t instanceof zr || (t = r[Fa(t)]), i instanceof zr || (i = r[Fa(i)]), !(!t || !i)) {
        var s = t.id + "-" + i.id, o = new sS(t, i, n);
        return o.hostGraph = this, this._directed && (t.outEdges.push(o), i.inEdges.push(o)), t.edges.push(o), t !== i && i.edges.push(o), this.edges.push(o), a[s] = o, o;
      }
    }, e.prototype.getEdgeByIndex = function(t) {
      var i = this.edgeData.getRawIndex(t);
      return this.edges[i];
    }, e.prototype.getEdge = function(t, i) {
      t instanceof zr && (t = t.id), i instanceof zr && (i = i.id);
      var n = this._edgesMap;
      return this._directed ? n[t + "-" + i] : n[t + "-" + i] || n[i + "-" + t];
    }, e.prototype.eachNode = function(t, i) {
      for (var n = this.nodes, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.eachEdge = function(t, i) {
      for (var n = this.edges, r = n.length, a = 0; a < r; a++)
        n[a].dataIndex >= 0 && n[a].node1.dataIndex >= 0 && n[a].node2.dataIndex >= 0 && t.call(i, n[a], a);
    }, e.prototype.breadthFirstTraverse = function(t, i, n, r) {
      if (i instanceof zr || (i = this._nodesMap[Fa(i)]), !!i) {
        for (var a = n === "out" ? "outEdges" : n === "in" ? "inEdges" : "edges", s = 0; s < this.nodes.length; s++)
          this.nodes[s].__visited = !1;
        if (!t.call(r, i, null))
          for (var o = [i]; o.length; )
            for (var l = o.shift(), u = l[a], s = 0; s < u.length; s++) {
              var c = u[s], h = c.node1 === l ? c.node2 : c.node1;
              if (!h.__visited) {
                if (t.call(r, h, l))
                  return;
                o.push(h), h.__visited = !0;
              }
            }
      }
    }, e.prototype.update = function() {
      for (var t = this.data, i = this.edgeData, n = this.nodes, r = this.edges, a = 0, s = n.length; a < s; a++)
        n[a].dataIndex = -1;
      for (var a = 0, s = t.count(); a < s; a++)
        n[t.getRawIndex(a)].dataIndex = a;
      i.filterSelf(function(o) {
        var l = r[i.getRawIndex(o)];
        return l.node1.dataIndex >= 0 && l.node2.dataIndex >= 0;
      });
      for (var a = 0, s = r.length; a < s; a++)
        r[a].dataIndex = -1;
      for (var a = 0, s = i.count(); a < s; a++)
        r[i.getRawIndex(a)].dataIndex = a;
    }, e.prototype.clone = function() {
      for (var t = new e(this._directed), i = this.nodes, n = this.edges, r = 0; r < i.length; r++)
        t.addNode(i[r].id, i[r].dataIndex);
      for (var r = 0; r < n.length; r++) {
        var a = n[r];
        t.addEdge(a.node1.id, a.node2.id, a.dataIndex);
      }
      return t;
    }, e;
  })()
), zr = (
  /** @class */
  (function() {
    function e(t, i) {
      this.inEdges = [], this.outEdges = [], this.edges = [], this.dataIndex = -1, this.id = t ?? "", this.dataIndex = i ?? -1;
    }
    return e.prototype.degree = function() {
      return this.edges.length;
    }, e.prototype.inDegree = function() {
      return this.inEdges.length;
    }, e.prototype.outDegree = function() {
      return this.outEdges.length;
    }, e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.data.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      for (var t = {
        edge: [],
        node: []
      }, i = 0; i < this.edges.length; i++) {
        var n = this.edges[i];
        n.dataIndex < 0 || (t.edge.push(n.dataIndex), t.node.push(n.node1.dataIndex, n.node2.dataIndex));
      }
      return t;
    }, e.prototype.getTrajectoryDataIndices = function() {
      for (var t = ht(), i = ht(), n = 0, r = this.edges.length; n < r; n++) {
        var a = this.edges[n];
        if (!(a.dataIndex < 0)) {
          t.set(a.dataIndex, !0);
          for (var s = [a.node1], o = [a.node2], l = 0; l < s.length; ) {
            var u = s[l];
            l++, i.set(u.dataIndex, !0);
            for (var c = u.inEdges, h = 0, d = c.length, f = void 0, v = void 0; h < d; h++)
              f = c[h], v = f.dataIndex, v >= 0 && !t.hasKey(v) && (t.set(v, !0), s.push(f.node1));
          }
          for (l = 0; l < o.length; ) {
            var m = o[l];
            l++, i.set(m.dataIndex, !0);
            for (var p = m.outEdges, h = 0, g = p.length, y = void 0, _ = void 0; h < g; h++)
              y = p[h], _ = y.dataIndex, _ >= 0 && !t.hasKey(_) && (t.set(_, !0), o.push(y.node2));
          }
        }
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
), sS = (
  /** @class */
  (function() {
    function e(t, i, n) {
      this.dataIndex = -1, this.node1 = t, this.node2 = i, this.dataIndex = n ?? -1;
    }
    return e.prototype.getModel = function(t) {
      if (!(this.dataIndex < 0)) {
        var i = this.hostGraph, n = i.edgeData.getItemModel(this.dataIndex);
        return n.getModel(t);
      }
    }, e.prototype.getAdjacentDataIndices = function() {
      return {
        edge: [this.dataIndex],
        node: [this.node1.dataIndex, this.node2.dataIndex]
      };
    }, e.prototype.getTrajectoryDataIndices = function() {
      var t = ht(), i = ht();
      t.set(this.dataIndex, !0);
      for (var n = [this.node1], r = [this.node2], a = 0; a < n.length; ) {
        var s = n[a];
        a++, i.set(s.dataIndex, !0);
        for (var o = s.inEdges, l = 0, u = o.length, c = void 0, h = void 0; l < u; l++)
          c = s.inEdges[l], h = c.dataIndex, h >= 0 && !t.hasKey(h) && (t.set(h, !0), n.push(c.node1));
      }
      for (a = 0; a < r.length; ) {
        var d = r[a];
        a++, i.set(d.dataIndex, !0);
        for (var f = d.outEdges, l = 0, u = f.length, v = void 0, m = void 0; l < u; l++)
          v = d.outEdges[l], m = v.dataIndex, m >= 0 && !t.hasKey(m) && (t.set(m, !0), r.push(v.node2));
      }
      return {
        edge: t.keys(),
        node: i.keys()
      };
    }, e;
  })()
);
function oS(e, t) {
  return {
    /**
     * @param Default 'value'. can be 'a', 'b', 'c', 'd', 'e'.
     */
    getValue: function(i) {
      var n = this[e][t];
      return n.getStore().get(n.getDimensionIndex(i || "value"), this.dataIndex);
    },
    // TODO: TYPE stricter type.
    setVisual: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemVisual(this.dataIndex, i, n);
    },
    getVisual: function(i) {
      return this[e][t].getItemVisual(this.dataIndex, i);
    },
    setLayout: function(i, n) {
      this.dataIndex >= 0 && this[e][t].setItemLayout(this.dataIndex, i, n);
    },
    getLayout: function() {
      return this[e][t].getItemLayout(this.dataIndex);
    },
    getGraphicEl: function() {
      return this[e][t].getItemGraphicEl(this.dataIndex);
    },
    getRawIndex: function() {
      return this[e][t].getRawIndex(this.dataIndex);
    }
  };
}
Pi(zr, oS("hostGraph", "data"));
Pi(sS, oS("hostGraph", "edgeData"));
function o4(e, t, i, n, r) {
  for (var a = new s4(n), s = 0; s < e.length; s++)
    a.addNode(rr(
      // Id, name, dataIndex
      e[s].id,
      e[s].name,
      s
    ), s);
  for (var o = [], l = [], u = 0, s = 0; s < t.length; s++) {
    var c = t[s], h = c.source, d = c.target;
    a.addEdge(h, d, u) && (l.push(c), o.push(rr(Ti(c.id, null), h + " > " + d)), u++);
  }
  var f = i.get("coordinateSystem"), v;
  if (f === "cartesian2d" || f === "polar" || f === "matrix")
    v = rB(e, i);
  else {
    var m = Bc.get(f), p = m ? m.dimensions || [] : [];
    Ht(p, "value") < 0 && p.concat(["value"]);
    var g = zw(e, {
      coordDimensions: p,
      encodeDefine: i.getEncode()
    }).dimensions;
    v = new Vf(g, i), v.initData(e);
  }
  var y = new Vf(["value"], i);
  return y.initData(l, o), r && r(v, y), J3({
    mainData: v,
    struct: a,
    structAttr: "graph",
    datas: {
      node: v,
      edge: y
    },
    datasAttr: {
      node: "data",
      edge: "edgeData"
    }
  }), a.update(), a;
}
var l4 = (
  /** @class */
  /* @__PURE__ */ (function() {
    function e() {
      this.x1 = 0, this.y1 = 0, this.x2 = 0, this.y2 = 0, this.cpx1 = 0, this.cpy1 = 0, this.cpx2 = 0, this.cpy2 = 0, this.extent = 0;
    }
    return e;
  })()
), u4 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t(i) {
      return e.call(this, i) || this;
    }
    return t.prototype.getDefaultShape = function() {
      return new l4();
    }, t.prototype.buildPath = function(i, n) {
      var r = n.extent;
      i.moveTo(n.x1, n.y1), i.bezierCurveTo(n.cpx1, n.cpy1, n.cpx2, n.cpy2, n.x2, n.y2), n.orient === "vertical" ? (i.lineTo(n.x2 + r, n.y2), i.bezierCurveTo(n.cpx2 + r, n.cpy2, n.cpx1 + r, n.cpy1, n.x1 + r, n.y1)) : (i.lineTo(n.x2, n.y2 + r), i.bezierCurveTo(n.cpx2, n.cpy2 + r, n.cpx1, n.cpy1 + r, n.x1, n.y1 + r)), i.closePath();
    }, t.prototype.highlight = function() {
      Yu(this);
    }, t.prototype.downplay = function() {
      Wu(this);
    }, t;
  })($t)
), c4 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i._mainGroup = new Ci(), i._focusAdjacencyDisabled = !1, i;
    }
    return t.prototype.init = function(i, n) {
      this._controller = new S3(n.getZr()), this._controllerHost = {
        target: this.group
      }, this.group.add(this._mainGroup);
    }, t.prototype.render = function(i, n, r) {
      var a = this, s = i.getGraph(), o = this._mainGroup, l = i.layoutInfo, u = l.width, c = l.height, h = i.getData(), d = i.getData("edge"), f = i.get("orient");
      this._model = i, o.removeAll(), o.x = l.x, o.y = l.y, this._updateViewCoordSys(i, r), m3(i, r, o, this._controller, this._controllerHost), s.eachEdge(function(v) {
        var m = new u4(), p = Vt(m);
        p.dataIndex = v.dataIndex, p.seriesIndex = i.seriesIndex, p.dataType = "edge";
        var g = v.getModel(), y = g.getModel("lineStyle"), _ = y.get("curveness"), b = v.node1.getLayout(), w = v.node1.getModel(), S = w.get("localX"), M = w.get("localY"), k = v.node2.getLayout(), T = v.node2.getModel(), D = T.get("localX"), C = T.get("localY"), P = v.getLayout(), L, O, N, B, G, V, F, $;
        m.shape.extent = Math.max(1, P.dy), m.shape.orient = f, f === "vertical" ? (L = (S != null ? S * u : b.x) + P.sy, O = (M != null ? M * c : b.y) + b.dy, N = (D != null ? D * u : k.x) + P.ty, B = C != null ? C * c : k.y, G = L, V = O * (1 - _) + B * _, F = N, $ = O * _ + B * (1 - _)) : (L = (S != null ? S * u : b.x) + b.dx, O = (M != null ? M * c : b.y) + P.sy, N = D != null ? D * u : k.x, B = (C != null ? C * c : k.y) + P.ty, G = L * (1 - _) + N * _, V = O, F = L * _ + N * (1 - _), $ = B), m.setShape({
          x1: L,
          y1: O,
          x2: N,
          y2: B,
          cpx1: G,
          cpy1: V,
          cpx2: F,
          cpy2: $
        }), m.useStyle(y.getItemStyle()), I_(m.style, f, v);
        var Z = "" + g.get("value"), j = W0(g, "edgeLabel");
        Y0(m, j, {
          labelFetcher: {
            getFormattedLabel: function(wt, Tt, me, Ae, At, Ft) {
              return i.getFormattedLabel(
                wt,
                Tt,
                "edge",
                Ae,
                // ensure edgeLabel formatter is provided
                // to prevent the inheritance from `label.formatter` of the series
                Qr(At, j.normal && j.normal.get("formatter"), Z),
                Ft
              );
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: Z
        }), m.setTextConfig({
          position: "inside"
        });
        var it = g.getModel("emphasis");
        P0(m, g, "lineStyle", function(wt) {
          var Tt = wt.getItemStyle();
          return I_(Tt, f, v), Tt;
        }), o.add(m), d.setItemGraphicEl(v.dataIndex, m);
        var st = it.get("focus");
        E0(m, st === "adjacency" ? v.getAdjacentDataIndices() : st === "trajectory" ? v.getTrajectoryDataIndices() : st, it.get("blurScope"), it.get("disabled"));
      }), s.eachNode(function(v) {
        var m = v.getLayout(), p = v.getModel(), g = p.get("localX"), y = p.get("localY"), _ = p.getModel("emphasis"), b = p.get(["itemStyle", "borderRadius"]) || 0, w = new De({
          shape: {
            x: g != null ? g * u : m.x,
            y: y != null ? y * c : m.y,
            width: m.dx,
            height: m.dy,
            r: b
          },
          style: p.getModel("itemStyle").getItemStyle(),
          z2: 10
        });
        Y0(w, W0(p), {
          labelFetcher: {
            getFormattedLabel: function(M, k) {
              return i.getFormattedLabel(M, k, "node");
            }
          },
          labelDataIndex: v.dataIndex,
          defaultText: v.id
        }), w.disableLabelAnimation = !0, w.setStyle("fill", v.getVisual("color")), w.setStyle("decal", v.getVisual("style").decal), P0(w, p), o.add(w), h.setItemGraphicEl(v.dataIndex, w), Vt(w).dataType = "node";
        var S = _.get("focus");
        E0(w, S === "adjacency" ? v.getAdjacentDataIndices() : S === "trajectory" ? v.getTrajectoryDataIndices() : S, _.get("blurScope"), _.get("disabled"));
      }), h.eachItemGraphicEl(function(v, m) {
        var p = h.getItemModel(m);
        p.get("draggable") && (v.drift = function(g, y) {
          a._focusAdjacencyDisabled = !0, this.shape.x += g, this.shape.y += y, this.dirty(), r.dispatchAction({
            type: "dragNode",
            seriesId: i.id,
            dataIndex: h.getRawIndex(m),
            localX: this.shape.x / u,
            localY: this.shape.y / c
          });
        }, v.ondragend = function() {
          a._focusAdjacencyDisabled = !1;
        }, v.draggable = !0, v.cursor = "move");
      }), !this._data && i.isAnimationEnabled() && o.setClipPath(h4(o.getBoundingRect(), i, function() {
        o.removeClipPath();
      })), this._data = i.getData();
    }, t.prototype.dispose = function() {
      this._controller && this._controller.dispose(), this._controllerHost = null;
    }, t.prototype._updateViewCoordSys = function(i, n) {
      var r = i.layoutInfo, a = r.width, s = r.height, o = i.coordinateSystem = new _3(null, {
        api: n,
        ecModel: i.ecModel
      });
      o.zoomLimit = i.get("scaleLimit"), o.setBoundingRect(0, 0, a, s), o.setCenter(i.get("center")), o.setZoom(i.get("zoom")), this._controllerHost.target.attr({
        x: o.x,
        y: o.y,
        scaleX: o.scaleX,
        scaleY: o.scaleY
      });
    }, t.type = "sankey", t;
  })(Jn)
);
function I_(e, t, i) {
  switch (e.fill) {
    case "source":
      e.fill = i.node1.getVisual("color"), e.decal = i.node1.getVisual("style").decal;
      break;
    case "target":
      e.fill = i.node2.getVisual("color"), e.decal = i.node2.getVisual("style").decal;
      break;
    case "gradient":
      var n = i.node1.getVisual("color"), r = i.node2.getVisual("color");
      et(n) && et(r) && (e.fill = new ux(0, 0, +(t === "horizontal"), +(t === "vertical"), [{
        color: n,
        offset: 0
      }, {
        color: r,
        offset: 1
      }]));
  }
}
function h4(e, t, i) {
  var n = new De({
    shape: {
      x: e.x - 10,
      y: e.y - 10,
      width: 0,
      height: e.height + 20
    }
  });
  return hx(n, {
    shape: {
      width: e.width + 20
    }
  }, t, i), n;
}
var d4 = (
  /** @class */
  (function(e) {
    oe(t, e);
    function t() {
      var i = e !== null && e.apply(this, arguments) || this;
      return i.type = t.type, i;
    }
    return t.prototype.getInitialData = function(i, n) {
      var r = i.edges || i.links || [], a = i.data || i.nodes || [], s = i.levels || [];
      this.levelModels = [];
      for (var o = this.levelModels, l = 0; l < s.length; l++)
        if (s[l].depth != null && s[l].depth >= 0)
          o[s[l].depth] = new jt(s[l], this, n);
        else if (process.env.NODE_ENV !== "production")
          throw new Error("levels[i].depth is mandatory and should be natural number");
      var u = o4(a, r, this, !0, c);
      return u.data;
      function c(h, d) {
        h.wrapMethod("getItemModel", function(f, v) {
          var m = f.parentModel, p = m.getData().getItemLayout(v);
          if (p) {
            var g = p.depth, y = m.levelModels[g];
            y && (f.parentModel = y);
          }
          return f;
        }), d.wrapMethod("getItemModel", function(f, v) {
          var m = f.parentModel, p = m.getGraph().getEdgeByIndex(v), g = p.node1.getLayout();
          if (g) {
            var y = g.depth, _ = m.levelModels[y];
            _ && (f.parentModel = _);
          }
          return f;
        });
      }
    }, t.prototype.setNodePosition = function(i, n) {
      var r = this.option.data || this.option.nodes, a = r[i];
      a.localX = n[0], a.localY = n[1];
    }, t.prototype.setCenter = function(i) {
      this.option.center = i;
    }, t.prototype.setZoom = function(i) {
      this.option.zoom = i;
    }, t.prototype.getGraph = function() {
      return this.getData().graph;
    }, t.prototype.getEdgeData = function() {
      return this.getGraph().edgeData;
    }, t.prototype.formatTooltip = function(i, n, r) {
      function a(f) {
        return isNaN(f) || f == null;
      }
      if (r === "edge") {
        var s = this.getDataParams(i, r), o = s.data, l = s.value, u = o.source + " -- " + o.target;
        return ua("nameValue", {
          name: u,
          value: l,
          noValue: a(l)
        });
      } else {
        var c = this.getGraph().getNodeByIndex(i), h = c.getLayout().value, d = this.getDataParams(i, r).data.name;
        return ua("nameValue", {
          name: d != null ? d + "" : null,
          value: h,
          noValue: a(h)
        });
      }
    }, t.prototype.optionUpdated = function() {
    }, t.prototype.getDataParams = function(i, n) {
      var r = e.prototype.getDataParams.call(this, i, n);
      if (r.value == null && n === "node") {
        var a = this.getGraph().getNodeByIndex(i), s = a.getLayout().value;
        r.value = s;
      }
      return r;
    }, t.type = "series.sankey", t.layoutMode = "box", t.defaultOption = {
      // zlevel: 0,
      z: 2,
      // `coordinateSystem` can be declared as 'matrix', 'calendar',
      //  which provides box layout container.
      coordinateSystemUsage: "box",
      left: "5%",
      top: "5%",
      right: "20%",
      bottom: "5%",
      orient: "horizontal",
      nodeWidth: 20,
      nodeGap: 8,
      draggable: !0,
      layoutIterations: 32,
      // true | false | 'move' | 'scale', see module:component/helper/RoamController.
      roam: !1,
      roamTrigger: "global",
      center: null,
      zoom: 1,
      label: {
        show: !0,
        position: "right",
        fontSize: 12
      },
      edgeLabel: {
        show: !1,
        fontSize: 12
      },
      levels: [],
      nodeAlign: "justify",
      lineStyle: {
        color: St.color.neutral50,
        opacity: 0.2,
        curveness: 0.5
      },
      emphasis: {
        label: {
          show: !0
        },
        lineStyle: {
          opacity: 0.5
        }
      },
      select: {
        itemStyle: {
          borderColor: St.color.primary
        }
      },
      animationEasing: "linear",
      animationDuration: 1e3
    }, t;
  })(sr)
);
function f4(e, t) {
  e.eachSeriesByType("sankey", function(i) {
    var n = i.get("nodeWidth"), r = i.get("nodeGap"), a = Ax(i, t).refContainer, s = np(i.getBoxLayoutParams(), a);
    i.layoutInfo = s;
    var o = s.width, l = s.height, u = i.getGraph(), c = u.nodes, h = u.edges;
    p4(c);
    var d = Ke(c, function(p) {
      return p.getLayout().value === 0;
    }), f = d.length !== 0 ? 0 : i.get("layoutIterations"), v = i.get("orient"), m = i.get("nodeAlign");
    v4(c, h, n, r, o, l, f, v, m);
  });
}
function v4(e, t, i, n, r, a, s, o, l) {
  g4(e, t, i, r, a, o, l), b4(e, t, a, r, n, s, o), E4(e, o);
}
function p4(e) {
  E(e, function(t) {
    var i = tr(t.outEdges, cc), n = tr(t.inEdges, cc), r = t.getValue() || 0, a = Math.max(i, n, r);
    t.setLayout({
      value: a
    }, !0);
  });
}
function g4(e, t, i, n, r, a, s) {
  for (var o = [], l = [], u = [], c = [], h = 0, d = 0; d < t.length; d++)
    o[d] = 1;
  for (var d = 0; d < e.length; d++)
    l[d] = e[d].inEdges.length, l[d] === 0 && u.push(e[d]);
  for (var f = -1; u.length; ) {
    for (var v = 0; v < u.length; v++) {
      var m = u[v], p = m.hostGraph.data.getRawDataItem(m.dataIndex), g = p.depth != null && p.depth >= 0;
      g && p.depth > f && (f = p.depth), m.setLayout({
        depth: g ? p.depth : h
      }, !0), a === "vertical" ? m.setLayout({
        dy: i
      }, !0) : m.setLayout({
        dx: i
      }, !0);
      for (var y = 0; y < m.outEdges.length; y++) {
        var _ = m.outEdges[y], b = t.indexOf(_);
        o[b] = 0;
        var w = _.node2, S = e.indexOf(w);
        --l[S] === 0 && c.indexOf(w) < 0 && c.push(w);
      }
    }
    ++h, u = c, c = [];
  }
  for (var d = 0; d < o.length; d++)
    if (o[d] === 1)
      throw new Error("Sankey is a DAG, the original data has cycle!");
  var M = f > h - 1 ? f : h - 1;
  s && s !== "left" && m4(e, s, a, M);
  var k = a === "vertical" ? (r - i) / M : (n - i) / M;
  _4(e, k, a);
}
function lS(e) {
  var t = e.hostGraph.data.getRawDataItem(e.dataIndex);
  return t.depth != null && t.depth >= 0;
}
function m4(e, t, i, n) {
  if (t === "right") {
    for (var r = [], a = e, s = 0; a.length; ) {
      for (var o = 0; o < a.length; o++) {
        var l = a[o];
        l.setLayout({
          skNodeHeight: s
        }, !0);
        for (var u = 0; u < l.inEdges.length; u++) {
          var c = l.inEdges[u];
          r.indexOf(c.node1) < 0 && r.push(c.node1);
        }
      }
      a = r, r = [], ++s;
    }
    E(e, function(h) {
      lS(h) || h.setLayout({
        depth: Math.max(0, n - h.getLayout().skNodeHeight)
      }, !0);
    });
  } else t === "justify" && y4(e, n);
}
function y4(e, t) {
  E(e, function(i) {
    !lS(i) && !i.outEdges.length && i.setLayout({
      depth: t
    }, !0);
  });
}
function _4(e, t, i) {
  E(e, function(n) {
    var r = n.getLayout().depth * t;
    i === "vertical" ? n.setLayout({
      y: r
    }, !0) : n.setLayout({
      x: r
    }, !0);
  });
}
function b4(e, t, i, n, r, a, s) {
  var o = x4(e, s);
  w4(o, t, i, n, r, s), Ed(o, r, i, n, s);
  for (var l = 1; a > 0; a--)
    l *= 0.99, S4(o, l, s), Ed(o, r, i, n, s), C4(o, l, s), Ed(o, r, i, n, s);
}
function x4(e, t) {
  var i = [], n = t === "vertical" ? "y" : "x", r = GL(e, function(a) {
    return a.getLayout()[n];
  });
  return r.keys.sort(function(a, s) {
    return a - s;
  }), E(r.keys, function(a) {
    i.push(r.buckets.get(a));
  }), i;
}
function w4(e, t, i, n, r, a) {
  var s = 1 / 0;
  E(e, function(o) {
    var l = o.length, u = 0;
    E(o, function(h) {
      u += h.getLayout().value;
    });
    var c = a === "vertical" ? (n - (l - 1) * r) / u : (i - (l - 1) * r) / u;
    c < s && (s = c);
  }), E(e, function(o) {
    E(o, function(l, u) {
      var c = l.getLayout().value * s;
      a === "vertical" ? (l.setLayout({
        x: u
      }, !0), l.setLayout({
        dx: c
      }, !0)) : (l.setLayout({
        y: u
      }, !0), l.setLayout({
        dy: c
      }, !0));
    });
  }), E(t, function(o) {
    var l = +o.getValue() * s;
    o.setLayout({
      dy: l
    }, !0);
  });
}
function Ed(e, t, i, n, r) {
  var a = r === "vertical" ? "x" : "y";
  E(e, function(s) {
    s.sort(function(m, p) {
      return m.getLayout()[a] - p.getLayout()[a];
    });
    for (var o, l, u, c = 0, h = s.length, d = r === "vertical" ? "dx" : "dy", f = 0; f < h; f++)
      l = s[f], u = c - l.getLayout()[a], u > 0 && (o = l.getLayout()[a] + u, r === "vertical" ? l.setLayout({
        x: o
      }, !0) : l.setLayout({
        y: o
      }, !0)), c = l.getLayout()[a] + l.getLayout()[d] + t;
    var v = r === "vertical" ? n : i;
    if (u = c - t - v, u > 0) {
      o = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
        x: o
      }, !0) : l.setLayout({
        y: o
      }, !0), c = o;
      for (var f = h - 2; f >= 0; --f)
        l = s[f], u = l.getLayout()[a] + l.getLayout()[d] + t - c, u > 0 && (o = l.getLayout()[a] - u, r === "vertical" ? l.setLayout({
          x: o
        }, !0) : l.setLayout({
          y: o
        }, !0)), c = l.getLayout()[a];
    }
  });
}
function S4(e, t, i) {
  E(e.slice().reverse(), function(n) {
    E(n, function(r) {
      if (r.outEdges.length) {
        var a = tr(r.outEdges, M4, i) / tr(r.outEdges, cc);
        if (isNaN(a)) {
          var s = r.outEdges.length;
          a = s ? tr(r.outEdges, k4, i) / s : 0;
        }
        if (i === "vertical") {
          var o = r.getLayout().x + (a - lr(r, i)) * t;
          r.setLayout({
            x: o
          }, !0);
        } else {
          var l = r.getLayout().y + (a - lr(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function M4(e, t) {
  return lr(e.node2, t) * e.getValue();
}
function k4(e, t) {
  return lr(e.node2, t);
}
function D4(e, t) {
  return lr(e.node1, t) * e.getValue();
}
function T4(e, t) {
  return lr(e.node1, t);
}
function lr(e, t) {
  return t === "vertical" ? e.getLayout().x + e.getLayout().dx / 2 : e.getLayout().y + e.getLayout().dy / 2;
}
function cc(e) {
  return e.getValue();
}
function tr(e, t, i) {
  for (var n = 0, r = e.length, a = -1; ++a < r; ) {
    var s = +t(e[a], i);
    isNaN(s) || (n += s);
  }
  return n;
}
function C4(e, t, i) {
  E(e, function(n) {
    E(n, function(r) {
      if (r.inEdges.length) {
        var a = tr(r.inEdges, D4, i) / tr(r.inEdges, cc);
        if (isNaN(a)) {
          var s = r.inEdges.length;
          a = s ? tr(r.inEdges, T4, i) / s : 0;
        }
        if (i === "vertical") {
          var o = r.getLayout().x + (a - lr(r, i)) * t;
          r.setLayout({
            x: o
          }, !0);
        } else {
          var l = r.getLayout().y + (a - lr(r, i)) * t;
          r.setLayout({
            y: l
          }, !0);
        }
      }
    });
  });
}
function E4(e, t) {
  var i = t === "vertical" ? "x" : "y";
  E(e, function(n) {
    n.outEdges.sort(function(r, a) {
      return r.node2.getLayout()[i] - a.node2.getLayout()[i];
    }), n.inEdges.sort(function(r, a) {
      return r.node1.getLayout()[i] - a.node1.getLayout()[i];
    });
  }), E(e, function(n) {
    var r = 0, a = 0;
    E(n.outEdges, function(s) {
      s.setLayout({
        sy: r
      }, !0), r += s.getLayout().dy;
    }), E(n.inEdges, function(s) {
      s.setLayout({
        ty: a
      }, !0), a += s.getLayout().dy;
    });
  });
}
function A4(e) {
  e.eachSeriesByType("sankey", function(t) {
    var i = t.getGraph(), n = i.nodes, r = i.edges;
    if (n.length) {
      var a = 1 / 0, s = -1 / 0;
      E(n, function(o) {
        var l = o.getLayout().value;
        l < a && (a = l), l > s && (s = l);
      }), E(n, function(o) {
        var l = new xp({
          type: "color",
          mappingMethod: "linear",
          dataExtent: [a, s],
          visual: t.get("color")
        }), u = l.mapValueToVisual(o.getLayout().value), c = o.getModel().get(["itemStyle", "color"]);
        c != null ? (o.setVisual("color", c), o.setVisual("style", {
          fill: c
        })) : (o.setVisual("color", u), o.setVisual("style", {
          fill: u
        }));
      });
    }
    r.length && E(r, function(o) {
      var l = o.getModel().get("lineStyle");
      o.setVisual("style", l);
    });
  });
}
function P4(e) {
  e.registerChartView(c4), e.registerSeriesModel(d4), e.registerLayout(f4), e.registerVisual(A4), e.registerAction({
    type: "dragNode",
    event: "dragnode",
    // here can only use 'update' now, other value is not support in echarts.
    update: "update"
  }, function(t, i) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(n) {
      n.setNodePosition(t.dataIndex, [t.localX, t.localY]);
    });
  }), e.registerAction({
    type: "sankeyRoam",
    event: "sankeyRoam",
    update: "none"
  }, function(t, i, n) {
    i.eachComponent({
      mainType: "series",
      subType: "sankey",
      query: t
    }, function(r) {
      var a = r.coordinateSystem, s = y3(a, t, r.get("scaleLimit"));
      r.setCenter(s.center), r.setZoom(s.zoom);
    });
  });
}
function R_(e, t, i) {
  var n = Tn.createCanvas(), r = t.getWidth(), a = t.getHeight(), s = n.style;
  return s && (s.position = "absolute", s.left = "0", s.top = "0", s.width = r + "px", s.height = a + "px", n.setAttribute("data-zr-dom-id", e)), n.width = r * i, n.height = a * i, n;
}
var Ad = (function(e) {
  Lt(t, e);
  function t(i, n, r) {
    var a = e.call(this) || this;
    a.motionBlur = !1, a.lastFrameAlpha = 0.7, a.dpr = 1, a.virtual = !1, a.config = {}, a.incremental = !1, a.zlevel = 0, a.maxRepaintRectCount = 5, a.__dirty = !0, a.__firstTimePaint = !0, a.__used = !1, a.__drawIndex = 0, a.__startIndex = 0, a.__endIndex = 0, a.__prevStartIndex = null, a.__prevEndIndex = null;
    var s;
    r = r || Nu, typeof i == "string" ? s = R_(i, n, r) : tt(i) && (s = i, i = s.id), a.id = i, a.dom = s;
    var o = s.style;
    return o && (r1(s), s.onselectstart = function() {
      return !1;
    }, o.padding = "0", o.margin = "0", o.borderWidth = "0"), a.painter = n, a.dpr = r, a;
  }
  return t.prototype.getElementCount = function() {
    return this.__endIndex - this.__startIndex;
  }, t.prototype.afterBrush = function() {
    this.__prevStartIndex = this.__startIndex, this.__prevEndIndex = this.__endIndex;
  }, t.prototype.initContext = function() {
    this.ctx = this.dom.getContext("2d"), this.ctx.dpr = this.dpr;
  }, t.prototype.setUnpainted = function() {
    this.__firstTimePaint = !0;
  }, t.prototype.createBackBuffer = function() {
    var i = this.dpr;
    this.domBack = R_("back-" + this.id, this.painter, i), this.ctxBack = this.domBack.getContext("2d"), i !== 1 && this.ctxBack.scale(i, i);
  }, t.prototype.createRepaintRects = function(i, n, r, a) {
    if (this.__firstTimePaint)
      return this.__firstTimePaint = !1, null;
    var s = [], o = this.maxRepaintRectCount, l = !1, u = new lt(0, 0, 0, 0);
    function c(y) {
      if (!(!y.isFinite() || y.isZero()))
        if (s.length === 0) {
          var _ = new lt(0, 0, 0, 0);
          _.copy(y), s.push(_);
        } else {
          for (var b = !1, w = 1 / 0, S = 0, M = 0; M < s.length; ++M) {
            var k = s[M];
            if (k.intersect(y)) {
              var T = new lt(0, 0, 0, 0);
              T.copy(k), T.union(y), s[M] = T, b = !0;
              break;
            } else if (l) {
              u.copy(y), u.union(k);
              var D = y.width * y.height, C = k.width * k.height, P = u.width * u.height, L = P - D - C;
              L < w && (w = L, S = M);
            }
          }
          if (l && (s[S].union(y), b = !0), !b) {
            var _ = new lt(0, 0, 0, 0);
            _.copy(y), s.push(_);
          }
          l || (l = s.length >= o);
        }
    }
    for (var h = this.__startIndex; h < this.__endIndex; ++h) {
      var d = i[h];
      if (d) {
        var f = d.shouldBePainted(r, a, !0, !0), v = d.__isRendered && (d.__dirty & Qe || !f) ? d.getPrevPaintRect() : null;
        v && c(v);
        var m = f && (d.__dirty & Qe || !d.__isRendered) ? d.getPaintRect() : null;
        m && c(m);
      }
    }
    for (var h = this.__prevStartIndex; h < this.__prevEndIndex; ++h) {
      var d = n[h], f = d && d.shouldBePainted(r, a, !0, !0);
      if (d && (!f || !d.__zr) && d.__isRendered) {
        var v = d.getPrevPaintRect();
        v && c(v);
      }
    }
    var p;
    do {
      p = !1;
      for (var h = 0; h < s.length; ) {
        if (s[h].isZero()) {
          s.splice(h, 1);
          continue;
        }
        for (var g = h + 1; g < s.length; )
          s[h].intersect(s[g]) ? (p = !0, s[h].union(s[g]), s.splice(g, 1)) : g++;
        h++;
      }
    } while (p);
    return this._paintRects = s, s;
  }, t.prototype.debugGetPaintRects = function() {
    return (this._paintRects || []).slice();
  }, t.prototype.resize = function(i, n) {
    var r = this.dpr, a = this.dom, s = a.style, o = this.domBack;
    s && (s.width = i + "px", s.height = n + "px"), a.width = i * r, a.height = n * r, o && (o.width = i * r, o.height = n * r, r !== 1 && this.ctxBack.scale(r, r));
  }, t.prototype.clear = function(i, n, r) {
    var a = this.dom, s = this.ctx, o = a.width, l = a.height;
    n = n || this.clearColor;
    var u = this.motionBlur && !i, c = this.lastFrameAlpha, h = this.dpr, d = this;
    u && (this.domBack || this.createBackBuffer(), this.ctxBack.globalCompositeOperation = "copy", this.ctxBack.drawImage(a, 0, 0, o / h, l / h));
    var f = this.domBack;
    function v(m, p, g, y) {
      if (s.clearRect(m, p, g, y), n && n !== "transparent") {
        var _ = void 0;
        if (kc(n)) {
          var b = n.global || n.__width === g && n.__height === y;
          _ = b && n.__canvasGradient || Rf(s, n, {
            x: 0,
            y: 0,
            width: g,
            height: y
          }), n.__canvasGradient = _, n.__width = g, n.__height = y;
        } else jA(n) && (n.scaleX = n.scaleX || h, n.scaleY = n.scaleY || h, _ = Nf(s, n, {
          dirty: function() {
            d.setUnpainted(), d.painter.refresh();
          }
        }));
        s.save(), s.fillStyle = _ || n, s.fillRect(m, p, g, y), s.restore();
      }
      u && (s.save(), s.globalAlpha = c, s.drawImage(f, m, p, g, y), s.restore());
    }
    !r || u ? v(0, 0, o, l) : r.length && E(r, function(m) {
      v(m.x * h, m.y * h, m.width * h, m.height * h);
    });
  }, t;
})(Li), N_ = 1e5, Rr = 314159, Jl = 0.01, L4 = 1e-3;
function O4(e) {
  return e ? e.__builtin__ ? !0 : !(typeof e.resize != "function" || typeof e.refresh != "function") : !1;
}
function I4(e, t) {
  var i = document.createElement("div");
  return i.style.cssText = [
    "position:relative",
    "width:" + e + "px",
    "height:" + t + "px",
    "padding:0",
    "margin:0",
    "border-width:0"
  ].join(";") + ";", i;
}
var R4 = (function() {
  function e(t, i, n, r) {
    this.type = "canvas", this._zlevelList = [], this._prevDisplayList = [], this._layers = {}, this._layerConfig = {}, this._needsManuallyCompositing = !1, this.type = "canvas";
    var a = !t.nodeName || t.nodeName.toUpperCase() === "CANVAS";
    this._opts = n = Y({}, n || {}), this.dpr = n.devicePixelRatio || Nu, this._singleCanvas = a, this.root = t;
    var s = t.style;
    s && (r1(t), t.innerHTML = ""), this.storage = i;
    var o = this._zlevelList;
    this._prevDisplayList = [];
    var l = this._layers;
    if (a) {
      var c = t, h = c.width, d = c.height;
      n.width != null && (h = n.width), n.height != null && (d = n.height), this.dpr = n.devicePixelRatio || 1, c.width = h * this.dpr, c.height = d * this.dpr, this._width = h, this._height = d;
      var f = new Ad(c, this, this.dpr);
      f.__builtin__ = !0, f.initContext(), l[Rr] = f, f.zlevel = Rr, o.push(Rr), this._domRoot = t;
    } else {
      this._width = Wl(t, 0, n), this._height = Wl(t, 1, n);
      var u = this._domRoot = I4(this._width, this._height);
      t.appendChild(u);
    }
  }
  return e.prototype.getType = function() {
    return "canvas";
  }, e.prototype.isSingleCanvas = function() {
    return this._singleCanvas;
  }, e.prototype.getViewportRoot = function() {
    return this._domRoot;
  }, e.prototype.getViewportRootOffset = function() {
    var t = this.getViewportRoot();
    if (t)
      return {
        offsetLeft: t.offsetLeft || 0,
        offsetTop: t.offsetTop || 0
      };
  }, e.prototype.refresh = function(t) {
    var i = this.storage.getDisplayList(!0), n = this._prevDisplayList, r = this._zlevelList;
    this._redrawId = Math.random(), this._paintList(i, n, t, this._redrawId);
    for (var a = 0; a < r.length; a++) {
      var s = r[a], o = this._layers[s];
      if (!o.__builtin__ && o.refresh) {
        var l = a === 0 ? this._backgroundColor : null;
        o.refresh(l);
      }
    }
    return this._opts.useDirtyRect && (this._prevDisplayList = i.slice()), this;
  }, e.prototype.refreshHover = function() {
    this._paintHoverList(this.storage.getDisplayList(!1));
  }, e.prototype._paintHoverList = function(t) {
    var i = t.length, n = this._hoverlayer;
    if (n && n.clear(), !!i) {
      for (var r = {
        inHover: !0,
        viewWidth: this._width,
        viewHeight: this._height
      }, a, s = 0; s < i; s++) {
        var o = t[s];
        o.__inHover && (n || (n = this._hoverlayer = this.getLayer(N_)), a || (a = n.ctx, a.save()), Xr(a, o, r, s === i - 1));
      }
      a && a.restore();
    }
  }, e.prototype.getHoverLayer = function() {
    return this.getLayer(N_);
  }, e.prototype.paintOne = function(t, i) {
    gw(t, i);
  }, e.prototype._paintList = function(t, i, n, r) {
    if (this._redrawId === r) {
      n = n || !1, this._updateLayerStatus(t);
      var a = this._doPaintList(t, i, n), s = a.finished, o = a.needsRefreshHover;
      if (this._needsManuallyCompositing && this._compositeManually(), o && this._paintHoverList(t), s)
        this.eachLayer(function(u) {
          u.afterBrush && u.afterBrush();
        });
      else {
        var l = this;
        Au(function() {
          l._paintList(t, i, n, r);
        });
      }
    }
  }, e.prototype._compositeManually = function() {
    var t = this.getLayer(Rr).ctx, i = this._domRoot.width, n = this._domRoot.height;
    t.clearRect(0, 0, i, n), this.eachBuiltinLayer(function(r) {
      r.virtual && t.drawImage(r.dom, 0, 0, i, n);
    });
  }, e.prototype._doPaintList = function(t, i, n) {
    for (var r = this, a = [], s = this._opts.useDirtyRect, o = 0; o < this._zlevelList.length; o++) {
      var l = this._zlevelList[o], u = this._layers[l];
      u.__builtin__ && u !== this._hoverlayer && (u.__dirty || n) && a.push(u);
    }
    for (var c = !0, h = !1, d = function(m) {
      var p = a[m], g = p.ctx, y = s && p.createRepaintRects(t, i, f._width, f._height), _ = n ? p.__startIndex : p.__drawIndex, b = !n && p.incremental && Date.now, w = b && Date.now(), S = p.zlevel === f._zlevelList[0] ? f._backgroundColor : null;
      if (p.__startIndex === p.__endIndex)
        p.clear(!1, S, y);
      else if (_ === p.__startIndex) {
        var M = t[_];
        (!M.incremental || !M.notClear || n) && p.clear(!1, S, y);
      }
      _ === -1 && (console.error("For some unknown reason. drawIndex is -1"), _ = p.__startIndex);
      var k, T = function(L) {
        var O = {
          inHover: !1,
          allClipped: !1,
          prevEl: null,
          viewWidth: r._width,
          viewHeight: r._height
        };
        for (k = _; k < p.__endIndex; k++) {
          var N = t[k];
          if (N.__inHover && (h = !0), r._doPaintEl(N, p, s, L, O, k === p.__endIndex - 1), b) {
            var B = Date.now() - w;
            if (B > 15)
              break;
          }
        }
        O.prevElClipPaths && g.restore();
      };
      if (y)
        if (y.length === 0)
          k = p.__endIndex;
        else
          for (var D = f.dpr, C = 0; C < y.length; ++C) {
            var P = y[C];
            g.save(), g.beginPath(), g.rect(P.x * D, P.y * D, P.width * D, P.height * D), g.clip(), T(P), g.restore();
          }
      else
        g.save(), T(), g.restore();
      p.__drawIndex = k, p.__drawIndex < p.__endIndex && (c = !1);
    }, f = this, v = 0; v < a.length; v++)
      d(v);
    return ot.wxa && E(this._layers, function(m) {
      m && m.ctx && m.ctx.draw && m.ctx.draw();
    }), {
      finished: c,
      needsRefreshHover: h
    };
  }, e.prototype._doPaintEl = function(t, i, n, r, a, s) {
    var o = i.ctx;
    if (n) {
      var l = t.getPaintRect();
      (!r || l && l.intersect(r)) && (Xr(o, t, a, s), t.setPrevPaintRect(l));
    } else
      Xr(o, t, a, s);
  }, e.prototype.getLayer = function(t, i) {
    this._singleCanvas && !this._needsManuallyCompositing && (t = Rr);
    var n = this._layers[t];
    return n || (n = new Ad("zr_" + t, this, this.dpr), n.zlevel = t, n.__builtin__ = !0, this._layerConfig[t] ? se(n, this._layerConfig[t], !0) : this._layerConfig[t - Jl] && se(n, this._layerConfig[t - Jl], !0), i && (n.virtual = i), this.insertLayer(t, n), n.initContext()), n;
  }, e.prototype.insertLayer = function(t, i) {
    var n = this._layers, r = this._zlevelList, a = r.length, s = this._domRoot, o = null, l = -1;
    if (n[t]) {
      process.env.NODE_ENV !== "production" && Kr("ZLevel " + t + " has been used already");
      return;
    }
    if (!O4(i)) {
      process.env.NODE_ENV !== "production" && Kr("Layer of zlevel " + t + " is not valid");
      return;
    }
    if (a > 0 && t > r[0]) {
      for (l = 0; l < a - 1 && !(r[l] < t && r[l + 1] > t); l++)
        ;
      o = n[r[l]];
    }
    if (r.splice(l + 1, 0, t), n[t] = i, !i.virtual)
      if (o) {
        var u = o.dom;
        u.nextSibling ? s.insertBefore(i.dom, u.nextSibling) : s.appendChild(i.dom);
      } else
        s.firstChild ? s.insertBefore(i.dom, s.firstChild) : s.appendChild(i.dom);
    i.painter || (i.painter = this);
  }, e.prototype.eachLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r];
      t.call(i, this._layers[a], a);
    }
  }, e.prototype.eachBuiltinLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], s = this._layers[a];
      s.__builtin__ && t.call(i, s, a);
    }
  }, e.prototype.eachOtherLayer = function(t, i) {
    for (var n = this._zlevelList, r = 0; r < n.length; r++) {
      var a = n[r], s = this._layers[a];
      s.__builtin__ || t.call(i, s, a);
    }
  }, e.prototype.getLayers = function() {
    return this._layers;
  }, e.prototype._updateLayerStatus = function(t) {
    this.eachBuiltinLayer(function(h, d) {
      h.__dirty = h.__used = !1;
    });
    function i(h) {
      a && (a.__endIndex !== h && (a.__dirty = !0), a.__endIndex = h);
    }
    if (this._singleCanvas)
      for (var n = 1; n < t.length; n++) {
        var r = t[n];
        if (r.zlevel !== t[n - 1].zlevel || r.incremental) {
          this._needsManuallyCompositing = !0;
          break;
        }
      }
    var a = null, s = 0, o, l;
    for (l = 0; l < t.length; l++) {
      var r = t[l], u = r.zlevel, c = void 0;
      o !== u && (o = u, s = 0), r.incremental ? (c = this.getLayer(u + L4, this._needsManuallyCompositing), c.incremental = !0, s = 1) : c = this.getLayer(u + (s > 0 ? Jl : 0), this._needsManuallyCompositing), c.__builtin__ || Kr("ZLevel " + u + " has been used by unkown layer " + c.id), c !== a && (c.__used = !0, c.__startIndex !== l && (c.__dirty = !0), c.__startIndex = l, c.incremental ? c.__drawIndex = -1 : c.__drawIndex = l, i(l), a = c), r.__dirty & Qe && !r.__inHover && (c.__dirty = !0, c.incremental && c.__drawIndex < 0 && (c.__drawIndex = l));
    }
    i(l), this.eachBuiltinLayer(function(h, d) {
      !h.__used && h.getElementCount() > 0 && (h.__dirty = !0, h.__startIndex = h.__endIndex = h.__drawIndex = 0), h.__dirty && h.__drawIndex < 0 && (h.__drawIndex = h.__startIndex);
    });
  }, e.prototype.clear = function() {
    return this.eachBuiltinLayer(this._clearLayer), this;
  }, e.prototype._clearLayer = function(t) {
    t.clear();
  }, e.prototype.setBackgroundColor = function(t) {
    this._backgroundColor = t, E(this._layers, function(i) {
      i.setUnpainted();
    });
  }, e.prototype.configLayer = function(t, i) {
    if (i) {
      var n = this._layerConfig;
      n[t] ? se(n[t], i, !0) : n[t] = i;
      for (var r = 0; r < this._zlevelList.length; r++) {
        var a = this._zlevelList[r];
        if (a === t || a === t + Jl) {
          var s = this._layers[a];
          se(s, n[t], !0);
        }
      }
    }
  }, e.prototype.delLayer = function(t) {
    var i = this._layers, n = this._zlevelList, r = i[t];
    r && (r.dom.parentNode.removeChild(r.dom), delete i[t], n.splice(Ht(n, t), 1));
  }, e.prototype.resize = function(t, i) {
    if (this._domRoot.style) {
      var n = this._domRoot;
      n.style.display = "none";
      var r = this._opts, a = this.root;
      if (t != null && (r.width = t), i != null && (r.height = i), t = Wl(a, 0, r), i = Wl(a, 1, r), n.style.display = "", this._width !== t || i !== this._height) {
        n.style.width = t + "px", n.style.height = i + "px";
        for (var s in this._layers)
          this._layers.hasOwnProperty(s) && this._layers[s].resize(t, i);
        this.refresh(!0);
      }
      this._width = t, this._height = i;
    } else {
      if (t == null || i == null)
        return;
      this._width = t, this._height = i, this.getLayer(Rr).resize(t, i);
    }
    return this;
  }, e.prototype.clearLayer = function(t) {
    var i = this._layers[t];
    i && i.clear();
  }, e.prototype.dispose = function() {
    this.root.innerHTML = "", this.root = this.storage = this._domRoot = this._layers = null;
  }, e.prototype.getRenderedCanvas = function(t) {
    if (t = t || {}, this._singleCanvas && !this._compositeManually)
      return this._layers[Rr].dom;
    var i = new Ad("image", this, t.pixelRatio || this.dpr);
    i.initContext(), i.clear(!1, t.backgroundColor || this._backgroundColor);
    var n = i.ctx;
    if (t.pixelRatio <= this.dpr) {
      this.refresh();
      var r = i.dom.width, a = i.dom.height;
      this.eachLayer(function(h) {
        h.__builtin__ ? n.drawImage(h.dom, 0, 0, r, a) : h.renderToCanvas && (n.save(), h.renderToCanvas(n), n.restore());
      });
    } else
      for (var s = {
        inHover: !1,
        viewWidth: this._width,
        viewHeight: this._height
      }, o = this.storage.getDisplayList(!0), l = 0, u = o.length; l < u; l++) {
        var c = o[l];
        Xr(n, c, s, l === u - 1);
      }
    return i.dom;
  }, e.prototype.getWidth = function() {
    return this._width;
  }, e.prototype.getHeight = function() {
    return this._height;
  }, e;
})();
function N4(e) {
  e.registerPainter("canvas", R4);
}
const F4 = { class: "chart-container" }, B4 = {
  key: 1,
  class: "chart-wrapper"
}, $4 = /* @__PURE__ */ le({
  __name: "SankeyChart",
  props: {
    data: { default: () => ({ nodes: [], links: [] }) },
    title: { default: "" },
    height: { default: "500px" },
    nodeColors: { default: () => ({}) },
    useGradient: { type: Boolean, default: !0 },
    nodeGap: { default: 20 },
    theme: { default: void 0 }
  },
  setup(e, { expose: t }) {
    pp([U3, Q3, P4, N4]);
    const i = e, { isDark: n, colors: r } = _e(ye(i, "theme")), a = gi(null), s = gi(!0), o = gi(!1);
    let l = null;
    const u = {
      animation: { duration: 1e3, easing: "cubicOut" },
      margins: { left: "2%", right: "2%", top: "2%", bottom: "2%" },
      node: { width: 70, gap: 20, align: "left", iterations: 64 },
      style: {
        shadowBlur: 4,
        shadowColor: "rgba(139, 92, 246, 0.15)"
      }
    }, c = [
      "#C67DFF",
      // Primary light
      "#8b5cf6",
      // Primary medium
      "#a855f7",
      // Bright purple
      "#7c3aed",
      // Vibrant purple
      "#5d4b93",
      // Primary dark
      "#9333ea"
      // Deep purple
    ], h = () => {
      const _ = i.data.links.filter(
        (M) => M.source && M.target && typeof M.value == "number"
      ), b = Math.max(..._.map((M) => M.value), 1), w = Math.max(1, b * 0.01), S = _.map((M) => ({
        ...M,
        originalValue: M.value,
        value: M.value < b * 0.01 ? w : M.value
      }));
      return {
        nodes: i.data.nodes.filter((M) => M.name),
        links: S
      };
    }, d = (_) => _.map((b, w) => ({
      ...b,
      itemStyle: {
        color: i.nodeColors[b.name] || c[w % c.length],
        borderRadius: 8
      }
    })), f = (_) => (b) => {
      const w = b.dataType === "node", S = r.value.tooltipText, M = n.value ? "#d1d5db" : "#e2e8f0";
      if (w) {
        const P = _.filter((N) => N.target === b.name), L = _.filter((N) => N.source === b.name), O = P.length > 0 ? P.reduce((N, B) => N + (B.originalValue || B.value), 0) : L.reduce((N, B) => N + (B.originalValue || B.value), 0);
        return `<div style="font-weight: 600; margin-bottom: 4px; color: ${S};">${b.name}</div><div style="color: ${M}; font-size: 12px;">Count: ${O.toLocaleString()}</div>`;
      }
      const k = b.data?.source || b.source || "Unknown", T = b.data?.target || b.target || "Unknown", D = b.data?.originalValue || b.data?.value || b.value || 0, C = b.data?.label || `${D.toLocaleString()}`;
      return `<div style="font-weight: 600; margin-bottom: 4px; color: ${S};">${k}  ${T}</div><div style="color: ${M}; font-size: 12px;">Flow: ${C}</div>`;
    }, v = () => {
      if (!(!l || !i.data.nodes?.length || !i.data.links?.length))
        try {
          const { nodes: _, links: b } = h(), w = d(_), S = {
            tooltip: {
              trigger: "item",
              triggerOn: "mousemove",
              formatter: f(b),
              backgroundColor: r.value.tooltipBg,
              borderColor: n.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
              borderWidth: 1,
              borderRadius: 8,
              padding: [10, 14],
              textStyle: {
                color: r.value.tooltipText,
                fontSize: 13,
                fontFamily: "'DM Sans', sans-serif",
                fontWeight: 500
              },
              shadowBlur: 10,
              shadowColor: "rgba(0, 0, 0, 0.3)"
            },
            series: [
              {
                type: "sankey",
                data: w,
                links: b,
                emphasis: { focus: "adjacency" },
                levels: [
                  {
                    depth: 0,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  },
                  {
                    depth: 1,
                    itemStyle: {
                      color: "#8b5cf6",
                      borderRadius: 8
                    },
                    lineStyle: { color: "source", opacity: 0.5 }
                  }
                ],
                lineStyle: {
                  color: i.useGradient ? "gradient" : "source",
                  curveness: 0.5,
                  opacity: 0.6
                },
                itemStyle: u.style,
                label: {
                  show: !0,
                  position: "inside",
                  color: "#ffffff",
                  fontWeight: 600,
                  fontSize: 12,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (M) => {
                    const k = M.name || "";
                    return k.length > 15 ? `${k.substring(0, 15)}...` : k;
                  }
                },
                edgeLabel: {
                  show: !0,
                  fontSize: 11,
                  color: r.value.textSecondary,
                  fontWeight: 600,
                  fontFamily: "'DM Sans', sans-serif",
                  formatter: (M) => {
                    const k = M.data?.originalValue || M.value || 0;
                    return M.data?.label || `${k.toLocaleString()}`;
                  }
                },
                nodeAlign: u.node.align,
                nodeGap: i.nodeGap,
                nodeWidth: u.node.width,
                layoutIterations: u.node.iterations,
                orient: "horizontal",
                draggable: !1,
                ...u.margins
              }
            ],
            backgroundColor: "transparent",
            animation: !0,
            animationDuration: u.animation.duration,
            animationEasing: u.animation.easing
          };
          l.setOption(S);
        } catch (_) {
          console.error("Error setting Sankey chart options:", _), o.value = !0;
        }
    }, m = async () => {
      if (a.value)
        try {
          l = EF(a.value), v(), window.addEventListener("resize", g);
        } catch (_) {
          console.error("Error initializing Sankey chart:", _), o.value = !0;
        } finally {
          s.value = !1;
        }
    }, p = async (_ = 40) => {
      await q_();
      for (let b = 0; b < _; b++) {
        if (a.value?.clientWidth && a.value.clientWidth > 0 && a.value?.clientHeight && a.value.clientHeight > 0)
          return await m();
        await new Promise((w) => setTimeout(w, 50));
      }
      await m(), setTimeout(g, 50);
    }, g = () => l?.resize(), y = () => {
      window.removeEventListener("resize", g), l && (l.dispose(), l = null);
    };
    return tv(() => a.value && p()), n2(y), ns(() => i.data, v, { deep: !0 }), ns(n, v), t({ isDark: n }), (_, b) => (A(), I("div", F4, [
      o.value ? (A(), I("div", {
        key: 0,
        class: "error-state",
        style: qr({ height: e.height })
      }, [...b[0] || (b[0] = [
        Nt('<div class="error-content" data-v-e8598dd9><svg class="error-icon" fill="none" stroke="currentColor" viewBox="0 0 24 24" data-v-e8598dd9><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4m0 4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-e8598dd9></path></svg><p class="error-title" data-v-e8598dd9>Chart could not be loaded</p><p class="error-description" data-v-e8598dd9>Please check the data format.</p></div>', 1)
      ])], 4)) : (A(), I("div", B4, [
        jp(x("div", {
          ref_key: "chartEl",
          ref: a,
          class: "chart-content",
          style: qr({ height: e.height })
        }, null, 4), [
          [qp, !s.value]
        ]),
        jp(x("div", {
          class: "loading-state",
          style: qr({ height: e.height })
        }, [...b[1] || (b[1] = [
          Nt('<div class="loading-container" data-v-e8598dd9><div class="sankey-loader" data-v-e8598dd9><div class="flow flow-1" data-v-e8598dd9></div><div class="flow flow-2" data-v-e8598dd9></div><div class="flow flow-3" data-v-e8598dd9></div><div class="flow flow-4" data-v-e8598dd9></div></div><p class="loading-text" data-v-e8598dd9>Loading Sankey diagram...</p></div>', 1)
        ])], 4), [
          [qp, s.value]
        ])
      ]))
    ]));
  }
}), pa = /* @__PURE__ */ te($4, [["__scopeId", "data-v-e8598dd9"]]);
function Sp(e, t) {
  return A(), I("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M3 13.125C3 12.504 3.504 12 4.125 12h2.25c.621 0 1.125.504 1.125 1.125v6.75C7.5 20.496 6.996 21 6.375 21h-2.25A1.125 1.125 0 0 1 3 19.875v-6.75ZM9.75 8.625c0-.621.504-1.125 1.125-1.125h2.25c.621 0 1.125.504 1.125 1.125v11.25c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V8.625ZM16.5 4.125c0-.621.504-1.125 1.125-1.125h2.25C20.496 3 21 3.504 21 4.125v15.75c0 .621-.504 1.125-1.125 1.125h-2.25a1.125 1.125 0 0 1-1.125-1.125V4.125Z"
    })
  ]);
}
function z4(e, t) {
  return A(), I("svg", {
    xmlns: "http://www.w3.org/2000/svg",
    fill: "none",
    viewBox: "0 0 24 24",
    "stroke-width": "1.5",
    stroke: "currentColor",
    "aria-hidden": "true",
    "data-slot": "icon"
  }, [
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M10.5 6a7.5 7.5 0 1 0 7.5 7.5h-7.5V6Z"
    }),
    x("path", {
      "stroke-linecap": "round",
      "stroke-linejoin": "round",
      d: "M13.5 10.5H21A7.5 7.5 0 0 0 13.5 3v7.5Z"
    })
  ]);
}
const V4 = { class: "chart-footer" }, H4 = { class: "export-actions" }, Y4 = { class: "export-buttons" }, W4 = /* @__PURE__ */ le({
  __name: "FooterExport",
  props: {
    formats: { default: () => ["pdf", "csv", "xlsx"] }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = e, n = t, r = (s) => i.formats.includes(s), a = (s) => {
      n("export", s);
    };
    return (s, o) => (A(), I("footer", V4, [
      o[7] || (o[7] = x("div", { class: "footer-divider" }, null, -1)),
      x("div", H4, [
        o[6] || (o[6] = x("span", { class: "export-label" }, "Export", -1)),
        x("div", Y4, [
          r("pdf") ? (A(), I("button", {
            key: 0,
            type: "button",
            class: "export-btn",
            title: "Download PDF",
            onClick: o[0] || (o[0] = (l) => a("pdf"))
          }, [...o[3] || (o[3] = [
            Nt('<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-73d36d4a><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" data-v-73d36d4a></path><polyline points="14 2 14 8 20 8" data-v-73d36d4a></polyline><line x1="16" y1="13" x2="8" y2="13" data-v-73d36d4a></line><line x1="16" y1="17" x2="8" y2="17" data-v-73d36d4a></line><polyline points="10 9 9 9 8 9" data-v-73d36d4a></polyline></svg><span data-v-73d36d4a>PDF</span>', 2)
          ])])) : Q("", !0),
          r("csv") ? (A(), I("button", {
            key: 1,
            type: "button",
            class: "export-btn",
            title: "Download CSV",
            onClick: o[1] || (o[1] = (l) => a("csv"))
          }, [...o[4] || (o[4] = [
            Nt('<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" data-v-73d36d4a><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" data-v-73d36d4a></path><polyline points="14 2 14 8 20 8" data-v-73d36d4a></polyline><line x1="12" y1="18" x2="12" y2="12" data-v-73d36d4a></line><line x1="9" y1="15" x2="15" y2="15" data-v-73d36d4a></line></svg><span data-v-73d36d4a>CSV</span>', 2)
          ])])) : Q("", !0),
          r("xlsx") ? (A(), I("button", {
            key: 2,
            type: "button",
            class: "export-btn",
            title: "Download XLSX",
            onClick: o[2] || (o[2] = (l) => a("xlsx"))
          }, [...o[5] || (o[5] = [
            x("svg", {
              width: "14",
              height: "14",
              viewBox: "0 0 24 24",
              fill: "none",
              stroke: "currentColor",
              "stroke-width": "2",
              "stroke-linecap": "round",
              "stroke-linejoin": "round"
            }, [
              x("path", { d: "M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z" }),
              x("polyline", { points: "14 2 14 8 20 8" }),
              x("rect", {
                x: "8",
                y: "12",
                width: "8",
                height: "6",
                rx: "1"
              })
            ], -1),
            x("span", null, "XLSX", -1)
          ])])) : Q("", !0)
        ])
      ])
    ]));
  }
}), ei = /* @__PURE__ */ te(W4, [["__scopeId", "data-v-73d36d4a"]]), U4 = { class: "agents-per-day-card" }, G4 = {
  key: 0,
  class: "card-body"
}, X4 = {
  key: 0,
  class: "chart-section"
}, j4 = {
  key: 1,
  class: "empty-state"
}, q4 = { class: "empty-state-content" }, Z4 = { class: "empty-icon-wrapper" }, K4 = {
  key: 1,
  class: "loading-state"
}, Q4 = /* @__PURE__ */ le({
  __name: "AgentsPerDay",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, r = e, a = i, s = (d) => {
      a("export", d);
    }, { isDark: o, colors: l } = _e(ye(r, "theme")), u = (d) => {
      const f = new Date(d), v = String(f.getDate()).padStart(2, "0"), m = String(f.getMonth() + 1).padStart(2, "0");
      return `${v}-${m}`;
    }, c = q(() => {
      const d = r.data?.agents_by_day || {}, f = Object.keys(d).sort();
      if (f.length === 0)
        return { labels: [], datasets: [] };
      const v = f.map((_) => u(_)), m = /* @__PURE__ */ new Set();
      for (const _ of Object.values(d))
        for (const b of Object.keys(_))
          m.add(b);
      const p = Array.from(m), g = (_) => _, y = p.map((_) => ({
        label: _,
        data: f.map((b) => d[b]?.[_] || 0),
        backgroundColor: `${n[_] || "#94a3b8"}80`,
        borderColor: g(n[_] || "#94a3b8"),
        borderWidth: 1
      }));
      return {
        labels: v,
        datasets: y
      };
    }), h = q(() => r.options ? r.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      interaction: {
        mode: "index",
        intersect: !1
      },
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: l.value.textSecondary,
            padding: 12,
            boxWidth: 12,
            boxHeight: 12,
            borderRadius: 4,
            usePointStyle: !0,
            pointStyle: "rectRounded"
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: l.value.tooltipBg,
          titleColor: l.value.tooltipText,
          bodyColor: l.value.tooltipText,
          borderColor: o.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          }
        }
      },
      scales: {
        x: {
          stacked: !0,
          border: {
            display: !1
          },
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: l.value.textSecondary,
            padding: 8
          }
        },
        y: {
          stacked: !0,
          beginAtZero: !0,
          border: {
            display: !1
          },
          grid: {
            color: l.value.gridLines,
            lineWidth: 1,
            drawTicks: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: l.value.textSecondary,
            padding: 8
          }
        }
      }
    });
    return t({ isDark: o }), (d, f) => (A(), I("article", U4, [
      f[3] || (f[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Agents Total Messages per Day"),
          x("p", { class: "card-subtitle" }, "Daily agent interactions (stacked)")
        ])
      ], -1)),
      e.loading ? (A(), I("div", K4, [...f[2] || (f[2] = [
        Nt('<div class="loading-container" data-v-1e6b77c1><div class="chart-lines-loader" data-v-1e6b77c1><div class="line line-1" data-v-1e6b77c1></div><div class="line line-2" data-v-1e6b77c1></div><div class="line line-3" data-v-1e6b77c1></div><div class="line line-4" data-v-1e6b77c1></div><div class="line line-5" data-v-1e6b77c1></div></div><p class="loading-text" data-v-1e6b77c1>Loading chart data...</p></div>', 1)
      ])])) : (A(), I("div", G4, [
        c.value.labels && c.value.labels.length ? (A(), I("section", X4, [
          fe(jb, {
            data: c.value,
            options: h.value,
            stacked: !0
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: s
          })) : Q("", !0)
        ])) : (A(), I("section", j4, [
          x("div", q4, [
            x("div", Z4, [
              fe(X(Sp), { class: "empty-icon" })
            ]),
            f[0] || (f[0] = x("p", { class: "empty-title" }, "No agents data per day", -1)),
            f[1] || (f[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see daily agent interactions.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), J4 = /* @__PURE__ */ te(Q4, [["__scopeId", "data-v-1e6b77c1"]]);
var uS;
function H() {
  return uS.apply(null, arguments);
}
function t$(e) {
  uS = e;
}
function Ei(e) {
  return e instanceof Array || Object.prototype.toString.call(e) === "[object Array]";
}
function aa(e) {
  return e != null && Object.prototype.toString.call(e) === "[object Object]";
}
function bt(e, t) {
  return Object.prototype.hasOwnProperty.call(e, t);
}
function Mp(e) {
  if (Object.getOwnPropertyNames)
    return Object.getOwnPropertyNames(e).length === 0;
  var t;
  for (t in e)
    if (bt(e, t))
      return !1;
  return !0;
}
function ze(e) {
  return e === void 0;
}
function An(e) {
  return typeof e == "number" || Object.prototype.toString.call(e) === "[object Number]";
}
function tl(e) {
  return e instanceof Date || Object.prototype.toString.call(e) === "[object Date]";
}
function cS(e, t) {
  var i = [], n, r = e.length;
  for (n = 0; n < r; ++n)
    i.push(t(e[n], n));
  return i;
}
function jn(e, t) {
  for (var i in t)
    bt(t, i) && (e[i] = t[i]);
  return bt(t, "toString") && (e.toString = t.toString), bt(t, "valueOf") && (e.valueOf = t.valueOf), e;
}
function rn(e, t, i, n) {
  return OS(e, t, i, n, !0).utc();
}
function e$() {
  return {
    empty: !1,
    unusedTokens: [],
    unusedInput: [],
    overflow: -2,
    charsLeftOver: 0,
    nullInput: !1,
    invalidEra: null,
    invalidMonth: null,
    invalidFormat: !1,
    userInvalidated: !1,
    iso: !1,
    parsedDateParts: [],
    era: null,
    meridiem: null,
    rfc2822: !1,
    weekdayMismatch: !1
  };
}
function ut(e) {
  return e._pf == null && (e._pf = e$()), e._pf;
}
var Xf;
Array.prototype.some ? Xf = Array.prototype.some : Xf = function(e) {
  var t = Object(this), i = t.length >>> 0, n;
  for (n = 0; n < i; n++)
    if (n in t && e.call(this, t[n], n, t))
      return !0;
  return !1;
};
function kp(e) {
  var t = null, i = !1, n = e._d && !isNaN(e._d.getTime());
  if (n && (t = ut(e), i = Xf.call(t.parsedDateParts, function(r) {
    return r != null;
  }), n = t.overflow < 0 && !t.empty && !t.invalidEra && !t.invalidMonth && !t.invalidWeekday && !t.weekdayMismatch && !t.nullInput && !t.invalidFormat && !t.userInvalidated && (!t.meridiem || t.meridiem && i), e._strict && (n = n && t.charsLeftOver === 0 && t.unusedTokens.length === 0 && t.bigHour === void 0)), Object.isFrozen == null || !Object.isFrozen(e))
    e._isValid = n;
  else
    return n;
  return e._isValid;
}
function Yc(e) {
  var t = rn(NaN);
  return e != null ? jn(ut(t), e) : ut(t).userInvalidated = !0, t;
}
var F_ = H.momentProperties = [], Pd = !1;
function Dp(e, t) {
  var i, n, r, a = F_.length;
  if (ze(t._isAMomentObject) || (e._isAMomentObject = t._isAMomentObject), ze(t._i) || (e._i = t._i), ze(t._f) || (e._f = t._f), ze(t._l) || (e._l = t._l), ze(t._strict) || (e._strict = t._strict), ze(t._tzm) || (e._tzm = t._tzm), ze(t._isUTC) || (e._isUTC = t._isUTC), ze(t._offset) || (e._offset = t._offset), ze(t._pf) || (e._pf = ut(t)), ze(t._locale) || (e._locale = t._locale), a > 0)
    for (i = 0; i < a; i++)
      n = F_[i], r = t[n], ze(r) || (e[n] = r);
  return e;
}
function el(e) {
  Dp(this, e), this._d = new Date(e._d != null ? e._d.getTime() : NaN), this.isValid() || (this._d = /* @__PURE__ */ new Date(NaN)), Pd === !1 && (Pd = !0, H.updateOffset(this), Pd = !1);
}
function Ai(e) {
  return e instanceof el || e != null && e._isAMomentObject != null;
}
function hS(e) {
  H.suppressDeprecationWarnings === !1 && typeof console < "u" && console.warn && console.warn("Deprecation warning: " + e);
}
function bi(e, t) {
  var i = !0;
  return jn(function() {
    if (H.deprecationHandler != null && H.deprecationHandler(null, e), i) {
      var n = [], r, a, s, o = arguments.length;
      for (a = 0; a < o; a++) {
        if (r = "", typeof arguments[a] == "object") {
          r += `
[` + a + "] ";
          for (s in arguments[0])
            bt(arguments[0], s) && (r += s + ": " + arguments[0][s] + ", ");
          r = r.slice(0, -2);
        } else
          r = arguments[a];
        n.push(r);
      }
      hS(
        e + `
Arguments: ` + Array.prototype.slice.call(n).join("") + `
` + new Error().stack
      ), i = !1;
    }
    return t.apply(this, arguments);
  }, t);
}
var B_ = {};
function dS(e, t) {
  H.deprecationHandler != null && H.deprecationHandler(e, t), B_[e] || (hS(t), B_[e] = !0);
}
H.suppressDeprecationWarnings = !1;
H.deprecationHandler = null;
function an(e) {
  return typeof Function < "u" && e instanceof Function || Object.prototype.toString.call(e) === "[object Function]";
}
function i$(e) {
  var t, i;
  for (i in e)
    bt(e, i) && (t = e[i], an(t) ? this[i] = t : this["_" + i] = t);
  this._config = e, this._dayOfMonthOrdinalParseLenient = new RegExp(
    (this._dayOfMonthOrdinalParse.source || this._ordinalParse.source) + "|" + /\d{1,2}/.source
  );
}
function jf(e, t) {
  var i = jn({}, e), n;
  for (n in t)
    bt(t, n) && (aa(e[n]) && aa(t[n]) ? (i[n] = {}, jn(i[n], e[n]), jn(i[n], t[n])) : t[n] != null ? i[n] = t[n] : delete i[n]);
  for (n in e)
    bt(e, n) && !bt(t, n) && aa(e[n]) && (i[n] = jn({}, i[n]));
  return i;
}
function Tp(e) {
  e != null && this.set(e);
}
var qf;
Object.keys ? qf = Object.keys : qf = function(e) {
  var t, i = [];
  for (t in e)
    bt(e, t) && i.push(t);
  return i;
};
var n$ = {
  sameDay: "[Today at] LT",
  nextDay: "[Tomorrow at] LT",
  nextWeek: "dddd [at] LT",
  lastDay: "[Yesterday at] LT",
  lastWeek: "[Last] dddd [at] LT",
  sameElse: "L"
};
function r$(e, t, i) {
  var n = this._calendar[e] || this._calendar.sameElse;
  return an(n) ? n.call(t, i) : n;
}
function en(e, t, i) {
  var n = "" + Math.abs(e), r = t - n.length, a = e >= 0;
  return (a ? i ? "+" : "" : "-") + Math.pow(10, Math.max(0, r)).toString().substr(1) + n;
}
var Cp = /(\[[^\[]*\])|(\\)?([Hh]mm(ss)?|Mo|MM?M?M?|Do|DDDo|DD?D?D?|ddd?d?|do?|w[o|w]?|W[o|W]?|Qo?|N{1,5}|YYYYYY|YYYYY|YYYY|YY|y{2,4}|yo?|gg(ggg?)?|GG(GGG?)?|e|E|a|A|hh?|HH?|kk?|mm?|ss?|S{1,9}|x|X|zz?|ZZ?|.)/g, tu = /(\[[^\[]*\])|(\\)?(LTS|LT|LL?L?L?|l{1,4})/g, Ld = {}, ts = {};
function J(e, t, i, n) {
  var r = n;
  typeof n == "string" && (r = function() {
    return this[n]();
  }), e && (ts[e] = r), t && (ts[t[0]] = function() {
    return en(r.apply(this, arguments), t[1], t[2]);
  }), i && (ts[i] = function() {
    return this.localeData().ordinal(
      r.apply(this, arguments),
      e
    );
  });
}
function a$(e) {
  return e.match(/\[[\s\S]/) ? e.replace(/^\[|\]$/g, "") : e.replace(/\\/g, "");
}
function s$(e) {
  var t = e.match(Cp), i, n;
  for (i = 0, n = t.length; i < n; i++)
    ts[t[i]] ? t[i] = ts[t[i]] : t[i] = a$(t[i]);
  return function(r) {
    var a = "", s;
    for (s = 0; s < n; s++)
      a += an(t[s]) ? t[s].call(r, e) : t[s];
    return a;
  };
}
function gu(e, t) {
  return e.isValid() ? (t = fS(t, e.localeData()), Ld[t] = Ld[t] || s$(t), Ld[t](e)) : e.localeData().invalidDate();
}
function fS(e, t) {
  var i = 5;
  function n(r) {
    return t.longDateFormat(r) || r;
  }
  for (tu.lastIndex = 0; i >= 0 && tu.test(e); )
    e = e.replace(
      tu,
      n
    ), tu.lastIndex = 0, i -= 1;
  return e;
}
var o$ = {
  LTS: "h:mm:ss A",
  LT: "h:mm A",
  L: "MM/DD/YYYY",
  LL: "MMMM D, YYYY",
  LLL: "MMMM D, YYYY h:mm A",
  LLLL: "dddd, MMMM D, YYYY h:mm A"
};
function l$(e) {
  var t = this._longDateFormat[e], i = this._longDateFormat[e.toUpperCase()];
  return t || !i ? t : (this._longDateFormat[e] = i.match(Cp).map(function(n) {
    return n === "MMMM" || n === "MM" || n === "DD" || n === "dddd" ? n.slice(1) : n;
  }).join(""), this._longDateFormat[e]);
}
var u$ = "Invalid date";
function c$() {
  return this._invalidDate;
}
var h$ = "%d", d$ = /\d{1,2}/;
function f$(e) {
  return this._ordinal.replace("%d", e);
}
var v$ = {
  future: "in %s",
  past: "%s ago",
  s: "a few seconds",
  ss: "%d seconds",
  m: "a minute",
  mm: "%d minutes",
  h: "an hour",
  hh: "%d hours",
  d: "a day",
  dd: "%d days",
  w: "a week",
  ww: "%d weeks",
  M: "a month",
  MM: "%d months",
  y: "a year",
  yy: "%d years"
};
function p$(e, t, i, n) {
  var r = this._relativeTime[i];
  return an(r) ? r(e, t, i, n) : r.replace(/%d/i, e);
}
function g$(e, t) {
  var i = this._relativeTime[e > 0 ? "future" : "past"];
  return an(i) ? i(t) : i.replace(/%s/i, t);
}
var $_ = {
  D: "date",
  dates: "date",
  date: "date",
  d: "day",
  days: "day",
  day: "day",
  e: "weekday",
  weekdays: "weekday",
  weekday: "weekday",
  E: "isoWeekday",
  isoweekdays: "isoWeekday",
  isoweekday: "isoWeekday",
  DDD: "dayOfYear",
  dayofyears: "dayOfYear",
  dayofyear: "dayOfYear",
  h: "hour",
  hours: "hour",
  hour: "hour",
  ms: "millisecond",
  milliseconds: "millisecond",
  millisecond: "millisecond",
  m: "minute",
  minutes: "minute",
  minute: "minute",
  M: "month",
  months: "month",
  month: "month",
  Q: "quarter",
  quarters: "quarter",
  quarter: "quarter",
  s: "second",
  seconds: "second",
  second: "second",
  gg: "weekYear",
  weekyears: "weekYear",
  weekyear: "weekYear",
  GG: "isoWeekYear",
  isoweekyears: "isoWeekYear",
  isoweekyear: "isoWeekYear",
  w: "week",
  weeks: "week",
  week: "week",
  W: "isoWeek",
  isoweeks: "isoWeek",
  isoweek: "isoWeek",
  y: "year",
  years: "year",
  year: "year"
};
function xi(e) {
  return typeof e == "string" ? $_[e] || $_[e.toLowerCase()] : void 0;
}
function Ep(e) {
  var t = {}, i, n;
  for (n in e)
    bt(e, n) && (i = xi(n), i && (t[i] = e[n]));
  return t;
}
var m$ = {
  date: 9,
  day: 11,
  weekday: 11,
  isoWeekday: 11,
  dayOfYear: 4,
  hour: 13,
  millisecond: 16,
  minute: 14,
  month: 8,
  quarter: 7,
  second: 15,
  weekYear: 1,
  isoWeekYear: 1,
  week: 5,
  isoWeek: 5,
  year: 1
};
function y$(e) {
  var t = [], i;
  for (i in e)
    bt(e, i) && t.push({ unit: i, priority: m$[i] });
  return t.sort(function(n, r) {
    return n.priority - r.priority;
  }), t;
}
var vS = /\d/, ii = /\d\d/, pS = /\d{3}/, Ap = /\d{4}/, Wc = /[+-]?\d{6}/, Wt = /\d\d?/, gS = /\d\d\d\d?/, mS = /\d\d\d\d\d\d?/, Uc = /\d{1,3}/, Pp = /\d{1,4}/, Gc = /[+-]?\d{1,6}/, ys = /\d+/, Xc = /[+-]?\d+/, _$ = /Z|[+-]\d\d:?\d\d/gi, jc = /Z|[+-]\d\d(?::?\d\d)?/gi, b$ = /[+-]?\d+(\.\d{1,3})?/, il = /[0-9]{0,256}['a-z\u00A0-\u05FF\u0700-\uD7FF\uF900-\uFDCF\uFDF0-\uFF07\uFF10-\uFFEF]{1,256}|[\u0600-\u06FF\/]{1,256}(\s*?[\u0600-\u06FF]{1,256}){1,2}/i, _s = /^[1-9]\d?/, Lp = /^([1-9]\d|\d)/, hc;
hc = {};
function U(e, t, i) {
  hc[e] = an(t) ? t : function(n, r) {
    return n && i ? i : t;
  };
}
function x$(e, t) {
  return bt(hc, e) ? hc[e](t._strict, t._locale) : new RegExp(w$(e));
}
function w$(e) {
  return kn(
    e.replace("\\", "").replace(
      /\\(\[)|\\(\])|\[([^\]\[]*)\]|\\(.)/g,
      function(t, i, n, r, a) {
        return i || n || r || a;
      }
    )
  );
}
function kn(e) {
  return e.replace(/[-\/\\^$*+?.()|[\]{}]/g, "\\$&");
}
function vi(e) {
  return e < 0 ? Math.ceil(e) || 0 : Math.floor(e);
}
function gt(e) {
  var t = +e, i = 0;
  return t !== 0 && isFinite(t) && (i = vi(t)), i;
}
var Zf = {};
function Ot(e, t) {
  var i, n = t, r;
  for (typeof e == "string" && (e = [e]), An(t) && (n = function(a, s) {
    s[t] = gt(a);
  }), r = e.length, i = 0; i < r; i++)
    Zf[e[i]] = n;
}
function nl(e, t) {
  Ot(e, function(i, n, r, a) {
    r._w = r._w || {}, t(i, r._w, r, a);
  });
}
function S$(e, t, i) {
  t != null && bt(Zf, e) && Zf[e](t, i._a, i, e);
}
function qc(e) {
  return e % 4 === 0 && e % 100 !== 0 || e % 400 === 0;
}
var Te = 0, xn = 1, Gi = 2, de = 3, Di = 4, wn = 5, jr = 6, M$ = 7, k$ = 8;
J("Y", 0, 0, function() {
  var e = this.year();
  return e <= 9999 ? en(e, 4) : "+" + e;
});
J(0, ["YY", 2], 0, function() {
  return this.year() % 100;
});
J(0, ["YYYY", 4], 0, "year");
J(0, ["YYYYY", 5], 0, "year");
J(0, ["YYYYYY", 6, !0], 0, "year");
U("Y", Xc);
U("YY", Wt, ii);
U("YYYY", Pp, Ap);
U("YYYYY", Gc, Wc);
U("YYYYYY", Gc, Wc);
Ot(["YYYYY", "YYYYYY"], Te);
Ot("YYYY", function(e, t) {
  t[Te] = e.length === 2 ? H.parseTwoDigitYear(e) : gt(e);
});
Ot("YY", function(e, t) {
  t[Te] = H.parseTwoDigitYear(e);
});
Ot("Y", function(e, t) {
  t[Te] = parseInt(e, 10);
});
function wo(e) {
  return qc(e) ? 366 : 365;
}
H.parseTwoDigitYear = function(e) {
  return gt(e) + (gt(e) > 68 ? 1900 : 2e3);
};
var yS = bs("FullYear", !0);
function D$() {
  return qc(this.year());
}
function bs(e, t) {
  return function(i) {
    return i != null ? (_S(this, e, i), H.updateOffset(this, t), this) : Wo(this, e);
  };
}
function Wo(e, t) {
  if (!e.isValid())
    return NaN;
  var i = e._d, n = e._isUTC;
  switch (t) {
    case "Milliseconds":
      return n ? i.getUTCMilliseconds() : i.getMilliseconds();
    case "Seconds":
      return n ? i.getUTCSeconds() : i.getSeconds();
    case "Minutes":
      return n ? i.getUTCMinutes() : i.getMinutes();
    case "Hours":
      return n ? i.getUTCHours() : i.getHours();
    case "Date":
      return n ? i.getUTCDate() : i.getDate();
    case "Day":
      return n ? i.getUTCDay() : i.getDay();
    case "Month":
      return n ? i.getUTCMonth() : i.getMonth();
    case "FullYear":
      return n ? i.getUTCFullYear() : i.getFullYear();
    default:
      return NaN;
  }
}
function _S(e, t, i) {
  var n, r, a, s, o;
  if (!(!e.isValid() || isNaN(i))) {
    switch (n = e._d, r = e._isUTC, t) {
      case "Milliseconds":
        return void (r ? n.setUTCMilliseconds(i) : n.setMilliseconds(i));
      case "Seconds":
        return void (r ? n.setUTCSeconds(i) : n.setSeconds(i));
      case "Minutes":
        return void (r ? n.setUTCMinutes(i) : n.setMinutes(i));
      case "Hours":
        return void (r ? n.setUTCHours(i) : n.setHours(i));
      case "Date":
        return void (r ? n.setUTCDate(i) : n.setDate(i));
      // case 'Day': // Not real
      //    return void (isUTC ? d.setUTCDay(value) : d.setDay(value));
      // case 'Month': // Not used because we need to pass two variables
      //     return void (isUTC ? d.setUTCMonth(value) : d.setMonth(value));
      case "FullYear":
        break;
      // See below ...
      default:
        return;
    }
    a = i, s = e.month(), o = e.date(), o = o === 29 && s === 1 && !qc(a) ? 28 : o, r ? n.setUTCFullYear(a, s, o) : n.setFullYear(a, s, o);
  }
}
function T$(e) {
  return e = xi(e), an(this[e]) ? this[e]() : this;
}
function C$(e, t) {
  if (typeof e == "object") {
    e = Ep(e);
    var i = y$(e), n, r = i.length;
    for (n = 0; n < r; n++)
      this[i[n].unit](e[i[n].unit]);
  } else if (e = xi(e), an(this[e]))
    return this[e](t);
  return this;
}
function E$(e, t) {
  return (e % t + t) % t;
}
var ee;
Array.prototype.indexOf ? ee = Array.prototype.indexOf : ee = function(e) {
  var t;
  for (t = 0; t < this.length; ++t)
    if (this[t] === e)
      return t;
  return -1;
};
function Op(e, t) {
  if (isNaN(e) || isNaN(t))
    return NaN;
  var i = E$(t, 12);
  return e += (t - i) / 12, i === 1 ? qc(e) ? 29 : 28 : 31 - i % 7 % 2;
}
J("M", ["MM", 2], "Mo", function() {
  return this.month() + 1;
});
J("MMM", 0, 0, function(e) {
  return this.localeData().monthsShort(this, e);
});
J("MMMM", 0, 0, function(e) {
  return this.localeData().months(this, e);
});
U("M", Wt, _s);
U("MM", Wt, ii);
U("MMM", function(e, t) {
  return t.monthsShortRegex(e);
});
U("MMMM", function(e, t) {
  return t.monthsRegex(e);
});
Ot(["M", "MM"], function(e, t) {
  t[xn] = gt(e) - 1;
});
Ot(["MMM", "MMMM"], function(e, t, i, n) {
  var r = i._locale.monthsParse(e, n, i._strict);
  r != null ? t[xn] = r : ut(i).invalidMonth = e;
});
var A$ = "January_February_March_April_May_June_July_August_September_October_November_December".split(
  "_"
), bS = "Jan_Feb_Mar_Apr_May_Jun_Jul_Aug_Sep_Oct_Nov_Dec".split("_"), xS = /D[oD]?(\[[^\[\]]*\]|\s)+MMMM?/, P$ = il, L$ = il;
function O$(e, t) {
  return e ? Ei(this._months) ? this._months[e.month()] : this._months[(this._months.isFormat || xS).test(t) ? "format" : "standalone"][e.month()] : Ei(this._months) ? this._months : this._months.standalone;
}
function I$(e, t) {
  return e ? Ei(this._monthsShort) ? this._monthsShort[e.month()] : this._monthsShort[xS.test(t) ? "format" : "standalone"][e.month()] : Ei(this._monthsShort) ? this._monthsShort : this._monthsShort.standalone;
}
function R$(e, t, i) {
  var n, r, a, s = e.toLocaleLowerCase();
  if (!this._monthsParse)
    for (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = [], n = 0; n < 12; ++n)
      a = rn([2e3, n]), this._shortMonthsParse[n] = this.monthsShort(
        a,
        ""
      ).toLocaleLowerCase(), this._longMonthsParse[n] = this.months(a, "").toLocaleLowerCase();
  return i ? t === "MMM" ? (r = ee.call(this._shortMonthsParse, s), r !== -1 ? r : null) : (r = ee.call(this._longMonthsParse, s), r !== -1 ? r : null) : t === "MMM" ? (r = ee.call(this._shortMonthsParse, s), r !== -1 ? r : (r = ee.call(this._longMonthsParse, s), r !== -1 ? r : null)) : (r = ee.call(this._longMonthsParse, s), r !== -1 ? r : (r = ee.call(this._shortMonthsParse, s), r !== -1 ? r : null));
}
function N$(e, t, i) {
  var n, r, a;
  if (this._monthsParseExact)
    return R$.call(this, e, t, i);
  for (this._monthsParse || (this._monthsParse = [], this._longMonthsParse = [], this._shortMonthsParse = []), n = 0; n < 12; n++) {
    if (r = rn([2e3, n]), i && !this._longMonthsParse[n] && (this._longMonthsParse[n] = new RegExp(
      "^" + this.months(r, "").replace(".", "") + "$",
      "i"
    ), this._shortMonthsParse[n] = new RegExp(
      "^" + this.monthsShort(r, "").replace(".", "") + "$",
      "i"
    )), !i && !this._monthsParse[n] && (a = "^" + this.months(r, "") + "|^" + this.monthsShort(r, ""), this._monthsParse[n] = new RegExp(a.replace(".", ""), "i")), i && t === "MMMM" && this._longMonthsParse[n].test(e))
      return n;
    if (i && t === "MMM" && this._shortMonthsParse[n].test(e))
      return n;
    if (!i && this._monthsParse[n].test(e))
      return n;
  }
}
function wS(e, t) {
  if (!e.isValid())
    return e;
  if (typeof t == "string") {
    if (/^\d+$/.test(t))
      t = gt(t);
    else if (t = e.localeData().monthsParse(t), !An(t))
      return e;
  }
  var i = t, n = e.date();
  return n = n < 29 ? n : Math.min(n, Op(e.year(), i)), e._isUTC ? e._d.setUTCMonth(i, n) : e._d.setMonth(i, n), e;
}
function SS(e) {
  return e != null ? (wS(this, e), H.updateOffset(this, !0), this) : Wo(this, "Month");
}
function F$() {
  return Op(this.year(), this.month());
}
function B$(e) {
  return this._monthsParseExact ? (bt(this, "_monthsRegex") || MS.call(this), e ? this._monthsShortStrictRegex : this._monthsShortRegex) : (bt(this, "_monthsShortRegex") || (this._monthsShortRegex = P$), this._monthsShortStrictRegex && e ? this._monthsShortStrictRegex : this._monthsShortRegex);
}
function $$(e) {
  return this._monthsParseExact ? (bt(this, "_monthsRegex") || MS.call(this), e ? this._monthsStrictRegex : this._monthsRegex) : (bt(this, "_monthsRegex") || (this._monthsRegex = L$), this._monthsStrictRegex && e ? this._monthsStrictRegex : this._monthsRegex);
}
function MS() {
  function e(l, u) {
    return u.length - l.length;
  }
  var t = [], i = [], n = [], r, a, s, o;
  for (r = 0; r < 12; r++)
    a = rn([2e3, r]), s = kn(this.monthsShort(a, "")), o = kn(this.months(a, "")), t.push(s), i.push(o), n.push(o), n.push(s);
  t.sort(e), i.sort(e), n.sort(e), this._monthsRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._monthsShortRegex = this._monthsRegex, this._monthsStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._monthsShortStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function z$(e, t, i, n, r, a, s) {
  var o;
  return e < 100 && e >= 0 ? (o = new Date(e + 400, t, i, n, r, a, s), isFinite(o.getFullYear()) && o.setFullYear(e)) : o = new Date(e, t, i, n, r, a, s), o;
}
function Uo(e) {
  var t, i;
  return e < 100 && e >= 0 ? (i = Array.prototype.slice.call(arguments), i[0] = e + 400, t = new Date(Date.UTC.apply(null, i)), isFinite(t.getUTCFullYear()) && t.setUTCFullYear(e)) : t = new Date(Date.UTC.apply(null, arguments)), t;
}
function dc(e, t, i) {
  var n = 7 + t - i, r = (7 + Uo(e, 0, n).getUTCDay() - t) % 7;
  return -r + n - 1;
}
function kS(e, t, i, n, r) {
  var a = (7 + i - n) % 7, s = dc(e, n, r), o = 1 + 7 * (t - 1) + a + s, l, u;
  return o <= 0 ? (l = e - 1, u = wo(l) + o) : o > wo(e) ? (l = e + 1, u = o - wo(e)) : (l = e, u = o), {
    year: l,
    dayOfYear: u
  };
}
function Go(e, t, i) {
  var n = dc(e.year(), t, i), r = Math.floor((e.dayOfYear() - n - 1) / 7) + 1, a, s;
  return r < 1 ? (s = e.year() - 1, a = r + Dn(s, t, i)) : r > Dn(e.year(), t, i) ? (a = r - Dn(e.year(), t, i), s = e.year() + 1) : (s = e.year(), a = r), {
    week: a,
    year: s
  };
}
function Dn(e, t, i) {
  var n = dc(e, t, i), r = dc(e + 1, t, i);
  return (wo(e) - n + r) / 7;
}
J("w", ["ww", 2], "wo", "week");
J("W", ["WW", 2], "Wo", "isoWeek");
U("w", Wt, _s);
U("ww", Wt, ii);
U("W", Wt, _s);
U("WW", Wt, ii);
nl(
  ["w", "ww", "W", "WW"],
  function(e, t, i, n) {
    t[n.substr(0, 1)] = gt(e);
  }
);
function V$(e) {
  return Go(e, this._week.dow, this._week.doy).week;
}
var H$ = {
  dow: 0,
  // Sunday is the first day of the week.
  doy: 6
  // The week that contains Jan 6th is the first week of the year.
};
function Y$() {
  return this._week.dow;
}
function W$() {
  return this._week.doy;
}
function U$(e) {
  var t = this.localeData().week(this);
  return e == null ? t : this.add((e - t) * 7, "d");
}
function G$(e) {
  var t = Go(this, 1, 4).week;
  return e == null ? t : this.add((e - t) * 7, "d");
}
J("d", 0, "do", "day");
J("dd", 0, 0, function(e) {
  return this.localeData().weekdaysMin(this, e);
});
J("ddd", 0, 0, function(e) {
  return this.localeData().weekdaysShort(this, e);
});
J("dddd", 0, 0, function(e) {
  return this.localeData().weekdays(this, e);
});
J("e", 0, 0, "weekday");
J("E", 0, 0, "isoWeekday");
U("d", Wt);
U("e", Wt);
U("E", Wt);
U("dd", function(e, t) {
  return t.weekdaysMinRegex(e);
});
U("ddd", function(e, t) {
  return t.weekdaysShortRegex(e);
});
U("dddd", function(e, t) {
  return t.weekdaysRegex(e);
});
nl(["dd", "ddd", "dddd"], function(e, t, i, n) {
  var r = i._locale.weekdaysParse(e, n, i._strict);
  r != null ? t.d = r : ut(i).invalidWeekday = e;
});
nl(["d", "e", "E"], function(e, t, i, n) {
  t[n] = gt(e);
});
function X$(e, t) {
  return typeof e != "string" ? e : isNaN(e) ? (e = t.weekdaysParse(e), typeof e == "number" ? e : null) : parseInt(e, 10);
}
function j$(e, t) {
  return typeof e == "string" ? t.weekdaysParse(e) % 7 || 7 : isNaN(e) ? null : e;
}
function Ip(e, t) {
  return e.slice(t, 7).concat(e.slice(0, t));
}
var q$ = "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), DS = "Sun_Mon_Tue_Wed_Thu_Fri_Sat".split("_"), Z$ = "Su_Mo_Tu_We_Th_Fr_Sa".split("_"), K$ = il, Q$ = il, J$ = il;
function tz(e, t) {
  var i = Ei(this._weekdays) ? this._weekdays : this._weekdays[e && e !== !0 && this._weekdays.isFormat.test(t) ? "format" : "standalone"];
  return e === !0 ? Ip(i, this._week.dow) : e ? i[e.day()] : i;
}
function ez(e) {
  return e === !0 ? Ip(this._weekdaysShort, this._week.dow) : e ? this._weekdaysShort[e.day()] : this._weekdaysShort;
}
function iz(e) {
  return e === !0 ? Ip(this._weekdaysMin, this._week.dow) : e ? this._weekdaysMin[e.day()] : this._weekdaysMin;
}
function nz(e, t, i) {
  var n, r, a, s = e.toLocaleLowerCase();
  if (!this._weekdaysParse)
    for (this._weekdaysParse = [], this._shortWeekdaysParse = [], this._minWeekdaysParse = [], n = 0; n < 7; ++n)
      a = rn([2e3, 1]).day(n), this._minWeekdaysParse[n] = this.weekdaysMin(
        a,
        ""
      ).toLocaleLowerCase(), this._shortWeekdaysParse[n] = this.weekdaysShort(
        a,
        ""
      ).toLocaleLowerCase(), this._weekdaysParse[n] = this.weekdays(a, "").toLocaleLowerCase();
  return i ? t === "dddd" ? (r = ee.call(this._weekdaysParse, s), r !== -1 ? r : null) : t === "ddd" ? (r = ee.call(this._shortWeekdaysParse, s), r !== -1 ? r : null) : (r = ee.call(this._minWeekdaysParse, s), r !== -1 ? r : null) : t === "dddd" ? (r = ee.call(this._weekdaysParse, s), r !== -1 || (r = ee.call(this._shortWeekdaysParse, s), r !== -1) ? r : (r = ee.call(this._minWeekdaysParse, s), r !== -1 ? r : null)) : t === "ddd" ? (r = ee.call(this._shortWeekdaysParse, s), r !== -1 || (r = ee.call(this._weekdaysParse, s), r !== -1) ? r : (r = ee.call(this._minWeekdaysParse, s), r !== -1 ? r : null)) : (r = ee.call(this._minWeekdaysParse, s), r !== -1 || (r = ee.call(this._weekdaysParse, s), r !== -1) ? r : (r = ee.call(this._shortWeekdaysParse, s), r !== -1 ? r : null));
}
function rz(e, t, i) {
  var n, r, a;
  if (this._weekdaysParseExact)
    return nz.call(this, e, t, i);
  for (this._weekdaysParse || (this._weekdaysParse = [], this._minWeekdaysParse = [], this._shortWeekdaysParse = [], this._fullWeekdaysParse = []), n = 0; n < 7; n++) {
    if (r = rn([2e3, 1]).day(n), i && !this._fullWeekdaysParse[n] && (this._fullWeekdaysParse[n] = new RegExp(
      "^" + this.weekdays(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._shortWeekdaysParse[n] = new RegExp(
      "^" + this.weekdaysShort(r, "").replace(".", "\\.?") + "$",
      "i"
    ), this._minWeekdaysParse[n] = new RegExp(
      "^" + this.weekdaysMin(r, "").replace(".", "\\.?") + "$",
      "i"
    )), this._weekdaysParse[n] || (a = "^" + this.weekdays(r, "") + "|^" + this.weekdaysShort(r, "") + "|^" + this.weekdaysMin(r, ""), this._weekdaysParse[n] = new RegExp(a.replace(".", ""), "i")), i && t === "dddd" && this._fullWeekdaysParse[n].test(e))
      return n;
    if (i && t === "ddd" && this._shortWeekdaysParse[n].test(e))
      return n;
    if (i && t === "dd" && this._minWeekdaysParse[n].test(e))
      return n;
    if (!i && this._weekdaysParse[n].test(e))
      return n;
  }
}
function az(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = Wo(this, "Day");
  return e != null ? (e = X$(e, this.localeData()), this.add(e - t, "d")) : t;
}
function sz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  var t = (this.day() + 7 - this.localeData()._week.dow) % 7;
  return e == null ? t : this.add(e - t, "d");
}
function oz(e) {
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    var t = j$(e, this.localeData());
    return this.day(this.day() % 7 ? t : t - 7);
  } else
    return this.day() || 7;
}
function lz(e) {
  return this._weekdaysParseExact ? (bt(this, "_weekdaysRegex") || Rp.call(this), e ? this._weekdaysStrictRegex : this._weekdaysRegex) : (bt(this, "_weekdaysRegex") || (this._weekdaysRegex = K$), this._weekdaysStrictRegex && e ? this._weekdaysStrictRegex : this._weekdaysRegex);
}
function uz(e) {
  return this._weekdaysParseExact ? (bt(this, "_weekdaysRegex") || Rp.call(this), e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex) : (bt(this, "_weekdaysShortRegex") || (this._weekdaysShortRegex = Q$), this._weekdaysShortStrictRegex && e ? this._weekdaysShortStrictRegex : this._weekdaysShortRegex);
}
function cz(e) {
  return this._weekdaysParseExact ? (bt(this, "_weekdaysRegex") || Rp.call(this), e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex) : (bt(this, "_weekdaysMinRegex") || (this._weekdaysMinRegex = J$), this._weekdaysMinStrictRegex && e ? this._weekdaysMinStrictRegex : this._weekdaysMinRegex);
}
function Rp() {
  function e(c, h) {
    return h.length - c.length;
  }
  var t = [], i = [], n = [], r = [], a, s, o, l, u;
  for (a = 0; a < 7; a++)
    s = rn([2e3, 1]).day(a), o = kn(this.weekdaysMin(s, "")), l = kn(this.weekdaysShort(s, "")), u = kn(this.weekdays(s, "")), t.push(o), i.push(l), n.push(u), r.push(o), r.push(l), r.push(u);
  t.sort(e), i.sort(e), n.sort(e), r.sort(e), this._weekdaysRegex = new RegExp("^(" + r.join("|") + ")", "i"), this._weekdaysShortRegex = this._weekdaysRegex, this._weekdaysMinRegex = this._weekdaysRegex, this._weekdaysStrictRegex = new RegExp(
    "^(" + n.join("|") + ")",
    "i"
  ), this._weekdaysShortStrictRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  ), this._weekdaysMinStrictRegex = new RegExp(
    "^(" + t.join("|") + ")",
    "i"
  );
}
function Np() {
  return this.hours() % 12 || 12;
}
function hz() {
  return this.hours() || 24;
}
J("H", ["HH", 2], 0, "hour");
J("h", ["hh", 2], 0, Np);
J("k", ["kk", 2], 0, hz);
J("hmm", 0, 0, function() {
  return "" + Np.apply(this) + en(this.minutes(), 2);
});
J("hmmss", 0, 0, function() {
  return "" + Np.apply(this) + en(this.minutes(), 2) + en(this.seconds(), 2);
});
J("Hmm", 0, 0, function() {
  return "" + this.hours() + en(this.minutes(), 2);
});
J("Hmmss", 0, 0, function() {
  return "" + this.hours() + en(this.minutes(), 2) + en(this.seconds(), 2);
});
function TS(e, t) {
  J(e, 0, 0, function() {
    return this.localeData().meridiem(
      this.hours(),
      this.minutes(),
      t
    );
  });
}
TS("a", !0);
TS("A", !1);
function CS(e, t) {
  return t._meridiemParse;
}
U("a", CS);
U("A", CS);
U("H", Wt, Lp);
U("h", Wt, _s);
U("k", Wt, _s);
U("HH", Wt, ii);
U("hh", Wt, ii);
U("kk", Wt, ii);
U("hmm", gS);
U("hmmss", mS);
U("Hmm", gS);
U("Hmmss", mS);
Ot(["H", "HH"], de);
Ot(["k", "kk"], function(e, t, i) {
  var n = gt(e);
  t[de] = n === 24 ? 0 : n;
});
Ot(["a", "A"], function(e, t, i) {
  i._isPm = i._locale.isPM(e), i._meridiem = e;
});
Ot(["h", "hh"], function(e, t, i) {
  t[de] = gt(e), ut(i).bigHour = !0;
});
Ot("hmm", function(e, t, i) {
  var n = e.length - 2;
  t[de] = gt(e.substr(0, n)), t[Di] = gt(e.substr(n)), ut(i).bigHour = !0;
});
Ot("hmmss", function(e, t, i) {
  var n = e.length - 4, r = e.length - 2;
  t[de] = gt(e.substr(0, n)), t[Di] = gt(e.substr(n, 2)), t[wn] = gt(e.substr(r)), ut(i).bigHour = !0;
});
Ot("Hmm", function(e, t, i) {
  var n = e.length - 2;
  t[de] = gt(e.substr(0, n)), t[Di] = gt(e.substr(n));
});
Ot("Hmmss", function(e, t, i) {
  var n = e.length - 4, r = e.length - 2;
  t[de] = gt(e.substr(0, n)), t[Di] = gt(e.substr(n, 2)), t[wn] = gt(e.substr(r));
});
function dz(e) {
  return (e + "").toLowerCase().charAt(0) === "p";
}
var fz = /[ap]\.?m?\.?/i, vz = bs("Hours", !0);
function pz(e, t, i) {
  return e > 11 ? i ? "pm" : "PM" : i ? "am" : "AM";
}
var ES = {
  calendar: n$,
  longDateFormat: o$,
  invalidDate: u$,
  ordinal: h$,
  dayOfMonthOrdinalParse: d$,
  relativeTime: v$,
  months: A$,
  monthsShort: bS,
  week: H$,
  weekdays: q$,
  weekdaysMin: Z$,
  weekdaysShort: DS,
  meridiemParse: fz
}, Ut = {}, Xs = {}, Xo;
function gz(e, t) {
  var i, n = Math.min(e.length, t.length);
  for (i = 0; i < n; i += 1)
    if (e[i] !== t[i])
      return i;
  return n;
}
function z_(e) {
  return e && e.toLowerCase().replace("_", "-");
}
function mz(e) {
  for (var t = 0, i, n, r, a; t < e.length; ) {
    for (a = z_(e[t]).split("-"), i = a.length, n = z_(e[t + 1]), n = n ? n.split("-") : null; i > 0; ) {
      if (r = Zc(a.slice(0, i).join("-")), r)
        return r;
      if (n && n.length >= i && gz(a, n) >= i - 1)
        break;
      i--;
    }
    t++;
  }
  return Xo;
}
function yz(e) {
  return !!(e && e.match("^[^/\\\\]*$"));
}
function Zc(e) {
  var t = null, i;
  if (Ut[e] === void 0 && typeof module < "u" && module && module.exports && yz(e))
    try {
      t = Xo._abbr, i = require, i("./locale/" + e), er(t);
    } catch {
      Ut[e] = null;
    }
  return Ut[e];
}
function er(e, t) {
  var i;
  return e && (ze(t) ? i = On(e) : i = Fp(e, t), i ? Xo = i : typeof console < "u" && console.warn && console.warn(
    "Locale " + e + " not found. Did you forget to load it?"
  )), Xo._abbr;
}
function Fp(e, t) {
  if (t !== null) {
    var i, n = ES;
    if (t.abbr = e, Ut[e] != null)
      dS(
        "defineLocaleOverride",
        "use moment.updateLocale(localeName, config) to change an existing locale. moment.defineLocale(localeName, config) should only be used for creating a new locale See http://momentjs.com/guides/#/warnings/define-locale/ for more info."
      ), n = Ut[e]._config;
    else if (t.parentLocale != null)
      if (Ut[t.parentLocale] != null)
        n = Ut[t.parentLocale]._config;
      else if (i = Zc(t.parentLocale), i != null)
        n = i._config;
      else
        return Xs[t.parentLocale] || (Xs[t.parentLocale] = []), Xs[t.parentLocale].push({
          name: e,
          config: t
        }), null;
    return Ut[e] = new Tp(jf(n, t)), Xs[e] && Xs[e].forEach(function(r) {
      Fp(r.name, r.config);
    }), er(e), Ut[e];
  } else
    return delete Ut[e], null;
}
function _z(e, t) {
  if (t != null) {
    var i, n, r = ES;
    Ut[e] != null && Ut[e].parentLocale != null ? Ut[e].set(jf(Ut[e]._config, t)) : (n = Zc(e), n != null && (r = n._config), t = jf(r, t), n == null && (t.abbr = e), i = new Tp(t), i.parentLocale = Ut[e], Ut[e] = i), er(e);
  } else
    Ut[e] != null && (Ut[e].parentLocale != null ? (Ut[e] = Ut[e].parentLocale, e === er() && er(e)) : Ut[e] != null && delete Ut[e]);
  return Ut[e];
}
function On(e) {
  var t;
  if (e && e._locale && e._locale._abbr && (e = e._locale._abbr), !e)
    return Xo;
  if (!Ei(e)) {
    if (t = Zc(e), t)
      return t;
    e = [e];
  }
  return mz(e);
}
function bz() {
  return qf(Ut);
}
function Bp(e) {
  var t, i = e._a;
  return i && ut(e).overflow === -2 && (t = i[xn] < 0 || i[xn] > 11 ? xn : i[Gi] < 1 || i[Gi] > Op(i[Te], i[xn]) ? Gi : i[de] < 0 || i[de] > 24 || i[de] === 24 && (i[Di] !== 0 || i[wn] !== 0 || i[jr] !== 0) ? de : i[Di] < 0 || i[Di] > 59 ? Di : i[wn] < 0 || i[wn] > 59 ? wn : i[jr] < 0 || i[jr] > 999 ? jr : -1, ut(e)._overflowDayOfYear && (t < Te || t > Gi) && (t = Gi), ut(e)._overflowWeeks && t === -1 && (t = M$), ut(e)._overflowWeekday && t === -1 && (t = k$), ut(e).overflow = t), e;
}
var xz = /^\s*((?:[+-]\d{6}|\d{4})-(?:\d\d-\d\d|W\d\d-\d|W\d\d|\d\d\d|\d\d))(?:(T| )(\d\d(?::\d\d(?::\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, wz = /^\s*((?:[+-]\d{6}|\d{4})(?:\d\d\d\d|W\d\d\d|W\d\d|\d\d\d|\d\d|))(?:(T| )(\d\d(?:\d\d(?:\d\d(?:[.,]\d+)?)?)?)([+-]\d\d(?::?\d\d)?|\s*Z)?)?$/, Sz = /Z|[+-]\d\d(?::?\d\d)?/, eu = [
  ["YYYYYY-MM-DD", /[+-]\d{6}-\d\d-\d\d/],
  ["YYYY-MM-DD", /\d{4}-\d\d-\d\d/],
  ["GGGG-[W]WW-E", /\d{4}-W\d\d-\d/],
  ["GGGG-[W]WW", /\d{4}-W\d\d/, !1],
  ["YYYY-DDD", /\d{4}-\d{3}/],
  ["YYYY-MM", /\d{4}-\d\d/, !1],
  ["YYYYYYMMDD", /[+-]\d{10}/],
  ["YYYYMMDD", /\d{8}/],
  ["GGGG[W]WWE", /\d{4}W\d{3}/],
  ["GGGG[W]WW", /\d{4}W\d{2}/, !1],
  ["YYYYDDD", /\d{7}/],
  ["YYYYMM", /\d{6}/, !1],
  ["YYYY", /\d{4}/, !1]
], Od = [
  ["HH:mm:ss.SSSS", /\d\d:\d\d:\d\d\.\d+/],
  ["HH:mm:ss,SSSS", /\d\d:\d\d:\d\d,\d+/],
  ["HH:mm:ss", /\d\d:\d\d:\d\d/],
  ["HH:mm", /\d\d:\d\d/],
  ["HHmmss.SSSS", /\d\d\d\d\d\d\.\d+/],
  ["HHmmss,SSSS", /\d\d\d\d\d\d,\d+/],
  ["HHmmss", /\d\d\d\d\d\d/],
  ["HHmm", /\d\d\d\d/],
  ["HH", /\d\d/]
], Mz = /^\/?Date\((-?\d+)/i, kz = /^(?:(Mon|Tue|Wed|Thu|Fri|Sat|Sun),?\s)?(\d{1,2})\s(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)\s(\d{2,4})\s(\d\d):(\d\d)(?::(\d\d))?\s(?:(UT|GMT|[ECMP][SD]T)|([Zz])|([+-]\d{4}))$/, Dz = {
  UT: 0,
  GMT: 0,
  EDT: -240,
  EST: -300,
  CDT: -300,
  CST: -360,
  MDT: -360,
  MST: -420,
  PDT: -420,
  PST: -480
};
function AS(e) {
  var t, i, n = e._i, r = xz.exec(n) || wz.exec(n), a, s, o, l, u = eu.length, c = Od.length;
  if (r) {
    for (ut(e).iso = !0, t = 0, i = u; t < i; t++)
      if (eu[t][1].exec(r[1])) {
        s = eu[t][0], a = eu[t][2] !== !1;
        break;
      }
    if (s == null) {
      e._isValid = !1;
      return;
    }
    if (r[3]) {
      for (t = 0, i = c; t < i; t++)
        if (Od[t][1].exec(r[3])) {
          o = (r[2] || " ") + Od[t][0];
          break;
        }
      if (o == null) {
        e._isValid = !1;
        return;
      }
    }
    if (!a && o != null) {
      e._isValid = !1;
      return;
    }
    if (r[4])
      if (Sz.exec(r[4]))
        l = "Z";
      else {
        e._isValid = !1;
        return;
      }
    e._f = s + (o || "") + (l || ""), zp(e);
  } else
    e._isValid = !1;
}
function Tz(e, t, i, n, r, a) {
  var s = [
    Cz(e),
    bS.indexOf(t),
    parseInt(i, 10),
    parseInt(n, 10),
    parseInt(r, 10)
  ];
  return a && s.push(parseInt(a, 10)), s;
}
function Cz(e) {
  var t = parseInt(e, 10);
  return t <= 49 ? 2e3 + t : t <= 999 ? 1900 + t : t;
}
function Ez(e) {
  return e.replace(/\([^()]*\)|[\n\t]/g, " ").replace(/(\s\s+)/g, " ").replace(/^\s\s*/, "").replace(/\s\s*$/, "");
}
function Az(e, t, i) {
  if (e) {
    var n = DS.indexOf(e), r = new Date(
      t[0],
      t[1],
      t[2]
    ).getDay();
    if (n !== r)
      return ut(i).weekdayMismatch = !0, i._isValid = !1, !1;
  }
  return !0;
}
function Pz(e, t, i) {
  if (e)
    return Dz[e];
  if (t)
    return 0;
  var n = parseInt(i, 10), r = n % 100, a = (n - r) / 100;
  return a * 60 + r;
}
function PS(e) {
  var t = kz.exec(Ez(e._i)), i;
  if (t) {
    if (i = Tz(
      t[4],
      t[3],
      t[2],
      t[5],
      t[6],
      t[7]
    ), !Az(t[1], i, e))
      return;
    e._a = i, e._tzm = Pz(t[8], t[9], t[10]), e._d = Uo.apply(null, e._a), e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), ut(e).rfc2822 = !0;
  } else
    e._isValid = !1;
}
function Lz(e) {
  var t = Mz.exec(e._i);
  if (t !== null) {
    e._d = /* @__PURE__ */ new Date(+t[1]);
    return;
  }
  if (AS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  if (PS(e), e._isValid === !1)
    delete e._isValid;
  else
    return;
  e._strict ? e._isValid = !1 : H.createFromInputFallback(e);
}
H.createFromInputFallback = bi(
  "value provided is not in a recognized RFC2822 or ISO format. moment construction falls back to js Date(), which is not reliable across all browsers and versions. Non RFC2822/ISO date formats are discouraged. Please refer to http://momentjs.com/guides/#/warnings/js-date/ for more info.",
  function(e) {
    e._d = /* @__PURE__ */ new Date(e._i + (e._useUTC ? " UTC" : ""));
  }
);
function za(e, t, i) {
  return e ?? t ?? i;
}
function Oz(e) {
  var t = new Date(H.now());
  return e._useUTC ? [
    t.getUTCFullYear(),
    t.getUTCMonth(),
    t.getUTCDate()
  ] : [t.getFullYear(), t.getMonth(), t.getDate()];
}
function $p(e) {
  var t, i, n = [], r, a, s;
  if (!e._d) {
    for (r = Oz(e), e._w && e._a[Gi] == null && e._a[xn] == null && Iz(e), e._dayOfYear != null && (s = za(e._a[Te], r[Te]), (e._dayOfYear > wo(s) || e._dayOfYear === 0) && (ut(e)._overflowDayOfYear = !0), i = Uo(s, 0, e._dayOfYear), e._a[xn] = i.getUTCMonth(), e._a[Gi] = i.getUTCDate()), t = 0; t < 3 && e._a[t] == null; ++t)
      e._a[t] = n[t] = r[t];
    for (; t < 7; t++)
      e._a[t] = n[t] = e._a[t] == null ? t === 2 ? 1 : 0 : e._a[t];
    e._a[de] === 24 && e._a[Di] === 0 && e._a[wn] === 0 && e._a[jr] === 0 && (e._nextDay = !0, e._a[de] = 0), e._d = (e._useUTC ? Uo : z$).apply(
      null,
      n
    ), a = e._useUTC ? e._d.getUTCDay() : e._d.getDay(), e._tzm != null && e._d.setUTCMinutes(e._d.getUTCMinutes() - e._tzm), e._nextDay && (e._a[de] = 24), e._w && typeof e._w.d < "u" && e._w.d !== a && (ut(e).weekdayMismatch = !0);
  }
}
function Iz(e) {
  var t, i, n, r, a, s, o, l, u;
  t = e._w, t.GG != null || t.W != null || t.E != null ? (a = 1, s = 4, i = za(
    t.GG,
    e._a[Te],
    Go(Yt(), 1, 4).year
  ), n = za(t.W, 1), r = za(t.E, 1), (r < 1 || r > 7) && (l = !0)) : (a = e._locale._week.dow, s = e._locale._week.doy, u = Go(Yt(), a, s), i = za(t.gg, e._a[Te], u.year), n = za(t.w, u.week), t.d != null ? (r = t.d, (r < 0 || r > 6) && (l = !0)) : t.e != null ? (r = t.e + a, (t.e < 0 || t.e > 6) && (l = !0)) : r = a), n < 1 || n > Dn(i, a, s) ? ut(e)._overflowWeeks = !0 : l != null ? ut(e)._overflowWeekday = !0 : (o = kS(i, n, r, a, s), e._a[Te] = o.year, e._dayOfYear = o.dayOfYear);
}
H.ISO_8601 = function() {
};
H.RFC_2822 = function() {
};
function zp(e) {
  if (e._f === H.ISO_8601) {
    AS(e);
    return;
  }
  if (e._f === H.RFC_2822) {
    PS(e);
    return;
  }
  e._a = [], ut(e).empty = !0;
  var t = "" + e._i, i, n, r, a, s, o = t.length, l = 0, u, c;
  for (r = fS(e._f, e._locale).match(Cp) || [], c = r.length, i = 0; i < c; i++)
    a = r[i], n = (t.match(x$(a, e)) || [])[0], n && (s = t.substr(0, t.indexOf(n)), s.length > 0 && ut(e).unusedInput.push(s), t = t.slice(
      t.indexOf(n) + n.length
    ), l += n.length), ts[a] ? (n ? ut(e).empty = !1 : ut(e).unusedTokens.push(a), S$(a, n, e)) : e._strict && !n && ut(e).unusedTokens.push(a);
  ut(e).charsLeftOver = o - l, t.length > 0 && ut(e).unusedInput.push(t), e._a[de] <= 12 && ut(e).bigHour === !0 && e._a[de] > 0 && (ut(e).bigHour = void 0), ut(e).parsedDateParts = e._a.slice(0), ut(e).meridiem = e._meridiem, e._a[de] = Rz(
    e._locale,
    e._a[de],
    e._meridiem
  ), u = ut(e).era, u !== null && (e._a[Te] = e._locale.erasConvertYear(u, e._a[Te])), $p(e), Bp(e);
}
function Rz(e, t, i) {
  var n;
  return i == null ? t : e.meridiemHour != null ? e.meridiemHour(t, i) : (e.isPM != null && (n = e.isPM(i), n && t < 12 && (t += 12), !n && t === 12 && (t = 0)), t);
}
function Nz(e) {
  var t, i, n, r, a, s, o = !1, l = e._f.length;
  if (l === 0) {
    ut(e).invalidFormat = !0, e._d = /* @__PURE__ */ new Date(NaN);
    return;
  }
  for (r = 0; r < l; r++)
    a = 0, s = !1, t = Dp({}, e), e._useUTC != null && (t._useUTC = e._useUTC), t._f = e._f[r], zp(t), kp(t) && (s = !0), a += ut(t).charsLeftOver, a += ut(t).unusedTokens.length * 10, ut(t).score = a, o ? a < n && (n = a, i = t) : (n == null || a < n || s) && (n = a, i = t, s && (o = !0));
  jn(e, i || t);
}
function Fz(e) {
  if (!e._d) {
    var t = Ep(e._i), i = t.day === void 0 ? t.date : t.day;
    e._a = cS(
      [t.year, t.month, i, t.hour, t.minute, t.second, t.millisecond],
      function(n) {
        return n && parseInt(n, 10);
      }
    ), $p(e);
  }
}
function Bz(e) {
  var t = new el(Bp(LS(e)));
  return t._nextDay && (t.add(1, "d"), t._nextDay = void 0), t;
}
function LS(e) {
  var t = e._i, i = e._f;
  return e._locale = e._locale || On(e._l), t === null || i === void 0 && t === "" ? Yc({ nullInput: !0 }) : (typeof t == "string" && (e._i = t = e._locale.preparse(t)), Ai(t) ? new el(Bp(t)) : (tl(t) ? e._d = t : Ei(i) ? Nz(e) : i ? zp(e) : $z(e), kp(e) || (e._d = null), e));
}
function $z(e) {
  var t = e._i;
  ze(t) ? e._d = new Date(H.now()) : tl(t) ? e._d = new Date(t.valueOf()) : typeof t == "string" ? Lz(e) : Ei(t) ? (e._a = cS(t.slice(0), function(i) {
    return parseInt(i, 10);
  }), $p(e)) : aa(t) ? Fz(e) : An(t) ? e._d = new Date(t) : H.createFromInputFallback(e);
}
function OS(e, t, i, n, r) {
  var a = {};
  return (t === !0 || t === !1) && (n = t, t = void 0), (i === !0 || i === !1) && (n = i, i = void 0), (aa(e) && Mp(e) || Ei(e) && e.length === 0) && (e = void 0), a._isAMomentObject = !0, a._useUTC = a._isUTC = r, a._l = i, a._i = e, a._f = t, a._strict = n, Bz(a);
}
function Yt(e, t, i, n) {
  return OS(e, t, i, n, !1);
}
var zz = bi(
  "moment().min is deprecated, use moment.max instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Yt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e < this ? this : e : Yc();
  }
), Vz = bi(
  "moment().max is deprecated, use moment.min instead. http://momentjs.com/guides/#/warnings/min-max/",
  function() {
    var e = Yt.apply(null, arguments);
    return this.isValid() && e.isValid() ? e > this ? this : e : Yc();
  }
);
function IS(e, t) {
  var i, n;
  if (t.length === 1 && Ei(t[0]) && (t = t[0]), !t.length)
    return Yt();
  for (i = t[0], n = 1; n < t.length; ++n)
    (!t[n].isValid() || t[n][e](i)) && (i = t[n]);
  return i;
}
function Hz() {
  var e = [].slice.call(arguments, 0);
  return IS("isBefore", e);
}
function Yz() {
  var e = [].slice.call(arguments, 0);
  return IS("isAfter", e);
}
var Wz = function() {
  return Date.now ? Date.now() : +/* @__PURE__ */ new Date();
}, js = [
  "year",
  "quarter",
  "month",
  "week",
  "day",
  "hour",
  "minute",
  "second",
  "millisecond"
];
function Uz(e) {
  var t, i = !1, n, r = js.length;
  for (t in e)
    if (bt(e, t) && !(ee.call(js, t) !== -1 && (e[t] == null || !isNaN(e[t]))))
      return !1;
  for (n = 0; n < r; ++n)
    if (e[js[n]]) {
      if (i)
        return !1;
      parseFloat(e[js[n]]) !== gt(e[js[n]]) && (i = !0);
    }
  return !0;
}
function Gz() {
  return this._isValid;
}
function Xz() {
  return Ri(NaN);
}
function Kc(e) {
  var t = Ep(e), i = t.year || 0, n = t.quarter || 0, r = t.month || 0, a = t.week || t.isoWeek || 0, s = t.day || 0, o = t.hour || 0, l = t.minute || 0, u = t.second || 0, c = t.millisecond || 0;
  this._isValid = Uz(t), this._milliseconds = +c + u * 1e3 + // 1000
  l * 6e4 + // 1000 * 60
  o * 1e3 * 60 * 60, this._days = +s + a * 7, this._months = +r + n * 3 + i * 12, this._data = {}, this._locale = On(), this._bubble();
}
function mu(e) {
  return e instanceof Kc;
}
function Kf(e) {
  return e < 0 ? Math.round(-1 * e) * -1 : Math.round(e);
}
function jz(e, t, i) {
  var n = Math.min(e.length, t.length), r = Math.abs(e.length - t.length), a = 0, s;
  for (s = 0; s < n; s++)
    gt(e[s]) !== gt(t[s]) && a++;
  return a + r;
}
function RS(e, t) {
  J(e, 0, 0, function() {
    var i = this.utcOffset(), n = "+";
    return i < 0 && (i = -i, n = "-"), n + en(~~(i / 60), 2) + t + en(~~i % 60, 2);
  });
}
RS("Z", ":");
RS("ZZ", "");
U("Z", jc);
U("ZZ", jc);
Ot(["Z", "ZZ"], function(e, t, i) {
  i._useUTC = !0, i._tzm = Vp(jc, e);
});
var qz = /([\+\-]|\d\d)/gi;
function Vp(e, t) {
  var i = (t || "").match(e), n, r, a;
  return i === null ? null : (n = i[i.length - 1] || [], r = (n + "").match(qz) || ["-", 0, 0], a = +(r[1] * 60) + gt(r[2]), a === 0 ? 0 : r[0] === "+" ? a : -a);
}
function Hp(e, t) {
  var i, n;
  return t._isUTC ? (i = t.clone(), n = (Ai(e) || tl(e) ? e.valueOf() : Yt(e).valueOf()) - i.valueOf(), i._d.setTime(i._d.valueOf() + n), H.updateOffset(i, !1), i) : Yt(e).local();
}
function Qf(e) {
  return -Math.round(e._d.getTimezoneOffset());
}
H.updateOffset = function() {
};
function Zz(e, t, i) {
  var n = this._offset || 0, r;
  if (!this.isValid())
    return e != null ? this : NaN;
  if (e != null) {
    if (typeof e == "string") {
      if (e = Vp(jc, e), e === null)
        return this;
    } else Math.abs(e) < 16 && !i && (e = e * 60);
    return !this._isUTC && t && (r = Qf(this)), this._offset = e, this._isUTC = !0, r != null && this.add(r, "m"), n !== e && (!t || this._changeInProgress ? BS(
      this,
      Ri(e - n, "m"),
      1,
      !1
    ) : this._changeInProgress || (this._changeInProgress = !0, H.updateOffset(this, !0), this._changeInProgress = null)), this;
  } else
    return this._isUTC ? n : Qf(this);
}
function Kz(e, t) {
  return e != null ? (typeof e != "string" && (e = -e), this.utcOffset(e, t), this) : -this.utcOffset();
}
function Qz(e) {
  return this.utcOffset(0, e);
}
function Jz(e) {
  return this._isUTC && (this.utcOffset(0, e), this._isUTC = !1, e && this.subtract(Qf(this), "m")), this;
}
function tV() {
  if (this._tzm != null)
    this.utcOffset(this._tzm, !1, !0);
  else if (typeof this._i == "string") {
    var e = Vp(_$, this._i);
    e != null ? this.utcOffset(e) : this.utcOffset(0, !0);
  }
  return this;
}
function eV(e) {
  return this.isValid() ? (e = e ? Yt(e).utcOffset() : 0, (this.utcOffset() - e) % 60 === 0) : !1;
}
function iV() {
  return this.utcOffset() > this.clone().month(0).utcOffset() || this.utcOffset() > this.clone().month(5).utcOffset();
}
function nV() {
  if (!ze(this._isDSTShifted))
    return this._isDSTShifted;
  var e = {}, t;
  return Dp(e, this), e = LS(e), e._a ? (t = e._isUTC ? rn(e._a) : Yt(e._a), this._isDSTShifted = this.isValid() && jz(e._a, t.toArray()) > 0) : this._isDSTShifted = !1, this._isDSTShifted;
}
function rV() {
  return this.isValid() ? !this._isUTC : !1;
}
function aV() {
  return this.isValid() ? this._isUTC : !1;
}
function NS() {
  return this.isValid() ? this._isUTC && this._offset === 0 : !1;
}
var sV = /^(-|\+)?(?:(\d*)[. ])?(\d+):(\d+)(?::(\d+)(\.\d*)?)?$/, oV = /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
function Ri(e, t) {
  var i = e, n = null, r, a, s;
  return mu(e) ? i = {
    ms: e._milliseconds,
    d: e._days,
    M: e._months
  } : An(e) || !isNaN(+e) ? (i = {}, t ? i[t] = +e : i.milliseconds = +e) : (n = sV.exec(e)) ? (r = n[1] === "-" ? -1 : 1, i = {
    y: 0,
    d: gt(n[Gi]) * r,
    h: gt(n[de]) * r,
    m: gt(n[Di]) * r,
    s: gt(n[wn]) * r,
    ms: gt(Kf(n[jr] * 1e3)) * r
    // the millisecond decimal point is included in the match
  }) : (n = oV.exec(e)) ? (r = n[1] === "-" ? -1 : 1, i = {
    y: Nr(n[2], r),
    M: Nr(n[3], r),
    w: Nr(n[4], r),
    d: Nr(n[5], r),
    h: Nr(n[6], r),
    m: Nr(n[7], r),
    s: Nr(n[8], r)
  }) : i == null ? i = {} : typeof i == "object" && ("from" in i || "to" in i) && (s = lV(
    Yt(i.from),
    Yt(i.to)
  ), i = {}, i.ms = s.milliseconds, i.M = s.months), a = new Kc(i), mu(e) && bt(e, "_locale") && (a._locale = e._locale), mu(e) && bt(e, "_isValid") && (a._isValid = e._isValid), a;
}
Ri.fn = Kc.prototype;
Ri.invalid = Xz;
function Nr(e, t) {
  var i = e && parseFloat(e.replace(",", "."));
  return (isNaN(i) ? 0 : i) * t;
}
function V_(e, t) {
  var i = {};
  return i.months = t.month() - e.month() + (t.year() - e.year()) * 12, e.clone().add(i.months, "M").isAfter(t) && --i.months, i.milliseconds = +t - +e.clone().add(i.months, "M"), i;
}
function lV(e, t) {
  var i;
  return e.isValid() && t.isValid() ? (t = Hp(t, e), e.isBefore(t) ? i = V_(e, t) : (i = V_(t, e), i.milliseconds = -i.milliseconds, i.months = -i.months), i) : { milliseconds: 0, months: 0 };
}
function FS(e, t) {
  return function(i, n) {
    var r, a;
    return n !== null && !isNaN(+n) && (dS(
      t,
      "moment()." + t + "(period, number) is deprecated. Please use moment()." + t + "(number, period). See http://momentjs.com/guides/#/warnings/add-inverted-param/ for more info."
    ), a = i, i = n, n = a), r = Ri(i, n), BS(this, r, e), this;
  };
}
function BS(e, t, i, n) {
  var r = t._milliseconds, a = Kf(t._days), s = Kf(t._months);
  e.isValid() && (n = n ?? !0, s && wS(e, Wo(e, "Month") + s * i), a && _S(e, "Date", Wo(e, "Date") + a * i), r && e._d.setTime(e._d.valueOf() + r * i), n && H.updateOffset(e, a || s));
}
var uV = FS(1, "add"), cV = FS(-1, "subtract");
function $S(e) {
  return typeof e == "string" || e instanceof String;
}
function hV(e) {
  return Ai(e) || tl(e) || $S(e) || An(e) || fV(e) || dV(e) || e === null || e === void 0;
}
function dV(e) {
  var t = aa(e) && !Mp(e), i = !1, n = [
    "years",
    "year",
    "y",
    "months",
    "month",
    "M",
    "days",
    "day",
    "d",
    "dates",
    "date",
    "D",
    "hours",
    "hour",
    "h",
    "minutes",
    "minute",
    "m",
    "seconds",
    "second",
    "s",
    "milliseconds",
    "millisecond",
    "ms"
  ], r, a, s = n.length;
  for (r = 0; r < s; r += 1)
    a = n[r], i = i || bt(e, a);
  return t && i;
}
function fV(e) {
  var t = Ei(e), i = !1;
  return t && (i = e.filter(function(n) {
    return !An(n) && $S(e);
  }).length === 0), t && i;
}
function vV(e) {
  var t = aa(e) && !Mp(e), i = !1, n = [
    "sameDay",
    "nextDay",
    "lastDay",
    "nextWeek",
    "lastWeek",
    "sameElse"
  ], r, a;
  for (r = 0; r < n.length; r += 1)
    a = n[r], i = i || bt(e, a);
  return t && i;
}
function pV(e, t) {
  var i = e.diff(t, "days", !0);
  return i < -6 ? "sameElse" : i < -1 ? "lastWeek" : i < 0 ? "lastDay" : i < 1 ? "sameDay" : i < 2 ? "nextDay" : i < 7 ? "nextWeek" : "sameElse";
}
function gV(e, t) {
  arguments.length === 1 && (arguments[0] ? hV(arguments[0]) ? (e = arguments[0], t = void 0) : vV(arguments[0]) && (t = arguments[0], e = void 0) : (e = void 0, t = void 0));
  var i = e || Yt(), n = Hp(i, this).startOf("day"), r = H.calendarFormat(this, n) || "sameElse", a = t && (an(t[r]) ? t[r].call(this, i) : t[r]);
  return this.format(
    a || this.localeData().calendar(r, this, Yt(i))
  );
}
function mV() {
  return new el(this);
}
function yV(e, t) {
  var i = Ai(e) ? e : Yt(e);
  return this.isValid() && i.isValid() ? (t = xi(t) || "millisecond", t === "millisecond" ? this.valueOf() > i.valueOf() : i.valueOf() < this.clone().startOf(t).valueOf()) : !1;
}
function _V(e, t) {
  var i = Ai(e) ? e : Yt(e);
  return this.isValid() && i.isValid() ? (t = xi(t) || "millisecond", t === "millisecond" ? this.valueOf() < i.valueOf() : this.clone().endOf(t).valueOf() < i.valueOf()) : !1;
}
function bV(e, t, i, n) {
  var r = Ai(e) ? e : Yt(e), a = Ai(t) ? t : Yt(t);
  return this.isValid() && r.isValid() && a.isValid() ? (n = n || "()", (n[0] === "(" ? this.isAfter(r, i) : !this.isBefore(r, i)) && (n[1] === ")" ? this.isBefore(a, i) : !this.isAfter(a, i))) : !1;
}
function xV(e, t) {
  var i = Ai(e) ? e : Yt(e), n;
  return this.isValid() && i.isValid() ? (t = xi(t) || "millisecond", t === "millisecond" ? this.valueOf() === i.valueOf() : (n = i.valueOf(), this.clone().startOf(t).valueOf() <= n && n <= this.clone().endOf(t).valueOf())) : !1;
}
function wV(e, t) {
  return this.isSame(e, t) || this.isAfter(e, t);
}
function SV(e, t) {
  return this.isSame(e, t) || this.isBefore(e, t);
}
function MV(e, t, i) {
  var n, r, a;
  if (!this.isValid())
    return NaN;
  if (n = Hp(e, this), !n.isValid())
    return NaN;
  switch (r = (n.utcOffset() - this.utcOffset()) * 6e4, t = xi(t), t) {
    case "year":
      a = yu(this, n) / 12;
      break;
    case "month":
      a = yu(this, n);
      break;
    case "quarter":
      a = yu(this, n) / 3;
      break;
    case "second":
      a = (this - n) / 1e3;
      break;
    // 1000
    case "minute":
      a = (this - n) / 6e4;
      break;
    // 1000 * 60
    case "hour":
      a = (this - n) / 36e5;
      break;
    // 1000 * 60 * 60
    case "day":
      a = (this - n - r) / 864e5;
      break;
    // 1000 * 60 * 60 * 24, negate dst
    case "week":
      a = (this - n - r) / 6048e5;
      break;
    // 1000 * 60 * 60 * 24 * 7, negate dst
    default:
      a = this - n;
  }
  return i ? a : vi(a);
}
function yu(e, t) {
  if (e.date() < t.date())
    return -yu(t, e);
  var i = (t.year() - e.year()) * 12 + (t.month() - e.month()), n = e.clone().add(i, "months"), r, a;
  return t - n < 0 ? (r = e.clone().add(i - 1, "months"), a = (t - n) / (n - r)) : (r = e.clone().add(i + 1, "months"), a = (t - n) / (r - n)), -(i + a) || 0;
}
H.defaultFormat = "YYYY-MM-DDTHH:mm:ssZ";
H.defaultFormatUtc = "YYYY-MM-DDTHH:mm:ss[Z]";
function kV() {
  return this.clone().locale("en").format("ddd MMM DD YYYY HH:mm:ss [GMT]ZZ");
}
function DV(e) {
  if (!this.isValid())
    return null;
  var t = e !== !0, i = t ? this.clone().utc() : this;
  return i.year() < 0 || i.year() > 9999 ? gu(
    i,
    t ? "YYYYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYYYY-MM-DD[T]HH:mm:ss.SSSZ"
  ) : an(Date.prototype.toISOString) ? t ? this.toDate().toISOString() : new Date(this.valueOf() + this.utcOffset() * 60 * 1e3).toISOString().replace("Z", gu(i, "Z")) : gu(
    i,
    t ? "YYYY-MM-DD[T]HH:mm:ss.SSS[Z]" : "YYYY-MM-DD[T]HH:mm:ss.SSSZ"
  );
}
function TV() {
  if (!this.isValid())
    return "moment.invalid(/* " + this._i + " */)";
  var e = "moment", t = "", i, n, r, a;
  return this.isLocal() || (e = this.utcOffset() === 0 ? "moment.utc" : "moment.parseZone", t = "Z"), i = "[" + e + '("]', n = 0 <= this.year() && this.year() <= 9999 ? "YYYY" : "YYYYYY", r = "-MM-DD[T]HH:mm:ss.SSS", a = t + '[")]', this.format(i + n + r + a);
}
function CV(e) {
  e || (e = this.isUtc() ? H.defaultFormatUtc : H.defaultFormat);
  var t = gu(this, e);
  return this.localeData().postformat(t);
}
function EV(e, t) {
  return this.isValid() && (Ai(e) && e.isValid() || Yt(e).isValid()) ? Ri({ to: this, from: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function AV(e) {
  return this.from(Yt(), e);
}
function PV(e, t) {
  return this.isValid() && (Ai(e) && e.isValid() || Yt(e).isValid()) ? Ri({ from: this, to: e }).locale(this.locale()).humanize(!t) : this.localeData().invalidDate();
}
function LV(e) {
  return this.to(Yt(), e);
}
function zS(e) {
  var t;
  return e === void 0 ? this._locale._abbr : (t = On(e), t != null && (this._locale = t), this);
}
var VS = bi(
  "moment().lang() is deprecated. Instead, use moment().localeData() to get the language configuration. Use moment().locale() to change languages.",
  function(e) {
    return e === void 0 ? this.localeData() : this.locale(e);
  }
);
function HS() {
  return this._locale;
}
var fc = 1e3, es = 60 * fc, vc = 60 * es, YS = (365 * 400 + 97) * 24 * vc;
function is(e, t) {
  return (e % t + t) % t;
}
function WS(e, t, i) {
  return e < 100 && e >= 0 ? new Date(e + 400, t, i) - YS : new Date(e, t, i).valueOf();
}
function US(e, t, i) {
  return e < 100 && e >= 0 ? Date.UTC(e + 400, t, i) - YS : Date.UTC(e, t, i);
}
function OV(e) {
  var t, i;
  if (e = xi(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (i = this._isUTC ? US : WS, e) {
    case "year":
      t = i(this.year(), 0, 1);
      break;
    case "quarter":
      t = i(
        this.year(),
        this.month() - this.month() % 3,
        1
      );
      break;
    case "month":
      t = i(this.year(), this.month(), 1);
      break;
    case "week":
      t = i(
        this.year(),
        this.month(),
        this.date() - this.weekday()
      );
      break;
    case "isoWeek":
      t = i(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1)
      );
      break;
    case "day":
    case "date":
      t = i(this.year(), this.month(), this.date());
      break;
    case "hour":
      t = this._d.valueOf(), t -= is(
        t + (this._isUTC ? 0 : this.utcOffset() * es),
        vc
      );
      break;
    case "minute":
      t = this._d.valueOf(), t -= is(t, es);
      break;
    case "second":
      t = this._d.valueOf(), t -= is(t, fc);
      break;
  }
  return this._d.setTime(t), H.updateOffset(this, !0), this;
}
function IV(e) {
  var t, i;
  if (e = xi(e), e === void 0 || e === "millisecond" || !this.isValid())
    return this;
  switch (i = this._isUTC ? US : WS, e) {
    case "year":
      t = i(this.year() + 1, 0, 1) - 1;
      break;
    case "quarter":
      t = i(
        this.year(),
        this.month() - this.month() % 3 + 3,
        1
      ) - 1;
      break;
    case "month":
      t = i(this.year(), this.month() + 1, 1) - 1;
      break;
    case "week":
      t = i(
        this.year(),
        this.month(),
        this.date() - this.weekday() + 7
      ) - 1;
      break;
    case "isoWeek":
      t = i(
        this.year(),
        this.month(),
        this.date() - (this.isoWeekday() - 1) + 7
      ) - 1;
      break;
    case "day":
    case "date":
      t = i(this.year(), this.month(), this.date() + 1) - 1;
      break;
    case "hour":
      t = this._d.valueOf(), t += vc - is(
        t + (this._isUTC ? 0 : this.utcOffset() * es),
        vc
      ) - 1;
      break;
    case "minute":
      t = this._d.valueOf(), t += es - is(t, es) - 1;
      break;
    case "second":
      t = this._d.valueOf(), t += fc - is(t, fc) - 1;
      break;
  }
  return this._d.setTime(t), H.updateOffset(this, !0), this;
}
function RV() {
  return this._d.valueOf() - (this._offset || 0) * 6e4;
}
function NV() {
  return Math.floor(this.valueOf() / 1e3);
}
function FV() {
  return new Date(this.valueOf());
}
function BV() {
  var e = this;
  return [
    e.year(),
    e.month(),
    e.date(),
    e.hour(),
    e.minute(),
    e.second(),
    e.millisecond()
  ];
}
function $V() {
  var e = this;
  return {
    years: e.year(),
    months: e.month(),
    date: e.date(),
    hours: e.hours(),
    minutes: e.minutes(),
    seconds: e.seconds(),
    milliseconds: e.milliseconds()
  };
}
function zV() {
  return this.isValid() ? this.toISOString() : null;
}
function VV() {
  return kp(this);
}
function HV() {
  return jn({}, ut(this));
}
function YV() {
  return ut(this).overflow;
}
function WV() {
  return {
    input: this._i,
    format: this._f,
    locale: this._locale,
    isUTC: this._isUTC,
    strict: this._strict
  };
}
J("N", 0, 0, "eraAbbr");
J("NN", 0, 0, "eraAbbr");
J("NNN", 0, 0, "eraAbbr");
J("NNNN", 0, 0, "eraName");
J("NNNNN", 0, 0, "eraNarrow");
J("y", ["y", 1], "yo", "eraYear");
J("y", ["yy", 2], 0, "eraYear");
J("y", ["yyy", 3], 0, "eraYear");
J("y", ["yyyy", 4], 0, "eraYear");
U("N", Yp);
U("NN", Yp);
U("NNN", Yp);
U("NNNN", eH);
U("NNNNN", iH);
Ot(
  ["N", "NN", "NNN", "NNNN", "NNNNN"],
  function(e, t, i, n) {
    var r = i._locale.erasParse(e, n, i._strict);
    r ? ut(i).era = r : ut(i).invalidEra = e;
  }
);
U("y", ys);
U("yy", ys);
U("yyy", ys);
U("yyyy", ys);
U("yo", nH);
Ot(["y", "yy", "yyy", "yyyy"], Te);
Ot(["yo"], function(e, t, i, n) {
  var r;
  i._locale._eraYearOrdinalRegex && (r = e.match(i._locale._eraYearOrdinalRegex)), i._locale.eraYearOrdinalParse ? t[Te] = i._locale.eraYearOrdinalParse(e, r) : t[Te] = parseInt(e, 10);
});
function UV(e, t) {
  var i, n, r, a = this._eras || On("en")._eras;
  for (i = 0, n = a.length; i < n; ++i) {
    switch (typeof a[i].since) {
      case "string":
        r = H(a[i].since).startOf("day"), a[i].since = r.valueOf();
        break;
    }
    switch (typeof a[i].until) {
      case "undefined":
        a[i].until = 1 / 0;
        break;
      case "string":
        r = H(a[i].until).startOf("day").valueOf(), a[i].until = r.valueOf();
        break;
    }
  }
  return a;
}
function GV(e, t, i) {
  var n, r, a = this.eras(), s, o, l;
  for (e = e.toUpperCase(), n = 0, r = a.length; n < r; ++n)
    if (s = a[n].name.toUpperCase(), o = a[n].abbr.toUpperCase(), l = a[n].narrow.toUpperCase(), i)
      switch (t) {
        case "N":
        case "NN":
        case "NNN":
          if (o === e)
            return a[n];
          break;
        case "NNNN":
          if (s === e)
            return a[n];
          break;
        case "NNNNN":
          if (l === e)
            return a[n];
          break;
      }
    else if ([s, o, l].indexOf(e) >= 0)
      return a[n];
}
function XV(e, t) {
  var i = e.since <= e.until ? 1 : -1;
  return t === void 0 ? H(e.since).year() : H(e.since).year() + (t - e.offset) * i;
}
function jV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].name;
  return "";
}
function qV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].narrow;
  return "";
}
function ZV() {
  var e, t, i, n = this.localeData().eras();
  for (e = 0, t = n.length; e < t; ++e)
    if (i = this.clone().startOf("day").valueOf(), n[e].since <= i && i <= n[e].until || n[e].until <= i && i <= n[e].since)
      return n[e].abbr;
  return "";
}
function KV() {
  var e, t, i, n, r = this.localeData().eras();
  for (e = 0, t = r.length; e < t; ++e)
    if (i = r[e].since <= r[e].until ? 1 : -1, n = this.clone().startOf("day").valueOf(), r[e].since <= n && n <= r[e].until || r[e].until <= n && n <= r[e].since)
      return (this.year() - H(r[e].since).year()) * i + r[e].offset;
  return this.year();
}
function QV(e) {
  return bt(this, "_erasNameRegex") || Wp.call(this), e ? this._erasNameRegex : this._erasRegex;
}
function JV(e) {
  return bt(this, "_erasAbbrRegex") || Wp.call(this), e ? this._erasAbbrRegex : this._erasRegex;
}
function tH(e) {
  return bt(this, "_erasNarrowRegex") || Wp.call(this), e ? this._erasNarrowRegex : this._erasRegex;
}
function Yp(e, t) {
  return t.erasAbbrRegex(e);
}
function eH(e, t) {
  return t.erasNameRegex(e);
}
function iH(e, t) {
  return t.erasNarrowRegex(e);
}
function nH(e, t) {
  return t._eraYearOrdinalRegex || ys;
}
function Wp() {
  var e = [], t = [], i = [], n = [], r, a, s, o, l, u = this.eras();
  for (r = 0, a = u.length; r < a; ++r)
    s = kn(u[r].name), o = kn(u[r].abbr), l = kn(u[r].narrow), t.push(s), e.push(o), i.push(l), n.push(s), n.push(o), n.push(l);
  this._erasRegex = new RegExp("^(" + n.join("|") + ")", "i"), this._erasNameRegex = new RegExp("^(" + t.join("|") + ")", "i"), this._erasAbbrRegex = new RegExp("^(" + e.join("|") + ")", "i"), this._erasNarrowRegex = new RegExp(
    "^(" + i.join("|") + ")",
    "i"
  );
}
J(0, ["gg", 2], 0, function() {
  return this.weekYear() % 100;
});
J(0, ["GG", 2], 0, function() {
  return this.isoWeekYear() % 100;
});
function Qc(e, t) {
  J(0, [e, e.length], 0, t);
}
Qc("gggg", "weekYear");
Qc("ggggg", "weekYear");
Qc("GGGG", "isoWeekYear");
Qc("GGGGG", "isoWeekYear");
U("G", Xc);
U("g", Xc);
U("GG", Wt, ii);
U("gg", Wt, ii);
U("GGGG", Pp, Ap);
U("gggg", Pp, Ap);
U("GGGGG", Gc, Wc);
U("ggggg", Gc, Wc);
nl(
  ["gggg", "ggggg", "GGGG", "GGGGG"],
  function(e, t, i, n) {
    t[n.substr(0, 2)] = gt(e);
  }
);
nl(["gg", "GG"], function(e, t, i, n) {
  t[n] = H.parseTwoDigitYear(e);
});
function rH(e) {
  return GS.call(
    this,
    e,
    this.week(),
    this.weekday() + this.localeData()._week.dow,
    this.localeData()._week.dow,
    this.localeData()._week.doy
  );
}
function aH(e) {
  return GS.call(
    this,
    e,
    this.isoWeek(),
    this.isoWeekday(),
    1,
    4
  );
}
function sH() {
  return Dn(this.year(), 1, 4);
}
function oH() {
  return Dn(this.isoWeekYear(), 1, 4);
}
function lH() {
  var e = this.localeData()._week;
  return Dn(this.year(), e.dow, e.doy);
}
function uH() {
  var e = this.localeData()._week;
  return Dn(this.weekYear(), e.dow, e.doy);
}
function GS(e, t, i, n, r) {
  var a;
  return e == null ? Go(this, n, r).year : (a = Dn(e, n, r), t > a && (t = a), cH.call(this, e, t, i, n, r));
}
function cH(e, t, i, n, r) {
  var a = kS(e, t, i, n, r), s = Uo(a.year, 0, a.dayOfYear);
  return this.year(s.getUTCFullYear()), this.month(s.getUTCMonth()), this.date(s.getUTCDate()), this;
}
J("Q", 0, "Qo", "quarter");
U("Q", vS);
Ot("Q", function(e, t) {
  t[xn] = (gt(e) - 1) * 3;
});
function hH(e) {
  return e == null ? Math.ceil((this.month() + 1) / 3) : this.month((e - 1) * 3 + this.month() % 3);
}
J("D", ["DD", 2], "Do", "date");
U("D", Wt, _s);
U("DD", Wt, ii);
U("Do", function(e, t) {
  return e ? t._dayOfMonthOrdinalParse || t._ordinalParse : t._dayOfMonthOrdinalParseLenient;
});
Ot(["D", "DD"], Gi);
Ot("Do", function(e, t) {
  t[Gi] = gt(e.match(Wt)[0]);
});
var XS = bs("Date", !0);
J("DDD", ["DDDD", 3], "DDDo", "dayOfYear");
U("DDD", Uc);
U("DDDD", pS);
Ot(["DDD", "DDDD"], function(e, t, i) {
  i._dayOfYear = gt(e);
});
function dH(e) {
  var t = Math.round(
    (this.clone().startOf("day") - this.clone().startOf("year")) / 864e5
  ) + 1;
  return e == null ? t : this.add(e - t, "d");
}
J("m", ["mm", 2], 0, "minute");
U("m", Wt, Lp);
U("mm", Wt, ii);
Ot(["m", "mm"], Di);
var fH = bs("Minutes", !1);
J("s", ["ss", 2], 0, "second");
U("s", Wt, Lp);
U("ss", Wt, ii);
Ot(["s", "ss"], wn);
var vH = bs("Seconds", !1);
J("S", 0, 0, function() {
  return ~~(this.millisecond() / 100);
});
J(0, ["SS", 2], 0, function() {
  return ~~(this.millisecond() / 10);
});
J(0, ["SSS", 3], 0, "millisecond");
J(0, ["SSSS", 4], 0, function() {
  return this.millisecond() * 10;
});
J(0, ["SSSSS", 5], 0, function() {
  return this.millisecond() * 100;
});
J(0, ["SSSSSS", 6], 0, function() {
  return this.millisecond() * 1e3;
});
J(0, ["SSSSSSS", 7], 0, function() {
  return this.millisecond() * 1e4;
});
J(0, ["SSSSSSSS", 8], 0, function() {
  return this.millisecond() * 1e5;
});
J(0, ["SSSSSSSSS", 9], 0, function() {
  return this.millisecond() * 1e6;
});
U("S", Uc, vS);
U("SS", Uc, ii);
U("SSS", Uc, pS);
var qn, jS;
for (qn = "SSSS"; qn.length <= 9; qn += "S")
  U(qn, ys);
function pH(e, t) {
  t[jr] = gt(("0." + e) * 1e3);
}
for (qn = "S"; qn.length <= 9; qn += "S")
  Ot(qn, pH);
jS = bs("Milliseconds", !1);
J("z", 0, 0, "zoneAbbr");
J("zz", 0, 0, "zoneName");
function gH() {
  return this._isUTC ? "UTC" : "";
}
function mH() {
  return this._isUTC ? "Coordinated Universal Time" : "";
}
var z = el.prototype;
z.add = uV;
z.calendar = gV;
z.clone = mV;
z.diff = MV;
z.endOf = IV;
z.format = CV;
z.from = EV;
z.fromNow = AV;
z.to = PV;
z.toNow = LV;
z.get = T$;
z.invalidAt = YV;
z.isAfter = yV;
z.isBefore = _V;
z.isBetween = bV;
z.isSame = xV;
z.isSameOrAfter = wV;
z.isSameOrBefore = SV;
z.isValid = VV;
z.lang = VS;
z.locale = zS;
z.localeData = HS;
z.max = Vz;
z.min = zz;
z.parsingFlags = HV;
z.set = C$;
z.startOf = OV;
z.subtract = cV;
z.toArray = BV;
z.toObject = $V;
z.toDate = FV;
z.toISOString = DV;
z.inspect = TV;
typeof Symbol < "u" && Symbol.for != null && (z[Symbol.for("nodejs.util.inspect.custom")] = function() {
  return "Moment<" + this.format() + ">";
});
z.toJSON = zV;
z.toString = kV;
z.unix = NV;
z.valueOf = RV;
z.creationData = WV;
z.eraName = jV;
z.eraNarrow = qV;
z.eraAbbr = ZV;
z.eraYear = KV;
z.year = yS;
z.isLeapYear = D$;
z.weekYear = rH;
z.isoWeekYear = aH;
z.quarter = z.quarters = hH;
z.month = SS;
z.daysInMonth = F$;
z.week = z.weeks = U$;
z.isoWeek = z.isoWeeks = G$;
z.weeksInYear = lH;
z.weeksInWeekYear = uH;
z.isoWeeksInYear = sH;
z.isoWeeksInISOWeekYear = oH;
z.date = XS;
z.day = z.days = az;
z.weekday = sz;
z.isoWeekday = oz;
z.dayOfYear = dH;
z.hour = z.hours = vz;
z.minute = z.minutes = fH;
z.second = z.seconds = vH;
z.millisecond = z.milliseconds = jS;
z.utcOffset = Zz;
z.utc = Qz;
z.local = Jz;
z.parseZone = tV;
z.hasAlignedHourOffset = eV;
z.isDST = iV;
z.isLocal = rV;
z.isUtcOffset = aV;
z.isUtc = NS;
z.isUTC = NS;
z.zoneAbbr = gH;
z.zoneName = mH;
z.dates = bi(
  "dates accessor is deprecated. Use date instead.",
  XS
);
z.months = bi(
  "months accessor is deprecated. Use month instead",
  SS
);
z.years = bi(
  "years accessor is deprecated. Use year instead",
  yS
);
z.zone = bi(
  "moment().zone is deprecated, use moment().utcOffset instead. http://momentjs.com/guides/#/warnings/zone/",
  Kz
);
z.isDSTShifted = bi(
  "isDSTShifted is deprecated. See http://momentjs.com/guides/#/warnings/dst-shifted/ for more information",
  nV
);
function yH(e) {
  return Yt(e * 1e3);
}
function _H() {
  return Yt.apply(null, arguments).parseZone();
}
function qS(e) {
  return e;
}
var xt = Tp.prototype;
xt.calendar = r$;
xt.longDateFormat = l$;
xt.invalidDate = c$;
xt.ordinal = f$;
xt.preparse = qS;
xt.postformat = qS;
xt.relativeTime = p$;
xt.pastFuture = g$;
xt.set = i$;
xt.eras = UV;
xt.erasParse = GV;
xt.erasConvertYear = XV;
xt.erasAbbrRegex = JV;
xt.erasNameRegex = QV;
xt.erasNarrowRegex = tH;
xt.months = O$;
xt.monthsShort = I$;
xt.monthsParse = N$;
xt.monthsRegex = $$;
xt.monthsShortRegex = B$;
xt.week = V$;
xt.firstDayOfYear = W$;
xt.firstDayOfWeek = Y$;
xt.weekdays = tz;
xt.weekdaysMin = iz;
xt.weekdaysShort = ez;
xt.weekdaysParse = rz;
xt.weekdaysRegex = lz;
xt.weekdaysShortRegex = uz;
xt.weekdaysMinRegex = cz;
xt.isPM = dz;
xt.meridiem = pz;
function pc(e, t, i, n) {
  var r = On(), a = rn().set(n, t);
  return r[i](a, e);
}
function ZS(e, t, i) {
  if (An(e) && (t = e, e = void 0), e = e || "", t != null)
    return pc(e, t, i, "month");
  var n, r = [];
  for (n = 0; n < 12; n++)
    r[n] = pc(e, n, i, "month");
  return r;
}
function Up(e, t, i, n) {
  typeof e == "boolean" ? (An(t) && (i = t, t = void 0), t = t || "") : (t = e, i = t, e = !1, An(t) && (i = t, t = void 0), t = t || "");
  var r = On(), a = e ? r._week.dow : 0, s, o = [];
  if (i != null)
    return pc(t, (i + a) % 7, n, "day");
  for (s = 0; s < 7; s++)
    o[s] = pc(t, (s + a) % 7, n, "day");
  return o;
}
function bH(e, t) {
  return ZS(e, t, "months");
}
function xH(e, t) {
  return ZS(e, t, "monthsShort");
}
function wH(e, t, i) {
  return Up(e, t, i, "weekdays");
}
function SH(e, t, i) {
  return Up(e, t, i, "weekdaysShort");
}
function MH(e, t, i) {
  return Up(e, t, i, "weekdaysMin");
}
er("en", {
  eras: [
    {
      since: "0001-01-01",
      until: 1 / 0,
      offset: 1,
      name: "Anno Domini",
      narrow: "AD",
      abbr: "AD"
    },
    {
      since: "0000-12-31",
      until: -1 / 0,
      offset: 1,
      name: "Before Christ",
      narrow: "BC",
      abbr: "BC"
    }
  ],
  dayOfMonthOrdinalParse: /\d{1,2}(th|st|nd|rd)/,
  ordinal: function(e) {
    var t = e % 10, i = gt(e % 100 / 10) === 1 ? "th" : t === 1 ? "st" : t === 2 ? "nd" : t === 3 ? "rd" : "th";
    return e + i;
  }
});
H.lang = bi(
  "moment.lang is deprecated. Use moment.locale instead.",
  er
);
H.langData = bi(
  "moment.langData is deprecated. Use moment.localeData instead.",
  On
);
var hn = Math.abs;
function kH() {
  var e = this._data;
  return this._milliseconds = hn(this._milliseconds), this._days = hn(this._days), this._months = hn(this._months), e.milliseconds = hn(e.milliseconds), e.seconds = hn(e.seconds), e.minutes = hn(e.minutes), e.hours = hn(e.hours), e.months = hn(e.months), e.years = hn(e.years), this;
}
function KS(e, t, i, n) {
  var r = Ri(t, i);
  return e._milliseconds += n * r._milliseconds, e._days += n * r._days, e._months += n * r._months, e._bubble();
}
function DH(e, t) {
  return KS(this, e, t, 1);
}
function TH(e, t) {
  return KS(this, e, t, -1);
}
function H_(e) {
  return e < 0 ? Math.floor(e) : Math.ceil(e);
}
function CH() {
  var e = this._milliseconds, t = this._days, i = this._months, n = this._data, r, a, s, o, l;
  return e >= 0 && t >= 0 && i >= 0 || e <= 0 && t <= 0 && i <= 0 || (e += H_(Jf(i) + t) * 864e5, t = 0, i = 0), n.milliseconds = e % 1e3, r = vi(e / 1e3), n.seconds = r % 60, a = vi(r / 60), n.minutes = a % 60, s = vi(a / 60), n.hours = s % 24, t += vi(s / 24), l = vi(QS(t)), i += l, t -= H_(Jf(l)), o = vi(i / 12), i %= 12, n.days = t, n.months = i, n.years = o, this;
}
function QS(e) {
  return e * 4800 / 146097;
}
function Jf(e) {
  return e * 146097 / 4800;
}
function EH(e) {
  if (!this.isValid())
    return NaN;
  var t, i, n = this._milliseconds;
  if (e = xi(e), e === "month" || e === "quarter" || e === "year")
    switch (t = this._days + n / 864e5, i = this._months + QS(t), e) {
      case "month":
        return i;
      case "quarter":
        return i / 3;
      case "year":
        return i / 12;
    }
  else
    switch (t = this._days + Math.round(Jf(this._months)), e) {
      case "week":
        return t / 7 + n / 6048e5;
      case "day":
        return t + n / 864e5;
      case "hour":
        return t * 24 + n / 36e5;
      case "minute":
        return t * 1440 + n / 6e4;
      case "second":
        return t * 86400 + n / 1e3;
      // Math.floor prevents floating point math errors here
      case "millisecond":
        return Math.floor(t * 864e5) + n;
      default:
        throw new Error("Unknown unit " + e);
    }
}
function In(e) {
  return function() {
    return this.as(e);
  };
}
var JS = In("ms"), AH = In("s"), PH = In("m"), LH = In("h"), OH = In("d"), IH = In("w"), RH = In("M"), NH = In("Q"), FH = In("y"), BH = JS;
function $H() {
  return Ri(this);
}
function zH(e) {
  return e = xi(e), this.isValid() ? this[e + "s"]() : NaN;
}
function ga(e) {
  return function() {
    return this.isValid() ? this._data[e] : NaN;
  };
}
var VH = ga("milliseconds"), HH = ga("seconds"), YH = ga("minutes"), WH = ga("hours"), UH = ga("days"), GH = ga("months"), XH = ga("years");
function jH() {
  return vi(this.days() / 7);
}
var pn = Math.round, Xa = {
  ss: 44,
  // a few seconds to seconds
  s: 45,
  // seconds to minute
  m: 45,
  // minutes to hour
  h: 22,
  // hours to day
  d: 26,
  // days to month/week
  w: null,
  // weeks to month
  M: 11
  // months to year
};
function qH(e, t, i, n, r) {
  return r.relativeTime(t || 1, !!i, e, n);
}
function ZH(e, t, i, n) {
  var r = Ri(e).abs(), a = pn(r.as("s")), s = pn(r.as("m")), o = pn(r.as("h")), l = pn(r.as("d")), u = pn(r.as("M")), c = pn(r.as("w")), h = pn(r.as("y")), d = a <= i.ss && ["s", a] || a < i.s && ["ss", a] || s <= 1 && ["m"] || s < i.m && ["mm", s] || o <= 1 && ["h"] || o < i.h && ["hh", o] || l <= 1 && ["d"] || l < i.d && ["dd", l];
  return i.w != null && (d = d || c <= 1 && ["w"] || c < i.w && ["ww", c]), d = d || u <= 1 && ["M"] || u < i.M && ["MM", u] || h <= 1 && ["y"] || ["yy", h], d[2] = t, d[3] = +e > 0, d[4] = n, qH.apply(null, d);
}
function KH(e) {
  return e === void 0 ? pn : typeof e == "function" ? (pn = e, !0) : !1;
}
function QH(e, t) {
  return Xa[e] === void 0 ? !1 : t === void 0 ? Xa[e] : (Xa[e] = t, e === "s" && (Xa.ss = t - 1), !0);
}
function JH(e, t) {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var i = !1, n = Xa, r, a;
  return typeof e == "object" && (t = e, e = !1), typeof e == "boolean" && (i = e), typeof t == "object" && (n = Object.assign({}, Xa, t), t.s != null && t.ss == null && (n.ss = t.s - 1)), r = this.localeData(), a = ZH(this, !i, n, r), i && (a = r.pastFuture(+this, a)), r.postformat(a);
}
var Id = Math.abs;
function Ba(e) {
  return (e > 0) - (e < 0) || +e;
}
function Jc() {
  if (!this.isValid())
    return this.localeData().invalidDate();
  var e = Id(this._milliseconds) / 1e3, t = Id(this._days), i = Id(this._months), n, r, a, s, o = this.asSeconds(), l, u, c, h;
  return o ? (n = vi(e / 60), r = vi(n / 60), e %= 60, n %= 60, a = vi(i / 12), i %= 12, s = e ? e.toFixed(3).replace(/\.?0+$/, "") : "", l = o < 0 ? "-" : "", u = Ba(this._months) !== Ba(o) ? "-" : "", c = Ba(this._days) !== Ba(o) ? "-" : "", h = Ba(this._milliseconds) !== Ba(o) ? "-" : "", l + "P" + (a ? u + a + "Y" : "") + (i ? u + i + "M" : "") + (t ? c + t + "D" : "") + (r || n || e ? "T" : "") + (r ? h + r + "H" : "") + (n ? h + n + "M" : "") + (e ? h + s + "S" : "")) : "P0D";
}
var yt = Kc.prototype;
yt.isValid = Gz;
yt.abs = kH;
yt.add = DH;
yt.subtract = TH;
yt.as = EH;
yt.asMilliseconds = JS;
yt.asSeconds = AH;
yt.asMinutes = PH;
yt.asHours = LH;
yt.asDays = OH;
yt.asWeeks = IH;
yt.asMonths = RH;
yt.asQuarters = NH;
yt.asYears = FH;
yt.valueOf = BH;
yt._bubble = CH;
yt.clone = $H;
yt.get = zH;
yt.milliseconds = VH;
yt.seconds = HH;
yt.minutes = YH;
yt.hours = WH;
yt.days = UH;
yt.weeks = jH;
yt.months = GH;
yt.years = XH;
yt.humanize = JH;
yt.toISOString = Jc;
yt.toString = Jc;
yt.toJSON = Jc;
yt.locale = zS;
yt.localeData = HS;
yt.toIsoString = bi(
  "toIsoString() is deprecated. Please use toISOString() instead (notice the capitals)",
  Jc
);
yt.lang = VS;
J("X", 0, 0, "unix");
J("x", 0, 0, "valueOf");
U("x", Xc);
U("X", b$);
Ot("X", function(e, t, i) {
  i._d = new Date(parseFloat(e) * 1e3);
});
Ot("x", function(e, t, i) {
  i._d = new Date(gt(e));
});
H.version = "2.30.1";
t$(Yt);
H.fn = z;
H.min = Hz;
H.max = Yz;
H.now = Wz;
H.utc = rn;
H.unix = yH;
H.months = bH;
H.isDate = tl;
H.locale = er;
H.invalid = Yc;
H.duration = Ri;
H.isMoment = Ai;
H.weekdays = wH;
H.parseZone = _H;
H.localeData = On;
H.isDuration = mu;
H.monthsShort = xH;
H.weekdaysMin = MH;
H.defineLocale = Fp;
H.updateLocale = _z;
H.locales = bz;
H.weekdaysShort = SH;
H.normalizeUnits = xi;
H.relativeTimeRounding = KH;
H.relativeTimeThreshold = QH;
H.calendarFormat = pV;
H.prototype = z;
H.HTML5_FMT = {
  DATETIME_LOCAL: "YYYY-MM-DDTHH:mm",
  // <input type="datetime-local" />
  DATETIME_LOCAL_SECONDS: "YYYY-MM-DDTHH:mm:ss",
  // <input type="datetime-local" step="1" />
  DATETIME_LOCAL_MS: "YYYY-MM-DDTHH:mm:ss.SSS",
  // <input type="datetime-local" step="0.001" />
  DATE: "YYYY-MM-DD",
  // <input type="date" />
  TIME: "HH:mm",
  // <input type="time" />
  TIME_SECONDS: "HH:mm:ss",
  // <input type="time" step="1" />
  TIME_MS: "HH:mm:ss.SSS",
  // <input type="time" step="0.001" />
  WEEK: "GGGG-[W]WW",
  // <input type="week" />
  MONTH: "YYYY-MM"
  // <input type="month" />
};
const dt = (e) => e == null ? "0" : new Intl.NumberFormat("en-US").format(e), Y_ = (e, t = "USD") => e == null ? "$0.00" : new Intl.NumberFormat("en-US", {
  style: "currency",
  currency: t,
  minimumFractionDigits: 2,
  maximumFractionDigits: 2
}).format(e), t8 = { class: "booking-manager-card" }, e8 = { class: "card-header" }, i8 = { class: "header-content" }, n8 = {
  key: 0,
  class: "payment-success-badge"
}, r8 = { class: "badge-value" }, a8 = {
  key: 0,
  class: "loading-state"
}, s8 = {
  key: 1,
  class: "error-state"
}, o8 = { class: "error-content" }, l8 = { class: "error-description" }, u8 = {
  key: 2,
  class: "card-body"
}, c8 = { class: "chart-section" }, h8 = { class: "chart-wrapper" }, d8 = {
  key: 0,
  class: "table-section"
}, f8 = { class: "table-wrapper" }, v8 = { class: "data-table" }, p8 = { class: "table-body" }, g8 = { class: "table-cell font-medium" }, m8 = { class: "table-cell text-center" }, y8 = { class: "table-cell text-center" }, _8 = { class: "percentage-text" }, b8 = { class: "table-cell text-center" }, x8 = { class: "table-cell" }, w8 = { class: "badges-container" }, S8 = { class: "badge badge-success" }, M8 = { class: "badge badge-error" }, k8 = { class: "table-cell" }, D8 = { class: "badges-container" }, T8 = { class: "badge badge-error" }, C8 = { class: "badge badge-warning" }, E8 = { class: "badge badge-yellow" }, A8 = { class: "badge badge-error" }, P8 = {
  key: 1,
  class: "empty-state"
}, L8 = /* @__PURE__ */ le({
  __name: "BookingManager",
  props: {
    data: { default: () => ({
      total_booking_initiated: 0,
      total_booking_started: 0,
      total_payment_initiated: 0,
      total_not_found: 0,
      total_cancelled: 0,
      total_no_pending_balance: 0,
      total_errors: 0,
      total_payment_success: 0,
      total_payment_failed: 0,
      booking_manager_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    error: { default: null },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = e, n = t, r = (u) => {
      n("export", u);
    }, a = q(() => i.data?.booking_manager_by_day ? [...i.data.booking_manager_by_day].sort(
      (u, c) => new Date(u.date).getTime() - new Date(c.date).getTime()
    ) : []), s = q(() => {
      const u = i.data, c = u.total_booking_initiated || 0, h = u.total_booking_started || 0, d = u.total_payment_initiated || 0, f = u.total_not_found || 0, v = u.total_cancelled || 0, m = u.total_no_pending_balance || 0, p = u.total_errors || 0, g = u.total_payment_success || 0, y = u.total_payment_failed || 0, _ = Math.max(0, c - h), b = Math.max(0, h - d - f - v - m - p), w = (k, T) => {
        const D = T > 0 ? Math.round(k / T * 100) : 0;
        return `${k.toLocaleString()} (${D}%)`;
      }, S = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Payment Initiated" },
        { name: "Not Found" },
        { name: "Cancelled" },
        { name: "No Pending Balance" },
        { name: "Errors" },
        { name: "Payment Success" },
        { name: "Payment Failed" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], M = [];
      return h > 0 && M.push({
        source: "Initiated",
        target: "Started",
        value: h,
        label: w(h, c)
      }), _ > 0 && M.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: _,
        label: w(_, c)
      }), d > 0 && M.push({
        source: "Started",
        target: "Payment Initiated",
        value: d,
        label: w(d, h)
      }), f > 0 && M.push({
        source: "Started",
        target: "Not Found",
        value: f,
        label: w(f, h)
      }), v > 0 && M.push({
        source: "Started",
        target: "Cancelled",
        value: v,
        label: w(v, h)
      }), m > 0 && M.push({
        source: "Started",
        target: "No Pending Balance",
        value: m,
        label: w(m, h)
      }), p > 0 && M.push({
        source: "Started",
        target: "Errors",
        value: p,
        label: w(p, h)
      }), b > 0 && M.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: b,
        label: w(b, h)
      }), g > 0 && M.push({
        source: "Payment Initiated",
        target: "Payment Success",
        value: g,
        label: w(g, d)
      }), y > 0 && M.push({
        source: "Payment Initiated",
        target: "Payment Failed",
        value: y,
        label: w(y, d)
      }), { nodes: S, links: M };
    }), o = {
      Initiated: "#DBEAFE",
      Started: "#93C5FD",
      "Payment Initiated": "#FED7AA",
      "Not Found": "#FECACA",
      Cancelled: "#FED7AA",
      "No Pending Balance": "#FEF08A",
      Errors: "#FCA5A5",
      "Payment Success": "#86EFAC",
      "Payment Failed": "#FCA5A5",
      "Abandoned (Init)": "#FEE2E2",
      "Abandoned (Start)": "#FEE2E2"
    }, l = (u, c) => !c || c === 0 ? "0%" : `${Math.round(u / c * 100)}%`;
    return (u, c) => (A(), I("article", t8, [
      x("header", e8, [
        x("div", i8, [
          c[1] || (c[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Booking Manager Metrics"),
            x("p", { class: "card-subtitle" }, "Booking manager workflow tracking and analysis")
          ], -1)),
          i.loading ? Q("", !0) : (A(), I("div", n8, [
            c[0] || (c[0] = x("p", { class: "badge-label" }, "Payment Success", -1)),
            x("p", r8, R(X(dt)(i.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      i.loading ? (A(), I("div", a8, [...c[2] || (c[2] = [
        Nt('<div class="loading-container" data-v-f2a1ae01><div class="chart-flow-loader" data-v-f2a1ae01><div class="flow-line flow-1" data-v-f2a1ae01></div><div class="flow-line flow-2" data-v-f2a1ae01></div><div class="flow-line flow-3" data-v-f2a1ae01></div><div class="flow-line flow-4" data-v-f2a1ae01></div><div class="flow-line flow-5" data-v-f2a1ae01></div></div><p class="loading-text" data-v-f2a1ae01>Loading booking data...</p></div>', 1)
      ])])) : i.error ? (A(), I("div", s8, [
        x("div", o8, [
          c[3] || (c[3] = x("div", { class: "error-icon-wrapper" }, [
            x("svg", {
              class: "error-icon",
              fill: "none",
              viewBox: "0 0 24 24",
              stroke: "currentColor"
            }, [
              x("path", {
                "stroke-linecap": "round",
                "stroke-linejoin": "round",
                "stroke-width": "2",
                d: "M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              })
            ])
          ], -1)),
          c[4] || (c[4] = x("p", { class: "error-title" }, "Error loading data", -1)),
          x("p", l8, R(i.error), 1)
        ])
      ])) : (A(), I("div", u8, [
        x("section", c8, [
          x("div", h8, [
            fe(pa, {
              data: s.value,
              "node-colors": o,
              height: "500px",
              "node-gap": 15
            }, null, 8, ["data"])
          ])
        ]),
        a.value.length > 0 ? (A(), I("section", d8, [
          c[6] || (c[6] = x("div", { class: "section-header" }, [
            x("h4", { class: "section-title" }, "Daily Overview")
          ], -1)),
          x("div", f8, [
            x("table", v8, [
              c[5] || (c[5] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Initiated"),
                  x("th", { class: "table-header" }, "Started"),
                  x("th", { class: "table-header" }, "Payment Initiated"),
                  x("th", { class: "table-header" }, "Payment Results"),
                  x("th", { class: "table-header" }, "Outcomes")
                ])
              ], -1)),
              x("tbody", p8, [
                (A(!0), I(Rt, null, ce(a.value, (h) => (A(), I("tr", {
                  key: h.date,
                  class: "table-row"
                }, [
                  x("td", g8, R(X(H)(h.date).format("DD/MM/YYYY")), 1),
                  x("td", m8, R(X(dt)(h.booking_initiated_count)), 1),
                  x("td", y8, [
                    _u(R(X(dt)(h.booking_started_count)) + " ", 1),
                    x("span", _8, " (" + R(l(h.booking_started_count, h.booking_initiated_count)) + ") ", 1)
                  ]),
                  x("td", b8, R(X(dt)(h.payment_initiated_count)), 1),
                  x("td", x8, [
                    x("div", w8, [
                      x("span", S8, " Success: " + R(h.payment_success_count ? X(dt)(h.payment_success_count) : "N/A"), 1),
                      x("span", M8, " Failed: " + R(h.payment_failed_count ? X(dt)(h.payment_failed_count) : "N/A"), 1)
                    ])
                  ]),
                  x("td", k8, [
                    x("div", D8, [
                      x("span", T8, " Not Found: " + R(h.not_found_count ? X(dt)(h.not_found_count) : "N/A"), 1),
                      x("span", C8, " Cancelled: " + R(h.cancelled_count ? X(dt)(h.cancelled_count) : "N/A"), 1),
                      x("span", E8, " No Balance: " + R(h.no_pending_balance_count ? X(dt)(h.no_pending_balance_count) : "N/A"), 1),
                      x("span", A8, " Errors: " + R(h.error_count ? X(dt)(h.error_count) : "N/A"), 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: r
          })) : Q("", !0)
        ])) : (A(), I("section", P8, [...c[7] || (c[7] = [
          Nt('<div class="empty-state-content" data-v-f2a1ae01><div class="empty-icon-wrapper" data-v-f2a1ae01><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-f2a1ae01><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" data-v-f2a1ae01></path></svg></div><p class="empty-title" data-v-f2a1ae01>No booking manager data available</p><p class="empty-description" data-v-f2a1ae01>No booking manager data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), O8 = /* @__PURE__ */ te(L8, [["__scopeId", "data-v-f2a1ae01"]]), I8 = { class: "checkin-metrics-card" }, R8 = {
  key: 0,
  class: "loading-state"
}, N8 = {
  key: 1,
  class: "card-body"
}, F8 = {
  key: 0,
  class: "chart-section"
}, B8 = { class: "chart-wrapper" }, $8 = {
  key: 1,
  class: "table-section"
}, z8 = { class: "table-wrapper" }, V8 = { class: "data-table" }, H8 = { class: "table-body" }, Y8 = { class: "table-cell font-medium" }, W8 = { class: "table-cell text-center" }, U8 = { class: "table-cell text-center" }, G8 = { class: "table-cell text-center" }, X8 = { class: "table-cell text-center" }, j8 = { class: "table-cell text-center" }, q8 = { class: "table-cell text-center" }, Z8 = { class: "table-cell text-left" }, K8 = {
  key: 0,
  class: "failed-steps"
}, Q8 = { class: "step-name" }, J8 = { class: "step-count" }, tY = {
  key: 1,
  class: "empty-cell"
}, eY = {
  key: 2,
  class: "empty-state"
}, iY = {
  __name: "Checkin",
  props: {
    loading: {
      type: Boolean,
      default: !1
    },
    enableExport: {
      type: Boolean,
      default: !1
    },
    checkinData: {
      type: Object,
      default: () => ({
        total_checkin_init: 0,
        total_checkin_initiated: 0,
        total_checkin_init_abandoned: 0,
        total_checkin_started: 0,
        total_checkin_completed: 0,
        total_checkin_closed: 0,
        total_checkin_unrecovered: 0,
        checkin_by_day: []
      })
    },
    failedData: {
      type: Object,
      default: () => ({
        total_checkin_failed: 0,
        failed_by_step_by_day: [],
        unrecovered_by_step: []
      })
    }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = t, n = (p) => {
      i("export", p);
    }, r = e, a = {
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }, s = {
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }, o = gi([]), l = q(() => r.checkinData ?? a), u = q(() => r.failedData ?? s), c = q(() => {
      const p = {
        // Main flow progression - from blue to purple to green
        "Checkin Init": "#93C5FD",
        // Blue for started state
        "Booking retrive": "#C7D2FE",
        // Light purple
        "Booking retrive success": "#A5B4FC",
        // Medium purple for success
        "Number of Passengers": "#8B8CF6",
        // Medium purple
        Completed: "#A7F3D0",
        // Light green
        "Closed with BP": "#7BE39E",
        // Green for success
        // Abandoned states - progressive yellow/orange
        "Abandoned (Init)": "#FCA5A5",
        // Light red
        "Abandoned (Started)": "#F87171",
        // Medium red
        "Abandoned (Flow)": "#EF4444",
        // Darker red
        "BP Error": "#EF4444",
        // Darker red for boarding pass error
        // Failed states - progressive red intensity
        Unrecovered: "#F87171"
        // Medium red for main unrecovered node
      };
      return (u.value.unrecovered_by_step || []).forEach((y) => {
        const b = y.step_name.replace(/_/g, " ").split(" ").map((S) => S.charAt(0).toUpperCase() + S.slice(1)).join(" "), w = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        p[b] = w[b] || "#DC2626";
      }), p;
    }), h = (p, g) => !g || g === 0 ? "0%" : `${Math.round(p / g * 100)}%`, d = (p, g) => {
      const y = dt(p), _ = h(p, g);
      return `${y} (${_})`;
    }, f = (p) => p.reduce((g, y) => g + y.failed_count, 0), v = q(() => {
      const p = [], g = [];
      if (!l.value.total_checkin_initiated)
        return { nodes: p, links: g };
      p.push({ name: "Checkin Init" }), p.push({ name: "Booking retrive" }), p.push({ name: "Booking retrive success" }), p.push({ name: "Number of Passengers" }), p.push({ name: "Completed" }), p.push({ name: "Closed with BP" });
      const y = l.value.total_checkin_initiated, _ = l.value.total_checkin_init, b = l.value.total_checkin_init_abandoned, w = _ - b, S = l.value.total_checkin_started, M = l.value.total_checkin_completed, k = l.value.total_checkin_closed, T = u.value.unrecovered_by_step || [], D = T.reduce((O, N) => O + N.count, 0);
      if (console.log(JSON.stringify(l.value)), _ > 0) {
        const O = Math.round(_ / y * 100);
        g.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: _,
          label: `${_.toLocaleString()} (${O}%)`
        });
      }
      const C = y - _;
      if (C > 0) {
        const O = Math.round(C / y * 100);
        p.push({ name: "Abandoned (Init)" }), g.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: C,
          label: `${C.toLocaleString()} (${O}%)`
        });
      }
      if (b > 0) {
        const O = Math.round(b / y * 100);
        p.push({ name: "Abandoned (Started)" }), g.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: b,
          label: `${b.toLocaleString()} (${O}%)`
        });
      }
      if (w > 0) {
        const O = Math.round(w / y * 100);
        g.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: w,
          label: `${w.toLocaleString()} (${O}%)`
        });
      }
      if (S > 0) {
        const O = Math.round(S / y * 100);
        g.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: S,
          label: `${S.toLocaleString()} (${O}%)`
        });
      }
      if (M > 0) {
        const O = Math.round(M / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Completed",
          value: M,
          label: `${M.toLocaleString()} (${O}%)`
        });
      }
      if (T.length > 0 && D > 0) {
        p.push({ name: "Unrecovered" });
        const O = Math.round(D / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: D,
          label: `${D.toLocaleString()} (${O}%)`
        }), T.forEach((N) => {
          const G = N.step_name.replace(/_/g, " ").split(" ").map((F) => F.charAt(0).toUpperCase() + F.slice(1)).join(" "), V = Math.round(N.count / S * 100);
          p.push({ name: G }), g.push({
            source: "Unrecovered",
            target: G,
            value: N.count,
            label: `${N.count.toLocaleString()} (${V}%)`
          });
        });
      }
      const P = S - (M + D);
      if (P > 0) {
        const O = Math.round(P / S * 100);
        p.push({ name: "Abandoned (Flow)" }), g.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: P,
          label: `${P.toLocaleString()} (${O}%)`
        });
      }
      const L = M - k;
      if (L > 0) {
        const O = Math.round(L / S * 100);
        p.push({ name: "BP Error" }), g.push({
          source: "Completed",
          target: "BP Error",
          value: L,
          label: `${L.toLocaleString()} (${O}%)`
        });
      }
      if (k > 0) {
        const O = Math.round(k / S * 100);
        g.push({
          source: "Completed",
          target: "Closed with BP",
          value: k,
          label: `${k.toLocaleString()} (${O}%)`
        });
      }
      return console.log(JSON.stringify(p)), console.log(JSON.stringify(g)), { nodes: p, links: g };
    }), m = () => {
      const p = l.value.checkin_by_day || [], g = u.value.failed_by_step_by_day || [];
      if (p.length === 0) {
        o.value = [];
        return;
      }
      o.value = [...p].map((y) => {
        const _ = g.find(
          (b) => b.date === y.date
        );
        return {
          ...y,
          failed_steps: _?.steps || []
        };
      }), o.value.sort((y, _) => new Date(y.date) - new Date(_.date));
    };
    return ns(
      [() => r.checkinData, () => r.failedData],
      () => {
        m();
      },
      { deep: !0, immediate: !0 }
    ), (p, g) => (A(), I("article", I8, [
      g[3] || (g[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Check-in Metrics"),
          x("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      r.loading ? (A(), I("div", R8, [...g[0] || (g[0] = [
        Nt('<div class="loading-container" data-v-eb5822ab><div class="chart-flow-loader" data-v-eb5822ab><div class="flow-line flow-1" data-v-eb5822ab></div><div class="flow-line flow-2" data-v-eb5822ab></div><div class="flow-line flow-3" data-v-eb5822ab></div><div class="flow-line flow-4" data-v-eb5822ab></div><div class="flow-line flow-5" data-v-eb5822ab></div></div><p class="loading-text" data-v-eb5822ab>Loading check-in data...</p></div>', 1)
      ])])) : (A(), I("div", N8, [
        v.value.nodes.length > 0 ? (A(), I("section", F8, [
          x("div", B8, [
            fe(pa, {
              data: v.value,
              height: "500px",
              "node-colors": c.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : Q("", !0),
        o.value && o.value.length > 0 ? (A(), I("section", $8, [
          x("div", z8, [
            x("table", V8, [
              g[1] || (g[1] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Checkin Init"),
                  x("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  x("th", { class: "table-header" }, "Number of Passengers"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed with BP (%)"),
                  x("th", { class: "table-header" }, "Failed (%)"),
                  x("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              x("tbody", H8, [
                (A(!0), I(Rt, null, ce(o.value, (y) => (A(), I("tr", {
                  key: y.date,
                  class: "table-row"
                }, [
                  x("td", Y8, R(X(H)(y.date).format("DD/MM/YYYY")), 1),
                  x("td", W8, R(X(dt)(y.checkin_initiated_count)), 1),
                  x("td", U8, R(d(y.checkin_init_count, y.checkin_initiated_count)), 1),
                  x("td", G8, R(X(dt)(y.checkin_started_count)), 1),
                  x("td", X8, R(d(y.checkin_completed_count, y.checkin_started_count)), 1),
                  x("td", j8, R(d(y.checkin_closed_count, y.checkin_started_count)), 1),
                  x("td", q8, R(d(f(y.failed_steps), y.checkin_started_count)), 1),
                  x("td", Z8, [
                    y.failed_steps && y.failed_steps.length > 0 ? (A(), I("div", K8, [
                      (A(!0), I(Rt, null, ce(y.failed_steps, (_) => (A(), I("div", {
                        key: _.step_name,
                        class: "failed-step-item"
                      }, [
                        x("span", Q8, R(_.step_name.replace(/_/g, " ")) + ":", 1),
                        x("span", J8, R(_.failed_count), 1)
                      ]))), 128))
                    ])) : (A(), I("div", tY, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: n
          })) : Q("", !0)
        ])) : (A(), I("section", eY, [...g[2] || (g[2] = [
          Nt('<div class="empty-state-content" data-v-eb5822ab><div class="empty-icon-wrapper" data-v-eb5822ab><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-eb5822ab><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-eb5822ab></path></svg></div><p class="empty-title" data-v-eb5822ab>No check-in data available</p><p class="empty-description" data-v-eb5822ab>Try adjusting the date range or check your filters to see check-in performance data.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}, nY = /* @__PURE__ */ te(iY, [["__scopeId", "data-v-eb5822ab"]]), rY = { class: "checkin-metrics-card" }, aY = {
  key: 0,
  class: "loading-state"
}, sY = {
  key: 1,
  class: "card-body"
}, oY = {
  key: 0,
  class: "sankey-section"
}, lY = {
  key: 1,
  class: "table-section"
}, uY = { class: "table-wrapper" }, cY = { class: "data-table" }, hY = { class: "table-body" }, dY = { class: "table-cell date-cell" }, fY = { class: "table-cell text-center" }, vY = { class: "table-cell text-center" }, pY = { class: "table-cell text-center" }, gY = { class: "table-cell text-center" }, mY = { class: "table-cell text-center" }, yY = { class: "table-cell text-center" }, _Y = { class: "table-cell reasons-cell" }, bY = {
  key: 0,
  class: "reasons-list"
}, xY = { class: "reason-name" }, wY = { class: "reason-count" }, SY = {
  key: 1,
  class: "no-reasons"
}, MY = {
  key: 2,
  class: "empty-state"
}, kY = { class: "empty-state-content" }, DY = { class: "empty-icon-wrapper" }, TY = /* @__PURE__ */ le({
  __name: "CheckinMetrics",
  props: {
    checkinData: { default: () => ({
      total_checkin_init: 0,
      total_checkin_initiated: 0,
      total_checkin_init_abandoned: 0,
      total_checkin_started: 0,
      total_checkin_completed: 0,
      total_checkin_closed: 0,
      total_checkin_unrecovered: 0,
      checkin_by_day: []
    }) },
    failedData: { default: () => ({
      total_checkin_failed: 0,
      failed_by_step_by_day: [],
      unrecovered_by_step: []
    }) },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (p) => {
      r("export", p);
    }, { isDark: s } = _e(ye(n, "theme")), o = (p) => p == null ? "0" : p.toLocaleString(), l = (p) => {
      const g = new Date(p), y = String(g.getDate()).padStart(2, "0"), _ = String(g.getMonth() + 1).padStart(2, "0"), b = g.getFullYear();
      return `${y}/${_}/${b}`;
    }, u = (p) => p.replace(/_/g, " ").replace(/\b\w/g, (g) => g.toUpperCase()), c = (p, g) => !g || g === 0 ? "0%" : `${Math.round(p / g * 100)}%`, h = (p, g) => {
      const y = p || 0, _ = g || 0, b = o(y), w = c(y, _);
      return `${b} (${w})`;
    }, d = (p) => p ? p.reduce((g, y) => g + y.failed_count, 0) : 0, f = q(() => {
      const p = {
        "Checkin Init": "#93C5FD",
        "Booking retrive": "#C7D2FE",
        "Booking retrive success": "#A5B4FC",
        "Number of Passengers": "#8B8CF6",
        Completed: "#A7F3D0",
        "Closed with BP": "#7BE39E",
        "Abandoned (Init)": "#FCA5A5",
        "Abandoned (Started)": "#F87171",
        "Abandoned (Flow)": "#EF4444",
        "BP Error": "#EF4444",
        Unrecovered: "#F87171"
      };
      return (n.failedData?.unrecovered_by_step || []).forEach((y) => {
        const b = y.step_name.replace(/_/g, " ").split(" ").map((S) => S.charAt(0).toUpperCase() + S.slice(1)).join(" "), w = {
          "Get Seatmap": "#DC2626",
          "Save Missing Info": "#F87171",
          "Checkin Segments": "#EF4444",
          "Assign Seat": "#F87171"
        };
        p[b] = w[b] || "#DC2626";
      }), p;
    }), v = q(() => {
      const p = n.checkinData?.checkin_by_day || [], g = n.failedData?.failed_by_step_by_day || [];
      return p.map((_) => {
        const b = g.find((w) => w.date === _.date);
        return {
          ..._,
          failed_steps: b?.steps || []
        };
      }).sort((_, b) => new Date(_.date).getTime() - new Date(b.date).getTime());
    }), m = q(() => {
      const p = [], g = [];
      if (!n.checkinData?.total_checkin_initiated)
        return { nodes: p, links: g };
      p.push({ name: "Checkin Init" }), p.push({ name: "Booking retrive" }), p.push({ name: "Booking retrive success" }), p.push({ name: "Number of Passengers" }), p.push({ name: "Completed" }), p.push({ name: "Closed with BP" });
      const y = n.checkinData.total_checkin_initiated || 0, _ = n.checkinData.total_checkin_init || 0, b = n.checkinData.total_checkin_init_abandoned || 0, w = _ - b, S = n.checkinData.total_checkin_started || 0, M = n.checkinData.total_checkin_completed || 0, k = n.checkinData.total_checkin_closed || 0, T = n.failedData?.unrecovered_by_step || [], D = T.reduce((O, N) => O + N.count, 0);
      if (_ > 0) {
        const O = Math.round(_ / y * 100);
        g.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: _,
          label: `${_.toLocaleString()} (${O}%)`
        });
      }
      const C = y - _;
      if (C > 0) {
        const O = Math.round(C / y * 100);
        p.push({ name: "Abandoned (Init)" }), g.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: C,
          label: `${C.toLocaleString()} (${O}%)`
        });
      }
      if (b > 0) {
        const O = Math.round(b / y * 100);
        p.push({ name: "Abandoned (Started)" }), g.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: b,
          label: `${b.toLocaleString()} (${O}%)`
        });
      }
      if (w > 0) {
        const O = Math.round(w / y * 100);
        g.push({
          source: "Booking retrive",
          target: "Booking retrive success",
          value: w,
          label: `${w.toLocaleString()} (${O}%)`
        });
      }
      if (S > 0) {
        const O = Math.round(S / y * 100);
        g.push({
          source: "Booking retrive success",
          target: "Number of Passengers",
          value: S,
          label: `${S.toLocaleString()} (${O}%)`
        });
      }
      if (M > 0) {
        const O = Math.round(M / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Completed",
          value: M,
          label: `${M.toLocaleString()} (${O}%)`
        });
      }
      if (T.length > 0 && D > 0) {
        p.push({ name: "Unrecovered" });
        const O = Math.round(D / S * 100);
        g.push({
          source: "Number of Passengers",
          target: "Unrecovered",
          value: D,
          label: `${D.toLocaleString()} (${O}%)`
        }), T.forEach((N) => {
          const G = N.step_name.replace(/_/g, " ").split(" ").map((F) => F.charAt(0).toUpperCase() + F.slice(1)).join(" "), V = Math.round(N.count / S * 100);
          p.push({ name: G }), g.push({
            source: "Unrecovered",
            target: G,
            value: N.count,
            label: `${N.count.toLocaleString()} (${V}%)`
          });
        });
      }
      const P = S - (M + D);
      if (P > 0) {
        const O = Math.round(P / S * 100);
        p.push({ name: "Abandoned (Flow)" }), g.push({
          source: "Number of Passengers",
          target: "Abandoned (Flow)",
          value: P,
          label: `${P.toLocaleString()} (${O}%)`
        });
      }
      const L = M - k;
      if (L > 0) {
        const O = Math.round(L / S * 100);
        p.push({ name: "BP Error" }), g.push({
          source: "Completed",
          target: "BP Error",
          value: L,
          label: `${L.toLocaleString()} (${O}%)`
        });
      }
      if (k > 0) {
        const O = Math.round(k / S * 100);
        g.push({
          source: "Completed",
          target: "Closed with BP",
          value: k,
          label: `${k.toLocaleString()} (${O}%)`
        });
      }
      return { nodes: p, links: g };
    });
    return t({ isDark: s }), (p, g) => (A(), I("article", rY, [
      g[4] || (g[4] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Check-in Metrics"),
          x("p", { class: "card-subtitle" }, "Check-in performance and failure analysis")
        ])
      ], -1)),
      e.loading ? (A(), I("div", aY, [...g[0] || (g[0] = [
        Nt('<div class="loading-container" data-v-33a227cc><div class="chart-bars-loader" data-v-33a227cc><div class="bar bar-1" data-v-33a227cc></div><div class="bar bar-2" data-v-33a227cc></div><div class="bar bar-3" data-v-33a227cc></div><div class="bar bar-4" data-v-33a227cc></div><div class="bar bar-5" data-v-33a227cc></div></div><p class="loading-text" data-v-33a227cc>Loading check-in data...</p></div>', 1)
      ])])) : (A(), I("div", sY, [
        m.value.nodes.length > 0 ? (A(), I("div", oY, [
          fe(pa, {
            data: m.value,
            height: "500px",
            "node-colors": f.value,
            "use-gradient": !1,
            "node-gap": 30
          }, null, 8, ["data", "node-colors"])
        ])) : Q("", !0),
        v.value && v.value.length > 0 ? (A(), I("div", lY, [
          x("div", uY, [
            x("table", cY, [
              g[1] || (g[1] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Checkin Init"),
                  x("th", { class: "table-header" }, "Booking Retrieve (%)"),
                  x("th", { class: "table-header" }, "Number of Passengers"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed with BP (%)"),
                  x("th", { class: "table-header" }, "Failed (%)"),
                  x("th", { class: "table-header" }, "Failed (Reasons)")
                ])
              ], -1)),
              x("tbody", hY, [
                (A(!0), I(Rt, null, ce(v.value, (y) => (A(), I("tr", {
                  key: y.date,
                  class: "table-row"
                }, [
                  x("td", dY, R(l(y.date)), 1),
                  x("td", fY, R(o(y.checkin_initiated_count)), 1),
                  x("td", vY, R(h(y.checkin_init_count, y.checkin_initiated_count)), 1),
                  x("td", pY, R(o(y.checkin_started_count)), 1),
                  x("td", gY, R(h(y.checkin_completed_count, y.checkin_started_count)), 1),
                  x("td", mY, R(h(y.checkin_closed_count, y.checkin_started_count)), 1),
                  x("td", yY, R(h(d(y.failed_steps), y.checkin_started_count)), 1),
                  x("td", _Y, [
                    y.failed_steps && y.failed_steps.length > 0 ? (A(), I("div", bY, [
                      (A(!0), I(Rt, null, ce(y.failed_steps, (_) => (A(), I("div", {
                        key: _.step_name,
                        class: "reason-item"
                      }, [
                        x("span", xY, R(u(_.step_name)) + ":", 1),
                        x("span", wY, R(_.failed_count), 1)
                      ]))), 128))
                    ])) : (A(), I("div", SY, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: a
          })) : Q("", !0)
        ])) : (A(), I("div", MY, [
          x("div", kY, [
            x("div", DY, [
              fe(X(Sp), { class: "empty-icon" })
            ]),
            g[2] || (g[2] = x("p", { class: "empty-title" }, "No check-in data available", -1)),
            g[3] || (g[3] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see check-in metrics.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), CY = /* @__PURE__ */ te(TY, [["__scopeId", "data-v-33a227cc"]]), EY = { class: "checkin-segments-card" }, AY = {
  key: 0,
  class: "loading-state"
}, PY = {
  key: 1,
  class: "card-body"
}, LY = {
  key: 0,
  class: "table-section"
}, OY = { class: "table-wrapper" }, IY = { class: "data-table" }, RY = { class: "table-body" }, NY = { class: "table-cell font-medium text-center" }, FY = { class: "airport-badge" }, BY = { class: "table-cell text-center" }, $Y = {
  key: 0,
  class: "airport-badge connection"
}, zY = {
  key: 1,
  class: "empty-connection"
}, VY = { class: "table-cell text-center" }, HY = { class: "airport-badge" }, YY = { class: "table-cell text-center" }, WY = {
  key: 0,
  class: "trip-badge roundtrip"
}, UY = {
  key: 1,
  class: "trip-badge oneway"
}, GY = { class: "table-cell text-center" }, XY = { class: "table-cell text-center" }, jY = { class: "percentage-value" }, qY = { class: "table-cell text-center" }, ZY = { class: "percentage-value" }, KY = { class: "table-cell text-center" }, QY = { class: "percentage-value success" }, JY = {
  key: 1,
  class: "empty-state"
}, t6 = /* @__PURE__ */ le({
  __name: "checkinSegments",
  props: {
    data: { default: () => [] },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (c) => {
      r("export", c);
    }, { isDark: s } = _e(ye(n, "theme")), o = (c, h) => !h || h === 0 || !c ? "0%" : `${Math.round(c / h * 100)}%`, l = (c) => !c || c === "None" ? "-" : String(c).trim().replace(/_[0-9]+$/i, ""), u = (c) => {
      const h = l(c?.departure_airport), d = l(c?.arrival_airport);
      return h === "-" || d === "-" ? !1 : h === d;
    };
    return t({ isDark: s }), (c, h) => (A(), I("article", EY, [
      h[5] || (h[5] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Checkin Segments"),
          x("p", { class: "card-subtitle" }, "Breakdown by flight segment with connection when applicable")
        ])
      ], -1)),
      n.loading ? (A(), I("div", AY, [...h[0] || (h[0] = [
        Nt('<div class="loading-container" data-v-7e0d8a90><div class="chart-flow-loader" data-v-7e0d8a90><div class="flow-line flow-1" data-v-7e0d8a90></div><div class="flow-line flow-2" data-v-7e0d8a90></div><div class="flow-line flow-3" data-v-7e0d8a90></div><div class="flow-line flow-4" data-v-7e0d8a90></div><div class="flow-line flow-5" data-v-7e0d8a90></div></div><p class="loading-text" data-v-7e0d8a90>Loading segment data...</p></div>', 1)
      ])])) : (A(), I("div", PY, [
        n.data.length > 0 ? (A(), I("section", LY, [
          x("div", OY, [
            x("table", IY, [
              h[3] || (h[3] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Departure"),
                  x("th", { class: "table-header" }, "Connection"),
                  x("th", { class: "table-header" }, "Arrival"),
                  x("th", { class: "table-header" }, "Trip"),
                  x("th", { class: "table-header" }, "Init"),
                  x("th", { class: "table-header" }, "Started (%)"),
                  x("th", { class: "table-header" }, "Completed (%)"),
                  x("th", { class: "table-header" }, "Closed (%)")
                ])
              ], -1)),
              x("tbody", RY, [
                (A(!0), I(Rt, null, ce(n.data, (d, f) => (A(), I("tr", {
                  key: f,
                  class: "table-row"
                }, [
                  x("td", NY, [
                    x("span", FY, R(l(d.departure_airport)), 1)
                  ]),
                  x("td", BY, [
                    l(d.conexion_airport) !== "-" ? (A(), I("span", $Y, R(l(d.conexion_airport)), 1)) : (A(), I("span", zY, "-"))
                  ]),
                  x("td", VY, [
                    x("span", HY, R(l(d.arrival_airport)), 1)
                  ]),
                  x("td", YY, [
                    u(d) ? (A(), I("span", WY, [...h[1] || (h[1] = [
                      x("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        x("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M4 4v5h.582m15.356 2A8.001 8.001 0 004.582 9m0 0H9m11 11v-5h-.581m0 0a8.003 8.003 0 01-15.357-2m15.357 2H15"
                        })
                      ], -1),
                      _u(" Roundtrip ", -1)
                    ])])) : (A(), I("span", UY, [...h[2] || (h[2] = [
                      x("svg", {
                        class: "trip-icon",
                        fill: "none",
                        viewBox: "0 0 24 24",
                        stroke: "currentColor"
                      }, [
                        x("path", {
                          "stroke-linecap": "round",
                          "stroke-linejoin": "round",
                          "stroke-width": "2",
                          d: "M14 5l7 7m0 0l-7 7m7-7H3"
                        })
                      ], -1),
                      _u(" One way ", -1)
                    ])]))
                  ]),
                  x("td", GY, R(X(dt)(d.segment_init_count)), 1),
                  x("td", XY, [
                    x("span", jY, R(o(d.segment_started_count, d.segment_init_count)), 1)
                  ]),
                  x("td", qY, [
                    x("span", ZY, R(o(d.segment_completed_count, d.segment_init_count)), 1)
                  ]),
                  x("td", KY, [
                    x("span", QY, R(o(d.segment_closed_count, d.segment_init_count)), 1)
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: a
          })) : Q("", !0)
        ])) : (A(), I("section", JY, [...h[4] || (h[4] = [
          Nt('<div class="empty-state-content" data-v-7e0d8a90><div class="empty-icon-wrapper" data-v-7e0d8a90><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-7e0d8a90><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M3.055 11H5a2 2 0 012 2v1a2 2 0 002 2 2 2 0 012 2v2.945M8 3.935V5.5A2.5 2.5 0 0010.5 8h.5a2 2 0 012 2 2 2 0 104 0 2 2 0 012-2h1.064M15 20.488V18a2 2 0 012-2h3.064M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-7e0d8a90></path></svg></div><p class="empty-title" data-v-7e0d8a90>No segment data available</p><p class="empty-description" data-v-7e0d8a90>No flight segment data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), e6 = /* @__PURE__ */ te(t6, [["__scopeId", "data-v-7e0d8a90"]]), i6 = { class: "disruption-metrics-card" }, n6 = { class: "card-header" }, r6 = { class: "header-content" }, a6 = {
  key: 0,
  class: "payment-success-badge"
}, s6 = { class: "badge-value" }, o6 = {
  key: 0,
  class: "loading-state"
}, l6 = {
  key: 1,
  class: "card-body"
}, u6 = { class: "chart-section" }, c6 = { class: "chart-wrapper" }, h6 = {
  key: 1,
  class: "empty-chart"
}, d6 = {
  key: 0,
  class: "table-section"
}, f6 = { class: "table-wrapper" }, v6 = { class: "data-table" }, p6 = { class: "table-body" }, g6 = { class: "table-cell font-medium text-center" }, m6 = { class: "table-cell text-center" }, y6 = { class: "table-cell text-center" }, _6 = { class: "percentage-text" }, b6 = { class: "table-cell text-center" }, x6 = { class: "abandoned-value" }, w6 = { class: "table-cell" }, S6 = { class: "badges-container badges-wrap" }, M6 = { class: "badge badge-vol" }, k6 = { class: "badge badge-confirm" }, D6 = { class: "badge badge-not-confirm" }, T6 = { class: "badge badge-reject" }, C6 = { class: "badge badge-not-paid" }, E6 = { class: "badge badge-success" }, A6 = { class: "table-cell" }, P6 = { class: "badges-container badges-wrap" }, L6 = { class: "badge badge-inv" }, O6 = { class: "badge badge-human" }, I6 = { class: "badge badge-accept" }, R6 = {
  key: 1,
  class: "empty-state"
}, N6 = /* @__PURE__ */ le({
  __name: "Disruption",
  props: {
    data: { default: () => ({
      total_disruption_conversations: 0,
      total_disruption_initiated: 0,
      total_voluntary: 0,
      total_involuntary: 0,
      total_accepted: 0,
      total_confirmed: 0,
      total_sell_success: 0,
      total_sell_failed: 0,
      total_finished: 0,
      total_payment_success: 0,
      disruption_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = e, n = t, r = (u) => {
      n("export", u);
    }, a = q(() => i.data?.disruption_by_day ? [...i.data.disruption_by_day].sort(
      (u, c) => new Date(u.date).getTime() - new Date(c.date).getTime()
    ) : []), s = (u, c) => !c || c === 0 ? "0%" : `${Math.round(u / c * 100)}%`, o = q(() => {
      const u = i.data, c = u.total_disruption_conversations || 0, h = u.total_disruption_initiated || 0, d = u.total_voluntary || 0, f = u.total_involuntary || 0, v = u.total_accepted || 0, m = u.total_confirmed || 0, p = u.total_sell_success || 0, g = u.total_sell_failed || 0, y = Math.max(0, c - h), _ = Math.max(0, h - d - f), b = Math.max(0, f - v), w = Math.max(0, d - m), S = g, M = Math.max(0, m - p - S), k = (C, P) => {
        const L = P > 0 ? Math.round(C / P * 100) : 0;
        return `${C.toLocaleString()} (${L}%)`;
      }, T = [
        { name: "Initiated" },
        { name: "Started" },
        { name: "Voluntary" },
        { name: "Confirmed" },
        { name: "Paid" },
        { name: "Not Paid" },
        { name: "Rejected" },
        { name: "Not Confirmed" },
        { name: "Involuntary" },
        { name: "Accepted" },
        { name: "Redirect to Human" },
        { name: "Abandoned (Init)" },
        { name: "Abandoned (Start)" }
      ], D = [];
      return h > 0 && D.push({
        source: "Initiated",
        target: "Started",
        value: h,
        label: k(h, c)
      }), y > 0 && D.push({
        source: "Initiated",
        target: "Abandoned (Init)",
        value: y,
        label: k(y, c)
      }), d > 0 && D.push({
        source: "Started",
        target: "Voluntary",
        value: d,
        label: k(d, c)
      }), f > 0 && D.push({
        source: "Started",
        target: "Involuntary",
        value: f,
        label: k(f, c)
      }), _ > 0 && D.push({
        source: "Started",
        target: "Abandoned (Start)",
        value: _,
        label: k(_, c)
      }), v > 0 && D.push({
        source: "Involuntary",
        target: "Accepted",
        value: v,
        label: k(v, c)
      }), b > 0 && D.push({
        source: "Involuntary",
        target: "Redirect to Human",
        value: b,
        label: k(b, c)
      }), m > 0 && D.push({
        source: "Voluntary",
        target: "Confirmed",
        value: m,
        label: k(m, c)
      }), w > 0 && D.push({
        source: "Voluntary",
        target: "Not Confirmed",
        value: w,
        label: k(w, c)
      }), p > 0 && D.push({
        source: "Confirmed",
        target: "Paid",
        value: p,
        label: k(p, c)
      }), S > 0 && D.push({
        source: "Confirmed",
        target: "Rejected",
        value: S,
        label: k(S, c)
      }), M > 0 && D.push({
        source: "Confirmed",
        target: "Not Paid",
        value: M,
        label: k(M, c)
      }), { nodes: T, links: D };
    }), l = {
      Initiated: "#E5E7EB",
      Started: "#DBEAFE",
      "Abandoned (Start)": "#FEE2E2",
      Voluntary: "#FED7AA",
      Involuntary: "#E9D5FF",
      "Abandoned (Init)": "#FEE2E2",
      Accepted: "#86EFAC",
      "Redirect to Human": "#FCA5A5",
      Confirmed: "#BFDBFE",
      "Not Confirmed": "#FED7AA",
      Paid: "#86EFAC",
      Rejected: "#FCA5A5",
      "Not Paid": "#FED7AA"
    };
    return (u, c) => (A(), I("article", i6, [
      x("header", n6, [
        x("div", r6, [
          c[1] || (c[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Disruption Metrics"),
            x("p", { class: "card-subtitle" }, "Disruption workflow performance and completion tracking")
          ], -1)),
          i.loading ? Q("", !0) : (A(), I("div", a6, [
            c[0] || (c[0] = x("p", { class: "badge-label" }, "Payment Success", -1)),
            x("p", s6, R(X(dt)(i.data.total_payment_success || 0)), 1)
          ]))
        ])
      ]),
      i.loading ? (A(), I("div", o6, [...c[2] || (c[2] = [
        Nt('<div class="loading-container" data-v-5fae53dd><div class="chart-bars-loader" data-v-5fae53dd><div class="bar bar-1" data-v-5fae53dd></div><div class="bar bar-2" data-v-5fae53dd></div><div class="bar bar-3" data-v-5fae53dd></div><div class="bar bar-4" data-v-5fae53dd></div><div class="bar bar-5" data-v-5fae53dd></div></div><p class="loading-text" data-v-5fae53dd>Loading disruption data...</p></div>', 1)
      ])])) : (A(), I("div", l6, [
        x("section", u6, [
          x("div", c6, [
            o.value.nodes.length > 0 && o.value.links.length > 0 ? (A(), Re(pa, {
              key: 0,
              data: o.value,
              "node-colors": l,
              height: "500px"
            }, null, 8, ["data"])) : (A(), I("div", h6, [...c[3] || (c[3] = [
              x("p", { class: "empty-chart-text" }, "No disruption data available for visualization", -1)
            ])]))
          ])
        ]),
        a.value && a.value.length > 0 ? (A(), I("section", d6, [
          c[5] || (c[5] = Nt('<div class="section-header" data-v-5fae53dd><h4 class="section-title" data-v-5fae53dd>Daily Overview</h4></div><div class="legend-container" data-v-5fae53dd><p class="legend-title" data-v-5fae53dd>Legend</p><div class="legend-items" data-v-5fae53dd><div class="legend-group" data-v-5fae53dd><span class="legend-label" data-v-5fae53dd>Voluntary:</span><span class="badge badge-vol" data-v-5fae53dd>VOL</span></div><div class="legend-group" data-v-5fae53dd><span class="legend-label" data-v-5fae53dd>Involuntary:</span><span class="badge badge-inv" data-v-5fae53dd>INV</span></div><div class="legend-note" data-v-5fae53dd><span data-v-5fae53dd>Vol=Voluntary</span><span data-v-5fae53dd></span><span data-v-5fae53dd>Inv=Involuntary</span></div></div></div>', 2)),
          x("div", f6, [
            x("table", v6, [
              c[4] || (c[4] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Initiated"),
                  x("th", { class: "table-header" }, "Started"),
                  x("th", { class: "table-header" }, "Abandoned (%)"),
                  x("th", { class: "table-header" }, "Voluntary"),
                  x("th", { class: "table-header" }, "Involuntary")
                ])
              ], -1)),
              x("tbody", p6, [
                (A(!0), I(Rt, null, ce(a.value, (h) => (A(), I("tr", {
                  key: h.date,
                  class: "table-row"
                }, [
                  x("td", g6, R(X(H)(h.date).format("DD/MM")), 1),
                  x("td", m6, R(X(dt)(h.disruption_conversations)), 1),
                  x("td", y6, [
                    _u(R(X(dt)(h.disruption_initiated_count)) + " ", 1),
                    x("span", _6, " (" + R(s(h.disruption_initiated_count, h.disruption_conversations)) + ") ", 1)
                  ]),
                  x("td", b6, [
                    x("span", x6, R(X(dt)(h.disruption_initiated_count - h.voluntary_count - h.involuntary_count)) + " (" + R(s(h.disruption_initiated_count - h.voluntary_count - h.involuntary_count, h.disruption_conversations)) + ") ", 1)
                  ]),
                  x("td", w6, [
                    x("div", S6, [
                      x("span", M6, " VOL " + R(X(dt)(h.voluntary_count)) + " (" + R(s(h.voluntary_count, h.disruption_conversations)) + ") ", 1),
                      x("span", k6, " Confirm " + R(X(dt)(h.confirmed_count)) + " (" + R(s(h.confirmed_count, h.disruption_conversations)) + ") ", 1),
                      x("span", D6, " Not Confirm " + R(X(dt)(h.voluntary_count - h.confirmed_count)) + " (" + R(s(h.voluntary_count - h.confirmed_count, h.disruption_conversations)) + ") ", 1),
                      x("span", T6, " Reject " + R(X(dt)(h.sell_failed_count)) + " (" + R(s(h.sell_failed_count, h.disruption_conversations)) + ") ", 1),
                      x("span", C6, " Not Paid " + R(X(dt)(Math.max(0, h.confirmed_count - h.sell_success_count - h.sell_failed_count))) + " (" + R(s(Math.max(0, h.confirmed_count - h.sell_success_count - h.sell_failed_count), h.disruption_conversations)) + ") ", 1),
                      x("span", E6, " Finish " + R(X(dt)(h.sell_success_count)) + " (" + R(s(h.sell_success_count, h.disruption_conversations)) + ") ", 1)
                    ])
                  ]),
                  x("td", A6, [
                    x("div", P6, [
                      x("span", L6, " INV " + R(X(dt)(h.involuntary_count)) + " (" + R(s(h.involuntary_count, h.disruption_conversations)) + ") ", 1),
                      x("span", O6, " Human " + R(X(dt)(h.involuntary_count - h.accepted_count)) + " (" + R(s(h.involuntary_count - h.accepted_count, h.disruption_conversations)) + ") ", 1),
                      x("span", I6, " Accept " + R(X(dt)(h.accepted_count)) + " (" + R(s(h.accepted_count, h.disruption_conversations)) + ") ", 1)
                    ])
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: r
          })) : Q("", !0)
        ])) : (A(), I("section", R6, [...c[6] || (c[6] = [
          Nt('<div class="empty-state-content" data-v-5fae53dd><div class="empty-icon-wrapper" data-v-5fae53dd><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-5fae53dd><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z" data-v-5fae53dd></path></svg></div><p class="empty-title" data-v-5fae53dd>No disruption data available</p><p class="empty-description" data-v-5fae53dd>No disruption data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), F6 = /* @__PURE__ */ te(N6, [["__scopeId", "data-v-5fae53dd"]]), B6 = { class: "faq-metrics-card" }, $6 = {
  key: 0,
  class: "card-body"
}, z6 = { class: "kpi-grid" }, V6 = { class: "kpi-card" }, H6 = { class: "kpi-value" }, Y6 = { class: "kpi-card" }, W6 = { class: "kpi-value" }, U6 = { class: "kpi-card" }, G6 = { class: "kpi-value" }, X6 = { class: "kpi-card" }, j6 = { class: "kpi-value" }, q6 = { class: "kpi-card" }, Z6 = { class: "kpi-value" }, K6 = {
  key: 0,
  class: "chart-section"
}, Q6 = {
  key: 1,
  class: "empty-state"
}, J6 = {
  key: 1,
  class: "loading-state"
}, tW = /* @__PURE__ */ le({
  __name: "FAQ",
  props: {
    loading: { type: Boolean, default: !1 },
    data: { default: null },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (d) => {
      r("export", d);
    }, { isDark: s, colors: o } = _e(ye(n, "theme")), l = gi({ labels: [], datasets: [] }), u = q(() => n.data ?? {
      total_faq_events: 0,
      total_documents_found: 0,
      total_airline_information_retrieved: 0,
      total_booking_info_retrieved: 0,
      total_flight_status_retrieved: 0,
      faq_by_day: []
    }), c = q(() => ({
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12
            },
            color: o.value.textSecondary
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: o.value.tooltipBg,
          titleColor: o.value.tooltipText,
          bodyColor: o.value.textSecondary,
          borderColor: s.value ? "rgba(198, 125, 255, 0.2)" : "rgba(0, 0, 0, 0.1)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'Space Grotesk', sans-serif",
            size: 14,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 13
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: o.value.textSecondary
          }
        },
        y: {
          type: "linear",
          display: !0,
          position: "left",
          beginAtZero: !0,
          grid: {
            color: o.value.gridLines
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: o.value.textSecondary
          }
        }
      },
      interaction: {
        mode: "nearest",
        axis: "x",
        intersect: !1
      }
    })), h = (d) => {
      if (!d) {
        l.value = { labels: [], datasets: [] };
        return;
      }
      const f = d.faq_by_day || [];
      if (f.length > 0) {
        const v = f.map((y) => H(y.date).format("MMM DD")), m = f.map((y) => y.airline_information_retrieved_count || 0), p = f.map((y) => y.flight_status_retrieved_count || 0), g = f.map((y) => y.booking_info_retrieved_count || 0);
        l.value = {
          labels: v,
          datasets: [
            {
              label: "Airline Information",
              data: m,
              borderColor: "#8b5cf6",
              backgroundColor: "rgba(139, 92, 246, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#8b5cf6",
              pointBorderColor: "#7c3aed",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Flight Status",
              data: p,
              borderColor: "#06b6d4",
              backgroundColor: "rgba(6, 182, 212, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#06b6d4",
              pointBorderColor: "#0891b2",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            },
            {
              label: "Booking Information",
              data: g,
              borderColor: "#f59e0b",
              backgroundColor: "rgba(245, 158, 11, 0.1)",
              borderWidth: 2,
              fill: !0,
              tension: 0.4,
              pointBackgroundColor: "#f59e0b",
              pointBorderColor: "#d97706",
              pointBorderWidth: 2,
              pointRadius: 4,
              pointHoverRadius: 6
            }
          ]
        };
      } else
        l.value = { labels: [], datasets: [] };
    };
    return ns(
      () => n.data,
      (d) => {
        h(d ?? null);
      },
      { deep: !0, immediate: !0 }
    ), t({ isDark: s }), (d, f) => (A(), I("article", B6, [
      f[7] || (f[7] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "FAQ Metrics"),
          x("p", { class: "card-subtitle" }, "Daily FAQ consultation and retrieval metrics")
        ])
      ], -1)),
      n.loading ? (A(), I("div", J6, [...f[6] || (f[6] = [
        Nt('<div class="loading-container" data-v-3ff47164><div class="chart-bars-loader" data-v-3ff47164><div class="bar bar-1" data-v-3ff47164></div><div class="bar bar-2" data-v-3ff47164></div><div class="bar bar-3" data-v-3ff47164></div><div class="bar bar-4" data-v-3ff47164></div><div class="bar bar-5" data-v-3ff47164></div></div><p class="loading-text" data-v-3ff47164>Loading FAQ metrics...</p></div>', 1)
      ])])) : (A(), I("div", $6, [
        x("div", z6, [
          x("div", V6, [
            f[0] || (f[0] = x("span", { class: "kpi-label" }, "Total FAQ", -1)),
            x("span", H6, R(X(dt)(u.value.total_faq_events)), 1)
          ]),
          x("div", Y6, [
            f[1] || (f[1] = x("span", { class: "kpi-label" }, "Documents Found", -1)),
            x("span", W6, R(X(dt)(u.value.total_documents_found)), 1)
          ]),
          x("div", U6, [
            f[2] || (f[2] = x("span", { class: "kpi-label" }, "Airline Info", -1)),
            x("span", G6, R(X(dt)(u.value.total_airline_information_retrieved)), 1)
          ]),
          x("div", X6, [
            f[3] || (f[3] = x("span", { class: "kpi-label" }, "Booking Info", -1)),
            x("span", j6, R(X(dt)(u.value.total_booking_info_retrieved)), 1)
          ]),
          x("div", q6, [
            f[4] || (f[4] = x("span", { class: "kpi-label" }, "Flight Status", -1)),
            x("span", Z6, R(X(dt)(u.value.total_flight_status_retrieved)), 1)
          ])
        ]),
        l.value.labels && l.value.labels.length ? (A(), I("section", K6, [
          fe(_v, {
            data: l.value,
            options: c.value
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: a
          })) : Q("", !0)
        ])) : (A(), I("section", Q6, [...f[5] || (f[5] = [
          Nt('<div class="empty-state-content" data-v-3ff47164><div class="empty-icon-wrapper" data-v-3ff47164><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-3ff47164><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12h6m-6 4h6m2 5H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z" data-v-3ff47164></path></svg></div><p class="empty-title" data-v-3ff47164>No FAQ data available</p><p class="empty-description" data-v-3ff47164>No FAQ consultation data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), eW = /* @__PURE__ */ te(tW, [["__scopeId", "data-v-3ff47164"]]), iW = { class: "messages-per-agent-card" }, nW = {
  key: 0,
  class: "card-body"
}, rW = {
  key: 0,
  class: "chart-section"
}, aW = {
  key: 1,
  class: "empty-state"
}, sW = { class: "empty-state-content" }, oW = { class: "empty-icon-wrapper" }, lW = {
  key: 1,
  class: "loading-state"
}, uW = /* @__PURE__ */ le({
  __name: "MessagesPerAgent",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, r = e, a = i, s = (h) => {
      a("export", h);
    }, { isDark: o, colors: l } = _e(ye(r, "theme")), u = q(() => {
      const h = r.data?.agents_by_day || {}, d = Object.keys(h).sort();
      if (d.length === 0)
        return { labels: [], datasets: [] };
      const f = /* @__PURE__ */ new Set();
      for (const p of Object.values(h))
        for (const g of Object.keys(p))
          f.add(g);
      const m = Array.from(f).map((p) => {
        const g = n[p] || "#94a3b8";
        return {
          label: p.charAt(0).toUpperCase() + p.slice(1).replace(/_/g, " "),
          data: d.map((y) => h[y]?.[p] || 0),
          borderColor: g,
          backgroundColor: `${g}20`,
          pointBackgroundColor: g,
          pointBorderColor: o.value ? "#1a1a1d" : "#ffffff",
          pointBorderWidth: 2,
          pointRadius: 5,
          pointHoverRadius: 7,
          tension: 0.3,
          fill: !1
        };
      });
      return {
        labels: d,
        datasets: m
      };
    }), c = q(() => r.options ? r.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          display: !0,
          position: "top",
          align: "end",
          labels: {
            usePointStyle: !0,
            pointStyle: "circle",
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 12,
              weight: 500
            },
            color: l.value.textSecondary
          }
        },
        tooltip: {
          mode: "index",
          intersect: !1,
          backgroundColor: l.value.tooltipBg,
          titleColor: l.value.tooltipText,
          bodyColor: l.value.tooltipText,
          borderColor: o.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          }
        }
      },
      scales: {
        x: {
          display: !0,
          grid: {
            display: !1
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: l.value.textSecondary
          }
        },
        y: {
          display: !0,
          beginAtZero: !0,
          grid: {
            color: l.value.gridLines
          },
          ticks: {
            font: {
              family: "'DM Sans', sans-serif",
              size: 11
            },
            color: l.value.textSecondary
          }
        }
      }
    });
    return t({ isDark: o }), (h, d) => (A(), I("article", iW, [
      d[3] || (d[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Messages per Agent"),
          x("p", { class: "card-subtitle" }, "Agent interaction trends over time")
        ])
      ], -1)),
      e.loading ? (A(), I("div", lW, [...d[2] || (d[2] = [
        Nt('<div class="loading-container" data-v-9aac0798><div class="chart-lines-loader" data-v-9aac0798><div class="line line-1" data-v-9aac0798></div><div class="line line-2" data-v-9aac0798></div><div class="line line-3" data-v-9aac0798></div><div class="line line-4" data-v-9aac0798></div><div class="line line-5" data-v-9aac0798></div></div><p class="loading-text" data-v-9aac0798>Loading chart data...</p></div>', 1)
      ])])) : (A(), I("div", nW, [
        u.value.labels && u.value.labels.length ? (A(), I("section", rW, [
          fe(_v, {
            data: u.value,
            options: c.value
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: s
          })) : Q("", !0)
        ])) : (A(), I("section", aW, [
          x("div", sW, [
            x("div", oW, [
              fe(X(Sp), { class: "empty-icon" })
            ]),
            d[0] || (d[0] = x("p", { class: "empty-title" }, "No agent interactions data", -1)),
            d[1] || (d[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), cW = /* @__PURE__ */ te(uW, [["__scopeId", "data-v-9aac0798"]]), hW = { class: "record-locator-card" }, dW = {
  key: 0,
  class: "loading-state"
}, fW = {
  key: 1,
  class: "card-body"
}, vW = {
  key: 0,
  class: "chart-section"
}, pW = { class: "chart-wrapper" }, gW = {
  key: 1,
  class: "table-section"
}, mW = { class: "table-wrapper" }, yW = { class: "data-table" }, _W = { class: "table-header-row" }, bW = {
  key: 0,
  class: "table-header"
}, xW = {
  key: 1,
  class: "table-header"
}, wW = { class: "table-body" }, SW = { class: "table-cell font-medium" }, MW = { class: "table-cell text-center" }, kW = { class: "table-cell text-center" }, DW = { class: "table-cell text-center" }, TW = { class: "table-cell text-center" }, CW = { class: "table-cell text-center success-value" }, EW = { class: "table-cell text-center failed-value" }, AW = { class: "table-cell text-center warning-value" }, PW = {
  key: 0,
  class: "table-cell text-center"
}, LW = {
  key: 1,
  class: "table-cell text-center failed-value"
}, OW = {
  key: 2,
  class: "empty-state"
}, IW = /* @__PURE__ */ le({
  __name: "RecordLocator",
  props: {
    data: { default: () => ({
      total_checkin_initiated: 0,
      total_record_locator_init: 0,
      total_record_locator_started: 0,
      total_record_locator_completed: 0,
      total_record_locator_closed: 0,
      total_record_locator_failed: 0,
      total_record_locator_abandoned: 0,
      total_record_locator_init_abandoned: 0,
      record_locator_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    isAvianca: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (f) => {
      r("export", f);
    }, { isDark: s } = _e(ye(n, "theme")), o = q(() => n.data?.record_locator_by_day ? [...n.data.record_locator_by_day].sort(
      (f, v) => new Date(f.date).getTime() - new Date(v.date).getTime()
    ) : []), l = q(() => n.data), u = q(() => ({
      // Main flow progression - from blue to cyan to green
      "Checkin Init": "#93C5FD",
      // Blue for started state
      "Booking retrive": "#67E8F9",
      // Light cyan
      "Checkin Started": "#22D3EE",
      // Medium cyan
      "Checkin Completed": "#A7F3D0",
      // Light green
      "Checkin Closed": "#7BE39E",
      // Green for success
      // Abandoned states - progressive red
      "Abandoned (Init)": "#FCA5A5",
      // Light red
      "Abandoned (Started)": "#F87171",
      // Medium red
      "Abandoned (Flow)": "#EF4444",
      // Darker red
      // Failed states
      "Checkin Failed": "#F87171"
      // Medium red for main failed node
    })), c = (f, v) => !v || v === 0 ? "0%" : `${Math.round(f / v * 100)}%`, h = (f, v) => {
      const m = dt(f), p = c(f, v);
      return `${m} (${p})`;
    }, d = q(() => {
      const f = [], v = [];
      if (!l.value.total_checkin_initiated)
        return { nodes: f, links: v };
      f.push({ name: "Checkin Init" }), f.push({ name: "Booking retrive" }), f.push({ name: "Checkin Started" }), f.push({ name: "Checkin Completed" }), f.push({ name: "Checkin Closed" });
      const m = l.value.total_checkin_initiated, p = l.value.total_record_locator_init, g = l.value.total_record_locator_started, y = l.value.total_record_locator_completed, _ = l.value.total_record_locator_closed, b = l.value.total_record_locator_failed, w = l.value.total_record_locator_abandoned, S = l.value.total_record_locator_init_abandoned;
      if (p > 0) {
        const k = Math.round(p / m * 100);
        v.push({
          source: "Checkin Init",
          target: "Booking retrive",
          value: p,
          label: `${p.toLocaleString()} (${k}%)`
        });
      }
      const M = m - p;
      if (M > 0) {
        const k = Math.round(M / m * 100);
        f.push({ name: "Abandoned (Init)" }), v.push({
          source: "Checkin Init",
          target: "Abandoned (Init)",
          value: M,
          label: `${M.toLocaleString()} (${k}%)`
        });
      }
      if (g > 0) {
        const k = Math.round(g / m * 100);
        v.push({
          source: "Booking retrive",
          target: "Checkin Started",
          value: g,
          label: `${g.toLocaleString()} (${k}%)`
        });
      }
      if (S > 0) {
        const k = Math.round(S / m * 100);
        f.push({ name: "Abandoned (Started)" }), v.push({
          source: "Booking retrive",
          target: "Abandoned (Started)",
          value: S,
          label: `${S.toLocaleString()} (${k}%)`
        });
      }
      if (y > 0) {
        const k = Math.round(y / g * 100);
        v.push({
          source: "Checkin Started",
          target: "Checkin Completed",
          value: y,
          label: `${y.toLocaleString()} (${k}%)`
        });
      }
      if (_ > 0) {
        const k = Math.round(_ / g * 100);
        v.push({
          source: "Checkin Completed",
          target: "Checkin Closed",
          value: _,
          label: `${_.toLocaleString()} (${k}%)`
        });
      }
      if (b > 0) {
        const k = Math.round(b / g * 100);
        f.push({ name: "Checkin Failed" }), v.push({
          source: "Checkin Started",
          target: "Checkin Failed",
          value: b,
          label: `${b.toLocaleString()} (${k}%)`
        });
      }
      if (w > 0) {
        const k = Math.round(w / g * 100);
        f.push({ name: "Abandoned (Flow)" }), v.push({
          source: "Checkin Started",
          target: "Abandoned (Flow)",
          value: w,
          label: `${w.toLocaleString()} (${k}%)`
        });
      }
      return { nodes: f, links: v };
    });
    return t({ isDark: s }), (f, v) => (A(), I("article", hW, [
      v[10] || (v[10] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Checkin by Record Locator Metrics"),
          x("p", { class: "card-subtitle" }, "Checkin by record locator retrieval and completion analysis")
        ])
      ], -1)),
      n.loading ? (A(), I("div", dW, [...v[0] || (v[0] = [
        Nt('<div class="loading-container" data-v-f0077a21><div class="chart-flow-loader" data-v-f0077a21><div class="flow-line flow-1" data-v-f0077a21></div><div class="flow-line flow-2" data-v-f0077a21></div><div class="flow-line flow-3" data-v-f0077a21></div><div class="flow-line flow-4" data-v-f0077a21></div><div class="flow-line flow-5" data-v-f0077a21></div></div><p class="loading-text" data-v-f0077a21>Loading record locator data...</p></div>', 1)
      ])])) : (A(), I("div", fW, [
        d.value.nodes.length > 0 ? (A(), I("section", vW, [
          x("div", pW, [
            fe(pa, {
              data: d.value,
              height: "500px",
              "node-colors": u.value,
              "use-gradient": !1,
              "node-gap": 30
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : Q("", !0),
        o.value && o.value.length > 0 ? (A(), I("section", gW, [
          x("div", mW, [
            x("table", yW, [
              x("thead", null, [
                x("tr", _W, [
                  v[1] || (v[1] = x("th", { class: "table-header" }, "Date", -1)),
                  v[2] || (v[2] = x("th", { class: "table-header" }, "Checkin Init", -1)),
                  v[3] || (v[3] = x("th", { class: "table-header" }, "Booking Retrieve (%)", -1)),
                  v[4] || (v[4] = x("th", { class: "table-header" }, "Checkin Started", -1)),
                  v[5] || (v[5] = x("th", { class: "table-header" }, "Checkin Completed (%)", -1)),
                  v[6] || (v[6] = x("th", { class: "table-header" }, "Checkin Closed (%)", -1)),
                  v[7] || (v[7] = x("th", { class: "table-header" }, "Checkin Failed (%)", -1)),
                  v[8] || (v[8] = x("th", { class: "table-header" }, "Abandoned (%)", -1)),
                  n.isAvianca ? (A(), I("th", bW, "Create Payment")) : Q("", !0),
                  n.isAvianca ? (A(), I("th", xW, "Failed Payment")) : Q("", !0)
                ])
              ]),
              x("tbody", wW, [
                (A(!0), I(Rt, null, ce(o.value, (m) => (A(), I("tr", {
                  key: m.date,
                  class: "table-row"
                }, [
                  x("td", SW, R(X(H)(m.date).format("DD/MM/YYYY")), 1),
                  x("td", MW, R(X(dt)(m.checkin_initiated)), 1),
                  x("td", kW, R(h(m.record_locator_init_count, m.checkin_initiated)), 1),
                  x("td", DW, R(X(dt)(m.record_locator_started_count)), 1),
                  x("td", TW, R(h(m.record_locator_completed_count, m.record_locator_started_count)), 1),
                  x("td", CW, R(h(m.record_locator_closed_count, m.record_locator_started_count)), 1),
                  x("td", EW, R(h(m.record_locator_failed_count, m.record_locator_started_count)), 1),
                  x("td", AW, R(h(m.record_locator_abandoned_count, m.record_locator_started_count)), 1),
                  n.isAvianca ? (A(), I("td", PW, R(X(dt)(m.record_locator_create_payment_count)), 1)) : Q("", !0),
                  n.isAvianca ? (A(), I("td", LW, R(X(dt)(m.record_locator_create_payment_failed_count)), 1)) : Q("", !0)
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: a
          })) : Q("", !0)
        ])) : (A(), I("section", OW, [...v[9] || (v[9] = [
          Nt('<div class="empty-state-content" data-v-f0077a21><div class="empty-icon-wrapper" data-v-f0077a21><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-f0077a21><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01" data-v-f0077a21></path></svg></div><p class="empty-title" data-v-f0077a21>No record locator data available</p><p class="empty-description" data-v-f0077a21>No record locator data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])]))
      ]))
    ]));
  }
}), RW = /* @__PURE__ */ te(IW, [["__scopeId", "data-v-f0077a21"]]), NW = { class: "seller-metrics-card" }, FW = { class: "card-header" }, BW = { class: "header-content" }, $W = {
  key: 0,
  class: "stats-badge"
}, zW = { class: "badge-value" }, VW = {
  key: 0,
  class: "loading-state"
}, HW = {
  key: 1,
  class: "card-body"
}, YW = {
  key: 0,
  class: "chart-section"
}, WW = { class: "chart-wrapper" }, UW = {
  key: 1,
  class: "empty-state"
}, GW = {
  key: 2,
  class: "table-section"
}, XW = { class: "table-wrapper" }, jW = { class: "data-table" }, qW = { class: "table-body" }, ZW = { class: "table-cell font-medium" }, KW = { class: "table-cell text-center" }, QW = { class: "table-cell text-center" }, JW = { class: "table-cell text-center" }, t9 = { class: "table-cell text-center" }, e9 = { class: "table-cell text-center" }, i9 = { class: "table-cell text-center success-value" }, n9 = { class: "table-cell text-left" }, r9 = {
  key: 0,
  class: "failed-reasons"
}, a9 = { class: "reason-name" }, s9 = { class: "reason-count" }, o9 = {
  key: 1,
  class: "empty-cell"
}, l9 = /* @__PURE__ */ le({
  __name: "Seller",
  props: {
    sellerData: { default: () => ({
      total_seller_conversations: 0,
      total_sell_started: 0,
      total_sell_get_quote: 0,
      total_sell_booking_created: 0,
      total_sell_success: 0,
      total_value_sell_success: 0,
      seller_by_day: []
    }) },
    failedData: { default: () => ({
      total_sell_failed: 0,
      failed_by_reason_by_day: []
    }) },
    loading: { type: Boolean, default: !1 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = e, r = i, a = (m) => {
      r("export", m);
    }, { isDark: s } = _e(ye(n, "theme")), o = q(() => {
      if (!n.sellerData?.seller_by_day) return [];
      const m = [...n.sellerData.seller_by_day];
      return n.failedData?.failed_by_reason_by_day && n.failedData.failed_by_reason_by_day.forEach((p) => {
        const g = m.findIndex((y) => y.date === p.date);
        g !== -1 ? m[g] = { ...m[g], reasons: p.reasons } : m.push({
          date: p.date,
          seller_conversations: 0,
          sell_started_count: 0,
          sell_get_quote_count: 0,
          sell_booking_created_count: 0,
          sell_success_count: 0,
          daily_value_sell_success: 0,
          reasons: p.reasons
        });
      }), m.sort((p, g) => new Date(p.date).getTime() - new Date(g.date).getTime());
    }), l = q(() => n.sellerData), u = q(() => n.failedData), c = q(() => {
      const {
        total_seller_conversations: m = 0,
        total_sell_started: p = 0,
        total_sell_booking_created: g = 0,
        total_sell_success: y = 0
      } = l.value, { failed_by_reason_by_day: _ = [] } = u.value;
      if (m === 0) return { nodes: [], links: [] };
      const b = [
        { name: "Sell Initiated", value: m },
        { name: "Sell Started", value: p },
        { name: "Booking Created", value: g },
        { name: "Sell Success", value: y }
      ], w = [], S = m - p;
      if (S > 0) {
        const D = Math.round(S / m * 100);
        b.push({ name: "Abandoned (Init)", value: S }), w.push({
          source: "Sell Initiated",
          target: "Abandoned (Init)",
          value: S,
          label: `${S.toLocaleString()} (${D}%)`
        });
      }
      if (p > 0) {
        const D = Math.round(p / m * 100);
        w.push({
          source: "Sell Initiated",
          target: "Sell Started",
          value: p,
          label: `${p.toLocaleString()} (${D}%)`
        });
      }
      const M = _.reduce((D, C) => (C.reasons && Array.isArray(C.reasons) && C.reasons.forEach((P) => {
        const L = P.reason, O = P.failed_count;
        D[L] = (D[L] || 0) + O;
      }), D), {});
      if (g > 0) {
        const D = Math.round(g / m * 100);
        w.push({
          source: "Sell Started",
          target: "Booking Created",
          value: g,
          label: `${g.toLocaleString()} (${D}%)`
        });
      }
      if (y > 0) {
        const D = Math.round(y / m * 100);
        w.push({
          source: "Booking Created",
          target: "Sell Success",
          value: y,
          label: `${y.toLocaleString()} (${D}%)`
        });
      }
      const k = p - g;
      if (k > 0) {
        const D = Math.round(k / m * 100);
        b.push({ name: "Failed at Booking", value: k }), w.push({
          source: "Sell Started",
          target: "Failed at Booking",
          value: k,
          label: `${k.toLocaleString()} (${D}%)`
        });
      }
      if (Object.keys(M).length > 0) {
        const D = Object.values(M).reduce((P, L) => P + L, 0), C = k - D;
        if (Object.entries(M).filter(([, P]) => P > 0).sort(([, P], [, L]) => L - P).forEach(([P, L]) => {
          const O = Math.round(L / m * 100);
          b.push({ name: `Failed: ${P}`, value: L }), w.push({
            source: "Failed at Booking",
            target: `Failed: ${P}`,
            value: L,
            label: `${L.toLocaleString()} (${O}%)`
          });
        }), C > 0) {
          const P = Math.round(C / m * 100);
          b.push({ name: "Failed: Without Reason", value: C }), w.push({
            source: "Failed at Booking",
            target: "Failed: Without Reason",
            value: C,
            label: `${C.toLocaleString()} (${P}%)`
          });
        }
      }
      const T = g - y;
      if (T > 0) {
        const D = Math.round(T / m * 100);
        b.push({ name: "Failed at Completion", value: T }), w.push({
          source: "Booking Created",
          target: "Failed at Completion",
          value: T,
          label: `${T.toLocaleString()} (${D}%)`
        });
      }
      return { nodes: b, links: w };
    }), h = {
      "Sell Initiated": "#DBEAFE",
      "Abandoned (Init)": "#FEE2E2",
      "Sell Started": "#93C5FD",
      "Get Quote": "#C7D2FE",
      "Booking Created": "#8B8CF6",
      "Sell Success": "#7BE39E",
      "Sell Failed": "#FCA5A5",
      "Failed at Quote": "#FCA5A5",
      "Failed at Booking": "#F87171",
      "Failed at Completion": "#EF4444",
      "Failed: rejected": "#F87171",
      "Failed: payment_processing": "#EF4444",
      "Failed: seat_selection": "#F87171",
      "Failed: booking_validation": "#EF4444",
      "Failed: flight_availability": "#DC2626",
      "Failed: passenger_data": "#F87171",
      "Failed: system_error": "#DC2626",
      "Failed: timeout": "#EF4444",
      "Failed: Without Reason": "#F87171"
    }, d = q(() => h), f = (m, p) => !p || p === 0 ? "0%" : `${Math.round(m / p * 100)}%`, v = (m, p) => {
      const g = dt(m), y = f(m, p);
      return `${g} (${y})`;
    };
    return t({ isDark: s }), (m, p) => (A(), I("article", NW, [
      x("header", FW, [
        x("div", BW, [
          p[1] || (p[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "Seller Metrics"),
            x("p", { class: "card-subtitle" }, "Sales performance and failure analysis")
          ], -1)),
          n.loading ? Q("", !0) : (A(), I("div", $W, [
            p[0] || (p[0] = x("p", { class: "badge-label" }, "Total Sales Value", -1)),
            x("p", zW, R(X(Y_)(n.sellerData.total_value_sell_success)), 1)
          ]))
        ])
      ]),
      n.loading ? (A(), I("div", VW, [...p[2] || (p[2] = [
        Nt('<div class="loading-container" data-v-0a358f99><div class="chart-flow-loader" data-v-0a358f99><div class="flow-line flow-1" data-v-0a358f99></div><div class="flow-line flow-2" data-v-0a358f99></div><div class="flow-line flow-3" data-v-0a358f99></div><div class="flow-line flow-4" data-v-0a358f99></div><div class="flow-line flow-5" data-v-0a358f99></div></div><p class="loading-text" data-v-0a358f99>Loading sales data...</p></div>', 1)
      ])])) : (A(), I("div", HW, [
        c.value.nodes.length > 0 ? (A(), I("section", YW, [
          x("div", WW, [
            fe(pa, {
              data: c.value,
              "node-colors": d.value,
              title: "",
              height: "320px"
            }, null, 8, ["data", "node-colors"])
          ])
        ])) : (A(), I("section", UW, [...p[3] || (p[3] = [
          Nt('<div class="empty-state-content" data-v-0a358f99><div class="empty-icon-wrapper" data-v-0a358f99><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-0a358f99><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8c-1.657 0-3 .895-3 2s1.343 2 3 2 3 .895 3 2-1.343 2-3 2m0-8c1.11 0 2.08.402 2.599 1M12 8V7m0 1v8m0 0v1m0-1c-1.11 0-2.08-.402-2.599-1M21 12a9 9 0 11-18 0 9 9 0 0118 0z" data-v-0a358f99></path></svg></div><p class="empty-title" data-v-0a358f99>No sales data available</p><p class="empty-description" data-v-0a358f99>No sales data found for the selected period. Try adjusting the date range.</p></div>', 1)
        ])])),
        o.value && o.value.length > 0 ? (A(), I("section", GW, [
          x("div", XW, [
            x("table", jW, [
              p[4] || (p[4] = x("thead", null, [
                x("tr", { class: "table-header-row" }, [
                  x("th", { class: "table-header" }, "Date"),
                  x("th", { class: "table-header" }, "Sell Initiated"),
                  x("th", { class: "table-header" }, "Sell Started"),
                  x("th", { class: "table-header" }, "Get Quote"),
                  x("th", { class: "table-header" }, "Booking Created"),
                  x("th", { class: "table-header" }, "Sell Success"),
                  x("th", { class: "table-header" }, "Total Sales Value"),
                  x("th", { class: "table-header" }, "Failed")
                ])
              ], -1)),
              x("tbody", qW, [
                (A(!0), I(Rt, null, ce(o.value, (g) => (A(), I("tr", {
                  key: g.date,
                  class: "table-row"
                }, [
                  x("td", ZW, R(X(H)(g.date).format("DD/MM/YYYY")), 1),
                  x("td", KW, R(X(dt)(g.seller_conversations || 0)), 1),
                  x("td", QW, R(v(g.sell_started_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", JW, R(v(g.sell_get_quote_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", t9, R(v(g.sell_booking_created_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", e9, R(v(g.sell_success_count, g.seller_conversations || g.sell_started_count)), 1),
                  x("td", i9, R(X(Y_)(g.daily_value_sell_success)), 1),
                  x("td", n9, [
                    g.reasons && g.reasons.length > 0 ? (A(), I("div", r9, [
                      (A(!0), I(Rt, null, ce(g.reasons, (y) => (A(), I("div", {
                        key: y.reason,
                        class: "failed-reason-item"
                      }, [
                        x("span", a9, R(y.reason) + ":", 1),
                        x("span", s9, R(y.failed_count), 1)
                      ]))), 128))
                    ])) : (A(), I("div", o9, "-"))
                  ])
                ]))), 128))
              ])
            ])
          ]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: a
          })) : Q("", !0)
        ])) : Q("", !0)
      ]))
    ]));
  }
}), u9 = /* @__PURE__ */ te(l9, [["__scopeId", "data-v-0a358f99"]]), c9 = { class: "top-agents-card" }, h9 = {
  key: 0,
  class: "card-body"
}, d9 = {
  key: 0,
  class: "chart-section"
}, f9 = {
  key: 1,
  class: "empty-state"
}, v9 = { class: "empty-state-content" }, p9 = { class: "empty-icon-wrapper" }, g9 = {
  key: 1,
  class: "loading-state"
}, m9 = /* @__PURE__ */ le({
  __name: "TopAgents",
  props: {
    data: { default: () => ({}) },
    loading: { type: Boolean, default: !1 },
    options: { default: void 0 },
    theme: { default: void 0 },
    enableExport: { type: Boolean, default: !1 }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = {
      checkin: "#3B82F6",
      faq: "#EF4444",
      disruption_manager: "#F59E0B",
      booking_manager: "#a78bfa",
      triage: "#10B981",
      seller: "#06B6D4",
      human: "#F472B6",
      agency: "#6366F1",
      loyalty: "#EAB308"
    }, r = e, a = i, s = (h) => {
      a("export", h);
    }, { isDark: o, colors: l } = _e(ye(r, "theme")), u = q(() => {
      const d = (r.data?.top_agents || []).filter(
        (p) => p.agent_type?.toLowerCase() !== "triage"
      );
      if (d.length === 0)
        return { labels: [], datasets: [] };
      const f = d.reduce(
        (p, g) => p + (Number(g.conversations) || 0),
        0
      ), v = d.map((p) => {
        const g = p.agent_type?.toLowerCase();
        return n[g] || "#94a3b8";
      }), m = v.map((p) => `${p}80`);
      return {
        labels: d.map((p) => {
          const g = Number(p.conversations) || 0, y = f ? g / f * 100 : 0;
          return `${p.agent_type} - ${g.toLocaleString()} (${y.toFixed(1)}%)`;
        }),
        datasets: [
          {
            data: d.map((p) => p.conversations),
            backgroundColor: m,
            borderColor: v,
            borderWidth: 2
          }
        ]
      };
    }), c = q(() => r.options ? r.options : {
      responsive: !0,
      maintainAspectRatio: !1,
      plugins: {
        legend: {
          position: "bottom",
          labels: {
            usePointStyle: !0,
            padding: 20,
            font: {
              family: "'DM Sans', sans-serif",
              size: 13,
              weight: 500
            },
            color: l.value.textSecondary
          }
        },
        tooltip: {
          enabled: !0,
          backgroundColor: l.value.tooltipBg,
          titleColor: l.value.tooltipText,
          bodyColor: l.value.tooltipText,
          borderColor: o.value ? "rgba(198, 125, 255, 0.2)" : "rgba(148, 163, 184, 0.2)",
          borderWidth: 1,
          padding: 12,
          cornerRadius: 8,
          titleFont: {
            family: "'DM Sans', sans-serif",
            size: 13,
            weight: 600
          },
          bodyFont: {
            family: "'DM Sans', sans-serif",
            size: 12,
            weight: 500
          },
          callbacks: {
            label: (h) => {
              const d = (h.label || "").toString().split(" - ")[0], f = Number(h.parsed) || 0, v = (h.dataset.data || []).reduce(
                (p, g) => p + (Number(g) || 0),
                0
              ), m = v ? f / v * 100 : 0;
              return `${d}: ${f.toLocaleString()} (${m.toFixed(1)}%)`;
            }
          }
        }
      }
    });
    return t({ isDark: o }), (h, d) => (A(), I("article", c9, [
      d[3] || (d[3] = x("header", { class: "card-header" }, [
        x("div", { class: "header-content" }, [
          x("h3", { class: "card-title" }, "Top Agents"),
          x("p", { class: "card-subtitle" }, "Interactions by agent (excluding triage)")
        ])
      ], -1)),
      e.loading ? (A(), I("div", g9, [...d[2] || (d[2] = [
        Nt('<div class="loading-container" data-v-404133bb><div class="chart-lines-loader" data-v-404133bb><div class="line line-1" data-v-404133bb></div><div class="line line-2" data-v-404133bb></div><div class="line line-3" data-v-404133bb></div><div class="line line-4" data-v-404133bb></div><div class="line line-5" data-v-404133bb></div></div><p class="loading-text" data-v-404133bb>Loading chart data...</p></div>', 1)
      ])])) : (A(), I("div", h9, [
        u.value.labels && u.value.labels.length ? (A(), I("section", d9, [
          fe(qb, {
            data: u.value,
            options: c.value
          }, null, 8, ["data", "options"]),
          e.enableExport ? (A(), Re(X(ei), {
            key: 0,
            onExport: s
          })) : Q("", !0)
        ])) : (A(), I("section", f9, [
          x("div", v9, [
            x("div", p9, [
              fe(X(z4), { class: "empty-icon" })
            ]),
            d[0] || (d[0] = x("p", { class: "empty-title" }, "No top agents data", -1)),
            d[1] || (d[1] = x("p", { class: "empty-description" }, "Try adjusting the date range or check your filters to see agent interaction trends.", -1))
          ])
        ]))
      ]))
    ]));
  }
}), y9 = /* @__PURE__ */ te(m9, [["__scopeId", "data-v-404133bb"]]), _9 = { class: "nps-daily-card" }, b9 = { class: "card-header" }, x9 = { class: "header-content" }, w9 = {
  key: 0,
  class: "stats-badge"
}, S9 = { class: "badge-value" }, M9 = {
  key: 0,
  class: "loading-state"
}, k9 = {
  key: 1,
  class: "card-body"
}, D9 = { class: "tooltip-content" }, T9 = { class: "tooltip-title" }, C9 = { class: "tooltip-stats" }, E9 = { class: "tooltip-stat-row" }, A9 = { class: "tooltip-value" }, P9 = { class: "tooltip-stat-row" }, L9 = { class: "tooltip-value" }, O9 = { class: "tooltip-stat-row" }, I9 = { class: "tooltip-value" }, R9 = { class: "tooltip-stat-row" }, N9 = { class: "tooltip-value" }, F9 = { class: "tooltip-stat-row" }, B9 = { class: "tooltip-value" }, $9 = { class: "tooltip-stat-row" }, z9 = { class: "tooltip-value" }, V9 = {
  key: 2,
  class: "empty-state"
}, W_ = 400, qs = 60, U_ = 90, G_ = 120, H9 = {
  __name: "npsDailyMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: void 0
    },
    enableExport: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = i, r = (p) => {
      n("export", p);
    }, a = e, { isDark: s } = _e(ye(a, "theme")), o = q(() => a.data), l = gi(null), u = gi({
      visible: !1,
      x: 0,
      y: 0,
      date: "",
      min: "",
      max: "",
      q1: "",
      avg: "",
      q3: "",
      median: ""
    }), c = q(() => {
      if (!o.value || !o.value.nps_by_day) return 800;
      const p = o.value.nps_by_day.length;
      return Math.max(800, qs * 2 + p * G_);
    }), h = (p, g) => {
      const _ = (p - 1) / 9;
      return qs + g - _ * g;
    }, d = (p) => p ? H(p).format("DD-MM-YYYY") : "", f = q(() => {
      if (!o.value || !o.value.nps_by_day || o.value.nps_by_day.length === 0)
        return [];
      const p = [], g = W_ - qs - U_;
      return o.value.nps_by_day.forEach((y, _) => {
        const b = y.min_score || 0, w = y.q1_score || 0, S = y.median_score || 0, M = y.q3_score || 0, k = y.max_score || 0, T = y.average_score || 0;
        p.push({
          label: d(y.date),
          responseCount: y.nps_responses_count || 0,
          isTotal: !1,
          open: w,
          // Q1 as open
          high: k,
          // Max as high
          low: b,
          // Min as low
          close: M,
          // Q3 as close
          median: S,
          average: T,
          openY: h(w, g),
          highY: h(k, g),
          lowY: h(b, g),
          closeY: h(M, g),
          medianY: h(S, g),
          averageY: T > 0 ? h(T, g) : null,
          centerX: qs + (_ + 1) * G_
        });
      }), p;
    }), v = (p, g) => {
      if (!l.value || !g || g.horizontal) return;
      const y = l.value.getBoundingClientRect(), _ = p.clientX, b = p.clientY, w = 140, S = 160, M = 10, k = 15;
      let T = _ - y.left - w / 2, D = b - y.top - S - k;
      T = Math.max(M, Math.min(T, y.width - w - M)), D < M && (D = b - y.top + k), D = Math.max(M, Math.min(D, y.height - S - M)), u.value = {
        visible: !0,
        x: T,
        y: D,
        date: g.label || "",
        min: g.low !== void 0 ? g.low.toFixed(1) : "N/A",
        max: g.high !== void 0 ? g.high.toFixed(1) : "N/A",
        q1: g.open !== void 0 ? g.open.toFixed(1) : "N/A",
        avg: g.average !== void 0 && g.average > 0 ? g.average.toFixed(1) : "N/A",
        q3: g.close !== void 0 ? g.close.toFixed(1) : "N/A",
        median: g.median !== void 0 ? g.median.toFixed(1) : "N/A"
      };
    }, m = () => {
      u.value.visible = !1;
    };
    return t({ isDark: s }), (p, g) => (A(), I("article", _9, [
      x("header", b9, [
        x("div", x9, [
          g[1] || (g[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "NPS Daily Metrics"),
            x("p", { class: "card-subtitle" }, "Daily NPS Distribution")
          ], -1)),
          o.value && o.value.nps_by_day && o.value.nps_by_day.length > 0 ? (A(), I("div", w9, [
            g[0] || (g[0] = x("p", { class: "badge-label" }, "Days", -1)),
            x("p", S9, R(o.value.nps_by_day.length), 1)
          ])) : Q("", !0)
        ])
      ]),
      a.loading ? (A(), I("div", M9, [...g[2] || (g[2] = [
        Nt('<div class="loading-container" data-v-855dc52b><div class="chart-flow-loader" data-v-855dc52b><div class="flow-line flow-1" data-v-855dc52b></div><div class="flow-line flow-2" data-v-855dc52b></div><div class="flow-line flow-3" data-v-855dc52b></div><div class="flow-line flow-4" data-v-855dc52b></div><div class="flow-line flow-5" data-v-855dc52b></div></div><p class="loading-text" data-v-855dc52b>Loading daily NPS data...</p></div>', 1)
      ])])) : o.value && o.value.nps_by_day && o.value.nps_by_day.length > 0 ? (A(), I("div", k9, [
        x("div", {
          class: "chart-wrapper",
          ref_key: "chartContainerRef",
          ref: l
        }, [
          f.value && f.value.length > 0 ? (A(), Re(Zb, {
            key: 0,
            "candlestick-data": f.value,
            "chart-width": c.value,
            "chart-height": W_,
            "chart-margin": qs,
            "chart-bottom-margin": U_,
            "show-legend": !0,
            rotation: 0,
            "candle-width": 30,
            onCandleHover: v,
            onCandleLeave: m
          }, null, 8, ["candlestick-data", "chart-width"])) : Q("", !0),
          u.value.visible ? (A(), I("div", {
            key: 1,
            class: "tooltip-overlay",
            style: qr({
              left: `${u.value.x}px`,
              top: `${u.value.y}px`
            })
          }, [
            x("div", D9, [
              x("div", T9, R(u.value.date), 1),
              g[9] || (g[9] = x("div", { class: "tooltip-divider" }, null, -1)),
              x("div", C9, [
                x("div", E9, [
                  g[3] || (g[3] = x("span", { class: "tooltip-label tooltip-min" }, "Min:", -1)),
                  x("span", A9, R(u.value.min), 1)
                ]),
                x("div", P9, [
                  g[4] || (g[4] = x("span", { class: "tooltip-label tooltip-q1" }, "Q1:", -1)),
                  x("span", L9, R(u.value.q1), 1)
                ]),
                x("div", O9, [
                  g[5] || (g[5] = x("span", { class: "tooltip-label tooltip-median" }, "Median:", -1)),
                  x("span", I9, R(u.value.median), 1)
                ]),
                x("div", R9, [
                  g[6] || (g[6] = x("span", { class: "tooltip-label tooltip-avg" }, "Avg:", -1)),
                  x("span", N9, R(u.value.avg), 1)
                ]),
                x("div", F9, [
                  g[7] || (g[7] = x("span", { class: "tooltip-label tooltip-q3" }, "Q3:", -1)),
                  x("span", B9, R(u.value.q3), 1)
                ]),
                x("div", $9, [
                  g[8] || (g[8] = x("span", { class: "tooltip-label tooltip-max" }, "Max:", -1)),
                  x("span", z9, R(u.value.max), 1)
                ])
              ])
            ])
          ], 4)) : Q("", !0)
        ], 512),
        e.enableExport ? (A(), Re(X(ei), {
          key: 0,
          onExport: r
        })) : Q("", !0)
      ])) : (A(), I("div", V9, [...g[10] || (g[10] = [
        Nt('<div class="empty-state-content" data-v-855dc52b><div class="empty-icon-wrapper" data-v-855dc52b><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-855dc52b><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-855dc52b></path></svg></div><p class="empty-title" data-v-855dc52b>No daily NPS data available</p><p class="empty-description" data-v-855dc52b>No daily NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, t2 = /* @__PURE__ */ te(H9, [["__scopeId", "data-v-855dc52b"]]), Y9 = { class: "nps-overview-card" }, W9 = { class: "card-header" }, U9 = { class: "header-content" }, G9 = {
  key: 0,
  class: "stats-badge"
}, X9 = { class: "badge-value" }, j9 = {
  key: 0,
  class: "loading-state"
}, q9 = {
  key: 1,
  class: "card-body"
}, Z9 = { class: "chart-wrapper" }, K9 = {
  key: 2,
  class: "empty-state"
}, Q9 = 500, J9 = 60, t7 = 80, e7 = {
  __name: "npsOverviewMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    theme: {
      type: String,
      default: void 0
    },
    enableExport: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["export"],
  setup(e, { expose: t, emit: i }) {
    const n = i, r = (u) => {
      n("export", u);
    }, a = e, { isDark: s } = _e(ye(a, "theme")), o = q(() => a.data), l = q(() => Math.max(600, window.innerWidth * 0.85));
    return t({ isDark: s }), (u, c) => (A(), I("article", Y9, [
      x("header", W9, [
        x("div", U9, [
          c[1] || (c[1] = x("div", { class: "title-section" }, [
            x("h3", { class: "card-title" }, "NPS Overview Metrics"),
            x("p", { class: "card-subtitle" }, "Overall NPS Distribution")
          ], -1)),
          o.value && o.value.total_nps_responses > 0 ? (A(), I("div", G9, [
            c[0] || (c[0] = x("p", { class: "badge-label" }, "Responses", -1)),
            x("p", X9, R(o.value.total_nps_responses), 1)
          ])) : Q("", !0)
        ])
      ]),
      a.loading ? (A(), I("div", j9, [...c[2] || (c[2] = [
        Nt('<div class="loading-container" data-v-124fc3c9><div class="chart-flow-loader" data-v-124fc3c9><div class="flow-line flow-1" data-v-124fc3c9></div><div class="flow-line flow-2" data-v-124fc3c9></div><div class="flow-line flow-3" data-v-124fc3c9></div><div class="flow-line flow-4" data-v-124fc3c9></div><div class="flow-line flow-5" data-v-124fc3c9></div></div><p class="loading-text" data-v-124fc3c9>Loading NPS data...</p></div>', 1)
      ])])) : o.value && o.value.total_nps_responses > 0 ? (A(), I("div", q9, [
        x("div", Z9, [
          fe(Kb, {
            histogram: o.value.histogram || [],
            "min-score": o.value.min_score || 0,
            "max-score": o.value.max_score || 0,
            "q1-score": o.value.q1_score || 0,
            "median-score": o.value.median_score || 0,
            "q3-score": o.value.q3_score || 0,
            "average-score": o.value.average_score || 0,
            "chart-width": l.value,
            "chart-height": Q9,
            "chart-margin": J9,
            "chart-bottom-margin": t7
          }, null, 8, ["histogram", "min-score", "max-score", "q1-score", "median-score", "q3-score", "average-score", "chart-width"])
        ]),
        e.enableExport ? (A(), Re(X(ei), {
          key: 0,
          onExport: r
        })) : Q("", !0)
      ])) : (A(), I("div", K9, [...c[3] || (c[3] = [
        Nt('<div class="empty-state-content" data-v-124fc3c9><div class="empty-icon-wrapper" data-v-124fc3c9><svg class="empty-icon" fill="none" viewBox="0 0 24 24" stroke="currentColor" data-v-124fc3c9><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z" data-v-124fc3c9></path></svg></div><p class="empty-title" data-v-124fc3c9>No NPS data available</p><p class="empty-description" data-v-124fc3c9>No NPS data found for the selected period. Try adjusting the date range.</p></div>', 1)
      ])]))
    ]));
  }
}, e2 = /* @__PURE__ */ te(e7, [["__scopeId", "data-v-124fc3c9"]]), i7 = { class: "nps-metrics-container" }, n7 = {
  __name: "npsMetrics",
  props: {
    data: {
      type: Object,
      default: () => null
    },
    loading: {
      type: Boolean,
      default: !1
    },
    enableExport: {
      type: Boolean,
      default: !1
    }
  },
  emits: ["export"],
  setup(e, { emit: t }) {
    const i = t, n = (r) => {
      i("export", r);
    };
    return (r, a) => (A(), I("div", i7, [
      fe(e2, {
        data: e.data,
        loading: e.loading,
        "enable-export": e.enableExport,
        onExport: n
      }, null, 8, ["data", "loading", "enable-export"]),
      fe(t2, {
        data: e.data,
        loading: e.loading,
        "enable-export": e.enableExport,
        onExport: n
      }, null, 8, ["data", "loading", "enable-export"])
    ]));
  }
}, r7 = /* @__PURE__ */ te(n7, [["__scopeId", "data-v-25fe3b80"]]), h7 = {
  install(e) {
    e.component("KiutChartBar", jb), e.component("KiutChartLine", _v), e.component("KiutPieChart", qb), e.component("KiutBoxplotChart", tE), e.component("KiutCandlestickChart", Zb), e.component("KiutHistogramChart", Kb), e.component("KiutSankeyChart", pa), e.component("KiutAgentsPerDay", J4), e.component("KiutBookingManager", O8), e.component("KiutCheckin", nY), e.component("KiutCheckinMetrics", CY), e.component("KiutCheckinSegments", e6), e.component("KiutDisruption", F6), e.component("KiutFAQ", eW), e.component("KiutMessagesPerAgent", cW), e.component("KiutRecordLocator", RW), e.component("KiutSeller", u9), e.component("KiutTopAgents", y9), e.component("KiutNpsDailyMetrics", t2), e.component("KiutNpsMetrics", r7), e.component("KiutNpsOverviewMetrics", e2);
  }
};
export {
  J4 as AgentsPerDay,
  O8 as BookingManager,
  tE as BoxplotChart,
  Zb as CandlestickChart,
  jb as ChartBar,
  _v as ChartLine,
  nY as Checkin,
  CY as CheckinMetrics,
  e6 as CheckinSegments,
  F6 as Disruption,
  eW as FAQ,
  Kb as HistogramChart,
  h7 as KiutUIPlugin,
  cW as MessagesPerAgent,
  t2 as NpsDailyMetrics,
  r7 as NpsMetrics,
  e2 as NpsOverviewMetrics,
  qb as PieChart,
  RW as RecordLocator,
  pa as SankeyChart,
  u9 as Seller,
  y9 as TopAgents
};
//# sourceMappingURL=kiut-ui.es.js.map
